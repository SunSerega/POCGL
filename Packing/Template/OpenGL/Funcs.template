  
  
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  gl = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    
    // added in gl4.1
    private z_ActiveShaderProgram_adr := GetProcAddress('glActiveShaderProgram');
    private z_ActiveShaderProgram_1 := GetProcOrNil&<procedure(pipeline: gl_program_pipeline; &program: gl_program)>(z_ActiveShaderProgram_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ActiveShaderProgram(pipeline: gl_program_pipeline; &program: gl_program) :=
    z_ActiveShaderProgram_1(pipeline, &program);
    
    // added in gl1.3
    private z_ActiveTexture_adr := GetProcAddress('glActiveTexture');
    private z_ActiveTexture_1 := GetProcOrNil&<procedure(texture: TextureUnit)>(z_ActiveTexture_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ActiveTexture(texture: TextureUnit) :=
    z_ActiveTexture_1(texture);
    
    // added in gl2.0
    private z_AttachShader_adr := GetProcAddress('glAttachShader');
    private z_AttachShader_1 := GetProcOrNil&<procedure(&program: gl_program; shader: gl_shader)>(z_AttachShader_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AttachShader(&program: gl_program; shader: gl_shader) :=
    z_AttachShader_1(&program, shader);
    
    // added in gl3.0
    private z_BeginConditionalRender_adr := GetProcAddress('glBeginConditionalRender');
    private z_BeginConditionalRender_1 := GetProcOrNil&<procedure(id: UInt32; mode: ConditionalRenderMode)>(z_BeginConditionalRender_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginConditionalRender(id: UInt32; mode: ConditionalRenderMode) :=
    z_BeginConditionalRender_1(id, mode);
    
    // added in gl1.5
    private z_BeginQuery_adr := GetProcAddress('glBeginQuery');
    private z_BeginQuery_1 := GetProcOrNil&<procedure(target: QueryTarget; id: gl_query)>(z_BeginQuery_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginQuery(target: QueryTarget; id: gl_query) :=
    z_BeginQuery_1(target, id);
    
    // added in gl4.0
    private z_BeginQueryIndexed_adr := GetProcAddress('glBeginQueryIndexed');
    private z_BeginQueryIndexed_1 := GetProcOrNil&<procedure(target: QueryTarget; index: UInt32; id: gl_query)>(z_BeginQueryIndexed_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginQueryIndexed(target: QueryTarget; index: UInt32; id: gl_query) :=
    z_BeginQueryIndexed_1(target, index, id);
    
    // added in gl3.0
    private z_BeginTransformFeedback_adr := GetProcAddress('glBeginTransformFeedback');
    private z_BeginTransformFeedback_1 := GetProcOrNil&<procedure(primitiveMode: PrimitiveType)>(z_BeginTransformFeedback_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginTransformFeedback(primitiveMode: PrimitiveType) :=
    z_BeginTransformFeedback_1(primitiveMode);
    
    // added in gl2.0
    private z_BindAttribLocation_adr := GetProcAddress('glBindAttribLocation');
    private z_BindAttribLocation_1 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; name: IntPtr)>(z_BindAttribLocation_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindAttribLocation(&program: gl_program; index: UInt32; name: string);
    begin
      var name_str_ptr: IntPtr;
      try
        name_str_ptr := Marshal.StringToHGlobalAnsi(name);
        z_BindAttribLocation_1(&program, index, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindAttribLocation(&program: gl_program; index: UInt32; name: IntPtr) :=
    z_BindAttribLocation_1(&program, index, name);
    
    // added in gl1.5
    private z_BindBuffer_adr := GetProcAddress('glBindBuffer');
    private z_BindBuffer_1 := GetProcOrNil&<procedure(target: BufferTarget; buffer: gl_buffer)>(z_BindBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffer(target: BufferTarget; buffer: gl_buffer) :=
    z_BindBuffer_1(target, buffer);
    
    // added in gl3.0
    private z_BindBufferBase_adr := GetProcAddress('glBindBufferBase');
    private z_BindBufferBase_1 := GetProcOrNil&<procedure(target: BufferTarget; index: UInt32; buffer: gl_buffer)>(z_BindBufferBase_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBufferBase(target: BufferTarget; index: UInt32; buffer: gl_buffer) :=
    z_BindBufferBase_1(target, index, buffer);
    
    // added in gl3.0
    private z_BindBufferRange_adr := GetProcAddress('glBindBufferRange');
    private z_BindBufferRange_1 := GetProcOrNil&<procedure(target: BufferTarget; index: UInt32; buffer: gl_buffer; offset: IntPtr; size: UIntPtr)>(z_BindBufferRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBufferRange(target: BufferTarget; index: UInt32; buffer: gl_buffer; offset: IntPtr; size: UIntPtr) :=
    z_BindBufferRange_1(target, index, buffer, offset, size);
    
    // added in gl4.4
    private z_BindBuffersBase_adr := GetProcAddress('glBindBuffersBase');
    private z_BindBuffersBase_1 := GetProcOrNil&<procedure(target: BufferTarget; first: UInt32; count: Int32; buffers: IntPtr)>(z_BindBuffersBase_adr);
    private z_BindBuffersBase_2 := GetProcOrNil&<procedure(target: BufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer)>(z_BindBuffersBase_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersBase(target: BufferTarget; first: UInt32; count: Int32; buffers: array of gl_buffer);
    type Pgl_buffer=^gl_buffer;
    begin
      if (buffers<>nil) and (buffers.Length<>0) then
        z_BindBuffersBase_2(target, first, count, buffers[0]) else
        z_BindBuffersBase_2(target, first, count, Pgl_buffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersBase(target: BufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer) :=
    z_BindBuffersBase_2(target, first, count, buffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersBase(target: BufferTarget; first: UInt32; count: Int32; buffers: IntPtr) :=
    z_BindBuffersBase_1(target, first, count, buffers);
    
    // added in gl4.4
    private z_BindBuffersRange_adr := GetProcAddress('glBindBuffersRange');
    private z_BindBuffersRange_1 := GetProcOrNil&<procedure(target: BufferTarget; first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; sizes: IntPtr)>(z_BindBuffersRange_adr);
    private z_BindBuffersRange_2 := GetProcOrNil&<procedure(target: BufferTarget; first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; var sizes: UIntPtr)>(z_BindBuffersRange_adr);
    private z_BindBuffersRange_3 := GetProcOrNil&<procedure(target: BufferTarget; first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; sizes: IntPtr)>(z_BindBuffersRange_adr);
    private z_BindBuffersRange_4 := GetProcOrNil&<procedure(target: BufferTarget; first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; var sizes: UIntPtr)>(z_BindBuffersRange_adr);
    private z_BindBuffersRange_5 := GetProcOrNil&<procedure(target: BufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; sizes: IntPtr)>(z_BindBuffersRange_adr);
    private z_BindBuffersRange_6 := GetProcOrNil&<procedure(target: BufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; var sizes: UIntPtr)>(z_BindBuffersRange_adr);
    private z_BindBuffersRange_7 := GetProcOrNil&<procedure(target: BufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; sizes: IntPtr)>(z_BindBuffersRange_adr);
    private z_BindBuffersRange_8 := GetProcOrNil&<procedure(target: BufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; var sizes: UIntPtr)>(z_BindBuffersRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: BufferTarget; first: UInt32; count: Int32; buffers: array of gl_buffer; offsets: array of IntPtr; sizes: array of UIntPtr);
    type Pgl_buffer=^gl_buffer;
    type PIntPtr=^IntPtr;
    type PUIntPtr=^UIntPtr;
    begin
      if (sizes<>nil) and (sizes.Length<>0) then
        if (offsets<>nil) and (offsets.Length<>0) then
          if (buffers<>nil) and (buffers.Length<>0) then
            z_BindBuffersRange_8(target, first, count, buffers[0], offsets[0], sizes[0]) else
            z_BindBuffersRange_8(target, first, count, Pgl_buffer(nil)^, offsets[0], sizes[0]) else
          if (buffers<>nil) and (buffers.Length<>0) then
            z_BindBuffersRange_8(target, first, count, buffers[0], PIntPtr(nil)^, sizes[0]) else
            z_BindBuffersRange_8(target, first, count, Pgl_buffer(nil)^, PIntPtr(nil)^, sizes[0]) else
        if (offsets<>nil) and (offsets.Length<>0) then
          if (buffers<>nil) and (buffers.Length<>0) then
            z_BindBuffersRange_8(target, first, count, buffers[0], offsets[0], PUIntPtr(nil)^) else
            z_BindBuffersRange_8(target, first, count, Pgl_buffer(nil)^, offsets[0], PUIntPtr(nil)^) else
          if (buffers<>nil) and (buffers.Length<>0) then
            z_BindBuffersRange_8(target, first, count, buffers[0], PIntPtr(nil)^, PUIntPtr(nil)^) else
            z_BindBuffersRange_8(target, first, count, Pgl_buffer(nil)^, PIntPtr(nil)^, PUIntPtr(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: BufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; var sizes: UIntPtr) :=
    z_BindBuffersRange_8(target, first, count, buffers, offsets, sizes);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: BufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; sizes: IntPtr) :=
    z_BindBuffersRange_7(target, first, count, buffers, offsets, sizes);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: BufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; var sizes: UIntPtr) :=
    z_BindBuffersRange_6(target, first, count, buffers, offsets, sizes);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: BufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; sizes: IntPtr) :=
    z_BindBuffersRange_5(target, first, count, buffers, offsets, sizes);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: BufferTarget; first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; var sizes: UIntPtr) :=
    z_BindBuffersRange_4(target, first, count, buffers, offsets, sizes);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: BufferTarget; first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; sizes: IntPtr) :=
    z_BindBuffersRange_3(target, first, count, buffers, offsets, sizes);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: BufferTarget; first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; var sizes: UIntPtr) :=
    z_BindBuffersRange_2(target, first, count, buffers, offsets, sizes);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: BufferTarget; first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; sizes: IntPtr) :=
    z_BindBuffersRange_1(target, first, count, buffers, offsets, sizes);
    
    // added in gl3.0
    private z_BindFragDataLocation_adr := GetProcAddress('glBindFragDataLocation');
    private z_BindFragDataLocation_1 := GetProcOrNil&<procedure(&program: gl_program; color: UInt32; name: IntPtr)>(z_BindFragDataLocation_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindFragDataLocation(&program: gl_program; color: UInt32; name: string);
    begin
      var name_str_ptr: IntPtr;
      try
        name_str_ptr := Marshal.StringToHGlobalAnsi(name);
        z_BindFragDataLocation_1(&program, color, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindFragDataLocation(&program: gl_program; color: UInt32; name: IntPtr) :=
    z_BindFragDataLocation_1(&program, color, name);
    
    // added in gl3.3
    private z_BindFragDataLocationIndexed_adr := GetProcAddress('glBindFragDataLocationIndexed');
    private z_BindFragDataLocationIndexed_1 := GetProcOrNil&<procedure(&program: gl_program; colorNumber: UInt32; index: UInt32; name: IntPtr)>(z_BindFragDataLocationIndexed_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindFragDataLocationIndexed(&program: gl_program; colorNumber: UInt32; index: UInt32; name: string);
    begin
      var name_str_ptr: IntPtr;
      try
        name_str_ptr := Marshal.StringToHGlobalAnsi(name);
        z_BindFragDataLocationIndexed_1(&program, colorNumber, index, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindFragDataLocationIndexed(&program: gl_program; colorNumber: UInt32; index: UInt32; name: IntPtr) :=
    z_BindFragDataLocationIndexed_1(&program, colorNumber, index, name);
    
    // added in gl3.0
    private z_BindFramebuffer_adr := GetProcAddress('glBindFramebuffer');
    private z_BindFramebuffer_1 := GetProcOrNil&<procedure(target: FramebufferTarget; framebuffer: gl_framebuffer)>(z_BindFramebuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindFramebuffer(target: FramebufferTarget; framebuffer: gl_framebuffer) :=
    z_BindFramebuffer_1(target, framebuffer);
    
    // added in gl4.2
    private z_BindImageTexture_adr := GetProcAddress('glBindImageTexture');
    private z_BindImageTexture_1 := GetProcOrNil&<procedure(&unit: UInt32; texture: gl_texture; level: Int32; layered: boolean; layer: Int32; access: BufferAccess; format: InternalFormat)>(z_BindImageTexture_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindImageTexture(&unit: UInt32; texture: gl_texture; level: Int32; layered: boolean; layer: Int32; access: BufferAccess; format: InternalFormat) :=
    z_BindImageTexture_1(&unit, texture, level, layered, layer, access, format);
    
    // added in gl4.4
    private z_BindImageTextures_adr := GetProcAddress('glBindImageTextures');
    private z_BindImageTextures_1 := GetProcOrNil&<procedure(first: UInt32; count: Int32; textures: IntPtr)>(z_BindImageTextures_adr);
    private z_BindImageTextures_2 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var textures: gl_texture)>(z_BindImageTextures_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindImageTextures(first: UInt32; count: Int32; textures: array of gl_texture);
    type Pgl_texture=^gl_texture;
    begin
      if (textures<>nil) and (textures.Length<>0) then
        z_BindImageTextures_2(first, count, textures[0]) else
        z_BindImageTextures_2(first, count, Pgl_texture(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindImageTextures(first: UInt32; count: Int32; var textures: gl_texture) :=
    z_BindImageTextures_2(first, count, textures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindImageTextures(first: UInt32; count: Int32; textures: IntPtr) :=
    z_BindImageTextures_1(first, count, textures);
    
    // added in gl4.1
    private z_BindProgramPipeline_adr := GetProcAddress('glBindProgramPipeline');
    private z_BindProgramPipeline_1 := GetProcOrNil&<procedure(pipeline: gl_program_pipeline)>(z_BindProgramPipeline_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindProgramPipeline(pipeline: gl_program_pipeline) :=
    z_BindProgramPipeline_1(pipeline);
    
    // added in gl3.0
    private z_BindRenderbuffer_adr := GetProcAddress('glBindRenderbuffer');
    private z_BindRenderbuffer_1 := GetProcOrNil&<procedure(target: RenderbufferTarget; renderbuffer: gl_renderbuffer)>(z_BindRenderbuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindRenderbuffer(target: RenderbufferTarget; renderbuffer: gl_renderbuffer) :=
    z_BindRenderbuffer_1(target, renderbuffer);
    
    // added in gl3.3
    private z_BindSampler_adr := GetProcAddress('glBindSampler');
    private z_BindSampler_1 := GetProcOrNil&<procedure(&unit: UInt32; sampler: gl_sampler)>(z_BindSampler_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindSampler(&unit: UInt32; sampler: gl_sampler) :=
    z_BindSampler_1(&unit, sampler);
    
    // added in gl4.4
    private z_BindSamplers_adr := GetProcAddress('glBindSamplers');
    private z_BindSamplers_1 := GetProcOrNil&<procedure(first: UInt32; count: Int32; samplers: IntPtr)>(z_BindSamplers_adr);
    private z_BindSamplers_2 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var samplers: gl_sampler)>(z_BindSamplers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindSamplers(first: UInt32; count: Int32; samplers: array of gl_sampler);
    type Pgl_sampler=^gl_sampler;
    begin
      if (samplers<>nil) and (samplers.Length<>0) then
        z_BindSamplers_2(first, count, samplers[0]) else
        z_BindSamplers_2(first, count, Pgl_sampler(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindSamplers(first: UInt32; count: Int32; var samplers: gl_sampler) :=
    z_BindSamplers_2(first, count, samplers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindSamplers(first: UInt32; count: Int32; samplers: IntPtr) :=
    z_BindSamplers_1(first, count, samplers);
    
    // added in gl1.1
    private z_BindTexture_adr := GetProcAddress('glBindTexture');
    private z_BindTexture_1 := GetProcOrNil&<procedure(target: TextureTarget; texture: gl_texture)>(z_BindTexture_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTexture(target: TextureTarget; texture: gl_texture) :=
    z_BindTexture_1(target, texture);
    
    // added in gl4.4
    private z_BindTextures_adr := GetProcAddress('glBindTextures');
    private z_BindTextures_1 := GetProcOrNil&<procedure(first: UInt32; count: Int32; textures: IntPtr)>(z_BindTextures_adr);
    private z_BindTextures_2 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var textures: gl_texture)>(z_BindTextures_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTextures(first: UInt32; count: Int32; textures: array of gl_texture);
    type Pgl_texture=^gl_texture;
    begin
      if (textures<>nil) and (textures.Length<>0) then
        z_BindTextures_2(first, count, textures[0]) else
        z_BindTextures_2(first, count, Pgl_texture(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTextures(first: UInt32; count: Int32; var textures: gl_texture) :=
    z_BindTextures_2(first, count, textures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTextures(first: UInt32; count: Int32; textures: IntPtr) :=
    z_BindTextures_1(first, count, textures);
    
    // added in gl4.5
    private z_BindTextureUnit_adr := GetProcAddress('glBindTextureUnit');
    private z_BindTextureUnit_1 := GetProcOrNil&<procedure(&unit: UInt32; texture: gl_texture)>(z_BindTextureUnit_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTextureUnit(&unit: UInt32; texture: gl_texture) :=
    z_BindTextureUnit_1(&unit, texture);
    
    // added in gl4.0
    private z_BindTransformFeedback_adr := GetProcAddress('glBindTransformFeedback');
    private z_BindTransformFeedback_1 := GetProcOrNil&<procedure(target: BindTransformFeedbackTarget; id: gl_transform_feedback)>(z_BindTransformFeedback_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTransformFeedback(target: BindTransformFeedbackTarget; id: gl_transform_feedback) :=
    z_BindTransformFeedback_1(target, id);
    
    // added in gl3.0
    private z_BindVertexArray_adr := GetProcAddress('glBindVertexArray');
    private z_BindVertexArray_1 := GetProcOrNil&<procedure(&array: gl_vertex_array)>(z_BindVertexArray_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexArray(&array: gl_vertex_array) :=
    z_BindVertexArray_1(&array);
    
    // added in gl4.3
    private z_BindVertexBuffer_adr := GetProcAddress('glBindVertexBuffer');
    private z_BindVertexBuffer_1 := GetProcOrNil&<procedure(bindingindex: UInt32; buffer: gl_buffer; offset: IntPtr; stride: Int32)>(z_BindVertexBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffer(bindingindex: UInt32; buffer: gl_buffer; offset: IntPtr; stride: Int32) :=
    z_BindVertexBuffer_1(bindingindex, buffer, offset, stride);
    
    // added in gl4.4
    private z_BindVertexBuffers_adr := GetProcAddress('glBindVertexBuffers');
    private z_BindVertexBuffers_1 := GetProcOrNil&<procedure(first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; strides: IntPtr)>(z_BindVertexBuffers_adr);
    private z_BindVertexBuffers_2 := GetProcOrNil&<procedure(first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; var strides: Int32)>(z_BindVertexBuffers_adr);
    private z_BindVertexBuffers_3 := GetProcOrNil&<procedure(first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; strides: IntPtr)>(z_BindVertexBuffers_adr);
    private z_BindVertexBuffers_4 := GetProcOrNil&<procedure(first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; var strides: Int32)>(z_BindVertexBuffers_adr);
    private z_BindVertexBuffers_5 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; strides: IntPtr)>(z_BindVertexBuffers_adr);
    private z_BindVertexBuffers_6 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; var strides: Int32)>(z_BindVertexBuffers_adr);
    private z_BindVertexBuffers_7 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; strides: IntPtr)>(z_BindVertexBuffers_adr);
    private z_BindVertexBuffers_8 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; var strides: Int32)>(z_BindVertexBuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; buffers: array of gl_buffer; offsets: array of IntPtr; strides: array of Int32);
    type Pgl_buffer=^gl_buffer;
    type PIntPtr=^IntPtr;
    type PInt32=^Int32;
    begin
      if (strides<>nil) and (strides.Length<>0) then
        if (offsets<>nil) and (offsets.Length<>0) then
          if (buffers<>nil) and (buffers.Length<>0) then
            z_BindVertexBuffers_8(first, count, buffers[0], offsets[0], strides[0]) else
            z_BindVertexBuffers_8(first, count, Pgl_buffer(nil)^, offsets[0], strides[0]) else
          if (buffers<>nil) and (buffers.Length<>0) then
            z_BindVertexBuffers_8(first, count, buffers[0], PIntPtr(nil)^, strides[0]) else
            z_BindVertexBuffers_8(first, count, Pgl_buffer(nil)^, PIntPtr(nil)^, strides[0]) else
        if (offsets<>nil) and (offsets.Length<>0) then
          if (buffers<>nil) and (buffers.Length<>0) then
            z_BindVertexBuffers_8(first, count, buffers[0], offsets[0], PInt32(nil)^) else
            z_BindVertexBuffers_8(first, count, Pgl_buffer(nil)^, offsets[0], PInt32(nil)^) else
          if (buffers<>nil) and (buffers.Length<>0) then
            z_BindVertexBuffers_8(first, count, buffers[0], PIntPtr(nil)^, PInt32(nil)^) else
            z_BindVertexBuffers_8(first, count, Pgl_buffer(nil)^, PIntPtr(nil)^, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; var strides: Int32) :=
    z_BindVertexBuffers_8(first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; strides: IntPtr) :=
    z_BindVertexBuffers_7(first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; var strides: Int32) :=
    z_BindVertexBuffers_6(first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; strides: IntPtr) :=
    z_BindVertexBuffers_5(first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; var strides: Int32) :=
    z_BindVertexBuffers_4(first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; strides: IntPtr) :=
    z_BindVertexBuffers_3(first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; var strides: Int32) :=
    z_BindVertexBuffers_2(first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; strides: IntPtr) :=
    z_BindVertexBuffers_1(first, count, buffers, offsets, strides);
    
    // added in gl1.4
    private z_BlendColor_adr := GetProcAddress('glBlendColor');
    private z_BlendColor_1 := GetProcOrNil&<procedure(red: single; green: single; blue: single; alpha: single)>(z_BlendColor_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendColor(red: single; green: single; blue: single; alpha: single) :=
    z_BlendColor_1(red, green, blue, alpha);
    
    // added in gl1.4
    private z_BlendEquation_adr := GetProcAddress('glBlendEquation');
    private z_BlendEquation_1 := GetProcOrNil&<procedure(mode: BlendEquationMode)>(z_BlendEquation_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquation(mode: BlendEquationMode) :=
    z_BlendEquation_1(mode);
    
    // added in gl4.0
    private z_BlendEquationi_adr := GetProcAddress('glBlendEquationi');
    private z_BlendEquationi_1 := GetProcOrNil&<procedure(buf: UInt32; mode: BlendEquationMode)>(z_BlendEquationi_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquationi(buf: UInt32; mode: BlendEquationMode) :=
    z_BlendEquationi_1(buf, mode);
    
    // added in gl2.0
    private z_BlendEquationSeparate_adr := GetProcAddress('glBlendEquationSeparate');
    private z_BlendEquationSeparate_1 := GetProcOrNil&<procedure(modeRGB: BlendEquationMode; modeAlpha: BlendEquationMode)>(z_BlendEquationSeparate_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquationSeparate(modeRGB: BlendEquationMode; modeAlpha: BlendEquationMode) :=
    z_BlendEquationSeparate_1(modeRGB, modeAlpha);
    
    // added in gl4.0
    private z_BlendEquationSeparatei_adr := GetProcAddress('glBlendEquationSeparatei');
    private z_BlendEquationSeparatei_1 := GetProcOrNil&<procedure(buf: UInt32; modeRGB: BlendEquationMode; modeAlpha: BlendEquationMode)>(z_BlendEquationSeparatei_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquationSeparatei(buf: UInt32; modeRGB: BlendEquationMode; modeAlpha: BlendEquationMode) :=
    z_BlendEquationSeparatei_1(buf, modeRGB, modeAlpha);
    
    // added in gl1.0
    private z_BlendFunc_adr := GetProcAddress('glBlendFunc');
    private z_BlendFunc_1 := GetProcOrNil&<procedure(sfactor: BlendingFactor; dfactor: BlendingFactor)>(z_BlendFunc_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendFunc(sfactor: BlendingFactor; dfactor: BlendingFactor) :=
    z_BlendFunc_1(sfactor, dfactor);
    
    // added in gl4.0
    private z_BlendFunci_adr := GetProcAddress('glBlendFunci');
    private z_BlendFunci_1 := GetProcOrNil&<procedure(buf: UInt32; src: BlendingFactor; dst: BlendingFactor)>(z_BlendFunci_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendFunci(buf: UInt32; src: BlendingFactor; dst: BlendingFactor) :=
    z_BlendFunci_1(buf, src, dst);
    
    // added in gl1.4
    private z_BlendFuncSeparate_adr := GetProcAddress('glBlendFuncSeparate');
    private z_BlendFuncSeparate_1 := GetProcOrNil&<procedure(sfactorRGB: BlendingFactor; dfactorRGB: BlendingFactor; sfactorAlpha: BlendingFactor; dfactorAlpha: BlendingFactor)>(z_BlendFuncSeparate_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendFuncSeparate(sfactorRGB: BlendingFactor; dfactorRGB: BlendingFactor; sfactorAlpha: BlendingFactor; dfactorAlpha: BlendingFactor) :=
    z_BlendFuncSeparate_1(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
    
    // added in gl4.0
    private z_BlendFuncSeparatei_adr := GetProcAddress('glBlendFuncSeparatei');
    private z_BlendFuncSeparatei_1 := GetProcOrNil&<procedure(buf: UInt32; srcRGB: BlendingFactor; dstRGB: BlendingFactor; srcAlpha: BlendingFactor; dstAlpha: BlendingFactor)>(z_BlendFuncSeparatei_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendFuncSeparatei(buf: UInt32; srcRGB: BlendingFactor; dstRGB: BlendingFactor; srcAlpha: BlendingFactor; dstAlpha: BlendingFactor) :=
    z_BlendFuncSeparatei_1(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
    
    // added in gl3.0
    private z_BlitFramebuffer_adr := GetProcAddress('glBlitFramebuffer');
    private z_BlitFramebuffer_1 := GetProcOrNil&<procedure(srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: ClearBufferMask; filter: BlitFramebufferFilter)>(z_BlitFramebuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlitFramebuffer(srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: ClearBufferMask; filter: BlitFramebufferFilter) :=
    z_BlitFramebuffer_1(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    
    // added in gl4.5
    private z_BlitNamedFramebuffer_adr := GetProcAddress('glBlitNamedFramebuffer');
    private z_BlitNamedFramebuffer_1 := GetProcOrNil&<procedure(readFramebuffer: gl_framebuffer; drawFramebuffer: gl_framebuffer; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: ClearBufferMask; filter: BlitFramebufferFilter)>(z_BlitNamedFramebuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlitNamedFramebuffer(readFramebuffer: gl_framebuffer; drawFramebuffer: gl_framebuffer; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: ClearBufferMask; filter: BlitFramebufferFilter) :=
    z_BlitNamedFramebuffer_1(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    
    // added in gl1.5
    private z_BufferData_adr := GetProcAddress('glBufferData');
    private z_BufferData_1 := GetProcOrNil&<procedure(target: BufferTarget; size: UIntPtr; data: pointer; usage: BufferUsage)>(z_BufferData_adr);
    private z_BufferData_2 := GetProcOrNil&<procedure(target: BufferTarget; size: UIntPtr; var data: Byte; usage: BufferUsage)>(z_BufferData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferData<T>(target: BufferTarget; size: UIntPtr; data: array of T; usage: BufferUsage); where T: record;
    type PT=^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        BufferData(target, size, data[0], usage) else
        BufferData(target, size, PT(nil)^, usage);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferData<T>(target: BufferTarget; size: UIntPtr; var data: T; usage: BufferUsage); where T: record;
    begin
      z_BufferData_2(target, size, PByte(pointer(@data))^, usage);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferData(target: BufferTarget; size: UIntPtr; data: pointer; usage: BufferUsage) :=
    z_BufferData_1(target, size, data, usage);
    
    // added in gl4.4
    private z_BufferStorage_adr := GetProcAddress('glBufferStorage');
    private z_BufferStorage_1 := GetProcOrNil&<procedure(target: BufferStorageTarget; size: UIntPtr; data: pointer; flags: BufferStorageMask)>(z_BufferStorage_adr);
    private z_BufferStorage_2 := GetProcOrNil&<procedure(target: BufferStorageTarget; size: UIntPtr; var data: Byte; flags: BufferStorageMask)>(z_BufferStorage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferStorage<T>(target: BufferStorageTarget; size: UIntPtr; data: array of T; flags: BufferStorageMask); where T: record;
    type PT=^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        BufferStorage(target, size, data[0], flags) else
        BufferStorage(target, size, PT(nil)^, flags);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferStorage<T>(target: BufferStorageTarget; size: UIntPtr; var data: T; flags: BufferStorageMask); where T: record;
    begin
      z_BufferStorage_2(target, size, PByte(pointer(@data))^, flags);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferStorage(target: BufferStorageTarget; size: UIntPtr; data: pointer; flags: BufferStorageMask) :=
    z_BufferStorage_1(target, size, data, flags);
    
    // added in gl1.5
    private z_BufferSubData_adr := GetProcAddress('glBufferSubData');
    private z_BufferSubData_1 := GetProcOrNil&<procedure(target: BufferTarget; offset: IntPtr; size: UIntPtr; data: pointer)>(z_BufferSubData_adr);
    private z_BufferSubData_2 := GetProcOrNil&<procedure(target: BufferTarget; offset: IntPtr; size: UIntPtr; var data: Byte)>(z_BufferSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferSubData<T>(target: BufferTarget; offset: IntPtr; size: UIntPtr; data: array of T); where T: record;
    type PT=^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        BufferSubData(target, offset, size, data[0]) else
        BufferSubData(target, offset, size, PT(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferSubData<T>(target: BufferTarget; offset: IntPtr; size: UIntPtr; var data: T); where T: record;
    begin
      z_BufferSubData_2(target, offset, size, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferSubData(target: BufferTarget; offset: IntPtr; size: UIntPtr; data: pointer) :=
    z_BufferSubData_1(target, offset, size, data);
    
    // added in gl3.0
    private z_CheckFramebufferStatus_adr := GetProcAddress('glCheckFramebufferStatus');
    private z_CheckFramebufferStatus_1 := GetProcOrNil&<function(target: FramebufferTarget): FramebufferStatus>(z_CheckFramebufferStatus_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CheckFramebufferStatus(target: FramebufferTarget): FramebufferStatus :=
    z_CheckFramebufferStatus_1(target);
    
    // added in gl4.5
    private z_CheckNamedFramebufferStatus_adr := GetProcAddress('glCheckNamedFramebufferStatus');
    private z_CheckNamedFramebufferStatus_1 := GetProcOrNil&<function(framebuffer: gl_framebuffer; target: FramebufferTarget): FramebufferStatus>(z_CheckNamedFramebufferStatus_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CheckNamedFramebufferStatus(framebuffer: gl_framebuffer; target: FramebufferTarget): FramebufferStatus :=
    z_CheckNamedFramebufferStatus_1(framebuffer, target);
    
    // added in gl3.0
    private z_ClampColor_adr := GetProcAddress('glClampColor');
    private z_ClampColor_1 := GetProcOrNil&<procedure(target: ClampColorTarget; clamp: ClampColorMode)>(z_ClampColor_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClampColor(target: ClampColorTarget; clamp: ClampColorMode) :=
    z_ClampColor_1(target, clamp);
    
    // added in gl1.0
    private z_Clear_adr := GetProcAddress('glClear');
    private z_Clear_1 := GetProcOrNil&<procedure(mask: ClearBufferMask)>(z_Clear_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Clear(mask: ClearBufferMask) :=
    z_Clear_1(mask);
    
    // added in gl4.3
    private z_ClearBufferData_adr := GetProcAddress('glClearBufferData');
    private z_ClearBufferData_1 := GetProcOrNil&<procedure(target: BufferStorageTarget; internalformat: SizedInternalFormat; format: PixelFormat; &type: PixelType; data: pointer)>(z_ClearBufferData_adr);
    private z_ClearBufferData_2 := GetProcOrNil&<procedure(target: BufferStorageTarget; internalformat: SizedInternalFormat; format: PixelFormat; &type: PixelType; var data: Byte)>(z_ClearBufferData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferData<T>(target: BufferStorageTarget; internalformat: SizedInternalFormat; format: PixelFormat; &type: PixelType; data: array of T); where T: record;
    type PT=^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        ClearBufferData(target, internalformat, format, &type, data[0]) else
        ClearBufferData(target, internalformat, format, &type, PT(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferData<T>(target: BufferStorageTarget; internalformat: SizedInternalFormat; format: PixelFormat; &type: PixelType; var data: T); where T: record;
    begin
      z_ClearBufferData_2(target, internalformat, format, &type, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferData(target: BufferStorageTarget; internalformat: SizedInternalFormat; format: PixelFormat; &type: PixelType; data: pointer) :=
    z_ClearBufferData_1(target, internalformat, format, &type, data);
    
    // added in gl3.0
    private z_ClearBufferfi_adr := GetProcAddress('glClearBufferfi');
    private z_ClearBufferfi_1 := GetProcOrNil&<procedure(_buffer: Buffer; drawbuffer: Int32; depth: single; stencil: Int32)>(z_ClearBufferfi_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferfi(_buffer: Buffer; drawbuffer: Int32; depth: single; stencil: Int32) :=
    z_ClearBufferfi_1(_buffer, drawbuffer, depth, stencil);
    
    // added in gl3.0
    private z_ClearBufferfv_adr := GetProcAddress('glClearBufferfv');
    private z_ClearBufferfv_1 := GetProcOrNil&<procedure(_buffer: Buffer; drawbuffer: Int32; value: IntPtr)>(z_ClearBufferfv_adr);
    private z_ClearBufferfv_2 := GetProcOrNil&<procedure(_buffer: Buffer; drawbuffer: Int32; var value: single)>(z_ClearBufferfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferfv(_buffer: Buffer; drawbuffer: Int32; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ClearBufferfv_2(_buffer, drawbuffer, value[0]) else
        z_ClearBufferfv_2(_buffer, drawbuffer, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferfv(_buffer: Buffer; drawbuffer: Int32; var value: single) :=
    z_ClearBufferfv_2(_buffer, drawbuffer, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferfv(_buffer: Buffer; drawbuffer: Int32; value: IntPtr) :=
    z_ClearBufferfv_1(_buffer, drawbuffer, value);
    
    // added in gl3.0
    private z_ClearBufferiv_adr := GetProcAddress('glClearBufferiv');
    private z_ClearBufferiv_1 := GetProcOrNil&<procedure(_buffer: Buffer; drawbuffer: Int32; value: IntPtr)>(z_ClearBufferiv_adr);
    private z_ClearBufferiv_2 := GetProcOrNil&<procedure(_buffer: Buffer; drawbuffer: Int32; var value: Int32)>(z_ClearBufferiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferiv(_buffer: Buffer; drawbuffer: Int32; value: array of Int32);
    type PInt32=^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ClearBufferiv_2(_buffer, drawbuffer, value[0]) else
        z_ClearBufferiv_2(_buffer, drawbuffer, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferiv(_buffer: Buffer; drawbuffer: Int32; var value: Int32) :=
    z_ClearBufferiv_2(_buffer, drawbuffer, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferiv(_buffer: Buffer; drawbuffer: Int32; value: IntPtr) :=
    z_ClearBufferiv_1(_buffer, drawbuffer, value);
    
    // added in gl4.3
    private z_ClearBufferSubData_adr := GetProcAddress('glClearBufferSubData');
    private z_ClearBufferSubData_1 := GetProcOrNil&<procedure(target: BufferTarget; internalformat: SizedInternalFormat; offset: IntPtr; size: UIntPtr; format: PixelFormat; &type: PixelType; data: pointer)>(z_ClearBufferSubData_adr);
    private z_ClearBufferSubData_2 := GetProcOrNil&<procedure(target: BufferTarget; internalformat: SizedInternalFormat; offset: IntPtr; size: UIntPtr; format: PixelFormat; &type: PixelType; var data: Byte)>(z_ClearBufferSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferSubData<T>(target: BufferTarget; internalformat: SizedInternalFormat; offset: IntPtr; size: UIntPtr; format: PixelFormat; &type: PixelType; data: array of T); where T: record;
    type PT=^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        ClearBufferSubData(target, internalformat, offset, size, format, &type, data[0]) else
        ClearBufferSubData(target, internalformat, offset, size, format, &type, PT(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferSubData<T>(target: BufferTarget; internalformat: SizedInternalFormat; offset: IntPtr; size: UIntPtr; format: PixelFormat; &type: PixelType; var data: T); where T: record;
    begin
      z_ClearBufferSubData_2(target, internalformat, offset, size, format, &type, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferSubData(target: BufferTarget; internalformat: SizedInternalFormat; offset: IntPtr; size: UIntPtr; format: PixelFormat; &type: PixelType; data: pointer) :=
    z_ClearBufferSubData_1(target, internalformat, offset, size, format, &type, data);
    
    // added in gl3.0
    private z_ClearBufferuiv_adr := GetProcAddress('glClearBufferuiv');
    private z_ClearBufferuiv_1 := GetProcOrNil&<procedure(_buffer: Buffer; drawbuffer: Int32; value: IntPtr)>(z_ClearBufferuiv_adr);
    private z_ClearBufferuiv_2 := GetProcOrNil&<procedure(_buffer: Buffer; drawbuffer: Int32; var value: UInt32)>(z_ClearBufferuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferuiv(_buffer: Buffer; drawbuffer: Int32; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ClearBufferuiv_2(_buffer, drawbuffer, value[0]) else
        z_ClearBufferuiv_2(_buffer, drawbuffer, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferuiv(_buffer: Buffer; drawbuffer: Int32; var value: UInt32) :=
    z_ClearBufferuiv_2(_buffer, drawbuffer, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferuiv(_buffer: Buffer; drawbuffer: Int32; value: IntPtr) :=
    z_ClearBufferuiv_1(_buffer, drawbuffer, value);
    
    // added in gl1.0
    private z_ClearColor_adr := GetProcAddress('glClearColor');
    private z_ClearColor_1 := GetProcOrNil&<procedure(red: single; green: single; blue: single; alpha: single)>(z_ClearColor_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearColor(red: single; green: single; blue: single; alpha: single) :=
    z_ClearColor_1(red, green, blue, alpha);
    
    // added in gl1.0
    private z_ClearDepth_adr := GetProcAddress('glClearDepth');
    private z_ClearDepth_1 := GetProcOrNil&<procedure(depth: real)>(z_ClearDepth_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearDepth(depth: real) :=
    z_ClearDepth_1(depth);
    
    // added in gl4.1
    private z_ClearDepthf_adr := GetProcAddress('glClearDepthf');
    private z_ClearDepthf_1 := GetProcOrNil&<procedure(d: single)>(z_ClearDepthf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearDepthf(d: single) :=
    z_ClearDepthf_1(d);
    
    // added in gl4.5
    private z_ClearNamedBufferData_adr := GetProcAddress('glClearNamedBufferData');
    private z_ClearNamedBufferData_1 := GetProcOrNil&<procedure(buffer: gl_buffer; internalformat: SizedInternalFormat; format: PixelFormat; &type: PixelType; data: pointer)>(z_ClearNamedBufferData_adr);
    private z_ClearNamedBufferData_2 := GetProcOrNil&<procedure(buffer: gl_buffer; internalformat: SizedInternalFormat; format: PixelFormat; &type: PixelType; var data: Byte)>(z_ClearNamedBufferData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferData<T>(buffer: gl_buffer; internalformat: SizedInternalFormat; format: PixelFormat; &type: PixelType; data: array of T); where T: record;
    type PT=^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        ClearNamedBufferData(buffer, internalformat, format, &type, data[0]) else
        ClearNamedBufferData(buffer, internalformat, format, &type, PT(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferData<T>(buffer: gl_buffer; internalformat: SizedInternalFormat; format: PixelFormat; &type: PixelType; var data: T); where T: record;
    begin
      z_ClearNamedBufferData_2(buffer, internalformat, format, &type, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferData(buffer: gl_buffer; internalformat: SizedInternalFormat; format: PixelFormat; &type: PixelType; data: pointer) :=
    z_ClearNamedBufferData_1(buffer, internalformat, format, &type, data);
    
    // added in gl4.5
    private z_ClearNamedBufferSubData_adr := GetProcAddress('glClearNamedBufferSubData');
    private z_ClearNamedBufferSubData_1 := GetProcOrNil&<procedure(buffer: gl_buffer; internalformat: SizedInternalFormat; offset: IntPtr; size: UIntPtr; format: PixelFormat; &type: PixelType; data: pointer)>(z_ClearNamedBufferSubData_adr);
    private z_ClearNamedBufferSubData_2 := GetProcOrNil&<procedure(buffer: gl_buffer; internalformat: SizedInternalFormat; offset: IntPtr; size: UIntPtr; format: PixelFormat; &type: PixelType; var data: Byte)>(z_ClearNamedBufferSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferSubData<T>(buffer: gl_buffer; internalformat: SizedInternalFormat; offset: IntPtr; size: UIntPtr; format: PixelFormat; &type: PixelType; data: array of T); where T: record;
    type PT=^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        ClearNamedBufferSubData(buffer, internalformat, offset, size, format, &type, data[0]) else
        ClearNamedBufferSubData(buffer, internalformat, offset, size, format, &type, PT(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferSubData<T>(buffer: gl_buffer; internalformat: SizedInternalFormat; offset: IntPtr; size: UIntPtr; format: PixelFormat; &type: PixelType; var data: T); where T: record;
    begin
      z_ClearNamedBufferSubData_2(buffer, internalformat, offset, size, format, &type, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferSubData(buffer: gl_buffer; internalformat: SizedInternalFormat; offset: IntPtr; size: UIntPtr; format: PixelFormat; &type: PixelType; data: pointer) :=
    z_ClearNamedBufferSubData_1(buffer, internalformat, offset, size, format, &type, data);
    
    // added in gl4.5
    private z_ClearNamedFramebufferfi_adr := GetProcAddress('glClearNamedFramebufferfi');
    private z_ClearNamedFramebufferfi_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; _buffer: Buffer; drawbuffer: Int32; depth: single; stencil: Int32)>(z_ClearNamedFramebufferfi_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferfi(framebuffer: gl_framebuffer; _buffer: Buffer; drawbuffer: Int32; depth: single; stencil: Int32) :=
    z_ClearNamedFramebufferfi_1(framebuffer, _buffer, drawbuffer, depth, stencil);
    
    // added in gl4.5
    private z_ClearNamedFramebufferfv_adr := GetProcAddress('glClearNamedFramebufferfv');
    private z_ClearNamedFramebufferfv_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; _buffer: Buffer; drawbuffer: Int32; value: IntPtr)>(z_ClearNamedFramebufferfv_adr);
    private z_ClearNamedFramebufferfv_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; _buffer: Buffer; drawbuffer: Int32; var value: single)>(z_ClearNamedFramebufferfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferfv(framebuffer: gl_framebuffer; _buffer: Buffer; drawbuffer: Int32; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ClearNamedFramebufferfv_2(framebuffer, _buffer, drawbuffer, value[0]) else
        z_ClearNamedFramebufferfv_2(framebuffer, _buffer, drawbuffer, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferfv(framebuffer: gl_framebuffer; _buffer: Buffer; drawbuffer: Int32; var value: single) :=
    z_ClearNamedFramebufferfv_2(framebuffer, _buffer, drawbuffer, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferfv(framebuffer: gl_framebuffer; _buffer: Buffer; drawbuffer: Int32; value: IntPtr) :=
    z_ClearNamedFramebufferfv_1(framebuffer, _buffer, drawbuffer, value);
    
    // added in gl4.5
    private z_ClearNamedFramebufferiv_adr := GetProcAddress('glClearNamedFramebufferiv');
    private z_ClearNamedFramebufferiv_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; _buffer: Buffer; drawbuffer: Int32; value: IntPtr)>(z_ClearNamedFramebufferiv_adr);
    private z_ClearNamedFramebufferiv_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; _buffer: Buffer; drawbuffer: Int32; var value: Int32)>(z_ClearNamedFramebufferiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferiv(framebuffer: gl_framebuffer; _buffer: Buffer; drawbuffer: Int32; value: array of Int32);
    type PInt32=^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ClearNamedFramebufferiv_2(framebuffer, _buffer, drawbuffer, value[0]) else
        z_ClearNamedFramebufferiv_2(framebuffer, _buffer, drawbuffer, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferiv(framebuffer: gl_framebuffer; _buffer: Buffer; drawbuffer: Int32; var value: Int32) :=
    z_ClearNamedFramebufferiv_2(framebuffer, _buffer, drawbuffer, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferiv(framebuffer: gl_framebuffer; _buffer: Buffer; drawbuffer: Int32; value: IntPtr) :=
    z_ClearNamedFramebufferiv_1(framebuffer, _buffer, drawbuffer, value);
    
    // added in gl4.5
    private z_ClearNamedFramebufferuiv_adr := GetProcAddress('glClearNamedFramebufferuiv');
    private z_ClearNamedFramebufferuiv_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; _buffer: Buffer; drawbuffer: Int32; value: IntPtr)>(z_ClearNamedFramebufferuiv_adr);
    private z_ClearNamedFramebufferuiv_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; _buffer: Buffer; drawbuffer: Int32; var value: UInt32)>(z_ClearNamedFramebufferuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferuiv(framebuffer: gl_framebuffer; _buffer: Buffer; drawbuffer: Int32; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ClearNamedFramebufferuiv_2(framebuffer, _buffer, drawbuffer, value[0]) else
        z_ClearNamedFramebufferuiv_2(framebuffer, _buffer, drawbuffer, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferuiv(framebuffer: gl_framebuffer; _buffer: Buffer; drawbuffer: Int32; var value: UInt32) :=
    z_ClearNamedFramebufferuiv_2(framebuffer, _buffer, drawbuffer, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferuiv(framebuffer: gl_framebuffer; _buffer: Buffer; drawbuffer: Int32; value: IntPtr) :=
    z_ClearNamedFramebufferuiv_1(framebuffer, _buffer, drawbuffer, value);
    
    // added in gl1.0
    private z_ClearStencil_adr := GetProcAddress('glClearStencil');
    private z_ClearStencil_1 := GetProcOrNil&<procedure(s: Int32)>(z_ClearStencil_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearStencil(s: Int32) :=
    z_ClearStencil_1(s);
    
    // added in gl4.4
    private z_ClearTexImage_adr := GetProcAddress('glClearTexImage');
    private z_ClearTexImage_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; format: PixelFormat; &type: PixelType; data: IntPtr)>(z_ClearTexImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearTexImage(texture: gl_texture; level: Int32; format: PixelFormat; &type: PixelType; data: IntPtr) :=
    z_ClearTexImage_1(texture, level, format, &type, data);
    
    // added in gl4.4
    private z_ClearTexSubImage_adr := GetProcAddress('glClearTexSubImage');
    private z_ClearTexSubImage_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: PixelFormat; &type: PixelType; data: IntPtr)>(z_ClearTexSubImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearTexSubImage(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: PixelFormat; &type: PixelType; data: IntPtr) :=
    z_ClearTexSubImage_1(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, data);
    
    // added in gl3.2
    private z_ClientWaitSync_adr := GetProcAddress('glClientWaitSync');
    private z_ClientWaitSync_1 := GetProcOrNil&<function(sync: gl_sync; flags: SyncObjectMask; timeout: UInt64): SyncStatus>(z_ClientWaitSync_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ClientWaitSync(sync: gl_sync; flags: SyncObjectMask; timeout: UInt64): SyncStatus :=
    z_ClientWaitSync_1(sync, flags, timeout);
    
    // added in gl4.5
    private z_ClipControl_adr := GetProcAddress('glClipControl');
    private z_ClipControl_1 := GetProcOrNil&<procedure(origin: ClipControlOrigin; depth: ClipControlDepth)>(z_ClipControl_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipControl(origin: ClipControlOrigin; depth: ClipControlDepth) :=
    z_ClipControl_1(origin, depth);
    
    // added in gl1.0
    private z_ColorMask_adr := GetProcAddress('glColorMask');
    private z_ColorMask_1 := GetProcOrNil&<procedure(red: boolean; green: boolean; blue: boolean; alpha: boolean)>(z_ColorMask_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorMask(red: boolean; green: boolean; blue: boolean; alpha: boolean) :=
    z_ColorMask_1(red, green, blue, alpha);
    
    // added in gl3.0
    private z_ColorMaski_adr := GetProcAddress('glColorMaski');
    private z_ColorMaski_1 := GetProcOrNil&<procedure(index: UInt32; r: boolean; g: boolean; b: boolean; a: boolean)>(z_ColorMaski_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorMaski(index: UInt32; r: boolean; g: boolean; b: boolean; a: boolean) :=
    z_ColorMaski_1(index, r, g, b, a);
    
    // added in gl3.3
    private z_ColorP3ui_adr := GetProcAddress('glColorP3ui');
    private z_ColorP3ui_1 := GetProcOrNil&<procedure(&type: ColorPointerType; color: UInt32)>(z_ColorP3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP3ui(&type: ColorPointerType; color: UInt32) :=
    z_ColorP3ui_1(&type, color);
    
    // added in gl3.3
    private z_ColorP3uiv_adr := GetProcAddress('glColorP3uiv');
    private z_ColorP3uiv_1 := GetProcOrNil&<procedure(&type: ColorPointerType; color: IntPtr)>(z_ColorP3uiv_adr);
    private z_ColorP3uiv_2 := GetProcOrNil&<procedure(&type: ColorPointerType; var color: UInt32)>(z_ColorP3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP3uiv(&type: ColorPointerType; color: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (color<>nil) and (color.Length<>0) then
        z_ColorP3uiv_2(&type, color[0]) else
        z_ColorP3uiv_2(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP3uiv(&type: ColorPointerType; var color: UInt32) :=
    z_ColorP3uiv_2(&type, color);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP3uiv(&type: ColorPointerType; color: IntPtr) :=
    z_ColorP3uiv_1(&type, color);
    
    // added in gl3.3
    private z_ColorP4ui_adr := GetProcAddress('glColorP4ui');
    private z_ColorP4ui_1 := GetProcOrNil&<procedure(&type: ColorPointerType; color: UInt32)>(z_ColorP4ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP4ui(&type: ColorPointerType; color: UInt32) :=
    z_ColorP4ui_1(&type, color);
    
    // added in gl3.3
    private z_ColorP4uiv_adr := GetProcAddress('glColorP4uiv');
    private z_ColorP4uiv_1 := GetProcOrNil&<procedure(&type: ColorPointerType; color: IntPtr)>(z_ColorP4uiv_adr);
    private z_ColorP4uiv_2 := GetProcOrNil&<procedure(&type: ColorPointerType; var color: UInt32)>(z_ColorP4uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP4uiv(&type: ColorPointerType; color: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (color<>nil) and (color.Length<>0) then
        z_ColorP4uiv_2(&type, color[0]) else
        z_ColorP4uiv_2(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP4uiv(&type: ColorPointerType; var color: UInt32) :=
    z_ColorP4uiv_2(&type, color);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP4uiv(&type: ColorPointerType; color: IntPtr) :=
    z_ColorP4uiv_1(&type, color);
    
    // added in gl2.0
    private z_CompileShader_adr := GetProcAddress('glCompileShader');
    private z_CompileShader_1 := GetProcOrNil&<procedure(shader: gl_shader)>(z_CompileShader_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileShader(shader: gl_shader) :=
    z_CompileShader_1(shader);
    
    // added in gl1.3
    private z_CompressedTexImage1D_adr := GetProcAddress('glCompressedTexImage1D');
    private z_CompressedTexImage1D_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; border: Int32; imageSize: Int32; data: IntPtr)>(z_CompressedTexImage1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexImage1D(target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; border: Int32; imageSize: Int32; data: IntPtr) :=
    z_CompressedTexImage1D_1(target, level, _internalformat, width, border, imageSize, data);
    
    // added in gl1.3
    private z_CompressedTexImage2D_adr := GetProcAddress('glCompressedTexImage2D');
    private z_CompressedTexImage2D_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; border: Int32; imageSize: Int32; data: IntPtr)>(z_CompressedTexImage2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexImage2D(target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; border: Int32; imageSize: Int32; data: IntPtr) :=
    z_CompressedTexImage2D_1(target, level, _internalformat, width, height, border, imageSize, data);
    
    // added in gl1.3
    private z_CompressedTexImage3D_adr := GetProcAddress('glCompressedTexImage3D');
    private z_CompressedTexImage3D_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; data: IntPtr)>(z_CompressedTexImage3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexImage3D(target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; data: IntPtr) :=
    z_CompressedTexImage3D_1(target, level, _internalformat, width, height, depth, border, imageSize, data);
    
    // added in gl1.3
    private z_CompressedTexSubImage1D_adr := GetProcAddress('glCompressedTexSubImage1D');
    private z_CompressedTexSubImage1D_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; xoffset: Int32; width: Int32; format: InternalFormat; imageSize: Int32; data: IntPtr)>(z_CompressedTexSubImage1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexSubImage1D(target: TextureTarget; level: Int32; xoffset: Int32; width: Int32; format: InternalFormat; imageSize: Int32; data: IntPtr) :=
    z_CompressedTexSubImage1D_1(target, level, xoffset, width, format, imageSize, data);
    
    // added in gl1.3
    private z_CompressedTexSubImage2D_adr := GetProcAddress('glCompressedTexSubImage2D');
    private z_CompressedTexSubImage2D_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: InternalFormat; imageSize: Int32; data: IntPtr)>(z_CompressedTexSubImage2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexSubImage2D(target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: InternalFormat; imageSize: Int32; data: IntPtr) :=
    z_CompressedTexSubImage2D_1(target, level, xoffset, yoffset, width, height, format, imageSize, data);
    
    // added in gl1.3
    private z_CompressedTexSubImage3D_adr := GetProcAddress('glCompressedTexSubImage3D');
    private z_CompressedTexSubImage3D_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: InternalFormat; imageSize: Int32; data: IntPtr)>(z_CompressedTexSubImage3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexSubImage3D(target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: InternalFormat; imageSize: Int32; data: IntPtr) :=
    z_CompressedTexSubImage3D_1(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
    
    // added in gl4.5
    private z_CompressedTextureSubImage1D_adr := GetProcAddress('glCompressedTextureSubImage1D');
    private z_CompressedTextureSubImage1D_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; width: Int32; format: InternalFormat; imageSize: Int32; data: IntPtr)>(z_CompressedTextureSubImage1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureSubImage1D(texture: gl_texture; level: Int32; xoffset: Int32; width: Int32; format: InternalFormat; imageSize: Int32; data: IntPtr) :=
    z_CompressedTextureSubImage1D_1(texture, level, xoffset, width, format, imageSize, data);
    
    // added in gl4.5
    private z_CompressedTextureSubImage2D_adr := GetProcAddress('glCompressedTextureSubImage2D');
    private z_CompressedTextureSubImage2D_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: InternalFormat; imageSize: Int32; data: IntPtr)>(z_CompressedTextureSubImage2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureSubImage2D(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: InternalFormat; imageSize: Int32; data: IntPtr) :=
    z_CompressedTextureSubImage2D_1(texture, level, xoffset, yoffset, width, height, format, imageSize, data);
    
    // added in gl4.5
    private z_CompressedTextureSubImage3D_adr := GetProcAddress('glCompressedTextureSubImage3D');
    private z_CompressedTextureSubImage3D_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: InternalFormat; imageSize: Int32; data: IntPtr)>(z_CompressedTextureSubImage3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureSubImage3D(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: InternalFormat; imageSize: Int32; data: IntPtr) :=
    z_CompressedTextureSubImage3D_1(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
    
    // added in gl3.1
    private z_CopyBufferSubData_adr := GetProcAddress('glCopyBufferSubData');
    private z_CopyBufferSubData_1 := GetProcOrNil&<procedure(readTarget: CopyBufferSubDataTarget; writeTarget: CopyBufferSubDataTarget; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr)>(z_CopyBufferSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyBufferSubData(readTarget: CopyBufferSubDataTarget; writeTarget: CopyBufferSubDataTarget; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr) :=
    z_CopyBufferSubData_1(readTarget, writeTarget, readOffset, writeOffset, size);
    
    // added in gl4.3
    private z_CopyImageSubData_adr := GetProcAddress('glCopyImageSubData');
    private z_CopyImageSubData_1 := GetProcOrNil&<procedure(srcName: UInt32; srcTarget: CopyImageSubDataTarget; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: CopyImageSubDataTarget; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32)>(z_CopyImageSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyImageSubData(srcName: UInt32; srcTarget: CopyImageSubDataTarget; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: CopyImageSubDataTarget; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32) :=
    z_CopyImageSubData_1(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
    
    // added in gl4.5
    private z_CopyNamedBufferSubData_adr := GetProcAddress('glCopyNamedBufferSubData');
    private z_CopyNamedBufferSubData_1 := GetProcOrNil&<procedure(readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr)>(z_CopyNamedBufferSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyNamedBufferSubData(readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr) :=
    z_CopyNamedBufferSubData_1(readBuffer, writeBuffer, readOffset, writeOffset, size);
    
    // added in gl1.1
    private z_CopyTexImage1D_adr := GetProcAddress('glCopyTexImage1D');
    private z_CopyTexImage1D_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; _internalformat: InternalFormat; x: Int32; y: Int32; width: Int32; border: Int32)>(z_CopyTexImage1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTexImage1D(target: TextureTarget; level: Int32; _internalformat: InternalFormat; x: Int32; y: Int32; width: Int32; border: Int32) :=
    z_CopyTexImage1D_1(target, level, _internalformat, x, y, width, border);
    
    // added in gl1.1
    private z_CopyTexImage2D_adr := GetProcAddress('glCopyTexImage2D');
    private z_CopyTexImage2D_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; _internalformat: InternalFormat; x: Int32; y: Int32; width: Int32; height: Int32; border: Int32)>(z_CopyTexImage2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTexImage2D(target: TextureTarget; level: Int32; _internalformat: InternalFormat; x: Int32; y: Int32; width: Int32; height: Int32; border: Int32) :=
    z_CopyTexImage2D_1(target, level, _internalformat, x, y, width, height, border);
    
    // added in gl1.1
    private z_CopyTexSubImage1D_adr := GetProcAddress('glCopyTexSubImage1D');
    private z_CopyTexSubImage1D_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32)>(z_CopyTexSubImage1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTexSubImage1D(target: TextureTarget; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32) :=
    z_CopyTexSubImage1D_1(target, level, xoffset, x, y, width);
    
    // added in gl1.1
    private z_CopyTexSubImage2D_adr := GetProcAddress('glCopyTexSubImage2D');
    private z_CopyTexSubImage2D_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32)>(z_CopyTexSubImage2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTexSubImage2D(target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) :=
    z_CopyTexSubImage2D_1(target, level, xoffset, yoffset, x, y, width, height);
    
    // added in gl1.2
    private z_CopyTexSubImage3D_adr := GetProcAddress('glCopyTexSubImage3D');
    private z_CopyTexSubImage3D_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32)>(z_CopyTexSubImage3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTexSubImage3D(target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) :=
    z_CopyTexSubImage3D_1(target, level, xoffset, yoffset, zoffset, x, y, width, height);
    
    // added in gl4.5
    private z_CopyTextureSubImage1D_adr := GetProcAddress('glCopyTextureSubImage1D');
    private z_CopyTextureSubImage1D_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32)>(z_CopyTextureSubImage1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTextureSubImage1D(texture: gl_texture; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32) :=
    z_CopyTextureSubImage1D_1(texture, level, xoffset, x, y, width);
    
    // added in gl4.5
    private z_CopyTextureSubImage2D_adr := GetProcAddress('glCopyTextureSubImage2D');
    private z_CopyTextureSubImage2D_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32)>(z_CopyTextureSubImage2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTextureSubImage2D(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) :=
    z_CopyTextureSubImage2D_1(texture, level, xoffset, yoffset, x, y, width, height);
    
    // added in gl4.5
    private z_CopyTextureSubImage3D_adr := GetProcAddress('glCopyTextureSubImage3D');
    private z_CopyTextureSubImage3D_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32)>(z_CopyTextureSubImage3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTextureSubImage3D(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) :=
    z_CopyTextureSubImage3D_1(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
    
    // added in gl4.5
    private z_CreateBuffers_adr := GetProcAddress('glCreateBuffers');
    private z_CreateBuffers_1 := GetProcOrNil&<procedure(n: Int32; buffers: IntPtr)>(z_CreateBuffers_adr);
    private z_CreateBuffers_2 := GetProcOrNil&<procedure(n: Int32; var buffers: gl_buffer)>(z_CreateBuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateBuffers(n: Int32; buffers: array of gl_buffer);
    type Pgl_buffer=^gl_buffer;
    begin
      if (buffers<>nil) and (buffers.Length<>0) then
        z_CreateBuffers_2(n, buffers[0]) else
        z_CreateBuffers_2(n, Pgl_buffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateBuffers(n: Int32; var buffers: gl_buffer) :=
    z_CreateBuffers_2(n, buffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateBuffers(n: Int32; buffers: IntPtr) :=
    z_CreateBuffers_1(n, buffers);
    
    // added in gl4.5
    private z_CreateFramebuffers_adr := GetProcAddress('glCreateFramebuffers');
    private z_CreateFramebuffers_1 := GetProcOrNil&<procedure(n: Int32; framebuffers: IntPtr)>(z_CreateFramebuffers_adr);
    private z_CreateFramebuffers_2 := GetProcOrNil&<procedure(n: Int32; var framebuffers: gl_framebuffer)>(z_CreateFramebuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateFramebuffers(n: Int32; framebuffers: array of gl_framebuffer);
    type Pgl_framebuffer=^gl_framebuffer;
    begin
      if (framebuffers<>nil) and (framebuffers.Length<>0) then
        z_CreateFramebuffers_2(n, framebuffers[0]) else
        z_CreateFramebuffers_2(n, Pgl_framebuffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateFramebuffers(n: Int32; var framebuffers: gl_framebuffer) :=
    z_CreateFramebuffers_2(n, framebuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateFramebuffers(n: Int32; framebuffers: IntPtr) :=
    z_CreateFramebuffers_1(n, framebuffers);
    
    // added in gl2.0
    private z_CreateProgram_adr := GetProcAddress('glCreateProgram');
    private z_CreateProgram_1 := GetProcOrNil&<function: gl_program>(z_CreateProgram_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateProgram: gl_program :=
    z_CreateProgram_1();
    
    // added in gl4.5
    private z_CreateProgramPipelines_adr := GetProcAddress('glCreateProgramPipelines');
    private z_CreateProgramPipelines_1 := GetProcOrNil&<procedure(n: Int32; pipelines: IntPtr)>(z_CreateProgramPipelines_adr);
    private z_CreateProgramPipelines_2 := GetProcOrNil&<procedure(n: Int32; var pipelines: gl_program_pipeline)>(z_CreateProgramPipelines_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateProgramPipelines(n: Int32; pipelines: array of gl_program_pipeline);
    type Pgl_program_pipeline=^gl_program_pipeline;
    begin
      if (pipelines<>nil) and (pipelines.Length<>0) then
        z_CreateProgramPipelines_2(n, pipelines[0]) else
        z_CreateProgramPipelines_2(n, Pgl_program_pipeline(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateProgramPipelines(n: Int32; var pipelines: gl_program_pipeline) :=
    z_CreateProgramPipelines_2(n, pipelines);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateProgramPipelines(n: Int32; pipelines: IntPtr) :=
    z_CreateProgramPipelines_1(n, pipelines);
    
    // added in gl4.5
    private z_CreateQueries_adr := GetProcAddress('glCreateQueries');
    private z_CreateQueries_1 := GetProcOrNil&<procedure(target: QueryTarget; n: Int32; ids: IntPtr)>(z_CreateQueries_adr);
    private z_CreateQueries_2 := GetProcOrNil&<procedure(target: QueryTarget; n: Int32; var ids: gl_query)>(z_CreateQueries_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateQueries(target: QueryTarget; n: Int32; ids: array of gl_query);
    type Pgl_query=^gl_query;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        z_CreateQueries_2(target, n, ids[0]) else
        z_CreateQueries_2(target, n, Pgl_query(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateQueries(target: QueryTarget; n: Int32; var ids: gl_query) :=
    z_CreateQueries_2(target, n, ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateQueries(target: QueryTarget; n: Int32; ids: IntPtr) :=
    z_CreateQueries_1(target, n, ids);
    
    // added in gl4.5
    private z_CreateRenderbuffers_adr := GetProcAddress('glCreateRenderbuffers');
    private z_CreateRenderbuffers_1 := GetProcOrNil&<procedure(n: Int32; renderbuffers: IntPtr)>(z_CreateRenderbuffers_adr);
    private z_CreateRenderbuffers_2 := GetProcOrNil&<procedure(n: Int32; var renderbuffers: gl_renderbuffer)>(z_CreateRenderbuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateRenderbuffers(n: Int32; renderbuffers: array of gl_renderbuffer);
    type Pgl_renderbuffer=^gl_renderbuffer;
    begin
      if (renderbuffers<>nil) and (renderbuffers.Length<>0) then
        z_CreateRenderbuffers_2(n, renderbuffers[0]) else
        z_CreateRenderbuffers_2(n, Pgl_renderbuffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateRenderbuffers(n: Int32; var renderbuffers: gl_renderbuffer) :=
    z_CreateRenderbuffers_2(n, renderbuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateRenderbuffers(n: Int32; renderbuffers: IntPtr) :=
    z_CreateRenderbuffers_1(n, renderbuffers);
    
    // added in gl4.5
    private z_CreateSamplers_adr := GetProcAddress('glCreateSamplers');
    private z_CreateSamplers_1 := GetProcOrNil&<procedure(n: Int32; samplers: IntPtr)>(z_CreateSamplers_adr);
    private z_CreateSamplers_2 := GetProcOrNil&<procedure(n: Int32; var samplers: gl_sampler)>(z_CreateSamplers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateSamplers(n: Int32; samplers: array of gl_sampler);
    type Pgl_sampler=^gl_sampler;
    begin
      if (samplers<>nil) and (samplers.Length<>0) then
        z_CreateSamplers_2(n, samplers[0]) else
        z_CreateSamplers_2(n, Pgl_sampler(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateSamplers(n: Int32; var samplers: gl_sampler) :=
    z_CreateSamplers_2(n, samplers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateSamplers(n: Int32; samplers: IntPtr) :=
    z_CreateSamplers_1(n, samplers);
    
    // added in gl2.0
    private z_CreateShader_adr := GetProcAddress('glCreateShader');
    private z_CreateShader_1 := GetProcOrNil&<function(&type: ShaderType): gl_shader>(z_CreateShader_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateShader(&type: ShaderType): gl_shader :=
    z_CreateShader_1(&type);
    
    // added in gl4.1
    private z_CreateShaderProgramv_adr := GetProcAddress('glCreateShaderProgramv');
    private z_CreateShaderProgramv_1 := GetProcOrNil&<function(&type: ShaderType; count: Int32; strings: pointer): gl_program>(z_CreateShaderProgramv_adr);
    private z_CreateShaderProgramv_2 := GetProcOrNil&<function(&type: ShaderType; count: Int32; var strings: IntPtr): gl_program>(z_CreateShaderProgramv_adr);
    private [MethodImpl(MethodImplOptions.AggressiveInlining)] function temp_CreateShaderProgramv_1(&type: ShaderType; count: Int32; strings: array of IntPtr): gl_program;
    type PIntPtr=^IntPtr;
    begin
      Result := if (strings<>nil) and (strings.Length<>0) then
        z_CreateShaderProgramv_2(&type, count, strings[0]) else
        z_CreateShaderProgramv_2(&type, count, PIntPtr(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateShaderProgramv(&type: ShaderType; count: Int32; strings: array of string): gl_program;
    begin
      var strings_str_ptrs: array of IntPtr;
      try
        strings_str_ptrs := strings?.ConvertAll(arr_el1->
          Marshal.StringToHGlobalAnsi(arr_el1)
        );
        Result := temp_CreateShaderProgramv_1(&type, count, strings_str_ptrs);
      finally
        if strings_str_ptrs<>nil then foreach var arr_el1 in strings_str_ptrs do
          Marshal.FreeHGlobal(arr_el1);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateShaderProgramv(&type: ShaderType; count: Int32; var strings: IntPtr): gl_program :=
    z_CreateShaderProgramv_2(&type, count, strings);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateShaderProgramv(&type: ShaderType; count: Int32; strings: pointer): gl_program :=
    z_CreateShaderProgramv_1(&type, count, strings);
    
    // added in gl4.5
    private z_CreateTextures_adr := GetProcAddress('glCreateTextures');
    private z_CreateTextures_1 := GetProcOrNil&<procedure(target: TextureTarget; n: Int32; textures: IntPtr)>(z_CreateTextures_adr);
    private z_CreateTextures_2 := GetProcOrNil&<procedure(target: TextureTarget; n: Int32; var textures: gl_texture)>(z_CreateTextures_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateTextures(target: TextureTarget; n: Int32; textures: array of gl_texture);
    type Pgl_texture=^gl_texture;
    begin
      if (textures<>nil) and (textures.Length<>0) then
        z_CreateTextures_2(target, n, textures[0]) else
        z_CreateTextures_2(target, n, Pgl_texture(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateTextures(target: TextureTarget; n: Int32; var textures: gl_texture) :=
    z_CreateTextures_2(target, n, textures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateTextures(target: TextureTarget; n: Int32; textures: IntPtr) :=
    z_CreateTextures_1(target, n, textures);
    
    // added in gl4.5
    private z_CreateTransformFeedbacks_adr := GetProcAddress('glCreateTransformFeedbacks');
    private z_CreateTransformFeedbacks_1 := GetProcOrNil&<procedure(n: Int32; ids: IntPtr)>(z_CreateTransformFeedbacks_adr);
    private z_CreateTransformFeedbacks_2 := GetProcOrNil&<procedure(n: Int32; var ids: gl_transform_feedback)>(z_CreateTransformFeedbacks_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateTransformFeedbacks(n: Int32; ids: array of gl_transform_feedback);
    type Pgl_transform_feedback=^gl_transform_feedback;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        z_CreateTransformFeedbacks_2(n, ids[0]) else
        z_CreateTransformFeedbacks_2(n, Pgl_transform_feedback(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateTransformFeedbacks(n: Int32; var ids: gl_transform_feedback) :=
    z_CreateTransformFeedbacks_2(n, ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateTransformFeedbacks(n: Int32; ids: IntPtr) :=
    z_CreateTransformFeedbacks_1(n, ids);
    
    // added in gl4.5
    private z_CreateVertexArrays_adr := GetProcAddress('glCreateVertexArrays');
    private z_CreateVertexArrays_1 := GetProcOrNil&<procedure(n: Int32; arrays: IntPtr)>(z_CreateVertexArrays_adr);
    private z_CreateVertexArrays_2 := GetProcOrNil&<procedure(n: Int32; var arrays: gl_vertex_array)>(z_CreateVertexArrays_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateVertexArrays(n: Int32; arrays: array of gl_vertex_array);
    type Pgl_vertex_array=^gl_vertex_array;
    begin
      if (arrays<>nil) and (arrays.Length<>0) then
        z_CreateVertexArrays_2(n, arrays[0]) else
        z_CreateVertexArrays_2(n, Pgl_vertex_array(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateVertexArrays(n: Int32; var arrays: gl_vertex_array) :=
    z_CreateVertexArrays_2(n, arrays);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateVertexArrays(n: Int32; arrays: IntPtr) :=
    z_CreateVertexArrays_1(n, arrays);
    
    // added in gl1.0
    private z_CullFace_adr := GetProcAddress('glCullFace');
    private z_CullFace_1 := GetProcOrNil&<procedure(mode: MaterialFace)>(z_CullFace_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CullFace(mode: MaterialFace) :=
    z_CullFace_1(mode);
    
    // added in gl4.3
    private z_DebugMessageCallback_adr := GetProcAddress('glDebugMessageCallback');
    private z_DebugMessageCallback_1 := GetProcOrNil&<procedure(callback: GL_DEBUG_PROC; userParam: IntPtr)>(z_DebugMessageCallback_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageCallback(callback: GL_DEBUG_PROC; userParam: IntPtr) :=
    z_DebugMessageCallback_1(callback, userParam);
    
    // added in gl4.3
    private z_DebugMessageControl_adr := GetProcAddress('glDebugMessageControl');
    private z_DebugMessageControl_1 := GetProcOrNil&<procedure(source: DebugSource; &type: DebugType; severity: DebugSeverity; count: Int32; ids: IntPtr; enabled: boolean)>(z_DebugMessageControl_adr);
    private z_DebugMessageControl_2 := GetProcOrNil&<procedure(source: DebugSource; &type: DebugType; severity: DebugSeverity; count: Int32; var ids: UInt32; enabled: boolean)>(z_DebugMessageControl_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageControl(source: DebugSource; &type: DebugType; severity: DebugSeverity; count: Int32; ids: array of UInt32; enabled: boolean);
    type PUInt32=^UInt32;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        z_DebugMessageControl_2(source, &type, severity, count, ids[0], enabled) else
        z_DebugMessageControl_2(source, &type, severity, count, PUInt32(nil)^, enabled);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageControl(source: DebugSource; &type: DebugType; severity: DebugSeverity; count: Int32; var ids: UInt32; enabled: boolean) :=
    z_DebugMessageControl_2(source, &type, severity, count, ids, enabled);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageControl(source: DebugSource; &type: DebugType; severity: DebugSeverity; count: Int32; ids: IntPtr; enabled: boolean) :=
    z_DebugMessageControl_1(source, &type, severity, count, ids, enabled);
    
    // added in gl4.3
    private z_DebugMessageInsert_adr := GetProcAddress('glDebugMessageInsert');
    private z_DebugMessageInsert_1 := GetProcOrNil&<procedure(source: DebugSource; &type: DebugType; id: UInt32; severity: DebugSeverity; length: Int32; buf: IntPtr)>(z_DebugMessageInsert_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageInsert(source: DebugSource; &type: DebugType; id: UInt32; severity: DebugSeverity; length: Int32; buf: string);
    begin
      var buf_str_ptr: IntPtr;
      try
        buf_str_ptr := Marshal.StringToHGlobalAnsi(buf);
        z_DebugMessageInsert_1(source, &type, id, severity, length, buf_str_ptr);
      finally
        Marshal.FreeHGlobal(buf_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageInsert(source: DebugSource; &type: DebugType; id: UInt32; severity: DebugSeverity; length: Int32; buf: IntPtr) :=
    z_DebugMessageInsert_1(source, &type, id, severity, length, buf);
    
    // added in gl1.5
    private z_DeleteBuffers_adr := GetProcAddress('glDeleteBuffers');
    private z_DeleteBuffers_1 := GetProcOrNil&<procedure(n: Int32; buffers: IntPtr)>(z_DeleteBuffers_adr);
    private z_DeleteBuffers_2 := GetProcOrNil&<procedure(n: Int32; var buffers: gl_buffer)>(z_DeleteBuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteBuffers(n: Int32; buffers: array of gl_buffer);
    type Pgl_buffer=^gl_buffer;
    begin
      if (buffers<>nil) and (buffers.Length<>0) then
        z_DeleteBuffers_2(n, buffers[0]) else
        z_DeleteBuffers_2(n, Pgl_buffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteBuffers(n: Int32; var buffers: gl_buffer) :=
    z_DeleteBuffers_2(n, buffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteBuffers(n: Int32; buffers: IntPtr) :=
    z_DeleteBuffers_1(n, buffers);
    
    // added in gl3.0
    private z_DeleteFramebuffers_adr := GetProcAddress('glDeleteFramebuffers');
    private z_DeleteFramebuffers_1 := GetProcOrNil&<procedure(n: Int32; framebuffers: IntPtr)>(z_DeleteFramebuffers_adr);
    private z_DeleteFramebuffers_2 := GetProcOrNil&<procedure(n: Int32; var framebuffers: gl_framebuffer)>(z_DeleteFramebuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFramebuffers(n: Int32; framebuffers: array of gl_framebuffer);
    type Pgl_framebuffer=^gl_framebuffer;
    begin
      if (framebuffers<>nil) and (framebuffers.Length<>0) then
        z_DeleteFramebuffers_2(n, framebuffers[0]) else
        z_DeleteFramebuffers_2(n, Pgl_framebuffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFramebuffers(n: Int32; var framebuffers: gl_framebuffer) :=
    z_DeleteFramebuffers_2(n, framebuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFramebuffers(n: Int32; framebuffers: IntPtr) :=
    z_DeleteFramebuffers_1(n, framebuffers);
    
    // added in gl2.0
    private z_DeleteProgram_adr := GetProcAddress('glDeleteProgram');
    private z_DeleteProgram_1 := GetProcOrNil&<procedure(&program: gl_program)>(z_DeleteProgram_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgram(&program: gl_program) :=
    z_DeleteProgram_1(&program);
    
    // added in gl4.1
    private z_DeleteProgramPipelines_adr := GetProcAddress('glDeleteProgramPipelines');
    private z_DeleteProgramPipelines_1 := GetProcOrNil&<procedure(n: Int32; pipelines: IntPtr)>(z_DeleteProgramPipelines_adr);
    private z_DeleteProgramPipelines_2 := GetProcOrNil&<procedure(n: Int32; var pipelines: gl_program_pipeline)>(z_DeleteProgramPipelines_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramPipelines(n: Int32; pipelines: array of gl_program_pipeline);
    type Pgl_program_pipeline=^gl_program_pipeline;
    begin
      if (pipelines<>nil) and (pipelines.Length<>0) then
        z_DeleteProgramPipelines_2(n, pipelines[0]) else
        z_DeleteProgramPipelines_2(n, Pgl_program_pipeline(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramPipelines(n: Int32; var pipelines: gl_program_pipeline) :=
    z_DeleteProgramPipelines_2(n, pipelines);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramPipelines(n: Int32; pipelines: IntPtr) :=
    z_DeleteProgramPipelines_1(n, pipelines);
    
    // added in gl1.5
    private z_DeleteQueries_adr := GetProcAddress('glDeleteQueries');
    private z_DeleteQueries_1 := GetProcOrNil&<procedure(n: Int32; ids: IntPtr)>(z_DeleteQueries_adr);
    private z_DeleteQueries_2 := GetProcOrNil&<procedure(n: Int32; var ids: gl_query)>(z_DeleteQueries_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteQueries(n: Int32; ids: array of gl_query);
    type Pgl_query=^gl_query;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        z_DeleteQueries_2(n, ids[0]) else
        z_DeleteQueries_2(n, Pgl_query(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteQueries(n: Int32; var ids: gl_query) :=
    z_DeleteQueries_2(n, ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteQueries(n: Int32; ids: IntPtr) :=
    z_DeleteQueries_1(n, ids);
    
    // added in gl3.0
    private z_DeleteRenderbuffers_adr := GetProcAddress('glDeleteRenderbuffers');
    private z_DeleteRenderbuffers_1 := GetProcOrNil&<procedure(n: Int32; renderbuffers: IntPtr)>(z_DeleteRenderbuffers_adr);
    private z_DeleteRenderbuffers_2 := GetProcOrNil&<procedure(n: Int32; var renderbuffers: gl_renderbuffer)>(z_DeleteRenderbuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteRenderbuffers(n: Int32; renderbuffers: array of gl_renderbuffer);
    type Pgl_renderbuffer=^gl_renderbuffer;
    begin
      if (renderbuffers<>nil) and (renderbuffers.Length<>0) then
        z_DeleteRenderbuffers_2(n, renderbuffers[0]) else
        z_DeleteRenderbuffers_2(n, Pgl_renderbuffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteRenderbuffers(n: Int32; var renderbuffers: gl_renderbuffer) :=
    z_DeleteRenderbuffers_2(n, renderbuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteRenderbuffers(n: Int32; renderbuffers: IntPtr) :=
    z_DeleteRenderbuffers_1(n, renderbuffers);
    
    // added in gl3.3
    private z_DeleteSamplers_adr := GetProcAddress('glDeleteSamplers');
    private z_DeleteSamplers_1 := GetProcOrNil&<procedure(count: Int32; samplers: IntPtr)>(z_DeleteSamplers_adr);
    private z_DeleteSamplers_2 := GetProcOrNil&<procedure(count: Int32; var samplers: gl_sampler)>(z_DeleteSamplers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteSamplers(count: Int32; samplers: array of gl_sampler);
    type Pgl_sampler=^gl_sampler;
    begin
      if (samplers<>nil) and (samplers.Length<>0) then
        z_DeleteSamplers_2(count, samplers[0]) else
        z_DeleteSamplers_2(count, Pgl_sampler(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteSamplers(count: Int32; var samplers: gl_sampler) :=
    z_DeleteSamplers_2(count, samplers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteSamplers(count: Int32; samplers: IntPtr) :=
    z_DeleteSamplers_1(count, samplers);
    
    // added in gl2.0
    private z_DeleteShader_adr := GetProcAddress('glDeleteShader');
    private z_DeleteShader_1 := GetProcOrNil&<procedure(shader: gl_shader)>(z_DeleteShader_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteShader(shader: gl_shader) :=
    z_DeleteShader_1(shader);
    
    // added in gl3.2
    private z_DeleteSync_adr := GetProcAddress('glDeleteSync');
    private z_DeleteSync_1 := GetProcOrNil&<procedure(sync: gl_sync)>(z_DeleteSync_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteSync(sync: gl_sync) :=
    z_DeleteSync_1(sync);
    
    // added in gl1.1
    private z_DeleteTextures_adr := GetProcAddress('glDeleteTextures');
    private z_DeleteTextures_1 := GetProcOrNil&<procedure(n: Int32; textures: IntPtr)>(z_DeleteTextures_adr);
    private z_DeleteTextures_2 := GetProcOrNil&<procedure(n: Int32; var textures: gl_texture)>(z_DeleteTextures_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTextures(n: Int32; textures: array of gl_texture);
    type Pgl_texture=^gl_texture;
    begin
      if (textures<>nil) and (textures.Length<>0) then
        z_DeleteTextures_2(n, textures[0]) else
        z_DeleteTextures_2(n, Pgl_texture(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTextures(n: Int32; var textures: gl_texture) :=
    z_DeleteTextures_2(n, textures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTextures(n: Int32; textures: IntPtr) :=
    z_DeleteTextures_1(n, textures);
    
    // added in gl4.0
    private z_DeleteTransformFeedbacks_adr := GetProcAddress('glDeleteTransformFeedbacks');
    private z_DeleteTransformFeedbacks_1 := GetProcOrNil&<procedure(n: Int32; ids: IntPtr)>(z_DeleteTransformFeedbacks_adr);
    private z_DeleteTransformFeedbacks_2 := GetProcOrNil&<procedure(n: Int32; var ids: gl_transform_feedback)>(z_DeleteTransformFeedbacks_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTransformFeedbacks(n: Int32; ids: array of gl_transform_feedback);
    type Pgl_transform_feedback=^gl_transform_feedback;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        z_DeleteTransformFeedbacks_2(n, ids[0]) else
        z_DeleteTransformFeedbacks_2(n, Pgl_transform_feedback(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTransformFeedbacks(n: Int32; var ids: gl_transform_feedback) :=
    z_DeleteTransformFeedbacks_2(n, ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTransformFeedbacks(n: Int32; ids: IntPtr) :=
    z_DeleteTransformFeedbacks_1(n, ids);
    
    // added in gl3.0
    private z_DeleteVertexArrays_adr := GetProcAddress('glDeleteVertexArrays');
    private z_DeleteVertexArrays_1 := GetProcOrNil&<procedure(n: Int32; arrays: IntPtr)>(z_DeleteVertexArrays_adr);
    private z_DeleteVertexArrays_2 := GetProcOrNil&<procedure(n: Int32; var arrays: gl_vertex_array)>(z_DeleteVertexArrays_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteVertexArrays(n: Int32; arrays: array of gl_vertex_array);
    type Pgl_vertex_array=^gl_vertex_array;
    begin
      if (arrays<>nil) and (arrays.Length<>0) then
        z_DeleteVertexArrays_2(n, arrays[0]) else
        z_DeleteVertexArrays_2(n, Pgl_vertex_array(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteVertexArrays(n: Int32; var arrays: gl_vertex_array) :=
    z_DeleteVertexArrays_2(n, arrays);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteVertexArrays(n: Int32; arrays: IntPtr) :=
    z_DeleteVertexArrays_1(n, arrays);
    
    // added in gl1.0
    private z_DepthFunc_adr := GetProcAddress('glDepthFunc');
    private z_DepthFunc_1 := GetProcOrNil&<procedure(func: DepthFunction)>(z_DepthFunc_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthFunc(func: DepthFunction) :=
    z_DepthFunc_1(func);
    
    // added in gl1.0
    private z_DepthMask_adr := GetProcAddress('glDepthMask');
    private z_DepthMask_1 := GetProcOrNil&<procedure(flag: boolean)>(z_DepthMask_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthMask(flag: boolean) :=
    z_DepthMask_1(flag);
    
    // added in gl1.0
    private z_DepthRange_adr := GetProcAddress('glDepthRange');
    private z_DepthRange_1 := GetProcOrNil&<procedure(n: real; f: real)>(z_DepthRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRange(n: real; f: real) :=
    z_DepthRange_1(n, f);
    
    // added in gl4.1
    private z_DepthRangeArrayv_adr := GetProcAddress('glDepthRangeArrayv');
    private z_DepthRangeArrayv_1 := GetProcOrNil&<procedure(first: UInt32; count: Int32; v: IntPtr)>(z_DepthRangeArrayv_adr);
    private z_DepthRangeArrayv_2 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var v: real)>(z_DepthRangeArrayv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeArrayv(first: UInt32; count: Int32; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_DepthRangeArrayv_2(first, count, v[0]) else
        z_DepthRangeArrayv_2(first, count, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeArrayv(first: UInt32; count: Int32; var v: real) :=
    z_DepthRangeArrayv_2(first, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeArrayv(first: UInt32; count: Int32; v: IntPtr) :=
    z_DepthRangeArrayv_1(first, count, v);
    
    // added in gl4.1
    private z_DepthRangef_adr := GetProcAddress('glDepthRangef');
    private z_DepthRangef_1 := GetProcOrNil&<procedure(n: single; f: single)>(z_DepthRangef_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangef(n: single; f: single) :=
    z_DepthRangef_1(n, f);
    
    // added in gl4.1
    private z_DepthRangeIndexed_adr := GetProcAddress('glDepthRangeIndexed');
    private z_DepthRangeIndexed_1 := GetProcOrNil&<procedure(index: UInt32; n: real; f: real)>(z_DepthRangeIndexed_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeIndexed(index: UInt32; n: real; f: real) :=
    z_DepthRangeIndexed_1(index, n, f);
    
    // added in gl2.0
    private z_DetachShader_adr := GetProcAddress('glDetachShader');
    private z_DetachShader_1 := GetProcOrNil&<procedure(&program: gl_program; shader: gl_shader)>(z_DetachShader_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DetachShader(&program: gl_program; shader: gl_shader) :=
    z_DetachShader_1(&program, shader);
    
    // added in gl1.0
    private z_Disable_adr := GetProcAddress('glDisable');
    private z_Disable_1 := GetProcOrNil&<procedure(cap: EnableCap)>(z_Disable_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Disable(cap: EnableCap) :=
    z_Disable_1(cap);
    
    // added in gl3.0
    private z_Disablei_adr := GetProcAddress('glDisablei');
    private z_Disablei_1 := GetProcOrNil&<procedure(target: EnableCap; index: UInt32)>(z_Disablei_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Disablei(target: EnableCap; index: UInt32) :=
    z_Disablei_1(target, index);
    
    // added in gl4.5
    private z_DisableVertexArrayAttrib_adr := GetProcAddress('glDisableVertexArrayAttrib');
    private z_DisableVertexArrayAttrib_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32)>(z_DisableVertexArrayAttrib_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableVertexArrayAttrib(vaobj: gl_vertex_array; index: UInt32) :=
    z_DisableVertexArrayAttrib_1(vaobj, index);
    
    // added in gl2.0
    private z_DisableVertexAttribArray_adr := GetProcAddress('glDisableVertexAttribArray');
    private z_DisableVertexAttribArray_1 := GetProcOrNil&<procedure(index: UInt32)>(z_DisableVertexAttribArray_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableVertexAttribArray(index: UInt32) :=
    z_DisableVertexAttribArray_1(index);
    
    // added in gl4.3
    private z_DispatchCompute_adr := GetProcAddress('glDispatchCompute');
    private z_DispatchCompute_1 := GetProcOrNil&<procedure(num_groups_x: UInt32; num_groups_y: UInt32; num_groups_z: UInt32)>(z_DispatchCompute_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DispatchCompute(num_groups_x: UInt32; num_groups_y: UInt32; num_groups_z: UInt32) :=
    z_DispatchCompute_1(num_groups_x, num_groups_y, num_groups_z);
    
    // added in gl4.3
    private z_DispatchComputeIndirect_adr := GetProcAddress('glDispatchComputeIndirect');
    private z_DispatchComputeIndirect_1 := GetProcOrNil&<procedure(indirect: IntPtr)>(z_DispatchComputeIndirect_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DispatchComputeIndirect(indirect: IntPtr) :=
    z_DispatchComputeIndirect_1(indirect);
    
    // added in gl1.1
    private z_DrawArrays_adr := GetProcAddress('glDrawArrays');
    private z_DrawArrays_1 := GetProcOrNil&<procedure(mode: PrimitiveType; first: Int32; count: Int32)>(z_DrawArrays_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawArrays(mode: PrimitiveType; first: Int32; count: Int32) :=
    z_DrawArrays_1(mode, first, count);
    
    // added in gl4.0
    private z_DrawArraysIndirect_adr := GetProcAddress('glDrawArraysIndirect');
    private z_DrawArraysIndirect_1 := GetProcOrNil&<procedure(mode: PrimitiveType; indirect: IntPtr)>(z_DrawArraysIndirect_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawArraysIndirect(mode: PrimitiveType; indirect: IntPtr) :=
    z_DrawArraysIndirect_1(mode, indirect);
    
    // added in gl3.1
    private z_DrawArraysInstanced_adr := GetProcAddress('glDrawArraysInstanced');
    private z_DrawArraysInstanced_1 := GetProcOrNil&<procedure(mode: PrimitiveType; first: Int32; count: Int32; instancecount: Int32)>(z_DrawArraysInstanced_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawArraysInstanced(mode: PrimitiveType; first: Int32; count: Int32; instancecount: Int32) :=
    z_DrawArraysInstanced_1(mode, first, count, instancecount);
    
    // added in gl4.2
    private z_DrawArraysInstancedBaseInstance_adr := GetProcAddress('glDrawArraysInstancedBaseInstance');
    private z_DrawArraysInstancedBaseInstance_1 := GetProcOrNil&<procedure(mode: PrimitiveType; first: Int32; count: Int32; instancecount: Int32; baseinstance: UInt32)>(z_DrawArraysInstancedBaseInstance_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawArraysInstancedBaseInstance(mode: PrimitiveType; first: Int32; count: Int32; instancecount: Int32; baseinstance: UInt32) :=
    z_DrawArraysInstancedBaseInstance_1(mode, first, count, instancecount, baseinstance);
    
    // added in gl1.0
    private z_DrawBuffer_adr := GetProcAddress('glDrawBuffer');
    private z_DrawBuffer_1 := GetProcOrNil&<procedure(buf: DrawBufferMode)>(z_DrawBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffer(buf: DrawBufferMode) :=
    z_DrawBuffer_1(buf);
    
    // added in gl2.0
    private z_DrawBuffers_adr := GetProcAddress('glDrawBuffers');
    private z_DrawBuffers_1 := GetProcOrNil&<procedure(n: Int32; bufs: IntPtr)>(z_DrawBuffers_adr);
    private z_DrawBuffers_2 := GetProcOrNil&<procedure(n: Int32; var bufs: DrawBufferMode)>(z_DrawBuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffers(n: Int32; bufs: array of DrawBufferMode);
    type PDrawBufferMode=^DrawBufferMode;
    begin
      if (bufs<>nil) and (bufs.Length<>0) then
        z_DrawBuffers_2(n, bufs[0]) else
        z_DrawBuffers_2(n, PDrawBufferMode(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffers(n: Int32; var bufs: DrawBufferMode) :=
    z_DrawBuffers_2(n, bufs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffers(n: Int32; bufs: IntPtr) :=
    z_DrawBuffers_1(n, bufs);
    
    // added in gl1.1
    private z_DrawElements_adr := GetProcAddress('glDrawElements');
    private z_DrawElements_1 := GetProcOrNil&<procedure(mode: PrimitiveType; count: Int32; &type: DrawElementsType; indices: IntPtr)>(z_DrawElements_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElements(mode: PrimitiveType; count: Int32; &type: DrawElementsType; indices: IntPtr) :=
    z_DrawElements_1(mode, count, &type, indices);
    
    // added in gl3.2
    private z_DrawElementsBaseVertex_adr := GetProcAddress('glDrawElementsBaseVertex');
    private z_DrawElementsBaseVertex_1 := GetProcOrNil&<procedure(mode: PrimitiveType; count: Int32; &type: DrawElementsType; indices: IntPtr; basevertex: Int32)>(z_DrawElementsBaseVertex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsBaseVertex(mode: PrimitiveType; count: Int32; &type: DrawElementsType; indices: IntPtr; basevertex: Int32) :=
    z_DrawElementsBaseVertex_1(mode, count, &type, indices, basevertex);
    
    // added in gl4.0
    private z_DrawElementsIndirect_adr := GetProcAddress('glDrawElementsIndirect');
    private z_DrawElementsIndirect_1 := GetProcOrNil&<procedure(mode: PrimitiveType; &type: DrawElementsType; indirect: IntPtr)>(z_DrawElementsIndirect_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsIndirect(mode: PrimitiveType; &type: DrawElementsType; indirect: IntPtr) :=
    z_DrawElementsIndirect_1(mode, &type, indirect);
    
    // added in gl3.1
    private z_DrawElementsInstanced_adr := GetProcAddress('glDrawElementsInstanced');
    private z_DrawElementsInstanced_1 := GetProcOrNil&<procedure(mode: PrimitiveType; count: Int32; &type: DrawElementsType; indices: IntPtr; instancecount: Int32)>(z_DrawElementsInstanced_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstanced(mode: PrimitiveType; count: Int32; &type: DrawElementsType; indices: IntPtr; instancecount: Int32) :=
    z_DrawElementsInstanced_1(mode, count, &type, indices, instancecount);
    
    // added in gl4.2
    private z_DrawElementsInstancedBaseInstance_adr := GetProcAddress('glDrawElementsInstancedBaseInstance');
    private z_DrawElementsInstancedBaseInstance_1 := GetProcOrNil&<procedure(mode: PrimitiveType; count: Int32; &type: PrimitiveType; indices: IntPtr; instancecount: Int32; baseinstance: UInt32)>(z_DrawElementsInstancedBaseInstance_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedBaseInstance(mode: PrimitiveType; count: Int32; &type: PrimitiveType; indices: IntPtr; instancecount: Int32; baseinstance: UInt32) :=
    z_DrawElementsInstancedBaseInstance_1(mode, count, &type, indices, instancecount, baseinstance);
    
    // added in gl3.2
    private z_DrawElementsInstancedBaseVertex_adr := GetProcAddress('glDrawElementsInstancedBaseVertex');
    private z_DrawElementsInstancedBaseVertex_1 := GetProcOrNil&<procedure(mode: PrimitiveType; count: Int32; &type: DrawElementsType; indices: IntPtr; instancecount: Int32; basevertex: Int32)>(z_DrawElementsInstancedBaseVertex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedBaseVertex(mode: PrimitiveType; count: Int32; &type: DrawElementsType; indices: IntPtr; instancecount: Int32; basevertex: Int32) :=
    z_DrawElementsInstancedBaseVertex_1(mode, count, &type, indices, instancecount, basevertex);
    
    // added in gl4.2
    private z_DrawElementsInstancedBaseVertexBaseInstance_adr := GetProcAddress('glDrawElementsInstancedBaseVertexBaseInstance');
    private z_DrawElementsInstancedBaseVertexBaseInstance_1 := GetProcOrNil&<procedure(mode: PrimitiveType; count: Int32; &type: DrawElementsType; indices: IntPtr; instancecount: Int32; basevertex: Int32; baseinstance: UInt32)>(z_DrawElementsInstancedBaseVertexBaseInstance_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedBaseVertexBaseInstance(mode: PrimitiveType; count: Int32; &type: DrawElementsType; indices: IntPtr; instancecount: Int32; basevertex: Int32; baseinstance: UInt32) :=
    z_DrawElementsInstancedBaseVertexBaseInstance_1(mode, count, &type, indices, instancecount, basevertex, baseinstance);
    
    // added in gl1.2
    private z_DrawRangeElements_adr := GetProcAddress('glDrawRangeElements');
    private z_DrawRangeElements_1 := GetProcOrNil&<procedure(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DrawElementsType; indices: IntPtr)>(z_DrawRangeElements_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawRangeElements(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DrawElementsType; indices: IntPtr) :=
    z_DrawRangeElements_1(mode, start, &end, count, &type, indices);
    
    // added in gl3.2
    private z_DrawRangeElementsBaseVertex_adr := GetProcAddress('glDrawRangeElementsBaseVertex');
    private z_DrawRangeElementsBaseVertex_1 := GetProcOrNil&<procedure(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DrawElementsType; indices: IntPtr; basevertex: Int32)>(z_DrawRangeElementsBaseVertex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawRangeElementsBaseVertex(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DrawElementsType; indices: IntPtr; basevertex: Int32) :=
    z_DrawRangeElementsBaseVertex_1(mode, start, &end, count, &type, indices, basevertex);
    
    // added in gl4.0
    private z_DrawTransformFeedback_adr := GetProcAddress('glDrawTransformFeedback');
    private z_DrawTransformFeedback_1 := GetProcOrNil&<procedure(mode: PrimitiveType; id: gl_transform_feedback)>(z_DrawTransformFeedback_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTransformFeedback(mode: PrimitiveType; id: gl_transform_feedback) :=
    z_DrawTransformFeedback_1(mode, id);
    
    // added in gl4.2
    private z_DrawTransformFeedbackInstanced_adr := GetProcAddress('glDrawTransformFeedbackInstanced');
    private z_DrawTransformFeedbackInstanced_1 := GetProcOrNil&<procedure(mode: PrimitiveType; id: gl_transform_feedback; instancecount: Int32)>(z_DrawTransformFeedbackInstanced_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTransformFeedbackInstanced(mode: PrimitiveType; id: gl_transform_feedback; instancecount: Int32) :=
    z_DrawTransformFeedbackInstanced_1(mode, id, instancecount);
    
    // added in gl4.0
    private z_DrawTransformFeedbackStream_adr := GetProcAddress('glDrawTransformFeedbackStream');
    private z_DrawTransformFeedbackStream_1 := GetProcOrNil&<procedure(mode: PrimitiveType; id: gl_transform_feedback; stream: UInt32)>(z_DrawTransformFeedbackStream_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTransformFeedbackStream(mode: PrimitiveType; id: gl_transform_feedback; stream: UInt32) :=
    z_DrawTransformFeedbackStream_1(mode, id, stream);
    
    // added in gl4.2
    private z_DrawTransformFeedbackStreamInstanced_adr := GetProcAddress('glDrawTransformFeedbackStreamInstanced');
    private z_DrawTransformFeedbackStreamInstanced_1 := GetProcOrNil&<procedure(mode: PrimitiveType; id: gl_transform_feedback; stream: UInt32; instancecount: Int32)>(z_DrawTransformFeedbackStreamInstanced_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTransformFeedbackStreamInstanced(mode: PrimitiveType; id: gl_transform_feedback; stream: UInt32; instancecount: Int32) :=
    z_DrawTransformFeedbackStreamInstanced_1(mode, id, stream, instancecount);
    
    // added in gl1.0
    private z_Enable_adr := GetProcAddress('glEnable');
    private z_Enable_1 := GetProcOrNil&<procedure(cap: EnableCap)>(z_Enable_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Enable(cap: EnableCap) :=
    z_Enable_1(cap);
    
    // added in gl3.0
    private z_Enablei_adr := GetProcAddress('glEnablei');
    private z_Enablei_1 := GetProcOrNil&<procedure(target: EnableCap; index: UInt32)>(z_Enablei_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Enablei(target: EnableCap; index: UInt32) :=
    z_Enablei_1(target, index);
    
    // added in gl4.5
    private z_EnableVertexArrayAttrib_adr := GetProcAddress('glEnableVertexArrayAttrib');
    private z_EnableVertexArrayAttrib_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32)>(z_EnableVertexArrayAttrib_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableVertexArrayAttrib(vaobj: gl_vertex_array; index: UInt32) :=
    z_EnableVertexArrayAttrib_1(vaobj, index);
    
    // added in gl2.0
    private z_EnableVertexAttribArray_adr := GetProcAddress('glEnableVertexAttribArray');
    private z_EnableVertexAttribArray_1 := GetProcOrNil&<procedure(index: UInt32)>(z_EnableVertexAttribArray_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableVertexAttribArray(index: UInt32) :=
    z_EnableVertexAttribArray_1(index);
    
    // added in gl3.0
    private z_EndConditionalRender_adr := GetProcAddress('glEndConditionalRender');
    private z_EndConditionalRender_1 := GetProcOrNil&<procedure>(z_EndConditionalRender_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndConditionalRender :=
    z_EndConditionalRender_1();
    
    // added in gl1.5
    private z_EndQuery_adr := GetProcAddress('glEndQuery');
    private z_EndQuery_1 := GetProcOrNil&<procedure(target: QueryTarget)>(z_EndQuery_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndQuery(target: QueryTarget) :=
    z_EndQuery_1(target);
    
    // added in gl4.0
    private z_EndQueryIndexed_adr := GetProcAddress('glEndQueryIndexed');
    private z_EndQueryIndexed_1 := GetProcOrNil&<procedure(target: QueryTarget; index: UInt32)>(z_EndQueryIndexed_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndQueryIndexed(target: QueryTarget; index: UInt32) :=
    z_EndQueryIndexed_1(target, index);
    
    // added in gl3.0
    private z_EndTransformFeedback_adr := GetProcAddress('glEndTransformFeedback');
    private z_EndTransformFeedback_1 := GetProcOrNil&<procedure>(z_EndTransformFeedback_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndTransformFeedback :=
    z_EndTransformFeedback_1();
    
    // added in gl3.2
    private z_FenceSync_adr := GetProcAddress('glFenceSync');
    private z_FenceSync_1 := GetProcOrNil&<function(condition: SyncCondition; flags: DummyFlags): gl_sync>(z_FenceSync_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function FenceSync(condition: SyncCondition; flags: DummyFlags): gl_sync :=
    z_FenceSync_1(condition, flags);
    
    // added in gl1.0
    private z_Finish_adr := GetProcAddress('glFinish');
    private z_Finish_1 := GetProcOrNil&<procedure>(z_Finish_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Finish :=
    z_Finish_1();
    
    // added in gl1.0
    private z_Flush_adr := GetProcAddress('glFlush');
    private z_Flush_1 := GetProcOrNil&<procedure>(z_Flush_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Flush :=
    z_Flush_1();
    
    // added in gl3.0
    private z_FlushMappedBufferRange_adr := GetProcAddress('glFlushMappedBufferRange');
    private z_FlushMappedBufferRange_1 := GetProcOrNil&<procedure(target: BufferTarget; offset: IntPtr; length: UIntPtr)>(z_FlushMappedBufferRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FlushMappedBufferRange(target: BufferTarget; offset: IntPtr; length: UIntPtr) :=
    z_FlushMappedBufferRange_1(target, offset, length);
    
    // added in gl4.5
    private z_FlushMappedNamedBufferRange_adr := GetProcAddress('glFlushMappedNamedBufferRange');
    private z_FlushMappedNamedBufferRange_1 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; length: UIntPtr)>(z_FlushMappedNamedBufferRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FlushMappedNamedBufferRange(buffer: gl_buffer; offset: IntPtr; length: UIntPtr) :=
    z_FlushMappedNamedBufferRange_1(buffer, offset, length);
    
    // added in gl4.3
    private z_FramebufferParameteri_adr := GetProcAddress('glFramebufferParameteri');
    private z_FramebufferParameteri_1 := GetProcOrNil&<procedure(target: FramebufferTarget; pname: FramebufferParameterName; param: Int32)>(z_FramebufferParameteri_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferParameteri(target: FramebufferTarget; pname: FramebufferParameterName; param: Int32) :=
    z_FramebufferParameteri_1(target, pname, param);
    
    // added in gl3.0
    private z_FramebufferRenderbuffer_adr := GetProcAddress('glFramebufferRenderbuffer');
    private z_FramebufferRenderbuffer_1 := GetProcOrNil&<procedure(target: FramebufferTarget; attachment: FramebufferAttachment; _renderbuffertarget: RenderbufferTarget; renderbuffer: gl_renderbuffer)>(z_FramebufferRenderbuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferRenderbuffer(target: FramebufferTarget; attachment: FramebufferAttachment; _renderbuffertarget: RenderbufferTarget; renderbuffer: gl_renderbuffer) :=
    z_FramebufferRenderbuffer_1(target, attachment, _renderbuffertarget, renderbuffer);
    
    // added in gl3.2
    private z_FramebufferTexture_adr := GetProcAddress('glFramebufferTexture');
    private z_FramebufferTexture_1 := GetProcOrNil&<procedure(target: FramebufferTarget; attachment: FramebufferAttachment; texture: gl_texture; level: Int32)>(z_FramebufferTexture_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTexture(target: FramebufferTarget; attachment: FramebufferAttachment; texture: gl_texture; level: Int32) :=
    z_FramebufferTexture_1(target, attachment, texture, level);
    
    // added in gl3.0
    private z_FramebufferTexture1D_adr := GetProcAddress('glFramebufferTexture1D');
    private z_FramebufferTexture1D_1 := GetProcOrNil&<procedure(target: FramebufferTarget; attachment: FramebufferAttachment; textarget: TextureTarget; texture: gl_texture; level: Int32)>(z_FramebufferTexture1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTexture1D(target: FramebufferTarget; attachment: FramebufferAttachment; textarget: TextureTarget; texture: gl_texture; level: Int32) :=
    z_FramebufferTexture1D_1(target, attachment, textarget, texture, level);
    
    // added in gl3.0
    private z_FramebufferTexture2D_adr := GetProcAddress('glFramebufferTexture2D');
    private z_FramebufferTexture2D_1 := GetProcOrNil&<procedure(target: FramebufferTarget; attachment: FramebufferAttachment; textarget: TextureTarget; texture: gl_texture; level: Int32)>(z_FramebufferTexture2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTexture2D(target: FramebufferTarget; attachment: FramebufferAttachment; textarget: TextureTarget; texture: gl_texture; level: Int32) :=
    z_FramebufferTexture2D_1(target, attachment, textarget, texture, level);
    
    // added in gl3.0
    private z_FramebufferTexture3D_adr := GetProcAddress('glFramebufferTexture3D');
    private z_FramebufferTexture3D_1 := GetProcOrNil&<procedure(target: FramebufferTarget; attachment: FramebufferAttachment; textarget: TextureTarget; texture: gl_texture; level: Int32; zoffset: Int32)>(z_FramebufferTexture3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTexture3D(target: FramebufferTarget; attachment: FramebufferAttachment; textarget: TextureTarget; texture: gl_texture; level: Int32; zoffset: Int32) :=
    z_FramebufferTexture3D_1(target, attachment, textarget, texture, level, zoffset);
    
    // added in gl3.0
    private z_FramebufferTextureLayer_adr := GetProcAddress('glFramebufferTextureLayer');
    private z_FramebufferTextureLayer_1 := GetProcOrNil&<procedure(target: FramebufferTarget; attachment: FramebufferAttachment; texture: gl_texture; level: Int32; layer: Int32)>(z_FramebufferTextureLayer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTextureLayer(target: FramebufferTarget; attachment: FramebufferAttachment; texture: gl_texture; level: Int32; layer: Int32) :=
    z_FramebufferTextureLayer_1(target, attachment, texture, level, layer);
    
    // added in gl1.0
    private z_FrontFace_adr := GetProcAddress('glFrontFace');
    private z_FrontFace_1 := GetProcOrNil&<procedure(mode: FrontFaceDirection)>(z_FrontFace_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FrontFace(mode: FrontFaceDirection) :=
    z_FrontFace_1(mode);
    
    // added in gl1.5
    private z_GenBuffers_adr := GetProcAddress('glGenBuffers');
    private z_GenBuffers_1 := GetProcOrNil&<procedure(n: Int32; buffers: IntPtr)>(z_GenBuffers_adr);
    private z_GenBuffers_2 := GetProcOrNil&<procedure(n: Int32; var buffers: gl_buffer)>(z_GenBuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenBuffers(n: Int32; buffers: array of gl_buffer);
    type Pgl_buffer=^gl_buffer;
    begin
      if (buffers<>nil) and (buffers.Length<>0) then
        z_GenBuffers_2(n, buffers[0]) else
        z_GenBuffers_2(n, Pgl_buffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenBuffers(n: Int32; var buffers: gl_buffer) :=
    z_GenBuffers_2(n, buffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenBuffers(n: Int32; buffers: IntPtr) :=
    z_GenBuffers_1(n, buffers);
    
    // added in gl3.0
    private z_GenerateMipmap_adr := GetProcAddress('glGenerateMipmap');
    private z_GenerateMipmap_1 := GetProcOrNil&<procedure(target: TextureTarget)>(z_GenerateMipmap_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenerateMipmap(target: TextureTarget) :=
    z_GenerateMipmap_1(target);
    
    // added in gl4.5
    private z_GenerateTextureMipmap_adr := GetProcAddress('glGenerateTextureMipmap');
    private z_GenerateTextureMipmap_1 := GetProcOrNil&<procedure(texture: gl_texture)>(z_GenerateTextureMipmap_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenerateTextureMipmap(texture: gl_texture) :=
    z_GenerateTextureMipmap_1(texture);
    
    // added in gl3.0
    private z_GenFramebuffers_adr := GetProcAddress('glGenFramebuffers');
    private z_GenFramebuffers_1 := GetProcOrNil&<procedure(n: Int32; framebuffers: IntPtr)>(z_GenFramebuffers_adr);
    private z_GenFramebuffers_2 := GetProcOrNil&<procedure(n: Int32; var framebuffers: gl_framebuffer)>(z_GenFramebuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFramebuffers(n: Int32; framebuffers: array of gl_framebuffer);
    type Pgl_framebuffer=^gl_framebuffer;
    begin
      if (framebuffers<>nil) and (framebuffers.Length<>0) then
        z_GenFramebuffers_2(n, framebuffers[0]) else
        z_GenFramebuffers_2(n, Pgl_framebuffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFramebuffers(n: Int32; var framebuffers: gl_framebuffer) :=
    z_GenFramebuffers_2(n, framebuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFramebuffers(n: Int32; framebuffers: IntPtr) :=
    z_GenFramebuffers_1(n, framebuffers);
    
    // added in gl4.1
    private z_GenProgramPipelines_adr := GetProcAddress('glGenProgramPipelines');
    private z_GenProgramPipelines_1 := GetProcOrNil&<procedure(n: Int32; pipelines: IntPtr)>(z_GenProgramPipelines_adr);
    private z_GenProgramPipelines_2 := GetProcOrNil&<procedure(n: Int32; var pipelines: gl_program_pipeline)>(z_GenProgramPipelines_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramPipelines(n: Int32; pipelines: array of gl_program_pipeline);
    type Pgl_program_pipeline=^gl_program_pipeline;
    begin
      if (pipelines<>nil) and (pipelines.Length<>0) then
        z_GenProgramPipelines_2(n, pipelines[0]) else
        z_GenProgramPipelines_2(n, Pgl_program_pipeline(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramPipelines(n: Int32; var pipelines: gl_program_pipeline) :=
    z_GenProgramPipelines_2(n, pipelines);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramPipelines(n: Int32; pipelines: IntPtr) :=
    z_GenProgramPipelines_1(n, pipelines);
    
    // added in gl1.5
    private z_GenQueries_adr := GetProcAddress('glGenQueries');
    private z_GenQueries_1 := GetProcOrNil&<procedure(n: Int32; ids: IntPtr)>(z_GenQueries_adr);
    private z_GenQueries_2 := GetProcOrNil&<procedure(n: Int32; var ids: gl_query)>(z_GenQueries_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenQueries(n: Int32; ids: array of gl_query);
    type Pgl_query=^gl_query;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        z_GenQueries_2(n, ids[0]) else
        z_GenQueries_2(n, Pgl_query(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenQueries(n: Int32; var ids: gl_query) :=
    z_GenQueries_2(n, ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenQueries(n: Int32; ids: IntPtr) :=
    z_GenQueries_1(n, ids);
    
    // added in gl3.0
    private z_GenRenderbuffers_adr := GetProcAddress('glGenRenderbuffers');
    private z_GenRenderbuffers_1 := GetProcOrNil&<procedure(n: Int32; renderbuffers: IntPtr)>(z_GenRenderbuffers_adr);
    private z_GenRenderbuffers_2 := GetProcOrNil&<procedure(n: Int32; var renderbuffers: gl_renderbuffer)>(z_GenRenderbuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenRenderbuffers(n: Int32; renderbuffers: array of gl_renderbuffer);
    type Pgl_renderbuffer=^gl_renderbuffer;
    begin
      if (renderbuffers<>nil) and (renderbuffers.Length<>0) then
        z_GenRenderbuffers_2(n, renderbuffers[0]) else
        z_GenRenderbuffers_2(n, Pgl_renderbuffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenRenderbuffers(n: Int32; var renderbuffers: gl_renderbuffer) :=
    z_GenRenderbuffers_2(n, renderbuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenRenderbuffers(n: Int32; renderbuffers: IntPtr) :=
    z_GenRenderbuffers_1(n, renderbuffers);
    
    // added in gl3.3
    private z_GenSamplers_adr := GetProcAddress('glGenSamplers');
    private z_GenSamplers_1 := GetProcOrNil&<procedure(count: Int32; samplers: IntPtr)>(z_GenSamplers_adr);
    private z_GenSamplers_2 := GetProcOrNil&<procedure(count: Int32; var samplers: gl_sampler)>(z_GenSamplers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenSamplers(count: Int32; samplers: array of gl_sampler);
    type Pgl_sampler=^gl_sampler;
    begin
      if (samplers<>nil) and (samplers.Length<>0) then
        z_GenSamplers_2(count, samplers[0]) else
        z_GenSamplers_2(count, Pgl_sampler(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenSamplers(count: Int32; var samplers: gl_sampler) :=
    z_GenSamplers_2(count, samplers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenSamplers(count: Int32; samplers: IntPtr) :=
    z_GenSamplers_1(count, samplers);
    
    // added in gl1.1
    private z_GenTextures_adr := GetProcAddress('glGenTextures');
    private z_GenTextures_1 := GetProcOrNil&<procedure(n: Int32; textures: IntPtr)>(z_GenTextures_adr);
    private z_GenTextures_2 := GetProcOrNil&<procedure(n: Int32; var textures: gl_texture)>(z_GenTextures_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTextures(n: Int32; textures: array of gl_texture);
    type Pgl_texture=^gl_texture;
    begin
      if (textures<>nil) and (textures.Length<>0) then
        z_GenTextures_2(n, textures[0]) else
        z_GenTextures_2(n, Pgl_texture(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTextures(n: Int32; var textures: gl_texture) :=
    z_GenTextures_2(n, textures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTextures(n: Int32; textures: IntPtr) :=
    z_GenTextures_1(n, textures);
    
    // added in gl4.0
    private z_GenTransformFeedbacks_adr := GetProcAddress('glGenTransformFeedbacks');
    private z_GenTransformFeedbacks_1 := GetProcOrNil&<procedure(n: Int32; ids: IntPtr)>(z_GenTransformFeedbacks_adr);
    private z_GenTransformFeedbacks_2 := GetProcOrNil&<procedure(n: Int32; var ids: gl_transform_feedback)>(z_GenTransformFeedbacks_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTransformFeedbacks(n: Int32; ids: array of gl_transform_feedback);
    type Pgl_transform_feedback=^gl_transform_feedback;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        z_GenTransformFeedbacks_2(n, ids[0]) else
        z_GenTransformFeedbacks_2(n, Pgl_transform_feedback(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTransformFeedbacks(n: Int32; var ids: gl_transform_feedback) :=
    z_GenTransformFeedbacks_2(n, ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTransformFeedbacks(n: Int32; ids: IntPtr) :=
    z_GenTransformFeedbacks_1(n, ids);
    
    // added in gl3.0
    private z_GenVertexArrays_adr := GetProcAddress('glGenVertexArrays');
    private z_GenVertexArrays_1 := GetProcOrNil&<procedure(n: Int32; arrays: IntPtr)>(z_GenVertexArrays_adr);
    private z_GenVertexArrays_2 := GetProcOrNil&<procedure(n: Int32; var arrays: gl_vertex_array)>(z_GenVertexArrays_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenVertexArrays(n: Int32; arrays: array of gl_vertex_array);
    type Pgl_vertex_array=^gl_vertex_array;
    begin
      if (arrays<>nil) and (arrays.Length<>0) then
        z_GenVertexArrays_2(n, arrays[0]) else
        z_GenVertexArrays_2(n, Pgl_vertex_array(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenVertexArrays(n: Int32; var arrays: gl_vertex_array) :=
    z_GenVertexArrays_2(n, arrays);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenVertexArrays(n: Int32; arrays: IntPtr) :=
    z_GenVertexArrays_1(n, arrays);
    
    // added in gl4.2
    private z_GetActiveAtomicCounterBufferiv_adr := GetProcAddress('glGetActiveAtomicCounterBufferiv');
    private z_GetActiveAtomicCounterBufferiv_1 := GetProcOrNil&<procedure(&program: gl_program; bufferIndex: UInt32; pname: AtomicCounterBufferPName; &params: IntPtr)>(z_GetActiveAtomicCounterBufferiv_adr);
    private z_GetActiveAtomicCounterBufferiv_2 := GetProcOrNil&<procedure(&program: gl_program; bufferIndex: UInt32; pname: AtomicCounterBufferPName; var &params: Int32)>(z_GetActiveAtomicCounterBufferiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAtomicCounterBufferiv(&program: gl_program; bufferIndex: UInt32; pname: AtomicCounterBufferPName; var &params: Int32) :=
    z_GetActiveAtomicCounterBufferiv_2(&program, bufferIndex, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAtomicCounterBufferiv(&program: gl_program; bufferIndex: UInt32; pname: AtomicCounterBufferPName; &params: IntPtr) :=
    z_GetActiveAtomicCounterBufferiv_1(&program, bufferIndex, pname, &params);
    
    // added in gl2.0
    private z_GetActiveAttrib_adr := GetProcAddress('glGetActiveAttrib');
    private z_GetActiveAttrib_1 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; &type: IntPtr; name: IntPtr)>(z_GetActiveAttrib_adr);
    private z_GetActiveAttrib_2 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; var &type: AttributeType; name: IntPtr)>(z_GetActiveAttrib_adr);
    private z_GetActiveAttrib_3 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; &type: IntPtr; name: IntPtr)>(z_GetActiveAttrib_adr);
    private z_GetActiveAttrib_4 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; var &type: AttributeType; name: IntPtr)>(z_GetActiveAttrib_adr);
    private z_GetActiveAttrib_5 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; &type: IntPtr; name: IntPtr)>(z_GetActiveAttrib_adr);
    private z_GetActiveAttrib_6 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; var &type: AttributeType; name: IntPtr)>(z_GetActiveAttrib_adr);
    private z_GetActiveAttrib_7 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: IntPtr; name: IntPtr)>(z_GetActiveAttrib_adr);
    private z_GetActiveAttrib_8 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: AttributeType; name: IntPtr)>(z_GetActiveAttrib_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttrib(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: AttributeType; name: IntPtr) :=
    z_GetActiveAttrib_8(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttrib(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: IntPtr; name: IntPtr) :=
    z_GetActiveAttrib_7(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttrib(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; var &type: AttributeType; name: IntPtr) :=
    z_GetActiveAttrib_6(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttrib(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; &type: IntPtr; name: IntPtr) :=
    z_GetActiveAttrib_5(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttrib(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; var &type: AttributeType; name: IntPtr) :=
    z_GetActiveAttrib_4(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttrib(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; &type: IntPtr; name: IntPtr) :=
    z_GetActiveAttrib_3(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttrib(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; var &type: AttributeType; name: IntPtr) :=
    z_GetActiveAttrib_2(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttrib(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; &type: IntPtr; name: IntPtr) :=
    z_GetActiveAttrib_1(&program, index, bufSize, length, size, &type, name);
    
    // added in gl4.0
    private z_GetActiveSubroutineName_adr := GetProcAddress('glGetActiveSubroutineName');
    private z_GetActiveSubroutineName_1 := GetProcOrNil&<procedure(&program: gl_program; _shadertype: ShaderType; index: UInt32; bufSize: Int32; length: IntPtr; name: IntPtr)>(z_GetActiveSubroutineName_adr);
    private z_GetActiveSubroutineName_2 := GetProcOrNil&<procedure(&program: gl_program; _shadertype: ShaderType; index: UInt32; bufSize: Int32; var length: Int32; name: IntPtr)>(z_GetActiveSubroutineName_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveSubroutineName(&program: gl_program; _shadertype: ShaderType; index: UInt32; bufSize: Int32; var length: Int32; name: IntPtr) :=
    z_GetActiveSubroutineName_2(&program, _shadertype, index, bufSize, length, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveSubroutineName(&program: gl_program; _shadertype: ShaderType; index: UInt32; bufSize: Int32; length: IntPtr; name: IntPtr) :=
    z_GetActiveSubroutineName_1(&program, _shadertype, index, bufSize, length, name);
    
    // added in gl4.0
    private z_GetActiveSubroutineUniformiv_adr := GetProcAddress('glGetActiveSubroutineUniformiv');
    private z_GetActiveSubroutineUniformiv_1 := GetProcOrNil&<procedure(&program: gl_program; _shadertype: ShaderType; index: UInt32; pname: SubroutineParameterName; values: IntPtr)>(z_GetActiveSubroutineUniformiv_adr);
    private z_GetActiveSubroutineUniformiv_2 := GetProcOrNil&<procedure(&program: gl_program; _shadertype: ShaderType; index: UInt32; pname: SubroutineParameterName; var values: Int32)>(z_GetActiveSubroutineUniformiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveSubroutineUniformiv(&program: gl_program; _shadertype: ShaderType; index: UInt32; pname: SubroutineParameterName; var values: Int32) :=
    z_GetActiveSubroutineUniformiv_2(&program, _shadertype, index, pname, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveSubroutineUniformiv(&program: gl_program; _shadertype: ShaderType; index: UInt32; pname: SubroutineParameterName; values: IntPtr) :=
    z_GetActiveSubroutineUniformiv_1(&program, _shadertype, index, pname, values);
    
    // added in gl4.0
    private z_GetActiveSubroutineUniformName_adr := GetProcAddress('glGetActiveSubroutineUniformName');
    private z_GetActiveSubroutineUniformName_1 := GetProcOrNil&<procedure(&program: gl_program; _shadertype: ShaderType; index: UInt32; bufSize: Int32; length: IntPtr; name: IntPtr)>(z_GetActiveSubroutineUniformName_adr);
    private z_GetActiveSubroutineUniformName_2 := GetProcOrNil&<procedure(&program: gl_program; _shadertype: ShaderType; index: UInt32; bufSize: Int32; var length: Int32; name: IntPtr)>(z_GetActiveSubroutineUniformName_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveSubroutineUniformName(&program: gl_program; _shadertype: ShaderType; index: UInt32; bufSize: Int32; var length: Int32; name: IntPtr) :=
    z_GetActiveSubroutineUniformName_2(&program, _shadertype, index, bufSize, length, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveSubroutineUniformName(&program: gl_program; _shadertype: ShaderType; index: UInt32; bufSize: Int32; length: IntPtr; name: IntPtr) :=
    z_GetActiveSubroutineUniformName_1(&program, _shadertype, index, bufSize, length, name);
    
    // added in gl2.0
    private z_GetActiveUniform_adr := GetProcAddress('glGetActiveUniform');
    private z_GetActiveUniform_1 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; &type: IntPtr; name: IntPtr)>(z_GetActiveUniform_adr);
    private z_GetActiveUniform_2 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; var &type: UniformType; name: IntPtr)>(z_GetActiveUniform_adr);
    private z_GetActiveUniform_3 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; &type: IntPtr; name: IntPtr)>(z_GetActiveUniform_adr);
    private z_GetActiveUniform_4 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; var &type: UniformType; name: IntPtr)>(z_GetActiveUniform_adr);
    private z_GetActiveUniform_5 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; &type: IntPtr; name: IntPtr)>(z_GetActiveUniform_adr);
    private z_GetActiveUniform_6 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; var &type: UniformType; name: IntPtr)>(z_GetActiveUniform_adr);
    private z_GetActiveUniform_7 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: IntPtr; name: IntPtr)>(z_GetActiveUniform_adr);
    private z_GetActiveUniform_8 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: UniformType; name: IntPtr)>(z_GetActiveUniform_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniform(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: UniformType; name: IntPtr) :=
    z_GetActiveUniform_8(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniform(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: IntPtr; name: IntPtr) :=
    z_GetActiveUniform_7(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniform(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; var &type: UniformType; name: IntPtr) :=
    z_GetActiveUniform_6(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniform(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; &type: IntPtr; name: IntPtr) :=
    z_GetActiveUniform_5(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniform(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; var &type: UniformType; name: IntPtr) :=
    z_GetActiveUniform_4(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniform(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; &type: IntPtr; name: IntPtr) :=
    z_GetActiveUniform_3(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniform(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; var &type: UniformType; name: IntPtr) :=
    z_GetActiveUniform_2(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniform(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; &type: IntPtr; name: IntPtr) :=
    z_GetActiveUniform_1(&program, index, bufSize, length, size, &type, name);
    
    // added in gl3.1
    private z_GetActiveUniformBlockiv_adr := GetProcAddress('glGetActiveUniformBlockiv');
    private z_GetActiveUniformBlockiv_1 := GetProcOrNil&<procedure(&program: gl_program; uniformBlockIndex: UInt32; pname: UniformBlockPName; &params: IntPtr)>(z_GetActiveUniformBlockiv_adr);
    private z_GetActiveUniformBlockiv_2 := GetProcOrNil&<procedure(&program: gl_program; uniformBlockIndex: UInt32; pname: UniformBlockPName; var &params: Int32)>(z_GetActiveUniformBlockiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformBlockiv(&program: gl_program; uniformBlockIndex: UInt32; pname: UniformBlockPName; var &params: Int32) :=
    z_GetActiveUniformBlockiv_2(&program, uniformBlockIndex, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformBlockiv(&program: gl_program; uniformBlockIndex: UInt32; pname: UniformBlockPName; &params: IntPtr) :=
    z_GetActiveUniformBlockiv_1(&program, uniformBlockIndex, pname, &params);
    
    // added in gl3.1
    private z_GetActiveUniformBlockName_adr := GetProcAddress('glGetActiveUniformBlockName');
    private z_GetActiveUniformBlockName_1 := GetProcOrNil&<procedure(&program: gl_program; uniformBlockIndex: UInt32; bufSize: Int32; length: IntPtr; uniformBlockName: IntPtr)>(z_GetActiveUniformBlockName_adr);
    private z_GetActiveUniformBlockName_2 := GetProcOrNil&<procedure(&program: gl_program; uniformBlockIndex: UInt32; bufSize: Int32; var length: Int32; uniformBlockName: IntPtr)>(z_GetActiveUniformBlockName_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformBlockName(&program: gl_program; uniformBlockIndex: UInt32; bufSize: Int32; var length: Int32; uniformBlockName: IntPtr) :=
    z_GetActiveUniformBlockName_2(&program, uniformBlockIndex, bufSize, length, uniformBlockName);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformBlockName(&program: gl_program; uniformBlockIndex: UInt32; bufSize: Int32; length: IntPtr; uniformBlockName: IntPtr) :=
    z_GetActiveUniformBlockName_1(&program, uniformBlockIndex, bufSize, length, uniformBlockName);
    
    // added in gl3.1
    private z_GetActiveUniformName_adr := GetProcAddress('glGetActiveUniformName');
    private z_GetActiveUniformName_1 := GetProcOrNil&<procedure(&program: gl_program; uniformIndex: UInt32; bufSize: Int32; length: IntPtr; uniformName: IntPtr)>(z_GetActiveUniformName_adr);
    private z_GetActiveUniformName_2 := GetProcOrNil&<procedure(&program: gl_program; uniformIndex: UInt32; bufSize: Int32; var length: Int32; uniformName: IntPtr)>(z_GetActiveUniformName_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformName(&program: gl_program; uniformIndex: UInt32; bufSize: Int32; var length: Int32; uniformName: IntPtr) :=
    z_GetActiveUniformName_2(&program, uniformIndex, bufSize, length, uniformName);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformName(&program: gl_program; uniformIndex: UInt32; bufSize: Int32; length: IntPtr; uniformName: IntPtr) :=
    z_GetActiveUniformName_1(&program, uniformIndex, bufSize, length, uniformName);
    
    // added in gl3.1
    private z_GetActiveUniformsiv_adr := GetProcAddress('glGetActiveUniformsiv');
    private z_GetActiveUniformsiv_1 := GetProcOrNil&<procedure(&program: gl_program; uniformCount: Int32; uniformIndices: IntPtr; pname: UniformPName; &params: IntPtr)>(z_GetActiveUniformsiv_adr);
    private z_GetActiveUniformsiv_2 := GetProcOrNil&<procedure(&program: gl_program; uniformCount: Int32; var uniformIndices: UInt32; pname: UniformPName; var &params: Int32)>(z_GetActiveUniformsiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformsiv(&program: gl_program; uniformCount: Int32; uniformIndices: array of UInt32; pname: UniformPName; &params: array of Int32);
    type PUInt32=^UInt32;
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        if (uniformIndices<>nil) and (uniformIndices.Length<>0) then
          z_GetActiveUniformsiv_2(&program, uniformCount, uniformIndices[0], pname, &params[0]) else
          z_GetActiveUniformsiv_2(&program, uniformCount, PUInt32(nil)^, pname, &params[0]) else
        if (uniformIndices<>nil) and (uniformIndices.Length<>0) then
          z_GetActiveUniformsiv_2(&program, uniformCount, uniformIndices[0], pname, PInt32(nil)^) else
          z_GetActiveUniformsiv_2(&program, uniformCount, PUInt32(nil)^, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformsiv(&program: gl_program; uniformCount: Int32; var uniformIndices: UInt32; pname: UniformPName; var &params: Int32) :=
    z_GetActiveUniformsiv_2(&program, uniformCount, uniformIndices, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformsiv(&program: gl_program; uniformCount: Int32; uniformIndices: IntPtr; pname: UniformPName; &params: IntPtr) :=
    z_GetActiveUniformsiv_1(&program, uniformCount, uniformIndices, pname, &params);
    
    // added in gl2.0
    private z_GetAttachedShaders_adr := GetProcAddress('glGetAttachedShaders');
    private z_GetAttachedShaders_1 := GetProcOrNil&<procedure(&program: gl_program; maxCount: Int32; count: IntPtr; shaders: IntPtr)>(z_GetAttachedShaders_adr);
    private z_GetAttachedShaders_2 := GetProcOrNil&<procedure(&program: gl_program; maxCount: Int32; count: IntPtr; var shaders: gl_shader)>(z_GetAttachedShaders_adr);
    private z_GetAttachedShaders_3 := GetProcOrNil&<procedure(&program: gl_program; maxCount: Int32; var count: Int32; shaders: IntPtr)>(z_GetAttachedShaders_adr);
    private z_GetAttachedShaders_4 := GetProcOrNil&<procedure(&program: gl_program; maxCount: Int32; var count: Int32; var shaders: gl_shader)>(z_GetAttachedShaders_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedShaders(&program: gl_program; maxCount: Int32; var count: Int32; var shaders: gl_shader) :=
    z_GetAttachedShaders_4(&program, maxCount, count, shaders);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedShaders(&program: gl_program; maxCount: Int32; var count: Int32; shaders: IntPtr) :=
    z_GetAttachedShaders_3(&program, maxCount, count, shaders);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedShaders(&program: gl_program; maxCount: Int32; count: IntPtr; var shaders: gl_shader) :=
    z_GetAttachedShaders_2(&program, maxCount, count, shaders);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedShaders(&program: gl_program; maxCount: Int32; count: IntPtr; shaders: IntPtr) :=
    z_GetAttachedShaders_1(&program, maxCount, count, shaders);
    
    // added in gl2.0
    private z_GetAttribLocation_adr := GetProcAddress('glGetAttribLocation');
    private z_GetAttribLocation_1 := GetProcOrNil&<function(&program: gl_program; name: IntPtr): Int32>(z_GetAttribLocation_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetAttribLocation(&program: gl_program; name: string): Int32;
    begin
      var name_str_ptr: IntPtr;
      try
        name_str_ptr := Marshal.StringToHGlobalAnsi(name);
        Result := z_GetAttribLocation_1(&program, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetAttribLocation(&program: gl_program; name: IntPtr): Int32 :=
    z_GetAttribLocation_1(&program, name);
    
    // added in gl3.0
    private z_GetBooleani_v_adr := GetProcAddress('glGetBooleani_v');
    private z_GetBooleani_v_1 := GetProcOrNil&<procedure(target: BufferTarget; index: UInt32; data: IntPtr)>(z_GetBooleani_v_adr);
    private z_GetBooleani_v_2 := GetProcOrNil&<procedure(target: BufferTarget; index: UInt32; var data: boolean)>(z_GetBooleani_v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBooleani_v(target: BufferTarget; index: UInt32; var data: boolean) :=
    z_GetBooleani_v_2(target, index, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBooleani_v(target: BufferTarget; index: UInt32; data: IntPtr) :=
    z_GetBooleani_v_1(target, index, data);
    
    // added in gl1.0
    private z_GetBooleanv_adr := GetProcAddress('glGetBooleanv');
    private z_GetBooleanv_1 := GetProcOrNil&<procedure(pname: GetPName; data: IntPtr)>(z_GetBooleanv_adr);
    private z_GetBooleanv_2 := GetProcOrNil&<procedure(pname: GetPName; var data: boolean)>(z_GetBooleanv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBooleanv(pname: GetPName; var data: boolean) :=
    z_GetBooleanv_2(pname, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBooleanv(pname: GetPName; data: IntPtr) :=
    z_GetBooleanv_1(pname, data);
    
    // added in gl3.2
    private z_GetBufferParameteri64v_adr := GetProcAddress('glGetBufferParameteri64v');
    private z_GetBufferParameteri64v_1 := GetProcOrNil&<procedure(target: BufferTarget; pname: BufferPName; &params: IntPtr)>(z_GetBufferParameteri64v_adr);
    private z_GetBufferParameteri64v_2 := GetProcOrNil&<procedure(target: BufferTarget; pname: BufferPName; var &params: Int64)>(z_GetBufferParameteri64v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferParameteri64v(target: BufferTarget; pname: BufferPName; var &params: Int64) :=
    z_GetBufferParameteri64v_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferParameteri64v(target: BufferTarget; pname: BufferPName; &params: IntPtr) :=
    z_GetBufferParameteri64v_1(target, pname, &params);
    
    // added in gl1.5
    private z_GetBufferParameteriv_adr := GetProcAddress('glGetBufferParameteriv');
    private z_GetBufferParameteriv_1 := GetProcOrNil&<procedure(target: BufferTarget; pname: BufferPName; &params: IntPtr)>(z_GetBufferParameteriv_adr);
    private z_GetBufferParameteriv_2 := GetProcOrNil&<procedure(target: BufferTarget; pname: BufferPName; var &params: Int32)>(z_GetBufferParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferParameteriv(target: BufferTarget; pname: BufferPName; var &params: Int32) :=
    z_GetBufferParameteriv_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferParameteriv(target: BufferTarget; pname: BufferPName; &params: IntPtr) :=
    z_GetBufferParameteriv_1(target, pname, &params);
    
    // added in gl1.5
    private z_GetBufferPointerv_adr := GetProcAddress('glGetBufferPointerv');
    private z_GetBufferPointerv_1 := GetProcOrNil&<procedure(target: BufferTarget; pname: BufferPointerName; &params: pointer)>(z_GetBufferPointerv_adr);
    private z_GetBufferPointerv_2 := GetProcOrNil&<procedure(target: BufferTarget; pname: BufferPointerName; var &params: IntPtr)>(z_GetBufferPointerv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferPointerv(target: BufferTarget; pname: BufferPointerName; var &params: IntPtr) :=
    z_GetBufferPointerv_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferPointerv(target: BufferTarget; pname: BufferPointerName; &params: pointer) :=
    z_GetBufferPointerv_1(target, pname, &params);
    
    // added in gl1.5
    private z_GetBufferSubData_adr := GetProcAddress('glGetBufferSubData');
    private z_GetBufferSubData_1 := GetProcOrNil&<procedure(target: BufferTarget; offset: IntPtr; size: UIntPtr; data: pointer)>(z_GetBufferSubData_adr);
    private z_GetBufferSubData_2 := GetProcOrNil&<procedure(target: BufferTarget; offset: IntPtr; size: UIntPtr; var data: Byte)>(z_GetBufferSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferSubData<T>(target: BufferTarget; offset: IntPtr; size: UIntPtr; var data: T); where T: record;
    begin
      z_GetBufferSubData_2(target, offset, size, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferSubData(target: BufferTarget; offset: IntPtr; size: UIntPtr; data: pointer) :=
    z_GetBufferSubData_1(target, offset, size, data);
    
    // added in gl1.3
    private z_GetCompressedTexImage_adr := GetProcAddress('glGetCompressedTexImage');
    private z_GetCompressedTexImage_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; img: IntPtr)>(z_GetCompressedTexImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCompressedTexImage(target: TextureTarget; level: Int32; img: IntPtr) :=
    z_GetCompressedTexImage_1(target, level, img);
    
    // added in gl4.5
    private z_GetCompressedTextureImage_adr := GetProcAddress('glGetCompressedTextureImage');
    private z_GetCompressedTextureImage_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; bufSize: Int32; pixels: IntPtr)>(z_GetCompressedTextureImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCompressedTextureImage(texture: gl_texture; level: Int32; bufSize: Int32; pixels: IntPtr) :=
    z_GetCompressedTextureImage_1(texture, level, bufSize, pixels);
    
    // added in gl4.5
    private z_GetCompressedTextureSubImage_adr := GetProcAddress('glGetCompressedTextureSubImage');
    private z_GetCompressedTextureSubImage_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; bufSize: Int32; pixels: IntPtr)>(z_GetCompressedTextureSubImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCompressedTextureSubImage(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; bufSize: Int32; pixels: IntPtr) :=
    z_GetCompressedTextureSubImage_1(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
    
    // added in gl4.3
    private z_GetDebugMessageLog_adr := GetProcAddress('glGetDebugMessageLog');
    private z_GetDebugMessageLog_1 := GetProcOrNil&<function(count: UInt32; bufSize: Int32; sources: IntPtr; types: IntPtr; ids: IntPtr; severities: IntPtr; lengths: IntPtr; messageLog: IntPtr): UInt32>(z_GetDebugMessageLog_adr);
    private z_GetDebugMessageLog_2 := GetProcOrNil&<function(count: UInt32; bufSize: Int32; var sources: DebugSource; var types: DebugType; var ids: UInt32; var severities: DebugSeverity; var lengths: Int32; messageLog: IntPtr): UInt32>(z_GetDebugMessageLog_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDebugMessageLog(count: UInt32; bufSize: Int32; var sources: DebugSource; var types: DebugType; var ids: UInt32; var severities: DebugSeverity; var lengths: Int32; messageLog: IntPtr): UInt32 :=
    z_GetDebugMessageLog_2(count, bufSize, sources, types, ids, severities, lengths, messageLog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDebugMessageLog(count: UInt32; bufSize: Int32; sources: IntPtr; types: IntPtr; ids: IntPtr; severities: IntPtr; lengths: IntPtr; messageLog: IntPtr): UInt32 :=
    z_GetDebugMessageLog_1(count, bufSize, sources, types, ids, severities, lengths, messageLog);
    
    // added in gl4.1
    private z_GetDoublei_v_adr := GetProcAddress('glGetDoublei_v');
    private z_GetDoublei_v_1 := GetProcOrNil&<procedure(target: GetPName; index: UInt32; data: IntPtr)>(z_GetDoublei_v_adr);
    private z_GetDoublei_v_2 := GetProcOrNil&<procedure(target: GetPName; index: UInt32; var data: real)>(z_GetDoublei_v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDoublei_v(target: GetPName; index: UInt32; var data: real) :=
    z_GetDoublei_v_2(target, index, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDoublei_v(target: GetPName; index: UInt32; data: IntPtr) :=
    z_GetDoublei_v_1(target, index, data);
    
    // added in gl1.0
    private z_GetDoublev_adr := GetProcAddress('glGetDoublev');
    private z_GetDoublev_1 := GetProcOrNil&<procedure(pname: GetPName; data: IntPtr)>(z_GetDoublev_adr);
    private z_GetDoublev_2 := GetProcOrNil&<procedure(pname: GetPName; var data: real)>(z_GetDoublev_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDoublev(pname: GetPName; var data: real) :=
    z_GetDoublev_2(pname, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDoublev(pname: GetPName; data: IntPtr) :=
    z_GetDoublev_1(pname, data);
    
    // added in gl1.0
    private z_GetError_adr := GetProcAddress('glGetError');
    private z_GetError_1 := GetProcOrNil&<function: ErrorCode>(z_GetError_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetError: ErrorCode :=
    z_GetError_1();
    
    // added in gl4.1
    private z_GetFloati_v_adr := GetProcAddress('glGetFloati_v');
    private z_GetFloati_v_1 := GetProcOrNil&<procedure(target: GetPName; index: UInt32; data: IntPtr)>(z_GetFloati_v_adr);
    private z_GetFloati_v_2 := GetProcOrNil&<procedure(target: GetPName; index: UInt32; var data: single)>(z_GetFloati_v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloati_v(target: GetPName; index: UInt32; var data: single) :=
    z_GetFloati_v_2(target, index, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloati_v(target: GetPName; index: UInt32; data: IntPtr) :=
    z_GetFloati_v_1(target, index, data);
    
    // added in gl1.0
    private z_GetFloatv_adr := GetProcAddress('glGetFloatv');
    private z_GetFloatv_1 := GetProcOrNil&<procedure(pname: GetPName; data: IntPtr)>(z_GetFloatv_adr);
    private z_GetFloatv_2 := GetProcOrNil&<procedure(pname: GetPName; var data: single)>(z_GetFloatv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloatv(pname: GetPName; var data: single) :=
    z_GetFloatv_2(pname, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloatv(pname: GetPName; data: IntPtr) :=
    z_GetFloatv_1(pname, data);
    
    // added in gl3.3
    private z_GetFragDataIndex_adr := GetProcAddress('glGetFragDataIndex');
    private z_GetFragDataIndex_1 := GetProcOrNil&<function(&program: gl_program; name: IntPtr): Int32>(z_GetFragDataIndex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFragDataIndex(&program: gl_program; name: string): Int32;
    begin
      var name_str_ptr: IntPtr;
      try
        name_str_ptr := Marshal.StringToHGlobalAnsi(name);
        Result := z_GetFragDataIndex_1(&program, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFragDataIndex(&program: gl_program; name: IntPtr): Int32 :=
    z_GetFragDataIndex_1(&program, name);
    
    // added in gl3.0
    private z_GetFragDataLocation_adr := GetProcAddress('glGetFragDataLocation');
    private z_GetFragDataLocation_1 := GetProcOrNil&<function(&program: gl_program; name: IntPtr): Int32>(z_GetFragDataLocation_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFragDataLocation(&program: gl_program; name: string): Int32;
    begin
      var name_str_ptr: IntPtr;
      try
        name_str_ptr := Marshal.StringToHGlobalAnsi(name);
        Result := z_GetFragDataLocation_1(&program, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFragDataLocation(&program: gl_program; name: IntPtr): Int32 :=
    z_GetFragDataLocation_1(&program, name);
    
    // added in gl3.0
    private z_GetFramebufferAttachmentParameteriv_adr := GetProcAddress('glGetFramebufferAttachmentParameteriv');
    private z_GetFramebufferAttachmentParameteriv_1 := GetProcOrNil&<procedure(target: FramebufferTarget; attachment: FramebufferAttachment; pname: FramebufferAttachmentParameterName; &params: IntPtr)>(z_GetFramebufferAttachmentParameteriv_adr);
    private z_GetFramebufferAttachmentParameteriv_2 := GetProcOrNil&<procedure(target: FramebufferTarget; attachment: FramebufferAttachment; pname: FramebufferAttachmentParameterName; var &params: Int32)>(z_GetFramebufferAttachmentParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferAttachmentParameteriv(target: FramebufferTarget; attachment: FramebufferAttachment; pname: FramebufferAttachmentParameterName; var &params: Int32) :=
    z_GetFramebufferAttachmentParameteriv_2(target, attachment, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferAttachmentParameteriv(target: FramebufferTarget; attachment: FramebufferAttachment; pname: FramebufferAttachmentParameterName; &params: IntPtr) :=
    z_GetFramebufferAttachmentParameteriv_1(target, attachment, pname, &params);
    
    // added in gl4.3
    private z_GetFramebufferParameteriv_adr := GetProcAddress('glGetFramebufferParameteriv');
    private z_GetFramebufferParameteriv_1 := GetProcOrNil&<procedure(target: FramebufferTarget; pname: FramebufferAttachmentParameterName; &params: IntPtr)>(z_GetFramebufferParameteriv_adr);
    private z_GetFramebufferParameteriv_2 := GetProcOrNil&<procedure(target: FramebufferTarget; pname: FramebufferAttachmentParameterName; var &params: Int32)>(z_GetFramebufferParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferParameteriv(target: FramebufferTarget; pname: FramebufferAttachmentParameterName; var &params: Int32) :=
    z_GetFramebufferParameteriv_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferParameteriv(target: FramebufferTarget; pname: FramebufferAttachmentParameterName; &params: IntPtr) :=
    z_GetFramebufferParameteriv_1(target, pname, &params);
    
    // added in gl4.5
    private z_GetGraphicsResetStatus_adr := GetProcAddress('glGetGraphicsResetStatus');
    private z_GetGraphicsResetStatus_1 := GetProcOrNil&<function: GraphicsResetStatus>(z_GetGraphicsResetStatus_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGraphicsResetStatus: GraphicsResetStatus :=
    z_GetGraphicsResetStatus_1();
    
    // added in gl3.2
    private z_GetInteger64i_v_adr := GetProcAddress('glGetInteger64i_v');
    private z_GetInteger64i_v_1 := GetProcOrNil&<procedure(target: GetPName; index: UInt32; data: IntPtr)>(z_GetInteger64i_v_adr);
    private z_GetInteger64i_v_2 := GetProcOrNil&<procedure(target: GetPName; index: UInt32; var data: Int64)>(z_GetInteger64i_v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInteger64i_v(target: GetPName; index: UInt32; var data: Int64) :=
    z_GetInteger64i_v_2(target, index, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInteger64i_v(target: GetPName; index: UInt32; data: IntPtr) :=
    z_GetInteger64i_v_1(target, index, data);
    
    // added in gl3.2
    private z_GetInteger64v_adr := GetProcAddress('glGetInteger64v');
    private z_GetInteger64v_1 := GetProcOrNil&<procedure(pname: GetPName; data: IntPtr)>(z_GetInteger64v_adr);
    private z_GetInteger64v_2 := GetProcOrNil&<procedure(pname: GetPName; var data: Int64)>(z_GetInteger64v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInteger64v(pname: GetPName; var data: Int64) :=
    z_GetInteger64v_2(pname, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInteger64v(pname: GetPName; data: IntPtr) :=
    z_GetInteger64v_1(pname, data);
    
    // added in gl3.0
    private z_GetIntegeri_v_adr := GetProcAddress('glGetIntegeri_v');
    private z_GetIntegeri_v_1 := GetProcOrNil&<procedure(target: GetPName; index: UInt32; data: IntPtr)>(z_GetIntegeri_v_adr);
    private z_GetIntegeri_v_2 := GetProcOrNil&<procedure(target: GetPName; index: UInt32; var data: Int32)>(z_GetIntegeri_v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegeri_v(target: GetPName; index: UInt32; var data: Int32) :=
    z_GetIntegeri_v_2(target, index, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegeri_v(target: GetPName; index: UInt32; data: IntPtr) :=
    z_GetIntegeri_v_1(target, index, data);
    
    // added in gl1.0
    private z_GetIntegerv_adr := GetProcAddress('glGetIntegerv');
    private z_GetIntegerv_1 := GetProcOrNil&<procedure(pname: GetPName; data: IntPtr)>(z_GetIntegerv_adr);
    private z_GetIntegerv_2 := GetProcOrNil&<procedure(pname: GetPName; var data: Int32)>(z_GetIntegerv_adr);
    private z_GetIntegerv_3 := GetProcOrNil&<procedure(pname: GetPName; var data: SubgroupSupportedFeatures)>(z_GetIntegerv_adr);
    private z_GetIntegerv_4 := GetProcOrNil&<procedure(pname: GetPName; var data: ContextProfileMask)>(z_GetIntegerv_adr);
    private z_GetIntegerv_5 := GetProcOrNil&<procedure(pname: GetPName; var data: ContextFlagMask)>(z_GetIntegerv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerv(pname: GetPName; var data: ContextFlagMask) :=
    z_GetIntegerv_5(pname, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerv(pname: GetPName; var data: ContextProfileMask) :=
    z_GetIntegerv_4(pname, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerv(pname: GetPName; var data: SubgroupSupportedFeatures) :=
    z_GetIntegerv_3(pname, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerv(pname: GetPName; var data: Int32) :=
    z_GetIntegerv_2(pname, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerv(pname: GetPName; data: IntPtr) :=
    z_GetIntegerv_1(pname, data);
    
    // added in gl4.3
    private z_GetInternalformati64v_adr := GetProcAddress('glGetInternalformati64v');
    private z_GetInternalformati64v_1 := GetProcOrNil&<procedure(target: TextureTarget; _internalformat: InternalFormat; pname: InternalFormatPName; count: Int32; &params: IntPtr)>(z_GetInternalformati64v_adr);
    private z_GetInternalformati64v_2 := GetProcOrNil&<procedure(target: TextureTarget; _internalformat: InternalFormat; pname: InternalFormatPName; count: Int32; var &params: Int64)>(z_GetInternalformati64v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInternalformati64v(target: TextureTarget; _internalformat: InternalFormat; pname: InternalFormatPName; count: Int32; var &params: Int64) :=
    z_GetInternalformati64v_2(target, _internalformat, pname, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInternalformati64v(target: TextureTarget; _internalformat: InternalFormat; pname: InternalFormatPName; count: Int32; &params: IntPtr) :=
    z_GetInternalformati64v_1(target, _internalformat, pname, count, &params);
    
    // added in gl4.2
    private z_GetInternalformativ_adr := GetProcAddress('glGetInternalformativ');
    private z_GetInternalformativ_1 := GetProcOrNil&<procedure(target: TextureTarget; _internalformat: InternalFormat; pname: InternalFormatPName; count: Int32; &params: IntPtr)>(z_GetInternalformativ_adr);
    private z_GetInternalformativ_2 := GetProcOrNil&<procedure(target: TextureTarget; _internalformat: InternalFormat; pname: InternalFormatPName; count: Int32; var &params: Int32)>(z_GetInternalformativ_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInternalformativ(target: TextureTarget; _internalformat: InternalFormat; pname: InternalFormatPName; count: Int32; var &params: Int32) :=
    z_GetInternalformativ_2(target, _internalformat, pname, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInternalformativ(target: TextureTarget; _internalformat: InternalFormat; pname: InternalFormatPName; count: Int32; &params: IntPtr) :=
    z_GetInternalformativ_1(target, _internalformat, pname, count, &params);
    
    // added in gl3.2
    private z_GetMultisamplefv_adr := GetProcAddress('glGetMultisamplefv');
    private z_GetMultisamplefv_1 := GetProcOrNil&<procedure(pname: GetMultisamplePName; index: UInt32; val: IntPtr)>(z_GetMultisamplefv_adr);
    private z_GetMultisamplefv_2 := GetProcOrNil&<procedure(pname: GetMultisamplePName; index: UInt32; var val: single)>(z_GetMultisamplefv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultisamplefv(pname: GetMultisamplePName; index: UInt32; var val: single) :=
    z_GetMultisamplefv_2(pname, index, val);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultisamplefv(pname: GetMultisamplePName; index: UInt32; val: IntPtr) :=
    z_GetMultisamplefv_1(pname, index, val);
    
    // added in gl4.5
    private z_GetNamedBufferParameteri64v_adr := GetProcAddress('glGetNamedBufferParameteri64v');
    private z_GetNamedBufferParameteri64v_1 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: BufferPName; &params: IntPtr)>(z_GetNamedBufferParameteri64v_adr);
    private z_GetNamedBufferParameteri64v_2 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: BufferPName; var &params: Int64)>(z_GetNamedBufferParameteri64v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameteri64v(buffer: gl_buffer; pname: BufferPName; var &params: Int64) :=
    z_GetNamedBufferParameteri64v_2(buffer, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameteri64v(buffer: gl_buffer; pname: BufferPName; &params: IntPtr) :=
    z_GetNamedBufferParameteri64v_1(buffer, pname, &params);
    
    // added in gl4.5
    private z_GetNamedBufferParameteriv_adr := GetProcAddress('glGetNamedBufferParameteriv');
    private z_GetNamedBufferParameteriv_1 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: BufferPName; &params: IntPtr)>(z_GetNamedBufferParameteriv_adr);
    private z_GetNamedBufferParameteriv_2 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: BufferPName; var &params: Int32)>(z_GetNamedBufferParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameteriv(buffer: gl_buffer; pname: BufferPName; var &params: Int32) :=
    z_GetNamedBufferParameteriv_2(buffer, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameteriv(buffer: gl_buffer; pname: BufferPName; &params: IntPtr) :=
    z_GetNamedBufferParameteriv_1(buffer, pname, &params);
    
    // added in gl4.5
    private z_GetNamedBufferPointerv_adr := GetProcAddress('glGetNamedBufferPointerv');
    private z_GetNamedBufferPointerv_1 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: BufferPointerName; &params: pointer)>(z_GetNamedBufferPointerv_adr);
    private z_GetNamedBufferPointerv_2 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: BufferPointerName; var &params: IntPtr)>(z_GetNamedBufferPointerv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferPointerv(buffer: gl_buffer; pname: BufferPointerName; var &params: IntPtr) :=
    z_GetNamedBufferPointerv_2(buffer, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferPointerv(buffer: gl_buffer; pname: BufferPointerName; &params: pointer) :=
    z_GetNamedBufferPointerv_1(buffer, pname, &params);
    
    // added in gl4.5
    private z_GetNamedBufferSubData_adr := GetProcAddress('glGetNamedBufferSubData');
    private z_GetNamedBufferSubData_1 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: pointer)>(z_GetNamedBufferSubData_adr);
    private z_GetNamedBufferSubData_2 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; var data: Byte)>(z_GetNamedBufferSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferSubData<T>(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; var data: T); where T: record;
    begin
      z_GetNamedBufferSubData_2(buffer, offset, size, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferSubData(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: pointer) :=
    z_GetNamedBufferSubData_1(buffer, offset, size, data);
    
    // added in gl4.5
    private z_GetNamedFramebufferAttachmentParameteriv_adr := GetProcAddress('glGetNamedFramebufferAttachmentParameteriv');
    private z_GetNamedFramebufferAttachmentParameteriv_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; pname: FramebufferAttachmentParameterName; &params: IntPtr)>(z_GetNamedFramebufferAttachmentParameteriv_adr);
    private z_GetNamedFramebufferAttachmentParameteriv_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; pname: FramebufferAttachmentParameterName; var &params: Int32)>(z_GetNamedFramebufferAttachmentParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferAttachmentParameteriv(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; pname: FramebufferAttachmentParameterName; var &params: Int32) :=
    z_GetNamedFramebufferAttachmentParameteriv_2(framebuffer, attachment, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferAttachmentParameteriv(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; pname: FramebufferAttachmentParameterName; &params: IntPtr) :=
    z_GetNamedFramebufferAttachmentParameteriv_1(framebuffer, attachment, pname, &params);
    
    // added in gl4.5
    private z_GetNamedFramebufferParameteriv_adr := GetProcAddress('glGetNamedFramebufferParameteriv');
    private z_GetNamedFramebufferParameteriv_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; pname: GetFramebufferParameter; param: IntPtr)>(z_GetNamedFramebufferParameteriv_adr);
    private z_GetNamedFramebufferParameteriv_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; pname: GetFramebufferParameter; var param: Int32)>(z_GetNamedFramebufferParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferParameteriv(framebuffer: gl_framebuffer; pname: GetFramebufferParameter; var param: Int32) :=
    z_GetNamedFramebufferParameteriv_2(framebuffer, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferParameteriv(framebuffer: gl_framebuffer; pname: GetFramebufferParameter; param: IntPtr) :=
    z_GetNamedFramebufferParameteriv_1(framebuffer, pname, param);
    
    // added in gl4.5
    private z_GetNamedRenderbufferParameteriv_adr := GetProcAddress('glGetNamedRenderbufferParameteriv');
    private z_GetNamedRenderbufferParameteriv_1 := GetProcOrNil&<procedure(renderbuffer: gl_renderbuffer; pname: RenderbufferParameterName; &params: IntPtr)>(z_GetNamedRenderbufferParameteriv_adr);
    private z_GetNamedRenderbufferParameteriv_2 := GetProcOrNil&<procedure(renderbuffer: gl_renderbuffer; pname: RenderbufferParameterName; var &params: Int32)>(z_GetNamedRenderbufferParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedRenderbufferParameteriv(renderbuffer: gl_renderbuffer; pname: RenderbufferParameterName; var &params: Int32) :=
    z_GetNamedRenderbufferParameteriv_2(renderbuffer, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedRenderbufferParameteriv(renderbuffer: gl_renderbuffer; pname: RenderbufferParameterName; &params: IntPtr) :=
    z_GetNamedRenderbufferParameteriv_1(renderbuffer, pname, &params);
    
    // added in gl4.5
    private z_GetnColorTable_adr := GetProcAddress('glGetnColorTable');
    private z_GetnColorTable_1 := GetProcOrNil&<procedure(target: ColorTableTarget; format: PixelFormat; &type: PixelType; bufSize: Int32; table: IntPtr)>(z_GetnColorTable_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnColorTable(target: ColorTableTarget; format: PixelFormat; &type: PixelType; bufSize: Int32; table: IntPtr) :=
    z_GetnColorTable_1(target, format, &type, bufSize, table);
    
    // added in gl4.5
    private z_GetnCompressedTexImage_adr := GetProcAddress('glGetnCompressedTexImage');
    private z_GetnCompressedTexImage_1 := GetProcOrNil&<procedure(target: TextureTarget; lod: Int32; bufSize: Int32; pixels: IntPtr)>(z_GetnCompressedTexImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnCompressedTexImage(target: TextureTarget; lod: Int32; bufSize: Int32; pixels: IntPtr) :=
    z_GetnCompressedTexImage_1(target, lod, bufSize, pixels);
    
    // added in gl4.5
    private z_GetnConvolutionFilter_adr := GetProcAddress('glGetnConvolutionFilter');
    private z_GetnConvolutionFilter_1 := GetProcOrNil&<procedure(target: ConvolutionTarget; format: PixelFormat; &type: PixelType; bufSize: Int32; image: IntPtr)>(z_GetnConvolutionFilter_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnConvolutionFilter(target: ConvolutionTarget; format: PixelFormat; &type: PixelType; bufSize: Int32; image: IntPtr) :=
    z_GetnConvolutionFilter_1(target, format, &type, bufSize, image);
    
    // added in gl4.5
    private z_GetnHistogram_adr := GetProcAddress('glGetnHistogram');
    private z_GetnHistogram_1 := GetProcOrNil&<procedure(target: HistogramTarget; reset: boolean; format: PixelFormat; &type: PixelType; bufSize: Int32; values: IntPtr)>(z_GetnHistogram_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnHistogram(target: HistogramTarget; reset: boolean; format: PixelFormat; &type: PixelType; bufSize: Int32; values: IntPtr) :=
    z_GetnHistogram_1(target, reset, format, &type, bufSize, values);
    
    // added in gl4.5
    private z_GetnMapdv_adr := GetProcAddress('glGetnMapdv');
    private z_GetnMapdv_1 := GetProcOrNil&<procedure(target: MapTarget; query: MapQuery; bufSize: Int32; v: IntPtr)>(z_GetnMapdv_adr);
    private z_GetnMapdv_2 := GetProcOrNil&<procedure(target: MapTarget; query: MapQuery; bufSize: Int32; var v: real)>(z_GetnMapdv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapdv(target: MapTarget; query: MapQuery; bufSize: Int32; var v: real) :=
    z_GetnMapdv_2(target, query, bufSize, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapdv(target: MapTarget; query: MapQuery; bufSize: Int32; v: IntPtr) :=
    z_GetnMapdv_1(target, query, bufSize, v);
    
    // added in gl4.5
    private z_GetnMapfv_adr := GetProcAddress('glGetnMapfv');
    private z_GetnMapfv_1 := GetProcOrNil&<procedure(target: MapTarget; query: MapQuery; bufSize: Int32; v: IntPtr)>(z_GetnMapfv_adr);
    private z_GetnMapfv_2 := GetProcOrNil&<procedure(target: MapTarget; query: MapQuery; bufSize: Int32; var v: single)>(z_GetnMapfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapfv(target: MapTarget; query: MapQuery; bufSize: Int32; var v: single) :=
    z_GetnMapfv_2(target, query, bufSize, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapfv(target: MapTarget; query: MapQuery; bufSize: Int32; v: IntPtr) :=
    z_GetnMapfv_1(target, query, bufSize, v);
    
    // added in gl4.5
    private z_GetnMapiv_adr := GetProcAddress('glGetnMapiv');
    private z_GetnMapiv_1 := GetProcOrNil&<procedure(target: MapTarget; query: MapQuery; bufSize: Int32; v: IntPtr)>(z_GetnMapiv_adr);
    private z_GetnMapiv_2 := GetProcOrNil&<procedure(target: MapTarget; query: MapQuery; bufSize: Int32; var v: Int32)>(z_GetnMapiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapiv(target: MapTarget; query: MapQuery; bufSize: Int32; var v: Int32) :=
    z_GetnMapiv_2(target, query, bufSize, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapiv(target: MapTarget; query: MapQuery; bufSize: Int32; v: IntPtr) :=
    z_GetnMapiv_1(target, query, bufSize, v);
    
    // added in gl4.5
    private z_GetnMinmax_adr := GetProcAddress('glGetnMinmax');
    private z_GetnMinmax_1 := GetProcOrNil&<procedure(target: MinmaxTarget; reset: boolean; format: PixelFormat; &type: PixelType; bufSize: Int32; values: IntPtr)>(z_GetnMinmax_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMinmax(target: MinmaxTarget; reset: boolean; format: PixelFormat; &type: PixelType; bufSize: Int32; values: IntPtr) :=
    z_GetnMinmax_1(target, reset, format, &type, bufSize, values);
    
    // added in gl4.5
    private z_GetnPixelMapfv_adr := GetProcAddress('glGetnPixelMapfv');
    private z_GetnPixelMapfv_1 := GetProcOrNil&<procedure(map: PixelMap; bufSize: Int32; values: IntPtr)>(z_GetnPixelMapfv_adr);
    private z_GetnPixelMapfv_2 := GetProcOrNil&<procedure(map: PixelMap; bufSize: Int32; var values: single)>(z_GetnPixelMapfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapfv(map: PixelMap; bufSize: Int32; var values: single) :=
    z_GetnPixelMapfv_2(map, bufSize, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapfv(map: PixelMap; bufSize: Int32; values: IntPtr) :=
    z_GetnPixelMapfv_1(map, bufSize, values);
    
    // added in gl4.5
    private z_GetnPixelMapuiv_adr := GetProcAddress('glGetnPixelMapuiv');
    private z_GetnPixelMapuiv_1 := GetProcOrNil&<procedure(map: PixelMap; bufSize: Int32; values: IntPtr)>(z_GetnPixelMapuiv_adr);
    private z_GetnPixelMapuiv_2 := GetProcOrNil&<procedure(map: PixelMap; bufSize: Int32; var values: UInt32)>(z_GetnPixelMapuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapuiv(map: PixelMap; bufSize: Int32; var values: UInt32) :=
    z_GetnPixelMapuiv_2(map, bufSize, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapuiv(map: PixelMap; bufSize: Int32; values: IntPtr) :=
    z_GetnPixelMapuiv_1(map, bufSize, values);
    
    // added in gl4.5
    private z_GetnPixelMapusv_adr := GetProcAddress('glGetnPixelMapusv');
    private z_GetnPixelMapusv_1 := GetProcOrNil&<procedure(map: PixelMap; bufSize: Int32; values: IntPtr)>(z_GetnPixelMapusv_adr);
    private z_GetnPixelMapusv_2 := GetProcOrNil&<procedure(map: PixelMap; bufSize: Int32; var values: UInt16)>(z_GetnPixelMapusv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapusv(map: PixelMap; bufSize: Int32; var values: UInt16) :=
    z_GetnPixelMapusv_2(map, bufSize, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapusv(map: PixelMap; bufSize: Int32; values: IntPtr) :=
    z_GetnPixelMapusv_1(map, bufSize, values);
    
    // added in gl4.5
    private z_GetnPolygonStipple_adr := GetProcAddress('glGetnPolygonStipple');
    private z_GetnPolygonStipple_1 := GetProcOrNil&<procedure(bufSize: Int32; pattern: IntPtr)>(z_GetnPolygonStipple_adr);
    private z_GetnPolygonStipple_2 := GetProcOrNil&<procedure(bufSize: Int32; var pattern: Byte)>(z_GetnPolygonStipple_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPolygonStipple(bufSize: Int32; var pattern: Byte) :=
    z_GetnPolygonStipple_2(bufSize, pattern);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPolygonStipple(bufSize: Int32; pattern: IntPtr) :=
    z_GetnPolygonStipple_1(bufSize, pattern);
    
    // added in gl4.5
    private z_GetnSeparableFilter_adr := GetProcAddress('glGetnSeparableFilter');
    private z_GetnSeparableFilter_1 := GetProcOrNil&<procedure(target: SeparableTarget; format: PixelFormat; &type: PixelType; rowBufSize: Int32; row: IntPtr; columnBufSize: Int32; column: IntPtr; span: IntPtr)>(z_GetnSeparableFilter_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnSeparableFilter(target: SeparableTarget; format: PixelFormat; &type: PixelType; rowBufSize: Int32; row: IntPtr; columnBufSize: Int32; column: IntPtr; span: IntPtr) :=
    z_GetnSeparableFilter_1(target, format, &type, rowBufSize, row, columnBufSize, column, span);
    
    // added in gl4.5
    private z_GetnTexImage_adr := GetProcAddress('glGetnTexImage');
    private z_GetnTexImage_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; format: PixelFormat; &type: PixelType; bufSize: Int32; pixels: IntPtr)>(z_GetnTexImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnTexImage(target: TextureTarget; level: Int32; format: PixelFormat; &type: PixelType; bufSize: Int32; pixels: IntPtr) :=
    z_GetnTexImage_1(target, level, format, &type, bufSize, pixels);
    
    // added in gl4.5
    private z_GetnUniformdv_adr := GetProcAddress('glGetnUniformdv');
    private z_GetnUniformdv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr)>(z_GetnUniformdv_adr);
    private z_GetnUniformdv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; var &params: real)>(z_GetnUniformdv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformdv(&program: gl_program; location: Int32; bufSize: Int32; var &params: real) :=
    z_GetnUniformdv_2(&program, location, bufSize, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformdv(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr) :=
    z_GetnUniformdv_1(&program, location, bufSize, &params);
    
    // added in gl4.5
    private z_GetnUniformfv_adr := GetProcAddress('glGetnUniformfv');
    private z_GetnUniformfv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr)>(z_GetnUniformfv_adr);
    private z_GetnUniformfv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; var &params: single)>(z_GetnUniformfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformfv(&program: gl_program; location: Int32; bufSize: Int32; var &params: single) :=
    z_GetnUniformfv_2(&program, location, bufSize, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformfv(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr) :=
    z_GetnUniformfv_1(&program, location, bufSize, &params);
    
    // added in gl4.5
    private z_GetnUniformiv_adr := GetProcAddress('glGetnUniformiv');
    private z_GetnUniformiv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr)>(z_GetnUniformiv_adr);
    private z_GetnUniformiv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; var &params: Int32)>(z_GetnUniformiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformiv(&program: gl_program; location: Int32; bufSize: Int32; var &params: Int32) :=
    z_GetnUniformiv_2(&program, location, bufSize, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformiv(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr) :=
    z_GetnUniformiv_1(&program, location, bufSize, &params);
    
    // added in gl4.5
    private z_GetnUniformuiv_adr := GetProcAddress('glGetnUniformuiv');
    private z_GetnUniformuiv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr)>(z_GetnUniformuiv_adr);
    private z_GetnUniformuiv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; var &params: UInt32)>(z_GetnUniformuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformuiv(&program: gl_program; location: Int32; bufSize: Int32; var &params: UInt32) :=
    z_GetnUniformuiv_2(&program, location, bufSize, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformuiv(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr) :=
    z_GetnUniformuiv_1(&program, location, bufSize, &params);
    
    // added in gl4.3
    private z_GetObjectLabel_adr := GetProcAddress('glGetObjectLabel');
    private z_GetObjectLabel_1 := GetProcOrNil&<procedure(identifier: ObjectIdentifier; name: UInt32; bufSize: Int32; length: IntPtr; &label: IntPtr)>(z_GetObjectLabel_adr);
    private z_GetObjectLabel_2 := GetProcOrNil&<procedure(identifier: ObjectIdentifier; name: UInt32; bufSize: Int32; var length: Int32; &label: IntPtr)>(z_GetObjectLabel_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectLabel(identifier: ObjectIdentifier; name: UInt32; bufSize: Int32; var length: Int32; &label: IntPtr) :=
    z_GetObjectLabel_2(identifier, name, bufSize, length, &label);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectLabel(identifier: ObjectIdentifier; name: UInt32; bufSize: Int32; length: IntPtr; &label: IntPtr) :=
    z_GetObjectLabel_1(identifier, name, bufSize, length, &label);
    
    // added in gl4.3
    private z_GetObjectPtrLabel_adr := GetProcAddress('glGetObjectPtrLabel');
    private z_GetObjectPtrLabel_1 := GetProcOrNil&<procedure(ptr: IntPtr; bufSize: Int32; length: IntPtr; &label: IntPtr)>(z_GetObjectPtrLabel_adr);
    private z_GetObjectPtrLabel_2 := GetProcOrNil&<procedure(ptr: IntPtr; bufSize: Int32; var length: Int32; &label: IntPtr)>(z_GetObjectPtrLabel_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectPtrLabel(ptr: IntPtr; bufSize: Int32; var length: Int32; &label: IntPtr) :=
    z_GetObjectPtrLabel_2(ptr, bufSize, length, &label);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectPtrLabel(ptr: IntPtr; bufSize: Int32; length: IntPtr; &label: IntPtr) :=
    z_GetObjectPtrLabel_1(ptr, bufSize, length, &label);
    
    // added in gl4.3
    private z_GetPointerv_adr := GetProcAddress('glGetPointerv');
    private z_GetPointerv_1 := GetProcOrNil&<procedure(pname: GetPointervPName; &params: pointer)>(z_GetPointerv_adr);
    private z_GetPointerv_2 := GetProcOrNil&<procedure(pname: GetPointervPName; var &params: IntPtr)>(z_GetPointerv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointerv(pname: GetPointervPName; var &params: IntPtr) :=
    z_GetPointerv_2(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointerv(pname: GetPointervPName; &params: pointer) :=
    z_GetPointerv_1(pname, &params);
    
    // added in gl4.1
    private z_GetProgramBinary_adr := GetProcAddress('glGetProgramBinary');
    private z_GetProgramBinary_1 := GetProcOrNil&<procedure(&program: gl_program; bufSize: Int32; length: IntPtr; binaryFormat: IntPtr; binary: IntPtr)>(z_GetProgramBinary_adr);
    private z_GetProgramBinary_2 := GetProcOrNil&<procedure(&program: gl_program; bufSize: Int32; length: IntPtr; var binaryFormat: DummyEnum; binary: IntPtr)>(z_GetProgramBinary_adr);
    private z_GetProgramBinary_3 := GetProcOrNil&<procedure(&program: gl_program; bufSize: Int32; var length: Int32; binaryFormat: IntPtr; binary: IntPtr)>(z_GetProgramBinary_adr);
    private z_GetProgramBinary_4 := GetProcOrNil&<procedure(&program: gl_program; bufSize: Int32; var length: Int32; var binaryFormat: DummyEnum; binary: IntPtr)>(z_GetProgramBinary_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramBinary(&program: gl_program; bufSize: Int32; var length: Int32; var binaryFormat: DummyEnum; binary: IntPtr) :=
    z_GetProgramBinary_4(&program, bufSize, length, binaryFormat, binary);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramBinary(&program: gl_program; bufSize: Int32; var length: Int32; binaryFormat: IntPtr; binary: IntPtr) :=
    z_GetProgramBinary_3(&program, bufSize, length, binaryFormat, binary);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramBinary(&program: gl_program; bufSize: Int32; length: IntPtr; var binaryFormat: DummyEnum; binary: IntPtr) :=
    z_GetProgramBinary_2(&program, bufSize, length, binaryFormat, binary);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramBinary(&program: gl_program; bufSize: Int32; length: IntPtr; binaryFormat: IntPtr; binary: IntPtr) :=
    z_GetProgramBinary_1(&program, bufSize, length, binaryFormat, binary);
    
    // added in gl2.0
    private z_GetProgramInfoLog_adr := GetProcAddress('glGetProgramInfoLog');
    private z_GetProgramInfoLog_1 := GetProcOrNil&<procedure(&program: gl_program; bufSize: Int32; length: IntPtr; infoLog: IntPtr)>(z_GetProgramInfoLog_adr);
    private z_GetProgramInfoLog_2 := GetProcOrNil&<procedure(&program: gl_program; bufSize: Int32; var length: Int32; infoLog: IntPtr)>(z_GetProgramInfoLog_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramInfoLog(&program: gl_program; bufSize: Int32; var length: Int32; infoLog: IntPtr) :=
    z_GetProgramInfoLog_2(&program, bufSize, length, infoLog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramInfoLog(&program: gl_program; bufSize: Int32; length: IntPtr; infoLog: IntPtr) :=
    z_GetProgramInfoLog_1(&program, bufSize, length, infoLog);
    
    // added in gl4.3
    private z_GetProgramInterfaceiv_adr := GetProcAddress('glGetProgramInterfaceiv');
    private z_GetProgramInterfaceiv_1 := GetProcOrNil&<procedure(&program: gl_program; _programInterface: ProgramInterface; pname: ProgramInterfacePName; &params: IntPtr)>(z_GetProgramInterfaceiv_adr);
    private z_GetProgramInterfaceiv_2 := GetProcOrNil&<procedure(&program: gl_program; _programInterface: ProgramInterface; pname: ProgramInterfacePName; var &params: Int32)>(z_GetProgramInterfaceiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramInterfaceiv(&program: gl_program; _programInterface: ProgramInterface; pname: ProgramInterfacePName; var &params: Int32) :=
    z_GetProgramInterfaceiv_2(&program, _programInterface, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramInterfaceiv(&program: gl_program; _programInterface: ProgramInterface; pname: ProgramInterfacePName; &params: IntPtr) :=
    z_GetProgramInterfaceiv_1(&program, _programInterface, pname, &params);
    
    // added in gl2.0
    private z_GetProgramiv_adr := GetProcAddress('glGetProgramiv');
    private z_GetProgramiv_1 := GetProcOrNil&<procedure(&program: gl_program; pname: ProgramProperty; &params: IntPtr)>(z_GetProgramiv_adr);
    private z_GetProgramiv_2 := GetProcOrNil&<procedure(&program: gl_program; pname: ProgramProperty; var &params: Int32)>(z_GetProgramiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramiv(&program: gl_program; pname: ProgramProperty; var &params: Int32) :=
    z_GetProgramiv_2(&program, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramiv(&program: gl_program; pname: ProgramProperty; &params: IntPtr) :=
    z_GetProgramiv_1(&program, pname, &params);
    
    // added in gl4.1
    private z_GetProgramPipelineInfoLog_adr := GetProcAddress('glGetProgramPipelineInfoLog');
    private z_GetProgramPipelineInfoLog_1 := GetProcOrNil&<procedure(pipeline: gl_program_pipeline; bufSize: Int32; length: IntPtr; infoLog: IntPtr)>(z_GetProgramPipelineInfoLog_adr);
    private z_GetProgramPipelineInfoLog_2 := GetProcOrNil&<procedure(pipeline: gl_program_pipeline; bufSize: Int32; var length: Int32; infoLog: IntPtr)>(z_GetProgramPipelineInfoLog_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramPipelineInfoLog(pipeline: gl_program_pipeline; bufSize: Int32; var length: Int32; infoLog: IntPtr) :=
    z_GetProgramPipelineInfoLog_2(pipeline, bufSize, length, infoLog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramPipelineInfoLog(pipeline: gl_program_pipeline; bufSize: Int32; length: IntPtr; infoLog: IntPtr) :=
    z_GetProgramPipelineInfoLog_1(pipeline, bufSize, length, infoLog);
    
    // added in gl4.1
    private z_GetProgramPipelineiv_adr := GetProcAddress('glGetProgramPipelineiv');
    private z_GetProgramPipelineiv_1 := GetProcOrNil&<procedure(pipeline: gl_program_pipeline; pname: PipelineParameterName; &params: IntPtr)>(z_GetProgramPipelineiv_adr);
    private z_GetProgramPipelineiv_2 := GetProcOrNil&<procedure(pipeline: gl_program_pipeline; pname: PipelineParameterName; var &params: Int32)>(z_GetProgramPipelineiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramPipelineiv(pipeline: gl_program_pipeline; pname: PipelineParameterName; var &params: Int32) :=
    z_GetProgramPipelineiv_2(pipeline, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramPipelineiv(pipeline: gl_program_pipeline; pname: PipelineParameterName; &params: IntPtr) :=
    z_GetProgramPipelineiv_1(pipeline, pname, &params);
    
    // added in gl4.3
    private z_GetProgramResourceIndex_adr := GetProcAddress('glGetProgramResourceIndex');
    private z_GetProgramResourceIndex_1 := GetProcOrNil&<function(&program: gl_program; _programInterface: ProgramInterface; name: IntPtr): UInt32>(z_GetProgramResourceIndex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProgramResourceIndex(&program: gl_program; _programInterface: ProgramInterface; name: string): UInt32;
    begin
      var name_str_ptr: IntPtr;
      try
        name_str_ptr := Marshal.StringToHGlobalAnsi(name);
        Result := z_GetProgramResourceIndex_1(&program, _programInterface, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProgramResourceIndex(&program: gl_program; _programInterface: ProgramInterface; name: IntPtr): UInt32 :=
    z_GetProgramResourceIndex_1(&program, _programInterface, name);
    
    // added in gl4.3
    private z_GetProgramResourceiv_adr := GetProcAddress('glGetProgramResourceiv');
    private z_GetProgramResourceiv_1 := GetProcOrNil&<procedure(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; length: IntPtr; &params: IntPtr)>(z_GetProgramResourceiv_adr);
    private z_GetProgramResourceiv_2 := GetProcOrNil&<procedure(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; length: IntPtr; var &params: Int32)>(z_GetProgramResourceiv_adr);
    private z_GetProgramResourceiv_3 := GetProcOrNil&<procedure(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; var length: Int32; &params: IntPtr)>(z_GetProgramResourceiv_adr);
    private z_GetProgramResourceiv_4 := GetProcOrNil&<procedure(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; var length: Int32; var &params: Int32)>(z_GetProgramResourceiv_adr);
    private z_GetProgramResourceiv_5 := GetProcOrNil&<procedure(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; var props: ProgramResourceProperty; count: Int32; length: IntPtr; &params: IntPtr)>(z_GetProgramResourceiv_adr);
    private z_GetProgramResourceiv_6 := GetProcOrNil&<procedure(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; var props: ProgramResourceProperty; count: Int32; length: IntPtr; var &params: Int32)>(z_GetProgramResourceiv_adr);
    private z_GetProgramResourceiv_7 := GetProcOrNil&<procedure(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; var props: ProgramResourceProperty; count: Int32; var length: Int32; &params: IntPtr)>(z_GetProgramResourceiv_adr);
    private z_GetProgramResourceiv_8 := GetProcOrNil&<procedure(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; var props: ProgramResourceProperty; count: Int32; var length: Int32; var &params: Int32)>(z_GetProgramResourceiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; props: array of ProgramResourceProperty; count: Int32; var length: Int32; var &params: Int32);
    type PProgramResourceProperty=^ProgramResourceProperty;
    begin
      if (props<>nil) and (props.Length<>0) then
        z_GetProgramResourceiv_8(&program, _programInterface, index, propCount, props[0], count, length, &params) else
        z_GetProgramResourceiv_8(&program, _programInterface, index, propCount, PProgramResourceProperty(nil)^, count, length, &params);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; props: array of ProgramResourceProperty; count: Int32; var length: Int32; &params: IntPtr);
    type PProgramResourceProperty=^ProgramResourceProperty;
    begin
      if (props<>nil) and (props.Length<>0) then
        z_GetProgramResourceiv_7(&program, _programInterface, index, propCount, props[0], count, length, &params) else
        z_GetProgramResourceiv_7(&program, _programInterface, index, propCount, PProgramResourceProperty(nil)^, count, length, &params);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; props: array of ProgramResourceProperty; count: Int32; length: IntPtr; var &params: Int32);
    type PProgramResourceProperty=^ProgramResourceProperty;
    begin
      if (props<>nil) and (props.Length<>0) then
        z_GetProgramResourceiv_6(&program, _programInterface, index, propCount, props[0], count, length, &params) else
        z_GetProgramResourceiv_6(&program, _programInterface, index, propCount, PProgramResourceProperty(nil)^, count, length, &params);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; props: array of ProgramResourceProperty; count: Int32; length: IntPtr; &params: IntPtr);
    type PProgramResourceProperty=^ProgramResourceProperty;
    begin
      if (props<>nil) and (props.Length<>0) then
        z_GetProgramResourceiv_5(&program, _programInterface, index, propCount, props[0], count, length, &params) else
        z_GetProgramResourceiv_5(&program, _programInterface, index, propCount, PProgramResourceProperty(nil)^, count, length, &params);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; var props: ProgramResourceProperty; count: Int32; var length: Int32; var &params: Int32) :=
    z_GetProgramResourceiv_8(&program, _programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; var props: ProgramResourceProperty; count: Int32; var length: Int32; &params: IntPtr) :=
    z_GetProgramResourceiv_7(&program, _programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; var props: ProgramResourceProperty; count: Int32; length: IntPtr; var &params: Int32) :=
    z_GetProgramResourceiv_6(&program, _programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; var props: ProgramResourceProperty; count: Int32; length: IntPtr; &params: IntPtr) :=
    z_GetProgramResourceiv_5(&program, _programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; var length: Int32; var &params: Int32) :=
    z_GetProgramResourceiv_4(&program, _programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; var length: Int32; &params: IntPtr) :=
    z_GetProgramResourceiv_3(&program, _programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; length: IntPtr; var &params: Int32) :=
    z_GetProgramResourceiv_2(&program, _programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; length: IntPtr; &params: IntPtr) :=
    z_GetProgramResourceiv_1(&program, _programInterface, index, propCount, props, count, length, &params);
    
    // added in gl4.3
    private z_GetProgramResourceLocation_adr := GetProcAddress('glGetProgramResourceLocation');
    private z_GetProgramResourceLocation_1 := GetProcOrNil&<function(&program: gl_program; _programInterface: ProgramInterface; name: IntPtr): Int32>(z_GetProgramResourceLocation_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProgramResourceLocation(&program: gl_program; _programInterface: ProgramInterface; name: string): Int32;
    begin
      var name_str_ptr: IntPtr;
      try
        name_str_ptr := Marshal.StringToHGlobalAnsi(name);
        Result := z_GetProgramResourceLocation_1(&program, _programInterface, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProgramResourceLocation(&program: gl_program; _programInterface: ProgramInterface; name: IntPtr): Int32 :=
    z_GetProgramResourceLocation_1(&program, _programInterface, name);
    
    // added in gl4.3
    private z_GetProgramResourceLocationIndex_adr := GetProcAddress('glGetProgramResourceLocationIndex');
    private z_GetProgramResourceLocationIndex_1 := GetProcOrNil&<function(&program: gl_program; _programInterface: ProgramInterface; name: IntPtr): Int32>(z_GetProgramResourceLocationIndex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProgramResourceLocationIndex(&program: gl_program; _programInterface: ProgramInterface; name: string): Int32;
    begin
      var name_str_ptr: IntPtr;
      try
        name_str_ptr := Marshal.StringToHGlobalAnsi(name);
        Result := z_GetProgramResourceLocationIndex_1(&program, _programInterface, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProgramResourceLocationIndex(&program: gl_program; _programInterface: ProgramInterface; name: IntPtr): Int32 :=
    z_GetProgramResourceLocationIndex_1(&program, _programInterface, name);
    
    // added in gl4.3
    private z_GetProgramResourceName_adr := GetProcAddress('glGetProgramResourceName');
    private z_GetProgramResourceName_1 := GetProcOrNil&<procedure(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; bufSize: Int32; length: IntPtr; name: IntPtr)>(z_GetProgramResourceName_adr);
    private z_GetProgramResourceName_2 := GetProcOrNil&<procedure(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; bufSize: Int32; var length: Int32; name: IntPtr)>(z_GetProgramResourceName_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceName(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; bufSize: Int32; var length: Int32; name: IntPtr) :=
    z_GetProgramResourceName_2(&program, _programInterface, index, bufSize, length, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceName(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; bufSize: Int32; length: IntPtr; name: IntPtr) :=
    z_GetProgramResourceName_1(&program, _programInterface, index, bufSize, length, name);
    
    // added in gl4.0
    private z_GetProgramStageiv_adr := GetProcAddress('glGetProgramStageiv');
    private z_GetProgramStageiv_1 := GetProcOrNil&<procedure(&program: gl_program; _shadertype: ShaderType; pname: ProgramStagePName; values: IntPtr)>(z_GetProgramStageiv_adr);
    private z_GetProgramStageiv_2 := GetProcOrNil&<procedure(&program: gl_program; _shadertype: ShaderType; pname: ProgramStagePName; var values: Int32)>(z_GetProgramStageiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramStageiv(&program: gl_program; _shadertype: ShaderType; pname: ProgramStagePName; var values: Int32) :=
    z_GetProgramStageiv_2(&program, _shadertype, pname, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramStageiv(&program: gl_program; _shadertype: ShaderType; pname: ProgramStagePName; values: IntPtr) :=
    z_GetProgramStageiv_1(&program, _shadertype, pname, values);
    
    // added in gl4.5
    private z_GetQueryBufferObjecti64v_adr := GetProcAddress('glGetQueryBufferObjecti64v');
    private z_GetQueryBufferObjecti64v_1 := GetProcOrNil&<procedure(id: gl_query; buffer: gl_buffer; pname: QueryObjectParameterName; offset: IntPtr)>(z_GetQueryBufferObjecti64v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryBufferObjecti64v(id: gl_query; buffer: gl_buffer; pname: QueryObjectParameterName; offset: IntPtr) :=
    z_GetQueryBufferObjecti64v_1(id, buffer, pname, offset);
    
    // added in gl4.5
    private z_GetQueryBufferObjectiv_adr := GetProcAddress('glGetQueryBufferObjectiv');
    private z_GetQueryBufferObjectiv_1 := GetProcOrNil&<procedure(id: gl_query; buffer: gl_buffer; pname: QueryObjectParameterName; offset: IntPtr)>(z_GetQueryBufferObjectiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryBufferObjectiv(id: gl_query; buffer: gl_buffer; pname: QueryObjectParameterName; offset: IntPtr) :=
    z_GetQueryBufferObjectiv_1(id, buffer, pname, offset);
    
    // added in gl4.5
    private z_GetQueryBufferObjectui64v_adr := GetProcAddress('glGetQueryBufferObjectui64v');
    private z_GetQueryBufferObjectui64v_1 := GetProcOrNil&<procedure(id: gl_query; buffer: gl_buffer; pname: QueryObjectParameterName; offset: IntPtr)>(z_GetQueryBufferObjectui64v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryBufferObjectui64v(id: gl_query; buffer: gl_buffer; pname: QueryObjectParameterName; offset: IntPtr) :=
    z_GetQueryBufferObjectui64v_1(id, buffer, pname, offset);
    
    // added in gl4.5
    private z_GetQueryBufferObjectuiv_adr := GetProcAddress('glGetQueryBufferObjectuiv');
    private z_GetQueryBufferObjectuiv_1 := GetProcOrNil&<procedure(id: gl_query; buffer: gl_buffer; pname: QueryObjectParameterName; offset: IntPtr)>(z_GetQueryBufferObjectuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryBufferObjectuiv(id: gl_query; buffer: gl_buffer; pname: QueryObjectParameterName; offset: IntPtr) :=
    z_GetQueryBufferObjectuiv_1(id, buffer, pname, offset);
    
    // added in gl4.0
    private z_GetQueryIndexediv_adr := GetProcAddress('glGetQueryIndexediv');
    private z_GetQueryIndexediv_1 := GetProcOrNil&<procedure(target: QueryTarget; index: UInt32; pname: QueryParameterName; &params: IntPtr)>(z_GetQueryIndexediv_adr);
    private z_GetQueryIndexediv_2 := GetProcOrNil&<procedure(target: QueryTarget; index: UInt32; pname: QueryParameterName; var &params: Int32)>(z_GetQueryIndexediv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryIndexediv(target: QueryTarget; index: UInt32; pname: QueryParameterName; var &params: Int32) :=
    z_GetQueryIndexediv_2(target, index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryIndexediv(target: QueryTarget; index: UInt32; pname: QueryParameterName; &params: IntPtr) :=
    z_GetQueryIndexediv_1(target, index, pname, &params);
    
    // added in gl1.5
    private z_GetQueryiv_adr := GetProcAddress('glGetQueryiv');
    private z_GetQueryiv_1 := GetProcOrNil&<procedure(target: QueryTarget; pname: QueryParameterName; &params: IntPtr)>(z_GetQueryiv_adr);
    private z_GetQueryiv_2 := GetProcOrNil&<procedure(target: QueryTarget; pname: QueryParameterName; var &params: Int32)>(z_GetQueryiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryiv(target: QueryTarget; pname: QueryParameterName; var &params: Int32) :=
    z_GetQueryiv_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryiv(target: QueryTarget; pname: QueryParameterName; &params: IntPtr) :=
    z_GetQueryiv_1(target, pname, &params);
    
    // added in gl3.3
    private z_GetQueryObjecti64v_adr := GetProcAddress('glGetQueryObjecti64v');
    private z_GetQueryObjecti64v_1 := GetProcOrNil&<procedure(id: gl_query; pname: QueryObjectParameterName; &params: IntPtr)>(z_GetQueryObjecti64v_adr);
    private z_GetQueryObjecti64v_2 := GetProcOrNil&<procedure(id: gl_query; pname: QueryObjectParameterName; var &params: Int64)>(z_GetQueryObjecti64v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjecti64v(id: gl_query; pname: QueryObjectParameterName; var &params: Int64) :=
    z_GetQueryObjecti64v_2(id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjecti64v(id: gl_query; pname: QueryObjectParameterName; &params: IntPtr) :=
    z_GetQueryObjecti64v_1(id, pname, &params);
    
    // added in gl1.5
    private z_GetQueryObjectiv_adr := GetProcAddress('glGetQueryObjectiv');
    private z_GetQueryObjectiv_1 := GetProcOrNil&<procedure(id: gl_query; pname: QueryObjectParameterName; &params: IntPtr)>(z_GetQueryObjectiv_adr);
    private z_GetQueryObjectiv_2 := GetProcOrNil&<procedure(id: gl_query; pname: QueryObjectParameterName; var &params: Int32)>(z_GetQueryObjectiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectiv(id: gl_query; pname: QueryObjectParameterName; var &params: Int32) :=
    z_GetQueryObjectiv_2(id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectiv(id: gl_query; pname: QueryObjectParameterName; &params: IntPtr) :=
    z_GetQueryObjectiv_1(id, pname, &params);
    
    // added in gl3.3
    private z_GetQueryObjectui64v_adr := GetProcAddress('glGetQueryObjectui64v');
    private z_GetQueryObjectui64v_1 := GetProcOrNil&<procedure(id: gl_query; pname: QueryObjectParameterName; &params: IntPtr)>(z_GetQueryObjectui64v_adr);
    private z_GetQueryObjectui64v_2 := GetProcOrNil&<procedure(id: gl_query; pname: QueryObjectParameterName; var &params: UInt64)>(z_GetQueryObjectui64v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectui64v(id: gl_query; pname: QueryObjectParameterName; var &params: UInt64) :=
    z_GetQueryObjectui64v_2(id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectui64v(id: gl_query; pname: QueryObjectParameterName; &params: IntPtr) :=
    z_GetQueryObjectui64v_1(id, pname, &params);
    
    // added in gl1.5
    private z_GetQueryObjectuiv_adr := GetProcAddress('glGetQueryObjectuiv');
    private z_GetQueryObjectuiv_1 := GetProcOrNil&<procedure(id: gl_query; pname: QueryObjectParameterName; &params: IntPtr)>(z_GetQueryObjectuiv_adr);
    private z_GetQueryObjectuiv_2 := GetProcOrNil&<procedure(id: gl_query; pname: QueryObjectParameterName; var &params: UInt32)>(z_GetQueryObjectuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectuiv(id: gl_query; pname: QueryObjectParameterName; var &params: UInt32) :=
    z_GetQueryObjectuiv_2(id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectuiv(id: gl_query; pname: QueryObjectParameterName; &params: IntPtr) :=
    z_GetQueryObjectuiv_1(id, pname, &params);
    
    // added in gl3.0
    private z_GetRenderbufferParameteriv_adr := GetProcAddress('glGetRenderbufferParameteriv');
    private z_GetRenderbufferParameteriv_1 := GetProcOrNil&<procedure(target: RenderbufferTarget; pname: RenderbufferParameterName; &params: IntPtr)>(z_GetRenderbufferParameteriv_adr);
    private z_GetRenderbufferParameteriv_2 := GetProcOrNil&<procedure(target: RenderbufferTarget; pname: RenderbufferParameterName; var &params: Int32)>(z_GetRenderbufferParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetRenderbufferParameteriv(target: RenderbufferTarget; pname: RenderbufferParameterName; var &params: Int32) :=
    z_GetRenderbufferParameteriv_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetRenderbufferParameteriv(target: RenderbufferTarget; pname: RenderbufferParameterName; &params: IntPtr) :=
    z_GetRenderbufferParameteriv_1(target, pname, &params);
    
    // added in gl3.3
    private z_GetSamplerParameterfv_adr := GetProcAddress('glGetSamplerParameterfv');
    private z_GetSamplerParameterfv_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: SamplerParameterF; &params: IntPtr)>(z_GetSamplerParameterfv_adr);
    private z_GetSamplerParameterfv_2 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: SamplerParameterF; var &params: single)>(z_GetSamplerParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterfv(sampler: gl_sampler; pname: SamplerParameterF; var &params: single) :=
    z_GetSamplerParameterfv_2(sampler, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterfv(sampler: gl_sampler; pname: SamplerParameterF; &params: IntPtr) :=
    z_GetSamplerParameterfv_1(sampler, pname, &params);
    
    // added in gl3.3
    private z_GetSamplerParameterIiv_adr := GetProcAddress('glGetSamplerParameterIiv');
    private z_GetSamplerParameterIiv_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: SamplerParameterI; &params: IntPtr)>(z_GetSamplerParameterIiv_adr);
    private z_GetSamplerParameterIiv_2 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: SamplerParameterI; var &params: Int32)>(z_GetSamplerParameterIiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterIiv(sampler: gl_sampler; pname: SamplerParameterI; var &params: Int32) :=
    z_GetSamplerParameterIiv_2(sampler, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterIiv(sampler: gl_sampler; pname: SamplerParameterI; &params: IntPtr) :=
    z_GetSamplerParameterIiv_1(sampler, pname, &params);
    
    // added in gl3.3
    private z_GetSamplerParameterIuiv_adr := GetProcAddress('glGetSamplerParameterIuiv');
    private z_GetSamplerParameterIuiv_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: SamplerParameterI; &params: IntPtr)>(z_GetSamplerParameterIuiv_adr);
    private z_GetSamplerParameterIuiv_2 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: SamplerParameterI; var &params: UInt32)>(z_GetSamplerParameterIuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterIuiv(sampler: gl_sampler; pname: SamplerParameterI; var &params: UInt32) :=
    z_GetSamplerParameterIuiv_2(sampler, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterIuiv(sampler: gl_sampler; pname: SamplerParameterI; &params: IntPtr) :=
    z_GetSamplerParameterIuiv_1(sampler, pname, &params);
    
    // added in gl3.3
    private z_GetSamplerParameteriv_adr := GetProcAddress('glGetSamplerParameteriv');
    private z_GetSamplerParameteriv_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: SamplerParameterI; &params: IntPtr)>(z_GetSamplerParameteriv_adr);
    private z_GetSamplerParameteriv_2 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: SamplerParameterI; var &params: Int32)>(z_GetSamplerParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameteriv(sampler: gl_sampler; pname: SamplerParameterI; var &params: Int32) :=
    z_GetSamplerParameteriv_2(sampler, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameteriv(sampler: gl_sampler; pname: SamplerParameterI; &params: IntPtr) :=
    z_GetSamplerParameteriv_1(sampler, pname, &params);
    
    // added in gl2.0
    private z_GetShaderInfoLog_adr := GetProcAddress('glGetShaderInfoLog');
    private z_GetShaderInfoLog_1 := GetProcOrNil&<procedure(shader: gl_shader; bufSize: Int32; length: IntPtr; infoLog: IntPtr)>(z_GetShaderInfoLog_adr);
    private z_GetShaderInfoLog_2 := GetProcOrNil&<procedure(shader: gl_shader; bufSize: Int32; var length: Int32; infoLog: IntPtr)>(z_GetShaderInfoLog_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderInfoLog(shader: gl_shader; bufSize: Int32; var length: Int32; infoLog: IntPtr) :=
    z_GetShaderInfoLog_2(shader, bufSize, length, infoLog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderInfoLog(shader: gl_shader; bufSize: Int32; length: IntPtr; infoLog: IntPtr) :=
    z_GetShaderInfoLog_1(shader, bufSize, length, infoLog);
    
    // added in gl2.0
    private z_GetShaderiv_adr := GetProcAddress('glGetShaderiv');
    private z_GetShaderiv_1 := GetProcOrNil&<procedure(shader: gl_shader; pname: ShaderParameterName; &params: IntPtr)>(z_GetShaderiv_adr);
    private z_GetShaderiv_2 := GetProcOrNil&<procedure(shader: gl_shader; pname: ShaderParameterName; var &params: Int32)>(z_GetShaderiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderiv(shader: gl_shader; pname: ShaderParameterName; var &params: Int32) :=
    z_GetShaderiv_2(shader, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderiv(shader: gl_shader; pname: ShaderParameterName; &params: IntPtr) :=
    z_GetShaderiv_1(shader, pname, &params);
    
    // added in gl4.1
    private z_GetShaderPrecisionFormat_adr := GetProcAddress('glGetShaderPrecisionFormat');
    private z_GetShaderPrecisionFormat_1 := GetProcOrNil&<procedure(_shadertype: ShaderType; _precisiontype: PrecisionType; range: IntPtr; precision: IntPtr)>(z_GetShaderPrecisionFormat_adr);
    private z_GetShaderPrecisionFormat_2 := GetProcOrNil&<procedure(_shadertype: ShaderType; _precisiontype: PrecisionType; range: IntPtr; var precision: Int32)>(z_GetShaderPrecisionFormat_adr);
    private z_GetShaderPrecisionFormat_3 := GetProcOrNil&<procedure(_shadertype: ShaderType; _precisiontype: PrecisionType; var range: Int32; precision: IntPtr)>(z_GetShaderPrecisionFormat_adr);
    private z_GetShaderPrecisionFormat_4 := GetProcOrNil&<procedure(_shadertype: ShaderType; _precisiontype: PrecisionType; var range: Int32; var precision: Int32)>(z_GetShaderPrecisionFormat_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderPrecisionFormat(_shadertype: ShaderType; _precisiontype: PrecisionType; var range: Int32; var precision: Int32) :=
    z_GetShaderPrecisionFormat_4(_shadertype, _precisiontype, range, precision);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderPrecisionFormat(_shadertype: ShaderType; _precisiontype: PrecisionType; var range: Int32; precision: IntPtr) :=
    z_GetShaderPrecisionFormat_3(_shadertype, _precisiontype, range, precision);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderPrecisionFormat(_shadertype: ShaderType; _precisiontype: PrecisionType; range: IntPtr; var precision: Int32) :=
    z_GetShaderPrecisionFormat_2(_shadertype, _precisiontype, range, precision);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderPrecisionFormat(_shadertype: ShaderType; _precisiontype: PrecisionType; range: IntPtr; precision: IntPtr) :=
    z_GetShaderPrecisionFormat_1(_shadertype, _precisiontype, range, precision);
    
    // added in gl2.0
    private z_GetShaderSource_adr := GetProcAddress('glGetShaderSource');
    private z_GetShaderSource_1 := GetProcOrNil&<procedure(shader: gl_shader; bufSize: Int32; length: IntPtr; source: IntPtr)>(z_GetShaderSource_adr);
    private z_GetShaderSource_2 := GetProcOrNil&<procedure(shader: gl_shader; bufSize: Int32; var length: Int32; source: IntPtr)>(z_GetShaderSource_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderSource(shader: gl_shader; bufSize: Int32; var length: Int32; source: IntPtr) :=
    z_GetShaderSource_2(shader, bufSize, length, source);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderSource(shader: gl_shader; bufSize: Int32; length: IntPtr; source: IntPtr) :=
    z_GetShaderSource_1(shader, bufSize, length, source);
    
    // added in gl1.0
    private z_GetString_adr := GetProcAddress('glGetString');
    private z_GetString_1 := GetProcOrNil&<function(name: StringName): IntPtr>(z_GetString_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetString(name: StringName): string;
    begin
      var Result_str_ptr: IntPtr;
      Result_str_ptr := z_GetString_1(name);
      Result := Marshal.PtrToStringAnsi(Result_str_ptr);
    end;
    
    // added in gl3.0
    private z_GetStringi_adr := GetProcAddress('glGetStringi');
    private z_GetStringi_1 := GetProcOrNil&<function(name: StringName; index: UInt32): IntPtr>(z_GetStringi_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetStringi(name: StringName; index: UInt32): string;
    begin
      var Result_str_ptr: IntPtr;
      Result_str_ptr := z_GetStringi_1(name, index);
      Result := Marshal.PtrToStringAnsi(Result_str_ptr);
    end;
    
    // added in gl4.0
    private z_GetSubroutineIndex_adr := GetProcAddress('glGetSubroutineIndex');
    private z_GetSubroutineIndex_1 := GetProcOrNil&<function(&program: gl_program; _shadertype: ShaderType; name: IntPtr): UInt32>(z_GetSubroutineIndex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSubroutineIndex(&program: gl_program; _shadertype: ShaderType; name: string): UInt32;
    begin
      var name_str_ptr: IntPtr;
      try
        name_str_ptr := Marshal.StringToHGlobalAnsi(name);
        Result := z_GetSubroutineIndex_1(&program, _shadertype, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSubroutineIndex(&program: gl_program; _shadertype: ShaderType; name: IntPtr): UInt32 :=
    z_GetSubroutineIndex_1(&program, _shadertype, name);
    
    // added in gl4.0
    private z_GetSubroutineUniformLocation_adr := GetProcAddress('glGetSubroutineUniformLocation');
    private z_GetSubroutineUniformLocation_1 := GetProcOrNil&<function(&program: gl_program; _shadertype: ShaderType; name: IntPtr): Int32>(z_GetSubroutineUniformLocation_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSubroutineUniformLocation(&program: gl_program; _shadertype: ShaderType; name: string): Int32;
    begin
      var name_str_ptr: IntPtr;
      try
        name_str_ptr := Marshal.StringToHGlobalAnsi(name);
        Result := z_GetSubroutineUniformLocation_1(&program, _shadertype, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSubroutineUniformLocation(&program: gl_program; _shadertype: ShaderType; name: IntPtr): Int32 :=
    z_GetSubroutineUniformLocation_1(&program, _shadertype, name);
    
    // added in gl3.2
    private z_GetSynciv_adr := GetProcAddress('glGetSynciv');
    private z_GetSynciv_1 := GetProcOrNil&<procedure(sync: gl_sync; pname: SyncParameterName; count: Int32; length: IntPtr; values: IntPtr)>(z_GetSynciv_adr);
    private z_GetSynciv_2 := GetProcOrNil&<procedure(sync: gl_sync; pname: SyncParameterName; count: Int32; length: IntPtr; var values: Int32)>(z_GetSynciv_adr);
    private z_GetSynciv_3 := GetProcOrNil&<procedure(sync: gl_sync; pname: SyncParameterName; count: Int32; var length: Int32; values: IntPtr)>(z_GetSynciv_adr);
    private z_GetSynciv_4 := GetProcOrNil&<procedure(sync: gl_sync; pname: SyncParameterName; count: Int32; var length: Int32; var values: Int32)>(z_GetSynciv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSynciv(sync: gl_sync; pname: SyncParameterName; count: Int32; var length: Int32; var values: Int32) :=
    z_GetSynciv_4(sync, pname, count, length, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSynciv(sync: gl_sync; pname: SyncParameterName; count: Int32; var length: Int32; values: IntPtr) :=
    z_GetSynciv_3(sync, pname, count, length, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSynciv(sync: gl_sync; pname: SyncParameterName; count: Int32; length: IntPtr; var values: Int32) :=
    z_GetSynciv_2(sync, pname, count, length, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSynciv(sync: gl_sync; pname: SyncParameterName; count: Int32; length: IntPtr; values: IntPtr) :=
    z_GetSynciv_1(sync, pname, count, length, values);
    
    // added in gl1.0
    private z_GetTexImage_adr := GetProcAddress('glGetTexImage');
    private z_GetTexImage_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr)>(z_GetTexImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexImage(target: TextureTarget; level: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr) :=
    z_GetTexImage_1(target, level, format, &type, pixels);
    
    // added in gl1.0
    private z_GetTexLevelParameterfv_adr := GetProcAddress('glGetTexLevelParameterfv');
    private z_GetTexLevelParameterfv_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; pname: GetTextureParameter; &params: IntPtr)>(z_GetTexLevelParameterfv_adr);
    private z_GetTexLevelParameterfv_2 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; pname: GetTextureParameter; var &params: single)>(z_GetTexLevelParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexLevelParameterfv(target: TextureTarget; level: Int32; pname: GetTextureParameter; var &params: single) :=
    z_GetTexLevelParameterfv_2(target, level, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexLevelParameterfv(target: TextureTarget; level: Int32; pname: GetTextureParameter; &params: IntPtr) :=
    z_GetTexLevelParameterfv_1(target, level, pname, &params);
    
    // added in gl1.0
    private z_GetTexLevelParameteriv_adr := GetProcAddress('glGetTexLevelParameteriv');
    private z_GetTexLevelParameteriv_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; pname: GetTextureParameter; &params: IntPtr)>(z_GetTexLevelParameteriv_adr);
    private z_GetTexLevelParameteriv_2 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; pname: GetTextureParameter; var &params: Int32)>(z_GetTexLevelParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexLevelParameteriv(target: TextureTarget; level: Int32; pname: GetTextureParameter; var &params: Int32) :=
    z_GetTexLevelParameteriv_2(target, level, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexLevelParameteriv(target: TextureTarget; level: Int32; pname: GetTextureParameter; &params: IntPtr) :=
    z_GetTexLevelParameteriv_1(target, level, pname, &params);
    
    // added in gl1.0
    private z_GetTexParameterfv_adr := GetProcAddress('glGetTexParameterfv');
    private z_GetTexParameterfv_1 := GetProcOrNil&<procedure(target: TextureTarget; pname: GetTextureParameter; &params: IntPtr)>(z_GetTexParameterfv_adr);
    private z_GetTexParameterfv_2 := GetProcOrNil&<procedure(target: TextureTarget; pname: GetTextureParameter; var &params: single)>(z_GetTexParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterfv(target: TextureTarget; pname: GetTextureParameter; var &params: single) :=
    z_GetTexParameterfv_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterfv(target: TextureTarget; pname: GetTextureParameter; &params: IntPtr) :=
    z_GetTexParameterfv_1(target, pname, &params);
    
    // added in gl3.0
    private z_GetTexParameterIiv_adr := GetProcAddress('glGetTexParameterIiv');
    private z_GetTexParameterIiv_1 := GetProcOrNil&<procedure(target: TextureTarget; pname: GetTextureParameter; &params: IntPtr)>(z_GetTexParameterIiv_adr);
    private z_GetTexParameterIiv_2 := GetProcOrNil&<procedure(target: TextureTarget; pname: GetTextureParameter; var &params: Int32)>(z_GetTexParameterIiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIiv(target: TextureTarget; pname: GetTextureParameter; var &params: Int32) :=
    z_GetTexParameterIiv_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIiv(target: TextureTarget; pname: GetTextureParameter; &params: IntPtr) :=
    z_GetTexParameterIiv_1(target, pname, &params);
    
    // added in gl3.0
    private z_GetTexParameterIuiv_adr := GetProcAddress('glGetTexParameterIuiv');
    private z_GetTexParameterIuiv_1 := GetProcOrNil&<procedure(target: TextureTarget; pname: GetTextureParameter; &params: IntPtr)>(z_GetTexParameterIuiv_adr);
    private z_GetTexParameterIuiv_2 := GetProcOrNil&<procedure(target: TextureTarget; pname: GetTextureParameter; var &params: UInt32)>(z_GetTexParameterIuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIuiv(target: TextureTarget; pname: GetTextureParameter; var &params: UInt32) :=
    z_GetTexParameterIuiv_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIuiv(target: TextureTarget; pname: GetTextureParameter; &params: IntPtr) :=
    z_GetTexParameterIuiv_1(target, pname, &params);
    
    // added in gl1.0
    private z_GetTexParameteriv_adr := GetProcAddress('glGetTexParameteriv');
    private z_GetTexParameteriv_1 := GetProcOrNil&<procedure(target: TextureTarget; pname: GetTextureParameter; &params: IntPtr)>(z_GetTexParameteriv_adr);
    private z_GetTexParameteriv_2 := GetProcOrNil&<procedure(target: TextureTarget; pname: GetTextureParameter; var &params: Int32)>(z_GetTexParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameteriv(target: TextureTarget; pname: GetTextureParameter; var &params: Int32) :=
    z_GetTexParameteriv_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameteriv(target: TextureTarget; pname: GetTextureParameter; &params: IntPtr) :=
    z_GetTexParameteriv_1(target, pname, &params);
    
    // added in gl4.5
    private z_GetTextureImage_adr := GetProcAddress('glGetTextureImage');
    private z_GetTextureImage_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; format: PixelFormat; &type: PixelType; bufSize: Int32; pixels: IntPtr)>(z_GetTextureImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureImage(texture: gl_texture; level: Int32; format: PixelFormat; &type: PixelType; bufSize: Int32; pixels: IntPtr) :=
    z_GetTextureImage_1(texture, level, format, &type, bufSize, pixels);
    
    // added in gl4.5
    private z_GetTextureLevelParameterfv_adr := GetProcAddress('glGetTextureLevelParameterfv');
    private z_GetTextureLevelParameterfv_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; pname: GetTextureParameter; &params: IntPtr)>(z_GetTextureLevelParameterfv_adr);
    private z_GetTextureLevelParameterfv_2 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; pname: GetTextureParameter; var &params: single)>(z_GetTextureLevelParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureLevelParameterfv(texture: gl_texture; level: Int32; pname: GetTextureParameter; var &params: single) :=
    z_GetTextureLevelParameterfv_2(texture, level, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureLevelParameterfv(texture: gl_texture; level: Int32; pname: GetTextureParameter; &params: IntPtr) :=
    z_GetTextureLevelParameterfv_1(texture, level, pname, &params);
    
    // added in gl4.5
    private z_GetTextureLevelParameteriv_adr := GetProcAddress('glGetTextureLevelParameteriv');
    private z_GetTextureLevelParameteriv_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; pname: GetTextureParameter; &params: IntPtr)>(z_GetTextureLevelParameteriv_adr);
    private z_GetTextureLevelParameteriv_2 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; pname: GetTextureParameter; var &params: Int32)>(z_GetTextureLevelParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureLevelParameteriv(texture: gl_texture; level: Int32; pname: GetTextureParameter; var &params: Int32) :=
    z_GetTextureLevelParameteriv_2(texture, level, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureLevelParameteriv(texture: gl_texture; level: Int32; pname: GetTextureParameter; &params: IntPtr) :=
    z_GetTextureLevelParameteriv_1(texture, level, pname, &params);
    
    // added in gl4.5
    private z_GetTextureParameterfv_adr := GetProcAddress('glGetTextureParameterfv');
    private z_GetTextureParameterfv_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: GetTextureParameter; &params: IntPtr)>(z_GetTextureParameterfv_adr);
    private z_GetTextureParameterfv_2 := GetProcOrNil&<procedure(texture: gl_texture; pname: GetTextureParameter; var &params: single)>(z_GetTextureParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterfv(texture: gl_texture; pname: GetTextureParameter; var &params: single) :=
    z_GetTextureParameterfv_2(texture, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterfv(texture: gl_texture; pname: GetTextureParameter; &params: IntPtr) :=
    z_GetTextureParameterfv_1(texture, pname, &params);
    
    // added in gl4.5
    private z_GetTextureParameterIiv_adr := GetProcAddress('glGetTextureParameterIiv');
    private z_GetTextureParameterIiv_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: GetTextureParameter; &params: IntPtr)>(z_GetTextureParameterIiv_adr);
    private z_GetTextureParameterIiv_2 := GetProcOrNil&<procedure(texture: gl_texture; pname: GetTextureParameter; var &params: Int32)>(z_GetTextureParameterIiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIiv(texture: gl_texture; pname: GetTextureParameter; var &params: Int32) :=
    z_GetTextureParameterIiv_2(texture, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIiv(texture: gl_texture; pname: GetTextureParameter; &params: IntPtr) :=
    z_GetTextureParameterIiv_1(texture, pname, &params);
    
    // added in gl4.5
    private z_GetTextureParameterIuiv_adr := GetProcAddress('glGetTextureParameterIuiv');
    private z_GetTextureParameterIuiv_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: GetTextureParameter; &params: IntPtr)>(z_GetTextureParameterIuiv_adr);
    private z_GetTextureParameterIuiv_2 := GetProcOrNil&<procedure(texture: gl_texture; pname: GetTextureParameter; var &params: UInt32)>(z_GetTextureParameterIuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIuiv(texture: gl_texture; pname: GetTextureParameter; var &params: UInt32) :=
    z_GetTextureParameterIuiv_2(texture, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIuiv(texture: gl_texture; pname: GetTextureParameter; &params: IntPtr) :=
    z_GetTextureParameterIuiv_1(texture, pname, &params);
    
    // added in gl4.5
    private z_GetTextureParameteriv_adr := GetProcAddress('glGetTextureParameteriv');
    private z_GetTextureParameteriv_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: GetTextureParameter; &params: IntPtr)>(z_GetTextureParameteriv_adr);
    private z_GetTextureParameteriv_2 := GetProcOrNil&<procedure(texture: gl_texture; pname: GetTextureParameter; var &params: Int32)>(z_GetTextureParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameteriv(texture: gl_texture; pname: GetTextureParameter; var &params: Int32) :=
    z_GetTextureParameteriv_2(texture, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameteriv(texture: gl_texture; pname: GetTextureParameter; &params: IntPtr) :=
    z_GetTextureParameteriv_1(texture, pname, &params);
    
    // added in gl4.5
    private z_GetTextureSubImage_adr := GetProcAddress('glGetTextureSubImage');
    private z_GetTextureSubImage_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: PixelFormat; &type: PixelType; bufSize: Int32; pixels: IntPtr)>(z_GetTextureSubImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureSubImage(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: PixelFormat; &type: PixelType; bufSize: Int32; pixels: IntPtr) :=
    z_GetTextureSubImage_1(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, bufSize, pixels);
    
    // added in gl4.5
    private z_GetTransformFeedbacki_v_adr := GetProcAddress('glGetTransformFeedbacki_v');
    private z_GetTransformFeedbacki_v_1 := GetProcOrNil&<procedure(xfb: gl_transform_feedback; pname: TransformFeedbackPName; index: UInt32; param: IntPtr)>(z_GetTransformFeedbacki_v_adr);
    private z_GetTransformFeedbacki_v_2 := GetProcOrNil&<procedure(xfb: gl_transform_feedback; pname: TransformFeedbackPName; index: UInt32; var param: Int32)>(z_GetTransformFeedbacki_v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbacki_v(xfb: gl_transform_feedback; pname: TransformFeedbackPName; index: UInt32; var param: Int32) :=
    z_GetTransformFeedbacki_v_2(xfb, pname, index, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbacki_v(xfb: gl_transform_feedback; pname: TransformFeedbackPName; index: UInt32; param: IntPtr) :=
    z_GetTransformFeedbacki_v_1(xfb, pname, index, param);
    
    // added in gl4.5
    private z_GetTransformFeedbacki64_v_adr := GetProcAddress('glGetTransformFeedbacki64_v');
    private z_GetTransformFeedbacki64_v_1 := GetProcOrNil&<procedure(xfb: gl_transform_feedback; pname: TransformFeedbackPName; index: UInt32; param: IntPtr)>(z_GetTransformFeedbacki64_v_adr);
    private z_GetTransformFeedbacki64_v_2 := GetProcOrNil&<procedure(xfb: gl_transform_feedback; pname: TransformFeedbackPName; index: UInt32; var param: Int64)>(z_GetTransformFeedbacki64_v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbacki64_v(xfb: gl_transform_feedback; pname: TransformFeedbackPName; index: UInt32; var param: Int64) :=
    z_GetTransformFeedbacki64_v_2(xfb, pname, index, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbacki64_v(xfb: gl_transform_feedback; pname: TransformFeedbackPName; index: UInt32; param: IntPtr) :=
    z_GetTransformFeedbacki64_v_1(xfb, pname, index, param);
    
    // added in gl4.5
    private z_GetTransformFeedbackiv_adr := GetProcAddress('glGetTransformFeedbackiv');
    private z_GetTransformFeedbackiv_1 := GetProcOrNil&<procedure(xfb: gl_transform_feedback; pname: TransformFeedbackPName; param: IntPtr)>(z_GetTransformFeedbackiv_adr);
    private z_GetTransformFeedbackiv_2 := GetProcOrNil&<procedure(xfb: gl_transform_feedback; pname: TransformFeedbackPName; var param: Int32)>(z_GetTransformFeedbackiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackiv(xfb: gl_transform_feedback; pname: TransformFeedbackPName; var param: Int32) :=
    z_GetTransformFeedbackiv_2(xfb, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackiv(xfb: gl_transform_feedback; pname: TransformFeedbackPName; param: IntPtr) :=
    z_GetTransformFeedbackiv_1(xfb, pname, param);
    
    // added in gl3.0
    private z_GetTransformFeedbackVarying_adr := GetProcAddress('glGetTransformFeedbackVarying');
    private z_GetTransformFeedbackVarying_1 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; &type: IntPtr; name: IntPtr)>(z_GetTransformFeedbackVarying_adr);
    private z_GetTransformFeedbackVarying_2 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; var &type: AttributeType; name: IntPtr)>(z_GetTransformFeedbackVarying_adr);
    private z_GetTransformFeedbackVarying_3 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; &type: IntPtr; name: IntPtr)>(z_GetTransformFeedbackVarying_adr);
    private z_GetTransformFeedbackVarying_4 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; var &type: AttributeType; name: IntPtr)>(z_GetTransformFeedbackVarying_adr);
    private z_GetTransformFeedbackVarying_5 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; &type: IntPtr; name: IntPtr)>(z_GetTransformFeedbackVarying_adr);
    private z_GetTransformFeedbackVarying_6 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; var &type: AttributeType; name: IntPtr)>(z_GetTransformFeedbackVarying_adr);
    private z_GetTransformFeedbackVarying_7 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: IntPtr; name: IntPtr)>(z_GetTransformFeedbackVarying_adr);
    private z_GetTransformFeedbackVarying_8 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: AttributeType; name: IntPtr)>(z_GetTransformFeedbackVarying_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVarying(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: AttributeType; name: IntPtr) :=
    z_GetTransformFeedbackVarying_8(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVarying(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: IntPtr; name: IntPtr) :=
    z_GetTransformFeedbackVarying_7(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVarying(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; var &type: AttributeType; name: IntPtr) :=
    z_GetTransformFeedbackVarying_6(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVarying(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; &type: IntPtr; name: IntPtr) :=
    z_GetTransformFeedbackVarying_5(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVarying(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; var &type: AttributeType; name: IntPtr) :=
    z_GetTransformFeedbackVarying_4(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVarying(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; &type: IntPtr; name: IntPtr) :=
    z_GetTransformFeedbackVarying_3(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVarying(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; var &type: AttributeType; name: IntPtr) :=
    z_GetTransformFeedbackVarying_2(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVarying(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; &type: IntPtr; name: IntPtr) :=
    z_GetTransformFeedbackVarying_1(&program, index, bufSize, length, size, &type, name);
    
    // added in gl3.1
    private z_GetUniformBlockIndex_adr := GetProcAddress('glGetUniformBlockIndex');
    private z_GetUniformBlockIndex_1 := GetProcOrNil&<function(&program: gl_program; uniformBlockName: IntPtr): UInt32>(z_GetUniformBlockIndex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetUniformBlockIndex(&program: gl_program; uniformBlockName: string): UInt32;
    begin
      var uniformBlockName_str_ptr: IntPtr;
      try
        uniformBlockName_str_ptr := Marshal.StringToHGlobalAnsi(uniformBlockName);
        Result := z_GetUniformBlockIndex_1(&program, uniformBlockName_str_ptr);
      finally
        Marshal.FreeHGlobal(uniformBlockName_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetUniformBlockIndex(&program: gl_program; uniformBlockName: IntPtr): UInt32 :=
    z_GetUniformBlockIndex_1(&program, uniformBlockName);
    
    // added in gl4.0
    private z_GetUniformdv_adr := GetProcAddress('glGetUniformdv');
    private z_GetUniformdv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; &params: IntPtr)>(z_GetUniformdv_adr);
    private z_GetUniformdv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; var &params: real)>(z_GetUniformdv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformdv(&program: gl_program; location: Int32; var &params: real) :=
    z_GetUniformdv_2(&program, location, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformdv(&program: gl_program; location: Int32; &params: IntPtr) :=
    z_GetUniformdv_1(&program, location, &params);
    
    // added in gl2.0
    private z_GetUniformfv_adr := GetProcAddress('glGetUniformfv');
    private z_GetUniformfv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; &params: IntPtr)>(z_GetUniformfv_adr);
    private z_GetUniformfv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; var &params: single)>(z_GetUniformfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformfv(&program: gl_program; location: Int32; var &params: single) :=
    z_GetUniformfv_2(&program, location, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformfv(&program: gl_program; location: Int32; &params: IntPtr) :=
    z_GetUniformfv_1(&program, location, &params);
    
    // added in gl3.1
    private z_GetUniformIndices_adr := GetProcAddress('glGetUniformIndices');
    private z_GetUniformIndices_1 := GetProcOrNil&<procedure(&program: gl_program; uniformCount: Int32; uniformNames: pointer; uniformIndices: IntPtr)>(z_GetUniformIndices_adr);
    private z_GetUniformIndices_2 := GetProcOrNil&<procedure(&program: gl_program; uniformCount: Int32; uniformNames: pointer; var uniformIndices: UInt32)>(z_GetUniformIndices_adr);
    private z_GetUniformIndices_3 := GetProcOrNil&<procedure(&program: gl_program; uniformCount: Int32; var uniformNames: IntPtr; uniformIndices: IntPtr)>(z_GetUniformIndices_adr);
    private z_GetUniformIndices_4 := GetProcOrNil&<procedure(&program: gl_program; uniformCount: Int32; var uniformNames: IntPtr; var uniformIndices: UInt32)>(z_GetUniformIndices_adr);
    private [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure temp_GetUniformIndices_1(&program: gl_program; uniformCount: Int32; uniformNames: array of IntPtr; uniformIndices: IntPtr);
    type PIntPtr=^IntPtr;
    begin
      if (uniformNames<>nil) and (uniformNames.Length<>0) then
        z_GetUniformIndices_3(&program, uniformCount, uniformNames[0], uniformIndices) else
        z_GetUniformIndices_3(&program, uniformCount, PIntPtr(nil)^, uniformIndices);
    end;
    private [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure temp_GetUniformIndices_2(&program: gl_program; uniformCount: Int32; uniformNames: array of IntPtr; var uniformIndices: UInt32);
    type PIntPtr=^IntPtr;
    begin
      if (uniformNames<>nil) and (uniformNames.Length<>0) then
        z_GetUniformIndices_4(&program, uniformCount, uniformNames[0], uniformIndices) else
        z_GetUniformIndices_4(&program, uniformCount, PIntPtr(nil)^, uniformIndices);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformIndices(&program: gl_program; uniformCount: Int32; uniformNames: array of string; var uniformIndices: UInt32);
    begin
      var uniformNames_str_ptrs: array of IntPtr;
      try
        uniformNames_str_ptrs := uniformNames?.ConvertAll(arr_el1->
          Marshal.StringToHGlobalAnsi(arr_el1)
        );
        temp_GetUniformIndices_2(&program, uniformCount, uniformNames_str_ptrs, uniformIndices);
      finally
        if uniformNames_str_ptrs<>nil then foreach var arr_el1 in uniformNames_str_ptrs do
          Marshal.FreeHGlobal(arr_el1);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformIndices(&program: gl_program; uniformCount: Int32; uniformNames: array of string; uniformIndices: IntPtr);
    begin
      var uniformNames_str_ptrs: array of IntPtr;
      try
        uniformNames_str_ptrs := uniformNames?.ConvertAll(arr_el1->
          Marshal.StringToHGlobalAnsi(arr_el1)
        );
        temp_GetUniformIndices_1(&program, uniformCount, uniformNames_str_ptrs, uniformIndices);
      finally
        if uniformNames_str_ptrs<>nil then foreach var arr_el1 in uniformNames_str_ptrs do
          Marshal.FreeHGlobal(arr_el1);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformIndices(&program: gl_program; uniformCount: Int32; var uniformNames: IntPtr; var uniformIndices: UInt32) :=
    z_GetUniformIndices_4(&program, uniformCount, uniformNames, uniformIndices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformIndices(&program: gl_program; uniformCount: Int32; var uniformNames: IntPtr; uniformIndices: IntPtr) :=
    z_GetUniformIndices_3(&program, uniformCount, uniformNames, uniformIndices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformIndices(&program: gl_program; uniformCount: Int32; uniformNames: pointer; var uniformIndices: UInt32) :=
    z_GetUniformIndices_2(&program, uniformCount, uniformNames, uniformIndices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformIndices(&program: gl_program; uniformCount: Int32; uniformNames: pointer; uniformIndices: IntPtr) :=
    z_GetUniformIndices_1(&program, uniformCount, uniformNames, uniformIndices);
    
    // added in gl2.0
    private z_GetUniformiv_adr := GetProcAddress('glGetUniformiv');
    private z_GetUniformiv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; &params: IntPtr)>(z_GetUniformiv_adr);
    private z_GetUniformiv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; var &params: Int32)>(z_GetUniformiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformiv(&program: gl_program; location: Int32; var &params: Int32) :=
    z_GetUniformiv_2(&program, location, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformiv(&program: gl_program; location: Int32; &params: IntPtr) :=
    z_GetUniformiv_1(&program, location, &params);
    
    // added in gl2.0
    private z_GetUniformLocation_adr := GetProcAddress('glGetUniformLocation');
    private z_GetUniformLocation_1 := GetProcOrNil&<function(&program: gl_program; name: IntPtr): Int32>(z_GetUniformLocation_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetUniformLocation(&program: gl_program; name: string): Int32;
    begin
      var name_str_ptr: IntPtr;
      try
        name_str_ptr := Marshal.StringToHGlobalAnsi(name);
        Result := z_GetUniformLocation_1(&program, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetUniformLocation(&program: gl_program; name: IntPtr): Int32 :=
    z_GetUniformLocation_1(&program, name);
    
    // added in gl4.0
    private z_GetUniformSubroutineuiv_adr := GetProcAddress('glGetUniformSubroutineuiv');
    private z_GetUniformSubroutineuiv_1 := GetProcOrNil&<procedure(_shadertype: ShaderType; location: Int32; &params: IntPtr)>(z_GetUniformSubroutineuiv_adr);
    private z_GetUniformSubroutineuiv_2 := GetProcOrNil&<procedure(_shadertype: ShaderType; location: Int32; var &params: UInt32)>(z_GetUniformSubroutineuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformSubroutineuiv(_shadertype: ShaderType; location: Int32; var &params: UInt32) :=
    z_GetUniformSubroutineuiv_2(_shadertype, location, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformSubroutineuiv(_shadertype: ShaderType; location: Int32; &params: IntPtr) :=
    z_GetUniformSubroutineuiv_1(_shadertype, location, &params);
    
    // added in gl3.0
    private z_GetUniformuiv_adr := GetProcAddress('glGetUniformuiv');
    private z_GetUniformuiv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; &params: IntPtr)>(z_GetUniformuiv_adr);
    private z_GetUniformuiv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; var &params: UInt32)>(z_GetUniformuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformuiv(&program: gl_program; location: Int32; var &params: UInt32) :=
    z_GetUniformuiv_2(&program, location, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformuiv(&program: gl_program; location: Int32; &params: IntPtr) :=
    z_GetUniformuiv_1(&program, location, &params);
    
    // added in gl4.5
    private z_GetVertexArrayIndexed64iv_adr := GetProcAddress('glGetVertexArrayIndexed64iv');
    private z_GetVertexArrayIndexed64iv_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32; pname: VertexArrayPName; param: IntPtr)>(z_GetVertexArrayIndexed64iv_adr);
    private z_GetVertexArrayIndexed64iv_2 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32; pname: VertexArrayPName; var param: Int64)>(z_GetVertexArrayIndexed64iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIndexed64iv(vaobj: gl_vertex_array; index: UInt32; pname: VertexArrayPName; var param: Int64) :=
    z_GetVertexArrayIndexed64iv_2(vaobj, index, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIndexed64iv(vaobj: gl_vertex_array; index: UInt32; pname: VertexArrayPName; param: IntPtr) :=
    z_GetVertexArrayIndexed64iv_1(vaobj, index, pname, param);
    
    // added in gl4.5
    private z_GetVertexArrayIndexediv_adr := GetProcAddress('glGetVertexArrayIndexediv');
    private z_GetVertexArrayIndexediv_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32; pname: VertexArrayPName; param: IntPtr)>(z_GetVertexArrayIndexediv_adr);
    private z_GetVertexArrayIndexediv_2 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32; pname: VertexArrayPName; var param: Int32)>(z_GetVertexArrayIndexediv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIndexediv(vaobj: gl_vertex_array; index: UInt32; pname: VertexArrayPName; var param: Int32) :=
    z_GetVertexArrayIndexediv_2(vaobj, index, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIndexediv(vaobj: gl_vertex_array; index: UInt32; pname: VertexArrayPName; param: IntPtr) :=
    z_GetVertexArrayIndexediv_1(vaobj, index, pname, param);
    
    // added in gl4.5
    private z_GetVertexArrayiv_adr := GetProcAddress('glGetVertexArrayiv');
    private z_GetVertexArrayiv_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; pname: VertexArrayPName; param: IntPtr)>(z_GetVertexArrayiv_adr);
    private z_GetVertexArrayiv_2 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; pname: VertexArrayPName; var param: Int32)>(z_GetVertexArrayiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayiv(vaobj: gl_vertex_array; pname: VertexArrayPName; var param: Int32) :=
    z_GetVertexArrayiv_2(vaobj, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayiv(vaobj: gl_vertex_array; pname: VertexArrayPName; param: IntPtr) :=
    z_GetVertexArrayiv_1(vaobj, pname, param);
    
    // added in gl2.0
    private z_GetVertexAttribdv_adr := GetProcAddress('glGetVertexAttribdv');
    private z_GetVertexAttribdv_1 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribProperty; &params: IntPtr)>(z_GetVertexAttribdv_adr);
    private z_GetVertexAttribdv_2 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribProperty; var &params: real)>(z_GetVertexAttribdv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribdv(index: UInt32; pname: VertexAttribProperty; var &params: real) :=
    z_GetVertexAttribdv_2(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribdv(index: UInt32; pname: VertexAttribProperty; &params: IntPtr) :=
    z_GetVertexAttribdv_1(index, pname, &params);
    
    // added in gl2.0
    private z_GetVertexAttribfv_adr := GetProcAddress('glGetVertexAttribfv');
    private z_GetVertexAttribfv_1 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribProperty; &params: IntPtr)>(z_GetVertexAttribfv_adr);
    private z_GetVertexAttribfv_2 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribProperty; var &params: single)>(z_GetVertexAttribfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribfv(index: UInt32; pname: VertexAttribProperty; var &params: single) :=
    z_GetVertexAttribfv_2(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribfv(index: UInt32; pname: VertexAttribProperty; &params: IntPtr) :=
    z_GetVertexAttribfv_1(index, pname, &params);
    
    // added in gl3.0
    private z_GetVertexAttribIiv_adr := GetProcAddress('glGetVertexAttribIiv');
    private z_GetVertexAttribIiv_1 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribEnum; &params: IntPtr)>(z_GetVertexAttribIiv_adr);
    private z_GetVertexAttribIiv_2 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribEnum; var &params: Int32)>(z_GetVertexAttribIiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIiv(index: UInt32; pname: VertexAttribEnum; var &params: Int32) :=
    z_GetVertexAttribIiv_2(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIiv(index: UInt32; pname: VertexAttribEnum; &params: IntPtr) :=
    z_GetVertexAttribIiv_1(index, pname, &params);
    
    // added in gl3.0
    private z_GetVertexAttribIuiv_adr := GetProcAddress('glGetVertexAttribIuiv');
    private z_GetVertexAttribIuiv_1 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribEnum; &params: IntPtr)>(z_GetVertexAttribIuiv_adr);
    private z_GetVertexAttribIuiv_2 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribEnum; var &params: UInt32)>(z_GetVertexAttribIuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIuiv(index: UInt32; pname: VertexAttribEnum; var &params: UInt32) :=
    z_GetVertexAttribIuiv_2(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIuiv(index: UInt32; pname: VertexAttribEnum; &params: IntPtr) :=
    z_GetVertexAttribIuiv_1(index, pname, &params);
    
    // added in gl2.0
    private z_GetVertexAttribiv_adr := GetProcAddress('glGetVertexAttribiv');
    private z_GetVertexAttribiv_1 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribProperty; &params: IntPtr)>(z_GetVertexAttribiv_adr);
    private z_GetVertexAttribiv_2 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribProperty; var &params: Int32)>(z_GetVertexAttribiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribiv(index: UInt32; pname: VertexAttribProperty; var &params: Int32) :=
    z_GetVertexAttribiv_2(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribiv(index: UInt32; pname: VertexAttribProperty; &params: IntPtr) :=
    z_GetVertexAttribiv_1(index, pname, &params);
    
    // added in gl4.1
    private z_GetVertexAttribLdv_adr := GetProcAddress('glGetVertexAttribLdv');
    private z_GetVertexAttribLdv_1 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribEnum; &params: IntPtr)>(z_GetVertexAttribLdv_adr);
    private z_GetVertexAttribLdv_2 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribEnum; var &params: real)>(z_GetVertexAttribLdv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLdv(index: UInt32; pname: VertexAttribEnum; var &params: real) :=
    z_GetVertexAttribLdv_2(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLdv(index: UInt32; pname: VertexAttribEnum; &params: IntPtr) :=
    z_GetVertexAttribLdv_1(index, pname, &params);
    
    // added in gl2.0
    private z_GetVertexAttribPointerv_adr := GetProcAddress('glGetVertexAttribPointerv');
    private z_GetVertexAttribPointerv_1 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribPointerProperty; _pointer: pointer)>(z_GetVertexAttribPointerv_adr);
    private z_GetVertexAttribPointerv_2 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribPointerProperty; var _pointer: IntPtr)>(z_GetVertexAttribPointerv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribPointerv(index: UInt32; pname: VertexAttribPointerProperty; var _pointer: IntPtr) :=
    z_GetVertexAttribPointerv_2(index, pname, _pointer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribPointerv(index: UInt32; pname: VertexAttribPointerProperty; _pointer: pointer) :=
    z_GetVertexAttribPointerv_1(index, pname, _pointer);
    
    // added in gl1.0
    private z_Hint_adr := GetProcAddress('glHint');
    private z_Hint_1 := GetProcOrNil&<procedure(target: HintTarget; mode: HintMode)>(z_Hint_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Hint(target: HintTarget; mode: HintMode) :=
    z_Hint_1(target, mode);
    
    // added in gl4.3
    private z_InvalidateBufferData_adr := GetProcAddress('glInvalidateBufferData');
    private z_InvalidateBufferData_1 := GetProcOrNil&<procedure(buffer: gl_buffer)>(z_InvalidateBufferData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateBufferData(buffer: gl_buffer) :=
    z_InvalidateBufferData_1(buffer);
    
    // added in gl4.3
    private z_InvalidateBufferSubData_adr := GetProcAddress('glInvalidateBufferSubData');
    private z_InvalidateBufferSubData_1 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; length: UIntPtr)>(z_InvalidateBufferSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateBufferSubData(buffer: gl_buffer; offset: IntPtr; length: UIntPtr) :=
    z_InvalidateBufferSubData_1(buffer, offset, length);
    
    // added in gl4.3
    private z_InvalidateFramebuffer_adr := GetProcAddress('glInvalidateFramebuffer');
    private z_InvalidateFramebuffer_1 := GetProcOrNil&<procedure(target: FramebufferTarget; numAttachments: Int32; attachments: IntPtr)>(z_InvalidateFramebuffer_adr);
    private z_InvalidateFramebuffer_2 := GetProcOrNil&<procedure(target: FramebufferTarget; numAttachments: Int32; var attachments: InvalidateFramebufferAttachment)>(z_InvalidateFramebuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateFramebuffer(target: FramebufferTarget; numAttachments: Int32; attachments: array of InvalidateFramebufferAttachment);
    type PInvalidateFramebufferAttachment=^InvalidateFramebufferAttachment;
    begin
      if (attachments<>nil) and (attachments.Length<>0) then
        z_InvalidateFramebuffer_2(target, numAttachments, attachments[0]) else
        z_InvalidateFramebuffer_2(target, numAttachments, PInvalidateFramebufferAttachment(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateFramebuffer(target: FramebufferTarget; numAttachments: Int32; var attachments: InvalidateFramebufferAttachment) :=
    z_InvalidateFramebuffer_2(target, numAttachments, attachments);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateFramebuffer(target: FramebufferTarget; numAttachments: Int32; attachments: IntPtr) :=
    z_InvalidateFramebuffer_1(target, numAttachments, attachments);
    
    // added in gl4.5
    private z_InvalidateNamedFramebufferData_adr := GetProcAddress('glInvalidateNamedFramebufferData');
    private z_InvalidateNamedFramebufferData_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; numAttachments: Int32; attachments: IntPtr)>(z_InvalidateNamedFramebufferData_adr);
    private z_InvalidateNamedFramebufferData_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; numAttachments: Int32; var attachments: FramebufferAttachment)>(z_InvalidateNamedFramebufferData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateNamedFramebufferData(framebuffer: gl_framebuffer; numAttachments: Int32; attachments: array of FramebufferAttachment);
    type PFramebufferAttachment=^FramebufferAttachment;
    begin
      if (attachments<>nil) and (attachments.Length<>0) then
        z_InvalidateNamedFramebufferData_2(framebuffer, numAttachments, attachments[0]) else
        z_InvalidateNamedFramebufferData_2(framebuffer, numAttachments, PFramebufferAttachment(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateNamedFramebufferData(framebuffer: gl_framebuffer; numAttachments: Int32; var attachments: FramebufferAttachment) :=
    z_InvalidateNamedFramebufferData_2(framebuffer, numAttachments, attachments);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateNamedFramebufferData(framebuffer: gl_framebuffer; numAttachments: Int32; attachments: IntPtr) :=
    z_InvalidateNamedFramebufferData_1(framebuffer, numAttachments, attachments);
    
    // added in gl4.5
    private z_InvalidateNamedFramebufferSubData_adr := GetProcAddress('glInvalidateNamedFramebufferSubData');
    private z_InvalidateNamedFramebufferSubData_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; numAttachments: Int32; attachments: IntPtr; x: Int32; y: Int32; width: Int32; height: Int32)>(z_InvalidateNamedFramebufferSubData_adr);
    private z_InvalidateNamedFramebufferSubData_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; numAttachments: Int32; var attachments: FramebufferAttachment; x: Int32; y: Int32; width: Int32; height: Int32)>(z_InvalidateNamedFramebufferSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateNamedFramebufferSubData(framebuffer: gl_framebuffer; numAttachments: Int32; attachments: array of FramebufferAttachment; x: Int32; y: Int32; width: Int32; height: Int32);
    type PFramebufferAttachment=^FramebufferAttachment;
    begin
      if (attachments<>nil) and (attachments.Length<>0) then
        z_InvalidateNamedFramebufferSubData_2(framebuffer, numAttachments, attachments[0], x, y, width, height) else
        z_InvalidateNamedFramebufferSubData_2(framebuffer, numAttachments, PFramebufferAttachment(nil)^, x, y, width, height);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateNamedFramebufferSubData(framebuffer: gl_framebuffer; numAttachments: Int32; var attachments: FramebufferAttachment; x: Int32; y: Int32; width: Int32; height: Int32) :=
    z_InvalidateNamedFramebufferSubData_2(framebuffer, numAttachments, attachments, x, y, width, height);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateNamedFramebufferSubData(framebuffer: gl_framebuffer; numAttachments: Int32; attachments: IntPtr; x: Int32; y: Int32; width: Int32; height: Int32) :=
    z_InvalidateNamedFramebufferSubData_1(framebuffer, numAttachments, attachments, x, y, width, height);
    
    // added in gl4.3
    private z_InvalidateSubFramebuffer_adr := GetProcAddress('glInvalidateSubFramebuffer');
    private z_InvalidateSubFramebuffer_1 := GetProcOrNil&<procedure(target: FramebufferTarget; numAttachments: Int32; attachments: IntPtr; x: Int32; y: Int32; width: Int32; height: Int32)>(z_InvalidateSubFramebuffer_adr);
    private z_InvalidateSubFramebuffer_2 := GetProcOrNil&<procedure(target: FramebufferTarget; numAttachments: Int32; var attachments: InvalidateFramebufferAttachment; x: Int32; y: Int32; width: Int32; height: Int32)>(z_InvalidateSubFramebuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateSubFramebuffer(target: FramebufferTarget; numAttachments: Int32; attachments: array of InvalidateFramebufferAttachment; x: Int32; y: Int32; width: Int32; height: Int32);
    type PInvalidateFramebufferAttachment=^InvalidateFramebufferAttachment;
    begin
      if (attachments<>nil) and (attachments.Length<>0) then
        z_InvalidateSubFramebuffer_2(target, numAttachments, attachments[0], x, y, width, height) else
        z_InvalidateSubFramebuffer_2(target, numAttachments, PInvalidateFramebufferAttachment(nil)^, x, y, width, height);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateSubFramebuffer(target: FramebufferTarget; numAttachments: Int32; var attachments: InvalidateFramebufferAttachment; x: Int32; y: Int32; width: Int32; height: Int32) :=
    z_InvalidateSubFramebuffer_2(target, numAttachments, attachments, x, y, width, height);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateSubFramebuffer(target: FramebufferTarget; numAttachments: Int32; attachments: IntPtr; x: Int32; y: Int32; width: Int32; height: Int32) :=
    z_InvalidateSubFramebuffer_1(target, numAttachments, attachments, x, y, width, height);
    
    // added in gl4.3
    private z_InvalidateTexImage_adr := GetProcAddress('glInvalidateTexImage');
    private z_InvalidateTexImage_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32)>(z_InvalidateTexImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateTexImage(texture: gl_texture; level: Int32) :=
    z_InvalidateTexImage_1(texture, level);
    
    // added in gl4.3
    private z_InvalidateTexSubImage_adr := GetProcAddress('glInvalidateTexSubImage');
    private z_InvalidateTexSubImage_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32)>(z_InvalidateTexSubImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateTexSubImage(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32) :=
    z_InvalidateTexSubImage_1(texture, level, xoffset, yoffset, zoffset, width, height, depth);
    
    // added in gl1.5
    private z_IsBuffer_adr := GetProcAddress('glIsBuffer');
    private z_IsBuffer_1 := GetProcOrNil&<function(buffer: gl_buffer): boolean>(z_IsBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsBuffer(buffer: gl_buffer): boolean :=
    z_IsBuffer_1(buffer);
    
    // added in gl1.0
    private z_IsEnabled_adr := GetProcAddress('glIsEnabled');
    private z_IsEnabled_1 := GetProcOrNil&<function(cap: EnableCap): boolean>(z_IsEnabled_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnabled(cap: EnableCap): boolean :=
    z_IsEnabled_1(cap);
    
    // added in gl3.0
    private z_IsEnabledi_adr := GetProcAddress('glIsEnabledi');
    private z_IsEnabledi_1 := GetProcOrNil&<function(target: EnableCap; index: UInt32): boolean>(z_IsEnabledi_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnabledi(target: EnableCap; index: UInt32): boolean :=
    z_IsEnabledi_1(target, index);
    
    // added in gl3.0
    private z_IsFramebuffer_adr := GetProcAddress('glIsFramebuffer');
    private z_IsFramebuffer_1 := GetProcOrNil&<function(framebuffer: gl_framebuffer): boolean>(z_IsFramebuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsFramebuffer(framebuffer: gl_framebuffer): boolean :=
    z_IsFramebuffer_1(framebuffer);
    
    // added in gl2.0
    private z_IsProgram_adr := GetProcAddress('glIsProgram');
    private z_IsProgram_1 := GetProcOrNil&<function(&program: gl_program): boolean>(z_IsProgram_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsProgram(&program: gl_program): boolean :=
    z_IsProgram_1(&program);
    
    // added in gl4.1
    private z_IsProgramPipeline_adr := GetProcAddress('glIsProgramPipeline');
    private z_IsProgramPipeline_1 := GetProcOrNil&<function(pipeline: gl_program_pipeline): boolean>(z_IsProgramPipeline_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsProgramPipeline(pipeline: gl_program_pipeline): boolean :=
    z_IsProgramPipeline_1(pipeline);
    
    // added in gl1.5
    private z_IsQuery_adr := GetProcAddress('glIsQuery');
    private z_IsQuery_1 := GetProcOrNil&<function(id: gl_query): boolean>(z_IsQuery_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsQuery(id: gl_query): boolean :=
    z_IsQuery_1(id);
    
    // added in gl3.0
    private z_IsRenderbuffer_adr := GetProcAddress('glIsRenderbuffer');
    private z_IsRenderbuffer_1 := GetProcOrNil&<function(renderbuffer: gl_renderbuffer): boolean>(z_IsRenderbuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsRenderbuffer(renderbuffer: gl_renderbuffer): boolean :=
    z_IsRenderbuffer_1(renderbuffer);
    
    // added in gl3.3
    private z_IsSampler_adr := GetProcAddress('glIsSampler');
    private z_IsSampler_1 := GetProcOrNil&<function(sampler: gl_sampler): boolean>(z_IsSampler_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsSampler(sampler: gl_sampler): boolean :=
    z_IsSampler_1(sampler);
    
    // added in gl2.0
    private z_IsShader_adr := GetProcAddress('glIsShader');
    private z_IsShader_1 := GetProcOrNil&<function(shader: gl_shader): boolean>(z_IsShader_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsShader(shader: gl_shader): boolean :=
    z_IsShader_1(shader);
    
    // added in gl3.2
    private z_IsSync_adr := GetProcAddress('glIsSync');
    private z_IsSync_1 := GetProcOrNil&<function(sync: gl_sync): boolean>(z_IsSync_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsSync(sync: gl_sync): boolean :=
    z_IsSync_1(sync);
    
    // added in gl1.1
    private z_IsTexture_adr := GetProcAddress('glIsTexture');
    private z_IsTexture_1 := GetProcOrNil&<function(texture: gl_texture): boolean>(z_IsTexture_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsTexture(texture: gl_texture): boolean :=
    z_IsTexture_1(texture);
    
    // added in gl4.0
    private z_IsTransformFeedback_adr := GetProcAddress('glIsTransformFeedback');
    private z_IsTransformFeedback_1 := GetProcOrNil&<function(id: gl_transform_feedback): boolean>(z_IsTransformFeedback_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsTransformFeedback(id: gl_transform_feedback): boolean :=
    z_IsTransformFeedback_1(id);
    
    // added in gl3.0
    private z_IsVertexArray_adr := GetProcAddress('glIsVertexArray');
    private z_IsVertexArray_1 := GetProcOrNil&<function(&array: gl_vertex_array): boolean>(z_IsVertexArray_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsVertexArray(&array: gl_vertex_array): boolean :=
    z_IsVertexArray_1(&array);
    
    // added in gl1.0
    private z_LineWidth_adr := GetProcAddress('glLineWidth');
    private z_LineWidth_1 := GetProcOrNil&<procedure(width: single)>(z_LineWidth_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LineWidth(width: single) :=
    z_LineWidth_1(width);
    
    // added in gl2.0
    private z_LinkProgram_adr := GetProcAddress('glLinkProgram');
    private z_LinkProgram_1 := GetProcOrNil&<procedure(&program: gl_program)>(z_LinkProgram_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LinkProgram(&program: gl_program) :=
    z_LinkProgram_1(&program);
    
    // added in gl1.0
    private z_LogicOp_adr := GetProcAddress('glLogicOp');
    private z_LogicOp_1 := GetProcOrNil&<procedure(opcode: OpenGL.LogicOp)>(z_LogicOp_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LogicOp(opcode: OpenGL.LogicOp) :=
    z_LogicOp_1(opcode);
    
    // added in gl1.5
    private z_MapBuffer_adr := GetProcAddress('glMapBuffer');
    private z_MapBuffer_1 := GetProcOrNil&<function(target: BufferTarget; access: BufferAccess): IntPtr>(z_MapBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapBuffer(target: BufferTarget; access: BufferAccess): IntPtr :=
    z_MapBuffer_1(target, access);
    
    // added in gl3.0
    private z_MapBufferRange_adr := GetProcAddress('glMapBufferRange');
    private z_MapBufferRange_1 := GetProcOrNil&<function(target: BufferTarget; offset: IntPtr; length: UIntPtr; access: MapBufferAccessMask): IntPtr>(z_MapBufferRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapBufferRange(target: BufferTarget; offset: IntPtr; length: UIntPtr; access: MapBufferAccessMask): IntPtr :=
    z_MapBufferRange_1(target, offset, length, access);
    
    // added in gl4.5
    private z_MapNamedBuffer_adr := GetProcAddress('glMapNamedBuffer');
    private z_MapNamedBuffer_1 := GetProcOrNil&<function(buffer: gl_buffer; access: BufferAccess): IntPtr>(z_MapNamedBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapNamedBuffer(buffer: gl_buffer; access: BufferAccess): IntPtr :=
    z_MapNamedBuffer_1(buffer, access);
    
    // added in gl4.5
    private z_MapNamedBufferRange_adr := GetProcAddress('glMapNamedBufferRange');
    private z_MapNamedBufferRange_1 := GetProcOrNil&<function(buffer: gl_buffer; offset: IntPtr; length: UIntPtr; access: MapBufferAccessMask): IntPtr>(z_MapNamedBufferRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapNamedBufferRange(buffer: gl_buffer; offset: IntPtr; length: UIntPtr; access: MapBufferAccessMask): IntPtr :=
    z_MapNamedBufferRange_1(buffer, offset, length, access);
    
    // added in gl4.2
    private z_MemoryBarrier_adr := GetProcAddress('glMemoryBarrier');
    private z_MemoryBarrier_1 := GetProcOrNil&<procedure(barriers: MemoryBarrierMask)>(z_MemoryBarrier_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MemoryBarrier(barriers: MemoryBarrierMask) :=
    z_MemoryBarrier_1(barriers);
    
    // added in gl4.5
    private z_MemoryBarrierByRegion_adr := GetProcAddress('glMemoryBarrierByRegion');
    private z_MemoryBarrierByRegion_1 := GetProcOrNil&<procedure(barriers: MemoryBarrierMask)>(z_MemoryBarrierByRegion_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MemoryBarrierByRegion(barriers: MemoryBarrierMask) :=
    z_MemoryBarrierByRegion_1(barriers);
    
    // added in gl4.0
    private z_MinSampleShading_adr := GetProcAddress('glMinSampleShading');
    private z_MinSampleShading_1 := GetProcOrNil&<procedure(value: single)>(z_MinSampleShading_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MinSampleShading(value: single) :=
    z_MinSampleShading_1(value);
    
    // added in gl1.4
    private z_MultiDrawArrays_adr := GetProcAddress('glMultiDrawArrays');
    private z_MultiDrawArrays_1 := GetProcOrNil&<procedure(mode: PrimitiveType; first: IntPtr; count: IntPtr; drawcount: Int32)>(z_MultiDrawArrays_adr);
    private z_MultiDrawArrays_2 := GetProcOrNil&<procedure(mode: PrimitiveType; first: IntPtr; var count: Int32; drawcount: Int32)>(z_MultiDrawArrays_adr);
    private z_MultiDrawArrays_3 := GetProcOrNil&<procedure(mode: PrimitiveType; var first: Int32; count: IntPtr; drawcount: Int32)>(z_MultiDrawArrays_adr);
    private z_MultiDrawArrays_4 := GetProcOrNil&<procedure(mode: PrimitiveType; var first: Int32; var count: Int32; drawcount: Int32)>(z_MultiDrawArrays_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArrays(mode: PrimitiveType; first: array of Int32; count: array of Int32; drawcount: Int32);
    type PInt32=^Int32;
    begin
      if (count<>nil) and (count.Length<>0) then
        if (first<>nil) and (first.Length<>0) then
          z_MultiDrawArrays_4(mode, first[0], count[0], drawcount) else
          z_MultiDrawArrays_4(mode, PInt32(nil)^, count[0], drawcount) else
        if (first<>nil) and (first.Length<>0) then
          z_MultiDrawArrays_4(mode, first[0], PInt32(nil)^, drawcount) else
          z_MultiDrawArrays_4(mode, PInt32(nil)^, PInt32(nil)^, drawcount);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArrays(mode: PrimitiveType; var first: Int32; var count: Int32; drawcount: Int32) :=
    z_MultiDrawArrays_4(mode, first, count, drawcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArrays(mode: PrimitiveType; var first: Int32; count: IntPtr; drawcount: Int32) :=
    z_MultiDrawArrays_3(mode, first, count, drawcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArrays(mode: PrimitiveType; first: IntPtr; var count: Int32; drawcount: Int32) :=
    z_MultiDrawArrays_2(mode, first, count, drawcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArrays(mode: PrimitiveType; first: IntPtr; count: IntPtr; drawcount: Int32) :=
    z_MultiDrawArrays_1(mode, first, count, drawcount);
    
    // added in gl4.3
    private z_MultiDrawArraysIndirect_adr := GetProcAddress('glMultiDrawArraysIndirect');
    private z_MultiDrawArraysIndirect_1 := GetProcOrNil&<procedure(mode: PrimitiveType; indirect: IntPtr; drawcount: Int32; stride: Int32)>(z_MultiDrawArraysIndirect_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysIndirect(mode: PrimitiveType; indirect: IntPtr; drawcount: Int32; stride: Int32) :=
    z_MultiDrawArraysIndirect_1(mode, indirect, drawcount, stride);
    
    // added in gl4.6
    private z_MultiDrawArraysIndirectCount_adr := GetProcAddress('glMultiDrawArraysIndirectCount');
    private z_MultiDrawArraysIndirectCount_1 := GetProcOrNil&<procedure(mode: PrimitiveType; indirect: IntPtr; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32)>(z_MultiDrawArraysIndirectCount_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysIndirectCount(mode: PrimitiveType; indirect: IntPtr; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32) :=
    z_MultiDrawArraysIndirectCount_1(mode, indirect, drawcount, maxdrawcount, stride);
    
    // added in gl1.4
    private z_MultiDrawElements_adr := GetProcAddress('glMultiDrawElements');
    private z_MultiDrawElements_1 := GetProcOrNil&<procedure(mode: PrimitiveType; count: IntPtr; &type: DrawElementsType; indices: pointer; drawcount: Int32)>(z_MultiDrawElements_adr);
    private z_MultiDrawElements_2 := GetProcOrNil&<procedure(mode: PrimitiveType; count: IntPtr; &type: DrawElementsType; var indices: IntPtr; drawcount: Int32)>(z_MultiDrawElements_adr);
    private z_MultiDrawElements_3 := GetProcOrNil&<procedure(mode: PrimitiveType; var count: Int32; &type: DrawElementsType; indices: pointer; drawcount: Int32)>(z_MultiDrawElements_adr);
    private z_MultiDrawElements_4 := GetProcOrNil&<procedure(mode: PrimitiveType; var count: Int32; &type: DrawElementsType; var indices: IntPtr; drawcount: Int32)>(z_MultiDrawElements_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElements(mode: PrimitiveType; count: array of Int32; &type: DrawElementsType; indices: array of IntPtr; drawcount: Int32);
    type PInt32=^Int32;
    type PIntPtr=^IntPtr;
    begin
      if (indices<>nil) and (indices.Length<>0) then
        if (count<>nil) and (count.Length<>0) then
          z_MultiDrawElements_4(mode, count[0], &type, indices[0], drawcount) else
          z_MultiDrawElements_4(mode, PInt32(nil)^, &type, indices[0], drawcount) else
        if (count<>nil) and (count.Length<>0) then
          z_MultiDrawElements_4(mode, count[0], &type, PIntPtr(nil)^, drawcount) else
          z_MultiDrawElements_4(mode, PInt32(nil)^, &type, PIntPtr(nil)^, drawcount);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElements(mode: PrimitiveType; var count: Int32; &type: DrawElementsType; var indices: IntPtr; drawcount: Int32) :=
    z_MultiDrawElements_4(mode, count, &type, indices, drawcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElements(mode: PrimitiveType; var count: Int32; &type: DrawElementsType; indices: pointer; drawcount: Int32) :=
    z_MultiDrawElements_3(mode, count, &type, indices, drawcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElements(mode: PrimitiveType; count: IntPtr; &type: DrawElementsType; var indices: IntPtr; drawcount: Int32) :=
    z_MultiDrawElements_2(mode, count, &type, indices, drawcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElements(mode: PrimitiveType; count: IntPtr; &type: DrawElementsType; indices: pointer; drawcount: Int32) :=
    z_MultiDrawElements_1(mode, count, &type, indices, drawcount);
    
    // added in gl3.2
    private z_MultiDrawElementsBaseVertex_adr := GetProcAddress('glMultiDrawElementsBaseVertex');
    private z_MultiDrawElementsBaseVertex_1 := GetProcOrNil&<procedure(mode: PrimitiveType; count: IntPtr; &type: DrawElementsType; indices: pointer; drawcount: Int32; basevertex: IntPtr)>(z_MultiDrawElementsBaseVertex_adr);
    private z_MultiDrawElementsBaseVertex_2 := GetProcOrNil&<procedure(mode: PrimitiveType; count: IntPtr; &type: DrawElementsType; indices: pointer; drawcount: Int32; var basevertex: Int32)>(z_MultiDrawElementsBaseVertex_adr);
    private z_MultiDrawElementsBaseVertex_3 := GetProcOrNil&<procedure(mode: PrimitiveType; count: IntPtr; &type: DrawElementsType; var indices: IntPtr; drawcount: Int32; basevertex: IntPtr)>(z_MultiDrawElementsBaseVertex_adr);
    private z_MultiDrawElementsBaseVertex_4 := GetProcOrNil&<procedure(mode: PrimitiveType; count: IntPtr; &type: DrawElementsType; var indices: IntPtr; drawcount: Int32; var basevertex: Int32)>(z_MultiDrawElementsBaseVertex_adr);
    private z_MultiDrawElementsBaseVertex_5 := GetProcOrNil&<procedure(mode: PrimitiveType; var count: Int32; &type: DrawElementsType; indices: pointer; drawcount: Int32; basevertex: IntPtr)>(z_MultiDrawElementsBaseVertex_adr);
    private z_MultiDrawElementsBaseVertex_6 := GetProcOrNil&<procedure(mode: PrimitiveType; var count: Int32; &type: DrawElementsType; indices: pointer; drawcount: Int32; var basevertex: Int32)>(z_MultiDrawElementsBaseVertex_adr);
    private z_MultiDrawElementsBaseVertex_7 := GetProcOrNil&<procedure(mode: PrimitiveType; var count: Int32; &type: DrawElementsType; var indices: IntPtr; drawcount: Int32; basevertex: IntPtr)>(z_MultiDrawElementsBaseVertex_adr);
    private z_MultiDrawElementsBaseVertex_8 := GetProcOrNil&<procedure(mode: PrimitiveType; var count: Int32; &type: DrawElementsType; var indices: IntPtr; drawcount: Int32; var basevertex: Int32)>(z_MultiDrawElementsBaseVertex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; count: array of Int32; &type: DrawElementsType; indices: array of IntPtr; drawcount: Int32; basevertex: array of Int32);
    type PInt32=^Int32;
    type PIntPtr=^IntPtr;
    begin
      if (basevertex<>nil) and (basevertex.Length<>0) then
        if (indices<>nil) and (indices.Length<>0) then
          if (count<>nil) and (count.Length<>0) then
            z_MultiDrawElementsBaseVertex_8(mode, count[0], &type, indices[0], drawcount, basevertex[0]) else
            z_MultiDrawElementsBaseVertex_8(mode, PInt32(nil)^, &type, indices[0], drawcount, basevertex[0]) else
          if (count<>nil) and (count.Length<>0) then
            z_MultiDrawElementsBaseVertex_8(mode, count[0], &type, PIntPtr(nil)^, drawcount, basevertex[0]) else
            z_MultiDrawElementsBaseVertex_8(mode, PInt32(nil)^, &type, PIntPtr(nil)^, drawcount, basevertex[0]) else
        if (indices<>nil) and (indices.Length<>0) then
          if (count<>nil) and (count.Length<>0) then
            z_MultiDrawElementsBaseVertex_8(mode, count[0], &type, indices[0], drawcount, PInt32(nil)^) else
            z_MultiDrawElementsBaseVertex_8(mode, PInt32(nil)^, &type, indices[0], drawcount, PInt32(nil)^) else
          if (count<>nil) and (count.Length<>0) then
            z_MultiDrawElementsBaseVertex_8(mode, count[0], &type, PIntPtr(nil)^, drawcount, PInt32(nil)^) else
            z_MultiDrawElementsBaseVertex_8(mode, PInt32(nil)^, &type, PIntPtr(nil)^, drawcount, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; var count: Int32; &type: DrawElementsType; var indices: IntPtr; drawcount: Int32; var basevertex: Int32) :=
    z_MultiDrawElementsBaseVertex_8(mode, count, &type, indices, drawcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; var count: Int32; &type: DrawElementsType; var indices: IntPtr; drawcount: Int32; basevertex: IntPtr) :=
    z_MultiDrawElementsBaseVertex_7(mode, count, &type, indices, drawcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; var count: Int32; &type: DrawElementsType; indices: pointer; drawcount: Int32; var basevertex: Int32) :=
    z_MultiDrawElementsBaseVertex_6(mode, count, &type, indices, drawcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; var count: Int32; &type: DrawElementsType; indices: pointer; drawcount: Int32; basevertex: IntPtr) :=
    z_MultiDrawElementsBaseVertex_5(mode, count, &type, indices, drawcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; count: IntPtr; &type: DrawElementsType; var indices: IntPtr; drawcount: Int32; var basevertex: Int32) :=
    z_MultiDrawElementsBaseVertex_4(mode, count, &type, indices, drawcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; count: IntPtr; &type: DrawElementsType; var indices: IntPtr; drawcount: Int32; basevertex: IntPtr) :=
    z_MultiDrawElementsBaseVertex_3(mode, count, &type, indices, drawcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; count: IntPtr; &type: DrawElementsType; indices: pointer; drawcount: Int32; var basevertex: Int32) :=
    z_MultiDrawElementsBaseVertex_2(mode, count, &type, indices, drawcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; count: IntPtr; &type: DrawElementsType; indices: pointer; drawcount: Int32; basevertex: IntPtr) :=
    z_MultiDrawElementsBaseVertex_1(mode, count, &type, indices, drawcount, basevertex);
    
    // added in gl4.3
    private z_MultiDrawElementsIndirect_adr := GetProcAddress('glMultiDrawElementsIndirect');
    private z_MultiDrawElementsIndirect_1 := GetProcOrNil&<procedure(mode: PrimitiveType; &type: DrawElementsType; indirect: IntPtr; drawcount: Int32; stride: Int32)>(z_MultiDrawElementsIndirect_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsIndirect(mode: PrimitiveType; &type: DrawElementsType; indirect: IntPtr; drawcount: Int32; stride: Int32) :=
    z_MultiDrawElementsIndirect_1(mode, &type, indirect, drawcount, stride);
    
    // added in gl4.6
    private z_MultiDrawElementsIndirectCount_adr := GetProcAddress('glMultiDrawElementsIndirectCount');
    private z_MultiDrawElementsIndirectCount_1 := GetProcOrNil&<procedure(mode: PrimitiveType; &type: DrawElementsType; indirect: IntPtr; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32)>(z_MultiDrawElementsIndirectCount_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsIndirectCount(mode: PrimitiveType; &type: DrawElementsType; indirect: IntPtr; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32) :=
    z_MultiDrawElementsIndirectCount_1(mode, &type, indirect, drawcount, maxdrawcount, stride);
    
    // added in gl3.3
    private z_MultiTexCoordP1ui_adr := GetProcAddress('glMultiTexCoordP1ui');
    private z_MultiTexCoordP1ui_1 := GetProcOrNil&<procedure(texture: TextureUnit; &type: TexCoordPointerType; coords: UInt32)>(z_MultiTexCoordP1ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP1ui(texture: TextureUnit; &type: TexCoordPointerType; coords: UInt32) :=
    z_MultiTexCoordP1ui_1(texture, &type, coords);
    
    // added in gl3.3
    private z_MultiTexCoordP1uiv_adr := GetProcAddress('glMultiTexCoordP1uiv');
    private z_MultiTexCoordP1uiv_1 := GetProcOrNil&<procedure(texture: TextureUnit; &type: TexCoordPointerType; coords: IntPtr)>(z_MultiTexCoordP1uiv_adr);
    private z_MultiTexCoordP1uiv_2 := GetProcOrNil&<procedure(texture: TextureUnit; &type: TexCoordPointerType; var coords: UInt32)>(z_MultiTexCoordP1uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP1uiv(texture: TextureUnit; &type: TexCoordPointerType; coords: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_MultiTexCoordP1uiv_2(texture, &type, coords[0]) else
        z_MultiTexCoordP1uiv_2(texture, &type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP1uiv(texture: TextureUnit; &type: TexCoordPointerType; var coords: UInt32) :=
    z_MultiTexCoordP1uiv_2(texture, &type, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP1uiv(texture: TextureUnit; &type: TexCoordPointerType; coords: IntPtr) :=
    z_MultiTexCoordP1uiv_1(texture, &type, coords);
    
    // added in gl3.3
    private z_MultiTexCoordP2ui_adr := GetProcAddress('glMultiTexCoordP2ui');
    private z_MultiTexCoordP2ui_1 := GetProcOrNil&<procedure(texture: TextureUnit; &type: TexCoordPointerType; coords: UInt32)>(z_MultiTexCoordP2ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP2ui(texture: TextureUnit; &type: TexCoordPointerType; coords: UInt32) :=
    z_MultiTexCoordP2ui_1(texture, &type, coords);
    
    // added in gl3.3
    private z_MultiTexCoordP2uiv_adr := GetProcAddress('glMultiTexCoordP2uiv');
    private z_MultiTexCoordP2uiv_1 := GetProcOrNil&<procedure(texture: TextureUnit; &type: TexCoordPointerType; coords: IntPtr)>(z_MultiTexCoordP2uiv_adr);
    private z_MultiTexCoordP2uiv_2 := GetProcOrNil&<procedure(texture: TextureUnit; &type: TexCoordPointerType; var coords: UInt32)>(z_MultiTexCoordP2uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP2uiv(texture: TextureUnit; &type: TexCoordPointerType; coords: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_MultiTexCoordP2uiv_2(texture, &type, coords[0]) else
        z_MultiTexCoordP2uiv_2(texture, &type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP2uiv(texture: TextureUnit; &type: TexCoordPointerType; var coords: UInt32) :=
    z_MultiTexCoordP2uiv_2(texture, &type, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP2uiv(texture: TextureUnit; &type: TexCoordPointerType; coords: IntPtr) :=
    z_MultiTexCoordP2uiv_1(texture, &type, coords);
    
    // added in gl3.3
    private z_MultiTexCoordP3ui_adr := GetProcAddress('glMultiTexCoordP3ui');
    private z_MultiTexCoordP3ui_1 := GetProcOrNil&<procedure(texture: TextureUnit; &type: TexCoordPointerType; coords: UInt32)>(z_MultiTexCoordP3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP3ui(texture: TextureUnit; &type: TexCoordPointerType; coords: UInt32) :=
    z_MultiTexCoordP3ui_1(texture, &type, coords);
    
    // added in gl3.3
    private z_MultiTexCoordP3uiv_adr := GetProcAddress('glMultiTexCoordP3uiv');
    private z_MultiTexCoordP3uiv_1 := GetProcOrNil&<procedure(texture: TextureUnit; &type: TexCoordPointerType; coords: IntPtr)>(z_MultiTexCoordP3uiv_adr);
    private z_MultiTexCoordP3uiv_2 := GetProcOrNil&<procedure(texture: TextureUnit; &type: TexCoordPointerType; var coords: UInt32)>(z_MultiTexCoordP3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP3uiv(texture: TextureUnit; &type: TexCoordPointerType; coords: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_MultiTexCoordP3uiv_2(texture, &type, coords[0]) else
        z_MultiTexCoordP3uiv_2(texture, &type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP3uiv(texture: TextureUnit; &type: TexCoordPointerType; var coords: UInt32) :=
    z_MultiTexCoordP3uiv_2(texture, &type, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP3uiv(texture: TextureUnit; &type: TexCoordPointerType; coords: IntPtr) :=
    z_MultiTexCoordP3uiv_1(texture, &type, coords);
    
    // added in gl3.3
    private z_MultiTexCoordP4ui_adr := GetProcAddress('glMultiTexCoordP4ui');
    private z_MultiTexCoordP4ui_1 := GetProcOrNil&<procedure(texture: TextureUnit; &type: TexCoordPointerType; coords: UInt32)>(z_MultiTexCoordP4ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP4ui(texture: TextureUnit; &type: TexCoordPointerType; coords: UInt32) :=
    z_MultiTexCoordP4ui_1(texture, &type, coords);
    
    // added in gl3.3
    private z_MultiTexCoordP4uiv_adr := GetProcAddress('glMultiTexCoordP4uiv');
    private z_MultiTexCoordP4uiv_1 := GetProcOrNil&<procedure(texture: TextureUnit; &type: TexCoordPointerType; coords: IntPtr)>(z_MultiTexCoordP4uiv_adr);
    private z_MultiTexCoordP4uiv_2 := GetProcOrNil&<procedure(texture: TextureUnit; &type: TexCoordPointerType; var coords: UInt32)>(z_MultiTexCoordP4uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP4uiv(texture: TextureUnit; &type: TexCoordPointerType; coords: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_MultiTexCoordP4uiv_2(texture, &type, coords[0]) else
        z_MultiTexCoordP4uiv_2(texture, &type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP4uiv(texture: TextureUnit; &type: TexCoordPointerType; var coords: UInt32) :=
    z_MultiTexCoordP4uiv_2(texture, &type, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP4uiv(texture: TextureUnit; &type: TexCoordPointerType; coords: IntPtr) :=
    z_MultiTexCoordP4uiv_1(texture, &type, coords);
    
    // added in gl4.5
    private z_NamedBufferData_adr := GetProcAddress('glNamedBufferData');
    private z_NamedBufferData_1 := GetProcOrNil&<procedure(buffer: gl_buffer; size: UIntPtr; data: pointer; usage: VertexBufferObjectUsage)>(z_NamedBufferData_adr);
    private z_NamedBufferData_2 := GetProcOrNil&<procedure(buffer: gl_buffer; size: UIntPtr; var data: Byte; usage: VertexBufferObjectUsage)>(z_NamedBufferData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferData<T>(buffer: gl_buffer; size: UIntPtr; data: array of T; usage: VertexBufferObjectUsage); where T: record;
    type PT=^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        NamedBufferData(buffer, size, data[0], usage) else
        NamedBufferData(buffer, size, PT(nil)^, usage);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferData<T>(buffer: gl_buffer; size: UIntPtr; var data: T; usage: VertexBufferObjectUsage); where T: record;
    begin
      z_NamedBufferData_2(buffer, size, PByte(pointer(@data))^, usage);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferData(buffer: gl_buffer; size: UIntPtr; data: pointer; usage: VertexBufferObjectUsage) :=
    z_NamedBufferData_1(buffer, size, data, usage);
    
    // added in gl4.5
    private z_NamedBufferStorage_adr := GetProcAddress('glNamedBufferStorage');
    private z_NamedBufferStorage_1 := GetProcOrNil&<procedure(buffer: gl_buffer; size: UIntPtr; data: pointer; flags: BufferStorageMask)>(z_NamedBufferStorage_adr);
    private z_NamedBufferStorage_2 := GetProcOrNil&<procedure(buffer: gl_buffer; size: UIntPtr; var data: Byte; flags: BufferStorageMask)>(z_NamedBufferStorage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferStorage<T>(buffer: gl_buffer; size: UIntPtr; data: array of T; flags: BufferStorageMask); where T: record;
    type PT=^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        NamedBufferStorage(buffer, size, data[0], flags) else
        NamedBufferStorage(buffer, size, PT(nil)^, flags);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferStorage<T>(buffer: gl_buffer; size: UIntPtr; var data: T; flags: BufferStorageMask); where T: record;
    begin
      z_NamedBufferStorage_2(buffer, size, PByte(pointer(@data))^, flags);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferStorage(buffer: gl_buffer; size: UIntPtr; data: pointer; flags: BufferStorageMask) :=
    z_NamedBufferStorage_1(buffer, size, data, flags);
    
    // added in gl4.5
    private z_NamedBufferSubData_adr := GetProcAddress('glNamedBufferSubData');
    private z_NamedBufferSubData_1 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: pointer)>(z_NamedBufferSubData_adr);
    private z_NamedBufferSubData_2 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; var data: Byte)>(z_NamedBufferSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferSubData<T>(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: array of T); where T: record;
    type PT=^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        NamedBufferSubData(buffer, offset, size, data[0]) else
        NamedBufferSubData(buffer, offset, size, PT(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferSubData<T>(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; var data: T); where T: record;
    begin
      z_NamedBufferSubData_2(buffer, offset, size, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferSubData(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: pointer) :=
    z_NamedBufferSubData_1(buffer, offset, size, data);
    
    // added in gl4.5
    private z_NamedFramebufferDrawBuffer_adr := GetProcAddress('glNamedFramebufferDrawBuffer');
    private z_NamedFramebufferDrawBuffer_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; buf: ColorBuffer)>(z_NamedFramebufferDrawBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferDrawBuffer(framebuffer: gl_framebuffer; buf: ColorBuffer) :=
    z_NamedFramebufferDrawBuffer_1(framebuffer, buf);
    
    // added in gl4.5
    private z_NamedFramebufferDrawBuffers_adr := GetProcAddress('glNamedFramebufferDrawBuffers');
    private z_NamedFramebufferDrawBuffers_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; n: Int32; bufs: IntPtr)>(z_NamedFramebufferDrawBuffers_adr);
    private z_NamedFramebufferDrawBuffers_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; n: Int32; var bufs: ColorBuffer)>(z_NamedFramebufferDrawBuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferDrawBuffers(framebuffer: gl_framebuffer; n: Int32; bufs: array of ColorBuffer);
    type PColorBuffer=^ColorBuffer;
    begin
      if (bufs<>nil) and (bufs.Length<>0) then
        z_NamedFramebufferDrawBuffers_2(framebuffer, n, bufs[0]) else
        z_NamedFramebufferDrawBuffers_2(framebuffer, n, PColorBuffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferDrawBuffers(framebuffer: gl_framebuffer; n: Int32; var bufs: ColorBuffer) :=
    z_NamedFramebufferDrawBuffers_2(framebuffer, n, bufs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferDrawBuffers(framebuffer: gl_framebuffer; n: Int32; bufs: IntPtr) :=
    z_NamedFramebufferDrawBuffers_1(framebuffer, n, bufs);
    
    // added in gl4.5
    private z_NamedFramebufferParameteri_adr := GetProcAddress('glNamedFramebufferParameteri');
    private z_NamedFramebufferParameteri_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; pname: FramebufferParameterName; param: Int32)>(z_NamedFramebufferParameteri_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferParameteri(framebuffer: gl_framebuffer; pname: FramebufferParameterName; param: Int32) :=
    z_NamedFramebufferParameteri_1(framebuffer, pname, param);
    
    // added in gl4.5
    private z_NamedFramebufferReadBuffer_adr := GetProcAddress('glNamedFramebufferReadBuffer');
    private z_NamedFramebufferReadBuffer_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; src: ColorBuffer)>(z_NamedFramebufferReadBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferReadBuffer(framebuffer: gl_framebuffer; src: ColorBuffer) :=
    z_NamedFramebufferReadBuffer_1(framebuffer, src);
    
    // added in gl4.5
    private z_NamedFramebufferRenderbuffer_adr := GetProcAddress('glNamedFramebufferRenderbuffer');
    private z_NamedFramebufferRenderbuffer_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; _renderbuffertarget: RenderbufferTarget; renderbuffer: gl_renderbuffer)>(z_NamedFramebufferRenderbuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferRenderbuffer(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; _renderbuffertarget: RenderbufferTarget; renderbuffer: gl_renderbuffer) :=
    z_NamedFramebufferRenderbuffer_1(framebuffer, attachment, _renderbuffertarget, renderbuffer);
    
    // added in gl4.5
    private z_NamedFramebufferTexture_adr := GetProcAddress('glNamedFramebufferTexture');
    private z_NamedFramebufferTexture_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; texture: gl_texture; level: Int32)>(z_NamedFramebufferTexture_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferTexture(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; texture: gl_texture; level: Int32) :=
    z_NamedFramebufferTexture_1(framebuffer, attachment, texture, level);
    
    // added in gl4.5
    private z_NamedFramebufferTextureLayer_adr := GetProcAddress('glNamedFramebufferTextureLayer');
    private z_NamedFramebufferTextureLayer_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; texture: gl_texture; level: Int32; layer: Int32)>(z_NamedFramebufferTextureLayer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferTextureLayer(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; texture: gl_texture; level: Int32; layer: Int32) :=
    z_NamedFramebufferTextureLayer_1(framebuffer, attachment, texture, level, layer);
    
    // added in gl4.5
    private z_NamedRenderbufferStorage_adr := GetProcAddress('glNamedRenderbufferStorage');
    private z_NamedRenderbufferStorage_1 := GetProcOrNil&<procedure(renderbuffer: gl_renderbuffer; _internalformat: InternalFormat; width: Int32; height: Int32)>(z_NamedRenderbufferStorage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedRenderbufferStorage(renderbuffer: gl_renderbuffer; _internalformat: InternalFormat; width: Int32; height: Int32) :=
    z_NamedRenderbufferStorage_1(renderbuffer, _internalformat, width, height);
    
    // added in gl4.5
    private z_NamedRenderbufferStorageMultisample_adr := GetProcAddress('glNamedRenderbufferStorageMultisample');
    private z_NamedRenderbufferStorageMultisample_1 := GetProcOrNil&<procedure(renderbuffer: gl_renderbuffer; samples: Int32; _internalformat: InternalFormat; width: Int32; height: Int32)>(z_NamedRenderbufferStorageMultisample_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedRenderbufferStorageMultisample(renderbuffer: gl_renderbuffer; samples: Int32; _internalformat: InternalFormat; width: Int32; height: Int32) :=
    z_NamedRenderbufferStorageMultisample_1(renderbuffer, samples, _internalformat, width, height);
    
    // added in gl3.3
    private z_NormalP3ui_adr := GetProcAddress('glNormalP3ui');
    private z_NormalP3ui_1 := GetProcOrNil&<procedure(&type: NormalPointerType; coords: UInt32)>(z_NormalP3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalP3ui(&type: NormalPointerType; coords: UInt32) :=
    z_NormalP3ui_1(&type, coords);
    
    // added in gl3.3
    private z_NormalP3uiv_adr := GetProcAddress('glNormalP3uiv');
    private z_NormalP3uiv_1 := GetProcOrNil&<procedure(&type: NormalPointerType; coords: IntPtr)>(z_NormalP3uiv_adr);
    private z_NormalP3uiv_2 := GetProcOrNil&<procedure(&type: NormalPointerType; var coords: UInt32)>(z_NormalP3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalP3uiv(&type: NormalPointerType; coords: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_NormalP3uiv_2(&type, coords[0]) else
        z_NormalP3uiv_2(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalP3uiv(&type: NormalPointerType; var coords: UInt32) :=
    z_NormalP3uiv_2(&type, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalP3uiv(&type: NormalPointerType; coords: IntPtr) :=
    z_NormalP3uiv_1(&type, coords);
    
    // added in gl4.3
    private z_ObjectLabel_adr := GetProcAddress('glObjectLabel');
    private z_ObjectLabel_1 := GetProcOrNil&<procedure(identifier: ObjectIdentifier; name: UInt32; length: Int32; &label: IntPtr)>(z_ObjectLabel_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ObjectLabel(identifier: ObjectIdentifier; name: UInt32; length: Int32; &label: string);
    begin
      var &label_str_ptr: IntPtr;
      try
        &label_str_ptr := Marshal.StringToHGlobalAnsi(&label);
        z_ObjectLabel_1(identifier, name, length, &label_str_ptr);
      finally
        Marshal.FreeHGlobal(&label_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ObjectLabel(identifier: ObjectIdentifier; name: UInt32; length: Int32; &label: IntPtr) :=
    z_ObjectLabel_1(identifier, name, length, &label);
    
    // added in gl4.3
    private z_ObjectPtrLabel_adr := GetProcAddress('glObjectPtrLabel');
    private z_ObjectPtrLabel_1 := GetProcOrNil&<procedure(ptr: IntPtr; length: Int32; &label: IntPtr)>(z_ObjectPtrLabel_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ObjectPtrLabel(ptr: IntPtr; length: Int32; &label: string);
    begin
      var &label_str_ptr: IntPtr;
      try
        &label_str_ptr := Marshal.StringToHGlobalAnsi(&label);
        z_ObjectPtrLabel_1(ptr, length, &label_str_ptr);
      finally
        Marshal.FreeHGlobal(&label_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ObjectPtrLabel(ptr: IntPtr; length: Int32; &label: IntPtr) :=
    z_ObjectPtrLabel_1(ptr, length, &label);
    
    // added in gl4.0
    private z_PatchParameterfv_adr := GetProcAddress('glPatchParameterfv');
    private z_PatchParameterfv_1 := GetProcOrNil&<procedure(pname: PatchParameterName; values: IntPtr)>(z_PatchParameterfv_adr);
    private z_PatchParameterfv_2 := GetProcOrNil&<procedure(pname: PatchParameterName; var values: single)>(z_PatchParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PatchParameterfv(pname: PatchParameterName; values: array of single);
    type Psingle=^single;
    begin
      if (values<>nil) and (values.Length<>0) then
        z_PatchParameterfv_2(pname, values[0]) else
        z_PatchParameterfv_2(pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PatchParameterfv(pname: PatchParameterName; var values: single) :=
    z_PatchParameterfv_2(pname, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PatchParameterfv(pname: PatchParameterName; values: IntPtr) :=
    z_PatchParameterfv_1(pname, values);
    
    // added in gl4.0
    private z_PatchParameteri_adr := GetProcAddress('glPatchParameteri');
    private z_PatchParameteri_1 := GetProcOrNil&<procedure(pname: PatchParameterName; value: Int32)>(z_PatchParameteri_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PatchParameteri(pname: PatchParameterName; value: Int32) :=
    z_PatchParameteri_1(pname, value);
    
    // added in gl4.0
    private z_PauseTransformFeedback_adr := GetProcAddress('glPauseTransformFeedback');
    private z_PauseTransformFeedback_1 := GetProcOrNil&<procedure>(z_PauseTransformFeedback_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PauseTransformFeedback :=
    z_PauseTransformFeedback_1();
    
    // added in gl1.0
    private z_PixelStoref_adr := GetProcAddress('glPixelStoref');
    private z_PixelStoref_1 := GetProcOrNil&<procedure(pname: PixelStoreParameter; param: single)>(z_PixelStoref_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelStoref(pname: PixelStoreParameter; param: single) :=
    z_PixelStoref_1(pname, param);
    
    // added in gl1.0
    private z_PixelStorei_adr := GetProcAddress('glPixelStorei');
    private z_PixelStorei_1 := GetProcOrNil&<procedure(pname: PixelStoreParameter; param: Int32)>(z_PixelStorei_adr);
    private z_PixelStorei_2 := GetProcOrNil&<procedure(pname: PixelStoreParameter; param: PixelStoreSubsampleRate)>(z_PixelStorei_adr);
    private z_PixelStorei_3 := GetProcOrNil&<procedure(pname: PixelStoreParameter; param: PixelStoreResampleMode)>(z_PixelStorei_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelStorei(pname: PixelStoreParameter; param: PixelStoreResampleMode) :=
    z_PixelStorei_3(pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelStorei(pname: PixelStoreParameter; param: PixelStoreSubsampleRate) :=
    z_PixelStorei_2(pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelStorei(pname: PixelStoreParameter; param: Int32) :=
    z_PixelStorei_1(pname, param);
    
    // added in gl1.4
    private z_PointParameterf_adr := GetProcAddress('glPointParameterf');
    private z_PointParameterf_1 := GetProcOrNil&<procedure(pname: PointParameterName; param: single)>(z_PointParameterf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterf(pname: PointParameterName; param: single) :=
    z_PointParameterf_1(pname, param);
    
    // added in gl1.4
    private z_PointParameterfv_adr := GetProcAddress('glPointParameterfv');
    private z_PointParameterfv_1 := GetProcOrNil&<procedure(pname: PointParameterName; &params: IntPtr)>(z_PointParameterfv_adr);
    private z_PointParameterfv_2 := GetProcOrNil&<procedure(pname: PointParameterName; var &params: single)>(z_PointParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfv(pname: PointParameterName; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_PointParameterfv_2(pname, &params[0]) else
        z_PointParameterfv_2(pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfv(pname: PointParameterName; var &params: single) :=
    z_PointParameterfv_2(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfv(pname: PointParameterName; &params: IntPtr) :=
    z_PointParameterfv_1(pname, &params);
    
    // added in gl1.4
    private z_PointParameteri_adr := GetProcAddress('glPointParameteri');
    private z_PointParameteri_1 := GetProcOrNil&<procedure(pname: PointParameterName; param: Int32)>(z_PointParameteri_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameteri(pname: PointParameterName; param: Int32) :=
    z_PointParameteri_1(pname, param);
    
    // added in gl1.4
    private z_PointParameteriv_adr := GetProcAddress('glPointParameteriv');
    private z_PointParameteriv_1 := GetProcOrNil&<procedure(pname: PointParameterName; &params: IntPtr)>(z_PointParameteriv_adr);
    private z_PointParameteriv_2 := GetProcOrNil&<procedure(pname: PointParameterName; var &params: Int32)>(z_PointParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameteriv(pname: PointParameterName; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_PointParameteriv_2(pname, &params[0]) else
        z_PointParameteriv_2(pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameteriv(pname: PointParameterName; var &params: Int32) :=
    z_PointParameteriv_2(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameteriv(pname: PointParameterName; &params: IntPtr) :=
    z_PointParameteriv_1(pname, &params);
    
    // added in gl1.0
    private z_PointSize_adr := GetProcAddress('glPointSize');
    private z_PointSize_1 := GetProcOrNil&<procedure(size: single)>(z_PointSize_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointSize(size: single) :=
    z_PointSize_1(size);
    
    // added in gl1.0
    private z_PolygonMode_adr := GetProcAddress('glPolygonMode');
    private z_PolygonMode_1 := GetProcOrNil&<procedure(face: MaterialFace; mode: OpenGL.PolygonMode)>(z_PolygonMode_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PolygonMode(face: MaterialFace; mode: OpenGL.PolygonMode) :=
    z_PolygonMode_1(face, mode);
    
    // added in gl1.1
    private z_PolygonOffset_adr := GetProcAddress('glPolygonOffset');
    private z_PolygonOffset_1 := GetProcOrNil&<procedure(factor: single; units: single)>(z_PolygonOffset_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PolygonOffset(factor: single; units: single) :=
    z_PolygonOffset_1(factor, units);
    
    // added in gl4.6
    private z_PolygonOffsetClamp_adr := GetProcAddress('glPolygonOffsetClamp');
    private z_PolygonOffsetClamp_1 := GetProcOrNil&<procedure(factor: single; units: single; clamp: single)>(z_PolygonOffsetClamp_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PolygonOffsetClamp(factor: single; units: single; clamp: single) :=
    z_PolygonOffsetClamp_1(factor, units, clamp);
    
    // added in gl4.3
    private z_PopDebugGroup_adr := GetProcAddress('glPopDebugGroup');
    private z_PopDebugGroup_1 := GetProcOrNil&<procedure>(z_PopDebugGroup_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PopDebugGroup :=
    z_PopDebugGroup_1();
    
    // added in gl3.1
    private z_PrimitiveRestartIndex_adr := GetProcAddress('glPrimitiveRestartIndex');
    private z_PrimitiveRestartIndex_1 := GetProcOrNil&<procedure(index: UInt32)>(z_PrimitiveRestartIndex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrimitiveRestartIndex(index: UInt32) :=
    z_PrimitiveRestartIndex_1(index);
    
    // added in gl4.1
    private z_ProgramBinary_adr := GetProcAddress('glProgramBinary');
    private z_ProgramBinary_1 := GetProcOrNil&<procedure(&program: gl_program; binaryFormat: DummyEnum; binary: IntPtr; length: Int32)>(z_ProgramBinary_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBinary(&program: gl_program; binaryFormat: DummyEnum; binary: IntPtr; length: Int32) :=
    z_ProgramBinary_1(&program, binaryFormat, binary, length);
    
    // added in gl4.1
    private z_ProgramParameteri_adr := GetProcAddress('glProgramParameteri');
    private z_ProgramParameteri_1 := GetProcOrNil&<procedure(&program: gl_program; pname: ProgramParameterPName; value: Int32)>(z_ProgramParameteri_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameteri(&program: gl_program; pname: ProgramParameterPName; value: Int32) :=
    z_ProgramParameteri_1(&program, pname, value);
    
    // added in gl4.1
    private z_ProgramUniform1d_adr := GetProcAddress('glProgramUniform1d');
    private z_ProgramUniform1d_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: real)>(z_ProgramUniform1d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1d(&program: gl_program; location: Int32; v0: real) :=
    z_ProgramUniform1d_1(&program, location, v0);
    
    // added in gl4.1
    private z_ProgramUniform1dv_adr := GetProcAddress('glProgramUniform1dv');
    private z_ProgramUniform1dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform1dv_adr);
    private z_ProgramUniform1dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: real)>(z_ProgramUniform1dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1dv(&program: gl_program; location: Int32; count: Int32; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform1dv_2(&program, location, count, value[0]) else
        z_ProgramUniform1dv_2(&program, location, count, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1dv(&program: gl_program; location: Int32; count: Int32; var value: real) :=
    z_ProgramUniform1dv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1dv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform1dv_1(&program, location, count, value);
    
    // added in gl4.1
    private z_ProgramUniform1f_adr := GetProcAddress('glProgramUniform1f');
    private z_ProgramUniform1f_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: single)>(z_ProgramUniform1f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1f(&program: gl_program; location: Int32; v0: single) :=
    z_ProgramUniform1f_1(&program, location, v0);
    
    // added in gl4.1
    private z_ProgramUniform1fv_adr := GetProcAddress('glProgramUniform1fv');
    private z_ProgramUniform1fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform1fv_adr);
    private z_ProgramUniform1fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: single)>(z_ProgramUniform1fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1fv(&program: gl_program; location: Int32; count: Int32; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform1fv_2(&program, location, count, value[0]) else
        z_ProgramUniform1fv_2(&program, location, count, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1fv(&program: gl_program; location: Int32; count: Int32; var value: single) :=
    z_ProgramUniform1fv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1fv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform1fv_1(&program, location, count, value);
    
    // added in gl4.1
    private z_ProgramUniform1i_adr := GetProcAddress('glProgramUniform1i');
    private z_ProgramUniform1i_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: Int32)>(z_ProgramUniform1i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i(&program: gl_program; location: Int32; v0: Int32) :=
    z_ProgramUniform1i_1(&program, location, v0);
    
    // added in gl4.1
    private z_ProgramUniform1iv_adr := GetProcAddress('glProgramUniform1iv');
    private z_ProgramUniform1iv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform1iv_adr);
    private z_ProgramUniform1iv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int32)>(z_ProgramUniform1iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1iv(&program: gl_program; location: Int32; count: Int32; value: array of Int32);
    type PInt32=^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform1iv_2(&program, location, count, value[0]) else
        z_ProgramUniform1iv_2(&program, location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1iv(&program: gl_program; location: Int32; count: Int32; var value: Int32) :=
    z_ProgramUniform1iv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1iv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform1iv_1(&program, location, count, value);
    
    // added in gl4.1
    private z_ProgramUniform1ui_adr := GetProcAddress('glProgramUniform1ui');
    private z_ProgramUniform1ui_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: UInt32)>(z_ProgramUniform1ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui(&program: gl_program; location: Int32; v0: UInt32) :=
    z_ProgramUniform1ui_1(&program, location, v0);
    
    // added in gl4.1
    private z_ProgramUniform1uiv_adr := GetProcAddress('glProgramUniform1uiv');
    private z_ProgramUniform1uiv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform1uiv_adr);
    private z_ProgramUniform1uiv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt32)>(z_ProgramUniform1uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1uiv(&program: gl_program; location: Int32; count: Int32; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform1uiv_2(&program, location, count, value[0]) else
        z_ProgramUniform1uiv_2(&program, location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1uiv(&program: gl_program; location: Int32; count: Int32; var value: UInt32) :=
    z_ProgramUniform1uiv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1uiv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform1uiv_1(&program, location, count, value);
    
    // added in gl4.1
    private z_ProgramUniform2d_adr := GetProcAddress('glProgramUniform2d');
    private z_ProgramUniform2d_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: real; v1: real)>(z_ProgramUniform2d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2d(&program: gl_program; location: Int32; v0: real; v1: real) :=
    z_ProgramUniform2d_1(&program, location, v0, v1);
    
    // added in gl4.1
    private z_ProgramUniform2dv_adr := GetProcAddress('glProgramUniform2dv');
    private z_ProgramUniform2dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform2dv_adr);
    private z_ProgramUniform2dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: real)>(z_ProgramUniform2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2dv(&program: gl_program; location: Int32; count: Int32; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform2dv_2(&program, location, count, value[0]) else
        z_ProgramUniform2dv_2(&program, location, count, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2dv(&program: gl_program; location: Int32; count: Int32; var value: real) :=
    z_ProgramUniform2dv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2dv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform2dv_1(&program, location, count, value);
    
    // added in gl4.1
    private z_ProgramUniform2f_adr := GetProcAddress('glProgramUniform2f');
    private z_ProgramUniform2f_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: single; v1: single)>(z_ProgramUniform2f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2f(&program: gl_program; location: Int32; v0: single; v1: single) :=
    z_ProgramUniform2f_1(&program, location, v0, v1);
    
    // added in gl4.1
    private z_ProgramUniform2fv_adr := GetProcAddress('glProgramUniform2fv');
    private z_ProgramUniform2fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform2fv_adr);
    private z_ProgramUniform2fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: single)>(z_ProgramUniform2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2fv(&program: gl_program; location: Int32; count: Int32; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform2fv_2(&program, location, count, value[0]) else
        z_ProgramUniform2fv_2(&program, location, count, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2fv(&program: gl_program; location: Int32; count: Int32; var value: single) :=
    z_ProgramUniform2fv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2fv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform2fv_1(&program, location, count, value);
    
    // added in gl4.1
    private z_ProgramUniform2i_adr := GetProcAddress('glProgramUniform2i');
    private z_ProgramUniform2i_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: Int32; v1: Int32)>(z_ProgramUniform2i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i(&program: gl_program; location: Int32; v0: Int32; v1: Int32) :=
    z_ProgramUniform2i_1(&program, location, v0, v1);
    
    // added in gl4.1
    private z_ProgramUniform2iv_adr := GetProcAddress('glProgramUniform2iv');
    private z_ProgramUniform2iv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform2iv_adr);
    private z_ProgramUniform2iv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int32)>(z_ProgramUniform2iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2iv(&program: gl_program; location: Int32; count: Int32; value: array of Int32);
    type PInt32=^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform2iv_2(&program, location, count, value[0]) else
        z_ProgramUniform2iv_2(&program, location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2iv(&program: gl_program; location: Int32; count: Int32; var value: Int32) :=
    z_ProgramUniform2iv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2iv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform2iv_1(&program, location, count, value);
    
    // added in gl4.1
    private z_ProgramUniform2ui_adr := GetProcAddress('glProgramUniform2ui');
    private z_ProgramUniform2ui_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: UInt32; v1: UInt32)>(z_ProgramUniform2ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui(&program: gl_program; location: Int32; v0: UInt32; v1: UInt32) :=
    z_ProgramUniform2ui_1(&program, location, v0, v1);
    
    // added in gl4.1
    private z_ProgramUniform2uiv_adr := GetProcAddress('glProgramUniform2uiv');
    private z_ProgramUniform2uiv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform2uiv_adr);
    private z_ProgramUniform2uiv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt32)>(z_ProgramUniform2uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2uiv(&program: gl_program; location: Int32; count: Int32; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform2uiv_2(&program, location, count, value[0]) else
        z_ProgramUniform2uiv_2(&program, location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2uiv(&program: gl_program; location: Int32; count: Int32; var value: UInt32) :=
    z_ProgramUniform2uiv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2uiv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform2uiv_1(&program, location, count, value);
    
    // added in gl4.1
    private z_ProgramUniform3d_adr := GetProcAddress('glProgramUniform3d');
    private z_ProgramUniform3d_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: real; v1: real; v2: real)>(z_ProgramUniform3d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3d(&program: gl_program; location: Int32; v0: real; v1: real; v2: real) :=
    z_ProgramUniform3d_1(&program, location, v0, v1, v2);
    
    // added in gl4.1
    private z_ProgramUniform3dv_adr := GetProcAddress('glProgramUniform3dv');
    private z_ProgramUniform3dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform3dv_adr);
    private z_ProgramUniform3dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: real)>(z_ProgramUniform3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3dv(&program: gl_program; location: Int32; count: Int32; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform3dv_2(&program, location, count, value[0]) else
        z_ProgramUniform3dv_2(&program, location, count, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3dv(&program: gl_program; location: Int32; count: Int32; var value: real) :=
    z_ProgramUniform3dv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3dv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform3dv_1(&program, location, count, value);
    
    // added in gl4.1
    private z_ProgramUniform3f_adr := GetProcAddress('glProgramUniform3f');
    private z_ProgramUniform3f_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: single; v1: single; v2: single)>(z_ProgramUniform3f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3f(&program: gl_program; location: Int32; v0: single; v1: single; v2: single) :=
    z_ProgramUniform3f_1(&program, location, v0, v1, v2);
    
    // added in gl4.1
    private z_ProgramUniform3fv_adr := GetProcAddress('glProgramUniform3fv');
    private z_ProgramUniform3fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform3fv_adr);
    private z_ProgramUniform3fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: single)>(z_ProgramUniform3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3fv(&program: gl_program; location: Int32; count: Int32; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform3fv_2(&program, location, count, value[0]) else
        z_ProgramUniform3fv_2(&program, location, count, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3fv(&program: gl_program; location: Int32; count: Int32; var value: single) :=
    z_ProgramUniform3fv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3fv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform3fv_1(&program, location, count, value);
    
    // added in gl4.1
    private z_ProgramUniform3i_adr := GetProcAddress('glProgramUniform3i');
    private z_ProgramUniform3i_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: Int32; v1: Int32; v2: Int32)>(z_ProgramUniform3i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i(&program: gl_program; location: Int32; v0: Int32; v1: Int32; v2: Int32) :=
    z_ProgramUniform3i_1(&program, location, v0, v1, v2);
    
    // added in gl4.1
    private z_ProgramUniform3iv_adr := GetProcAddress('glProgramUniform3iv');
    private z_ProgramUniform3iv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform3iv_adr);
    private z_ProgramUniform3iv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int32)>(z_ProgramUniform3iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3iv(&program: gl_program; location: Int32; count: Int32; value: array of Int32);
    type PInt32=^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform3iv_2(&program, location, count, value[0]) else
        z_ProgramUniform3iv_2(&program, location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3iv(&program: gl_program; location: Int32; count: Int32; var value: Int32) :=
    z_ProgramUniform3iv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3iv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform3iv_1(&program, location, count, value);
    
    // added in gl4.1
    private z_ProgramUniform3ui_adr := GetProcAddress('glProgramUniform3ui');
    private z_ProgramUniform3ui_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32)>(z_ProgramUniform3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui(&program: gl_program; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32) :=
    z_ProgramUniform3ui_1(&program, location, v0, v1, v2);
    
    // added in gl4.1
    private z_ProgramUniform3uiv_adr := GetProcAddress('glProgramUniform3uiv');
    private z_ProgramUniform3uiv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform3uiv_adr);
    private z_ProgramUniform3uiv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt32)>(z_ProgramUniform3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3uiv(&program: gl_program; location: Int32; count: Int32; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform3uiv_2(&program, location, count, value[0]) else
        z_ProgramUniform3uiv_2(&program, location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3uiv(&program: gl_program; location: Int32; count: Int32; var value: UInt32) :=
    z_ProgramUniform3uiv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3uiv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform3uiv_1(&program, location, count, value);
    
    // added in gl4.1
    private z_ProgramUniform4d_adr := GetProcAddress('glProgramUniform4d');
    private z_ProgramUniform4d_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: real; v1: real; v2: real; v3: real)>(z_ProgramUniform4d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4d(&program: gl_program; location: Int32; v0: real; v1: real; v2: real; v3: real) :=
    z_ProgramUniform4d_1(&program, location, v0, v1, v2, v3);
    
    // added in gl4.1
    private z_ProgramUniform4dv_adr := GetProcAddress('glProgramUniform4dv');
    private z_ProgramUniform4dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform4dv_adr);
    private z_ProgramUniform4dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: real)>(z_ProgramUniform4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4dv(&program: gl_program; location: Int32; count: Int32; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform4dv_2(&program, location, count, value[0]) else
        z_ProgramUniform4dv_2(&program, location, count, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4dv(&program: gl_program; location: Int32; count: Int32; var value: real) :=
    z_ProgramUniform4dv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4dv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform4dv_1(&program, location, count, value);
    
    // added in gl4.1
    private z_ProgramUniform4f_adr := GetProcAddress('glProgramUniform4f');
    private z_ProgramUniform4f_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: single; v1: single; v2: single; v3: single)>(z_ProgramUniform4f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4f(&program: gl_program; location: Int32; v0: single; v1: single; v2: single; v3: single) :=
    z_ProgramUniform4f_1(&program, location, v0, v1, v2, v3);
    
    // added in gl4.1
    private z_ProgramUniform4fv_adr := GetProcAddress('glProgramUniform4fv');
    private z_ProgramUniform4fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform4fv_adr);
    private z_ProgramUniform4fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: single)>(z_ProgramUniform4fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4fv(&program: gl_program; location: Int32; count: Int32; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform4fv_2(&program, location, count, value[0]) else
        z_ProgramUniform4fv_2(&program, location, count, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4fv(&program: gl_program; location: Int32; count: Int32; var value: single) :=
    z_ProgramUniform4fv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4fv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform4fv_1(&program, location, count, value);
    
    // added in gl4.1
    private z_ProgramUniform4i_adr := GetProcAddress('glProgramUniform4i');
    private z_ProgramUniform4i_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: Int32; v1: Int32; v2: Int32; v3: Int32)>(z_ProgramUniform4i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i(&program: gl_program; location: Int32; v0: Int32; v1: Int32; v2: Int32; v3: Int32) :=
    z_ProgramUniform4i_1(&program, location, v0, v1, v2, v3);
    
    // added in gl4.1
    private z_ProgramUniform4iv_adr := GetProcAddress('glProgramUniform4iv');
    private z_ProgramUniform4iv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform4iv_adr);
    private z_ProgramUniform4iv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int32)>(z_ProgramUniform4iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4iv(&program: gl_program; location: Int32; count: Int32; value: array of Int32);
    type PInt32=^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform4iv_2(&program, location, count, value[0]) else
        z_ProgramUniform4iv_2(&program, location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4iv(&program: gl_program; location: Int32; count: Int32; var value: Int32) :=
    z_ProgramUniform4iv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4iv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform4iv_1(&program, location, count, value);
    
    // added in gl4.1
    private z_ProgramUniform4ui_adr := GetProcAddress('glProgramUniform4ui');
    private z_ProgramUniform4ui_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32; v3: UInt32)>(z_ProgramUniform4ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui(&program: gl_program; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32; v3: UInt32) :=
    z_ProgramUniform4ui_1(&program, location, v0, v1, v2, v3);
    
    // added in gl4.1
    private z_ProgramUniform4uiv_adr := GetProcAddress('glProgramUniform4uiv');
    private z_ProgramUniform4uiv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform4uiv_adr);
    private z_ProgramUniform4uiv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt32)>(z_ProgramUniform4uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4uiv(&program: gl_program; location: Int32; count: Int32; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform4uiv_2(&program, location, count, value[0]) else
        z_ProgramUniform4uiv_2(&program, location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4uiv(&program: gl_program; location: Int32; count: Int32; var value: UInt32) :=
    z_ProgramUniform4uiv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4uiv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform4uiv_1(&program, location, count, value);
    
    // added in gl4.1
    private z_ProgramUniformMatrix2dv_adr := GetProcAddress('glProgramUniformMatrix2dv');
    private z_ProgramUniformMatrix2dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix2dv_adr);
    private z_ProgramUniformMatrix2dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real)>(z_ProgramUniformMatrix2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix2dv_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix2dv_2(&program, location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_ProgramUniformMatrix2dv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix2dv_1(&program, location, count, transpose, value);
    
    // added in gl4.1
    private z_ProgramUniformMatrix2fv_adr := GetProcAddress('glProgramUniformMatrix2fv');
    private z_ProgramUniformMatrix2fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix2fv_adr);
    private z_ProgramUniformMatrix2fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single)>(z_ProgramUniformMatrix2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix2fv_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix2fv_2(&program, location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_ProgramUniformMatrix2fv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix2fv_1(&program, location, count, transpose, value);
    
    // added in gl4.1
    private z_ProgramUniformMatrix2x3dv_adr := GetProcAddress('glProgramUniformMatrix2x3dv');
    private z_ProgramUniformMatrix2x3dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix2x3dv_adr);
    private z_ProgramUniformMatrix2x3dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real)>(z_ProgramUniformMatrix2x3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix2x3dv_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix2x3dv_2(&program, location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_ProgramUniformMatrix2x3dv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix2x3dv_1(&program, location, count, transpose, value);
    
    // added in gl4.1
    private z_ProgramUniformMatrix2x3fv_adr := GetProcAddress('glProgramUniformMatrix2x3fv');
    private z_ProgramUniformMatrix2x3fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix2x3fv_adr);
    private z_ProgramUniformMatrix2x3fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single)>(z_ProgramUniformMatrix2x3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix2x3fv_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix2x3fv_2(&program, location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_ProgramUniformMatrix2x3fv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix2x3fv_1(&program, location, count, transpose, value);
    
    // added in gl4.1
    private z_ProgramUniformMatrix2x4dv_adr := GetProcAddress('glProgramUniformMatrix2x4dv');
    private z_ProgramUniformMatrix2x4dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix2x4dv_adr);
    private z_ProgramUniformMatrix2x4dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real)>(z_ProgramUniformMatrix2x4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix2x4dv_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix2x4dv_2(&program, location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_ProgramUniformMatrix2x4dv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix2x4dv_1(&program, location, count, transpose, value);
    
    // added in gl4.1
    private z_ProgramUniformMatrix2x4fv_adr := GetProcAddress('glProgramUniformMatrix2x4fv');
    private z_ProgramUniformMatrix2x4fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix2x4fv_adr);
    private z_ProgramUniformMatrix2x4fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single)>(z_ProgramUniformMatrix2x4fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix2x4fv_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix2x4fv_2(&program, location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_ProgramUniformMatrix2x4fv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix2x4fv_1(&program, location, count, transpose, value);
    
    // added in gl4.1
    private z_ProgramUniformMatrix3dv_adr := GetProcAddress('glProgramUniformMatrix3dv');
    private z_ProgramUniformMatrix3dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix3dv_adr);
    private z_ProgramUniformMatrix3dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real)>(z_ProgramUniformMatrix3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix3dv_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix3dv_2(&program, location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_ProgramUniformMatrix3dv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix3dv_1(&program, location, count, transpose, value);
    
    // added in gl4.1
    private z_ProgramUniformMatrix3fv_adr := GetProcAddress('glProgramUniformMatrix3fv');
    private z_ProgramUniformMatrix3fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix3fv_adr);
    private z_ProgramUniformMatrix3fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single)>(z_ProgramUniformMatrix3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix3fv_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix3fv_2(&program, location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_ProgramUniformMatrix3fv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix3fv_1(&program, location, count, transpose, value);
    
    // added in gl4.1
    private z_ProgramUniformMatrix3x2dv_adr := GetProcAddress('glProgramUniformMatrix3x2dv');
    private z_ProgramUniformMatrix3x2dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix3x2dv_adr);
    private z_ProgramUniformMatrix3x2dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real)>(z_ProgramUniformMatrix3x2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix3x2dv_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix3x2dv_2(&program, location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_ProgramUniformMatrix3x2dv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix3x2dv_1(&program, location, count, transpose, value);
    
    // added in gl4.1
    private z_ProgramUniformMatrix3x2fv_adr := GetProcAddress('glProgramUniformMatrix3x2fv');
    private z_ProgramUniformMatrix3x2fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix3x2fv_adr);
    private z_ProgramUniformMatrix3x2fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single)>(z_ProgramUniformMatrix3x2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix3x2fv_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix3x2fv_2(&program, location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_ProgramUniformMatrix3x2fv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix3x2fv_1(&program, location, count, transpose, value);
    
    // added in gl4.1
    private z_ProgramUniformMatrix3x4dv_adr := GetProcAddress('glProgramUniformMatrix3x4dv');
    private z_ProgramUniformMatrix3x4dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix3x4dv_adr);
    private z_ProgramUniformMatrix3x4dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real)>(z_ProgramUniformMatrix3x4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix3x4dv_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix3x4dv_2(&program, location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_ProgramUniformMatrix3x4dv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix3x4dv_1(&program, location, count, transpose, value);
    
    // added in gl4.1
    private z_ProgramUniformMatrix3x4fv_adr := GetProcAddress('glProgramUniformMatrix3x4fv');
    private z_ProgramUniformMatrix3x4fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix3x4fv_adr);
    private z_ProgramUniformMatrix3x4fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single)>(z_ProgramUniformMatrix3x4fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix3x4fv_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix3x4fv_2(&program, location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_ProgramUniformMatrix3x4fv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix3x4fv_1(&program, location, count, transpose, value);
    
    // added in gl4.1
    private z_ProgramUniformMatrix4dv_adr := GetProcAddress('glProgramUniformMatrix4dv');
    private z_ProgramUniformMatrix4dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix4dv_adr);
    private z_ProgramUniformMatrix4dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real)>(z_ProgramUniformMatrix4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix4dv_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix4dv_2(&program, location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_ProgramUniformMatrix4dv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix4dv_1(&program, location, count, transpose, value);
    
    // added in gl4.1
    private z_ProgramUniformMatrix4fv_adr := GetProcAddress('glProgramUniformMatrix4fv');
    private z_ProgramUniformMatrix4fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix4fv_adr);
    private z_ProgramUniformMatrix4fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single)>(z_ProgramUniformMatrix4fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix4fv_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix4fv_2(&program, location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_ProgramUniformMatrix4fv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix4fv_1(&program, location, count, transpose, value);
    
    // added in gl4.1
    private z_ProgramUniformMatrix4x2dv_adr := GetProcAddress('glProgramUniformMatrix4x2dv');
    private z_ProgramUniformMatrix4x2dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix4x2dv_adr);
    private z_ProgramUniformMatrix4x2dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real)>(z_ProgramUniformMatrix4x2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix4x2dv_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix4x2dv_2(&program, location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_ProgramUniformMatrix4x2dv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix4x2dv_1(&program, location, count, transpose, value);
    
    // added in gl4.1
    private z_ProgramUniformMatrix4x2fv_adr := GetProcAddress('glProgramUniformMatrix4x2fv');
    private z_ProgramUniformMatrix4x2fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix4x2fv_adr);
    private z_ProgramUniformMatrix4x2fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single)>(z_ProgramUniformMatrix4x2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix4x2fv_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix4x2fv_2(&program, location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_ProgramUniformMatrix4x2fv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix4x2fv_1(&program, location, count, transpose, value);
    
    // added in gl4.1
    private z_ProgramUniformMatrix4x3dv_adr := GetProcAddress('glProgramUniformMatrix4x3dv');
    private z_ProgramUniformMatrix4x3dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix4x3dv_adr);
    private z_ProgramUniformMatrix4x3dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real)>(z_ProgramUniformMatrix4x3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix4x3dv_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix4x3dv_2(&program, location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_ProgramUniformMatrix4x3dv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix4x3dv_1(&program, location, count, transpose, value);
    
    // added in gl4.1
    private z_ProgramUniformMatrix4x3fv_adr := GetProcAddress('glProgramUniformMatrix4x3fv');
    private z_ProgramUniformMatrix4x3fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix4x3fv_adr);
    private z_ProgramUniformMatrix4x3fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single)>(z_ProgramUniformMatrix4x3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix4x3fv_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix4x3fv_2(&program, location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_ProgramUniformMatrix4x3fv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix4x3fv_1(&program, location, count, transpose, value);
    
    // added in gl3.2
    private z_ProvokingVertex_adr := GetProcAddress('glProvokingVertex');
    private z_ProvokingVertex_1 := GetProcOrNil&<procedure(mode: VertexProvokingMode)>(z_ProvokingVertex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProvokingVertex(mode: VertexProvokingMode) :=
    z_ProvokingVertex_1(mode);
    
    // added in gl4.3
    private z_PushDebugGroup_adr := GetProcAddress('glPushDebugGroup');
    private z_PushDebugGroup_1 := GetProcOrNil&<procedure(source: DebugSource; id: UInt32; length: Int32; message: IntPtr)>(z_PushDebugGroup_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PushDebugGroup(source: DebugSource; id: UInt32; length: Int32; message: string);
    begin
      var message_str_ptr: IntPtr;
      try
        message_str_ptr := Marshal.StringToHGlobalAnsi(message);
        z_PushDebugGroup_1(source, id, length, message_str_ptr);
      finally
        Marshal.FreeHGlobal(message_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PushDebugGroup(source: DebugSource; id: UInt32; length: Int32; message: IntPtr) :=
    z_PushDebugGroup_1(source, id, length, message);
    
    // added in gl3.3
    private z_QueryCounter_adr := GetProcAddress('glQueryCounter');
    private z_QueryCounter_1 := GetProcOrNil&<procedure(id: gl_query; target: QueryCounterTarget)>(z_QueryCounter_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure QueryCounter(id: gl_query; target: QueryCounterTarget) :=
    z_QueryCounter_1(id, target);
    
    // added in gl1.0
    private z_ReadBuffer_adr := GetProcAddress('glReadBuffer');
    private z_ReadBuffer_1 := GetProcOrNil&<procedure(src: ReadBufferMode)>(z_ReadBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReadBuffer(src: ReadBufferMode) :=
    z_ReadBuffer_1(src);
    
    // added in gl4.5
    private z_ReadnPixels_adr := GetProcAddress('glReadnPixels');
    private z_ReadnPixels_1 := GetProcOrNil&<procedure(x: Int32; y: Int32; width: Int32; height: Int32; format: PixelFormat; &type: PixelType; bufSize: Int32; data: IntPtr)>(z_ReadnPixels_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReadnPixels(x: Int32; y: Int32; width: Int32; height: Int32; format: PixelFormat; &type: PixelType; bufSize: Int32; data: IntPtr) :=
    z_ReadnPixels_1(x, y, width, height, format, &type, bufSize, data);
    
    // added in gl1.0
    private z_ReadPixels_adr := GetProcAddress('glReadPixels');
    private z_ReadPixels_1 := GetProcOrNil&<procedure(x: Int32; y: Int32; width: Int32; height: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr)>(z_ReadPixels_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReadPixels(x: Int32; y: Int32; width: Int32; height: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr) :=
    z_ReadPixels_1(x, y, width, height, format, &type, pixels);
    
    // added in gl4.1
    private z_ReleaseShaderCompiler_adr := GetProcAddress('glReleaseShaderCompiler');
    private z_ReleaseShaderCompiler_1 := GetProcOrNil&<procedure>(z_ReleaseShaderCompiler_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReleaseShaderCompiler :=
    z_ReleaseShaderCompiler_1();
    
    // added in gl3.0
    private z_RenderbufferStorage_adr := GetProcAddress('glRenderbufferStorage');
    private z_RenderbufferStorage_1 := GetProcOrNil&<procedure(target: RenderbufferTarget; _internalformat: InternalFormat; width: Int32; height: Int32)>(z_RenderbufferStorage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RenderbufferStorage(target: RenderbufferTarget; _internalformat: InternalFormat; width: Int32; height: Int32) :=
    z_RenderbufferStorage_1(target, _internalformat, width, height);
    
    // added in gl3.0
    private z_RenderbufferStorageMultisample_adr := GetProcAddress('glRenderbufferStorageMultisample');
    private z_RenderbufferStorageMultisample_1 := GetProcOrNil&<procedure(target: RenderbufferTarget; samples: Int32; _internalformat: InternalFormat; width: Int32; height: Int32)>(z_RenderbufferStorageMultisample_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RenderbufferStorageMultisample(target: RenderbufferTarget; samples: Int32; _internalformat: InternalFormat; width: Int32; height: Int32) :=
    z_RenderbufferStorageMultisample_1(target, samples, _internalformat, width, height);
    
    // added in gl4.0
    private z_ResumeTransformFeedback_adr := GetProcAddress('glResumeTransformFeedback');
    private z_ResumeTransformFeedback_1 := GetProcOrNil&<procedure>(z_ResumeTransformFeedback_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ResumeTransformFeedback :=
    z_ResumeTransformFeedback_1();
    
    // added in gl1.3
    private z_SampleCoverage_adr := GetProcAddress('glSampleCoverage');
    private z_SampleCoverage_1 := GetProcOrNil&<procedure(value: single; invert: boolean)>(z_SampleCoverage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SampleCoverage(value: single; invert: boolean) :=
    z_SampleCoverage_1(value, invert);
    
    // added in gl3.2
    private z_SampleMaski_adr := GetProcAddress('glSampleMaski');
    private z_SampleMaski_1 := GetProcOrNil&<procedure(maskNumber: UInt32; mask: DummyFlags)>(z_SampleMaski_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SampleMaski(maskNumber: UInt32; mask: DummyFlags) :=
    z_SampleMaski_1(maskNumber, mask);
    
    // added in gl3.3
    private z_SamplerParameterf_adr := GetProcAddress('glSamplerParameterf');
    private z_SamplerParameterf_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: OpenGL.SamplerParameterF; param: single)>(z_SamplerParameterf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterf(sampler: gl_sampler; pname: OpenGL.SamplerParameterF; param: single) :=
    z_SamplerParameterf_1(sampler, pname, param);
    
    // added in gl3.3
    private z_SamplerParameterfv_adr := GetProcAddress('glSamplerParameterfv');
    private z_SamplerParameterfv_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: OpenGL.SamplerParameterF; param: IntPtr)>(z_SamplerParameterfv_adr);
    private z_SamplerParameterfv_2 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: OpenGL.SamplerParameterF; var param: single)>(z_SamplerParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterfv(sampler: gl_sampler; pname: OpenGL.SamplerParameterF; param: array of single);
    type Psingle=^single;
    begin
      if (param<>nil) and (param.Length<>0) then
        z_SamplerParameterfv_2(sampler, pname, param[0]) else
        z_SamplerParameterfv_2(sampler, pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterfv(sampler: gl_sampler; pname: OpenGL.SamplerParameterF; var param: single) :=
    z_SamplerParameterfv_2(sampler, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterfv(sampler: gl_sampler; pname: OpenGL.SamplerParameterF; param: IntPtr) :=
    z_SamplerParameterfv_1(sampler, pname, param);
    
    // added in gl3.3
    private z_SamplerParameteri_adr := GetProcAddress('glSamplerParameteri');
    private z_SamplerParameteri_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; param: Int32)>(z_SamplerParameteri_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameteri(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; param: Int32) :=
    z_SamplerParameteri_1(sampler, pname, param);
    
    // added in gl3.3
    private z_SamplerParameterIiv_adr := GetProcAddress('glSamplerParameterIiv');
    private z_SamplerParameterIiv_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; param: IntPtr)>(z_SamplerParameterIiv_adr);
    private z_SamplerParameterIiv_2 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; var param: Int32)>(z_SamplerParameterIiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIiv(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; param: array of Int32);
    type PInt32=^Int32;
    begin
      if (param<>nil) and (param.Length<>0) then
        z_SamplerParameterIiv_2(sampler, pname, param[0]) else
        z_SamplerParameterIiv_2(sampler, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIiv(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; var param: Int32) :=
    z_SamplerParameterIiv_2(sampler, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIiv(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; param: IntPtr) :=
    z_SamplerParameterIiv_1(sampler, pname, param);
    
    // added in gl3.3
    private z_SamplerParameterIuiv_adr := GetProcAddress('glSamplerParameterIuiv');
    private z_SamplerParameterIuiv_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; param: IntPtr)>(z_SamplerParameterIuiv_adr);
    private z_SamplerParameterIuiv_2 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; var param: UInt32)>(z_SamplerParameterIuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIuiv(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; param: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (param<>nil) and (param.Length<>0) then
        z_SamplerParameterIuiv_2(sampler, pname, param[0]) else
        z_SamplerParameterIuiv_2(sampler, pname, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIuiv(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; var param: UInt32) :=
    z_SamplerParameterIuiv_2(sampler, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIuiv(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; param: IntPtr) :=
    z_SamplerParameterIuiv_1(sampler, pname, param);
    
    // added in gl3.3
    private z_SamplerParameteriv_adr := GetProcAddress('glSamplerParameteriv');
    private z_SamplerParameteriv_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; param: IntPtr)>(z_SamplerParameteriv_adr);
    private z_SamplerParameteriv_2 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; var param: Int32)>(z_SamplerParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameteriv(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; param: array of Int32);
    type PInt32=^Int32;
    begin
      if (param<>nil) and (param.Length<>0) then
        z_SamplerParameteriv_2(sampler, pname, param[0]) else
        z_SamplerParameteriv_2(sampler, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameteriv(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; var param: Int32) :=
    z_SamplerParameteriv_2(sampler, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameteriv(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; param: IntPtr) :=
    z_SamplerParameteriv_1(sampler, pname, param);
    
    // added in gl1.0
    private z_Scissor_adr := GetProcAddress('glScissor');
    private z_Scissor_1 := GetProcOrNil&<procedure(x: Int32; y: Int32; width: Int32; height: Int32)>(z_Scissor_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Scissor(x: Int32; y: Int32; width: Int32; height: Int32) :=
    z_Scissor_1(x, y, width, height);
    
    // added in gl4.1
    private z_ScissorArrayv_adr := GetProcAddress('glScissorArrayv');
    private z_ScissorArrayv_1 := GetProcOrNil&<procedure(first: UInt32; count: Int32; v: IntPtr)>(z_ScissorArrayv_adr);
    private z_ScissorArrayv_2 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var v: Int32)>(z_ScissorArrayv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorArrayv(first: UInt32; count: Int32; v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_ScissorArrayv_2(first, count, v[0]) else
        z_ScissorArrayv_2(first, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorArrayv(first: UInt32; count: Int32; var v: Int32) :=
    z_ScissorArrayv_2(first, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorArrayv(first: UInt32; count: Int32; v: IntPtr) :=
    z_ScissorArrayv_1(first, count, v);
    
    // added in gl4.1
    private z_ScissorIndexed_adr := GetProcAddress('glScissorIndexed');
    private z_ScissorIndexed_1 := GetProcOrNil&<procedure(index: UInt32; left: Int32; bottom: Int32; width: Int32; height: Int32)>(z_ScissorIndexed_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorIndexed(index: UInt32; left: Int32; bottom: Int32; width: Int32; height: Int32) :=
    z_ScissorIndexed_1(index, left, bottom, width, height);
    
    // added in gl4.1
    private z_ScissorIndexedv_adr := GetProcAddress('glScissorIndexedv');
    private z_ScissorIndexedv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_ScissorIndexedv_adr);
    private z_ScissorIndexedv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(z_ScissorIndexedv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorIndexedv(index: UInt32; v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_ScissorIndexedv_2(index, v[0]) else
        z_ScissorIndexedv_2(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorIndexedv(index: UInt32; var v: Int32) :=
    z_ScissorIndexedv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorIndexedv(index: UInt32; v: IntPtr) :=
    z_ScissorIndexedv_1(index, v);
    
    // added in gl3.3
    private z_SecondaryColorP3ui_adr := GetProcAddress('glSecondaryColorP3ui');
    private z_SecondaryColorP3ui_1 := GetProcOrNil&<procedure(&type: ColorPointerType; color: UInt32)>(z_SecondaryColorP3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorP3ui(&type: ColorPointerType; color: UInt32) :=
    z_SecondaryColorP3ui_1(&type, color);
    
    // added in gl3.3
    private z_SecondaryColorP3uiv_adr := GetProcAddress('glSecondaryColorP3uiv');
    private z_SecondaryColorP3uiv_1 := GetProcOrNil&<procedure(&type: ColorPointerType; color: IntPtr)>(z_SecondaryColorP3uiv_adr);
    private z_SecondaryColorP3uiv_2 := GetProcOrNil&<procedure(&type: ColorPointerType; var color: UInt32)>(z_SecondaryColorP3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorP3uiv(&type: ColorPointerType; color: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (color<>nil) and (color.Length<>0) then
        z_SecondaryColorP3uiv_2(&type, color[0]) else
        z_SecondaryColorP3uiv_2(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorP3uiv(&type: ColorPointerType; var color: UInt32) :=
    z_SecondaryColorP3uiv_2(&type, color);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorP3uiv(&type: ColorPointerType; color: IntPtr) :=
    z_SecondaryColorP3uiv_1(&type, color);
    
    // added in gl4.1
    private z_ShaderBinary_adr := GetProcAddress('glShaderBinary');
    private z_ShaderBinary_1 := GetProcOrNil&<procedure(count: Int32; shaders: IntPtr; binaryFormat: ShaderBinaryFormat; binary: IntPtr; length: Int32)>(z_ShaderBinary_adr);
    private z_ShaderBinary_2 := GetProcOrNil&<procedure(count: Int32; var shaders: gl_shader; binaryFormat: ShaderBinaryFormat; binary: IntPtr; length: Int32)>(z_ShaderBinary_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderBinary(count: Int32; shaders: array of gl_shader; binaryFormat: ShaderBinaryFormat; binary: IntPtr; length: Int32);
    type Pgl_shader=^gl_shader;
    begin
      if (shaders<>nil) and (shaders.Length<>0) then
        z_ShaderBinary_2(count, shaders[0], binaryFormat, binary, length) else
        z_ShaderBinary_2(count, Pgl_shader(nil)^, binaryFormat, binary, length);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderBinary(count: Int32; var shaders: gl_shader; binaryFormat: ShaderBinaryFormat; binary: IntPtr; length: Int32) :=
    z_ShaderBinary_2(count, shaders, binaryFormat, binary, length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderBinary(count: Int32; shaders: IntPtr; binaryFormat: ShaderBinaryFormat; binary: IntPtr; length: Int32) :=
    z_ShaderBinary_1(count, shaders, binaryFormat, binary, length);
    
    // added in gl2.0
    private z_ShaderSource_adr := GetProcAddress('glShaderSource');
    private z_ShaderSource_1 := GetProcOrNil&<procedure(shader: gl_shader; count: Int32; _string: pointer; length: IntPtr)>(z_ShaderSource_adr);
    private z_ShaderSource_2 := GetProcOrNil&<procedure(shader: gl_shader; count: Int32; _string: pointer; var length: Int32)>(z_ShaderSource_adr);
    private z_ShaderSource_3 := GetProcOrNil&<procedure(shader: gl_shader; count: Int32; var _string: IntPtr; length: IntPtr)>(z_ShaderSource_adr);
    private z_ShaderSource_4 := GetProcOrNil&<procedure(shader: gl_shader; count: Int32; var _string: IntPtr; var length: Int32)>(z_ShaderSource_adr);
    private [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure temp_ShaderSource_1(shader: gl_shader; count: Int32; _string: array of IntPtr; length: array of Int32);
    type PIntPtr=^IntPtr;
    type PInt32=^Int32;
    begin
      if (length<>nil) and (length.Length<>0) then
        if (_string<>nil) and (_string.Length<>0) then
          z_ShaderSource_4(shader, count, _string[0], length[0]) else
          z_ShaderSource_4(shader, count, PIntPtr(nil)^, length[0]) else
        if (_string<>nil) and (_string.Length<>0) then
          z_ShaderSource_4(shader, count, _string[0], PInt32(nil)^) else
          z_ShaderSource_4(shader, count, PIntPtr(nil)^, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderSource(shader: gl_shader; count: Int32; _string: array of string; length: array of Int32);
    begin
      var _string_str_ptrs: array of IntPtr;
      try
        _string_str_ptrs := _string?.ConvertAll(arr_el1->
          Marshal.StringToHGlobalAnsi(arr_el1)
        );
        temp_ShaderSource_1(shader, count, _string_str_ptrs, length);
      finally
        if _string_str_ptrs<>nil then foreach var arr_el1 in _string_str_ptrs do
          Marshal.FreeHGlobal(arr_el1);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderSource(shader: gl_shader; count: Int32; var _string: IntPtr; var length: Int32) :=
    z_ShaderSource_4(shader, count, _string, length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderSource(shader: gl_shader; count: Int32; var _string: IntPtr; length: IntPtr) :=
    z_ShaderSource_3(shader, count, _string, length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderSource(shader: gl_shader; count: Int32; _string: pointer; var length: Int32) :=
    z_ShaderSource_2(shader, count, _string, length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderSource(shader: gl_shader; count: Int32; _string: pointer; length: IntPtr) :=
    z_ShaderSource_1(shader, count, _string, length);
    
    // added in gl4.3
    private z_ShaderStorageBlockBinding_adr := GetProcAddress('glShaderStorageBlockBinding');
    private z_ShaderStorageBlockBinding_1 := GetProcOrNil&<procedure(&program: gl_program; storageBlockIndex: UInt32; storageBlockBinding: UInt32)>(z_ShaderStorageBlockBinding_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderStorageBlockBinding(&program: gl_program; storageBlockIndex: UInt32; storageBlockBinding: UInt32) :=
    z_ShaderStorageBlockBinding_1(&program, storageBlockIndex, storageBlockBinding);
    
    // added in gl4.6
    private z_SpecializeShader_adr := GetProcAddress('glSpecializeShader');
    private z_SpecializeShader_1 := GetProcOrNil&<procedure(shader: gl_shader; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; pConstantIndex: IntPtr; pConstantValue: IntPtr)>(z_SpecializeShader_adr);
    private z_SpecializeShader_2 := GetProcOrNil&<procedure(shader: gl_shader; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; pConstantIndex: IntPtr; var pConstantValue: UInt32)>(z_SpecializeShader_adr);
    private z_SpecializeShader_3 := GetProcOrNil&<procedure(shader: gl_shader; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; pConstantValue: IntPtr)>(z_SpecializeShader_adr);
    private z_SpecializeShader_4 := GetProcOrNil&<procedure(shader: gl_shader; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; var pConstantValue: UInt32)>(z_SpecializeShader_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShader(shader: gl_shader; pEntryPoint: string; numSpecializationConstants: UInt32; pConstantIndex: array of UInt32; pConstantValue: array of UInt32);
    type PUInt32=^UInt32;
    begin
      var pEntryPoint_str_ptr: IntPtr;
      try
        pEntryPoint_str_ptr := Marshal.StringToHGlobalAnsi(pEntryPoint);
        if (pConstantValue<>nil) and (pConstantValue.Length<>0) then
          if (pConstantIndex<>nil) and (pConstantIndex.Length<>0) then
            z_SpecializeShader_4(shader, pEntryPoint_str_ptr, numSpecializationConstants, pConstantIndex[0], pConstantValue[0]) else
            z_SpecializeShader_4(shader, pEntryPoint_str_ptr, numSpecializationConstants, PUInt32(nil)^, pConstantValue[0]) else
          if (pConstantIndex<>nil) and (pConstantIndex.Length<>0) then
            z_SpecializeShader_4(shader, pEntryPoint_str_ptr, numSpecializationConstants, pConstantIndex[0], PUInt32(nil)^) else
            z_SpecializeShader_4(shader, pEntryPoint_str_ptr, numSpecializationConstants, PUInt32(nil)^, PUInt32(nil)^);
      finally
        Marshal.FreeHGlobal(pEntryPoint_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShader(shader: gl_shader; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; pConstantIndex: array of UInt32; pConstantValue: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (pConstantValue<>nil) and (pConstantValue.Length<>0) then
        if (pConstantIndex<>nil) and (pConstantIndex.Length<>0) then
          z_SpecializeShader_4(shader, pEntryPoint, numSpecializationConstants, pConstantIndex[0], pConstantValue[0]) else
          z_SpecializeShader_4(shader, pEntryPoint, numSpecializationConstants, PUInt32(nil)^, pConstantValue[0]) else
        if (pConstantIndex<>nil) and (pConstantIndex.Length<>0) then
          z_SpecializeShader_4(shader, pEntryPoint, numSpecializationConstants, pConstantIndex[0], PUInt32(nil)^) else
          z_SpecializeShader_4(shader, pEntryPoint, numSpecializationConstants, PUInt32(nil)^, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShader(shader: gl_shader; pEntryPoint: string; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; var pConstantValue: UInt32);
    begin
      var pEntryPoint_str_ptr: IntPtr;
      try
        pEntryPoint_str_ptr := Marshal.StringToHGlobalAnsi(pEntryPoint);
        z_SpecializeShader_4(shader, pEntryPoint_str_ptr, numSpecializationConstants, pConstantIndex, pConstantValue);
      finally
        Marshal.FreeHGlobal(pEntryPoint_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShader(shader: gl_shader; pEntryPoint: string; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; pConstantValue: IntPtr);
    begin
      var pEntryPoint_str_ptr: IntPtr;
      try
        pEntryPoint_str_ptr := Marshal.StringToHGlobalAnsi(pEntryPoint);
        z_SpecializeShader_3(shader, pEntryPoint_str_ptr, numSpecializationConstants, pConstantIndex, pConstantValue);
      finally
        Marshal.FreeHGlobal(pEntryPoint_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShader(shader: gl_shader; pEntryPoint: string; numSpecializationConstants: UInt32; pConstantIndex: IntPtr; var pConstantValue: UInt32);
    begin
      var pEntryPoint_str_ptr: IntPtr;
      try
        pEntryPoint_str_ptr := Marshal.StringToHGlobalAnsi(pEntryPoint);
        z_SpecializeShader_2(shader, pEntryPoint_str_ptr, numSpecializationConstants, pConstantIndex, pConstantValue);
      finally
        Marshal.FreeHGlobal(pEntryPoint_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShader(shader: gl_shader; pEntryPoint: string; numSpecializationConstants: UInt32; pConstantIndex: IntPtr; pConstantValue: IntPtr);
    begin
      var pEntryPoint_str_ptr: IntPtr;
      try
        pEntryPoint_str_ptr := Marshal.StringToHGlobalAnsi(pEntryPoint);
        z_SpecializeShader_1(shader, pEntryPoint_str_ptr, numSpecializationConstants, pConstantIndex, pConstantValue);
      finally
        Marshal.FreeHGlobal(pEntryPoint_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShader(shader: gl_shader; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; var pConstantValue: UInt32) :=
    z_SpecializeShader_4(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShader(shader: gl_shader; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; pConstantValue: IntPtr) :=
    z_SpecializeShader_3(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShader(shader: gl_shader; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; pConstantIndex: IntPtr; var pConstantValue: UInt32) :=
    z_SpecializeShader_2(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShader(shader: gl_shader; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; pConstantIndex: IntPtr; pConstantValue: IntPtr) :=
    z_SpecializeShader_1(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
    
    // added in gl1.0
    private z_StencilFunc_adr := GetProcAddress('glStencilFunc');
    private z_StencilFunc_1 := GetProcOrNil&<procedure(func: StencilFunction; ref: Int32; mask: UInt32)>(z_StencilFunc_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilFunc(func: StencilFunction; ref: Int32; mask: UInt32) :=
    z_StencilFunc_1(func, ref, mask);
    
    // added in gl2.0
    private z_StencilFuncSeparate_adr := GetProcAddress('glStencilFuncSeparate');
    private z_StencilFuncSeparate_1 := GetProcOrNil&<procedure(face: MaterialFace; func: StencilFunction; ref: Int32; mask: UInt32)>(z_StencilFuncSeparate_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilFuncSeparate(face: MaterialFace; func: StencilFunction; ref: Int32; mask: UInt32) :=
    z_StencilFuncSeparate_1(face, func, ref, mask);
    
    // added in gl1.0
    private z_StencilMask_adr := GetProcAddress('glStencilMask');
    private z_StencilMask_1 := GetProcOrNil&<procedure(mask: UInt32)>(z_StencilMask_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilMask(mask: UInt32) :=
    z_StencilMask_1(mask);
    
    // added in gl2.0
    private z_StencilMaskSeparate_adr := GetProcAddress('glStencilMaskSeparate');
    private z_StencilMaskSeparate_1 := GetProcOrNil&<procedure(face: MaterialFace; mask: UInt32)>(z_StencilMaskSeparate_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilMaskSeparate(face: MaterialFace; mask: UInt32) :=
    z_StencilMaskSeparate_1(face, mask);
    
    // added in gl1.0
    private z_StencilOp_adr := GetProcAddress('glStencilOp');
    private z_StencilOp_1 := GetProcOrNil&<procedure(fail: OpenGL.StencilOp; zfail: OpenGL.StencilOp; zpass: OpenGL.StencilOp)>(z_StencilOp_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilOp(fail: OpenGL.StencilOp; zfail: OpenGL.StencilOp; zpass: OpenGL.StencilOp) :=
    z_StencilOp_1(fail, zfail, zpass);
    
    // added in gl2.0
    private z_StencilOpSeparate_adr := GetProcAddress('glStencilOpSeparate');
    private z_StencilOpSeparate_1 := GetProcOrNil&<procedure(face: MaterialFace; sfail: OpenGL.StencilOp; dpfail: OpenGL.StencilOp; dppass: OpenGL.StencilOp)>(z_StencilOpSeparate_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilOpSeparate(face: MaterialFace; sfail: OpenGL.StencilOp; dpfail: OpenGL.StencilOp; dppass: OpenGL.StencilOp) :=
    z_StencilOpSeparate_1(face, sfail, dpfail, dppass);
    
    // added in gl3.1
    private z_TexBuffer_adr := GetProcAddress('glTexBuffer');
    private z_TexBuffer_1 := GetProcOrNil&<procedure(target: TextureTarget; internalformat: SizedInternalFormat; buffer: gl_buffer)>(z_TexBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBuffer(target: TextureTarget; internalformat: SizedInternalFormat; buffer: gl_buffer) :=
    z_TexBuffer_1(target, internalformat, buffer);
    
    // added in gl4.3
    private z_TexBufferRange_adr := GetProcAddress('glTexBufferRange');
    private z_TexBufferRange_1 := GetProcOrNil&<procedure(target: TextureTarget; internalformat: SizedInternalFormat; buffer: gl_buffer; offset: IntPtr; size: UIntPtr)>(z_TexBufferRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBufferRange(target: TextureTarget; internalformat: SizedInternalFormat; buffer: gl_buffer; offset: IntPtr; size: UIntPtr) :=
    z_TexBufferRange_1(target, internalformat, buffer, offset, size);
    
    // added in gl3.3
    private z_TexCoordP1ui_adr := GetProcAddress('glTexCoordP1ui');
    private z_TexCoordP1ui_1 := GetProcOrNil&<procedure(&type: TexCoordPointerType; coords: UInt32)>(z_TexCoordP1ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP1ui(&type: TexCoordPointerType; coords: UInt32) :=
    z_TexCoordP1ui_1(&type, coords);
    
    // added in gl3.3
    private z_TexCoordP1uiv_adr := GetProcAddress('glTexCoordP1uiv');
    private z_TexCoordP1uiv_1 := GetProcOrNil&<procedure(&type: TexCoordPointerType; coords: IntPtr)>(z_TexCoordP1uiv_adr);
    private z_TexCoordP1uiv_2 := GetProcOrNil&<procedure(&type: TexCoordPointerType; var coords: UInt32)>(z_TexCoordP1uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP1uiv(&type: TexCoordPointerType; coords: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_TexCoordP1uiv_2(&type, coords[0]) else
        z_TexCoordP1uiv_2(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP1uiv(&type: TexCoordPointerType; var coords: UInt32) :=
    z_TexCoordP1uiv_2(&type, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP1uiv(&type: TexCoordPointerType; coords: IntPtr) :=
    z_TexCoordP1uiv_1(&type, coords);
    
    // added in gl3.3
    private z_TexCoordP2ui_adr := GetProcAddress('glTexCoordP2ui');
    private z_TexCoordP2ui_1 := GetProcOrNil&<procedure(&type: TexCoordPointerType; coords: UInt32)>(z_TexCoordP2ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP2ui(&type: TexCoordPointerType; coords: UInt32) :=
    z_TexCoordP2ui_1(&type, coords);
    
    // added in gl3.3
    private z_TexCoordP2uiv_adr := GetProcAddress('glTexCoordP2uiv');
    private z_TexCoordP2uiv_1 := GetProcOrNil&<procedure(&type: TexCoordPointerType; coords: IntPtr)>(z_TexCoordP2uiv_adr);
    private z_TexCoordP2uiv_2 := GetProcOrNil&<procedure(&type: TexCoordPointerType; var coords: UInt32)>(z_TexCoordP2uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP2uiv(&type: TexCoordPointerType; coords: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_TexCoordP2uiv_2(&type, coords[0]) else
        z_TexCoordP2uiv_2(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP2uiv(&type: TexCoordPointerType; var coords: UInt32) :=
    z_TexCoordP2uiv_2(&type, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP2uiv(&type: TexCoordPointerType; coords: IntPtr) :=
    z_TexCoordP2uiv_1(&type, coords);
    
    // added in gl3.3
    private z_TexCoordP3ui_adr := GetProcAddress('glTexCoordP3ui');
    private z_TexCoordP3ui_1 := GetProcOrNil&<procedure(&type: TexCoordPointerType; coords: UInt32)>(z_TexCoordP3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP3ui(&type: TexCoordPointerType; coords: UInt32) :=
    z_TexCoordP3ui_1(&type, coords);
    
    // added in gl3.3
    private z_TexCoordP3uiv_adr := GetProcAddress('glTexCoordP3uiv');
    private z_TexCoordP3uiv_1 := GetProcOrNil&<procedure(&type: TexCoordPointerType; coords: IntPtr)>(z_TexCoordP3uiv_adr);
    private z_TexCoordP3uiv_2 := GetProcOrNil&<procedure(&type: TexCoordPointerType; var coords: UInt32)>(z_TexCoordP3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP3uiv(&type: TexCoordPointerType; coords: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_TexCoordP3uiv_2(&type, coords[0]) else
        z_TexCoordP3uiv_2(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP3uiv(&type: TexCoordPointerType; var coords: UInt32) :=
    z_TexCoordP3uiv_2(&type, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP3uiv(&type: TexCoordPointerType; coords: IntPtr) :=
    z_TexCoordP3uiv_1(&type, coords);
    
    // added in gl3.3
    private z_TexCoordP4ui_adr := GetProcAddress('glTexCoordP4ui');
    private z_TexCoordP4ui_1 := GetProcOrNil&<procedure(&type: TexCoordPointerType; coords: UInt32)>(z_TexCoordP4ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP4ui(&type: TexCoordPointerType; coords: UInt32) :=
    z_TexCoordP4ui_1(&type, coords);
    
    // added in gl3.3
    private z_TexCoordP4uiv_adr := GetProcAddress('glTexCoordP4uiv');
    private z_TexCoordP4uiv_1 := GetProcOrNil&<procedure(&type: TexCoordPointerType; coords: IntPtr)>(z_TexCoordP4uiv_adr);
    private z_TexCoordP4uiv_2 := GetProcOrNil&<procedure(&type: TexCoordPointerType; var coords: UInt32)>(z_TexCoordP4uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP4uiv(&type: TexCoordPointerType; coords: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_TexCoordP4uiv_2(&type, coords[0]) else
        z_TexCoordP4uiv_2(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP4uiv(&type: TexCoordPointerType; var coords: UInt32) :=
    z_TexCoordP4uiv_2(&type, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP4uiv(&type: TexCoordPointerType; coords: IntPtr) :=
    z_TexCoordP4uiv_1(&type, coords);
    
    // added in gl1.0
    private z_TexImage1D_adr := GetProcAddress('glTexImage1D');
    private z_TexImage1D_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; border: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr)>(z_TexImage1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage1D(target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; border: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr) :=
    z_TexImage1D_1(target, level, _internalformat, width, border, format, &type, pixels);
    
    // added in gl1.0
    private z_TexImage2D_adr := GetProcAddress('glTexImage2D');
    private z_TexImage2D_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; border: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr)>(z_TexImage2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage2D(target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; border: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr) :=
    z_TexImage2D_1(target, level, _internalformat, width, height, border, format, &type, pixels);
    
    // added in gl3.2
    private z_TexImage2DMultisample_adr := GetProcAddress('glTexImage2DMultisample');
    private z_TexImage2DMultisample_1 := GetProcOrNil&<procedure(target: TextureTarget; samples: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; fixedsamplelocations: boolean)>(z_TexImage2DMultisample_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage2DMultisample(target: TextureTarget; samples: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; fixedsamplelocations: boolean) :=
    z_TexImage2DMultisample_1(target, samples, _internalformat, width, height, fixedsamplelocations);
    
    // added in gl1.2
    private z_TexImage3D_adr := GetProcAddress('glTexImage3D');
    private z_TexImage3D_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; depth: Int32; border: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr)>(z_TexImage3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage3D(target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; depth: Int32; border: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr) :=
    z_TexImage3D_1(target, level, _internalformat, width, height, depth, border, format, &type, pixels);
    
    // added in gl3.2
    private z_TexImage3DMultisample_adr := GetProcAddress('glTexImage3DMultisample');
    private z_TexImage3DMultisample_1 := GetProcOrNil&<procedure(target: TextureTarget; samples: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: boolean)>(z_TexImage3DMultisample_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage3DMultisample(target: TextureTarget; samples: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: boolean) :=
    z_TexImage3DMultisample_1(target, samples, _internalformat, width, height, depth, fixedsamplelocations);
    
    // added in gl1.0
    private z_TexParameterf_adr := GetProcAddress('glTexParameterf');
    private z_TexParameterf_1 := GetProcOrNil&<procedure(target: TextureTarget; pname: TextureParameterName; param: single)>(z_TexParameterf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterf(target: TextureTarget; pname: TextureParameterName; param: single) :=
    z_TexParameterf_1(target, pname, param);
    
    // added in gl1.0
    private z_TexParameterfv_adr := GetProcAddress('glTexParameterfv');
    private z_TexParameterfv_1 := GetProcOrNil&<procedure(target: TextureTarget; pname: TextureParameterName; &params: IntPtr)>(z_TexParameterfv_adr);
    private z_TexParameterfv_2 := GetProcOrNil&<procedure(target: TextureTarget; pname: TextureParameterName; var &params: single)>(z_TexParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterfv(target: TextureTarget; pname: TextureParameterName; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_TexParameterfv_2(target, pname, &params[0]) else
        z_TexParameterfv_2(target, pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterfv(target: TextureTarget; pname: TextureParameterName; var &params: single) :=
    z_TexParameterfv_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterfv(target: TextureTarget; pname: TextureParameterName; &params: IntPtr) :=
    z_TexParameterfv_1(target, pname, &params);
    
    // added in gl1.0
    private z_TexParameteri_adr := GetProcAddress('glTexParameteri');
    private z_TexParameteri_1 := GetProcOrNil&<procedure(target: TextureTarget; pname: TextureParameterName; param: Int32)>(z_TexParameteri_adr);
    private z_TexParameteri_2 := GetProcOrNil&<procedure(target: TextureTarget; pname: TextureParameterName; param: TextureWrapMode)>(z_TexParameteri_adr);
    private z_TexParameteri_3 := GetProcOrNil&<procedure(target: TextureTarget; pname: TextureParameterName; param: TextureSwizzle)>(z_TexParameteri_adr);
    private z_TexParameteri_4 := GetProcOrNil&<procedure(target: TextureTarget; pname: TextureParameterName; param: TextureMinFilter)>(z_TexParameteri_adr);
    private z_TexParameteri_5 := GetProcOrNil&<procedure(target: TextureTarget; pname: TextureParameterName; param: TextureMagFilter)>(z_TexParameteri_adr);
    private z_TexParameteri_6 := GetProcOrNil&<procedure(target: TextureTarget; pname: TextureParameterName; param: TextureCompareMode)>(z_TexParameteri_adr);
    private z_TexParameteri_7 := GetProcOrNil&<procedure(target: TextureTarget; pname: TextureParameterName; param: MapTextureFormat)>(z_TexParameteri_adr);
    private z_TexParameteri_8 := GetProcOrNil&<procedure(target: TextureTarget; pname: TextureParameterName; param: FoveationConfigBit)>(z_TexParameteri_adr);
    private z_TexParameteri_9 := GetProcOrNil&<procedure(target: TextureTarget; pname: TextureParameterName; param: DepthStencilTextureMode)>(z_TexParameteri_adr);
    private z_TexParameteri_10 := GetProcOrNil&<procedure(target: TextureTarget; pname: TextureParameterName; param: ConvolutionBorderMode)>(z_TexParameteri_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteri(target: TextureTarget; pname: TextureParameterName; param: ConvolutionBorderMode) :=
    z_TexParameteri_10(target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteri(target: TextureTarget; pname: TextureParameterName; param: DepthStencilTextureMode) :=
    z_TexParameteri_9(target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteri(target: TextureTarget; pname: TextureParameterName; param: FoveationConfigBit) :=
    z_TexParameteri_8(target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteri(target: TextureTarget; pname: TextureParameterName; param: MapTextureFormat) :=
    z_TexParameteri_7(target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteri(target: TextureTarget; pname: TextureParameterName; param: TextureCompareMode) :=
    z_TexParameteri_6(target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteri(target: TextureTarget; pname: TextureParameterName; param: TextureMagFilter) :=
    z_TexParameteri_5(target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteri(target: TextureTarget; pname: TextureParameterName; param: TextureMinFilter) :=
    z_TexParameteri_4(target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteri(target: TextureTarget; pname: TextureParameterName; param: TextureSwizzle) :=
    z_TexParameteri_3(target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteri(target: TextureTarget; pname: TextureParameterName; param: TextureWrapMode) :=
    z_TexParameteri_2(target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteri(target: TextureTarget; pname: TextureParameterName; param: Int32) :=
    z_TexParameteri_1(target, pname, param);
    
    // added in gl3.0
    private z_TexParameterIiv_adr := GetProcAddress('glTexParameterIiv');
    private z_TexParameterIiv_1 := GetProcOrNil&<procedure(target: TextureTarget; pname: TextureParameterName; &params: IntPtr)>(z_TexParameterIiv_adr);
    private z_TexParameterIiv_2 := GetProcOrNil&<procedure(target: TextureTarget; pname: TextureParameterName; var &params: Int32)>(z_TexParameterIiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIiv(target: TextureTarget; pname: TextureParameterName; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_TexParameterIiv_2(target, pname, &params[0]) else
        z_TexParameterIiv_2(target, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIiv(target: TextureTarget; pname: TextureParameterName; var &params: Int32) :=
    z_TexParameterIiv_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIiv(target: TextureTarget; pname: TextureParameterName; &params: IntPtr) :=
    z_TexParameterIiv_1(target, pname, &params);
    
    // added in gl3.0
    private z_TexParameterIuiv_adr := GetProcAddress('glTexParameterIuiv');
    private z_TexParameterIuiv_1 := GetProcOrNil&<procedure(target: TextureTarget; pname: TextureParameterName; &params: IntPtr)>(z_TexParameterIuiv_adr);
    private z_TexParameterIuiv_2 := GetProcOrNil&<procedure(target: TextureTarget; pname: TextureParameterName; var &params: UInt32)>(z_TexParameterIuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIuiv(target: TextureTarget; pname: TextureParameterName; &params: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_TexParameterIuiv_2(target, pname, &params[0]) else
        z_TexParameterIuiv_2(target, pname, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIuiv(target: TextureTarget; pname: TextureParameterName; var &params: UInt32) :=
    z_TexParameterIuiv_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIuiv(target: TextureTarget; pname: TextureParameterName; &params: IntPtr) :=
    z_TexParameterIuiv_1(target, pname, &params);
    
    // added in gl1.0
    private z_TexParameteriv_adr := GetProcAddress('glTexParameteriv');
    private z_TexParameteriv_1 := GetProcOrNil&<procedure(target: TextureTarget; pname: TextureParameterName; &params: IntPtr)>(z_TexParameteriv_adr);
    private z_TexParameteriv_2 := GetProcOrNil&<procedure(target: TextureTarget; pname: TextureParameterName; var &params: Int32)>(z_TexParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteriv(target: TextureTarget; pname: TextureParameterName; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_TexParameteriv_2(target, pname, &params[0]) else
        z_TexParameteriv_2(target, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteriv(target: TextureTarget; pname: TextureParameterName; var &params: Int32) :=
    z_TexParameteriv_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteriv(target: TextureTarget; pname: TextureParameterName; &params: IntPtr) :=
    z_TexParameteriv_1(target, pname, &params);
    
    // added in gl4.2
    private z_TexStorage1D_adr := GetProcAddress('glTexStorage1D');
    private z_TexStorage1D_1 := GetProcOrNil&<procedure(target: TextureTarget; levels: Int32; internalformat: SizedInternalFormat; width: Int32)>(z_TexStorage1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorage1D(target: TextureTarget; levels: Int32; internalformat: SizedInternalFormat; width: Int32) :=
    z_TexStorage1D_1(target, levels, internalformat, width);
    
    // added in gl4.2
    private z_TexStorage2D_adr := GetProcAddress('glTexStorage2D');
    private z_TexStorage2D_1 := GetProcOrNil&<procedure(target: TextureTarget; levels: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32)>(z_TexStorage2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorage2D(target: TextureTarget; levels: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32) :=
    z_TexStorage2D_1(target, levels, internalformat, width, height);
    
    // added in gl4.3
    private z_TexStorage2DMultisample_adr := GetProcAddress('glTexStorage2DMultisample');
    private z_TexStorage2DMultisample_1 := GetProcOrNil&<procedure(target: TextureTarget; samples: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32; fixedsamplelocations: boolean)>(z_TexStorage2DMultisample_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorage2DMultisample(target: TextureTarget; samples: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32; fixedsamplelocations: boolean) :=
    z_TexStorage2DMultisample_1(target, samples, internalformat, width, height, fixedsamplelocations);
    
    // added in gl4.2
    private z_TexStorage3D_adr := GetProcAddress('glTexStorage3D');
    private z_TexStorage3D_1 := GetProcOrNil&<procedure(target: TextureTarget; levels: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32; depth: Int32)>(z_TexStorage3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorage3D(target: TextureTarget; levels: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32; depth: Int32) :=
    z_TexStorage3D_1(target, levels, internalformat, width, height, depth);
    
    // added in gl4.3
    private z_TexStorage3DMultisample_adr := GetProcAddress('glTexStorage3DMultisample');
    private z_TexStorage3DMultisample_1 := GetProcOrNil&<procedure(target: TextureTarget; samples: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: boolean)>(z_TexStorage3DMultisample_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorage3DMultisample(target: TextureTarget; samples: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: boolean) :=
    z_TexStorage3DMultisample_1(target, samples, internalformat, width, height, depth, fixedsamplelocations);
    
    // added in gl1.1
    private z_TexSubImage1D_adr := GetProcAddress('glTexSubImage1D');
    private z_TexSubImage1D_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; xoffset: Int32; width: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr)>(z_TexSubImage1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexSubImage1D(target: TextureTarget; level: Int32; xoffset: Int32; width: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr) :=
    z_TexSubImage1D_1(target, level, xoffset, width, format, &type, pixels);
    
    // added in gl1.1
    private z_TexSubImage2D_adr := GetProcAddress('glTexSubImage2D');
    private z_TexSubImage2D_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr)>(z_TexSubImage2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexSubImage2D(target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr) :=
    z_TexSubImage2D_1(target, level, xoffset, yoffset, width, height, format, &type, pixels);
    
    // added in gl1.2
    private z_TexSubImage3D_adr := GetProcAddress('glTexSubImage3D');
    private z_TexSubImage3D_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr)>(z_TexSubImage3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexSubImage3D(target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr) :=
    z_TexSubImage3D_1(target, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, pixels);
    
    // added in gl4.5
    private z_TextureBarrier_adr := GetProcAddress('glTextureBarrier');
    private z_TextureBarrier_1 := GetProcOrNil&<procedure>(z_TextureBarrier_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureBarrier :=
    z_TextureBarrier_1();
    
    // added in gl4.5
    private z_TextureBuffer_adr := GetProcAddress('glTextureBuffer');
    private z_TextureBuffer_1 := GetProcOrNil&<procedure(texture: gl_texture; internalformat: SizedInternalFormat; buffer: gl_buffer)>(z_TextureBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureBuffer(texture: gl_texture; internalformat: SizedInternalFormat; buffer: gl_buffer) :=
    z_TextureBuffer_1(texture, internalformat, buffer);
    
    // added in gl4.5
    private z_TextureBufferRange_adr := GetProcAddress('glTextureBufferRange');
    private z_TextureBufferRange_1 := GetProcOrNil&<procedure(texture: gl_texture; internalformat: SizedInternalFormat; buffer: gl_buffer; offset: IntPtr; size: UIntPtr)>(z_TextureBufferRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureBufferRange(texture: gl_texture; internalformat: SizedInternalFormat; buffer: gl_buffer; offset: IntPtr; size: UIntPtr) :=
    z_TextureBufferRange_1(texture, internalformat, buffer, offset, size);
    
    // added in gl4.5
    private z_TextureParameterf_adr := GetProcAddress('glTextureParameterf');
    private z_TextureParameterf_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; param: single)>(z_TextureParameterf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterf(texture: gl_texture; pname: TextureParameterName; param: single) :=
    z_TextureParameterf_1(texture, pname, param);
    
    // added in gl4.5
    private z_TextureParameterfv_adr := GetProcAddress('glTextureParameterfv');
    private z_TextureParameterfv_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; param: IntPtr)>(z_TextureParameterfv_adr);
    private z_TextureParameterfv_2 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; var param: single)>(z_TextureParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterfv(texture: gl_texture; pname: TextureParameterName; param: array of single);
    type Psingle=^single;
    begin
      if (param<>nil) and (param.Length<>0) then
        z_TextureParameterfv_2(texture, pname, param[0]) else
        z_TextureParameterfv_2(texture, pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterfv(texture: gl_texture; pname: TextureParameterName; var param: single) :=
    z_TextureParameterfv_2(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterfv(texture: gl_texture; pname: TextureParameterName; param: IntPtr) :=
    z_TextureParameterfv_1(texture, pname, param);
    
    // added in gl4.5
    private z_TextureParameteri_adr := GetProcAddress('glTextureParameteri');
    private z_TextureParameteri_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; param: Int32)>(z_TextureParameteri_adr);
    private z_TextureParameteri_2 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; param: TextureWrapMode)>(z_TextureParameteri_adr);
    private z_TextureParameteri_3 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; param: TextureSwizzle)>(z_TextureParameteri_adr);
    private z_TextureParameteri_4 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; param: TextureMinFilter)>(z_TextureParameteri_adr);
    private z_TextureParameteri_5 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; param: TextureMagFilter)>(z_TextureParameteri_adr);
    private z_TextureParameteri_6 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; param: TextureCompareMode)>(z_TextureParameteri_adr);
    private z_TextureParameteri_7 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; param: MapTextureFormat)>(z_TextureParameteri_adr);
    private z_TextureParameteri_8 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; param: FoveationConfigBit)>(z_TextureParameteri_adr);
    private z_TextureParameteri_9 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; param: DepthStencilTextureMode)>(z_TextureParameteri_adr);
    private z_TextureParameteri_10 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; param: ConvolutionBorderMode)>(z_TextureParameteri_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: TextureParameterName; param: ConvolutionBorderMode) :=
    z_TextureParameteri_10(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: TextureParameterName; param: DepthStencilTextureMode) :=
    z_TextureParameteri_9(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: TextureParameterName; param: FoveationConfigBit) :=
    z_TextureParameteri_8(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: TextureParameterName; param: MapTextureFormat) :=
    z_TextureParameteri_7(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: TextureParameterName; param: TextureCompareMode) :=
    z_TextureParameteri_6(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: TextureParameterName; param: TextureMagFilter) :=
    z_TextureParameteri_5(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: TextureParameterName; param: TextureMinFilter) :=
    z_TextureParameteri_4(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: TextureParameterName; param: TextureSwizzle) :=
    z_TextureParameteri_3(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: TextureParameterName; param: TextureWrapMode) :=
    z_TextureParameteri_2(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: TextureParameterName; param: Int32) :=
    z_TextureParameteri_1(texture, pname, param);
    
    // added in gl4.5
    private z_TextureParameterIiv_adr := GetProcAddress('glTextureParameterIiv');
    private z_TextureParameterIiv_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; &params: IntPtr)>(z_TextureParameterIiv_adr);
    private z_TextureParameterIiv_2 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; var &params: Int32)>(z_TextureParameterIiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIiv(texture: gl_texture; pname: TextureParameterName; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_TextureParameterIiv_2(texture, pname, &params[0]) else
        z_TextureParameterIiv_2(texture, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIiv(texture: gl_texture; pname: TextureParameterName; var &params: Int32) :=
    z_TextureParameterIiv_2(texture, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIiv(texture: gl_texture; pname: TextureParameterName; &params: IntPtr) :=
    z_TextureParameterIiv_1(texture, pname, &params);
    
    // added in gl4.5
    private z_TextureParameterIuiv_adr := GetProcAddress('glTextureParameterIuiv');
    private z_TextureParameterIuiv_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; &params: IntPtr)>(z_TextureParameterIuiv_adr);
    private z_TextureParameterIuiv_2 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; var &params: UInt32)>(z_TextureParameterIuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIuiv(texture: gl_texture; pname: TextureParameterName; &params: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_TextureParameterIuiv_2(texture, pname, &params[0]) else
        z_TextureParameterIuiv_2(texture, pname, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIuiv(texture: gl_texture; pname: TextureParameterName; var &params: UInt32) :=
    z_TextureParameterIuiv_2(texture, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIuiv(texture: gl_texture; pname: TextureParameterName; &params: IntPtr) :=
    z_TextureParameterIuiv_1(texture, pname, &params);
    
    // added in gl4.5
    private z_TextureParameteriv_adr := GetProcAddress('glTextureParameteriv');
    private z_TextureParameteriv_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; param: IntPtr)>(z_TextureParameteriv_adr);
    private z_TextureParameteriv_2 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; var param: Int32)>(z_TextureParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriv(texture: gl_texture; pname: TextureParameterName; param: array of Int32);
    type PInt32=^Int32;
    begin
      if (param<>nil) and (param.Length<>0) then
        z_TextureParameteriv_2(texture, pname, param[0]) else
        z_TextureParameteriv_2(texture, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriv(texture: gl_texture; pname: TextureParameterName; var param: Int32) :=
    z_TextureParameteriv_2(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriv(texture: gl_texture; pname: TextureParameterName; param: IntPtr) :=
    z_TextureParameteriv_1(texture, pname, param);
    
    // added in gl4.5
    private z_TextureStorage1D_adr := GetProcAddress('glTextureStorage1D');
    private z_TextureStorage1D_1 := GetProcOrNil&<procedure(texture: gl_texture; levels: Int32; internalformat: SizedInternalFormat; width: Int32)>(z_TextureStorage1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage1D(texture: gl_texture; levels: Int32; internalformat: SizedInternalFormat; width: Int32) :=
    z_TextureStorage1D_1(texture, levels, internalformat, width);
    
    // added in gl4.5
    private z_TextureStorage2D_adr := GetProcAddress('glTextureStorage2D');
    private z_TextureStorage2D_1 := GetProcOrNil&<procedure(texture: gl_texture; levels: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32)>(z_TextureStorage2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage2D(texture: gl_texture; levels: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32) :=
    z_TextureStorage2D_1(texture, levels, internalformat, width, height);
    
    // added in gl4.5
    private z_TextureStorage2DMultisample_adr := GetProcAddress('glTextureStorage2DMultisample');
    private z_TextureStorage2DMultisample_1 := GetProcOrNil&<procedure(texture: gl_texture; samples: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32; fixedsamplelocations: boolean)>(z_TextureStorage2DMultisample_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage2DMultisample(texture: gl_texture; samples: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32; fixedsamplelocations: boolean) :=
    z_TextureStorage2DMultisample_1(texture, samples, internalformat, width, height, fixedsamplelocations);
    
    // added in gl4.5
    private z_TextureStorage3D_adr := GetProcAddress('glTextureStorage3D');
    private z_TextureStorage3D_1 := GetProcOrNil&<procedure(texture: gl_texture; levels: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32; depth: Int32)>(z_TextureStorage3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage3D(texture: gl_texture; levels: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32; depth: Int32) :=
    z_TextureStorage3D_1(texture, levels, internalformat, width, height, depth);
    
    // added in gl4.5
    private z_TextureStorage3DMultisample_adr := GetProcAddress('glTextureStorage3DMultisample');
    private z_TextureStorage3DMultisample_1 := GetProcOrNil&<procedure(texture: gl_texture; samples: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: boolean)>(z_TextureStorage3DMultisample_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage3DMultisample(texture: gl_texture; samples: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: boolean) :=
    z_TextureStorage3DMultisample_1(texture, samples, internalformat, width, height, depth, fixedsamplelocations);
    
    // added in gl4.5
    private z_TextureSubImage1D_adr := GetProcAddress('glTextureSubImage1D');
    private z_TextureSubImage1D_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; width: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr)>(z_TextureSubImage1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureSubImage1D(texture: gl_texture; level: Int32; xoffset: Int32; width: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr) :=
    z_TextureSubImage1D_1(texture, level, xoffset, width, format, &type, pixels);
    
    // added in gl4.5
    private z_TextureSubImage2D_adr := GetProcAddress('glTextureSubImage2D');
    private z_TextureSubImage2D_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr)>(z_TextureSubImage2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureSubImage2D(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr) :=
    z_TextureSubImage2D_1(texture, level, xoffset, yoffset, width, height, format, &type, pixels);
    
    // added in gl4.5
    private z_TextureSubImage3D_adr := GetProcAddress('glTextureSubImage3D');
    private z_TextureSubImage3D_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr)>(z_TextureSubImage3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureSubImage3D(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr) :=
    z_TextureSubImage3D_1(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, pixels);
    
    // added in gl4.3
    private z_TextureView_adr := GetProcAddress('glTextureView');
    private z_TextureView_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; origtexture: gl_texture; internalformat: SizedInternalFormat; minlevel: UInt32; numlevels: UInt32; minlayer: UInt32; numlayers: UInt32)>(z_TextureView_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureView(texture: gl_texture; target: TextureTarget; origtexture: gl_texture; internalformat: SizedInternalFormat; minlevel: UInt32; numlevels: UInt32; minlayer: UInt32; numlayers: UInt32) :=
    z_TextureView_1(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
    
    // added in gl4.5
    private z_TransformFeedbackBufferBase_adr := GetProcAddress('glTransformFeedbackBufferBase');
    private z_TransformFeedbackBufferBase_1 := GetProcOrNil&<procedure(xfb: gl_transform_feedback; index: UInt32; buffer: gl_buffer)>(z_TransformFeedbackBufferBase_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackBufferBase(xfb: gl_transform_feedback; index: UInt32; buffer: gl_buffer) :=
    z_TransformFeedbackBufferBase_1(xfb, index, buffer);
    
    // added in gl4.5
    private z_TransformFeedbackBufferRange_adr := GetProcAddress('glTransformFeedbackBufferRange');
    private z_TransformFeedbackBufferRange_1 := GetProcOrNil&<procedure(xfb: gl_transform_feedback; index: UInt32; buffer: gl_buffer; offset: IntPtr; size: UIntPtr)>(z_TransformFeedbackBufferRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackBufferRange(xfb: gl_transform_feedback; index: UInt32; buffer: gl_buffer; offset: IntPtr; size: UIntPtr) :=
    z_TransformFeedbackBufferRange_1(xfb, index, buffer, offset, size);
    
    // added in gl3.0
    private z_TransformFeedbackVaryings_adr := GetProcAddress('glTransformFeedbackVaryings');
    private z_TransformFeedbackVaryings_1 := GetProcOrNil&<procedure(&program: gl_program; count: Int32; varyings: pointer; bufferMode: TransformFeedbackBufferMode)>(z_TransformFeedbackVaryings_adr);
    private z_TransformFeedbackVaryings_2 := GetProcOrNil&<procedure(&program: gl_program; count: Int32; var varyings: IntPtr; bufferMode: TransformFeedbackBufferMode)>(z_TransformFeedbackVaryings_adr);
    private [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure temp_TransformFeedbackVaryings_1(&program: gl_program; count: Int32; varyings: array of IntPtr; bufferMode: TransformFeedbackBufferMode);
    type PIntPtr=^IntPtr;
    begin
      if (varyings<>nil) and (varyings.Length<>0) then
        z_TransformFeedbackVaryings_2(&program, count, varyings[0], bufferMode) else
        z_TransformFeedbackVaryings_2(&program, count, PIntPtr(nil)^, bufferMode);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackVaryings(&program: gl_program; count: Int32; varyings: array of string; bufferMode: TransformFeedbackBufferMode);
    begin
      var varyings_str_ptrs: array of IntPtr;
      try
        varyings_str_ptrs := varyings?.ConvertAll(arr_el1->
          Marshal.StringToHGlobalAnsi(arr_el1)
        );
        temp_TransformFeedbackVaryings_1(&program, count, varyings_str_ptrs, bufferMode);
      finally
        if varyings_str_ptrs<>nil then foreach var arr_el1 in varyings_str_ptrs do
          Marshal.FreeHGlobal(arr_el1);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackVaryings(&program: gl_program; count: Int32; var varyings: IntPtr; bufferMode: TransformFeedbackBufferMode) :=
    z_TransformFeedbackVaryings_2(&program, count, varyings, bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackVaryings(&program: gl_program; count: Int32; varyings: pointer; bufferMode: TransformFeedbackBufferMode) :=
    z_TransformFeedbackVaryings_1(&program, count, varyings, bufferMode);
    
    // added in gl4.0
    private z_Uniform1d_adr := GetProcAddress('glUniform1d');
    private z_Uniform1d_1 := GetProcOrNil&<procedure(location: Int32; x: real)>(z_Uniform1d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1d(location: Int32; x: real) :=
    z_Uniform1d_1(location, x);
    
    // added in gl4.0
    private z_Uniform1dv_adr := GetProcAddress('glUniform1dv');
    private z_Uniform1dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform1dv_adr);
    private z_Uniform1dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: real)>(z_Uniform1dv_adr);
    private z_Uniform1dv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec1d)>(z_Uniform1dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1dv(location: Int32; count: Int32; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform1dv_2(location, count, value[0]) else
        z_Uniform1dv_2(location, count, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1dv(location: Int32; count: Int32; var value: Vec1d) :=
    z_Uniform1dv_3(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1dv(location: Int32; count: Int32; var value: real) :=
    z_Uniform1dv_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1dv(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform1dv_1(location, count, value);
    
    // added in gl2.0
    private z_Uniform1f_adr := GetProcAddress('glUniform1f');
    private z_Uniform1f_1 := GetProcOrNil&<procedure(location: Int32; v0: single)>(z_Uniform1f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1f(location: Int32; v0: single) :=
    z_Uniform1f_1(location, v0);
    
    // added in gl2.0
    private z_Uniform1fv_adr := GetProcAddress('glUniform1fv');
    private z_Uniform1fv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform1fv_adr);
    private z_Uniform1fv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: single)>(z_Uniform1fv_adr);
    private z_Uniform1fv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec1f)>(z_Uniform1fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1fv(location: Int32; count: Int32; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform1fv_2(location, count, value[0]) else
        z_Uniform1fv_2(location, count, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1fv(location: Int32; count: Int32; var value: Vec1f) :=
    z_Uniform1fv_3(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1fv(location: Int32; count: Int32; var value: single) :=
    z_Uniform1fv_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1fv(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform1fv_1(location, count, value);
    
    // added in gl2.0
    private z_Uniform1i_adr := GetProcAddress('glUniform1i');
    private z_Uniform1i_1 := GetProcOrNil&<procedure(location: Int32; v0: Int32)>(z_Uniform1i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i(location: Int32; v0: Int32) :=
    z_Uniform1i_1(location, v0);
    
    // added in gl2.0
    private z_Uniform1iv_adr := GetProcAddress('glUniform1iv');
    private z_Uniform1iv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform1iv_adr);
    private z_Uniform1iv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int32)>(z_Uniform1iv_adr);
    private z_Uniform1iv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec1i)>(z_Uniform1iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1iv(location: Int32; count: Int32; value: array of Int32);
    type PInt32=^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform1iv_2(location, count, value[0]) else
        z_Uniform1iv_2(location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1iv(location: Int32; count: Int32; var value: Vec1i) :=
    z_Uniform1iv_3(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1iv(location: Int32; count: Int32; var value: Int32) :=
    z_Uniform1iv_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1iv(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform1iv_1(location, count, value);
    
    // added in gl3.0
    private z_Uniform1ui_adr := GetProcAddress('glUniform1ui');
    private z_Uniform1ui_1 := GetProcOrNil&<procedure(location: Int32; v0: UInt32)>(z_Uniform1ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui(location: Int32; v0: UInt32) :=
    z_Uniform1ui_1(location, v0);
    
    // added in gl3.0
    private z_Uniform1uiv_adr := GetProcAddress('glUniform1uiv');
    private z_Uniform1uiv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform1uiv_adr);
    private z_Uniform1uiv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt32)>(z_Uniform1uiv_adr);
    private z_Uniform1uiv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec1ui)>(z_Uniform1uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1uiv(location: Int32; count: Int32; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform1uiv_2(location, count, value[0]) else
        z_Uniform1uiv_2(location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1uiv(location: Int32; count: Int32; var value: Vec1ui) :=
    z_Uniform1uiv_3(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1uiv(location: Int32; count: Int32; var value: UInt32) :=
    z_Uniform1uiv_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1uiv(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform1uiv_1(location, count, value);
    
    // added in gl4.0
    private z_Uniform2d_adr := GetProcAddress('glUniform2d');
    private z_Uniform2d_1 := GetProcOrNil&<procedure(location: Int32; x: real; y: real)>(z_Uniform2d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2d(location: Int32; x: real; y: real) :=
    z_Uniform2d_1(location, x, y);
    
    // added in gl4.0
    private z_Uniform2dv_adr := GetProcAddress('glUniform2dv');
    private z_Uniform2dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform2dv_adr);
    private z_Uniform2dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: real)>(z_Uniform2dv_adr);
    private z_Uniform2dv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec2d)>(z_Uniform2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2dv(location: Int32; count: Int32; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform2dv_2(location, count, value[0]) else
        z_Uniform2dv_2(location, count, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2dv(location: Int32; count: Int32; var value: Vec2d) :=
    z_Uniform2dv_3(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2dv(location: Int32; count: Int32; var value: real) :=
    z_Uniform2dv_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2dv(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform2dv_1(location, count, value);
    
    // added in gl2.0
    private z_Uniform2f_adr := GetProcAddress('glUniform2f');
    private z_Uniform2f_1 := GetProcOrNil&<procedure(location: Int32; v0: single; v1: single)>(z_Uniform2f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2f(location: Int32; v0: single; v1: single) :=
    z_Uniform2f_1(location, v0, v1);
    
    // added in gl2.0
    private z_Uniform2fv_adr := GetProcAddress('glUniform2fv');
    private z_Uniform2fv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform2fv_adr);
    private z_Uniform2fv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: single)>(z_Uniform2fv_adr);
    private z_Uniform2fv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec2f)>(z_Uniform2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2fv(location: Int32; count: Int32; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform2fv_2(location, count, value[0]) else
        z_Uniform2fv_2(location, count, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2fv(location: Int32; count: Int32; var value: Vec2f) :=
    z_Uniform2fv_3(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2fv(location: Int32; count: Int32; var value: single) :=
    z_Uniform2fv_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2fv(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform2fv_1(location, count, value);
    
    // added in gl2.0
    private z_Uniform2i_adr := GetProcAddress('glUniform2i');
    private z_Uniform2i_1 := GetProcOrNil&<procedure(location: Int32; v0: Int32; v1: Int32)>(z_Uniform2i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i(location: Int32; v0: Int32; v1: Int32) :=
    z_Uniform2i_1(location, v0, v1);
    
    // added in gl2.0
    private z_Uniform2iv_adr := GetProcAddress('glUniform2iv');
    private z_Uniform2iv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform2iv_adr);
    private z_Uniform2iv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int32)>(z_Uniform2iv_adr);
    private z_Uniform2iv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec2i)>(z_Uniform2iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2iv(location: Int32; count: Int32; value: array of Int32);
    type PInt32=^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform2iv_2(location, count, value[0]) else
        z_Uniform2iv_2(location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2iv(location: Int32; count: Int32; var value: Vec2i) :=
    z_Uniform2iv_3(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2iv(location: Int32; count: Int32; var value: Int32) :=
    z_Uniform2iv_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2iv(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform2iv_1(location, count, value);
    
    // added in gl3.0
    private z_Uniform2ui_adr := GetProcAddress('glUniform2ui');
    private z_Uniform2ui_1 := GetProcOrNil&<procedure(location: Int32; v0: UInt32; v1: UInt32)>(z_Uniform2ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui(location: Int32; v0: UInt32; v1: UInt32) :=
    z_Uniform2ui_1(location, v0, v1);
    
    // added in gl3.0
    private z_Uniform2uiv_adr := GetProcAddress('glUniform2uiv');
    private z_Uniform2uiv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform2uiv_adr);
    private z_Uniform2uiv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt32)>(z_Uniform2uiv_adr);
    private z_Uniform2uiv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec2ui)>(z_Uniform2uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2uiv(location: Int32; count: Int32; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform2uiv_2(location, count, value[0]) else
        z_Uniform2uiv_2(location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2uiv(location: Int32; count: Int32; var value: Vec2ui) :=
    z_Uniform2uiv_3(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2uiv(location: Int32; count: Int32; var value: UInt32) :=
    z_Uniform2uiv_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2uiv(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform2uiv_1(location, count, value);
    
    // added in gl4.0
    private z_Uniform3d_adr := GetProcAddress('glUniform3d');
    private z_Uniform3d_1 := GetProcOrNil&<procedure(location: Int32; x: real; y: real; z: real)>(z_Uniform3d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3d(location: Int32; x: real; y: real; z: real) :=
    z_Uniform3d_1(location, x, y, z);
    
    // added in gl4.0
    private z_Uniform3dv_adr := GetProcAddress('glUniform3dv');
    private z_Uniform3dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform3dv_adr);
    private z_Uniform3dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: real)>(z_Uniform3dv_adr);
    private z_Uniform3dv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec3d)>(z_Uniform3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3dv(location: Int32; count: Int32; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform3dv_2(location, count, value[0]) else
        z_Uniform3dv_2(location, count, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3dv(location: Int32; count: Int32; var value: Vec3d) :=
    z_Uniform3dv_3(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3dv(location: Int32; count: Int32; var value: real) :=
    z_Uniform3dv_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3dv(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform3dv_1(location, count, value);
    
    // added in gl2.0
    private z_Uniform3f_adr := GetProcAddress('glUniform3f');
    private z_Uniform3f_1 := GetProcOrNil&<procedure(location: Int32; v0: single; v1: single; v2: single)>(z_Uniform3f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3f(location: Int32; v0: single; v1: single; v2: single) :=
    z_Uniform3f_1(location, v0, v1, v2);
    
    // added in gl2.0
    private z_Uniform3fv_adr := GetProcAddress('glUniform3fv');
    private z_Uniform3fv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform3fv_adr);
    private z_Uniform3fv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: single)>(z_Uniform3fv_adr);
    private z_Uniform3fv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec3f)>(z_Uniform3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3fv(location: Int32; count: Int32; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform3fv_2(location, count, value[0]) else
        z_Uniform3fv_2(location, count, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3fv(location: Int32; count: Int32; var value: Vec3f) :=
    z_Uniform3fv_3(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3fv(location: Int32; count: Int32; var value: single) :=
    z_Uniform3fv_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3fv(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform3fv_1(location, count, value);
    
    // added in gl2.0
    private z_Uniform3i_adr := GetProcAddress('glUniform3i');
    private z_Uniform3i_1 := GetProcOrNil&<procedure(location: Int32; v0: Int32; v1: Int32; v2: Int32)>(z_Uniform3i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i(location: Int32; v0: Int32; v1: Int32; v2: Int32) :=
    z_Uniform3i_1(location, v0, v1, v2);
    
    // added in gl2.0
    private z_Uniform3iv_adr := GetProcAddress('glUniform3iv');
    private z_Uniform3iv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform3iv_adr);
    private z_Uniform3iv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int32)>(z_Uniform3iv_adr);
    private z_Uniform3iv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec3i)>(z_Uniform3iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3iv(location: Int32; count: Int32; value: array of Int32);
    type PInt32=^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform3iv_2(location, count, value[0]) else
        z_Uniform3iv_2(location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3iv(location: Int32; count: Int32; var value: Vec3i) :=
    z_Uniform3iv_3(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3iv(location: Int32; count: Int32; var value: Int32) :=
    z_Uniform3iv_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3iv(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform3iv_1(location, count, value);
    
    // added in gl3.0
    private z_Uniform3ui_adr := GetProcAddress('glUniform3ui');
    private z_Uniform3ui_1 := GetProcOrNil&<procedure(location: Int32; v0: UInt32; v1: UInt32; v2: UInt32)>(z_Uniform3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui(location: Int32; v0: UInt32; v1: UInt32; v2: UInt32) :=
    z_Uniform3ui_1(location, v0, v1, v2);
    
    // added in gl3.0
    private z_Uniform3uiv_adr := GetProcAddress('glUniform3uiv');
    private z_Uniform3uiv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform3uiv_adr);
    private z_Uniform3uiv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt32)>(z_Uniform3uiv_adr);
    private z_Uniform3uiv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec3ui)>(z_Uniform3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3uiv(location: Int32; count: Int32; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform3uiv_2(location, count, value[0]) else
        z_Uniform3uiv_2(location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3uiv(location: Int32; count: Int32; var value: Vec3ui) :=
    z_Uniform3uiv_3(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3uiv(location: Int32; count: Int32; var value: UInt32) :=
    z_Uniform3uiv_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3uiv(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform3uiv_1(location, count, value);
    
    // added in gl4.0
    private z_Uniform4d_adr := GetProcAddress('glUniform4d');
    private z_Uniform4d_1 := GetProcOrNil&<procedure(location: Int32; x: real; y: real; z: real; w: real)>(z_Uniform4d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4d(location: Int32; x: real; y: real; z: real; w: real) :=
    z_Uniform4d_1(location, x, y, z, w);
    
    // added in gl4.0
    private z_Uniform4dv_adr := GetProcAddress('glUniform4dv');
    private z_Uniform4dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform4dv_adr);
    private z_Uniform4dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: real)>(z_Uniform4dv_adr);
    private z_Uniform4dv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec4d)>(z_Uniform4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4dv(location: Int32; count: Int32; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform4dv_2(location, count, value[0]) else
        z_Uniform4dv_2(location, count, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4dv(location: Int32; count: Int32; var value: Vec4d) :=
    z_Uniform4dv_3(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4dv(location: Int32; count: Int32; var value: real) :=
    z_Uniform4dv_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4dv(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform4dv_1(location, count, value);
    
    // added in gl2.0
    private z_Uniform4f_adr := GetProcAddress('glUniform4f');
    private z_Uniform4f_1 := GetProcOrNil&<procedure(location: Int32; v0: single; v1: single; v2: single; v3: single)>(z_Uniform4f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4f(location: Int32; v0: single; v1: single; v2: single; v3: single) :=
    z_Uniform4f_1(location, v0, v1, v2, v3);
    
    // added in gl2.0
    private z_Uniform4fv_adr := GetProcAddress('glUniform4fv');
    private z_Uniform4fv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform4fv_adr);
    private z_Uniform4fv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: single)>(z_Uniform4fv_adr);
    private z_Uniform4fv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec4f)>(z_Uniform4fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4fv(location: Int32; count: Int32; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform4fv_2(location, count, value[0]) else
        z_Uniform4fv_2(location, count, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4fv(location: Int32; count: Int32; var value: Vec4f) :=
    z_Uniform4fv_3(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4fv(location: Int32; count: Int32; var value: single) :=
    z_Uniform4fv_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4fv(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform4fv_1(location, count, value);
    
    // added in gl2.0
    private z_Uniform4i_adr := GetProcAddress('glUniform4i');
    private z_Uniform4i_1 := GetProcOrNil&<procedure(location: Int32; v0: Int32; v1: Int32; v2: Int32; v3: Int32)>(z_Uniform4i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i(location: Int32; v0: Int32; v1: Int32; v2: Int32; v3: Int32) :=
    z_Uniform4i_1(location, v0, v1, v2, v3);
    
    // added in gl2.0
    private z_Uniform4iv_adr := GetProcAddress('glUniform4iv');
    private z_Uniform4iv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform4iv_adr);
    private z_Uniform4iv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int32)>(z_Uniform4iv_adr);
    private z_Uniform4iv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec4i)>(z_Uniform4iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4iv(location: Int32; count: Int32; value: array of Int32);
    type PInt32=^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform4iv_2(location, count, value[0]) else
        z_Uniform4iv_2(location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4iv(location: Int32; count: Int32; var value: Vec4i) :=
    z_Uniform4iv_3(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4iv(location: Int32; count: Int32; var value: Int32) :=
    z_Uniform4iv_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4iv(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform4iv_1(location, count, value);
    
    // added in gl3.0
    private z_Uniform4ui_adr := GetProcAddress('glUniform4ui');
    private z_Uniform4ui_1 := GetProcOrNil&<procedure(location: Int32; v0: UInt32; v1: UInt32; v2: UInt32; v3: UInt32)>(z_Uniform4ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui(location: Int32; v0: UInt32; v1: UInt32; v2: UInt32; v3: UInt32) :=
    z_Uniform4ui_1(location, v0, v1, v2, v3);
    
    // added in gl3.0
    private z_Uniform4uiv_adr := GetProcAddress('glUniform4uiv');
    private z_Uniform4uiv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform4uiv_adr);
    private z_Uniform4uiv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt32)>(z_Uniform4uiv_adr);
    private z_Uniform4uiv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec4ui)>(z_Uniform4uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4uiv(location: Int32; count: Int32; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform4uiv_2(location, count, value[0]) else
        z_Uniform4uiv_2(location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4uiv(location: Int32; count: Int32; var value: Vec4ui) :=
    z_Uniform4uiv_3(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4uiv(location: Int32; count: Int32; var value: UInt32) :=
    z_Uniform4uiv_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4uiv(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform4uiv_1(location, count, value);
    
    // added in gl3.1
    private z_UniformBlockBinding_adr := GetProcAddress('glUniformBlockBinding');
    private z_UniformBlockBinding_1 := GetProcOrNil&<procedure(&program: gl_program; uniformBlockIndex: UInt32; uniformBlockBinding: UInt32)>(z_UniformBlockBinding_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformBlockBinding(&program: gl_program; uniformBlockIndex: UInt32; uniformBlockBinding: UInt32) :=
    z_UniformBlockBinding_1(&program, uniformBlockIndex, uniformBlockBinding);
    
    // added in gl4.0
    private z_UniformMatrix2dv_adr := GetProcAddress('glUniformMatrix2dv');
    private z_UniformMatrix2dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_UniformMatrix2dv_adr);
    private z_UniformMatrix2dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; var value: real)>(z_UniformMatrix2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2dv(location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_UniformMatrix2dv_2(location, count, transpose, value[0]) else
        z_UniformMatrix2dv_2(location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2dv(location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_UniformMatrix2dv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2dv(location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_UniformMatrix2dv_1(location, count, transpose, value);
    
    // added in gl2.0
    private z_UniformMatrix2fv_adr := GetProcAddress('glUniformMatrix2fv');
    private z_UniformMatrix2fv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_UniformMatrix2fv_adr);
    private z_UniformMatrix2fv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; var value: single)>(z_UniformMatrix2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2fv(location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_UniformMatrix2fv_2(location, count, transpose, value[0]) else
        z_UniformMatrix2fv_2(location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2fv(location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_UniformMatrix2fv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2fv(location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_UniformMatrix2fv_1(location, count, transpose, value);
    
    // added in gl4.0
    private z_UniformMatrix2x3dv_adr := GetProcAddress('glUniformMatrix2x3dv');
    private z_UniformMatrix2x3dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_UniformMatrix2x3dv_adr);
    private z_UniformMatrix2x3dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; var value: real)>(z_UniformMatrix2x3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x3dv(location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_UniformMatrix2x3dv_2(location, count, transpose, value[0]) else
        z_UniformMatrix2x3dv_2(location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x3dv(location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_UniformMatrix2x3dv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x3dv(location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_UniformMatrix2x3dv_1(location, count, transpose, value);
    
    // added in gl2.1
    private z_UniformMatrix2x3fv_adr := GetProcAddress('glUniformMatrix2x3fv');
    private z_UniformMatrix2x3fv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_UniformMatrix2x3fv_adr);
    private z_UniformMatrix2x3fv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; var value: single)>(z_UniformMatrix2x3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x3fv(location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_UniformMatrix2x3fv_2(location, count, transpose, value[0]) else
        z_UniformMatrix2x3fv_2(location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x3fv(location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_UniformMatrix2x3fv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x3fv(location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_UniformMatrix2x3fv_1(location, count, transpose, value);
    
    // added in gl4.0
    private z_UniformMatrix2x4dv_adr := GetProcAddress('glUniformMatrix2x4dv');
    private z_UniformMatrix2x4dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_UniformMatrix2x4dv_adr);
    private z_UniformMatrix2x4dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; var value: real)>(z_UniformMatrix2x4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x4dv(location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_UniformMatrix2x4dv_2(location, count, transpose, value[0]) else
        z_UniformMatrix2x4dv_2(location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x4dv(location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_UniformMatrix2x4dv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x4dv(location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_UniformMatrix2x4dv_1(location, count, transpose, value);
    
    // added in gl2.1
    private z_UniformMatrix2x4fv_adr := GetProcAddress('glUniformMatrix2x4fv');
    private z_UniformMatrix2x4fv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_UniformMatrix2x4fv_adr);
    private z_UniformMatrix2x4fv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; var value: single)>(z_UniformMatrix2x4fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x4fv(location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_UniformMatrix2x4fv_2(location, count, transpose, value[0]) else
        z_UniformMatrix2x4fv_2(location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x4fv(location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_UniformMatrix2x4fv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x4fv(location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_UniformMatrix2x4fv_1(location, count, transpose, value);
    
    // added in gl4.0
    private z_UniformMatrix3dv_adr := GetProcAddress('glUniformMatrix3dv');
    private z_UniformMatrix3dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_UniformMatrix3dv_adr);
    private z_UniformMatrix3dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; var value: real)>(z_UniformMatrix3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3dv(location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_UniformMatrix3dv_2(location, count, transpose, value[0]) else
        z_UniformMatrix3dv_2(location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3dv(location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_UniformMatrix3dv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3dv(location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_UniformMatrix3dv_1(location, count, transpose, value);
    
    // added in gl2.0
    private z_UniformMatrix3fv_adr := GetProcAddress('glUniformMatrix3fv');
    private z_UniformMatrix3fv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_UniformMatrix3fv_adr);
    private z_UniformMatrix3fv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; var value: single)>(z_UniformMatrix3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3fv(location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_UniformMatrix3fv_2(location, count, transpose, value[0]) else
        z_UniformMatrix3fv_2(location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3fv(location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_UniformMatrix3fv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3fv(location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_UniformMatrix3fv_1(location, count, transpose, value);
    
    // added in gl4.0
    private z_UniformMatrix3x2dv_adr := GetProcAddress('glUniformMatrix3x2dv');
    private z_UniformMatrix3x2dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_UniformMatrix3x2dv_adr);
    private z_UniformMatrix3x2dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; var value: real)>(z_UniformMatrix3x2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x2dv(location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_UniformMatrix3x2dv_2(location, count, transpose, value[0]) else
        z_UniformMatrix3x2dv_2(location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x2dv(location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_UniformMatrix3x2dv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x2dv(location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_UniformMatrix3x2dv_1(location, count, transpose, value);
    
    // added in gl2.1
    private z_UniformMatrix3x2fv_adr := GetProcAddress('glUniformMatrix3x2fv');
    private z_UniformMatrix3x2fv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_UniformMatrix3x2fv_adr);
    private z_UniformMatrix3x2fv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; var value: single)>(z_UniformMatrix3x2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x2fv(location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_UniformMatrix3x2fv_2(location, count, transpose, value[0]) else
        z_UniformMatrix3x2fv_2(location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x2fv(location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_UniformMatrix3x2fv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x2fv(location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_UniformMatrix3x2fv_1(location, count, transpose, value);
    
    // added in gl4.0
    private z_UniformMatrix3x4dv_adr := GetProcAddress('glUniformMatrix3x4dv');
    private z_UniformMatrix3x4dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_UniformMatrix3x4dv_adr);
    private z_UniformMatrix3x4dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; var value: real)>(z_UniformMatrix3x4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x4dv(location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_UniformMatrix3x4dv_2(location, count, transpose, value[0]) else
        z_UniformMatrix3x4dv_2(location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x4dv(location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_UniformMatrix3x4dv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x4dv(location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_UniformMatrix3x4dv_1(location, count, transpose, value);
    
    // added in gl2.1
    private z_UniformMatrix3x4fv_adr := GetProcAddress('glUniformMatrix3x4fv');
    private z_UniformMatrix3x4fv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_UniformMatrix3x4fv_adr);
    private z_UniformMatrix3x4fv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; var value: single)>(z_UniformMatrix3x4fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x4fv(location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_UniformMatrix3x4fv_2(location, count, transpose, value[0]) else
        z_UniformMatrix3x4fv_2(location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x4fv(location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_UniformMatrix3x4fv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x4fv(location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_UniformMatrix3x4fv_1(location, count, transpose, value);
    
    // added in gl4.0
    private z_UniformMatrix4dv_adr := GetProcAddress('glUniformMatrix4dv');
    private z_UniformMatrix4dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_UniformMatrix4dv_adr);
    private z_UniformMatrix4dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; var value: real)>(z_UniformMatrix4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4dv(location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_UniformMatrix4dv_2(location, count, transpose, value[0]) else
        z_UniformMatrix4dv_2(location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4dv(location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_UniformMatrix4dv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4dv(location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_UniformMatrix4dv_1(location, count, transpose, value);
    
    // added in gl2.0
    private z_UniformMatrix4fv_adr := GetProcAddress('glUniformMatrix4fv');
    private z_UniformMatrix4fv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_UniformMatrix4fv_adr);
    private z_UniformMatrix4fv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; var value: single)>(z_UniformMatrix4fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4fv(location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_UniformMatrix4fv_2(location, count, transpose, value[0]) else
        z_UniformMatrix4fv_2(location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4fv(location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_UniformMatrix4fv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4fv(location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_UniformMatrix4fv_1(location, count, transpose, value);
    
    // added in gl4.0
    private z_UniformMatrix4x2dv_adr := GetProcAddress('glUniformMatrix4x2dv');
    private z_UniformMatrix4x2dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_UniformMatrix4x2dv_adr);
    private z_UniformMatrix4x2dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; var value: real)>(z_UniformMatrix4x2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x2dv(location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_UniformMatrix4x2dv_2(location, count, transpose, value[0]) else
        z_UniformMatrix4x2dv_2(location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x2dv(location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_UniformMatrix4x2dv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x2dv(location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_UniformMatrix4x2dv_1(location, count, transpose, value);
    
    // added in gl2.1
    private z_UniformMatrix4x2fv_adr := GetProcAddress('glUniformMatrix4x2fv');
    private z_UniformMatrix4x2fv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_UniformMatrix4x2fv_adr);
    private z_UniformMatrix4x2fv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; var value: single)>(z_UniformMatrix4x2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x2fv(location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_UniformMatrix4x2fv_2(location, count, transpose, value[0]) else
        z_UniformMatrix4x2fv_2(location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x2fv(location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_UniformMatrix4x2fv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x2fv(location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_UniformMatrix4x2fv_1(location, count, transpose, value);
    
    // added in gl4.0
    private z_UniformMatrix4x3dv_adr := GetProcAddress('glUniformMatrix4x3dv');
    private z_UniformMatrix4x3dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_UniformMatrix4x3dv_adr);
    private z_UniformMatrix4x3dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; var value: real)>(z_UniformMatrix4x3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x3dv(location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_UniformMatrix4x3dv_2(location, count, transpose, value[0]) else
        z_UniformMatrix4x3dv_2(location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x3dv(location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_UniformMatrix4x3dv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x3dv(location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_UniformMatrix4x3dv_1(location, count, transpose, value);
    
    // added in gl2.1
    private z_UniformMatrix4x3fv_adr := GetProcAddress('glUniformMatrix4x3fv');
    private z_UniformMatrix4x3fv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_UniformMatrix4x3fv_adr);
    private z_UniformMatrix4x3fv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; var value: single)>(z_UniformMatrix4x3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x3fv(location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_UniformMatrix4x3fv_2(location, count, transpose, value[0]) else
        z_UniformMatrix4x3fv_2(location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x3fv(location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_UniformMatrix4x3fv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x3fv(location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_UniformMatrix4x3fv_1(location, count, transpose, value);
    
    // added in gl4.0
    private z_UniformSubroutinesuiv_adr := GetProcAddress('glUniformSubroutinesuiv');
    private z_UniformSubroutinesuiv_1 := GetProcOrNil&<procedure(_shadertype: ShaderType; count: Int32; indices: IntPtr)>(z_UniformSubroutinesuiv_adr);
    private z_UniformSubroutinesuiv_2 := GetProcOrNil&<procedure(_shadertype: ShaderType; count: Int32; var indices: UInt32)>(z_UniformSubroutinesuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformSubroutinesuiv(_shadertype: ShaderType; count: Int32; indices: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (indices<>nil) and (indices.Length<>0) then
        z_UniformSubroutinesuiv_2(_shadertype, count, indices[0]) else
        z_UniformSubroutinesuiv_2(_shadertype, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformSubroutinesuiv(_shadertype: ShaderType; count: Int32; var indices: UInt32) :=
    z_UniformSubroutinesuiv_2(_shadertype, count, indices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformSubroutinesuiv(_shadertype: ShaderType; count: Int32; indices: IntPtr) :=
    z_UniformSubroutinesuiv_1(_shadertype, count, indices);
    
    // added in gl1.5
    private z_UnmapBuffer_adr := GetProcAddress('glUnmapBuffer');
    private z_UnmapBuffer_1 := GetProcOrNil&<function(target: BufferTarget): boolean>(z_UnmapBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function UnmapBuffer(target: BufferTarget): boolean :=
    z_UnmapBuffer_1(target);
    
    // added in gl4.5
    private z_UnmapNamedBuffer_adr := GetProcAddress('glUnmapNamedBuffer');
    private z_UnmapNamedBuffer_1 := GetProcOrNil&<function(buffer: gl_buffer): boolean>(z_UnmapNamedBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function UnmapNamedBuffer(buffer: gl_buffer): boolean :=
    z_UnmapNamedBuffer_1(buffer);
    
    // added in gl2.0
    private z_UseProgram_adr := GetProcAddress('glUseProgram');
    private z_UseProgram_1 := GetProcOrNil&<procedure(&program: gl_program)>(z_UseProgram_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseProgram(&program: gl_program) :=
    z_UseProgram_1(&program);
    
    // added in gl4.1
    private z_UseProgramStages_adr := GetProcAddress('glUseProgramStages');
    private z_UseProgramStages_1 := GetProcOrNil&<procedure(pipeline: gl_program_pipeline; stages: UseProgramStageMask; &program: gl_program)>(z_UseProgramStages_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseProgramStages(pipeline: gl_program_pipeline; stages: UseProgramStageMask; &program: gl_program) :=
    z_UseProgramStages_1(pipeline, stages, &program);
    
    // added in gl2.0
    private z_ValidateProgram_adr := GetProcAddress('glValidateProgram');
    private z_ValidateProgram_1 := GetProcOrNil&<procedure(&program: gl_program)>(z_ValidateProgram_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ValidateProgram(&program: gl_program) :=
    z_ValidateProgram_1(&program);
    
    // added in gl4.1
    private z_ValidateProgramPipeline_adr := GetProcAddress('glValidateProgramPipeline');
    private z_ValidateProgramPipeline_1 := GetProcOrNil&<procedure(pipeline: gl_program_pipeline)>(z_ValidateProgramPipeline_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ValidateProgramPipeline(pipeline: gl_program_pipeline) :=
    z_ValidateProgramPipeline_1(pipeline);
    
    // added in gl4.5
    private z_VertexArrayAttribBinding_adr := GetProcAddress('glVertexArrayAttribBinding');
    private z_VertexArrayAttribBinding_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; attribindex: UInt32; bindingindex: UInt32)>(z_VertexArrayAttribBinding_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayAttribBinding(vaobj: gl_vertex_array; attribindex: UInt32; bindingindex: UInt32) :=
    z_VertexArrayAttribBinding_1(vaobj, attribindex, bindingindex);
    
    // added in gl4.5
    private z_VertexArrayAttribFormat_adr := GetProcAddress('glVertexArrayAttribFormat');
    private z_VertexArrayAttribFormat_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; attribindex: UInt32; size: Int32; &type: VertexAttribType; normalized: boolean; relativeoffset: UInt32)>(z_VertexArrayAttribFormat_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayAttribFormat(vaobj: gl_vertex_array; attribindex: UInt32; size: Int32; &type: VertexAttribType; normalized: boolean; relativeoffset: UInt32) :=
    z_VertexArrayAttribFormat_1(vaobj, attribindex, size, &type, normalized, relativeoffset);
    
    // added in gl4.5
    private z_VertexArrayAttribIFormat_adr := GetProcAddress('glVertexArrayAttribIFormat');
    private z_VertexArrayAttribIFormat_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; attribindex: UInt32; size: Int32; &type: VertexAttribIType; relativeoffset: UInt32)>(z_VertexArrayAttribIFormat_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayAttribIFormat(vaobj: gl_vertex_array; attribindex: UInt32; size: Int32; &type: VertexAttribIType; relativeoffset: UInt32) :=
    z_VertexArrayAttribIFormat_1(vaobj, attribindex, size, &type, relativeoffset);
    
    // added in gl4.5
    private z_VertexArrayAttribLFormat_adr := GetProcAddress('glVertexArrayAttribLFormat');
    private z_VertexArrayAttribLFormat_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; attribindex: UInt32; size: Int32; &type: VertexAttribLType; relativeoffset: UInt32)>(z_VertexArrayAttribLFormat_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayAttribLFormat(vaobj: gl_vertex_array; attribindex: UInt32; size: Int32; &type: VertexAttribLType; relativeoffset: UInt32) :=
    z_VertexArrayAttribLFormat_1(vaobj, attribindex, size, &type, relativeoffset);
    
    // added in gl4.5
    private z_VertexArrayBindingDivisor_adr := GetProcAddress('glVertexArrayBindingDivisor');
    private z_VertexArrayBindingDivisor_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; bindingindex: UInt32; divisor: UInt32)>(z_VertexArrayBindingDivisor_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayBindingDivisor(vaobj: gl_vertex_array; bindingindex: UInt32; divisor: UInt32) :=
    z_VertexArrayBindingDivisor_1(vaobj, bindingindex, divisor);
    
    // added in gl4.5
    private z_VertexArrayElementBuffer_adr := GetProcAddress('glVertexArrayElementBuffer');
    private z_VertexArrayElementBuffer_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; buffer: gl_buffer)>(z_VertexArrayElementBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayElementBuffer(vaobj: gl_vertex_array; buffer: gl_buffer) :=
    z_VertexArrayElementBuffer_1(vaobj, buffer);
    
    // added in gl4.5
    private z_VertexArrayVertexBuffer_adr := GetProcAddress('glVertexArrayVertexBuffer');
    private z_VertexArrayVertexBuffer_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; bindingindex: UInt32; buffer: gl_buffer; offset: IntPtr; stride: Int32)>(z_VertexArrayVertexBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffer(vaobj: gl_vertex_array; bindingindex: UInt32; buffer: gl_buffer; offset: IntPtr; stride: Int32) :=
    z_VertexArrayVertexBuffer_1(vaobj, bindingindex, buffer, offset, stride);
    
    // added in gl4.5
    private z_VertexArrayVertexBuffers_adr := GetProcAddress('glVertexArrayVertexBuffers');
    private z_VertexArrayVertexBuffers_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; strides: IntPtr)>(z_VertexArrayVertexBuffers_adr);
    private z_VertexArrayVertexBuffers_2 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; var strides: Int32)>(z_VertexArrayVertexBuffers_adr);
    private z_VertexArrayVertexBuffers_3 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; strides: IntPtr)>(z_VertexArrayVertexBuffers_adr);
    private z_VertexArrayVertexBuffers_4 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; var strides: Int32)>(z_VertexArrayVertexBuffers_adr);
    private z_VertexArrayVertexBuffers_5 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; strides: IntPtr)>(z_VertexArrayVertexBuffers_adr);
    private z_VertexArrayVertexBuffers_6 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; var strides: Int32)>(z_VertexArrayVertexBuffers_adr);
    private z_VertexArrayVertexBuffers_7 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; strides: IntPtr)>(z_VertexArrayVertexBuffers_adr);
    private z_VertexArrayVertexBuffers_8 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; var strides: Int32)>(z_VertexArrayVertexBuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: gl_vertex_array; first: UInt32; count: Int32; buffers: array of gl_buffer; offsets: array of IntPtr; strides: array of Int32);
    type Pgl_buffer=^gl_buffer;
    type PIntPtr=^IntPtr;
    type PInt32=^Int32;
    begin
      if (strides<>nil) and (strides.Length<>0) then
        if (offsets<>nil) and (offsets.Length<>0) then
          if (buffers<>nil) and (buffers.Length<>0) then
            z_VertexArrayVertexBuffers_8(vaobj, first, count, buffers[0], offsets[0], strides[0]) else
            z_VertexArrayVertexBuffers_8(vaobj, first, count, Pgl_buffer(nil)^, offsets[0], strides[0]) else
          if (buffers<>nil) and (buffers.Length<>0) then
            z_VertexArrayVertexBuffers_8(vaobj, first, count, buffers[0], PIntPtr(nil)^, strides[0]) else
            z_VertexArrayVertexBuffers_8(vaobj, first, count, Pgl_buffer(nil)^, PIntPtr(nil)^, strides[0]) else
        if (offsets<>nil) and (offsets.Length<>0) then
          if (buffers<>nil) and (buffers.Length<>0) then
            z_VertexArrayVertexBuffers_8(vaobj, first, count, buffers[0], offsets[0], PInt32(nil)^) else
            z_VertexArrayVertexBuffers_8(vaobj, first, count, Pgl_buffer(nil)^, offsets[0], PInt32(nil)^) else
          if (buffers<>nil) and (buffers.Length<>0) then
            z_VertexArrayVertexBuffers_8(vaobj, first, count, buffers[0], PIntPtr(nil)^, PInt32(nil)^) else
            z_VertexArrayVertexBuffers_8(vaobj, first, count, Pgl_buffer(nil)^, PIntPtr(nil)^, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: gl_vertex_array; first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; var strides: Int32) :=
    z_VertexArrayVertexBuffers_8(vaobj, first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: gl_vertex_array; first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; strides: IntPtr) :=
    z_VertexArrayVertexBuffers_7(vaobj, first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: gl_vertex_array; first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; var strides: Int32) :=
    z_VertexArrayVertexBuffers_6(vaobj, first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: gl_vertex_array; first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; strides: IntPtr) :=
    z_VertexArrayVertexBuffers_5(vaobj, first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: gl_vertex_array; first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; var strides: Int32) :=
    z_VertexArrayVertexBuffers_4(vaobj, first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: gl_vertex_array; first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; strides: IntPtr) :=
    z_VertexArrayVertexBuffers_3(vaobj, first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: gl_vertex_array; first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; var strides: Int32) :=
    z_VertexArrayVertexBuffers_2(vaobj, first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: gl_vertex_array; first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; strides: IntPtr) :=
    z_VertexArrayVertexBuffers_1(vaobj, first, count, buffers, offsets, strides);
    
    // added in gl2.0
    private z_VertexAttrib1d_adr := GetProcAddress('glVertexAttrib1d');
    private z_VertexAttrib1d_1 := GetProcOrNil&<procedure(index: UInt32; x: real)>(z_VertexAttrib1d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1d(index: UInt32; x: real) :=
    z_VertexAttrib1d_1(index, x);
    
    // added in gl2.0
    private z_VertexAttrib1dv_adr := GetProcAddress('glVertexAttrib1dv');
    private z_VertexAttrib1dv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib1dv_adr);
    private z_VertexAttrib1dv_2 := GetProcOrNil&<procedure(index: UInt32; var v: real)>(z_VertexAttrib1dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dv(index: UInt32; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib1dv_2(index, v[0]) else
        z_VertexAttrib1dv_2(index, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dv(index: UInt32; var v: real) :=
    z_VertexAttrib1dv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dv(index: UInt32; v: IntPtr) :=
    z_VertexAttrib1dv_1(index, v);
    
    // added in gl2.0
    private z_VertexAttrib1f_adr := GetProcAddress('glVertexAttrib1f');
    private z_VertexAttrib1f_1 := GetProcOrNil&<procedure(index: UInt32; x: single)>(z_VertexAttrib1f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1f(index: UInt32; x: single) :=
    z_VertexAttrib1f_1(index, x);
    
    // added in gl2.0
    private z_VertexAttrib1fv_adr := GetProcAddress('glVertexAttrib1fv');
    private z_VertexAttrib1fv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib1fv_adr);
    private z_VertexAttrib1fv_2 := GetProcOrNil&<procedure(index: UInt32; var v: single)>(z_VertexAttrib1fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fv(index: UInt32; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib1fv_2(index, v[0]) else
        z_VertexAttrib1fv_2(index, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fv(index: UInt32; var v: single) :=
    z_VertexAttrib1fv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fv(index: UInt32; v: IntPtr) :=
    z_VertexAttrib1fv_1(index, v);
    
    // added in gl2.0
    private z_VertexAttrib1s_adr := GetProcAddress('glVertexAttrib1s');
    private z_VertexAttrib1s_1 := GetProcOrNil&<procedure(index: UInt32; x: Int16)>(z_VertexAttrib1s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1s(index: UInt32; x: Int16) :=
    z_VertexAttrib1s_1(index, x);
    
    // added in gl2.0
    private z_VertexAttrib1sv_adr := GetProcAddress('glVertexAttrib1sv');
    private z_VertexAttrib1sv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib1sv_adr);
    private z_VertexAttrib1sv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(z_VertexAttrib1sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1sv(index: UInt32; v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib1sv_2(index, v[0]) else
        z_VertexAttrib1sv_2(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1sv(index: UInt32; var v: Int16) :=
    z_VertexAttrib1sv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1sv(index: UInt32; v: IntPtr) :=
    z_VertexAttrib1sv_1(index, v);
    
    // added in gl2.0
    private z_VertexAttrib2d_adr := GetProcAddress('glVertexAttrib2d');
    private z_VertexAttrib2d_1 := GetProcOrNil&<procedure(index: UInt32; x: real; y: real)>(z_VertexAttrib2d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2d(index: UInt32; x: real; y: real) :=
    z_VertexAttrib2d_1(index, x, y);
    
    // added in gl2.0
    private z_VertexAttrib2dv_adr := GetProcAddress('glVertexAttrib2dv');
    private z_VertexAttrib2dv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib2dv_adr);
    private z_VertexAttrib2dv_2 := GetProcOrNil&<procedure(index: UInt32; var v: real)>(z_VertexAttrib2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dv(index: UInt32; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib2dv_2(index, v[0]) else
        z_VertexAttrib2dv_2(index, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dv(index: UInt32; var v: real) :=
    z_VertexAttrib2dv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dv(index: UInt32; v: IntPtr) :=
    z_VertexAttrib2dv_1(index, v);
    
    // added in gl2.0
    private z_VertexAttrib2f_adr := GetProcAddress('glVertexAttrib2f');
    private z_VertexAttrib2f_1 := GetProcOrNil&<procedure(index: UInt32; x: single; y: single)>(z_VertexAttrib2f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2f(index: UInt32; x: single; y: single) :=
    z_VertexAttrib2f_1(index, x, y);
    
    // added in gl2.0
    private z_VertexAttrib2fv_adr := GetProcAddress('glVertexAttrib2fv');
    private z_VertexAttrib2fv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib2fv_adr);
    private z_VertexAttrib2fv_2 := GetProcOrNil&<procedure(index: UInt32; var v: single)>(z_VertexAttrib2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fv(index: UInt32; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib2fv_2(index, v[0]) else
        z_VertexAttrib2fv_2(index, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fv(index: UInt32; var v: single) :=
    z_VertexAttrib2fv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fv(index: UInt32; v: IntPtr) :=
    z_VertexAttrib2fv_1(index, v);
    
    // added in gl2.0
    private z_VertexAttrib2s_adr := GetProcAddress('glVertexAttrib2s');
    private z_VertexAttrib2s_1 := GetProcOrNil&<procedure(index: UInt32; x: Int16; y: Int16)>(z_VertexAttrib2s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2s(index: UInt32; x: Int16; y: Int16) :=
    z_VertexAttrib2s_1(index, x, y);
    
    // added in gl2.0
    private z_VertexAttrib2sv_adr := GetProcAddress('glVertexAttrib2sv');
    private z_VertexAttrib2sv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib2sv_adr);
    private z_VertexAttrib2sv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(z_VertexAttrib2sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2sv(index: UInt32; v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib2sv_2(index, v[0]) else
        z_VertexAttrib2sv_2(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2sv(index: UInt32; var v: Int16) :=
    z_VertexAttrib2sv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2sv(index: UInt32; v: IntPtr) :=
    z_VertexAttrib2sv_1(index, v);
    
    // added in gl2.0
    private z_VertexAttrib3d_adr := GetProcAddress('glVertexAttrib3d');
    private z_VertexAttrib3d_1 := GetProcOrNil&<procedure(index: UInt32; x: real; y: real; z: real)>(z_VertexAttrib3d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3d(index: UInt32; x: real; y: real; z: real) :=
    z_VertexAttrib3d_1(index, x, y, z);
    
    // added in gl2.0
    private z_VertexAttrib3dv_adr := GetProcAddress('glVertexAttrib3dv');
    private z_VertexAttrib3dv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib3dv_adr);
    private z_VertexAttrib3dv_2 := GetProcOrNil&<procedure(index: UInt32; var v: real)>(z_VertexAttrib3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dv(index: UInt32; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib3dv_2(index, v[0]) else
        z_VertexAttrib3dv_2(index, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dv(index: UInt32; var v: real) :=
    z_VertexAttrib3dv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dv(index: UInt32; v: IntPtr) :=
    z_VertexAttrib3dv_1(index, v);
    
    // added in gl2.0
    private z_VertexAttrib3f_adr := GetProcAddress('glVertexAttrib3f');
    private z_VertexAttrib3f_1 := GetProcOrNil&<procedure(index: UInt32; x: single; y: single; z: single)>(z_VertexAttrib3f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3f(index: UInt32; x: single; y: single; z: single) :=
    z_VertexAttrib3f_1(index, x, y, z);
    
    // added in gl2.0
    private z_VertexAttrib3fv_adr := GetProcAddress('glVertexAttrib3fv');
    private z_VertexAttrib3fv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib3fv_adr);
    private z_VertexAttrib3fv_2 := GetProcOrNil&<procedure(index: UInt32; var v: single)>(z_VertexAttrib3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fv(index: UInt32; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib3fv_2(index, v[0]) else
        z_VertexAttrib3fv_2(index, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fv(index: UInt32; var v: single) :=
    z_VertexAttrib3fv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fv(index: UInt32; v: IntPtr) :=
    z_VertexAttrib3fv_1(index, v);
    
    // added in gl2.0
    private z_VertexAttrib3s_adr := GetProcAddress('glVertexAttrib3s');
    private z_VertexAttrib3s_1 := GetProcOrNil&<procedure(index: UInt32; x: Int16; y: Int16; z: Int16)>(z_VertexAttrib3s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3s(index: UInt32; x: Int16; y: Int16; z: Int16) :=
    z_VertexAttrib3s_1(index, x, y, z);
    
    // added in gl2.0
    private z_VertexAttrib3sv_adr := GetProcAddress('glVertexAttrib3sv');
    private z_VertexAttrib3sv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib3sv_adr);
    private z_VertexAttrib3sv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(z_VertexAttrib3sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3sv(index: UInt32; v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib3sv_2(index, v[0]) else
        z_VertexAttrib3sv_2(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3sv(index: UInt32; var v: Int16) :=
    z_VertexAttrib3sv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3sv(index: UInt32; v: IntPtr) :=
    z_VertexAttrib3sv_1(index, v);
    
    // added in gl2.0
    private z_VertexAttrib4bv_adr := GetProcAddress('glVertexAttrib4bv');
    private z_VertexAttrib4bv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4bv_adr);
    private z_VertexAttrib4bv_2 := GetProcOrNil&<procedure(index: UInt32; var v: SByte)>(z_VertexAttrib4bv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4bv(index: UInt32; v: array of SByte);
    type PSByte=^SByte;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4bv_2(index, v[0]) else
        z_VertexAttrib4bv_2(index, PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4bv(index: UInt32; var v: SByte) :=
    z_VertexAttrib4bv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4bv(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4bv_1(index, v);
    
    // added in gl2.0
    private z_VertexAttrib4d_adr := GetProcAddress('glVertexAttrib4d');
    private z_VertexAttrib4d_1 := GetProcOrNil&<procedure(index: UInt32; x: real; y: real; z: real; w: real)>(z_VertexAttrib4d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4d(index: UInt32; x: real; y: real; z: real; w: real) :=
    z_VertexAttrib4d_1(index, x, y, z, w);
    
    // added in gl2.0
    private z_VertexAttrib4dv_adr := GetProcAddress('glVertexAttrib4dv');
    private z_VertexAttrib4dv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4dv_adr);
    private z_VertexAttrib4dv_2 := GetProcOrNil&<procedure(index: UInt32; var v: real)>(z_VertexAttrib4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dv(index: UInt32; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4dv_2(index, v[0]) else
        z_VertexAttrib4dv_2(index, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dv(index: UInt32; var v: real) :=
    z_VertexAttrib4dv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dv(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4dv_1(index, v);
    
    // added in gl2.0
    private z_VertexAttrib4f_adr := GetProcAddress('glVertexAttrib4f');
    private z_VertexAttrib4f_1 := GetProcOrNil&<procedure(index: UInt32; x: single; y: single; z: single; w: single)>(z_VertexAttrib4f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4f(index: UInt32; x: single; y: single; z: single; w: single) :=
    z_VertexAttrib4f_1(index, x, y, z, w);
    
    // added in gl2.0
    private z_VertexAttrib4fv_adr := GetProcAddress('glVertexAttrib4fv');
    private z_VertexAttrib4fv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4fv_adr);
    private z_VertexAttrib4fv_2 := GetProcOrNil&<procedure(index: UInt32; var v: single)>(z_VertexAttrib4fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fv(index: UInt32; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4fv_2(index, v[0]) else
        z_VertexAttrib4fv_2(index, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fv(index: UInt32; var v: single) :=
    z_VertexAttrib4fv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fv(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4fv_1(index, v);
    
    // added in gl2.0
    private z_VertexAttrib4iv_adr := GetProcAddress('glVertexAttrib4iv');
    private z_VertexAttrib4iv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4iv_adr);
    private z_VertexAttrib4iv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(z_VertexAttrib4iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4iv(index: UInt32; v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4iv_2(index, v[0]) else
        z_VertexAttrib4iv_2(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4iv(index: UInt32; var v: Int32) :=
    z_VertexAttrib4iv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4iv(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4iv_1(index, v);
    
    // added in gl2.0
    private z_VertexAttrib4Nbv_adr := GetProcAddress('glVertexAttrib4Nbv');
    private z_VertexAttrib4Nbv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4Nbv_adr);
    private z_VertexAttrib4Nbv_2 := GetProcOrNil&<procedure(index: UInt32; var v: SByte)>(z_VertexAttrib4Nbv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nbv(index: UInt32; v: array of SByte);
    type PSByte=^SByte;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4Nbv_2(index, v[0]) else
        z_VertexAttrib4Nbv_2(index, PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nbv(index: UInt32; var v: SByte) :=
    z_VertexAttrib4Nbv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nbv(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4Nbv_1(index, v);
    
    // added in gl2.0
    private z_VertexAttrib4Niv_adr := GetProcAddress('glVertexAttrib4Niv');
    private z_VertexAttrib4Niv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4Niv_adr);
    private z_VertexAttrib4Niv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(z_VertexAttrib4Niv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Niv(index: UInt32; v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4Niv_2(index, v[0]) else
        z_VertexAttrib4Niv_2(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Niv(index: UInt32; var v: Int32) :=
    z_VertexAttrib4Niv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Niv(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4Niv_1(index, v);
    
    // added in gl2.0
    private z_VertexAttrib4Nsv_adr := GetProcAddress('glVertexAttrib4Nsv');
    private z_VertexAttrib4Nsv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4Nsv_adr);
    private z_VertexAttrib4Nsv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(z_VertexAttrib4Nsv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nsv(index: UInt32; v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4Nsv_2(index, v[0]) else
        z_VertexAttrib4Nsv_2(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nsv(index: UInt32; var v: Int16) :=
    z_VertexAttrib4Nsv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nsv(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4Nsv_1(index, v);
    
    // added in gl2.0
    private z_VertexAttrib4Nub_adr := GetProcAddress('glVertexAttrib4Nub');
    private z_VertexAttrib4Nub_1 := GetProcOrNil&<procedure(index: UInt32; x: Byte; y: Byte; z: Byte; w: Byte)>(z_VertexAttrib4Nub_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nub(index: UInt32; x: Byte; y: Byte; z: Byte; w: Byte) :=
    z_VertexAttrib4Nub_1(index, x, y, z, w);
    
    // added in gl2.0
    private z_VertexAttrib4Nubv_adr := GetProcAddress('glVertexAttrib4Nubv');
    private z_VertexAttrib4Nubv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4Nubv_adr);
    private z_VertexAttrib4Nubv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Byte)>(z_VertexAttrib4Nubv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nubv(index: UInt32; v: array of Byte);
    type PByte=^Byte;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4Nubv_2(index, v[0]) else
        z_VertexAttrib4Nubv_2(index, PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nubv(index: UInt32; var v: Byte) :=
    z_VertexAttrib4Nubv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nubv(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4Nubv_1(index, v);
    
    // added in gl2.0
    private z_VertexAttrib4Nuiv_adr := GetProcAddress('glVertexAttrib4Nuiv');
    private z_VertexAttrib4Nuiv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4Nuiv_adr);
    private z_VertexAttrib4Nuiv_2 := GetProcOrNil&<procedure(index: UInt32; var v: UInt32)>(z_VertexAttrib4Nuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nuiv(index: UInt32; v: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4Nuiv_2(index, v[0]) else
        z_VertexAttrib4Nuiv_2(index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nuiv(index: UInt32; var v: UInt32) :=
    z_VertexAttrib4Nuiv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nuiv(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4Nuiv_1(index, v);
    
    // added in gl2.0
    private z_VertexAttrib4Nusv_adr := GetProcAddress('glVertexAttrib4Nusv');
    private z_VertexAttrib4Nusv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4Nusv_adr);
    private z_VertexAttrib4Nusv_2 := GetProcOrNil&<procedure(index: UInt32; var v: UInt16)>(z_VertexAttrib4Nusv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nusv(index: UInt32; v: array of UInt16);
    type PUInt16=^UInt16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4Nusv_2(index, v[0]) else
        z_VertexAttrib4Nusv_2(index, PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nusv(index: UInt32; var v: UInt16) :=
    z_VertexAttrib4Nusv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nusv(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4Nusv_1(index, v);
    
    // added in gl2.0
    private z_VertexAttrib4s_adr := GetProcAddress('glVertexAttrib4s');
    private z_VertexAttrib4s_1 := GetProcOrNil&<procedure(index: UInt32; x: Int16; y: Int16; z: Int16; w: Int16)>(z_VertexAttrib4s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4s(index: UInt32; x: Int16; y: Int16; z: Int16; w: Int16) :=
    z_VertexAttrib4s_1(index, x, y, z, w);
    
    // added in gl2.0
    private z_VertexAttrib4sv_adr := GetProcAddress('glVertexAttrib4sv');
    private z_VertexAttrib4sv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4sv_adr);
    private z_VertexAttrib4sv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(z_VertexAttrib4sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4sv(index: UInt32; v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4sv_2(index, v[0]) else
        z_VertexAttrib4sv_2(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4sv(index: UInt32; var v: Int16) :=
    z_VertexAttrib4sv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4sv(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4sv_1(index, v);
    
    // added in gl2.0
    private z_VertexAttrib4ubv_adr := GetProcAddress('glVertexAttrib4ubv');
    private z_VertexAttrib4ubv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4ubv_adr);
    private z_VertexAttrib4ubv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Byte)>(z_VertexAttrib4ubv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubv(index: UInt32; v: array of Byte);
    type PByte=^Byte;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4ubv_2(index, v[0]) else
        z_VertexAttrib4ubv_2(index, PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubv(index: UInt32; var v: Byte) :=
    z_VertexAttrib4ubv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubv(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4ubv_1(index, v);
    
    // added in gl2.0
    private z_VertexAttrib4uiv_adr := GetProcAddress('glVertexAttrib4uiv');
    private z_VertexAttrib4uiv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4uiv_adr);
    private z_VertexAttrib4uiv_2 := GetProcOrNil&<procedure(index: UInt32; var v: UInt32)>(z_VertexAttrib4uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4uiv(index: UInt32; v: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4uiv_2(index, v[0]) else
        z_VertexAttrib4uiv_2(index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4uiv(index: UInt32; var v: UInt32) :=
    z_VertexAttrib4uiv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4uiv(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4uiv_1(index, v);
    
    // added in gl2.0
    private z_VertexAttrib4usv_adr := GetProcAddress('glVertexAttrib4usv');
    private z_VertexAttrib4usv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4usv_adr);
    private z_VertexAttrib4usv_2 := GetProcOrNil&<procedure(index: UInt32; var v: UInt16)>(z_VertexAttrib4usv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4usv(index: UInt32; v: array of UInt16);
    type PUInt16=^UInt16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4usv_2(index, v[0]) else
        z_VertexAttrib4usv_2(index, PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4usv(index: UInt32; var v: UInt16) :=
    z_VertexAttrib4usv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4usv(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4usv_1(index, v);
    
    // added in gl4.3
    private z_VertexAttribBinding_adr := GetProcAddress('glVertexAttribBinding');
    private z_VertexAttribBinding_1 := GetProcOrNil&<procedure(attribindex: UInt32; bindingindex: UInt32)>(z_VertexAttribBinding_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribBinding(attribindex: UInt32; bindingindex: UInt32) :=
    z_VertexAttribBinding_1(attribindex, bindingindex);
    
    // added in gl3.3
    private z_VertexAttribDivisor_adr := GetProcAddress('glVertexAttribDivisor');
    private z_VertexAttribDivisor_1 := GetProcOrNil&<procedure(index: UInt32; divisor: UInt32)>(z_VertexAttribDivisor_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribDivisor(index: UInt32; divisor: UInt32) :=
    z_VertexAttribDivisor_1(index, divisor);
    
    // added in gl4.3
    private z_VertexAttribFormat_adr := GetProcAddress('glVertexAttribFormat');
    private z_VertexAttribFormat_1 := GetProcOrNil&<procedure(attribindex: UInt32; size: Int32; &type: VertexAttribType; normalized: boolean; relativeoffset: UInt32)>(z_VertexAttribFormat_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribFormat(attribindex: UInt32; size: Int32; &type: VertexAttribType; normalized: boolean; relativeoffset: UInt32) :=
    z_VertexAttribFormat_1(attribindex, size, &type, normalized, relativeoffset);
    
    // added in gl3.0
    private z_VertexAttribI1i_adr := GetProcAddress('glVertexAttribI1i');
    private z_VertexAttribI1i_1 := GetProcOrNil&<procedure(index: UInt32; x: Int32)>(z_VertexAttribI1i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1i(index: UInt32; x: Int32) :=
    z_VertexAttribI1i_1(index, x);
    
    // added in gl3.0
    private z_VertexAttribI1iv_adr := GetProcAddress('glVertexAttribI1iv');
    private z_VertexAttribI1iv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribI1iv_adr);
    private z_VertexAttribI1iv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(z_VertexAttribI1iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1iv(index: UInt32; v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribI1iv_2(index, v[0]) else
        z_VertexAttribI1iv_2(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1iv(index: UInt32; var v: Int32) :=
    z_VertexAttribI1iv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1iv(index: UInt32; v: IntPtr) :=
    z_VertexAttribI1iv_1(index, v);
    
    // added in gl3.0
    private z_VertexAttribI1ui_adr := GetProcAddress('glVertexAttribI1ui');
    private z_VertexAttribI1ui_1 := GetProcOrNil&<procedure(index: UInt32; x: UInt32)>(z_VertexAttribI1ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1ui(index: UInt32; x: UInt32) :=
    z_VertexAttribI1ui_1(index, x);
    
    // added in gl3.0
    private z_VertexAttribI1uiv_adr := GetProcAddress('glVertexAttribI1uiv');
    private z_VertexAttribI1uiv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribI1uiv_adr);
    private z_VertexAttribI1uiv_2 := GetProcOrNil&<procedure(index: UInt32; var v: UInt32)>(z_VertexAttribI1uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1uiv(index: UInt32; v: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribI1uiv_2(index, v[0]) else
        z_VertexAttribI1uiv_2(index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1uiv(index: UInt32; var v: UInt32) :=
    z_VertexAttribI1uiv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1uiv(index: UInt32; v: IntPtr) :=
    z_VertexAttribI1uiv_1(index, v);
    
    // added in gl3.0
    private z_VertexAttribI2i_adr := GetProcAddress('glVertexAttribI2i');
    private z_VertexAttribI2i_1 := GetProcOrNil&<procedure(index: UInt32; x: Int32; y: Int32)>(z_VertexAttribI2i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2i(index: UInt32; x: Int32; y: Int32) :=
    z_VertexAttribI2i_1(index, x, y);
    
    // added in gl3.0
    private z_VertexAttribI2iv_adr := GetProcAddress('glVertexAttribI2iv');
    private z_VertexAttribI2iv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribI2iv_adr);
    private z_VertexAttribI2iv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(z_VertexAttribI2iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2iv(index: UInt32; v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribI2iv_2(index, v[0]) else
        z_VertexAttribI2iv_2(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2iv(index: UInt32; var v: Int32) :=
    z_VertexAttribI2iv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2iv(index: UInt32; v: IntPtr) :=
    z_VertexAttribI2iv_1(index, v);
    
    // added in gl3.0
    private z_VertexAttribI2ui_adr := GetProcAddress('glVertexAttribI2ui');
    private z_VertexAttribI2ui_1 := GetProcOrNil&<procedure(index: UInt32; x: UInt32; y: UInt32)>(z_VertexAttribI2ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2ui(index: UInt32; x: UInt32; y: UInt32) :=
    z_VertexAttribI2ui_1(index, x, y);
    
    // added in gl3.0
    private z_VertexAttribI2uiv_adr := GetProcAddress('glVertexAttribI2uiv');
    private z_VertexAttribI2uiv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribI2uiv_adr);
    private z_VertexAttribI2uiv_2 := GetProcOrNil&<procedure(index: UInt32; var v: UInt32)>(z_VertexAttribI2uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2uiv(index: UInt32; v: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribI2uiv_2(index, v[0]) else
        z_VertexAttribI2uiv_2(index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2uiv(index: UInt32; var v: UInt32) :=
    z_VertexAttribI2uiv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2uiv(index: UInt32; v: IntPtr) :=
    z_VertexAttribI2uiv_1(index, v);
    
    // added in gl3.0
    private z_VertexAttribI3i_adr := GetProcAddress('glVertexAttribI3i');
    private z_VertexAttribI3i_1 := GetProcOrNil&<procedure(index: UInt32; x: Int32; y: Int32; z: Int32)>(z_VertexAttribI3i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3i(index: UInt32; x: Int32; y: Int32; z: Int32) :=
    z_VertexAttribI3i_1(index, x, y, z);
    
    // added in gl3.0
    private z_VertexAttribI3iv_adr := GetProcAddress('glVertexAttribI3iv');
    private z_VertexAttribI3iv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribI3iv_adr);
    private z_VertexAttribI3iv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(z_VertexAttribI3iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3iv(index: UInt32; v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribI3iv_2(index, v[0]) else
        z_VertexAttribI3iv_2(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3iv(index: UInt32; var v: Int32) :=
    z_VertexAttribI3iv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3iv(index: UInt32; v: IntPtr) :=
    z_VertexAttribI3iv_1(index, v);
    
    // added in gl3.0
    private z_VertexAttribI3ui_adr := GetProcAddress('glVertexAttribI3ui');
    private z_VertexAttribI3ui_1 := GetProcOrNil&<procedure(index: UInt32; x: UInt32; y: UInt32; z: UInt32)>(z_VertexAttribI3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3ui(index: UInt32; x: UInt32; y: UInt32; z: UInt32) :=
    z_VertexAttribI3ui_1(index, x, y, z);
    
    // added in gl3.0
    private z_VertexAttribI3uiv_adr := GetProcAddress('glVertexAttribI3uiv');
    private z_VertexAttribI3uiv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribI3uiv_adr);
    private z_VertexAttribI3uiv_2 := GetProcOrNil&<procedure(index: UInt32; var v: UInt32)>(z_VertexAttribI3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3uiv(index: UInt32; v: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribI3uiv_2(index, v[0]) else
        z_VertexAttribI3uiv_2(index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3uiv(index: UInt32; var v: UInt32) :=
    z_VertexAttribI3uiv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3uiv(index: UInt32; v: IntPtr) :=
    z_VertexAttribI3uiv_1(index, v);
    
    // added in gl3.0
    private z_VertexAttribI4bv_adr := GetProcAddress('glVertexAttribI4bv');
    private z_VertexAttribI4bv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribI4bv_adr);
    private z_VertexAttribI4bv_2 := GetProcOrNil&<procedure(index: UInt32; var v: SByte)>(z_VertexAttribI4bv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4bv(index: UInt32; v: array of SByte);
    type PSByte=^SByte;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribI4bv_2(index, v[0]) else
        z_VertexAttribI4bv_2(index, PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4bv(index: UInt32; var v: SByte) :=
    z_VertexAttribI4bv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4bv(index: UInt32; v: IntPtr) :=
    z_VertexAttribI4bv_1(index, v);
    
    // added in gl3.0
    private z_VertexAttribI4i_adr := GetProcAddress('glVertexAttribI4i');
    private z_VertexAttribI4i_1 := GetProcOrNil&<procedure(index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32)>(z_VertexAttribI4i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4i(index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32) :=
    z_VertexAttribI4i_1(index, x, y, z, w);
    
    // added in gl3.0
    private z_VertexAttribI4iv_adr := GetProcAddress('glVertexAttribI4iv');
    private z_VertexAttribI4iv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribI4iv_adr);
    private z_VertexAttribI4iv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(z_VertexAttribI4iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4iv(index: UInt32; v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribI4iv_2(index, v[0]) else
        z_VertexAttribI4iv_2(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4iv(index: UInt32; var v: Int32) :=
    z_VertexAttribI4iv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4iv(index: UInt32; v: IntPtr) :=
    z_VertexAttribI4iv_1(index, v);
    
    // added in gl3.0
    private z_VertexAttribI4sv_adr := GetProcAddress('glVertexAttribI4sv');
    private z_VertexAttribI4sv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribI4sv_adr);
    private z_VertexAttribI4sv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(z_VertexAttribI4sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4sv(index: UInt32; v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribI4sv_2(index, v[0]) else
        z_VertexAttribI4sv_2(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4sv(index: UInt32; var v: Int16) :=
    z_VertexAttribI4sv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4sv(index: UInt32; v: IntPtr) :=
    z_VertexAttribI4sv_1(index, v);
    
    // added in gl3.0
    private z_VertexAttribI4ubv_adr := GetProcAddress('glVertexAttribI4ubv');
    private z_VertexAttribI4ubv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribI4ubv_adr);
    private z_VertexAttribI4ubv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Byte)>(z_VertexAttribI4ubv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ubv(index: UInt32; v: array of Byte);
    type PByte=^Byte;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribI4ubv_2(index, v[0]) else
        z_VertexAttribI4ubv_2(index, PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ubv(index: UInt32; var v: Byte) :=
    z_VertexAttribI4ubv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ubv(index: UInt32; v: IntPtr) :=
    z_VertexAttribI4ubv_1(index, v);
    
    // added in gl3.0
    private z_VertexAttribI4ui_adr := GetProcAddress('glVertexAttribI4ui');
    private z_VertexAttribI4ui_1 := GetProcOrNil&<procedure(index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32)>(z_VertexAttribI4ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ui(index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32) :=
    z_VertexAttribI4ui_1(index, x, y, z, w);
    
    // added in gl3.0
    private z_VertexAttribI4uiv_adr := GetProcAddress('glVertexAttribI4uiv');
    private z_VertexAttribI4uiv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribI4uiv_adr);
    private z_VertexAttribI4uiv_2 := GetProcOrNil&<procedure(index: UInt32; var v: UInt32)>(z_VertexAttribI4uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4uiv(index: UInt32; v: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribI4uiv_2(index, v[0]) else
        z_VertexAttribI4uiv_2(index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4uiv(index: UInt32; var v: UInt32) :=
    z_VertexAttribI4uiv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4uiv(index: UInt32; v: IntPtr) :=
    z_VertexAttribI4uiv_1(index, v);
    
    // added in gl3.0
    private z_VertexAttribI4usv_adr := GetProcAddress('glVertexAttribI4usv');
    private z_VertexAttribI4usv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribI4usv_adr);
    private z_VertexAttribI4usv_2 := GetProcOrNil&<procedure(index: UInt32; var v: UInt16)>(z_VertexAttribI4usv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4usv(index: UInt32; v: array of UInt16);
    type PUInt16=^UInt16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribI4usv_2(index, v[0]) else
        z_VertexAttribI4usv_2(index, PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4usv(index: UInt32; var v: UInt16) :=
    z_VertexAttribI4usv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4usv(index: UInt32; v: IntPtr) :=
    z_VertexAttribI4usv_1(index, v);
    
    // added in gl4.3
    private z_VertexAttribIFormat_adr := GetProcAddress('glVertexAttribIFormat');
    private z_VertexAttribIFormat_1 := GetProcOrNil&<procedure(attribindex: UInt32; size: Int32; &type: VertexAttribIType; relativeoffset: UInt32)>(z_VertexAttribIFormat_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribIFormat(attribindex: UInt32; size: Int32; &type: VertexAttribIType; relativeoffset: UInt32) :=
    z_VertexAttribIFormat_1(attribindex, size, &type, relativeoffset);
    
    // added in gl3.0
    private z_VertexAttribIPointer_adr := GetProcAddress('glVertexAttribIPointer');
    private z_VertexAttribIPointer_1 := GetProcOrNil&<procedure(index: UInt32; size: Int32; &type: VertexAttribIType; stride: Int32; pointer: IntPtr)>(z_VertexAttribIPointer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribIPointer(index: UInt32; size: Int32; &type: VertexAttribIType; stride: Int32; pointer: IntPtr) :=
    z_VertexAttribIPointer_1(index, size, &type, stride, pointer);
    
    // added in gl4.1
    private z_VertexAttribL1d_adr := GetProcAddress('glVertexAttribL1d');
    private z_VertexAttribL1d_1 := GetProcOrNil&<procedure(index: UInt32; x: real)>(z_VertexAttribL1d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1d(index: UInt32; x: real) :=
    z_VertexAttribL1d_1(index, x);
    
    // added in gl4.1
    private z_VertexAttribL1dv_adr := GetProcAddress('glVertexAttribL1dv');
    private z_VertexAttribL1dv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribL1dv_adr);
    private z_VertexAttribL1dv_2 := GetProcOrNil&<procedure(index: UInt32; var v: real)>(z_VertexAttribL1dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1dv(index: UInt32; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribL1dv_2(index, v[0]) else
        z_VertexAttribL1dv_2(index, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1dv(index: UInt32; var v: real) :=
    z_VertexAttribL1dv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1dv(index: UInt32; v: IntPtr) :=
    z_VertexAttribL1dv_1(index, v);
    
    // added in gl4.1
    private z_VertexAttribL2d_adr := GetProcAddress('glVertexAttribL2d');
    private z_VertexAttribL2d_1 := GetProcOrNil&<procedure(index: UInt32; x: real; y: real)>(z_VertexAttribL2d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2d(index: UInt32; x: real; y: real) :=
    z_VertexAttribL2d_1(index, x, y);
    
    // added in gl4.1
    private z_VertexAttribL2dv_adr := GetProcAddress('glVertexAttribL2dv');
    private z_VertexAttribL2dv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribL2dv_adr);
    private z_VertexAttribL2dv_2 := GetProcOrNil&<procedure(index: UInt32; var v: real)>(z_VertexAttribL2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2dv(index: UInt32; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribL2dv_2(index, v[0]) else
        z_VertexAttribL2dv_2(index, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2dv(index: UInt32; var v: real) :=
    z_VertexAttribL2dv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2dv(index: UInt32; v: IntPtr) :=
    z_VertexAttribL2dv_1(index, v);
    
    // added in gl4.1
    private z_VertexAttribL3d_adr := GetProcAddress('glVertexAttribL3d');
    private z_VertexAttribL3d_1 := GetProcOrNil&<procedure(index: UInt32; x: real; y: real; z: real)>(z_VertexAttribL3d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3d(index: UInt32; x: real; y: real; z: real) :=
    z_VertexAttribL3d_1(index, x, y, z);
    
    // added in gl4.1
    private z_VertexAttribL3dv_adr := GetProcAddress('glVertexAttribL3dv');
    private z_VertexAttribL3dv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribL3dv_adr);
    private z_VertexAttribL3dv_2 := GetProcOrNil&<procedure(index: UInt32; var v: real)>(z_VertexAttribL3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3dv(index: UInt32; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribL3dv_2(index, v[0]) else
        z_VertexAttribL3dv_2(index, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3dv(index: UInt32; var v: real) :=
    z_VertexAttribL3dv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3dv(index: UInt32; v: IntPtr) :=
    z_VertexAttribL3dv_1(index, v);
    
    // added in gl4.1
    private z_VertexAttribL4d_adr := GetProcAddress('glVertexAttribL4d');
    private z_VertexAttribL4d_1 := GetProcOrNil&<procedure(index: UInt32; x: real; y: real; z: real; w: real)>(z_VertexAttribL4d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4d(index: UInt32; x: real; y: real; z: real; w: real) :=
    z_VertexAttribL4d_1(index, x, y, z, w);
    
    // added in gl4.1
    private z_VertexAttribL4dv_adr := GetProcAddress('glVertexAttribL4dv');
    private z_VertexAttribL4dv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribL4dv_adr);
    private z_VertexAttribL4dv_2 := GetProcOrNil&<procedure(index: UInt32; var v: real)>(z_VertexAttribL4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4dv(index: UInt32; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribL4dv_2(index, v[0]) else
        z_VertexAttribL4dv_2(index, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4dv(index: UInt32; var v: real) :=
    z_VertexAttribL4dv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4dv(index: UInt32; v: IntPtr) :=
    z_VertexAttribL4dv_1(index, v);
    
    // added in gl4.3
    private z_VertexAttribLFormat_adr := GetProcAddress('glVertexAttribLFormat');
    private z_VertexAttribLFormat_1 := GetProcOrNil&<procedure(attribindex: UInt32; size: Int32; &type: VertexAttribLType; relativeoffset: UInt32)>(z_VertexAttribLFormat_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribLFormat(attribindex: UInt32; size: Int32; &type: VertexAttribLType; relativeoffset: UInt32) :=
    z_VertexAttribLFormat_1(attribindex, size, &type, relativeoffset);
    
    // added in gl4.1
    private z_VertexAttribLPointer_adr := GetProcAddress('glVertexAttribLPointer');
    private z_VertexAttribLPointer_1 := GetProcOrNil&<procedure(index: UInt32; size: Int32; &type: VertexAttribLType; stride: Int32; pointer: IntPtr)>(z_VertexAttribLPointer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribLPointer(index: UInt32; size: Int32; &type: VertexAttribLType; stride: Int32; pointer: IntPtr) :=
    z_VertexAttribLPointer_1(index, size, &type, stride, pointer);
    
    // added in gl3.3
    private z_VertexAttribP1ui_adr := GetProcAddress('glVertexAttribP1ui');
    private z_VertexAttribP1ui_1 := GetProcOrNil&<procedure(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: UInt32)>(z_VertexAttribP1ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP1ui(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: UInt32) :=
    z_VertexAttribP1ui_1(index, &type, normalized, value);
    
    // added in gl3.3
    private z_VertexAttribP1uiv_adr := GetProcAddress('glVertexAttribP1uiv');
    private z_VertexAttribP1uiv_1 := GetProcOrNil&<procedure(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: IntPtr)>(z_VertexAttribP1uiv_adr);
    private z_VertexAttribP1uiv_2 := GetProcOrNil&<procedure(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; var value: UInt32)>(z_VertexAttribP1uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP1uiv(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_VertexAttribP1uiv_2(index, &type, normalized, value[0]) else
        z_VertexAttribP1uiv_2(index, &type, normalized, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP1uiv(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; var value: UInt32) :=
    z_VertexAttribP1uiv_2(index, &type, normalized, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP1uiv(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: IntPtr) :=
    z_VertexAttribP1uiv_1(index, &type, normalized, value);
    
    // added in gl3.3
    private z_VertexAttribP2ui_adr := GetProcAddress('glVertexAttribP2ui');
    private z_VertexAttribP2ui_1 := GetProcOrNil&<procedure(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: UInt32)>(z_VertexAttribP2ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP2ui(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: UInt32) :=
    z_VertexAttribP2ui_1(index, &type, normalized, value);
    
    // added in gl3.3
    private z_VertexAttribP2uiv_adr := GetProcAddress('glVertexAttribP2uiv');
    private z_VertexAttribP2uiv_1 := GetProcOrNil&<procedure(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: IntPtr)>(z_VertexAttribP2uiv_adr);
    private z_VertexAttribP2uiv_2 := GetProcOrNil&<procedure(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; var value: UInt32)>(z_VertexAttribP2uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP2uiv(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_VertexAttribP2uiv_2(index, &type, normalized, value[0]) else
        z_VertexAttribP2uiv_2(index, &type, normalized, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP2uiv(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; var value: UInt32) :=
    z_VertexAttribP2uiv_2(index, &type, normalized, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP2uiv(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: IntPtr) :=
    z_VertexAttribP2uiv_1(index, &type, normalized, value);
    
    // added in gl3.3
    private z_VertexAttribP3ui_adr := GetProcAddress('glVertexAttribP3ui');
    private z_VertexAttribP3ui_1 := GetProcOrNil&<procedure(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: UInt32)>(z_VertexAttribP3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP3ui(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: UInt32) :=
    z_VertexAttribP3ui_1(index, &type, normalized, value);
    
    // added in gl3.3
    private z_VertexAttribP3uiv_adr := GetProcAddress('glVertexAttribP3uiv');
    private z_VertexAttribP3uiv_1 := GetProcOrNil&<procedure(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: IntPtr)>(z_VertexAttribP3uiv_adr);
    private z_VertexAttribP3uiv_2 := GetProcOrNil&<procedure(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; var value: UInt32)>(z_VertexAttribP3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP3uiv(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_VertexAttribP3uiv_2(index, &type, normalized, value[0]) else
        z_VertexAttribP3uiv_2(index, &type, normalized, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP3uiv(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; var value: UInt32) :=
    z_VertexAttribP3uiv_2(index, &type, normalized, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP3uiv(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: IntPtr) :=
    z_VertexAttribP3uiv_1(index, &type, normalized, value);
    
    // added in gl3.3
    private z_VertexAttribP4ui_adr := GetProcAddress('glVertexAttribP4ui');
    private z_VertexAttribP4ui_1 := GetProcOrNil&<procedure(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: UInt32)>(z_VertexAttribP4ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP4ui(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: UInt32) :=
    z_VertexAttribP4ui_1(index, &type, normalized, value);
    
    // added in gl3.3
    private z_VertexAttribP4uiv_adr := GetProcAddress('glVertexAttribP4uiv');
    private z_VertexAttribP4uiv_1 := GetProcOrNil&<procedure(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: IntPtr)>(z_VertexAttribP4uiv_adr);
    private z_VertexAttribP4uiv_2 := GetProcOrNil&<procedure(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; var value: UInt32)>(z_VertexAttribP4uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP4uiv(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_VertexAttribP4uiv_2(index, &type, normalized, value[0]) else
        z_VertexAttribP4uiv_2(index, &type, normalized, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP4uiv(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; var value: UInt32) :=
    z_VertexAttribP4uiv_2(index, &type, normalized, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP4uiv(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: IntPtr) :=
    z_VertexAttribP4uiv_1(index, &type, normalized, value);
    
    // added in gl2.0
    private z_VertexAttribPointer_adr := GetProcAddress('glVertexAttribPointer');
    private z_VertexAttribPointer_1 := GetProcOrNil&<procedure(index: UInt32; size: Int32; &type: VertexAttribPointerType; normalized: boolean; stride: Int32; pointer: IntPtr)>(z_VertexAttribPointer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribPointer(index: UInt32; size: Int32; &type: VertexAttribPointerType; normalized: boolean; stride: Int32; pointer: IntPtr) :=
    z_VertexAttribPointer_1(index, size, &type, normalized, stride, pointer);
    
    // added in gl4.3
    private z_VertexBindingDivisor_adr := GetProcAddress('glVertexBindingDivisor');
    private z_VertexBindingDivisor_1 := GetProcOrNil&<procedure(bindingindex: UInt32; divisor: UInt32)>(z_VertexBindingDivisor_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexBindingDivisor(bindingindex: UInt32; divisor: UInt32) :=
    z_VertexBindingDivisor_1(bindingindex, divisor);
    
    // added in gl3.3
    private z_VertexP2ui_adr := GetProcAddress('glVertexP2ui');
    private z_VertexP2ui_1 := GetProcOrNil&<procedure(&type: VertexPointerType; value: UInt32)>(z_VertexP2ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP2ui(&type: VertexPointerType; value: UInt32) :=
    z_VertexP2ui_1(&type, value);
    
    // added in gl3.3
    private z_VertexP2uiv_adr := GetProcAddress('glVertexP2uiv');
    private z_VertexP2uiv_1 := GetProcOrNil&<procedure(&type: VertexPointerType; value: IntPtr)>(z_VertexP2uiv_adr);
    private z_VertexP2uiv_2 := GetProcOrNil&<procedure(&type: VertexPointerType; var value: UInt32)>(z_VertexP2uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP2uiv(&type: VertexPointerType; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_VertexP2uiv_2(&type, value[0]) else
        z_VertexP2uiv_2(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP2uiv(&type: VertexPointerType; var value: UInt32) :=
    z_VertexP2uiv_2(&type, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP2uiv(&type: VertexPointerType; value: IntPtr) :=
    z_VertexP2uiv_1(&type, value);
    
    // added in gl3.3
    private z_VertexP3ui_adr := GetProcAddress('glVertexP3ui');
    private z_VertexP3ui_1 := GetProcOrNil&<procedure(&type: VertexPointerType; value: UInt32)>(z_VertexP3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP3ui(&type: VertexPointerType; value: UInt32) :=
    z_VertexP3ui_1(&type, value);
    
    // added in gl3.3
    private z_VertexP3uiv_adr := GetProcAddress('glVertexP3uiv');
    private z_VertexP3uiv_1 := GetProcOrNil&<procedure(&type: VertexPointerType; value: IntPtr)>(z_VertexP3uiv_adr);
    private z_VertexP3uiv_2 := GetProcOrNil&<procedure(&type: VertexPointerType; var value: UInt32)>(z_VertexP3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP3uiv(&type: VertexPointerType; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_VertexP3uiv_2(&type, value[0]) else
        z_VertexP3uiv_2(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP3uiv(&type: VertexPointerType; var value: UInt32) :=
    z_VertexP3uiv_2(&type, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP3uiv(&type: VertexPointerType; value: IntPtr) :=
    z_VertexP3uiv_1(&type, value);
    
    // added in gl3.3
    private z_VertexP4ui_adr := GetProcAddress('glVertexP4ui');
    private z_VertexP4ui_1 := GetProcOrNil&<procedure(&type: VertexPointerType; value: UInt32)>(z_VertexP4ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP4ui(&type: VertexPointerType; value: UInt32) :=
    z_VertexP4ui_1(&type, value);
    
    // added in gl3.3
    private z_VertexP4uiv_adr := GetProcAddress('glVertexP4uiv');
    private z_VertexP4uiv_1 := GetProcOrNil&<procedure(&type: VertexPointerType; value: IntPtr)>(z_VertexP4uiv_adr);
    private z_VertexP4uiv_2 := GetProcOrNil&<procedure(&type: VertexPointerType; var value: UInt32)>(z_VertexP4uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP4uiv(&type: VertexPointerType; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_VertexP4uiv_2(&type, value[0]) else
        z_VertexP4uiv_2(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP4uiv(&type: VertexPointerType; var value: UInt32) :=
    z_VertexP4uiv_2(&type, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP4uiv(&type: VertexPointerType; value: IntPtr) :=
    z_VertexP4uiv_1(&type, value);
    
    // added in gl1.0
    private z_Viewport_adr := GetProcAddress('glViewport');
    private z_Viewport_1 := GetProcOrNil&<procedure(x: Int32; y: Int32; width: Int32; height: Int32)>(z_Viewport_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Viewport(x: Int32; y: Int32; width: Int32; height: Int32) :=
    z_Viewport_1(x, y, width, height);
    
    // added in gl4.1
    private z_ViewportArrayv_adr := GetProcAddress('glViewportArrayv');
    private z_ViewportArrayv_1 := GetProcOrNil&<procedure(first: UInt32; count: Int32; v: IntPtr)>(z_ViewportArrayv_adr);
    private z_ViewportArrayv_2 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var v: single)>(z_ViewportArrayv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportArrayv(first: UInt32; count: Int32; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_ViewportArrayv_2(first, count, v[0]) else
        z_ViewportArrayv_2(first, count, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportArrayv(first: UInt32; count: Int32; var v: single) :=
    z_ViewportArrayv_2(first, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportArrayv(first: UInt32; count: Int32; v: IntPtr) :=
    z_ViewportArrayv_1(first, count, v);
    
    // added in gl4.1
    private z_ViewportIndexedf_adr := GetProcAddress('glViewportIndexedf');
    private z_ViewportIndexedf_1 := GetProcOrNil&<procedure(index: UInt32; x: single; y: single; w: single; h: single)>(z_ViewportIndexedf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportIndexedf(index: UInt32; x: single; y: single; w: single; h: single) :=
    z_ViewportIndexedf_1(index, x, y, w, h);
    
    // added in gl4.1
    private z_ViewportIndexedfv_adr := GetProcAddress('glViewportIndexedfv');
    private z_ViewportIndexedfv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_ViewportIndexedfv_adr);
    private z_ViewportIndexedfv_2 := GetProcOrNil&<procedure(index: UInt32; var v: single)>(z_ViewportIndexedfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportIndexedfv(index: UInt32; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_ViewportIndexedfv_2(index, v[0]) else
        z_ViewportIndexedfv_2(index, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportIndexedfv(index: UInt32; var v: single) :=
    z_ViewportIndexedfv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportIndexedfv(index: UInt32; v: IntPtr) :=
    z_ViewportIndexedfv_1(index, v);
    
    // added in gl3.2
    private z_WaitSync_adr := GetProcAddress('glWaitSync');
    private z_WaitSync_1 := GetProcOrNil&<procedure(sync: gl_sync; flags: DummyFlags; timeout: UInt64)>(z_WaitSync_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSync(sync: gl_sync; flags: DummyFlags; timeout: UInt64) :=
    z_WaitSync_1(sync, flags, timeout);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glD = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Accum_adr := GetProcAddress('glAccum');
    private z_Accum_1 := GetProcOrNil&<procedure(op: AccumOp; value: single)>(z_Accum_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Accum(op: AccumOp; value: single) :=
    z_Accum_1(op, value);
    
    // added in gl1.0, deprecated in gl3.2
    private z_AlphaFunc_adr := GetProcAddress('glAlphaFunc');
    private z_AlphaFunc_1 := GetProcOrNil&<procedure(func: AlphaFunction; ref: single)>(z_AlphaFunc_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AlphaFunc(func: AlphaFunction; ref: single) :=
    z_AlphaFunc_1(func, ref);
    
    // added in gl1.1, deprecated in gl3.2
    private z_AreTexturesResident_adr := GetProcAddress('glAreTexturesResident');
    private z_AreTexturesResident_1 := GetProcOrNil&<function(n: Int32; textures: IntPtr; residences: IntPtr): boolean>(z_AreTexturesResident_adr);
    private z_AreTexturesResident_2 := GetProcOrNil&<function(n: Int32; textures: IntPtr; var residences: boolean): boolean>(z_AreTexturesResident_adr);
    private z_AreTexturesResident_3 := GetProcOrNil&<function(n: Int32; var textures: gl_texture; residences: IntPtr): boolean>(z_AreTexturesResident_adr);
    private z_AreTexturesResident_4 := GetProcOrNil&<function(n: Int32; var textures: gl_texture; var residences: boolean): boolean>(z_AreTexturesResident_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResident(n: Int32; textures: array of gl_texture; var residences: boolean): boolean;
    type Pgl_texture=^gl_texture;
    begin
      Result := if (textures<>nil) and (textures.Length<>0) then
        z_AreTexturesResident_4(n, textures[0], residences) else
        z_AreTexturesResident_4(n, Pgl_texture(nil)^, residences);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResident(n: Int32; textures: array of gl_texture; residences: IntPtr): boolean;
    type Pgl_texture=^gl_texture;
    begin
      Result := if (textures<>nil) and (textures.Length<>0) then
        z_AreTexturesResident_3(n, textures[0], residences) else
        z_AreTexturesResident_3(n, Pgl_texture(nil)^, residences);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResident(n: Int32; var textures: gl_texture; var residences: boolean): boolean :=
    z_AreTexturesResident_4(n, textures, residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResident(n: Int32; var textures: gl_texture; residences: IntPtr): boolean :=
    z_AreTexturesResident_3(n, textures, residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResident(n: Int32; textures: IntPtr; var residences: boolean): boolean :=
    z_AreTexturesResident_2(n, textures, residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResident(n: Int32; textures: IntPtr; residences: IntPtr): boolean :=
    z_AreTexturesResident_1(n, textures, residences);
    
    // added in gl1.1, deprecated in gl3.2
    private z_ArrayElement_adr := GetProcAddress('glArrayElement');
    private z_ArrayElement_1 := GetProcOrNil&<procedure(i: Int32)>(z_ArrayElement_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ArrayElement(i: Int32) :=
    z_ArrayElement_1(i);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Begin_adr := GetProcAddress('glBegin');
    private z_Begin_1 := GetProcOrNil&<procedure(mode: PrimitiveType)>(z_Begin_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure &Begin(mode: PrimitiveType) :=
    z_Begin_1(mode);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Bitmap_adr := GetProcAddress('glBitmap');
    private z_Bitmap_1 := GetProcOrNil&<procedure(width: Int32; height: Int32; xorig: single; yorig: single; xmove: single; ymove: single; bitmap: IntPtr)>(z_Bitmap_adr);
    private z_Bitmap_2 := GetProcOrNil&<procedure(width: Int32; height: Int32; xorig: single; yorig: single; xmove: single; ymove: single; var bitmap: Byte)>(z_Bitmap_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Bitmap(width: Int32; height: Int32; xorig: single; yorig: single; xmove: single; ymove: single; bitmap: array of Byte);
    type PByte=^Byte;
    begin
      if (bitmap<>nil) and (bitmap.Length<>0) then
        z_Bitmap_2(width, height, xorig, yorig, xmove, ymove, bitmap[0]) else
        z_Bitmap_2(width, height, xorig, yorig, xmove, ymove, PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Bitmap(width: Int32; height: Int32; xorig: single; yorig: single; xmove: single; ymove: single; var bitmap: Byte) :=
    z_Bitmap_2(width, height, xorig, yorig, xmove, ymove, bitmap);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Bitmap(width: Int32; height: Int32; xorig: single; yorig: single; xmove: single; ymove: single; bitmap: IntPtr) :=
    z_Bitmap_1(width, height, xorig, yorig, xmove, ymove, bitmap);
    
    // added in gl1.0, deprecated in gl3.2
    private z_CallList_adr := GetProcAddress('glCallList');
    private z_CallList_1 := GetProcOrNil&<procedure(list: UInt32)>(z_CallList_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CallList(list: UInt32) :=
    z_CallList_1(list);
    
    // added in gl1.0, deprecated in gl3.2
    private z_CallLists_adr := GetProcAddress('glCallLists');
    private z_CallLists_1 := GetProcOrNil&<procedure(n: Int32; &type: ListNameType; lists: IntPtr)>(z_CallLists_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CallLists(n: Int32; &type: ListNameType; lists: IntPtr) :=
    z_CallLists_1(n, &type, lists);
    
    // added in gl1.0, deprecated in gl3.2
    private z_ClearAccum_adr := GetProcAddress('glClearAccum');
    private z_ClearAccum_1 := GetProcOrNil&<procedure(red: single; green: single; blue: single; alpha: single)>(z_ClearAccum_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearAccum(red: single; green: single; blue: single; alpha: single) :=
    z_ClearAccum_1(red, green, blue, alpha);
    
    // added in gl1.0, deprecated in gl3.2
    private z_ClearIndex_adr := GetProcAddress('glClearIndex');
    private z_ClearIndex_1 := GetProcOrNil&<procedure(c: single)>(z_ClearIndex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearIndex(c: single) :=
    z_ClearIndex_1(c);
    
    // added in gl1.3, deprecated in gl3.2
    private z_ClientActiveTexture_adr := GetProcAddress('glClientActiveTexture');
    private z_ClientActiveTexture_1 := GetProcOrNil&<procedure(texture: TextureUnit)>(z_ClientActiveTexture_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientActiveTexture(texture: TextureUnit) :=
    z_ClientActiveTexture_1(texture);
    
    // added in gl1.0, deprecated in gl3.2
    private z_ClipPlane_adr := GetProcAddress('glClipPlane');
    private z_ClipPlane_1 := GetProcOrNil&<procedure(plane: ClipPlaneName; equation: IntPtr)>(z_ClipPlane_adr);
    private z_ClipPlane_2 := GetProcOrNil&<procedure(plane: ClipPlaneName; var equation: real)>(z_ClipPlane_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlane(plane: ClipPlaneName; equation: array of real);
    type Preal=^real;
    begin
      if (equation<>nil) and (equation.Length<>0) then
        z_ClipPlane_2(plane, equation[0]) else
        z_ClipPlane_2(plane, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlane(plane: ClipPlaneName; var equation: real) :=
    z_ClipPlane_2(plane, equation);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlane(plane: ClipPlaneName; equation: IntPtr) :=
    z_ClipPlane_1(plane, equation);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Color3b_adr := GetProcAddress('glColor3b');
    private z_Color3b_1 := GetProcOrNil&<procedure(red: SByte; green: SByte; blue: SByte)>(z_Color3b_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3b(red: SByte; green: SByte; blue: SByte) :=
    z_Color3b_1(red, green, blue);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Color3bv_adr := GetProcAddress('glColor3bv');
    private z_Color3bv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Color3bv_adr);
    private z_Color3bv_2 := GetProcOrNil&<procedure(var v: SByte)>(z_Color3bv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3bv(v: array of SByte);
    type PSByte=^SByte;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Color3bv_2(v[0]) else
        z_Color3bv_2(PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3bv(var v: SByte) :=
    z_Color3bv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3bv(v: IntPtr) :=
    z_Color3bv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Color3d_adr := GetProcAddress('glColor3d');
    private z_Color3d_1 := GetProcOrNil&<procedure(red: real; green: real; blue: real)>(z_Color3d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3d(red: real; green: real; blue: real) :=
    z_Color3d_1(red, green, blue);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Color3dv_adr := GetProcAddress('glColor3dv');
    private z_Color3dv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Color3dv_adr);
    private z_Color3dv_2 := GetProcOrNil&<procedure(var v: real)>(z_Color3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3dv(v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Color3dv_2(v[0]) else
        z_Color3dv_2(Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3dv(var v: real) :=
    z_Color3dv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3dv(v: IntPtr) :=
    z_Color3dv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Color3f_adr := GetProcAddress('glColor3f');
    private z_Color3f_1 := GetProcOrNil&<procedure(red: single; green: single; blue: single)>(z_Color3f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3f(red: single; green: single; blue: single) :=
    z_Color3f_1(red, green, blue);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Color3fv_adr := GetProcAddress('glColor3fv');
    private z_Color3fv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Color3fv_adr);
    private z_Color3fv_2 := GetProcOrNil&<procedure(var v: single)>(z_Color3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3fv(v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Color3fv_2(v[0]) else
        z_Color3fv_2(Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3fv(var v: single) :=
    z_Color3fv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3fv(v: IntPtr) :=
    z_Color3fv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Color3i_adr := GetProcAddress('glColor3i');
    private z_Color3i_1 := GetProcOrNil&<procedure(red: Int32; green: Int32; blue: Int32)>(z_Color3i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3i(red: Int32; green: Int32; blue: Int32) :=
    z_Color3i_1(red, green, blue);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Color3iv_adr := GetProcAddress('glColor3iv');
    private z_Color3iv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Color3iv_adr);
    private z_Color3iv_2 := GetProcOrNil&<procedure(var v: Int32)>(z_Color3iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3iv(v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Color3iv_2(v[0]) else
        z_Color3iv_2(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3iv(var v: Int32) :=
    z_Color3iv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3iv(v: IntPtr) :=
    z_Color3iv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Color3s_adr := GetProcAddress('glColor3s');
    private z_Color3s_1 := GetProcOrNil&<procedure(red: Int16; green: Int16; blue: Int16)>(z_Color3s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3s(red: Int16; green: Int16; blue: Int16) :=
    z_Color3s_1(red, green, blue);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Color3sv_adr := GetProcAddress('glColor3sv');
    private z_Color3sv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Color3sv_adr);
    private z_Color3sv_2 := GetProcOrNil&<procedure(var v: Int16)>(z_Color3sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3sv(v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Color3sv_2(v[0]) else
        z_Color3sv_2(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3sv(var v: Int16) :=
    z_Color3sv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3sv(v: IntPtr) :=
    z_Color3sv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Color3ub_adr := GetProcAddress('glColor3ub');
    private z_Color3ub_1 := GetProcOrNil&<procedure(red: Byte; green: Byte; blue: Byte)>(z_Color3ub_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3ub(red: Byte; green: Byte; blue: Byte) :=
    z_Color3ub_1(red, green, blue);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Color3ubv_adr := GetProcAddress('glColor3ubv');
    private z_Color3ubv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Color3ubv_adr);
    private z_Color3ubv_2 := GetProcOrNil&<procedure(var v: Byte)>(z_Color3ubv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3ubv(v: array of Byte);
    type PByte=^Byte;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Color3ubv_2(v[0]) else
        z_Color3ubv_2(PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3ubv(var v: Byte) :=
    z_Color3ubv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3ubv(v: IntPtr) :=
    z_Color3ubv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Color3ui_adr := GetProcAddress('glColor3ui');
    private z_Color3ui_1 := GetProcOrNil&<procedure(red: UInt32; green: UInt32; blue: UInt32)>(z_Color3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3ui(red: UInt32; green: UInt32; blue: UInt32) :=
    z_Color3ui_1(red, green, blue);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Color3uiv_adr := GetProcAddress('glColor3uiv');
    private z_Color3uiv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Color3uiv_adr);
    private z_Color3uiv_2 := GetProcOrNil&<procedure(var v: UInt32)>(z_Color3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3uiv(v: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Color3uiv_2(v[0]) else
        z_Color3uiv_2(PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3uiv(var v: UInt32) :=
    z_Color3uiv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3uiv(v: IntPtr) :=
    z_Color3uiv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Color3us_adr := GetProcAddress('glColor3us');
    private z_Color3us_1 := GetProcOrNil&<procedure(red: UInt16; green: UInt16; blue: UInt16)>(z_Color3us_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3us(red: UInt16; green: UInt16; blue: UInt16) :=
    z_Color3us_1(red, green, blue);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Color3usv_adr := GetProcAddress('glColor3usv');
    private z_Color3usv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Color3usv_adr);
    private z_Color3usv_2 := GetProcOrNil&<procedure(var v: UInt16)>(z_Color3usv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3usv(v: array of UInt16);
    type PUInt16=^UInt16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Color3usv_2(v[0]) else
        z_Color3usv_2(PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3usv(var v: UInt16) :=
    z_Color3usv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3usv(v: IntPtr) :=
    z_Color3usv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Color4b_adr := GetProcAddress('glColor4b');
    private z_Color4b_1 := GetProcOrNil&<procedure(red: SByte; green: SByte; blue: SByte; alpha: SByte)>(z_Color4b_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4b(red: SByte; green: SByte; blue: SByte; alpha: SByte) :=
    z_Color4b_1(red, green, blue, alpha);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Color4bv_adr := GetProcAddress('glColor4bv');
    private z_Color4bv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Color4bv_adr);
    private z_Color4bv_2 := GetProcOrNil&<procedure(var v: SByte)>(z_Color4bv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4bv(v: array of SByte);
    type PSByte=^SByte;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Color4bv_2(v[0]) else
        z_Color4bv_2(PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4bv(var v: SByte) :=
    z_Color4bv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4bv(v: IntPtr) :=
    z_Color4bv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Color4d_adr := GetProcAddress('glColor4d');
    private z_Color4d_1 := GetProcOrNil&<procedure(red: real; green: real; blue: real; alpha: real)>(z_Color4d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4d(red: real; green: real; blue: real; alpha: real) :=
    z_Color4d_1(red, green, blue, alpha);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Color4dv_adr := GetProcAddress('glColor4dv');
    private z_Color4dv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Color4dv_adr);
    private z_Color4dv_2 := GetProcOrNil&<procedure(var v: real)>(z_Color4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4dv(v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Color4dv_2(v[0]) else
        z_Color4dv_2(Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4dv(var v: real) :=
    z_Color4dv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4dv(v: IntPtr) :=
    z_Color4dv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Color4f_adr := GetProcAddress('glColor4f');
    private z_Color4f_1 := GetProcOrNil&<procedure(red: single; green: single; blue: single; alpha: single)>(z_Color4f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4f(red: single; green: single; blue: single; alpha: single) :=
    z_Color4f_1(red, green, blue, alpha);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Color4fv_adr := GetProcAddress('glColor4fv');
    private z_Color4fv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Color4fv_adr);
    private z_Color4fv_2 := GetProcOrNil&<procedure(var v: single)>(z_Color4fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fv(v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Color4fv_2(v[0]) else
        z_Color4fv_2(Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fv(var v: single) :=
    z_Color4fv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fv(v: IntPtr) :=
    z_Color4fv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Color4i_adr := GetProcAddress('glColor4i');
    private z_Color4i_1 := GetProcOrNil&<procedure(red: Int32; green: Int32; blue: Int32; alpha: Int32)>(z_Color4i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4i(red: Int32; green: Int32; blue: Int32; alpha: Int32) :=
    z_Color4i_1(red, green, blue, alpha);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Color4iv_adr := GetProcAddress('glColor4iv');
    private z_Color4iv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Color4iv_adr);
    private z_Color4iv_2 := GetProcOrNil&<procedure(var v: Int32)>(z_Color4iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4iv(v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Color4iv_2(v[0]) else
        z_Color4iv_2(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4iv(var v: Int32) :=
    z_Color4iv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4iv(v: IntPtr) :=
    z_Color4iv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Color4s_adr := GetProcAddress('glColor4s');
    private z_Color4s_1 := GetProcOrNil&<procedure(red: Int16; green: Int16; blue: Int16; alpha: Int16)>(z_Color4s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4s(red: Int16; green: Int16; blue: Int16; alpha: Int16) :=
    z_Color4s_1(red, green, blue, alpha);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Color4sv_adr := GetProcAddress('glColor4sv');
    private z_Color4sv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Color4sv_adr);
    private z_Color4sv_2 := GetProcOrNil&<procedure(var v: Int16)>(z_Color4sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4sv(v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Color4sv_2(v[0]) else
        z_Color4sv_2(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4sv(var v: Int16) :=
    z_Color4sv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4sv(v: IntPtr) :=
    z_Color4sv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Color4ub_adr := GetProcAddress('glColor4ub');
    private z_Color4ub_1 := GetProcOrNil&<procedure(red: Byte; green: Byte; blue: Byte; alpha: Byte)>(z_Color4ub_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ub(red: Byte; green: Byte; blue: Byte; alpha: Byte) :=
    z_Color4ub_1(red, green, blue, alpha);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Color4ubv_adr := GetProcAddress('glColor4ubv');
    private z_Color4ubv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Color4ubv_adr);
    private z_Color4ubv_2 := GetProcOrNil&<procedure(var v: Byte)>(z_Color4ubv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubv(v: array of Byte);
    type PByte=^Byte;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Color4ubv_2(v[0]) else
        z_Color4ubv_2(PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubv(var v: Byte) :=
    z_Color4ubv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubv(v: IntPtr) :=
    z_Color4ubv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Color4ui_adr := GetProcAddress('glColor4ui');
    private z_Color4ui_1 := GetProcOrNil&<procedure(red: UInt32; green: UInt32; blue: UInt32; alpha: UInt32)>(z_Color4ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ui(red: UInt32; green: UInt32; blue: UInt32; alpha: UInt32) :=
    z_Color4ui_1(red, green, blue, alpha);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Color4uiv_adr := GetProcAddress('glColor4uiv');
    private z_Color4uiv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Color4uiv_adr);
    private z_Color4uiv_2 := GetProcOrNil&<procedure(var v: UInt32)>(z_Color4uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4uiv(v: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Color4uiv_2(v[0]) else
        z_Color4uiv_2(PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4uiv(var v: UInt32) :=
    z_Color4uiv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4uiv(v: IntPtr) :=
    z_Color4uiv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Color4us_adr := GetProcAddress('glColor4us');
    private z_Color4us_1 := GetProcOrNil&<procedure(red: UInt16; green: UInt16; blue: UInt16; alpha: UInt16)>(z_Color4us_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4us(red: UInt16; green: UInt16; blue: UInt16; alpha: UInt16) :=
    z_Color4us_1(red, green, blue, alpha);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Color4usv_adr := GetProcAddress('glColor4usv');
    private z_Color4usv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Color4usv_adr);
    private z_Color4usv_2 := GetProcOrNil&<procedure(var v: UInt16)>(z_Color4usv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4usv(v: array of UInt16);
    type PUInt16=^UInt16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Color4usv_2(v[0]) else
        z_Color4usv_2(PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4usv(var v: UInt16) :=
    z_Color4usv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4usv(v: IntPtr) :=
    z_Color4usv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_ColorMaterial_adr := GetProcAddress('glColorMaterial');
    private z_ColorMaterial_1 := GetProcOrNil&<procedure(face: MaterialFace; mode: ColorMaterialParameter)>(z_ColorMaterial_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorMaterial(face: MaterialFace; mode: ColorMaterialParameter) :=
    z_ColorMaterial_1(face, mode);
    
    // added in gl1.1, deprecated in gl3.2
    private z_ColorPointer_adr := GetProcAddress('glColorPointer');
    private z_ColorPointer_1 := GetProcOrNil&<procedure(size: Int32; &type: ColorPointerType; stride: Int32; pointer: IntPtr)>(z_ColorPointer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorPointer(size: Int32; &type: ColorPointerType; stride: Int32; pointer: IntPtr) :=
    z_ColorPointer_1(size, &type, stride, pointer);
    
    // added in gl1.0, deprecated in gl3.2
    private z_CopyPixels_adr := GetProcAddress('glCopyPixels');
    private z_CopyPixels_1 := GetProcOrNil&<procedure(x: Int32; y: Int32; width: Int32; height: Int32; &type: PixelCopyType)>(z_CopyPixels_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyPixels(x: Int32; y: Int32; width: Int32; height: Int32; &type: PixelCopyType) :=
    z_CopyPixels_1(x, y, width, height, &type);
    
    // added in gl1.0, deprecated in gl3.2
    private z_DeleteLists_adr := GetProcAddress('glDeleteLists');
    private z_DeleteLists_1 := GetProcOrNil&<procedure(list: gl_display_list; range: Int32)>(z_DeleteLists_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteLists(list: gl_display_list; range: Int32) :=
    z_DeleteLists_1(list, range);
    
    // added in gl1.1, deprecated in gl3.2
    private z_DisableClientState_adr := GetProcAddress('glDisableClientState');
    private z_DisableClientState_1 := GetProcOrNil&<procedure(&array: EnableCap)>(z_DisableClientState_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableClientState(&array: EnableCap) :=
    z_DisableClientState_1(&array);
    
    // added in gl1.0, deprecated in gl3.2
    private z_DrawPixels_adr := GetProcAddress('glDrawPixels');
    private z_DrawPixels_1 := GetProcOrNil&<procedure(width: Int32; height: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr)>(z_DrawPixels_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawPixels(width: Int32; height: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr) :=
    z_DrawPixels_1(width, height, format, &type, pixels);
    
    // added in gl1.0, deprecated in gl3.2
    private z_EdgeFlag_adr := GetProcAddress('glEdgeFlag');
    private z_EdgeFlag_1 := GetProcOrNil&<procedure(flag: boolean)>(z_EdgeFlag_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlag(flag: boolean) :=
    z_EdgeFlag_1(flag);
    
    // added in gl1.1, deprecated in gl3.2
    private z_EdgeFlagPointer_adr := GetProcAddress('glEdgeFlagPointer');
    private z_EdgeFlagPointer_1 := GetProcOrNil&<procedure(stride: Int32; pointer: IntPtr)>(z_EdgeFlagPointer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlagPointer(stride: Int32; pointer: IntPtr) :=
    z_EdgeFlagPointer_1(stride, pointer);
    
    // added in gl1.0, deprecated in gl3.2
    private z_EdgeFlagv_adr := GetProcAddress('glEdgeFlagv');
    private z_EdgeFlagv_1 := GetProcOrNil&<procedure(flag: IntPtr)>(z_EdgeFlagv_adr);
    private z_EdgeFlagv_2 := GetProcOrNil&<procedure(var flag: boolean)>(z_EdgeFlagv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlagv(var flag: boolean) :=
    z_EdgeFlagv_2(flag);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlagv(flag: IntPtr) :=
    z_EdgeFlagv_1(flag);
    
    // added in gl1.1, deprecated in gl3.2
    private z_EnableClientState_adr := GetProcAddress('glEnableClientState');
    private z_EnableClientState_1 := GetProcOrNil&<procedure(&array: EnableCap)>(z_EnableClientState_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableClientState(&array: EnableCap) :=
    z_EnableClientState_1(&array);
    
    // added in gl1.0, deprecated in gl3.2
    private z_End_adr := GetProcAddress('glEnd');
    private z_End_1 := GetProcOrNil&<procedure>(z_End_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure &End :=
    z_End_1();
    
    // added in gl1.0, deprecated in gl3.2
    private z_EndList_adr := GetProcAddress('glEndList');
    private z_EndList_1 := GetProcOrNil&<procedure>(z_EndList_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndList :=
    z_EndList_1();
    
    // added in gl1.0, deprecated in gl3.2
    private z_EvalCoord1d_adr := GetProcAddress('glEvalCoord1d');
    private z_EvalCoord1d_1 := GetProcOrNil&<procedure(u: real)>(z_EvalCoord1d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1d(u: real) :=
    z_EvalCoord1d_1(u);
    
    // added in gl1.0, deprecated in gl3.2
    private z_EvalCoord1dv_adr := GetProcAddress('glEvalCoord1dv');
    private z_EvalCoord1dv_1 := GetProcOrNil&<procedure(u: IntPtr)>(z_EvalCoord1dv_adr);
    private z_EvalCoord1dv_2 := GetProcOrNil&<procedure(var u: real)>(z_EvalCoord1dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1dv(u: array of real);
    type Preal=^real;
    begin
      if (u<>nil) and (u.Length<>0) then
        z_EvalCoord1dv_2(u[0]) else
        z_EvalCoord1dv_2(Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1dv(var u: real) :=
    z_EvalCoord1dv_2(u);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1dv(u: IntPtr) :=
    z_EvalCoord1dv_1(u);
    
    // added in gl1.0, deprecated in gl3.2
    private z_EvalCoord1f_adr := GetProcAddress('glEvalCoord1f');
    private z_EvalCoord1f_1 := GetProcOrNil&<procedure(u: single)>(z_EvalCoord1f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1f(u: single) :=
    z_EvalCoord1f_1(u);
    
    // added in gl1.0, deprecated in gl3.2
    private z_EvalCoord1fv_adr := GetProcAddress('glEvalCoord1fv');
    private z_EvalCoord1fv_1 := GetProcOrNil&<procedure(u: IntPtr)>(z_EvalCoord1fv_adr);
    private z_EvalCoord1fv_2 := GetProcOrNil&<procedure(var u: single)>(z_EvalCoord1fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1fv(u: array of single);
    type Psingle=^single;
    begin
      if (u<>nil) and (u.Length<>0) then
        z_EvalCoord1fv_2(u[0]) else
        z_EvalCoord1fv_2(Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1fv(var u: single) :=
    z_EvalCoord1fv_2(u);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1fv(u: IntPtr) :=
    z_EvalCoord1fv_1(u);
    
    // added in gl1.0, deprecated in gl3.2
    private z_EvalCoord2d_adr := GetProcAddress('glEvalCoord2d');
    private z_EvalCoord2d_1 := GetProcOrNil&<procedure(u: real; v: real)>(z_EvalCoord2d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2d(u: real; v: real) :=
    z_EvalCoord2d_1(u, v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_EvalCoord2dv_adr := GetProcAddress('glEvalCoord2dv');
    private z_EvalCoord2dv_1 := GetProcOrNil&<procedure(u: IntPtr)>(z_EvalCoord2dv_adr);
    private z_EvalCoord2dv_2 := GetProcOrNil&<procedure(var u: real)>(z_EvalCoord2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2dv(u: array of real);
    type Preal=^real;
    begin
      if (u<>nil) and (u.Length<>0) then
        z_EvalCoord2dv_2(u[0]) else
        z_EvalCoord2dv_2(Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2dv(var u: real) :=
    z_EvalCoord2dv_2(u);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2dv(u: IntPtr) :=
    z_EvalCoord2dv_1(u);
    
    // added in gl1.0, deprecated in gl3.2
    private z_EvalCoord2f_adr := GetProcAddress('glEvalCoord2f');
    private z_EvalCoord2f_1 := GetProcOrNil&<procedure(u: single; v: single)>(z_EvalCoord2f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2f(u: single; v: single) :=
    z_EvalCoord2f_1(u, v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_EvalCoord2fv_adr := GetProcAddress('glEvalCoord2fv');
    private z_EvalCoord2fv_1 := GetProcOrNil&<procedure(u: IntPtr)>(z_EvalCoord2fv_adr);
    private z_EvalCoord2fv_2 := GetProcOrNil&<procedure(var u: single)>(z_EvalCoord2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2fv(u: array of single);
    type Psingle=^single;
    begin
      if (u<>nil) and (u.Length<>0) then
        z_EvalCoord2fv_2(u[0]) else
        z_EvalCoord2fv_2(Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2fv(var u: single) :=
    z_EvalCoord2fv_2(u);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2fv(u: IntPtr) :=
    z_EvalCoord2fv_1(u);
    
    // added in gl1.0, deprecated in gl3.2
    private z_EvalMesh1_adr := GetProcAddress('glEvalMesh1');
    private z_EvalMesh1_1 := GetProcOrNil&<procedure(mode: MeshMode1; i1: Int32; i2: Int32)>(z_EvalMesh1_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalMesh1(mode: MeshMode1; i1: Int32; i2: Int32) :=
    z_EvalMesh1_1(mode, i1, i2);
    
    // added in gl1.0, deprecated in gl3.2
    private z_EvalMesh2_adr := GetProcAddress('glEvalMesh2');
    private z_EvalMesh2_1 := GetProcOrNil&<procedure(mode: MeshMode2; i1: Int32; i2: Int32; j1: Int32; j2: Int32)>(z_EvalMesh2_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalMesh2(mode: MeshMode2; i1: Int32; i2: Int32; j1: Int32; j2: Int32) :=
    z_EvalMesh2_1(mode, i1, i2, j1, j2);
    
    // added in gl1.0, deprecated in gl3.2
    private z_EvalPoint1_adr := GetProcAddress('glEvalPoint1');
    private z_EvalPoint1_1 := GetProcOrNil&<procedure(i: Int32)>(z_EvalPoint1_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalPoint1(i: Int32) :=
    z_EvalPoint1_1(i);
    
    // added in gl1.0, deprecated in gl3.2
    private z_EvalPoint2_adr := GetProcAddress('glEvalPoint2');
    private z_EvalPoint2_1 := GetProcOrNil&<procedure(i: Int32; j: Int32)>(z_EvalPoint2_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalPoint2(i: Int32; j: Int32) :=
    z_EvalPoint2_1(i, j);
    
    // added in gl1.0, deprecated in gl3.2
    private z_FeedbackBuffer_adr := GetProcAddress('glFeedbackBuffer');
    private z_FeedbackBuffer_1 := GetProcOrNil&<procedure(size: Int32; &type: FeedbackType; buffer: IntPtr)>(z_FeedbackBuffer_adr);
    private z_FeedbackBuffer_2 := GetProcOrNil&<procedure(size: Int32; &type: FeedbackType; var buffer: FeedBackToken)>(z_FeedbackBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FeedbackBuffer(size: Int32; &type: FeedbackType; buffer: array of FeedBackToken);
    type PFeedBackToken=^FeedBackToken;
    begin
      if (buffer<>nil) and (buffer.Length<>0) then
        z_FeedbackBuffer_2(size, &type, buffer[0]) else
        z_FeedbackBuffer_2(size, &type, PFeedBackToken(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FeedbackBuffer(size: Int32; &type: FeedbackType; var buffer: FeedBackToken) :=
    z_FeedbackBuffer_2(size, &type, buffer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FeedbackBuffer(size: Int32; &type: FeedbackType; buffer: IntPtr) :=
    z_FeedbackBuffer_1(size, &type, buffer);
    
    // added in gl1.4, deprecated in gl3.2
    private z_FogCoordd_adr := GetProcAddress('glFogCoordd');
    private z_FogCoordd_1 := GetProcOrNil&<procedure(coord: real)>(z_FogCoordd_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordd(coord: real) :=
    z_FogCoordd_1(coord);
    
    // added in gl1.4, deprecated in gl3.2
    private z_FogCoorddv_adr := GetProcAddress('glFogCoorddv');
    private z_FogCoorddv_1 := GetProcOrNil&<procedure(coord: IntPtr)>(z_FogCoorddv_adr);
    private z_FogCoorddv_2 := GetProcOrNil&<procedure(var coord: real)>(z_FogCoorddv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoorddv(coord: array of real);
    type Preal=^real;
    begin
      if (coord<>nil) and (coord.Length<>0) then
        z_FogCoorddv_2(coord[0]) else
        z_FogCoorddv_2(Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoorddv(var coord: real) :=
    z_FogCoorddv_2(coord);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoorddv(coord: IntPtr) :=
    z_FogCoorddv_1(coord);
    
    // added in gl1.4, deprecated in gl3.2
    private z_FogCoordf_adr := GetProcAddress('glFogCoordf');
    private z_FogCoordf_1 := GetProcOrNil&<procedure(coord: single)>(z_FogCoordf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordf(coord: single) :=
    z_FogCoordf_1(coord);
    
    // added in gl1.4, deprecated in gl3.2
    private z_FogCoordfv_adr := GetProcAddress('glFogCoordfv');
    private z_FogCoordfv_1 := GetProcOrNil&<procedure(coord: IntPtr)>(z_FogCoordfv_adr);
    private z_FogCoordfv_2 := GetProcOrNil&<procedure(var coord: single)>(z_FogCoordfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordfv(coord: array of single);
    type Psingle=^single;
    begin
      if (coord<>nil) and (coord.Length<>0) then
        z_FogCoordfv_2(coord[0]) else
        z_FogCoordfv_2(Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordfv(var coord: single) :=
    z_FogCoordfv_2(coord);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordfv(coord: IntPtr) :=
    z_FogCoordfv_1(coord);
    
    // added in gl1.4, deprecated in gl3.2
    private z_FogCoordPointer_adr := GetProcAddress('glFogCoordPointer');
    private z_FogCoordPointer_1 := GetProcOrNil&<procedure(&type: FogPointerType; stride: Int32; pointer: IntPtr)>(z_FogCoordPointer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordPointer(&type: FogPointerType; stride: Int32; pointer: IntPtr) :=
    z_FogCoordPointer_1(&type, stride, pointer);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Fogf_adr := GetProcAddress('glFogf');
    private z_Fogf_1 := GetProcOrNil&<procedure(pname: FogParameter; param: single)>(z_Fogf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Fogf(pname: FogParameter; param: single) :=
    z_Fogf_1(pname, param);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Fogfv_adr := GetProcAddress('glFogfv');
    private z_Fogfv_1 := GetProcOrNil&<procedure(pname: FogParameter; &params: IntPtr)>(z_Fogfv_adr);
    private z_Fogfv_2 := GetProcOrNil&<procedure(pname: FogParameter; var &params: single)>(z_Fogfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Fogfv(pname: FogParameter; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_Fogfv_2(pname, &params[0]) else
        z_Fogfv_2(pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Fogfv(pname: FogParameter; var &params: single) :=
    z_Fogfv_2(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Fogfv(pname: FogParameter; &params: IntPtr) :=
    z_Fogfv_1(pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Fogi_adr := GetProcAddress('glFogi');
    private z_Fogi_1 := GetProcOrNil&<procedure(pname: FogParameter; param: Int32)>(z_Fogi_adr);
    private z_Fogi_2 := GetProcOrNil&<procedure(pname: FogParameter; param: FogMode)>(z_Fogi_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Fogi(pname: FogParameter; param: FogMode) :=
    z_Fogi_2(pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Fogi(pname: FogParameter; param: Int32) :=
    z_Fogi_1(pname, param);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Fogiv_adr := GetProcAddress('glFogiv');
    private z_Fogiv_1 := GetProcOrNil&<procedure(pname: FogParameter; &params: IntPtr)>(z_Fogiv_adr);
    private z_Fogiv_2 := GetProcOrNil&<procedure(pname: FogParameter; var &params: Int32)>(z_Fogiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Fogiv(pname: FogParameter; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_Fogiv_2(pname, &params[0]) else
        z_Fogiv_2(pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Fogiv(pname: FogParameter; var &params: Int32) :=
    z_Fogiv_2(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Fogiv(pname: FogParameter; &params: IntPtr) :=
    z_Fogiv_1(pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Frustum_adr := GetProcAddress('glFrustum');
    private z_Frustum_1 := GetProcOrNil&<procedure(left: real; right: real; bottom: real; top: real; zNear: real; zFar: real)>(z_Frustum_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Frustum(left: real; right: real; bottom: real; top: real; zNear: real; zFar: real) :=
    z_Frustum_1(left, right, bottom, top, zNear, zFar);
    
    // added in gl1.0, deprecated in gl3.2
    private z_GenLists_adr := GetProcAddress('glGenLists');
    private z_GenLists_1 := GetProcOrNil&<function(range: Int32): gl_display_list>(z_GenLists_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenLists(range: Int32): gl_display_list :=
    z_GenLists_1(range);
    
    // added in gl1.0, deprecated in gl3.2
    private z_GetClipPlane_adr := GetProcAddress('glGetClipPlane');
    private z_GetClipPlane_1 := GetProcOrNil&<procedure(plane: ClipPlaneName; equation: IntPtr)>(z_GetClipPlane_adr);
    private z_GetClipPlane_2 := GetProcOrNil&<procedure(plane: ClipPlaneName; var equation: real)>(z_GetClipPlane_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetClipPlane(plane: ClipPlaneName; var equation: real) :=
    z_GetClipPlane_2(plane, equation);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetClipPlane(plane: ClipPlaneName; equation: IntPtr) :=
    z_GetClipPlane_1(plane, equation);
    
    // added in gl1.0, deprecated in gl3.2
    private z_GetLightfv_adr := GetProcAddress('glGetLightfv');
    private z_GetLightfv_1 := GetProcOrNil&<procedure(light: LightName; pname: LightParameter; &params: IntPtr)>(z_GetLightfv_adr);
    private z_GetLightfv_2 := GetProcOrNil&<procedure(light: LightName; pname: LightParameter; var &params: single)>(z_GetLightfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLightfv(light: LightName; pname: LightParameter; var &params: single) :=
    z_GetLightfv_2(light, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLightfv(light: LightName; pname: LightParameter; &params: IntPtr) :=
    z_GetLightfv_1(light, pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private z_GetLightiv_adr := GetProcAddress('glGetLightiv');
    private z_GetLightiv_1 := GetProcOrNil&<procedure(light: LightName; pname: LightParameter; &params: IntPtr)>(z_GetLightiv_adr);
    private z_GetLightiv_2 := GetProcOrNil&<procedure(light: LightName; pname: LightParameter; var &params: Int32)>(z_GetLightiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLightiv(light: LightName; pname: LightParameter; var &params: Int32) :=
    z_GetLightiv_2(light, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLightiv(light: LightName; pname: LightParameter; &params: IntPtr) :=
    z_GetLightiv_1(light, pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private z_GetMapdv_adr := GetProcAddress('glGetMapdv');
    private z_GetMapdv_1 := GetProcOrNil&<procedure(target: MapTarget; query: GetMapQuery; v: IntPtr)>(z_GetMapdv_adr);
    private z_GetMapdv_2 := GetProcOrNil&<procedure(target: MapTarget; query: GetMapQuery; var v: real)>(z_GetMapdv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapdv(target: MapTarget; query: GetMapQuery; var v: real) :=
    z_GetMapdv_2(target, query, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapdv(target: MapTarget; query: GetMapQuery; v: IntPtr) :=
    z_GetMapdv_1(target, query, v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_GetMapfv_adr := GetProcAddress('glGetMapfv');
    private z_GetMapfv_1 := GetProcOrNil&<procedure(target: MapTarget; query: GetMapQuery; v: IntPtr)>(z_GetMapfv_adr);
    private z_GetMapfv_2 := GetProcOrNil&<procedure(target: MapTarget; query: GetMapQuery; var v: single)>(z_GetMapfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapfv(target: MapTarget; query: GetMapQuery; var v: single) :=
    z_GetMapfv_2(target, query, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapfv(target: MapTarget; query: GetMapQuery; v: IntPtr) :=
    z_GetMapfv_1(target, query, v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_GetMapiv_adr := GetProcAddress('glGetMapiv');
    private z_GetMapiv_1 := GetProcOrNil&<procedure(target: MapTarget; query: GetMapQuery; v: IntPtr)>(z_GetMapiv_adr);
    private z_GetMapiv_2 := GetProcOrNil&<procedure(target: MapTarget; query: GetMapQuery; var v: Int32)>(z_GetMapiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapiv(target: MapTarget; query: GetMapQuery; var v: Int32) :=
    z_GetMapiv_2(target, query, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapiv(target: MapTarget; query: GetMapQuery; v: IntPtr) :=
    z_GetMapiv_1(target, query, v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_GetMaterialfv_adr := GetProcAddress('glGetMaterialfv');
    private z_GetMaterialfv_1 := GetProcOrNil&<procedure(face: MaterialFace; pname: MaterialParameter; &params: IntPtr)>(z_GetMaterialfv_adr);
    private z_GetMaterialfv_2 := GetProcOrNil&<procedure(face: MaterialFace; pname: MaterialParameter; var &params: single)>(z_GetMaterialfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMaterialfv(face: MaterialFace; pname: MaterialParameter; var &params: single) :=
    z_GetMaterialfv_2(face, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMaterialfv(face: MaterialFace; pname: MaterialParameter; &params: IntPtr) :=
    z_GetMaterialfv_1(face, pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private z_GetMaterialiv_adr := GetProcAddress('glGetMaterialiv');
    private z_GetMaterialiv_1 := GetProcOrNil&<procedure(face: MaterialFace; pname: MaterialParameter; &params: IntPtr)>(z_GetMaterialiv_adr);
    private z_GetMaterialiv_2 := GetProcOrNil&<procedure(face: MaterialFace; pname: MaterialParameter; var &params: Int32)>(z_GetMaterialiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMaterialiv(face: MaterialFace; pname: MaterialParameter; var &params: Int32) :=
    z_GetMaterialiv_2(face, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMaterialiv(face: MaterialFace; pname: MaterialParameter; &params: IntPtr) :=
    z_GetMaterialiv_1(face, pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private z_GetPixelMapfv_adr := GetProcAddress('glGetPixelMapfv');
    private z_GetPixelMapfv_1 := GetProcOrNil&<procedure(map: PixelMap; values: IntPtr)>(z_GetPixelMapfv_adr);
    private z_GetPixelMapfv_2 := GetProcOrNil&<procedure(map: PixelMap; var values: single)>(z_GetPixelMapfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelMapfv(map: PixelMap; var values: single) :=
    z_GetPixelMapfv_2(map, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelMapfv(map: PixelMap; values: IntPtr) :=
    z_GetPixelMapfv_1(map, values);
    
    // added in gl1.0, deprecated in gl3.2
    private z_GetPixelMapuiv_adr := GetProcAddress('glGetPixelMapuiv');
    private z_GetPixelMapuiv_1 := GetProcOrNil&<procedure(map: PixelMap; values: IntPtr)>(z_GetPixelMapuiv_adr);
    private z_GetPixelMapuiv_2 := GetProcOrNil&<procedure(map: PixelMap; var values: UInt32)>(z_GetPixelMapuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelMapuiv(map: PixelMap; var values: UInt32) :=
    z_GetPixelMapuiv_2(map, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelMapuiv(map: PixelMap; values: IntPtr) :=
    z_GetPixelMapuiv_1(map, values);
    
    // added in gl1.0, deprecated in gl3.2
    private z_GetPixelMapusv_adr := GetProcAddress('glGetPixelMapusv');
    private z_GetPixelMapusv_1 := GetProcOrNil&<procedure(map: PixelMap; values: IntPtr)>(z_GetPixelMapusv_adr);
    private z_GetPixelMapusv_2 := GetProcOrNil&<procedure(map: PixelMap; var values: UInt16)>(z_GetPixelMapusv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelMapusv(map: PixelMap; var values: UInt16) :=
    z_GetPixelMapusv_2(map, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelMapusv(map: PixelMap; values: IntPtr) :=
    z_GetPixelMapusv_1(map, values);
    
    // added in gl1.0, deprecated in gl3.2
    private z_GetPolygonStipple_adr := GetProcAddress('glGetPolygonStipple');
    private z_GetPolygonStipple_1 := GetProcOrNil&<procedure(mask: IntPtr)>(z_GetPolygonStipple_adr);
    private z_GetPolygonStipple_2 := GetProcOrNil&<procedure(var mask: Byte)>(z_GetPolygonStipple_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPolygonStipple(var mask: Byte) :=
    z_GetPolygonStipple_2(mask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPolygonStipple(mask: IntPtr) :=
    z_GetPolygonStipple_1(mask);
    
    // added in gl1.0, deprecated in gl3.2
    private z_GetTexEnvfv_adr := GetProcAddress('glGetTexEnvfv');
    private z_GetTexEnvfv_1 := GetProcOrNil&<procedure(target: TextureEnvTarget; pname: TextureEnvParameter; &params: IntPtr)>(z_GetTexEnvfv_adr);
    private z_GetTexEnvfv_2 := GetProcOrNil&<procedure(target: TextureEnvTarget; pname: TextureEnvParameter; var &params: single)>(z_GetTexEnvfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexEnvfv(target: TextureEnvTarget; pname: TextureEnvParameter; var &params: single) :=
    z_GetTexEnvfv_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexEnvfv(target: TextureEnvTarget; pname: TextureEnvParameter; &params: IntPtr) :=
    z_GetTexEnvfv_1(target, pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private z_GetTexEnviv_adr := GetProcAddress('glGetTexEnviv');
    private z_GetTexEnviv_1 := GetProcOrNil&<procedure(target: TextureEnvTarget; pname: TextureEnvParameter; &params: IntPtr)>(z_GetTexEnviv_adr);
    private z_GetTexEnviv_2 := GetProcOrNil&<procedure(target: TextureEnvTarget; pname: TextureEnvParameter; var &params: Int32)>(z_GetTexEnviv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexEnviv(target: TextureEnvTarget; pname: TextureEnvParameter; var &params: Int32) :=
    z_GetTexEnviv_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexEnviv(target: TextureEnvTarget; pname: TextureEnvParameter; &params: IntPtr) :=
    z_GetTexEnviv_1(target, pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private z_GetTexGendv_adr := GetProcAddress('glGetTexGendv');
    private z_GetTexGendv_1 := GetProcOrNil&<procedure(coord: TextureCoordName; pname: TextureGenParameter; &params: IntPtr)>(z_GetTexGendv_adr);
    private z_GetTexGendv_2 := GetProcOrNil&<procedure(coord: TextureCoordName; pname: TextureGenParameter; var &params: real)>(z_GetTexGendv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGendv(coord: TextureCoordName; pname: TextureGenParameter; var &params: real) :=
    z_GetTexGendv_2(coord, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGendv(coord: TextureCoordName; pname: TextureGenParameter; &params: IntPtr) :=
    z_GetTexGendv_1(coord, pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private z_GetTexGenfv_adr := GetProcAddress('glGetTexGenfv');
    private z_GetTexGenfv_1 := GetProcOrNil&<procedure(coord: TextureCoordName; pname: TextureGenParameter; &params: IntPtr)>(z_GetTexGenfv_adr);
    private z_GetTexGenfv_2 := GetProcOrNil&<procedure(coord: TextureCoordName; pname: TextureGenParameter; var &params: single)>(z_GetTexGenfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGenfv(coord: TextureCoordName; pname: TextureGenParameter; var &params: single) :=
    z_GetTexGenfv_2(coord, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGenfv(coord: TextureCoordName; pname: TextureGenParameter; &params: IntPtr) :=
    z_GetTexGenfv_1(coord, pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private z_GetTexGeniv_adr := GetProcAddress('glGetTexGeniv');
    private z_GetTexGeniv_1 := GetProcOrNil&<procedure(coord: TextureCoordName; pname: TextureGenParameter; &params: IntPtr)>(z_GetTexGeniv_adr);
    private z_GetTexGeniv_2 := GetProcOrNil&<procedure(coord: TextureCoordName; pname: TextureGenParameter; var &params: Int32)>(z_GetTexGeniv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGeniv(coord: TextureCoordName; pname: TextureGenParameter; var &params: Int32) :=
    z_GetTexGeniv_2(coord, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGeniv(coord: TextureCoordName; pname: TextureGenParameter; &params: IntPtr) :=
    z_GetTexGeniv_1(coord, pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Indexd_adr := GetProcAddress('glIndexd');
    private z_Indexd_1 := GetProcOrNil&<procedure(c: real)>(z_Indexd_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexd(c: real) :=
    z_Indexd_1(c);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Indexdv_adr := GetProcAddress('glIndexdv');
    private z_Indexdv_1 := GetProcOrNil&<procedure(c: IntPtr)>(z_Indexdv_adr);
    private z_Indexdv_2 := GetProcOrNil&<procedure(var c: real)>(z_Indexdv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexdv(c: array of real);
    type Preal=^real;
    begin
      if (c<>nil) and (c.Length<>0) then
        z_Indexdv_2(c[0]) else
        z_Indexdv_2(Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexdv(var c: real) :=
    z_Indexdv_2(c);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexdv(c: IntPtr) :=
    z_Indexdv_1(c);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Indexf_adr := GetProcAddress('glIndexf');
    private z_Indexf_1 := GetProcOrNil&<procedure(c: single)>(z_Indexf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexf(c: single) :=
    z_Indexf_1(c);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Indexfv_adr := GetProcAddress('glIndexfv');
    private z_Indexfv_1 := GetProcOrNil&<procedure(c: IntPtr)>(z_Indexfv_adr);
    private z_Indexfv_2 := GetProcOrNil&<procedure(var c: single)>(z_Indexfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexfv(c: array of single);
    type Psingle=^single;
    begin
      if (c<>nil) and (c.Length<>0) then
        z_Indexfv_2(c[0]) else
        z_Indexfv_2(Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexfv(var c: single) :=
    z_Indexfv_2(c);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexfv(c: IntPtr) :=
    z_Indexfv_1(c);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Indexi_adr := GetProcAddress('glIndexi');
    private z_Indexi_1 := GetProcOrNil&<procedure(c: Int32)>(z_Indexi_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexi(c: Int32) :=
    z_Indexi_1(c);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Indexiv_adr := GetProcAddress('glIndexiv');
    private z_Indexiv_1 := GetProcOrNil&<procedure(c: IntPtr)>(z_Indexiv_adr);
    private z_Indexiv_2 := GetProcOrNil&<procedure(var c: Int32)>(z_Indexiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexiv(c: array of Int32);
    type PInt32=^Int32;
    begin
      if (c<>nil) and (c.Length<>0) then
        z_Indexiv_2(c[0]) else
        z_Indexiv_2(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexiv(var c: Int32) :=
    z_Indexiv_2(c);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexiv(c: IntPtr) :=
    z_Indexiv_1(c);
    
    // added in gl1.0, deprecated in gl3.2
    private z_IndexMask_adr := GetProcAddress('glIndexMask');
    private z_IndexMask_1 := GetProcOrNil&<procedure(mask: UInt32)>(z_IndexMask_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexMask(mask: UInt32) :=
    z_IndexMask_1(mask);
    
    // added in gl1.1, deprecated in gl3.2
    private z_IndexPointer_adr := GetProcAddress('glIndexPointer');
    private z_IndexPointer_1 := GetProcOrNil&<procedure(&type: IndexPointerType; stride: Int32; pointer: IntPtr)>(z_IndexPointer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexPointer(&type: IndexPointerType; stride: Int32; pointer: IntPtr) :=
    z_IndexPointer_1(&type, stride, pointer);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Indexs_adr := GetProcAddress('glIndexs');
    private z_Indexs_1 := GetProcOrNil&<procedure(c: Int16)>(z_Indexs_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexs(c: Int16) :=
    z_Indexs_1(c);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Indexsv_adr := GetProcAddress('glIndexsv');
    private z_Indexsv_1 := GetProcOrNil&<procedure(c: IntPtr)>(z_Indexsv_adr);
    private z_Indexsv_2 := GetProcOrNil&<procedure(var c: Int16)>(z_Indexsv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexsv(c: array of Int16);
    type PInt16=^Int16;
    begin
      if (c<>nil) and (c.Length<>0) then
        z_Indexsv_2(c[0]) else
        z_Indexsv_2(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexsv(var c: Int16) :=
    z_Indexsv_2(c);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexsv(c: IntPtr) :=
    z_Indexsv_1(c);
    
    // added in gl1.1, deprecated in gl3.2
    private z_Indexub_adr := GetProcAddress('glIndexub');
    private z_Indexub_1 := GetProcOrNil&<procedure(c: Byte)>(z_Indexub_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexub(c: Byte) :=
    z_Indexub_1(c);
    
    // added in gl1.1, deprecated in gl3.2
    private z_Indexubv_adr := GetProcAddress('glIndexubv');
    private z_Indexubv_1 := GetProcOrNil&<procedure(c: IntPtr)>(z_Indexubv_adr);
    private z_Indexubv_2 := GetProcOrNil&<procedure(var c: Byte)>(z_Indexubv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexubv(c: array of Byte);
    type PByte=^Byte;
    begin
      if (c<>nil) and (c.Length<>0) then
        z_Indexubv_2(c[0]) else
        z_Indexubv_2(PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexubv(var c: Byte) :=
    z_Indexubv_2(c);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexubv(c: IntPtr) :=
    z_Indexubv_1(c);
    
    // added in gl1.0, deprecated in gl3.2
    private z_InitNames_adr := GetProcAddress('glInitNames');
    private z_InitNames_1 := GetProcOrNil&<procedure>(z_InitNames_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InitNames :=
    z_InitNames_1();
    
    // added in gl1.1, deprecated in gl3.2
    private z_InterleavedArrays_adr := GetProcAddress('glInterleavedArrays');
    private z_InterleavedArrays_1 := GetProcOrNil&<procedure(format: InterleavedArrayFormat; stride: Int32; pointer: IntPtr)>(z_InterleavedArrays_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InterleavedArrays(format: InterleavedArrayFormat; stride: Int32; pointer: IntPtr) :=
    z_InterleavedArrays_1(format, stride, pointer);
    
    // added in gl1.0, deprecated in gl3.2
    private z_IsList_adr := GetProcAddress('glIsList');
    private z_IsList_1 := GetProcOrNil&<function(list: gl_display_list): boolean>(z_IsList_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsList(list: gl_display_list): boolean :=
    z_IsList_1(list);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Lightf_adr := GetProcAddress('glLightf');
    private z_Lightf_1 := GetProcOrNil&<procedure(light: LightName; pname: LightParameter; param: single)>(z_Lightf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Lightf(light: LightName; pname: LightParameter; param: single) :=
    z_Lightf_1(light, pname, param);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Lightfv_adr := GetProcAddress('glLightfv');
    private z_Lightfv_1 := GetProcOrNil&<procedure(light: LightName; pname: LightParameter; &params: IntPtr)>(z_Lightfv_adr);
    private z_Lightfv_2 := GetProcOrNil&<procedure(light: LightName; pname: LightParameter; var &params: single)>(z_Lightfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Lightfv(light: LightName; pname: LightParameter; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_Lightfv_2(light, pname, &params[0]) else
        z_Lightfv_2(light, pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Lightfv(light: LightName; pname: LightParameter; var &params: single) :=
    z_Lightfv_2(light, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Lightfv(light: LightName; pname: LightParameter; &params: IntPtr) :=
    z_Lightfv_1(light, pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Lighti_adr := GetProcAddress('glLighti');
    private z_Lighti_1 := GetProcOrNil&<procedure(light: LightName; pname: LightParameter; param: Int32)>(z_Lighti_adr);
    private z_Lighti_2 := GetProcOrNil&<procedure(light: LightName; pname: LightParameter; param: LightModelColorControl)>(z_Lighti_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Lighti(light: LightName; pname: LightParameter; param: LightModelColorControl) :=
    z_Lighti_2(light, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Lighti(light: LightName; pname: LightParameter; param: Int32) :=
    z_Lighti_1(light, pname, param);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Lightiv_adr := GetProcAddress('glLightiv');
    private z_Lightiv_1 := GetProcOrNil&<procedure(light: LightName; pname: LightParameter; &params: IntPtr)>(z_Lightiv_adr);
    private z_Lightiv_2 := GetProcOrNil&<procedure(light: LightName; pname: LightParameter; var &params: Int32)>(z_Lightiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Lightiv(light: LightName; pname: LightParameter; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_Lightiv_2(light, pname, &params[0]) else
        z_Lightiv_2(light, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Lightiv(light: LightName; pname: LightParameter; var &params: Int32) :=
    z_Lightiv_2(light, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Lightiv(light: LightName; pname: LightParameter; &params: IntPtr) :=
    z_Lightiv_1(light, pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private z_LightModelf_adr := GetProcAddress('glLightModelf');
    private z_LightModelf_1 := GetProcOrNil&<procedure(pname: LightModelParameter; param: single)>(z_LightModelf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModelf(pname: LightModelParameter; param: single) :=
    z_LightModelf_1(pname, param);
    
    // added in gl1.0, deprecated in gl3.2
    private z_LightModelfv_adr := GetProcAddress('glLightModelfv');
    private z_LightModelfv_1 := GetProcOrNil&<procedure(pname: LightModelParameter; &params: IntPtr)>(z_LightModelfv_adr);
    private z_LightModelfv_2 := GetProcOrNil&<procedure(pname: LightModelParameter; var &params: single)>(z_LightModelfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModelfv(pname: LightModelParameter; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_LightModelfv_2(pname, &params[0]) else
        z_LightModelfv_2(pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModelfv(pname: LightModelParameter; var &params: single) :=
    z_LightModelfv_2(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModelfv(pname: LightModelParameter; &params: IntPtr) :=
    z_LightModelfv_1(pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private z_LightModeli_adr := GetProcAddress('glLightModeli');
    private z_LightModeli_1 := GetProcOrNil&<procedure(pname: LightModelParameter; param: Int32)>(z_LightModeli_adr);
    private z_LightModeli_2 := GetProcOrNil&<procedure(pname: LightModelParameter; param: LightModelColorControl)>(z_LightModeli_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModeli(pname: LightModelParameter; param: LightModelColorControl) :=
    z_LightModeli_2(pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModeli(pname: LightModelParameter; param: Int32) :=
    z_LightModeli_1(pname, param);
    
    // added in gl1.0, deprecated in gl3.2
    private z_LightModeliv_adr := GetProcAddress('glLightModeliv');
    private z_LightModeliv_1 := GetProcOrNil&<procedure(pname: LightModelParameter; &params: IntPtr)>(z_LightModeliv_adr);
    private z_LightModeliv_2 := GetProcOrNil&<procedure(pname: LightModelParameter; var &params: Int32)>(z_LightModeliv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModeliv(pname: LightModelParameter; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_LightModeliv_2(pname, &params[0]) else
        z_LightModeliv_2(pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModeliv(pname: LightModelParameter; var &params: Int32) :=
    z_LightModeliv_2(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModeliv(pname: LightModelParameter; &params: IntPtr) :=
    z_LightModeliv_1(pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private z_LineStipple_adr := GetProcAddress('glLineStipple');
    private z_LineStipple_1 := GetProcOrNil&<procedure(factor: Int32; pattern: UInt16)>(z_LineStipple_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LineStipple(factor: Int32; pattern: UInt16) :=
    z_LineStipple_1(factor, pattern);
    
    // added in gl1.0, deprecated in gl3.2
    private z_ListBase_adr := GetProcAddress('glListBase');
    private z_ListBase_1 := GetProcOrNil&<procedure(base: UInt32)>(z_ListBase_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListBase(base: UInt32) :=
    z_ListBase_1(base);
    
    // added in gl1.0, deprecated in gl3.2
    private z_LoadIdentity_adr := GetProcAddress('glLoadIdentity');
    private z_LoadIdentity_1 := GetProcOrNil&<procedure>(z_LoadIdentity_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadIdentity :=
    z_LoadIdentity_1();
    
    // added in gl1.0, deprecated in gl3.2
    private z_LoadMatrixd_adr := GetProcAddress('glLoadMatrixd');
    private z_LoadMatrixd_1 := GetProcOrNil&<procedure(m: IntPtr)>(z_LoadMatrixd_adr);
    private z_LoadMatrixd_2 := GetProcOrNil&<procedure(var m: real)>(z_LoadMatrixd_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadMatrixd(m: array of real);
    type Preal=^real;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_LoadMatrixd_2(m[0]) else
        z_LoadMatrixd_2(Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadMatrixd(var m: real) :=
    z_LoadMatrixd_2(m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadMatrixd(m: IntPtr) :=
    z_LoadMatrixd_1(m);
    
    // added in gl1.0, deprecated in gl3.2
    private z_LoadMatrixf_adr := GetProcAddress('glLoadMatrixf');
    private z_LoadMatrixf_1 := GetProcOrNil&<procedure(m: IntPtr)>(z_LoadMatrixf_adr);
    private z_LoadMatrixf_2 := GetProcOrNil&<procedure(var m: single)>(z_LoadMatrixf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadMatrixf(m: array of single);
    type Psingle=^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_LoadMatrixf_2(m[0]) else
        z_LoadMatrixf_2(Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadMatrixf(var m: single) :=
    z_LoadMatrixf_2(m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadMatrixf(m: IntPtr) :=
    z_LoadMatrixf_1(m);
    
    // added in gl1.0, deprecated in gl3.2
    private z_LoadName_adr := GetProcAddress('glLoadName');
    private z_LoadName_1 := GetProcOrNil&<procedure(name: UInt32)>(z_LoadName_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadName(name: UInt32) :=
    z_LoadName_1(name);
    
    // added in gl1.3, deprecated in gl3.2
    private z_LoadTransposeMatrixd_adr := GetProcAddress('glLoadTransposeMatrixd');
    private z_LoadTransposeMatrixd_1 := GetProcOrNil&<procedure(m: IntPtr)>(z_LoadTransposeMatrixd_adr);
    private z_LoadTransposeMatrixd_2 := GetProcOrNil&<procedure(var m: real)>(z_LoadTransposeMatrixd_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixd(m: array of real);
    type Preal=^real;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_LoadTransposeMatrixd_2(m[0]) else
        z_LoadTransposeMatrixd_2(Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixd(var m: real) :=
    z_LoadTransposeMatrixd_2(m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixd(m: IntPtr) :=
    z_LoadTransposeMatrixd_1(m);
    
    // added in gl1.3, deprecated in gl3.2
    private z_LoadTransposeMatrixf_adr := GetProcAddress('glLoadTransposeMatrixf');
    private z_LoadTransposeMatrixf_1 := GetProcOrNil&<procedure(m: IntPtr)>(z_LoadTransposeMatrixf_adr);
    private z_LoadTransposeMatrixf_2 := GetProcOrNil&<procedure(var m: single)>(z_LoadTransposeMatrixf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixf(m: array of single);
    type Psingle=^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_LoadTransposeMatrixf_2(m[0]) else
        z_LoadTransposeMatrixf_2(Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixf(var m: single) :=
    z_LoadTransposeMatrixf_2(m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixf(m: IntPtr) :=
    z_LoadTransposeMatrixf_1(m);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Map1d_adr := GetProcAddress('glMap1d');
    private z_Map1d_1 := GetProcOrNil&<procedure(target: MapTarget; u1: real; u2: real; stride: Int32; order: Int32; points: IntPtr)>(z_Map1d_adr);
    private z_Map1d_2 := GetProcOrNil&<procedure(target: MapTarget; u1: real; u2: real; stride: Int32; order: Int32; var points: real)>(z_Map1d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map1d(target: MapTarget; u1: real; u2: real; stride: Int32; order: Int32; points: array of real);
    type Preal=^real;
    begin
      if (points<>nil) and (points.Length<>0) then
        z_Map1d_2(target, u1, u2, stride, order, points[0]) else
        z_Map1d_2(target, u1, u2, stride, order, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map1d(target: MapTarget; u1: real; u2: real; stride: Int32; order: Int32; var points: real) :=
    z_Map1d_2(target, u1, u2, stride, order, points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map1d(target: MapTarget; u1: real; u2: real; stride: Int32; order: Int32; points: IntPtr) :=
    z_Map1d_1(target, u1, u2, stride, order, points);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Map1f_adr := GetProcAddress('glMap1f');
    private z_Map1f_1 := GetProcOrNil&<procedure(target: MapTarget; u1: single; u2: single; stride: Int32; order: Int32; points: IntPtr)>(z_Map1f_adr);
    private z_Map1f_2 := GetProcOrNil&<procedure(target: MapTarget; u1: single; u2: single; stride: Int32; order: Int32; var points: single)>(z_Map1f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map1f(target: MapTarget; u1: single; u2: single; stride: Int32; order: Int32; points: array of single);
    type Psingle=^single;
    begin
      if (points<>nil) and (points.Length<>0) then
        z_Map1f_2(target, u1, u2, stride, order, points[0]) else
        z_Map1f_2(target, u1, u2, stride, order, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map1f(target: MapTarget; u1: single; u2: single; stride: Int32; order: Int32; var points: single) :=
    z_Map1f_2(target, u1, u2, stride, order, points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map1f(target: MapTarget; u1: single; u2: single; stride: Int32; order: Int32; points: IntPtr) :=
    z_Map1f_1(target, u1, u2, stride, order, points);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Map2d_adr := GetProcAddress('glMap2d');
    private z_Map2d_1 := GetProcOrNil&<procedure(target: MapTarget; u1: real; u2: real; ustride: Int32; uorder: Int32; v1: real; v2: real; vstride: Int32; vorder: Int32; points: IntPtr)>(z_Map2d_adr);
    private z_Map2d_2 := GetProcOrNil&<procedure(target: MapTarget; u1: real; u2: real; ustride: Int32; uorder: Int32; v1: real; v2: real; vstride: Int32; vorder: Int32; var points: real)>(z_Map2d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map2d(target: MapTarget; u1: real; u2: real; ustride: Int32; uorder: Int32; v1: real; v2: real; vstride: Int32; vorder: Int32; points: array of real);
    type Preal=^real;
    begin
      if (points<>nil) and (points.Length<>0) then
        z_Map2d_2(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points[0]) else
        z_Map2d_2(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map2d(target: MapTarget; u1: real; u2: real; ustride: Int32; uorder: Int32; v1: real; v2: real; vstride: Int32; vorder: Int32; var points: real) :=
    z_Map2d_2(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map2d(target: MapTarget; u1: real; u2: real; ustride: Int32; uorder: Int32; v1: real; v2: real; vstride: Int32; vorder: Int32; points: IntPtr) :=
    z_Map2d_1(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Map2f_adr := GetProcAddress('glMap2f');
    private z_Map2f_1 := GetProcOrNil&<procedure(target: MapTarget; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; points: IntPtr)>(z_Map2f_adr);
    private z_Map2f_2 := GetProcOrNil&<procedure(target: MapTarget; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; var points: single)>(z_Map2f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map2f(target: MapTarget; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; points: array of single);
    type Psingle=^single;
    begin
      if (points<>nil) and (points.Length<>0) then
        z_Map2f_2(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points[0]) else
        z_Map2f_2(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map2f(target: MapTarget; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; var points: single) :=
    z_Map2f_2(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map2f(target: MapTarget; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; points: IntPtr) :=
    z_Map2f_1(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    
    // added in gl1.0, deprecated in gl3.2
    private z_MapGrid1d_adr := GetProcAddress('glMapGrid1d');
    private z_MapGrid1d_1 := GetProcOrNil&<procedure(un: Int32; u1: real; u2: real)>(z_MapGrid1d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapGrid1d(un: Int32; u1: real; u2: real) :=
    z_MapGrid1d_1(un, u1, u2);
    
    // added in gl1.0, deprecated in gl3.2
    private z_MapGrid1f_adr := GetProcAddress('glMapGrid1f');
    private z_MapGrid1f_1 := GetProcOrNil&<procedure(un: Int32; u1: single; u2: single)>(z_MapGrid1f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapGrid1f(un: Int32; u1: single; u2: single) :=
    z_MapGrid1f_1(un, u1, u2);
    
    // added in gl1.0, deprecated in gl3.2
    private z_MapGrid2d_adr := GetProcAddress('glMapGrid2d');
    private z_MapGrid2d_1 := GetProcOrNil&<procedure(un: Int32; u1: real; u2: real; vn: Int32; v1: real; v2: real)>(z_MapGrid2d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapGrid2d(un: Int32; u1: real; u2: real; vn: Int32; v1: real; v2: real) :=
    z_MapGrid2d_1(un, u1, u2, vn, v1, v2);
    
    // added in gl1.0, deprecated in gl3.2
    private z_MapGrid2f_adr := GetProcAddress('glMapGrid2f');
    private z_MapGrid2f_1 := GetProcOrNil&<procedure(un: Int32; u1: single; u2: single; vn: Int32; v1: single; v2: single)>(z_MapGrid2f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapGrid2f(un: Int32; u1: single; u2: single; vn: Int32; v1: single; v2: single) :=
    z_MapGrid2f_1(un, u1, u2, vn, v1, v2);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Materialf_adr := GetProcAddress('glMaterialf');
    private z_Materialf_1 := GetProcOrNil&<procedure(face: MaterialFace; pname: MaterialParameter; param: single)>(z_Materialf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Materialf(face: MaterialFace; pname: MaterialParameter; param: single) :=
    z_Materialf_1(face, pname, param);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Materialfv_adr := GetProcAddress('glMaterialfv');
    private z_Materialfv_1 := GetProcOrNil&<procedure(face: MaterialFace; pname: MaterialParameter; &params: IntPtr)>(z_Materialfv_adr);
    private z_Materialfv_2 := GetProcOrNil&<procedure(face: MaterialFace; pname: MaterialParameter; var &params: single)>(z_Materialfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Materialfv(face: MaterialFace; pname: MaterialParameter; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_Materialfv_2(face, pname, &params[0]) else
        z_Materialfv_2(face, pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Materialfv(face: MaterialFace; pname: MaterialParameter; var &params: single) :=
    z_Materialfv_2(face, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Materialfv(face: MaterialFace; pname: MaterialParameter; &params: IntPtr) :=
    z_Materialfv_1(face, pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Materiali_adr := GetProcAddress('glMateriali');
    private z_Materiali_1 := GetProcOrNil&<procedure(face: MaterialFace; pname: MaterialParameter; param: Int32)>(z_Materiali_adr);
    private z_Materiali_2 := GetProcOrNil&<procedure(face: MaterialFace; pname: MaterialParameter; param: LightModelColorControl)>(z_Materiali_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Materiali(face: MaterialFace; pname: MaterialParameter; param: LightModelColorControl) :=
    z_Materiali_2(face, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Materiali(face: MaterialFace; pname: MaterialParameter; param: Int32) :=
    z_Materiali_1(face, pname, param);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Materialiv_adr := GetProcAddress('glMaterialiv');
    private z_Materialiv_1 := GetProcOrNil&<procedure(face: MaterialFace; pname: MaterialParameter; &params: IntPtr)>(z_Materialiv_adr);
    private z_Materialiv_2 := GetProcOrNil&<procedure(face: MaterialFace; pname: MaterialParameter; var &params: Int32)>(z_Materialiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Materialiv(face: MaterialFace; pname: MaterialParameter; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_Materialiv_2(face, pname, &params[0]) else
        z_Materialiv_2(face, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Materialiv(face: MaterialFace; pname: MaterialParameter; var &params: Int32) :=
    z_Materialiv_2(face, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Materialiv(face: MaterialFace; pname: MaterialParameter; &params: IntPtr) :=
    z_Materialiv_1(face, pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private z_MatrixMode_adr := GetProcAddress('glMatrixMode');
    private z_MatrixMode_1 := GetProcOrNil&<procedure(mode: OpenGL.MatrixMode)>(z_MatrixMode_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMode(mode: OpenGL.MatrixMode) :=
    z_MatrixMode_1(mode);
    
    // added in gl1.3, deprecated in gl3.2
    private z_MultiTexCoord1d_adr := GetProcAddress('glMultiTexCoord1d');
    private z_MultiTexCoord1d_1 := GetProcOrNil&<procedure(target: TextureUnit; s: real)>(z_MultiTexCoord1d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1d(target: TextureUnit; s: real) :=
    z_MultiTexCoord1d_1(target, s);
    
    // added in gl1.3, deprecated in gl3.2
    private z_MultiTexCoord1dv_adr := GetProcAddress('glMultiTexCoord1dv');
    private z_MultiTexCoord1dv_1 := GetProcOrNil&<procedure(target: TextureUnit; v: IntPtr)>(z_MultiTexCoord1dv_adr);
    private z_MultiTexCoord1dv_2 := GetProcOrNil&<procedure(target: TextureUnit; var v: real)>(z_MultiTexCoord1dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1dv(target: TextureUnit; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MultiTexCoord1dv_2(target, v[0]) else
        z_MultiTexCoord1dv_2(target, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1dv(target: TextureUnit; var v: real) :=
    z_MultiTexCoord1dv_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1dv(target: TextureUnit; v: IntPtr) :=
    z_MultiTexCoord1dv_1(target, v);
    
    // added in gl1.3, deprecated in gl3.2
    private z_MultiTexCoord1f_adr := GetProcAddress('glMultiTexCoord1f');
    private z_MultiTexCoord1f_1 := GetProcOrNil&<procedure(target: TextureUnit; s: single)>(z_MultiTexCoord1f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1f(target: TextureUnit; s: single) :=
    z_MultiTexCoord1f_1(target, s);
    
    // added in gl1.3, deprecated in gl3.2
    private z_MultiTexCoord1fv_adr := GetProcAddress('glMultiTexCoord1fv');
    private z_MultiTexCoord1fv_1 := GetProcOrNil&<procedure(target: TextureUnit; v: IntPtr)>(z_MultiTexCoord1fv_adr);
    private z_MultiTexCoord1fv_2 := GetProcOrNil&<procedure(target: TextureUnit; var v: single)>(z_MultiTexCoord1fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1fv(target: TextureUnit; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MultiTexCoord1fv_2(target, v[0]) else
        z_MultiTexCoord1fv_2(target, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1fv(target: TextureUnit; var v: single) :=
    z_MultiTexCoord1fv_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1fv(target: TextureUnit; v: IntPtr) :=
    z_MultiTexCoord1fv_1(target, v);
    
    // added in gl1.3, deprecated in gl3.2
    private z_MultiTexCoord1i_adr := GetProcAddress('glMultiTexCoord1i');
    private z_MultiTexCoord1i_1 := GetProcOrNil&<procedure(target: TextureUnit; s: Int32)>(z_MultiTexCoord1i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1i(target: TextureUnit; s: Int32) :=
    z_MultiTexCoord1i_1(target, s);
    
    // added in gl1.3, deprecated in gl3.2
    private z_MultiTexCoord1iv_adr := GetProcAddress('glMultiTexCoord1iv');
    private z_MultiTexCoord1iv_1 := GetProcOrNil&<procedure(target: TextureUnit; v: IntPtr)>(z_MultiTexCoord1iv_adr);
    private z_MultiTexCoord1iv_2 := GetProcOrNil&<procedure(target: TextureUnit; var v: Int32)>(z_MultiTexCoord1iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1iv(target: TextureUnit; v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MultiTexCoord1iv_2(target, v[0]) else
        z_MultiTexCoord1iv_2(target, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1iv(target: TextureUnit; var v: Int32) :=
    z_MultiTexCoord1iv_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1iv(target: TextureUnit; v: IntPtr) :=
    z_MultiTexCoord1iv_1(target, v);
    
    // added in gl1.3, deprecated in gl3.2
    private z_MultiTexCoord1s_adr := GetProcAddress('glMultiTexCoord1s');
    private z_MultiTexCoord1s_1 := GetProcOrNil&<procedure(target: TextureUnit; s: Int16)>(z_MultiTexCoord1s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1s(target: TextureUnit; s: Int16) :=
    z_MultiTexCoord1s_1(target, s);
    
    // added in gl1.3, deprecated in gl3.2
    private z_MultiTexCoord1sv_adr := GetProcAddress('glMultiTexCoord1sv');
    private z_MultiTexCoord1sv_1 := GetProcOrNil&<procedure(target: TextureUnit; v: IntPtr)>(z_MultiTexCoord1sv_adr);
    private z_MultiTexCoord1sv_2 := GetProcOrNil&<procedure(target: TextureUnit; var v: Int16)>(z_MultiTexCoord1sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1sv(target: TextureUnit; v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MultiTexCoord1sv_2(target, v[0]) else
        z_MultiTexCoord1sv_2(target, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1sv(target: TextureUnit; var v: Int16) :=
    z_MultiTexCoord1sv_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1sv(target: TextureUnit; v: IntPtr) :=
    z_MultiTexCoord1sv_1(target, v);
    
    // added in gl1.3, deprecated in gl3.2
    private z_MultiTexCoord2d_adr := GetProcAddress('glMultiTexCoord2d');
    private z_MultiTexCoord2d_1 := GetProcOrNil&<procedure(target: TextureUnit; s: real; t: real)>(z_MultiTexCoord2d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2d(target: TextureUnit; s: real; t: real) :=
    z_MultiTexCoord2d_1(target, s, t);
    
    // added in gl1.3, deprecated in gl3.2
    private z_MultiTexCoord2dv_adr := GetProcAddress('glMultiTexCoord2dv');
    private z_MultiTexCoord2dv_1 := GetProcOrNil&<procedure(target: TextureUnit; v: IntPtr)>(z_MultiTexCoord2dv_adr);
    private z_MultiTexCoord2dv_2 := GetProcOrNil&<procedure(target: TextureUnit; var v: real)>(z_MultiTexCoord2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2dv(target: TextureUnit; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MultiTexCoord2dv_2(target, v[0]) else
        z_MultiTexCoord2dv_2(target, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2dv(target: TextureUnit; var v: real) :=
    z_MultiTexCoord2dv_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2dv(target: TextureUnit; v: IntPtr) :=
    z_MultiTexCoord2dv_1(target, v);
    
    // added in gl1.3, deprecated in gl3.2
    private z_MultiTexCoord2f_adr := GetProcAddress('glMultiTexCoord2f');
    private z_MultiTexCoord2f_1 := GetProcOrNil&<procedure(target: TextureUnit; s: single; t: single)>(z_MultiTexCoord2f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2f(target: TextureUnit; s: single; t: single) :=
    z_MultiTexCoord2f_1(target, s, t);
    
    // added in gl1.3, deprecated in gl3.2
    private z_MultiTexCoord2fv_adr := GetProcAddress('glMultiTexCoord2fv');
    private z_MultiTexCoord2fv_1 := GetProcOrNil&<procedure(target: TextureUnit; v: IntPtr)>(z_MultiTexCoord2fv_adr);
    private z_MultiTexCoord2fv_2 := GetProcOrNil&<procedure(target: TextureUnit; var v: single)>(z_MultiTexCoord2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2fv(target: TextureUnit; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MultiTexCoord2fv_2(target, v[0]) else
        z_MultiTexCoord2fv_2(target, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2fv(target: TextureUnit; var v: single) :=
    z_MultiTexCoord2fv_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2fv(target: TextureUnit; v: IntPtr) :=
    z_MultiTexCoord2fv_1(target, v);
    
    // added in gl1.3, deprecated in gl3.2
    private z_MultiTexCoord2i_adr := GetProcAddress('glMultiTexCoord2i');
    private z_MultiTexCoord2i_1 := GetProcOrNil&<procedure(target: TextureUnit; s: Int32; t: Int32)>(z_MultiTexCoord2i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2i(target: TextureUnit; s: Int32; t: Int32) :=
    z_MultiTexCoord2i_1(target, s, t);
    
    // added in gl1.3, deprecated in gl3.2
    private z_MultiTexCoord2iv_adr := GetProcAddress('glMultiTexCoord2iv');
    private z_MultiTexCoord2iv_1 := GetProcOrNil&<procedure(target: TextureUnit; v: IntPtr)>(z_MultiTexCoord2iv_adr);
    private z_MultiTexCoord2iv_2 := GetProcOrNil&<procedure(target: TextureUnit; var v: Int32)>(z_MultiTexCoord2iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2iv(target: TextureUnit; v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MultiTexCoord2iv_2(target, v[0]) else
        z_MultiTexCoord2iv_2(target, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2iv(target: TextureUnit; var v: Int32) :=
    z_MultiTexCoord2iv_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2iv(target: TextureUnit; v: IntPtr) :=
    z_MultiTexCoord2iv_1(target, v);
    
    // added in gl1.3, deprecated in gl3.2
    private z_MultiTexCoord2s_adr := GetProcAddress('glMultiTexCoord2s');
    private z_MultiTexCoord2s_1 := GetProcOrNil&<procedure(target: TextureUnit; s: Int16; t: Int16)>(z_MultiTexCoord2s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2s(target: TextureUnit; s: Int16; t: Int16) :=
    z_MultiTexCoord2s_1(target, s, t);
    
    // added in gl1.3, deprecated in gl3.2
    private z_MultiTexCoord2sv_adr := GetProcAddress('glMultiTexCoord2sv');
    private z_MultiTexCoord2sv_1 := GetProcOrNil&<procedure(target: TextureUnit; v: IntPtr)>(z_MultiTexCoord2sv_adr);
    private z_MultiTexCoord2sv_2 := GetProcOrNil&<procedure(target: TextureUnit; var v: Int16)>(z_MultiTexCoord2sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2sv(target: TextureUnit; v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MultiTexCoord2sv_2(target, v[0]) else
        z_MultiTexCoord2sv_2(target, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2sv(target: TextureUnit; var v: Int16) :=
    z_MultiTexCoord2sv_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2sv(target: TextureUnit; v: IntPtr) :=
    z_MultiTexCoord2sv_1(target, v);
    
    // added in gl1.3, deprecated in gl3.2
    private z_MultiTexCoord3d_adr := GetProcAddress('glMultiTexCoord3d');
    private z_MultiTexCoord3d_1 := GetProcOrNil&<procedure(target: TextureUnit; s: real; t: real; r: real)>(z_MultiTexCoord3d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3d(target: TextureUnit; s: real; t: real; r: real) :=
    z_MultiTexCoord3d_1(target, s, t, r);
    
    // added in gl1.3, deprecated in gl3.2
    private z_MultiTexCoord3dv_adr := GetProcAddress('glMultiTexCoord3dv');
    private z_MultiTexCoord3dv_1 := GetProcOrNil&<procedure(target: TextureUnit; v: IntPtr)>(z_MultiTexCoord3dv_adr);
    private z_MultiTexCoord3dv_2 := GetProcOrNil&<procedure(target: TextureUnit; var v: real)>(z_MultiTexCoord3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3dv(target: TextureUnit; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MultiTexCoord3dv_2(target, v[0]) else
        z_MultiTexCoord3dv_2(target, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3dv(target: TextureUnit; var v: real) :=
    z_MultiTexCoord3dv_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3dv(target: TextureUnit; v: IntPtr) :=
    z_MultiTexCoord3dv_1(target, v);
    
    // added in gl1.3, deprecated in gl3.2
    private z_MultiTexCoord3f_adr := GetProcAddress('glMultiTexCoord3f');
    private z_MultiTexCoord3f_1 := GetProcOrNil&<procedure(target: TextureUnit; s: single; t: single; r: single)>(z_MultiTexCoord3f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3f(target: TextureUnit; s: single; t: single; r: single) :=
    z_MultiTexCoord3f_1(target, s, t, r);
    
    // added in gl1.3, deprecated in gl3.2
    private z_MultiTexCoord3fv_adr := GetProcAddress('glMultiTexCoord3fv');
    private z_MultiTexCoord3fv_1 := GetProcOrNil&<procedure(target: TextureUnit; v: IntPtr)>(z_MultiTexCoord3fv_adr);
    private z_MultiTexCoord3fv_2 := GetProcOrNil&<procedure(target: TextureUnit; var v: single)>(z_MultiTexCoord3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3fv(target: TextureUnit; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MultiTexCoord3fv_2(target, v[0]) else
        z_MultiTexCoord3fv_2(target, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3fv(target: TextureUnit; var v: single) :=
    z_MultiTexCoord3fv_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3fv(target: TextureUnit; v: IntPtr) :=
    z_MultiTexCoord3fv_1(target, v);
    
    // added in gl1.3, deprecated in gl3.2
    private z_MultiTexCoord3i_adr := GetProcAddress('glMultiTexCoord3i');
    private z_MultiTexCoord3i_1 := GetProcOrNil&<procedure(target: TextureUnit; s: Int32; t: Int32; r: Int32)>(z_MultiTexCoord3i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3i(target: TextureUnit; s: Int32; t: Int32; r: Int32) :=
    z_MultiTexCoord3i_1(target, s, t, r);
    
    // added in gl1.3, deprecated in gl3.2
    private z_MultiTexCoord3iv_adr := GetProcAddress('glMultiTexCoord3iv');
    private z_MultiTexCoord3iv_1 := GetProcOrNil&<procedure(target: TextureUnit; v: IntPtr)>(z_MultiTexCoord3iv_adr);
    private z_MultiTexCoord3iv_2 := GetProcOrNil&<procedure(target: TextureUnit; var v: Int32)>(z_MultiTexCoord3iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3iv(target: TextureUnit; v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MultiTexCoord3iv_2(target, v[0]) else
        z_MultiTexCoord3iv_2(target, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3iv(target: TextureUnit; var v: Int32) :=
    z_MultiTexCoord3iv_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3iv(target: TextureUnit; v: IntPtr) :=
    z_MultiTexCoord3iv_1(target, v);
    
    // added in gl1.3, deprecated in gl3.2
    private z_MultiTexCoord3s_adr := GetProcAddress('glMultiTexCoord3s');
    private z_MultiTexCoord3s_1 := GetProcOrNil&<procedure(target: TextureUnit; s: Int16; t: Int16; r: Int16)>(z_MultiTexCoord3s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3s(target: TextureUnit; s: Int16; t: Int16; r: Int16) :=
    z_MultiTexCoord3s_1(target, s, t, r);
    
    // added in gl1.3, deprecated in gl3.2
    private z_MultiTexCoord3sv_adr := GetProcAddress('glMultiTexCoord3sv');
    private z_MultiTexCoord3sv_1 := GetProcOrNil&<procedure(target: TextureUnit; v: IntPtr)>(z_MultiTexCoord3sv_adr);
    private z_MultiTexCoord3sv_2 := GetProcOrNil&<procedure(target: TextureUnit; var v: Int16)>(z_MultiTexCoord3sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3sv(target: TextureUnit; v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MultiTexCoord3sv_2(target, v[0]) else
        z_MultiTexCoord3sv_2(target, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3sv(target: TextureUnit; var v: Int16) :=
    z_MultiTexCoord3sv_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3sv(target: TextureUnit; v: IntPtr) :=
    z_MultiTexCoord3sv_1(target, v);
    
    // added in gl1.3, deprecated in gl3.2
    private z_MultiTexCoord4d_adr := GetProcAddress('glMultiTexCoord4d');
    private z_MultiTexCoord4d_1 := GetProcOrNil&<procedure(target: TextureUnit; s: real; t: real; r: real; q: real)>(z_MultiTexCoord4d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4d(target: TextureUnit; s: real; t: real; r: real; q: real) :=
    z_MultiTexCoord4d_1(target, s, t, r, q);
    
    // added in gl1.3, deprecated in gl3.2
    private z_MultiTexCoord4dv_adr := GetProcAddress('glMultiTexCoord4dv');
    private z_MultiTexCoord4dv_1 := GetProcOrNil&<procedure(target: TextureUnit; v: IntPtr)>(z_MultiTexCoord4dv_adr);
    private z_MultiTexCoord4dv_2 := GetProcOrNil&<procedure(target: TextureUnit; var v: real)>(z_MultiTexCoord4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4dv(target: TextureUnit; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MultiTexCoord4dv_2(target, v[0]) else
        z_MultiTexCoord4dv_2(target, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4dv(target: TextureUnit; var v: real) :=
    z_MultiTexCoord4dv_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4dv(target: TextureUnit; v: IntPtr) :=
    z_MultiTexCoord4dv_1(target, v);
    
    // added in gl1.3, deprecated in gl3.2
    private z_MultiTexCoord4f_adr := GetProcAddress('glMultiTexCoord4f');
    private z_MultiTexCoord4f_1 := GetProcOrNil&<procedure(target: TextureUnit; s: single; t: single; r: single; q: single)>(z_MultiTexCoord4f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4f(target: TextureUnit; s: single; t: single; r: single; q: single) :=
    z_MultiTexCoord4f_1(target, s, t, r, q);
    
    // added in gl1.3, deprecated in gl3.2
    private z_MultiTexCoord4fv_adr := GetProcAddress('glMultiTexCoord4fv');
    private z_MultiTexCoord4fv_1 := GetProcOrNil&<procedure(target: TextureUnit; v: IntPtr)>(z_MultiTexCoord4fv_adr);
    private z_MultiTexCoord4fv_2 := GetProcOrNil&<procedure(target: TextureUnit; var v: single)>(z_MultiTexCoord4fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4fv(target: TextureUnit; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MultiTexCoord4fv_2(target, v[0]) else
        z_MultiTexCoord4fv_2(target, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4fv(target: TextureUnit; var v: single) :=
    z_MultiTexCoord4fv_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4fv(target: TextureUnit; v: IntPtr) :=
    z_MultiTexCoord4fv_1(target, v);
    
    // added in gl1.3, deprecated in gl3.2
    private z_MultiTexCoord4i_adr := GetProcAddress('glMultiTexCoord4i');
    private z_MultiTexCoord4i_1 := GetProcOrNil&<procedure(target: TextureUnit; s: Int32; t: Int32; r: Int32; q: Int32)>(z_MultiTexCoord4i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4i(target: TextureUnit; s: Int32; t: Int32; r: Int32; q: Int32) :=
    z_MultiTexCoord4i_1(target, s, t, r, q);
    
    // added in gl1.3, deprecated in gl3.2
    private z_MultiTexCoord4iv_adr := GetProcAddress('glMultiTexCoord4iv');
    private z_MultiTexCoord4iv_1 := GetProcOrNil&<procedure(target: TextureUnit; v: IntPtr)>(z_MultiTexCoord4iv_adr);
    private z_MultiTexCoord4iv_2 := GetProcOrNil&<procedure(target: TextureUnit; var v: Int32)>(z_MultiTexCoord4iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4iv(target: TextureUnit; v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MultiTexCoord4iv_2(target, v[0]) else
        z_MultiTexCoord4iv_2(target, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4iv(target: TextureUnit; var v: Int32) :=
    z_MultiTexCoord4iv_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4iv(target: TextureUnit; v: IntPtr) :=
    z_MultiTexCoord4iv_1(target, v);
    
    // added in gl1.3, deprecated in gl3.2
    private z_MultiTexCoord4s_adr := GetProcAddress('glMultiTexCoord4s');
    private z_MultiTexCoord4s_1 := GetProcOrNil&<procedure(target: TextureUnit; s: Int16; t: Int16; r: Int16; q: Int16)>(z_MultiTexCoord4s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4s(target: TextureUnit; s: Int16; t: Int16; r: Int16; q: Int16) :=
    z_MultiTexCoord4s_1(target, s, t, r, q);
    
    // added in gl1.3, deprecated in gl3.2
    private z_MultiTexCoord4sv_adr := GetProcAddress('glMultiTexCoord4sv');
    private z_MultiTexCoord4sv_1 := GetProcOrNil&<procedure(target: TextureUnit; v: IntPtr)>(z_MultiTexCoord4sv_adr);
    private z_MultiTexCoord4sv_2 := GetProcOrNil&<procedure(target: TextureUnit; var v: Int16)>(z_MultiTexCoord4sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4sv(target: TextureUnit; v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MultiTexCoord4sv_2(target, v[0]) else
        z_MultiTexCoord4sv_2(target, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4sv(target: TextureUnit; var v: Int16) :=
    z_MultiTexCoord4sv_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4sv(target: TextureUnit; v: IntPtr) :=
    z_MultiTexCoord4sv_1(target, v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_MultMatrixd_adr := GetProcAddress('glMultMatrixd');
    private z_MultMatrixd_1 := GetProcOrNil&<procedure(m: IntPtr)>(z_MultMatrixd_adr);
    private z_MultMatrixd_2 := GetProcOrNil&<procedure(var m: real)>(z_MultMatrixd_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultMatrixd(m: array of real);
    type Preal=^real;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_MultMatrixd_2(m[0]) else
        z_MultMatrixd_2(Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultMatrixd(var m: real) :=
    z_MultMatrixd_2(m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultMatrixd(m: IntPtr) :=
    z_MultMatrixd_1(m);
    
    // added in gl1.0, deprecated in gl3.2
    private z_MultMatrixf_adr := GetProcAddress('glMultMatrixf');
    private z_MultMatrixf_1 := GetProcOrNil&<procedure(m: IntPtr)>(z_MultMatrixf_adr);
    private z_MultMatrixf_2 := GetProcOrNil&<procedure(var m: single)>(z_MultMatrixf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultMatrixf(m: array of single);
    type Psingle=^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_MultMatrixf_2(m[0]) else
        z_MultMatrixf_2(Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultMatrixf(var m: single) :=
    z_MultMatrixf_2(m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultMatrixf(m: IntPtr) :=
    z_MultMatrixf_1(m);
    
    // added in gl1.3, deprecated in gl3.2
    private z_MultTransposeMatrixd_adr := GetProcAddress('glMultTransposeMatrixd');
    private z_MultTransposeMatrixd_1 := GetProcOrNil&<procedure(m: IntPtr)>(z_MultTransposeMatrixd_adr);
    private z_MultTransposeMatrixd_2 := GetProcOrNil&<procedure(var m: real)>(z_MultTransposeMatrixd_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixd(m: array of real);
    type Preal=^real;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_MultTransposeMatrixd_2(m[0]) else
        z_MultTransposeMatrixd_2(Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixd(var m: real) :=
    z_MultTransposeMatrixd_2(m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixd(m: IntPtr) :=
    z_MultTransposeMatrixd_1(m);
    
    // added in gl1.3, deprecated in gl3.2
    private z_MultTransposeMatrixf_adr := GetProcAddress('glMultTransposeMatrixf');
    private z_MultTransposeMatrixf_1 := GetProcOrNil&<procedure(m: IntPtr)>(z_MultTransposeMatrixf_adr);
    private z_MultTransposeMatrixf_2 := GetProcOrNil&<procedure(var m: single)>(z_MultTransposeMatrixf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixf(m: array of single);
    type Psingle=^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_MultTransposeMatrixf_2(m[0]) else
        z_MultTransposeMatrixf_2(Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixf(var m: single) :=
    z_MultTransposeMatrixf_2(m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixf(m: IntPtr) :=
    z_MultTransposeMatrixf_1(m);
    
    // added in gl1.0, deprecated in gl3.2
    private z_NewList_adr := GetProcAddress('glNewList');
    private z_NewList_1 := GetProcOrNil&<procedure(list: UInt32; mode: ListMode)>(z_NewList_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NewList(list: UInt32; mode: ListMode) :=
    z_NewList_1(list, mode);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Normal3b_adr := GetProcAddress('glNormal3b');
    private z_Normal3b_1 := GetProcOrNil&<procedure(nx: SByte; ny: SByte; nz: SByte)>(z_Normal3b_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3b(nx: SByte; ny: SByte; nz: SByte) :=
    z_Normal3b_1(nx, ny, nz);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Normal3bv_adr := GetProcAddress('glNormal3bv');
    private z_Normal3bv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Normal3bv_adr);
    private z_Normal3bv_2 := GetProcOrNil&<procedure(var v: SByte)>(z_Normal3bv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3bv(v: array of SByte);
    type PSByte=^SByte;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Normal3bv_2(v[0]) else
        z_Normal3bv_2(PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3bv(var v: SByte) :=
    z_Normal3bv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3bv(v: IntPtr) :=
    z_Normal3bv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Normal3d_adr := GetProcAddress('glNormal3d');
    private z_Normal3d_1 := GetProcOrNil&<procedure(nx: real; ny: real; nz: real)>(z_Normal3d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3d(nx: real; ny: real; nz: real) :=
    z_Normal3d_1(nx, ny, nz);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Normal3dv_adr := GetProcAddress('glNormal3dv');
    private z_Normal3dv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Normal3dv_adr);
    private z_Normal3dv_2 := GetProcOrNil&<procedure(var v: real)>(z_Normal3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3dv(v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Normal3dv_2(v[0]) else
        z_Normal3dv_2(Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3dv(var v: real) :=
    z_Normal3dv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3dv(v: IntPtr) :=
    z_Normal3dv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Normal3f_adr := GetProcAddress('glNormal3f');
    private z_Normal3f_1 := GetProcOrNil&<procedure(nx: single; ny: single; nz: single)>(z_Normal3f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3f(nx: single; ny: single; nz: single) :=
    z_Normal3f_1(nx, ny, nz);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Normal3fv_adr := GetProcAddress('glNormal3fv');
    private z_Normal3fv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Normal3fv_adr);
    private z_Normal3fv_2 := GetProcOrNil&<procedure(var v: single)>(z_Normal3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fv(v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Normal3fv_2(v[0]) else
        z_Normal3fv_2(Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fv(var v: single) :=
    z_Normal3fv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fv(v: IntPtr) :=
    z_Normal3fv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Normal3i_adr := GetProcAddress('glNormal3i');
    private z_Normal3i_1 := GetProcOrNil&<procedure(nx: Int32; ny: Int32; nz: Int32)>(z_Normal3i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3i(nx: Int32; ny: Int32; nz: Int32) :=
    z_Normal3i_1(nx, ny, nz);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Normal3iv_adr := GetProcAddress('glNormal3iv');
    private z_Normal3iv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Normal3iv_adr);
    private z_Normal3iv_2 := GetProcOrNil&<procedure(var v: Int32)>(z_Normal3iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3iv(v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Normal3iv_2(v[0]) else
        z_Normal3iv_2(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3iv(var v: Int32) :=
    z_Normal3iv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3iv(v: IntPtr) :=
    z_Normal3iv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Normal3s_adr := GetProcAddress('glNormal3s');
    private z_Normal3s_1 := GetProcOrNil&<procedure(nx: Int16; ny: Int16; nz: Int16)>(z_Normal3s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3s(nx: Int16; ny: Int16; nz: Int16) :=
    z_Normal3s_1(nx, ny, nz);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Normal3sv_adr := GetProcAddress('glNormal3sv');
    private z_Normal3sv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Normal3sv_adr);
    private z_Normal3sv_2 := GetProcOrNil&<procedure(var v: Int16)>(z_Normal3sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3sv(v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Normal3sv_2(v[0]) else
        z_Normal3sv_2(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3sv(var v: Int16) :=
    z_Normal3sv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3sv(v: IntPtr) :=
    z_Normal3sv_1(v);
    
    // added in gl1.1, deprecated in gl3.2
    private z_NormalPointer_adr := GetProcAddress('glNormalPointer');
    private z_NormalPointer_1 := GetProcOrNil&<procedure(&type: NormalPointerType; stride: Int32; pointer: IntPtr)>(z_NormalPointer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalPointer(&type: NormalPointerType; stride: Int32; pointer: IntPtr) :=
    z_NormalPointer_1(&type, stride, pointer);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Ortho_adr := GetProcAddress('glOrtho');
    private z_Ortho_1 := GetProcOrNil&<procedure(left: real; right: real; bottom: real; top: real; zNear: real; zFar: real)>(z_Ortho_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Ortho(left: real; right: real; bottom: real; top: real; zNear: real; zFar: real) :=
    z_Ortho_1(left, right, bottom, top, zNear, zFar);
    
    // added in gl1.0, deprecated in gl3.2
    private z_PassThrough_adr := GetProcAddress('glPassThrough');
    private z_PassThrough_1 := GetProcOrNil&<procedure(token: single)>(z_PassThrough_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PassThrough(token: single) :=
    z_PassThrough_1(token);
    
    // added in gl1.0, deprecated in gl3.2
    private z_PixelMapfv_adr := GetProcAddress('glPixelMapfv');
    private z_PixelMapfv_1 := GetProcOrNil&<procedure(map: PixelMap; mapsize: Int32; values: IntPtr)>(z_PixelMapfv_adr);
    private z_PixelMapfv_2 := GetProcOrNil&<procedure(map: PixelMap; mapsize: Int32; var values: single)>(z_PixelMapfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelMapfv(map: PixelMap; mapsize: Int32; values: array of single);
    type Psingle=^single;
    begin
      if (values<>nil) and (values.Length<>0) then
        z_PixelMapfv_2(map, mapsize, values[0]) else
        z_PixelMapfv_2(map, mapsize, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelMapfv(map: PixelMap; mapsize: Int32; var values: single) :=
    z_PixelMapfv_2(map, mapsize, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelMapfv(map: PixelMap; mapsize: Int32; values: IntPtr) :=
    z_PixelMapfv_1(map, mapsize, values);
    
    // added in gl1.0, deprecated in gl3.2
    private z_PixelMapuiv_adr := GetProcAddress('glPixelMapuiv');
    private z_PixelMapuiv_1 := GetProcOrNil&<procedure(map: PixelMap; mapsize: Int32; values: IntPtr)>(z_PixelMapuiv_adr);
    private z_PixelMapuiv_2 := GetProcOrNil&<procedure(map: PixelMap; mapsize: Int32; var values: UInt32)>(z_PixelMapuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelMapuiv(map: PixelMap; mapsize: Int32; values: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (values<>nil) and (values.Length<>0) then
        z_PixelMapuiv_2(map, mapsize, values[0]) else
        z_PixelMapuiv_2(map, mapsize, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelMapuiv(map: PixelMap; mapsize: Int32; var values: UInt32) :=
    z_PixelMapuiv_2(map, mapsize, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelMapuiv(map: PixelMap; mapsize: Int32; values: IntPtr) :=
    z_PixelMapuiv_1(map, mapsize, values);
    
    // added in gl1.0, deprecated in gl3.2
    private z_PixelMapusv_adr := GetProcAddress('glPixelMapusv');
    private z_PixelMapusv_1 := GetProcOrNil&<procedure(map: PixelMap; mapsize: Int32; values: IntPtr)>(z_PixelMapusv_adr);
    private z_PixelMapusv_2 := GetProcOrNil&<procedure(map: PixelMap; mapsize: Int32; var values: UInt16)>(z_PixelMapusv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelMapusv(map: PixelMap; mapsize: Int32; values: array of UInt16);
    type PUInt16=^UInt16;
    begin
      if (values<>nil) and (values.Length<>0) then
        z_PixelMapusv_2(map, mapsize, values[0]) else
        z_PixelMapusv_2(map, mapsize, PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelMapusv(map: PixelMap; mapsize: Int32; var values: UInt16) :=
    z_PixelMapusv_2(map, mapsize, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelMapusv(map: PixelMap; mapsize: Int32; values: IntPtr) :=
    z_PixelMapusv_1(map, mapsize, values);
    
    // added in gl1.0, deprecated in gl3.2
    private z_PixelTransferf_adr := GetProcAddress('glPixelTransferf');
    private z_PixelTransferf_1 := GetProcOrNil&<procedure(pname: PixelTransferParameter; param: single)>(z_PixelTransferf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransferf(pname: PixelTransferParameter; param: single) :=
    z_PixelTransferf_1(pname, param);
    
    // added in gl1.0, deprecated in gl3.2
    private z_PixelTransferi_adr := GetProcAddress('glPixelTransferi');
    private z_PixelTransferi_1 := GetProcOrNil&<procedure(pname: PixelTransferParameter; param: Int32)>(z_PixelTransferi_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransferi(pname: PixelTransferParameter; param: Int32) :=
    z_PixelTransferi_1(pname, param);
    
    // added in gl1.0, deprecated in gl3.2
    private z_PixelZoom_adr := GetProcAddress('glPixelZoom');
    private z_PixelZoom_1 := GetProcOrNil&<procedure(xfactor: single; yfactor: single)>(z_PixelZoom_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelZoom(xfactor: single; yfactor: single) :=
    z_PixelZoom_1(xfactor, yfactor);
    
    // added in gl1.0, deprecated in gl3.2
    private z_PolygonStipple_adr := GetProcAddress('glPolygonStipple');
    private z_PolygonStipple_1 := GetProcOrNil&<procedure(mask: IntPtr)>(z_PolygonStipple_adr);
    private z_PolygonStipple_2 := GetProcOrNil&<procedure(var mask: Byte)>(z_PolygonStipple_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PolygonStipple(mask: array of Byte);
    type PByte=^Byte;
    begin
      if (mask<>nil) and (mask.Length<>0) then
        z_PolygonStipple_2(mask[0]) else
        z_PolygonStipple_2(PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PolygonStipple(var mask: Byte) :=
    z_PolygonStipple_2(mask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PolygonStipple(mask: IntPtr) :=
    z_PolygonStipple_1(mask);
    
    // added in gl1.0, deprecated in gl3.2
    private z_PopAttrib_adr := GetProcAddress('glPopAttrib');
    private z_PopAttrib_1 := GetProcOrNil&<procedure>(z_PopAttrib_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PopAttrib :=
    z_PopAttrib_1();
    
    // added in gl1.1, deprecated in gl3.2
    private z_PopClientAttrib_adr := GetProcAddress('glPopClientAttrib');
    private z_PopClientAttrib_1 := GetProcOrNil&<procedure>(z_PopClientAttrib_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PopClientAttrib :=
    z_PopClientAttrib_1();
    
    // added in gl1.0, deprecated in gl3.2
    private z_PopMatrix_adr := GetProcAddress('glPopMatrix');
    private z_PopMatrix_1 := GetProcOrNil&<procedure>(z_PopMatrix_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PopMatrix :=
    z_PopMatrix_1();
    
    // added in gl1.0, deprecated in gl3.2
    private z_PopName_adr := GetProcAddress('glPopName');
    private z_PopName_1 := GetProcOrNil&<procedure>(z_PopName_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PopName :=
    z_PopName_1();
    
    // added in gl1.1, deprecated in gl3.2
    private z_PrioritizeTextures_adr := GetProcAddress('glPrioritizeTextures');
    private z_PrioritizeTextures_1 := GetProcOrNil&<procedure(n: Int32; textures: IntPtr; priorities: IntPtr)>(z_PrioritizeTextures_adr);
    private z_PrioritizeTextures_2 := GetProcOrNil&<procedure(n: Int32; textures: IntPtr; var priorities: single)>(z_PrioritizeTextures_adr);
    private z_PrioritizeTextures_3 := GetProcOrNil&<procedure(n: Int32; var textures: gl_texture; priorities: IntPtr)>(z_PrioritizeTextures_adr);
    private z_PrioritizeTextures_4 := GetProcOrNil&<procedure(n: Int32; var textures: gl_texture; var priorities: single)>(z_PrioritizeTextures_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTextures(n: Int32; textures: array of gl_texture; priorities: array of single);
    type Pgl_texture=^gl_texture;
    type Psingle=^single;
    begin
      if (priorities<>nil) and (priorities.Length<>0) then
        if (textures<>nil) and (textures.Length<>0) then
          z_PrioritizeTextures_4(n, textures[0], priorities[0]) else
          z_PrioritizeTextures_4(n, Pgl_texture(nil)^, priorities[0]) else
        if (textures<>nil) and (textures.Length<>0) then
          z_PrioritizeTextures_4(n, textures[0], Psingle(nil)^) else
          z_PrioritizeTextures_4(n, Pgl_texture(nil)^, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTextures(n: Int32; var textures: gl_texture; var priorities: single) :=
    z_PrioritizeTextures_4(n, textures, priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTextures(n: Int32; var textures: gl_texture; priorities: IntPtr) :=
    z_PrioritizeTextures_3(n, textures, priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTextures(n: Int32; textures: IntPtr; var priorities: single) :=
    z_PrioritizeTextures_2(n, textures, priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTextures(n: Int32; textures: IntPtr; priorities: IntPtr) :=
    z_PrioritizeTextures_1(n, textures, priorities);
    
    // added in gl1.0, deprecated in gl3.2
    private z_PushAttrib_adr := GetProcAddress('glPushAttrib');
    private z_PushAttrib_1 := GetProcOrNil&<procedure(mask: AttribMask)>(z_PushAttrib_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PushAttrib(mask: AttribMask) :=
    z_PushAttrib_1(mask);
    
    // added in gl1.1, deprecated in gl3.2
    private z_PushClientAttrib_adr := GetProcAddress('glPushClientAttrib');
    private z_PushClientAttrib_1 := GetProcOrNil&<procedure(mask: ClientAttribMask)>(z_PushClientAttrib_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PushClientAttrib(mask: ClientAttribMask) :=
    z_PushClientAttrib_1(mask);
    
    // added in gl1.0, deprecated in gl3.2
    private z_PushMatrix_adr := GetProcAddress('glPushMatrix');
    private z_PushMatrix_1 := GetProcOrNil&<procedure>(z_PushMatrix_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PushMatrix :=
    z_PushMatrix_1();
    
    // added in gl1.0, deprecated in gl3.2
    private z_PushName_adr := GetProcAddress('glPushName');
    private z_PushName_1 := GetProcOrNil&<procedure(name: UInt32)>(z_PushName_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PushName(name: UInt32) :=
    z_PushName_1(name);
    
    // added in gl1.0, deprecated in gl3.2
    private z_RasterPos2d_adr := GetProcAddress('glRasterPos2d');
    private z_RasterPos2d_1 := GetProcOrNil&<procedure(x: real; y: real)>(z_RasterPos2d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2d(x: real; y: real) :=
    z_RasterPos2d_1(x, y);
    
    // added in gl1.0, deprecated in gl3.2
    private z_RasterPos2dv_adr := GetProcAddress('glRasterPos2dv');
    private z_RasterPos2dv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_RasterPos2dv_adr);
    private z_RasterPos2dv_2 := GetProcOrNil&<procedure(var v: real)>(z_RasterPos2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2dv(v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_RasterPos2dv_2(v[0]) else
        z_RasterPos2dv_2(Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2dv(var v: real) :=
    z_RasterPos2dv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2dv(v: IntPtr) :=
    z_RasterPos2dv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_RasterPos2f_adr := GetProcAddress('glRasterPos2f');
    private z_RasterPos2f_1 := GetProcOrNil&<procedure(x: single; y: single)>(z_RasterPos2f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2f(x: single; y: single) :=
    z_RasterPos2f_1(x, y);
    
    // added in gl1.0, deprecated in gl3.2
    private z_RasterPos2fv_adr := GetProcAddress('glRasterPos2fv');
    private z_RasterPos2fv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_RasterPos2fv_adr);
    private z_RasterPos2fv_2 := GetProcOrNil&<procedure(var v: single)>(z_RasterPos2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2fv(v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_RasterPos2fv_2(v[0]) else
        z_RasterPos2fv_2(Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2fv(var v: single) :=
    z_RasterPos2fv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2fv(v: IntPtr) :=
    z_RasterPos2fv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_RasterPos2i_adr := GetProcAddress('glRasterPos2i');
    private z_RasterPos2i_1 := GetProcOrNil&<procedure(x: Int32; y: Int32)>(z_RasterPos2i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2i(x: Int32; y: Int32) :=
    z_RasterPos2i_1(x, y);
    
    // added in gl1.0, deprecated in gl3.2
    private z_RasterPos2iv_adr := GetProcAddress('glRasterPos2iv');
    private z_RasterPos2iv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_RasterPos2iv_adr);
    private z_RasterPos2iv_2 := GetProcOrNil&<procedure(var v: Int32)>(z_RasterPos2iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2iv(v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_RasterPos2iv_2(v[0]) else
        z_RasterPos2iv_2(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2iv(var v: Int32) :=
    z_RasterPos2iv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2iv(v: IntPtr) :=
    z_RasterPos2iv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_RasterPos2s_adr := GetProcAddress('glRasterPos2s');
    private z_RasterPos2s_1 := GetProcOrNil&<procedure(x: Int16; y: Int16)>(z_RasterPos2s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2s(x: Int16; y: Int16) :=
    z_RasterPos2s_1(x, y);
    
    // added in gl1.0, deprecated in gl3.2
    private z_RasterPos2sv_adr := GetProcAddress('glRasterPos2sv');
    private z_RasterPos2sv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_RasterPos2sv_adr);
    private z_RasterPos2sv_2 := GetProcOrNil&<procedure(var v: Int16)>(z_RasterPos2sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2sv(v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_RasterPos2sv_2(v[0]) else
        z_RasterPos2sv_2(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2sv(var v: Int16) :=
    z_RasterPos2sv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2sv(v: IntPtr) :=
    z_RasterPos2sv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_RasterPos3d_adr := GetProcAddress('glRasterPos3d');
    private z_RasterPos3d_1 := GetProcOrNil&<procedure(x: real; y: real; z: real)>(z_RasterPos3d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3d(x: real; y: real; z: real) :=
    z_RasterPos3d_1(x, y, z);
    
    // added in gl1.0, deprecated in gl3.2
    private z_RasterPos3dv_adr := GetProcAddress('glRasterPos3dv');
    private z_RasterPos3dv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_RasterPos3dv_adr);
    private z_RasterPos3dv_2 := GetProcOrNil&<procedure(var v: real)>(z_RasterPos3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3dv(v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_RasterPos3dv_2(v[0]) else
        z_RasterPos3dv_2(Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3dv(var v: real) :=
    z_RasterPos3dv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3dv(v: IntPtr) :=
    z_RasterPos3dv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_RasterPos3f_adr := GetProcAddress('glRasterPos3f');
    private z_RasterPos3f_1 := GetProcOrNil&<procedure(x: single; y: single; z: single)>(z_RasterPos3f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3f(x: single; y: single; z: single) :=
    z_RasterPos3f_1(x, y, z);
    
    // added in gl1.0, deprecated in gl3.2
    private z_RasterPos3fv_adr := GetProcAddress('glRasterPos3fv');
    private z_RasterPos3fv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_RasterPos3fv_adr);
    private z_RasterPos3fv_2 := GetProcOrNil&<procedure(var v: single)>(z_RasterPos3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3fv(v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_RasterPos3fv_2(v[0]) else
        z_RasterPos3fv_2(Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3fv(var v: single) :=
    z_RasterPos3fv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3fv(v: IntPtr) :=
    z_RasterPos3fv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_RasterPos3i_adr := GetProcAddress('glRasterPos3i');
    private z_RasterPos3i_1 := GetProcOrNil&<procedure(x: Int32; y: Int32; z: Int32)>(z_RasterPos3i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3i(x: Int32; y: Int32; z: Int32) :=
    z_RasterPos3i_1(x, y, z);
    
    // added in gl1.0, deprecated in gl3.2
    private z_RasterPos3iv_adr := GetProcAddress('glRasterPos3iv');
    private z_RasterPos3iv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_RasterPos3iv_adr);
    private z_RasterPos3iv_2 := GetProcOrNil&<procedure(var v: Int32)>(z_RasterPos3iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3iv(v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_RasterPos3iv_2(v[0]) else
        z_RasterPos3iv_2(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3iv(var v: Int32) :=
    z_RasterPos3iv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3iv(v: IntPtr) :=
    z_RasterPos3iv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_RasterPos3s_adr := GetProcAddress('glRasterPos3s');
    private z_RasterPos3s_1 := GetProcOrNil&<procedure(x: Int16; y: Int16; z: Int16)>(z_RasterPos3s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3s(x: Int16; y: Int16; z: Int16) :=
    z_RasterPos3s_1(x, y, z);
    
    // added in gl1.0, deprecated in gl3.2
    private z_RasterPos3sv_adr := GetProcAddress('glRasterPos3sv');
    private z_RasterPos3sv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_RasterPos3sv_adr);
    private z_RasterPos3sv_2 := GetProcOrNil&<procedure(var v: Int16)>(z_RasterPos3sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3sv(v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_RasterPos3sv_2(v[0]) else
        z_RasterPos3sv_2(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3sv(var v: Int16) :=
    z_RasterPos3sv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3sv(v: IntPtr) :=
    z_RasterPos3sv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_RasterPos4d_adr := GetProcAddress('glRasterPos4d');
    private z_RasterPos4d_1 := GetProcOrNil&<procedure(x: real; y: real; z: real; w: real)>(z_RasterPos4d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4d(x: real; y: real; z: real; w: real) :=
    z_RasterPos4d_1(x, y, z, w);
    
    // added in gl1.0, deprecated in gl3.2
    private z_RasterPos4dv_adr := GetProcAddress('glRasterPos4dv');
    private z_RasterPos4dv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_RasterPos4dv_adr);
    private z_RasterPos4dv_2 := GetProcOrNil&<procedure(var v: real)>(z_RasterPos4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4dv(v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_RasterPos4dv_2(v[0]) else
        z_RasterPos4dv_2(Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4dv(var v: real) :=
    z_RasterPos4dv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4dv(v: IntPtr) :=
    z_RasterPos4dv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_RasterPos4f_adr := GetProcAddress('glRasterPos4f');
    private z_RasterPos4f_1 := GetProcOrNil&<procedure(x: single; y: single; z: single; w: single)>(z_RasterPos4f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4f(x: single; y: single; z: single; w: single) :=
    z_RasterPos4f_1(x, y, z, w);
    
    // added in gl1.0, deprecated in gl3.2
    private z_RasterPos4fv_adr := GetProcAddress('glRasterPos4fv');
    private z_RasterPos4fv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_RasterPos4fv_adr);
    private z_RasterPos4fv_2 := GetProcOrNil&<procedure(var v: single)>(z_RasterPos4fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4fv(v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_RasterPos4fv_2(v[0]) else
        z_RasterPos4fv_2(Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4fv(var v: single) :=
    z_RasterPos4fv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4fv(v: IntPtr) :=
    z_RasterPos4fv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_RasterPos4i_adr := GetProcAddress('glRasterPos4i');
    private z_RasterPos4i_1 := GetProcOrNil&<procedure(x: Int32; y: Int32; z: Int32; w: Int32)>(z_RasterPos4i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4i(x: Int32; y: Int32; z: Int32; w: Int32) :=
    z_RasterPos4i_1(x, y, z, w);
    
    // added in gl1.0, deprecated in gl3.2
    private z_RasterPos4iv_adr := GetProcAddress('glRasterPos4iv');
    private z_RasterPos4iv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_RasterPos4iv_adr);
    private z_RasterPos4iv_2 := GetProcOrNil&<procedure(var v: Int32)>(z_RasterPos4iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4iv(v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_RasterPos4iv_2(v[0]) else
        z_RasterPos4iv_2(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4iv(var v: Int32) :=
    z_RasterPos4iv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4iv(v: IntPtr) :=
    z_RasterPos4iv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_RasterPos4s_adr := GetProcAddress('glRasterPos4s');
    private z_RasterPos4s_1 := GetProcOrNil&<procedure(x: Int16; y: Int16; z: Int16; w: Int16)>(z_RasterPos4s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4s(x: Int16; y: Int16; z: Int16; w: Int16) :=
    z_RasterPos4s_1(x, y, z, w);
    
    // added in gl1.0, deprecated in gl3.2
    private z_RasterPos4sv_adr := GetProcAddress('glRasterPos4sv');
    private z_RasterPos4sv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_RasterPos4sv_adr);
    private z_RasterPos4sv_2 := GetProcOrNil&<procedure(var v: Int16)>(z_RasterPos4sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4sv(v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_RasterPos4sv_2(v[0]) else
        z_RasterPos4sv_2(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4sv(var v: Int16) :=
    z_RasterPos4sv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4sv(v: IntPtr) :=
    z_RasterPos4sv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Rectd_adr := GetProcAddress('glRectd');
    private z_Rectd_1 := GetProcOrNil&<procedure(x1: real; y1: real; x2: real; y2: real)>(z_Rectd_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectd(x1: real; y1: real; x2: real; y2: real) :=
    z_Rectd_1(x1, y1, x2, y2);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Rectdv_adr := GetProcAddress('glRectdv');
    private z_Rectdv_1 := GetProcOrNil&<procedure(v1: IntPtr; v2: IntPtr)>(z_Rectdv_adr);
    private z_Rectdv_2 := GetProcOrNil&<procedure(v1: IntPtr; var v2: real)>(z_Rectdv_adr);
    private z_Rectdv_3 := GetProcOrNil&<procedure(var v1: real; v2: IntPtr)>(z_Rectdv_adr);
    private z_Rectdv_4 := GetProcOrNil&<procedure(var v1: real; var v2: real)>(z_Rectdv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectdv(v1: array of real; v2: array of real);
    type Preal=^real;
    begin
      if (v2<>nil) and (v2.Length<>0) then
        if (v1<>nil) and (v1.Length<>0) then
          z_Rectdv_4(v1[0], v2[0]) else
          z_Rectdv_4(Preal(nil)^, v2[0]) else
        if (v1<>nil) and (v1.Length<>0) then
          z_Rectdv_4(v1[0], Preal(nil)^) else
          z_Rectdv_4(Preal(nil)^, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectdv(var v1: real; var v2: real) :=
    z_Rectdv_4(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectdv(var v1: real; v2: IntPtr) :=
    z_Rectdv_3(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectdv(v1: IntPtr; var v2: real) :=
    z_Rectdv_2(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectdv(v1: IntPtr; v2: IntPtr) :=
    z_Rectdv_1(v1, v2);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Rectf_adr := GetProcAddress('glRectf');
    private z_Rectf_1 := GetProcOrNil&<procedure(x1: single; y1: single; x2: single; y2: single)>(z_Rectf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectf(x1: single; y1: single; x2: single; y2: single) :=
    z_Rectf_1(x1, y1, x2, y2);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Rectfv_adr := GetProcAddress('glRectfv');
    private z_Rectfv_1 := GetProcOrNil&<procedure(v1: IntPtr; v2: IntPtr)>(z_Rectfv_adr);
    private z_Rectfv_2 := GetProcOrNil&<procedure(v1: IntPtr; var v2: single)>(z_Rectfv_adr);
    private z_Rectfv_3 := GetProcOrNil&<procedure(var v1: single; v2: IntPtr)>(z_Rectfv_adr);
    private z_Rectfv_4 := GetProcOrNil&<procedure(var v1: single; var v2: single)>(z_Rectfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectfv(v1: array of single; v2: array of single);
    type Psingle=^single;
    begin
      if (v2<>nil) and (v2.Length<>0) then
        if (v1<>nil) and (v1.Length<>0) then
          z_Rectfv_4(v1[0], v2[0]) else
          z_Rectfv_4(Psingle(nil)^, v2[0]) else
        if (v1<>nil) and (v1.Length<>0) then
          z_Rectfv_4(v1[0], Psingle(nil)^) else
          z_Rectfv_4(Psingle(nil)^, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectfv(var v1: single; var v2: single) :=
    z_Rectfv_4(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectfv(var v1: single; v2: IntPtr) :=
    z_Rectfv_3(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectfv(v1: IntPtr; var v2: single) :=
    z_Rectfv_2(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectfv(v1: IntPtr; v2: IntPtr) :=
    z_Rectfv_1(v1, v2);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Recti_adr := GetProcAddress('glRecti');
    private z_Recti_1 := GetProcOrNil&<procedure(x1: Int32; y1: Int32; x2: Int32; y2: Int32)>(z_Recti_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Recti(x1: Int32; y1: Int32; x2: Int32; y2: Int32) :=
    z_Recti_1(x1, y1, x2, y2);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Rectiv_adr := GetProcAddress('glRectiv');
    private z_Rectiv_1 := GetProcOrNil&<procedure(v1: IntPtr; v2: IntPtr)>(z_Rectiv_adr);
    private z_Rectiv_2 := GetProcOrNil&<procedure(v1: IntPtr; var v2: Int32)>(z_Rectiv_adr);
    private z_Rectiv_3 := GetProcOrNil&<procedure(var v1: Int32; v2: IntPtr)>(z_Rectiv_adr);
    private z_Rectiv_4 := GetProcOrNil&<procedure(var v1: Int32; var v2: Int32)>(z_Rectiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectiv(v1: array of Int32; v2: array of Int32);
    type PInt32=^Int32;
    begin
      if (v2<>nil) and (v2.Length<>0) then
        if (v1<>nil) and (v1.Length<>0) then
          z_Rectiv_4(v1[0], v2[0]) else
          z_Rectiv_4(PInt32(nil)^, v2[0]) else
        if (v1<>nil) and (v1.Length<>0) then
          z_Rectiv_4(v1[0], PInt32(nil)^) else
          z_Rectiv_4(PInt32(nil)^, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectiv(var v1: Int32; var v2: Int32) :=
    z_Rectiv_4(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectiv(var v1: Int32; v2: IntPtr) :=
    z_Rectiv_3(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectiv(v1: IntPtr; var v2: Int32) :=
    z_Rectiv_2(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectiv(v1: IntPtr; v2: IntPtr) :=
    z_Rectiv_1(v1, v2);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Rects_adr := GetProcAddress('glRects');
    private z_Rects_1 := GetProcOrNil&<procedure(x1: Int16; y1: Int16; x2: Int16; y2: Int16)>(z_Rects_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rects(x1: Int16; y1: Int16; x2: Int16; y2: Int16) :=
    z_Rects_1(x1, y1, x2, y2);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Rectsv_adr := GetProcAddress('glRectsv');
    private z_Rectsv_1 := GetProcOrNil&<procedure(v1: IntPtr; v2: IntPtr)>(z_Rectsv_adr);
    private z_Rectsv_2 := GetProcOrNil&<procedure(v1: IntPtr; var v2: Int16)>(z_Rectsv_adr);
    private z_Rectsv_3 := GetProcOrNil&<procedure(var v1: Int16; v2: IntPtr)>(z_Rectsv_adr);
    private z_Rectsv_4 := GetProcOrNil&<procedure(var v1: Int16; var v2: Int16)>(z_Rectsv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectsv(v1: array of Int16; v2: array of Int16);
    type PInt16=^Int16;
    begin
      if (v2<>nil) and (v2.Length<>0) then
        if (v1<>nil) and (v1.Length<>0) then
          z_Rectsv_4(v1[0], v2[0]) else
          z_Rectsv_4(PInt16(nil)^, v2[0]) else
        if (v1<>nil) and (v1.Length<>0) then
          z_Rectsv_4(v1[0], PInt16(nil)^) else
          z_Rectsv_4(PInt16(nil)^, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectsv(var v1: Int16; var v2: Int16) :=
    z_Rectsv_4(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectsv(var v1: Int16; v2: IntPtr) :=
    z_Rectsv_3(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectsv(v1: IntPtr; var v2: Int16) :=
    z_Rectsv_2(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectsv(v1: IntPtr; v2: IntPtr) :=
    z_Rectsv_1(v1, v2);
    
    // added in gl1.0, deprecated in gl3.2
    private z_RenderMode_adr := GetProcAddress('glRenderMode');
    private z_RenderMode_1 := GetProcOrNil&<function(mode: RenderingMode): Int32>(z_RenderMode_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function RenderMode(mode: RenderingMode): Int32 :=
    z_RenderMode_1(mode);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Rotated_adr := GetProcAddress('glRotated');
    private z_Rotated_1 := GetProcOrNil&<procedure(angle: real; x: real; y: real; z: real)>(z_Rotated_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rotated(angle: real; x: real; y: real; z: real) :=
    z_Rotated_1(angle, x, y, z);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Rotatef_adr := GetProcAddress('glRotatef');
    private z_Rotatef_1 := GetProcOrNil&<procedure(angle: single; x: single; y: single; z: single)>(z_Rotatef_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rotatef(angle: single; x: single; y: single; z: single) :=
    z_Rotatef_1(angle, x, y, z);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Scaled_adr := GetProcAddress('glScaled');
    private z_Scaled_1 := GetProcOrNil&<procedure(x: real; y: real; z: real)>(z_Scaled_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Scaled(x: real; y: real; z: real) :=
    z_Scaled_1(x, y, z);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Scalef_adr := GetProcAddress('glScalef');
    private z_Scalef_1 := GetProcOrNil&<procedure(x: single; y: single; z: single)>(z_Scalef_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Scalef(x: single; y: single; z: single) :=
    z_Scalef_1(x, y, z);
    
    // added in gl1.4, deprecated in gl3.2
    private z_SecondaryColor3b_adr := GetProcAddress('glSecondaryColor3b');
    private z_SecondaryColor3b_1 := GetProcOrNil&<procedure(red: SByte; green: SByte; blue: SByte)>(z_SecondaryColor3b_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3b(red: SByte; green: SByte; blue: SByte) :=
    z_SecondaryColor3b_1(red, green, blue);
    
    // added in gl1.4, deprecated in gl3.2
    private z_SecondaryColor3bv_adr := GetProcAddress('glSecondaryColor3bv');
    private z_SecondaryColor3bv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_SecondaryColor3bv_adr);
    private z_SecondaryColor3bv_2 := GetProcOrNil&<procedure(var v: SByte)>(z_SecondaryColor3bv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3bv(v: array of SByte);
    type PSByte=^SByte;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_SecondaryColor3bv_2(v[0]) else
        z_SecondaryColor3bv_2(PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3bv(var v: SByte) :=
    z_SecondaryColor3bv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3bv(v: IntPtr) :=
    z_SecondaryColor3bv_1(v);
    
    // added in gl1.4, deprecated in gl3.2
    private z_SecondaryColor3d_adr := GetProcAddress('glSecondaryColor3d');
    private z_SecondaryColor3d_1 := GetProcOrNil&<procedure(red: real; green: real; blue: real)>(z_SecondaryColor3d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3d(red: real; green: real; blue: real) :=
    z_SecondaryColor3d_1(red, green, blue);
    
    // added in gl1.4, deprecated in gl3.2
    private z_SecondaryColor3dv_adr := GetProcAddress('glSecondaryColor3dv');
    private z_SecondaryColor3dv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_SecondaryColor3dv_adr);
    private z_SecondaryColor3dv_2 := GetProcOrNil&<procedure(var v: real)>(z_SecondaryColor3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3dv(v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_SecondaryColor3dv_2(v[0]) else
        z_SecondaryColor3dv_2(Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3dv(var v: real) :=
    z_SecondaryColor3dv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3dv(v: IntPtr) :=
    z_SecondaryColor3dv_1(v);
    
    // added in gl1.4, deprecated in gl3.2
    private z_SecondaryColor3f_adr := GetProcAddress('glSecondaryColor3f');
    private z_SecondaryColor3f_1 := GetProcOrNil&<procedure(red: single; green: single; blue: single)>(z_SecondaryColor3f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3f(red: single; green: single; blue: single) :=
    z_SecondaryColor3f_1(red, green, blue);
    
    // added in gl1.4, deprecated in gl3.2
    private z_SecondaryColor3fv_adr := GetProcAddress('glSecondaryColor3fv');
    private z_SecondaryColor3fv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_SecondaryColor3fv_adr);
    private z_SecondaryColor3fv_2 := GetProcOrNil&<procedure(var v: single)>(z_SecondaryColor3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3fv(v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_SecondaryColor3fv_2(v[0]) else
        z_SecondaryColor3fv_2(Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3fv(var v: single) :=
    z_SecondaryColor3fv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3fv(v: IntPtr) :=
    z_SecondaryColor3fv_1(v);
    
    // added in gl1.4, deprecated in gl3.2
    private z_SecondaryColor3i_adr := GetProcAddress('glSecondaryColor3i');
    private z_SecondaryColor3i_1 := GetProcOrNil&<procedure(red: Int32; green: Int32; blue: Int32)>(z_SecondaryColor3i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3i(red: Int32; green: Int32; blue: Int32) :=
    z_SecondaryColor3i_1(red, green, blue);
    
    // added in gl1.4, deprecated in gl3.2
    private z_SecondaryColor3iv_adr := GetProcAddress('glSecondaryColor3iv');
    private z_SecondaryColor3iv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_SecondaryColor3iv_adr);
    private z_SecondaryColor3iv_2 := GetProcOrNil&<procedure(var v: Int32)>(z_SecondaryColor3iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3iv(v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_SecondaryColor3iv_2(v[0]) else
        z_SecondaryColor3iv_2(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3iv(var v: Int32) :=
    z_SecondaryColor3iv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3iv(v: IntPtr) :=
    z_SecondaryColor3iv_1(v);
    
    // added in gl1.4, deprecated in gl3.2
    private z_SecondaryColor3s_adr := GetProcAddress('glSecondaryColor3s');
    private z_SecondaryColor3s_1 := GetProcOrNil&<procedure(red: Int16; green: Int16; blue: Int16)>(z_SecondaryColor3s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3s(red: Int16; green: Int16; blue: Int16) :=
    z_SecondaryColor3s_1(red, green, blue);
    
    // added in gl1.4, deprecated in gl3.2
    private z_SecondaryColor3sv_adr := GetProcAddress('glSecondaryColor3sv');
    private z_SecondaryColor3sv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_SecondaryColor3sv_adr);
    private z_SecondaryColor3sv_2 := GetProcOrNil&<procedure(var v: Int16)>(z_SecondaryColor3sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3sv(v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_SecondaryColor3sv_2(v[0]) else
        z_SecondaryColor3sv_2(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3sv(var v: Int16) :=
    z_SecondaryColor3sv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3sv(v: IntPtr) :=
    z_SecondaryColor3sv_1(v);
    
    // added in gl1.4, deprecated in gl3.2
    private z_SecondaryColor3ub_adr := GetProcAddress('glSecondaryColor3ub');
    private z_SecondaryColor3ub_1 := GetProcOrNil&<procedure(red: Byte; green: Byte; blue: Byte)>(z_SecondaryColor3ub_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ub(red: Byte; green: Byte; blue: Byte) :=
    z_SecondaryColor3ub_1(red, green, blue);
    
    // added in gl1.4, deprecated in gl3.2
    private z_SecondaryColor3ubv_adr := GetProcAddress('glSecondaryColor3ubv');
    private z_SecondaryColor3ubv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_SecondaryColor3ubv_adr);
    private z_SecondaryColor3ubv_2 := GetProcOrNil&<procedure(var v: Byte)>(z_SecondaryColor3ubv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ubv(v: array of Byte);
    type PByte=^Byte;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_SecondaryColor3ubv_2(v[0]) else
        z_SecondaryColor3ubv_2(PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ubv(var v: Byte) :=
    z_SecondaryColor3ubv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ubv(v: IntPtr) :=
    z_SecondaryColor3ubv_1(v);
    
    // added in gl1.4, deprecated in gl3.2
    private z_SecondaryColor3ui_adr := GetProcAddress('glSecondaryColor3ui');
    private z_SecondaryColor3ui_1 := GetProcOrNil&<procedure(red: UInt32; green: UInt32; blue: UInt32)>(z_SecondaryColor3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ui(red: UInt32; green: UInt32; blue: UInt32) :=
    z_SecondaryColor3ui_1(red, green, blue);
    
    // added in gl1.4, deprecated in gl3.2
    private z_SecondaryColor3uiv_adr := GetProcAddress('glSecondaryColor3uiv');
    private z_SecondaryColor3uiv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_SecondaryColor3uiv_adr);
    private z_SecondaryColor3uiv_2 := GetProcOrNil&<procedure(var v: UInt32)>(z_SecondaryColor3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3uiv(v: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_SecondaryColor3uiv_2(v[0]) else
        z_SecondaryColor3uiv_2(PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3uiv(var v: UInt32) :=
    z_SecondaryColor3uiv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3uiv(v: IntPtr) :=
    z_SecondaryColor3uiv_1(v);
    
    // added in gl1.4, deprecated in gl3.2
    private z_SecondaryColor3us_adr := GetProcAddress('glSecondaryColor3us');
    private z_SecondaryColor3us_1 := GetProcOrNil&<procedure(red: UInt16; green: UInt16; blue: UInt16)>(z_SecondaryColor3us_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3us(red: UInt16; green: UInt16; blue: UInt16) :=
    z_SecondaryColor3us_1(red, green, blue);
    
    // added in gl1.4, deprecated in gl3.2
    private z_SecondaryColor3usv_adr := GetProcAddress('glSecondaryColor3usv');
    private z_SecondaryColor3usv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_SecondaryColor3usv_adr);
    private z_SecondaryColor3usv_2 := GetProcOrNil&<procedure(var v: UInt16)>(z_SecondaryColor3usv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3usv(v: array of UInt16);
    type PUInt16=^UInt16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_SecondaryColor3usv_2(v[0]) else
        z_SecondaryColor3usv_2(PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3usv(var v: UInt16) :=
    z_SecondaryColor3usv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3usv(v: IntPtr) :=
    z_SecondaryColor3usv_1(v);
    
    // added in gl1.4, deprecated in gl3.2
    private z_SecondaryColorPointer_adr := GetProcAddress('glSecondaryColorPointer');
    private z_SecondaryColorPointer_1 := GetProcOrNil&<procedure(size: Int32; &type: ColorPointerType; stride: Int32; pointer: IntPtr)>(z_SecondaryColorPointer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorPointer(size: Int32; &type: ColorPointerType; stride: Int32; pointer: IntPtr) :=
    z_SecondaryColorPointer_1(size, &type, stride, pointer);
    
    // added in gl1.0, deprecated in gl3.2
    private z_SelectBuffer_adr := GetProcAddress('glSelectBuffer');
    private z_SelectBuffer_1 := GetProcOrNil&<procedure(size: Int32; buffer: IntPtr)>(z_SelectBuffer_adr);
    private z_SelectBuffer_2 := GetProcOrNil&<procedure(size: Int32; var buffer: UInt32)>(z_SelectBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SelectBuffer(size: Int32; buffer: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (buffer<>nil) and (buffer.Length<>0) then
        z_SelectBuffer_2(size, buffer[0]) else
        z_SelectBuffer_2(size, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SelectBuffer(size: Int32; var buffer: UInt32) :=
    z_SelectBuffer_2(size, buffer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SelectBuffer(size: Int32; buffer: IntPtr) :=
    z_SelectBuffer_1(size, buffer);
    
    // added in gl1.0, deprecated in gl3.2
    private z_ShadeModel_adr := GetProcAddress('glShadeModel');
    private z_ShadeModel_1 := GetProcOrNil&<procedure(mode: ShadingModel)>(z_ShadeModel_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShadeModel(mode: ShadingModel) :=
    z_ShadeModel_1(mode);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexCoord1d_adr := GetProcAddress('glTexCoord1d');
    private z_TexCoord1d_1 := GetProcOrNil&<procedure(s: real)>(z_TexCoord1d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1d(s: real) :=
    z_TexCoord1d_1(s);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexCoord1dv_adr := GetProcAddress('glTexCoord1dv');
    private z_TexCoord1dv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_TexCoord1dv_adr);
    private z_TexCoord1dv_2 := GetProcOrNil&<procedure(var v: real)>(z_TexCoord1dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1dv(v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_TexCoord1dv_2(v[0]) else
        z_TexCoord1dv_2(Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1dv(var v: real) :=
    z_TexCoord1dv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1dv(v: IntPtr) :=
    z_TexCoord1dv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexCoord1f_adr := GetProcAddress('glTexCoord1f');
    private z_TexCoord1f_1 := GetProcOrNil&<procedure(s: single)>(z_TexCoord1f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1f(s: single) :=
    z_TexCoord1f_1(s);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexCoord1fv_adr := GetProcAddress('glTexCoord1fv');
    private z_TexCoord1fv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_TexCoord1fv_adr);
    private z_TexCoord1fv_2 := GetProcOrNil&<procedure(var v: single)>(z_TexCoord1fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1fv(v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_TexCoord1fv_2(v[0]) else
        z_TexCoord1fv_2(Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1fv(var v: single) :=
    z_TexCoord1fv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1fv(v: IntPtr) :=
    z_TexCoord1fv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexCoord1i_adr := GetProcAddress('glTexCoord1i');
    private z_TexCoord1i_1 := GetProcOrNil&<procedure(s: Int32)>(z_TexCoord1i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1i(s: Int32) :=
    z_TexCoord1i_1(s);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexCoord1iv_adr := GetProcAddress('glTexCoord1iv');
    private z_TexCoord1iv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_TexCoord1iv_adr);
    private z_TexCoord1iv_2 := GetProcOrNil&<procedure(var v: Int32)>(z_TexCoord1iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1iv(v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_TexCoord1iv_2(v[0]) else
        z_TexCoord1iv_2(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1iv(var v: Int32) :=
    z_TexCoord1iv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1iv(v: IntPtr) :=
    z_TexCoord1iv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexCoord1s_adr := GetProcAddress('glTexCoord1s');
    private z_TexCoord1s_1 := GetProcOrNil&<procedure(s: Int16)>(z_TexCoord1s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1s(s: Int16) :=
    z_TexCoord1s_1(s);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexCoord1sv_adr := GetProcAddress('glTexCoord1sv');
    private z_TexCoord1sv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_TexCoord1sv_adr);
    private z_TexCoord1sv_2 := GetProcOrNil&<procedure(var v: Int16)>(z_TexCoord1sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1sv(v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_TexCoord1sv_2(v[0]) else
        z_TexCoord1sv_2(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1sv(var v: Int16) :=
    z_TexCoord1sv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1sv(v: IntPtr) :=
    z_TexCoord1sv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexCoord2d_adr := GetProcAddress('glTexCoord2d');
    private z_TexCoord2d_1 := GetProcOrNil&<procedure(s: real; t: real)>(z_TexCoord2d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2d(s: real; t: real) :=
    z_TexCoord2d_1(s, t);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexCoord2dv_adr := GetProcAddress('glTexCoord2dv');
    private z_TexCoord2dv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_TexCoord2dv_adr);
    private z_TexCoord2dv_2 := GetProcOrNil&<procedure(var v: real)>(z_TexCoord2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2dv(v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_TexCoord2dv_2(v[0]) else
        z_TexCoord2dv_2(Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2dv(var v: real) :=
    z_TexCoord2dv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2dv(v: IntPtr) :=
    z_TexCoord2dv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexCoord2f_adr := GetProcAddress('glTexCoord2f');
    private z_TexCoord2f_1 := GetProcOrNil&<procedure(s: single; t: single)>(z_TexCoord2f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2f(s: single; t: single) :=
    z_TexCoord2f_1(s, t);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexCoord2fv_adr := GetProcAddress('glTexCoord2fv');
    private z_TexCoord2fv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_TexCoord2fv_adr);
    private z_TexCoord2fv_2 := GetProcOrNil&<procedure(var v: single)>(z_TexCoord2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fv(v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_TexCoord2fv_2(v[0]) else
        z_TexCoord2fv_2(Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fv(var v: single) :=
    z_TexCoord2fv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fv(v: IntPtr) :=
    z_TexCoord2fv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexCoord2i_adr := GetProcAddress('glTexCoord2i');
    private z_TexCoord2i_1 := GetProcOrNil&<procedure(s: Int32; t: Int32)>(z_TexCoord2i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2i(s: Int32; t: Int32) :=
    z_TexCoord2i_1(s, t);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexCoord2iv_adr := GetProcAddress('glTexCoord2iv');
    private z_TexCoord2iv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_TexCoord2iv_adr);
    private z_TexCoord2iv_2 := GetProcOrNil&<procedure(var v: Int32)>(z_TexCoord2iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2iv(v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_TexCoord2iv_2(v[0]) else
        z_TexCoord2iv_2(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2iv(var v: Int32) :=
    z_TexCoord2iv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2iv(v: IntPtr) :=
    z_TexCoord2iv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexCoord2s_adr := GetProcAddress('glTexCoord2s');
    private z_TexCoord2s_1 := GetProcOrNil&<procedure(s: Int16; t: Int16)>(z_TexCoord2s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2s(s: Int16; t: Int16) :=
    z_TexCoord2s_1(s, t);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexCoord2sv_adr := GetProcAddress('glTexCoord2sv');
    private z_TexCoord2sv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_TexCoord2sv_adr);
    private z_TexCoord2sv_2 := GetProcOrNil&<procedure(var v: Int16)>(z_TexCoord2sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2sv(v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_TexCoord2sv_2(v[0]) else
        z_TexCoord2sv_2(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2sv(var v: Int16) :=
    z_TexCoord2sv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2sv(v: IntPtr) :=
    z_TexCoord2sv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexCoord3d_adr := GetProcAddress('glTexCoord3d');
    private z_TexCoord3d_1 := GetProcOrNil&<procedure(s: real; t: real; r: real)>(z_TexCoord3d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3d(s: real; t: real; r: real) :=
    z_TexCoord3d_1(s, t, r);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexCoord3dv_adr := GetProcAddress('glTexCoord3dv');
    private z_TexCoord3dv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_TexCoord3dv_adr);
    private z_TexCoord3dv_2 := GetProcOrNil&<procedure(var v: real)>(z_TexCoord3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3dv(v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_TexCoord3dv_2(v[0]) else
        z_TexCoord3dv_2(Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3dv(var v: real) :=
    z_TexCoord3dv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3dv(v: IntPtr) :=
    z_TexCoord3dv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexCoord3f_adr := GetProcAddress('glTexCoord3f');
    private z_TexCoord3f_1 := GetProcOrNil&<procedure(s: single; t: single; r: single)>(z_TexCoord3f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3f(s: single; t: single; r: single) :=
    z_TexCoord3f_1(s, t, r);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexCoord3fv_adr := GetProcAddress('glTexCoord3fv');
    private z_TexCoord3fv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_TexCoord3fv_adr);
    private z_TexCoord3fv_2 := GetProcOrNil&<procedure(var v: single)>(z_TexCoord3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3fv(v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_TexCoord3fv_2(v[0]) else
        z_TexCoord3fv_2(Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3fv(var v: single) :=
    z_TexCoord3fv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3fv(v: IntPtr) :=
    z_TexCoord3fv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexCoord3i_adr := GetProcAddress('glTexCoord3i');
    private z_TexCoord3i_1 := GetProcOrNil&<procedure(s: Int32; t: Int32; r: Int32)>(z_TexCoord3i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3i(s: Int32; t: Int32; r: Int32) :=
    z_TexCoord3i_1(s, t, r);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexCoord3iv_adr := GetProcAddress('glTexCoord3iv');
    private z_TexCoord3iv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_TexCoord3iv_adr);
    private z_TexCoord3iv_2 := GetProcOrNil&<procedure(var v: Int32)>(z_TexCoord3iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3iv(v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_TexCoord3iv_2(v[0]) else
        z_TexCoord3iv_2(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3iv(var v: Int32) :=
    z_TexCoord3iv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3iv(v: IntPtr) :=
    z_TexCoord3iv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexCoord3s_adr := GetProcAddress('glTexCoord3s');
    private z_TexCoord3s_1 := GetProcOrNil&<procedure(s: Int16; t: Int16; r: Int16)>(z_TexCoord3s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3s(s: Int16; t: Int16; r: Int16) :=
    z_TexCoord3s_1(s, t, r);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexCoord3sv_adr := GetProcAddress('glTexCoord3sv');
    private z_TexCoord3sv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_TexCoord3sv_adr);
    private z_TexCoord3sv_2 := GetProcOrNil&<procedure(var v: Int16)>(z_TexCoord3sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3sv(v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_TexCoord3sv_2(v[0]) else
        z_TexCoord3sv_2(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3sv(var v: Int16) :=
    z_TexCoord3sv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3sv(v: IntPtr) :=
    z_TexCoord3sv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexCoord4d_adr := GetProcAddress('glTexCoord4d');
    private z_TexCoord4d_1 := GetProcOrNil&<procedure(s: real; t: real; r: real; q: real)>(z_TexCoord4d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4d(s: real; t: real; r: real; q: real) :=
    z_TexCoord4d_1(s, t, r, q);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexCoord4dv_adr := GetProcAddress('glTexCoord4dv');
    private z_TexCoord4dv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_TexCoord4dv_adr);
    private z_TexCoord4dv_2 := GetProcOrNil&<procedure(var v: real)>(z_TexCoord4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4dv(v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_TexCoord4dv_2(v[0]) else
        z_TexCoord4dv_2(Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4dv(var v: real) :=
    z_TexCoord4dv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4dv(v: IntPtr) :=
    z_TexCoord4dv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexCoord4f_adr := GetProcAddress('glTexCoord4f');
    private z_TexCoord4f_1 := GetProcOrNil&<procedure(s: single; t: single; r: single; q: single)>(z_TexCoord4f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4f(s: single; t: single; r: single; q: single) :=
    z_TexCoord4f_1(s, t, r, q);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexCoord4fv_adr := GetProcAddress('glTexCoord4fv');
    private z_TexCoord4fv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_TexCoord4fv_adr);
    private z_TexCoord4fv_2 := GetProcOrNil&<procedure(var v: single)>(z_TexCoord4fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fv(v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_TexCoord4fv_2(v[0]) else
        z_TexCoord4fv_2(Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fv(var v: single) :=
    z_TexCoord4fv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fv(v: IntPtr) :=
    z_TexCoord4fv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexCoord4i_adr := GetProcAddress('glTexCoord4i');
    private z_TexCoord4i_1 := GetProcOrNil&<procedure(s: Int32; t: Int32; r: Int32; q: Int32)>(z_TexCoord4i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4i(s: Int32; t: Int32; r: Int32; q: Int32) :=
    z_TexCoord4i_1(s, t, r, q);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexCoord4iv_adr := GetProcAddress('glTexCoord4iv');
    private z_TexCoord4iv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_TexCoord4iv_adr);
    private z_TexCoord4iv_2 := GetProcOrNil&<procedure(var v: Int32)>(z_TexCoord4iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4iv(v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_TexCoord4iv_2(v[0]) else
        z_TexCoord4iv_2(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4iv(var v: Int32) :=
    z_TexCoord4iv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4iv(v: IntPtr) :=
    z_TexCoord4iv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexCoord4s_adr := GetProcAddress('glTexCoord4s');
    private z_TexCoord4s_1 := GetProcOrNil&<procedure(s: Int16; t: Int16; r: Int16; q: Int16)>(z_TexCoord4s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4s(s: Int16; t: Int16; r: Int16; q: Int16) :=
    z_TexCoord4s_1(s, t, r, q);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexCoord4sv_adr := GetProcAddress('glTexCoord4sv');
    private z_TexCoord4sv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_TexCoord4sv_adr);
    private z_TexCoord4sv_2 := GetProcOrNil&<procedure(var v: Int16)>(z_TexCoord4sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4sv(v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_TexCoord4sv_2(v[0]) else
        z_TexCoord4sv_2(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4sv(var v: Int16) :=
    z_TexCoord4sv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4sv(v: IntPtr) :=
    z_TexCoord4sv_1(v);
    
    // added in gl1.1, deprecated in gl3.2
    private z_TexCoordPointer_adr := GetProcAddress('glTexCoordPointer');
    private z_TexCoordPointer_1 := GetProcOrNil&<procedure(size: Int32; &type: TexCoordPointerType; stride: Int32; pointer: IntPtr)>(z_TexCoordPointer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordPointer(size: Int32; &type: TexCoordPointerType; stride: Int32; pointer: IntPtr) :=
    z_TexCoordPointer_1(size, &type, stride, pointer);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexEnvf_adr := GetProcAddress('glTexEnvf');
    private z_TexEnvf_1 := GetProcOrNil&<procedure(target: TextureEnvTarget; pname: TextureEnvParameter; param: single)>(z_TexEnvf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvf(target: TextureEnvTarget; pname: TextureEnvParameter; param: single) :=
    z_TexEnvf_1(target, pname, param);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexEnvfv_adr := GetProcAddress('glTexEnvfv');
    private z_TexEnvfv_1 := GetProcOrNil&<procedure(target: TextureEnvTarget; pname: TextureEnvParameter; &params: IntPtr)>(z_TexEnvfv_adr);
    private z_TexEnvfv_2 := GetProcOrNil&<procedure(target: TextureEnvTarget; pname: TextureEnvParameter; var &params: single)>(z_TexEnvfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvfv(target: TextureEnvTarget; pname: TextureEnvParameter; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_TexEnvfv_2(target, pname, &params[0]) else
        z_TexEnvfv_2(target, pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvfv(target: TextureEnvTarget; pname: TextureEnvParameter; var &params: single) :=
    z_TexEnvfv_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvfv(target: TextureEnvTarget; pname: TextureEnvParameter; &params: IntPtr) :=
    z_TexEnvfv_1(target, pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexEnvi_adr := GetProcAddress('glTexEnvi');
    private z_TexEnvi_1 := GetProcOrNil&<procedure(target: TextureEnvTarget; pname: TextureEnvParameter; param: Int32)>(z_TexEnvi_adr);
    private z_TexEnvi_2 := GetProcOrNil&<procedure(target: TextureEnvTarget; pname: TextureEnvParameter; param: TextureEnvMode)>(z_TexEnvi_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvi(target: TextureEnvTarget; pname: TextureEnvParameter; param: TextureEnvMode) :=
    z_TexEnvi_2(target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvi(target: TextureEnvTarget; pname: TextureEnvParameter; param: Int32) :=
    z_TexEnvi_1(target, pname, param);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexEnviv_adr := GetProcAddress('glTexEnviv');
    private z_TexEnviv_1 := GetProcOrNil&<procedure(target: TextureEnvTarget; pname: TextureEnvParameter; &params: IntPtr)>(z_TexEnviv_adr);
    private z_TexEnviv_2 := GetProcOrNil&<procedure(target: TextureEnvTarget; pname: TextureEnvParameter; var &params: Int32)>(z_TexEnviv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnviv(target: TextureEnvTarget; pname: TextureEnvParameter; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_TexEnviv_2(target, pname, &params[0]) else
        z_TexEnviv_2(target, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnviv(target: TextureEnvTarget; pname: TextureEnvParameter; var &params: Int32) :=
    z_TexEnviv_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnviv(target: TextureEnvTarget; pname: TextureEnvParameter; &params: IntPtr) :=
    z_TexEnviv_1(target, pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexGend_adr := GetProcAddress('glTexGend');
    private z_TexGend_1 := GetProcOrNil&<procedure(coord: TextureCoordName; pname: TextureGenParameter; param: real)>(z_TexGend_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGend(coord: TextureCoordName; pname: TextureGenParameter; param: real) :=
    z_TexGend_1(coord, pname, param);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexGendv_adr := GetProcAddress('glTexGendv');
    private z_TexGendv_1 := GetProcOrNil&<procedure(coord: TextureCoordName; pname: TextureGenParameter; &params: IntPtr)>(z_TexGendv_adr);
    private z_TexGendv_2 := GetProcOrNil&<procedure(coord: TextureCoordName; pname: TextureGenParameter; var &params: real)>(z_TexGendv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGendv(coord: TextureCoordName; pname: TextureGenParameter; &params: array of real);
    type Preal=^real;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_TexGendv_2(coord, pname, &params[0]) else
        z_TexGendv_2(coord, pname, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGendv(coord: TextureCoordName; pname: TextureGenParameter; var &params: real) :=
    z_TexGendv_2(coord, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGendv(coord: TextureCoordName; pname: TextureGenParameter; &params: IntPtr) :=
    z_TexGendv_1(coord, pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexGenf_adr := GetProcAddress('glTexGenf');
    private z_TexGenf_1 := GetProcOrNil&<procedure(coord: TextureCoordName; pname: TextureGenParameter; param: single)>(z_TexGenf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenf(coord: TextureCoordName; pname: TextureGenParameter; param: single) :=
    z_TexGenf_1(coord, pname, param);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexGenfv_adr := GetProcAddress('glTexGenfv');
    private z_TexGenfv_1 := GetProcOrNil&<procedure(coord: TextureCoordName; pname: TextureGenParameter; &params: IntPtr)>(z_TexGenfv_adr);
    private z_TexGenfv_2 := GetProcOrNil&<procedure(coord: TextureCoordName; pname: TextureGenParameter; var &params: single)>(z_TexGenfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenfv(coord: TextureCoordName; pname: TextureGenParameter; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_TexGenfv_2(coord, pname, &params[0]) else
        z_TexGenfv_2(coord, pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenfv(coord: TextureCoordName; pname: TextureGenParameter; var &params: single) :=
    z_TexGenfv_2(coord, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenfv(coord: TextureCoordName; pname: TextureGenParameter; &params: IntPtr) :=
    z_TexGenfv_1(coord, pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexGeni_adr := GetProcAddress('glTexGeni');
    private z_TexGeni_1 := GetProcOrNil&<procedure(coord: TextureCoordName; pname: TextureGenParameter; param: Int32)>(z_TexGeni_adr);
    private z_TexGeni_2 := GetProcOrNil&<procedure(coord: TextureCoordName; pname: TextureGenParameter; param: TextureGenMode)>(z_TexGeni_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGeni(coord: TextureCoordName; pname: TextureGenParameter; param: TextureGenMode) :=
    z_TexGeni_2(coord, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGeni(coord: TextureCoordName; pname: TextureGenParameter; param: Int32) :=
    z_TexGeni_1(coord, pname, param);
    
    // added in gl1.0, deprecated in gl3.2
    private z_TexGeniv_adr := GetProcAddress('glTexGeniv');
    private z_TexGeniv_1 := GetProcOrNil&<procedure(coord: TextureCoordName; pname: TextureGenParameter; &params: IntPtr)>(z_TexGeniv_adr);
    private z_TexGeniv_2 := GetProcOrNil&<procedure(coord: TextureCoordName; pname: TextureGenParameter; var &params: Int32)>(z_TexGeniv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGeniv(coord: TextureCoordName; pname: TextureGenParameter; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_TexGeniv_2(coord, pname, &params[0]) else
        z_TexGeniv_2(coord, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGeniv(coord: TextureCoordName; pname: TextureGenParameter; var &params: Int32) :=
    z_TexGeniv_2(coord, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGeniv(coord: TextureCoordName; pname: TextureGenParameter; &params: IntPtr) :=
    z_TexGeniv_1(coord, pname, &params);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Translated_adr := GetProcAddress('glTranslated');
    private z_Translated_1 := GetProcOrNil&<procedure(x: real; y: real; z: real)>(z_Translated_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Translated(x: real; y: real; z: real) :=
    z_Translated_1(x, y, z);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Translatef_adr := GetProcAddress('glTranslatef');
    private z_Translatef_1 := GetProcOrNil&<procedure(x: single; y: single; z: single)>(z_Translatef_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Translatef(x: single; y: single; z: single) :=
    z_Translatef_1(x, y, z);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Vertex2d_adr := GetProcAddress('glVertex2d');
    private z_Vertex2d_1 := GetProcOrNil&<procedure(x: real; y: real)>(z_Vertex2d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2d(x: real; y: real) :=
    z_Vertex2d_1(x, y);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Vertex2dv_adr := GetProcAddress('glVertex2dv');
    private z_Vertex2dv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Vertex2dv_adr);
    private z_Vertex2dv_2 := GetProcOrNil&<procedure(var v: real)>(z_Vertex2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2dv(v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Vertex2dv_2(v[0]) else
        z_Vertex2dv_2(Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2dv(var v: real) :=
    z_Vertex2dv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2dv(v: IntPtr) :=
    z_Vertex2dv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Vertex2f_adr := GetProcAddress('glVertex2f');
    private z_Vertex2f_1 := GetProcOrNil&<procedure(x: single; y: single)>(z_Vertex2f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2f(x: single; y: single) :=
    z_Vertex2f_1(x, y);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Vertex2fv_adr := GetProcAddress('glVertex2fv');
    private z_Vertex2fv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Vertex2fv_adr);
    private z_Vertex2fv_2 := GetProcOrNil&<procedure(var v: single)>(z_Vertex2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2fv(v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Vertex2fv_2(v[0]) else
        z_Vertex2fv_2(Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2fv(var v: single) :=
    z_Vertex2fv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2fv(v: IntPtr) :=
    z_Vertex2fv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Vertex2i_adr := GetProcAddress('glVertex2i');
    private z_Vertex2i_1 := GetProcOrNil&<procedure(x: Int32; y: Int32)>(z_Vertex2i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2i(x: Int32; y: Int32) :=
    z_Vertex2i_1(x, y);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Vertex2iv_adr := GetProcAddress('glVertex2iv');
    private z_Vertex2iv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Vertex2iv_adr);
    private z_Vertex2iv_2 := GetProcOrNil&<procedure(var v: Int32)>(z_Vertex2iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2iv(v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Vertex2iv_2(v[0]) else
        z_Vertex2iv_2(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2iv(var v: Int32) :=
    z_Vertex2iv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2iv(v: IntPtr) :=
    z_Vertex2iv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Vertex2s_adr := GetProcAddress('glVertex2s');
    private z_Vertex2s_1 := GetProcOrNil&<procedure(x: Int16; y: Int16)>(z_Vertex2s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2s(x: Int16; y: Int16) :=
    z_Vertex2s_1(x, y);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Vertex2sv_adr := GetProcAddress('glVertex2sv');
    private z_Vertex2sv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Vertex2sv_adr);
    private z_Vertex2sv_2 := GetProcOrNil&<procedure(var v: Int16)>(z_Vertex2sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2sv(v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Vertex2sv_2(v[0]) else
        z_Vertex2sv_2(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2sv(var v: Int16) :=
    z_Vertex2sv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2sv(v: IntPtr) :=
    z_Vertex2sv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Vertex3d_adr := GetProcAddress('glVertex3d');
    private z_Vertex3d_1 := GetProcOrNil&<procedure(x: real; y: real; z: real)>(z_Vertex3d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3d(x: real; y: real; z: real) :=
    z_Vertex3d_1(x, y, z);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Vertex3dv_adr := GetProcAddress('glVertex3dv');
    private z_Vertex3dv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Vertex3dv_adr);
    private z_Vertex3dv_2 := GetProcOrNil&<procedure(var v: real)>(z_Vertex3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3dv(v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Vertex3dv_2(v[0]) else
        z_Vertex3dv_2(Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3dv(var v: real) :=
    z_Vertex3dv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3dv(v: IntPtr) :=
    z_Vertex3dv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Vertex3f_adr := GetProcAddress('glVertex3f');
    private z_Vertex3f_1 := GetProcOrNil&<procedure(x: single; y: single; z: single)>(z_Vertex3f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3f(x: single; y: single; z: single) :=
    z_Vertex3f_1(x, y, z);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Vertex3fv_adr := GetProcAddress('glVertex3fv');
    private z_Vertex3fv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Vertex3fv_adr);
    private z_Vertex3fv_2 := GetProcOrNil&<procedure(var v: single)>(z_Vertex3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3fv(v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Vertex3fv_2(v[0]) else
        z_Vertex3fv_2(Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3fv(var v: single) :=
    z_Vertex3fv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3fv(v: IntPtr) :=
    z_Vertex3fv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Vertex3i_adr := GetProcAddress('glVertex3i');
    private z_Vertex3i_1 := GetProcOrNil&<procedure(x: Int32; y: Int32; z: Int32)>(z_Vertex3i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3i(x: Int32; y: Int32; z: Int32) :=
    z_Vertex3i_1(x, y, z);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Vertex3iv_adr := GetProcAddress('glVertex3iv');
    private z_Vertex3iv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Vertex3iv_adr);
    private z_Vertex3iv_2 := GetProcOrNil&<procedure(var v: Int32)>(z_Vertex3iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3iv(v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Vertex3iv_2(v[0]) else
        z_Vertex3iv_2(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3iv(var v: Int32) :=
    z_Vertex3iv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3iv(v: IntPtr) :=
    z_Vertex3iv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Vertex3s_adr := GetProcAddress('glVertex3s');
    private z_Vertex3s_1 := GetProcOrNil&<procedure(x: Int16; y: Int16; z: Int16)>(z_Vertex3s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3s(x: Int16; y: Int16; z: Int16) :=
    z_Vertex3s_1(x, y, z);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Vertex3sv_adr := GetProcAddress('glVertex3sv');
    private z_Vertex3sv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Vertex3sv_adr);
    private z_Vertex3sv_2 := GetProcOrNil&<procedure(var v: Int16)>(z_Vertex3sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3sv(v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Vertex3sv_2(v[0]) else
        z_Vertex3sv_2(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3sv(var v: Int16) :=
    z_Vertex3sv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3sv(v: IntPtr) :=
    z_Vertex3sv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Vertex4d_adr := GetProcAddress('glVertex4d');
    private z_Vertex4d_1 := GetProcOrNil&<procedure(x: real; y: real; z: real; w: real)>(z_Vertex4d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4d(x: real; y: real; z: real; w: real) :=
    z_Vertex4d_1(x, y, z, w);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Vertex4dv_adr := GetProcAddress('glVertex4dv');
    private z_Vertex4dv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Vertex4dv_adr);
    private z_Vertex4dv_2 := GetProcOrNil&<procedure(var v: real)>(z_Vertex4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4dv(v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Vertex4dv_2(v[0]) else
        z_Vertex4dv_2(Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4dv(var v: real) :=
    z_Vertex4dv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4dv(v: IntPtr) :=
    z_Vertex4dv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Vertex4f_adr := GetProcAddress('glVertex4f');
    private z_Vertex4f_1 := GetProcOrNil&<procedure(x: single; y: single; z: single; w: single)>(z_Vertex4f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4f(x: single; y: single; z: single; w: single) :=
    z_Vertex4f_1(x, y, z, w);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Vertex4fv_adr := GetProcAddress('glVertex4fv');
    private z_Vertex4fv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Vertex4fv_adr);
    private z_Vertex4fv_2 := GetProcOrNil&<procedure(var v: single)>(z_Vertex4fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4fv(v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Vertex4fv_2(v[0]) else
        z_Vertex4fv_2(Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4fv(var v: single) :=
    z_Vertex4fv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4fv(v: IntPtr) :=
    z_Vertex4fv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Vertex4i_adr := GetProcAddress('glVertex4i');
    private z_Vertex4i_1 := GetProcOrNil&<procedure(x: Int32; y: Int32; z: Int32; w: Int32)>(z_Vertex4i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4i(x: Int32; y: Int32; z: Int32; w: Int32) :=
    z_Vertex4i_1(x, y, z, w);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Vertex4iv_adr := GetProcAddress('glVertex4iv');
    private z_Vertex4iv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Vertex4iv_adr);
    private z_Vertex4iv_2 := GetProcOrNil&<procedure(var v: Int32)>(z_Vertex4iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4iv(v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Vertex4iv_2(v[0]) else
        z_Vertex4iv_2(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4iv(var v: Int32) :=
    z_Vertex4iv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4iv(v: IntPtr) :=
    z_Vertex4iv_1(v);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Vertex4s_adr := GetProcAddress('glVertex4s');
    private z_Vertex4s_1 := GetProcOrNil&<procedure(x: Int16; y: Int16; z: Int16; w: Int16)>(z_Vertex4s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4s(x: Int16; y: Int16; z: Int16; w: Int16) :=
    z_Vertex4s_1(x, y, z, w);
    
    // added in gl1.0, deprecated in gl3.2
    private z_Vertex4sv_adr := GetProcAddress('glVertex4sv');
    private z_Vertex4sv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Vertex4sv_adr);
    private z_Vertex4sv_2 := GetProcOrNil&<procedure(var v: Int16)>(z_Vertex4sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4sv(v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Vertex4sv_2(v[0]) else
        z_Vertex4sv_2(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4sv(var v: Int16) :=
    z_Vertex4sv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4sv(v: IntPtr) :=
    z_Vertex4sv_1(v);
    
    // added in gl1.1, deprecated in gl3.2
    private z_VertexPointer_adr := GetProcAddress('glVertexPointer');
    private z_VertexPointer_1 := GetProcOrNil&<procedure(size: Int32; &type: VertexPointerType; stride: Int32; pointer: IntPtr)>(z_VertexPointer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexPointer(size: Int32; &type: VertexPointerType; stride: Int32; pointer: IntPtr) :=
    z_VertexPointer_1(size, &type, stride, pointer);
    
    // added in gl1.4, deprecated in gl3.2
    private z_WindowPos2d_adr := GetProcAddress('glWindowPos2d');
    private z_WindowPos2d_1 := GetProcOrNil&<procedure(x: real; y: real)>(z_WindowPos2d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2d(x: real; y: real) :=
    z_WindowPos2d_1(x, y);
    
    // added in gl1.4, deprecated in gl3.2
    private z_WindowPos2dv_adr := GetProcAddress('glWindowPos2dv');
    private z_WindowPos2dv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_WindowPos2dv_adr);
    private z_WindowPos2dv_2 := GetProcOrNil&<procedure(var v: real)>(z_WindowPos2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dv(v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_WindowPos2dv_2(v[0]) else
        z_WindowPos2dv_2(Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dv(var v: real) :=
    z_WindowPos2dv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dv(v: IntPtr) :=
    z_WindowPos2dv_1(v);
    
    // added in gl1.4, deprecated in gl3.2
    private z_WindowPos2f_adr := GetProcAddress('glWindowPos2f');
    private z_WindowPos2f_1 := GetProcOrNil&<procedure(x: single; y: single)>(z_WindowPos2f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2f(x: single; y: single) :=
    z_WindowPos2f_1(x, y);
    
    // added in gl1.4, deprecated in gl3.2
    private z_WindowPos2fv_adr := GetProcAddress('glWindowPos2fv');
    private z_WindowPos2fv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_WindowPos2fv_adr);
    private z_WindowPos2fv_2 := GetProcOrNil&<procedure(var v: single)>(z_WindowPos2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fv(v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_WindowPos2fv_2(v[0]) else
        z_WindowPos2fv_2(Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fv(var v: single) :=
    z_WindowPos2fv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fv(v: IntPtr) :=
    z_WindowPos2fv_1(v);
    
    // added in gl1.4, deprecated in gl3.2
    private z_WindowPos2i_adr := GetProcAddress('glWindowPos2i');
    private z_WindowPos2i_1 := GetProcOrNil&<procedure(x: Int32; y: Int32)>(z_WindowPos2i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2i(x: Int32; y: Int32) :=
    z_WindowPos2i_1(x, y);
    
    // added in gl1.4, deprecated in gl3.2
    private z_WindowPos2iv_adr := GetProcAddress('glWindowPos2iv');
    private z_WindowPos2iv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_WindowPos2iv_adr);
    private z_WindowPos2iv_2 := GetProcOrNil&<procedure(var v: Int32)>(z_WindowPos2iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2iv(v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_WindowPos2iv_2(v[0]) else
        z_WindowPos2iv_2(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2iv(var v: Int32) :=
    z_WindowPos2iv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2iv(v: IntPtr) :=
    z_WindowPos2iv_1(v);
    
    // added in gl1.4, deprecated in gl3.2
    private z_WindowPos2s_adr := GetProcAddress('glWindowPos2s');
    private z_WindowPos2s_1 := GetProcOrNil&<procedure(x: Int16; y: Int16)>(z_WindowPos2s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2s(x: Int16; y: Int16) :=
    z_WindowPos2s_1(x, y);
    
    // added in gl1.4, deprecated in gl3.2
    private z_WindowPos2sv_adr := GetProcAddress('glWindowPos2sv');
    private z_WindowPos2sv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_WindowPos2sv_adr);
    private z_WindowPos2sv_2 := GetProcOrNil&<procedure(var v: Int16)>(z_WindowPos2sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2sv(v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_WindowPos2sv_2(v[0]) else
        z_WindowPos2sv_2(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2sv(var v: Int16) :=
    z_WindowPos2sv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2sv(v: IntPtr) :=
    z_WindowPos2sv_1(v);
    
    // added in gl1.4, deprecated in gl3.2
    private z_WindowPos3d_adr := GetProcAddress('glWindowPos3d');
    private z_WindowPos3d_1 := GetProcOrNil&<procedure(x: real; y: real; z: real)>(z_WindowPos3d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3d(x: real; y: real; z: real) :=
    z_WindowPos3d_1(x, y, z);
    
    // added in gl1.4, deprecated in gl3.2
    private z_WindowPos3dv_adr := GetProcAddress('glWindowPos3dv');
    private z_WindowPos3dv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_WindowPos3dv_adr);
    private z_WindowPos3dv_2 := GetProcOrNil&<procedure(var v: real)>(z_WindowPos3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dv(v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_WindowPos3dv_2(v[0]) else
        z_WindowPos3dv_2(Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dv(var v: real) :=
    z_WindowPos3dv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dv(v: IntPtr) :=
    z_WindowPos3dv_1(v);
    
    // added in gl1.4, deprecated in gl3.2
    private z_WindowPos3f_adr := GetProcAddress('glWindowPos3f');
    private z_WindowPos3f_1 := GetProcOrNil&<procedure(x: single; y: single; z: single)>(z_WindowPos3f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3f(x: single; y: single; z: single) :=
    z_WindowPos3f_1(x, y, z);
    
    // added in gl1.4, deprecated in gl3.2
    private z_WindowPos3fv_adr := GetProcAddress('glWindowPos3fv');
    private z_WindowPos3fv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_WindowPos3fv_adr);
    private z_WindowPos3fv_2 := GetProcOrNil&<procedure(var v: single)>(z_WindowPos3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fv(v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_WindowPos3fv_2(v[0]) else
        z_WindowPos3fv_2(Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fv(var v: single) :=
    z_WindowPos3fv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fv(v: IntPtr) :=
    z_WindowPos3fv_1(v);
    
    // added in gl1.4, deprecated in gl3.2
    private z_WindowPos3i_adr := GetProcAddress('glWindowPos3i');
    private z_WindowPos3i_1 := GetProcOrNil&<procedure(x: Int32; y: Int32; z: Int32)>(z_WindowPos3i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3i(x: Int32; y: Int32; z: Int32) :=
    z_WindowPos3i_1(x, y, z);
    
    // added in gl1.4, deprecated in gl3.2
    private z_WindowPos3iv_adr := GetProcAddress('glWindowPos3iv');
    private z_WindowPos3iv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_WindowPos3iv_adr);
    private z_WindowPos3iv_2 := GetProcOrNil&<procedure(var v: Int32)>(z_WindowPos3iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3iv(v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_WindowPos3iv_2(v[0]) else
        z_WindowPos3iv_2(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3iv(var v: Int32) :=
    z_WindowPos3iv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3iv(v: IntPtr) :=
    z_WindowPos3iv_1(v);
    
    // added in gl1.4, deprecated in gl3.2
    private z_WindowPos3s_adr := GetProcAddress('glWindowPos3s');
    private z_WindowPos3s_1 := GetProcOrNil&<procedure(x: Int16; y: Int16; z: Int16)>(z_WindowPos3s_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3s(x: Int16; y: Int16; z: Int16) :=
    z_WindowPos3s_1(x, y, z);
    
    // added in gl1.4, deprecated in gl3.2
    private z_WindowPos3sv_adr := GetProcAddress('glWindowPos3sv');
    private z_WindowPos3sv_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_WindowPos3sv_adr);
    private z_WindowPos3sv_2 := GetProcOrNil&<procedure(var v: Int16)>(z_WindowPos3sv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3sv(v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_WindowPos3sv_2(v[0]) else
        z_WindowPos3sv_2(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3sv(var v: Int16) :=
    z_WindowPos3sv_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3sv(v: IntPtr) :=
    z_WindowPos3sv_1(v);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  wgl = static class
    
    // added in wgl1.0
    private static function z_CopyContext_1(hglrcSrc: wgl_context; hglrcDst: wgl_context; mask: UInt32): Bool;
    external 'opengl32.dll' name 'wglCopyContext';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CopyContext(hglrcSrc: wgl_context; hglrcDst: wgl_context; mask: UInt32): Bool :=
    z_CopyContext_1(hglrcSrc, hglrcDst, mask);
    
    // added in wgl1.0
    private static function z_CreateContext_1(hDc: gdi_device_context): wgl_context;
    external 'opengl32.dll' name 'wglCreateContext';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateContext(hDc: gdi_device_context): wgl_context :=
    z_CreateContext_1(hDc);
    
    // added in wgl1.0
    private static function z_CreateLayerContext_1(hDc: gdi_device_context; level: Int32): wgl_context;
    external 'opengl32.dll' name 'wglCreateLayerContext';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateLayerContext(hDc: gdi_device_context; level: Int32): wgl_context :=
    z_CreateLayerContext_1(hDc, level);
    
    // added in wgl1.0
    private static function z_DeleteContext_1(oldContext: wgl_context): Bool;
    external 'opengl32.dll' name 'wglDeleteContext';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function DeleteContext(oldContext: wgl_context): Bool :=
    z_DeleteContext_1(oldContext);
    
    // added in wgl1.0
    private static function z_DescribeLayerPlane_1(hDc: gdi_device_context; pixelFormat: Int32; layerPlane: Int32; nBytes: UInt32; plpd: IntPtr): Bool;
    external 'opengl32.dll' name 'wglDescribeLayerPlane';
    private static function z_DescribeLayerPlane_2(hDc: gdi_device_context; pixelFormat: Int32; layerPlane: Int32; nBytes: UInt32; var plpd: gdi_layer_plane_descriptor): Bool;
    external 'opengl32.dll' name 'wglDescribeLayerPlane';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function DescribeLayerPlane(hDc: gdi_device_context; pixelFormat: Int32; layerPlane: Int32; nBytes: UInt32; plpd: array of gdi_layer_plane_descriptor): Bool;
    type Pgdi_layer_plane_descriptor=^gdi_layer_plane_descriptor;
    begin
      Result := if (plpd<>nil) and (plpd.Length<>0) then
        z_DescribeLayerPlane_2(hDc, pixelFormat, layerPlane, nBytes, plpd[0]) else
        z_DescribeLayerPlane_2(hDc, pixelFormat, layerPlane, nBytes, Pgdi_layer_plane_descriptor(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function DescribeLayerPlane(hDc: gdi_device_context; pixelFormat: Int32; layerPlane: Int32; nBytes: UInt32; var plpd: gdi_layer_plane_descriptor): Bool :=
    z_DescribeLayerPlane_2(hDc, pixelFormat, layerPlane, nBytes, plpd);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function DescribeLayerPlane(hDc: gdi_device_context; pixelFormat: Int32; layerPlane: Int32; nBytes: UInt32; plpd: IntPtr): Bool :=
    z_DescribeLayerPlane_1(hDc, pixelFormat, layerPlane, nBytes, plpd);
    
    // added in wgl1.0
    private static function z_GetCurrentContext_1: wgl_context;
    external 'opengl32.dll' name 'wglGetCurrentContext';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCurrentContext: wgl_context :=
    z_GetCurrentContext_1();
    
    // added in wgl1.0
    private static function z_GetCurrentDC_1: gdi_device_context;
    external 'opengl32.dll' name 'wglGetCurrentDC';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCurrentDC: gdi_device_context :=
    z_GetCurrentDC_1();
    
    // added in wgl1.0
    private static function z_GetLayerPaletteEntries_1(hdc: gdi_device_context; iLayerPlane: Int32; iStart: Int32; cEntries: Int32; pcr: IntPtr): Int32;
    external 'opengl32.dll' name 'wglGetLayerPaletteEntries';
    private static function z_GetLayerPaletteEntries_2(hdc: gdi_device_context; iLayerPlane: Int32; iStart: Int32; cEntries: Int32; var pcr: gdi_colorref): Int32;
    external 'opengl32.dll' name 'wglGetLayerPaletteEntries';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetLayerPaletteEntries(hdc: gdi_device_context; iLayerPlane: Int32; iStart: Int32; cEntries: Int32; pcr: array of gdi_colorref): Int32;
    type Pgdi_colorref=^gdi_colorref;
    begin
      Result := if (pcr<>nil) and (pcr.Length<>0) then
        z_GetLayerPaletteEntries_2(hdc, iLayerPlane, iStart, cEntries, pcr[0]) else
        z_GetLayerPaletteEntries_2(hdc, iLayerPlane, iStart, cEntries, Pgdi_colorref(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetLayerPaletteEntries(hdc: gdi_device_context; iLayerPlane: Int32; iStart: Int32; cEntries: Int32; var pcr: gdi_colorref): Int32 :=
    z_GetLayerPaletteEntries_2(hdc, iLayerPlane, iStart, cEntries, pcr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetLayerPaletteEntries(hdc: gdi_device_context; iLayerPlane: Int32; iStart: Int32; cEntries: Int32; pcr: IntPtr): Int32 :=
    z_GetLayerPaletteEntries_1(hdc, iLayerPlane, iStart, cEntries, pcr);
    
    // added in wgl1.0
    private static function z_GetProcAddress_1(lpszProc: IntPtr): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProcAddress(lpszProc: string): IntPtr;
    begin
      var lpszProc_str_ptr: IntPtr;
      try
        lpszProc_str_ptr := Marshal.StringToHGlobalAnsi(lpszProc);
        Result := z_GetProcAddress_1(lpszProc_str_ptr);
      finally
        Marshal.FreeHGlobal(lpszProc_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProcAddress(lpszProc: IntPtr): IntPtr :=
    z_GetProcAddress_1(lpszProc);
    
    // added in wgl1.0
    private static function z_MakeCurrent_1(hDc: gdi_device_context; newContext: wgl_context): Bool;
    external 'opengl32.dll' name 'wglMakeCurrent';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function MakeCurrent(hDc: gdi_device_context; newContext: wgl_context): Bool :=
    z_MakeCurrent_1(hDc, newContext);
    
    // added in wgl1.0
    private static function z_RealizeLayerPalette_1(hdc: gdi_device_context; iLayerPlane: Int32; bRealize: Bool): Bool;
    external 'opengl32.dll' name 'wglRealizeLayerPalette';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function RealizeLayerPalette(hdc: gdi_device_context; iLayerPlane: Int32; bRealize: Bool): Bool :=
    z_RealizeLayerPalette_1(hdc, iLayerPlane, bRealize);
    
    // added in wgl1.0
    private static function z_SetLayerPaletteEntries_1(hdc: gdi_device_context; iLayerPlane: Int32; iStart: Int32; cEntries: Int32; pcr: IntPtr): Int32;
    external 'opengl32.dll' name 'wglSetLayerPaletteEntries';
    private static function z_SetLayerPaletteEntries_2(hdc: gdi_device_context; iLayerPlane: Int32; iStart: Int32; cEntries: Int32; var pcr: gdi_colorref): Int32;
    external 'opengl32.dll' name 'wglSetLayerPaletteEntries';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetLayerPaletteEntries(hdc: gdi_device_context; iLayerPlane: Int32; iStart: Int32; cEntries: Int32; pcr: array of gdi_colorref): Int32;
    type Pgdi_colorref=^gdi_colorref;
    begin
      Result := if (pcr<>nil) and (pcr.Length<>0) then
        z_SetLayerPaletteEntries_2(hdc, iLayerPlane, iStart, cEntries, pcr[0]) else
        z_SetLayerPaletteEntries_2(hdc, iLayerPlane, iStart, cEntries, Pgdi_colorref(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetLayerPaletteEntries(hdc: gdi_device_context; iLayerPlane: Int32; iStart: Int32; cEntries: Int32; var pcr: gdi_colorref): Int32 :=
    z_SetLayerPaletteEntries_2(hdc, iLayerPlane, iStart, cEntries, pcr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetLayerPaletteEntries(hdc: gdi_device_context; iLayerPlane: Int32; iStart: Int32; cEntries: Int32; pcr: IntPtr): Int32 :=
    z_SetLayerPaletteEntries_1(hdc, iLayerPlane, iStart, cEntries, pcr);
    
    // added in wgl1.0
    private static function z_ShareLists_1(hrcSrvShare: wgl_context; hrcSrvSource: wgl_context): Bool;
    external 'opengl32.dll' name 'wglShareLists';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ShareLists(hrcSrvShare: wgl_context; hrcSrvSource: wgl_context): Bool :=
    z_ShareLists_1(hrcSrvShare, hrcSrvSource);
    
    // added in wgl1.0
    private static function z_SwapLayerBuffers_1(hdc: gdi_device_context; fuFlags: UInt32): Bool;
    external 'opengl32.dll' name 'wglSwapLayerBuffers';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SwapLayerBuffers(hdc: gdi_device_context; fuFlags: UInt32): Bool :=
    z_SwapLayerBuffers_1(hdc, fuFlags);
    
    // added in wgl1.0
    private static function z_UseFontBitmaps_1(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32): Bool;
    external 'opengl32.dll' name 'wglUseFontBitmaps';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function UseFontBitmaps(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32): Bool :=
    z_UseFontBitmaps_1(hDC, first, count, listBase);
    
    // added in wgl1.0
    private static function z_UseFontBitmapsA_1(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32): Bool;
    external 'opengl32.dll' name 'wglUseFontBitmapsA';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function UseFontBitmapsA(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32): Bool :=
    z_UseFontBitmapsA_1(hDC, first, count, listBase);
    
    // added in wgl1.0
    private static function z_UseFontBitmapsW_1(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32): Bool;
    external 'opengl32.dll' name 'wglUseFontBitmapsW';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function UseFontBitmapsW(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32): Bool :=
    z_UseFontBitmapsW_1(hDC, first, count, listBase);
    
    // added in wgl1.0
    private static function z_UseFontOutlines_1(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: Int32; lpgmf: IntPtr): Bool;
    external 'opengl32.dll' name 'wglUseFontOutlines';
    private static function z_UseFontOutlines_2(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: Int32; var lpgmf: gdi_glyphmetrics_float): Bool;
    external 'opengl32.dll' name 'wglUseFontOutlines';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function UseFontOutlines(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: Int32; lpgmf: array of gdi_glyphmetrics_float): Bool;
    type Pgdi_glyphmetrics_float=^gdi_glyphmetrics_float;
    begin
      Result := if (lpgmf<>nil) and (lpgmf.Length<>0) then
        z_UseFontOutlines_2(hDC, first, count, listBase, deviation, extrusion, format, lpgmf[0]) else
        z_UseFontOutlines_2(hDC, first, count, listBase, deviation, extrusion, format, Pgdi_glyphmetrics_float(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function UseFontOutlines(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: Int32; var lpgmf: gdi_glyphmetrics_float): Bool :=
    z_UseFontOutlines_2(hDC, first, count, listBase, deviation, extrusion, format, lpgmf);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function UseFontOutlines(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: Int32; lpgmf: IntPtr): Bool :=
    z_UseFontOutlines_1(hDC, first, count, listBase, deviation, extrusion, format, lpgmf);
    
    // added in wgl1.0
    private static function z_UseFontOutlinesA_1(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: Int32; lpgmf: IntPtr): Bool;
    external 'opengl32.dll' name 'wglUseFontOutlinesA';
    private static function z_UseFontOutlinesA_2(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: Int32; var lpgmf: gdi_glyphmetrics_float): Bool;
    external 'opengl32.dll' name 'wglUseFontOutlinesA';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function UseFontOutlinesA(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: Int32; lpgmf: array of gdi_glyphmetrics_float): Bool;
    type Pgdi_glyphmetrics_float=^gdi_glyphmetrics_float;
    begin
      Result := if (lpgmf<>nil) and (lpgmf.Length<>0) then
        z_UseFontOutlinesA_2(hDC, first, count, listBase, deviation, extrusion, format, lpgmf[0]) else
        z_UseFontOutlinesA_2(hDC, first, count, listBase, deviation, extrusion, format, Pgdi_glyphmetrics_float(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function UseFontOutlinesA(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: Int32; var lpgmf: gdi_glyphmetrics_float): Bool :=
    z_UseFontOutlinesA_2(hDC, first, count, listBase, deviation, extrusion, format, lpgmf);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function UseFontOutlinesA(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: Int32; lpgmf: IntPtr): Bool :=
    z_UseFontOutlinesA_1(hDC, first, count, listBase, deviation, extrusion, format, lpgmf);
    
    // added in wgl1.0
    private static function z_UseFontOutlinesW_1(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: Int32; lpgmf: IntPtr): Bool;
    external 'opengl32.dll' name 'wglUseFontOutlinesW';
    private static function z_UseFontOutlinesW_2(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: Int32; var lpgmf: gdi_glyphmetrics_float): Bool;
    external 'opengl32.dll' name 'wglUseFontOutlinesW';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function UseFontOutlinesW(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: Int32; lpgmf: array of gdi_glyphmetrics_float): Bool;
    type Pgdi_glyphmetrics_float=^gdi_glyphmetrics_float;
    begin
      Result := if (lpgmf<>nil) and (lpgmf.Length<>0) then
        z_UseFontOutlinesW_2(hDC, first, count, listBase, deviation, extrusion, format, lpgmf[0]) else
        z_UseFontOutlinesW_2(hDC, first, count, listBase, deviation, extrusion, format, Pgdi_glyphmetrics_float(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function UseFontOutlinesW(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: Int32; var lpgmf: gdi_glyphmetrics_float): Bool :=
    z_UseFontOutlinesW_2(hDC, first, count, listBase, deviation, extrusion, format, lpgmf);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function UseFontOutlinesW(hDC: gdi_device_context; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: Int32; lpgmf: IntPtr): Bool :=
    z_UseFontOutlinesW_1(hDC, first, count, listBase, deviation, extrusion, format, lpgmf);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glx = static class
    
    // added in glx1.3
    private static function z_ChooseFBConfig_1(dpy: x_p_display; screen: Int32; attrib_list: IntPtr; nelements: IntPtr): ^glx_fb_config;
    external 'libGL.so.1' name 'glXChooseFBConfig';
    private static function z_ChooseFBConfig_2(dpy: x_p_display; screen: Int32; attrib_list: IntPtr; var nelements: Int32): ^glx_fb_config;
    external 'libGL.so.1' name 'glXChooseFBConfig';
    private static function z_ChooseFBConfig_3(dpy: x_p_display; screen: Int32; var attrib_list: Int32; nelements: IntPtr): ^glx_fb_config;
    external 'libGL.so.1' name 'glXChooseFBConfig';
    private static function z_ChooseFBConfig_4(dpy: x_p_display; screen: Int32; var attrib_list: Int32; var nelements: Int32): ^glx_fb_config;
    external 'libGL.so.1' name 'glXChooseFBConfig';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ChooseFBConfig(dpy: x_p_display; screen: Int32; attrib_list: array of Int32; nelements: array of Int32): ^glx_fb_config;
    type PInt32=^Int32;
    begin
      Result := if (nelements<>nil) and (nelements.Length<>0) then
        if (attrib_list<>nil) and (attrib_list.Length<>0) then
          z_ChooseFBConfig_4(dpy, screen, attrib_list[0], nelements[0]) else
          z_ChooseFBConfig_4(dpy, screen, PInt32(nil)^, nelements[0]) else
        if (attrib_list<>nil) and (attrib_list.Length<>0) then
          z_ChooseFBConfig_4(dpy, screen, attrib_list[0], PInt32(nil)^) else
          z_ChooseFBConfig_4(dpy, screen, PInt32(nil)^, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ChooseFBConfig(dpy: x_p_display; screen: Int32; var attrib_list: Int32; var nelements: Int32): ^glx_fb_config :=
    z_ChooseFBConfig_4(dpy, screen, attrib_list, nelements);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ChooseFBConfig(dpy: x_p_display; screen: Int32; var attrib_list: Int32; nelements: IntPtr): ^glx_fb_config :=
    z_ChooseFBConfig_3(dpy, screen, attrib_list, nelements);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ChooseFBConfig(dpy: x_p_display; screen: Int32; attrib_list: IntPtr; var nelements: Int32): ^glx_fb_config :=
    z_ChooseFBConfig_2(dpy, screen, attrib_list, nelements);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ChooseFBConfig(dpy: x_p_display; screen: Int32; attrib_list: IntPtr; nelements: IntPtr): ^glx_fb_config :=
    z_ChooseFBConfig_1(dpy, screen, attrib_list, nelements);
    
    // added in glx1.0
    private static function z_ChooseVisual_1(dpy: x_p_display; screen: Int32; attribList: IntPtr): x_p_visual_info;
    external 'libGL.so.1' name 'glXChooseVisual';
    private static function z_ChooseVisual_2(dpy: x_p_display; screen: Int32; var attribList: Int32): x_p_visual_info;
    external 'libGL.so.1' name 'glXChooseVisual';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ChooseVisual(dpy: x_p_display; screen: Int32; attribList: array of Int32): x_p_visual_info;
    type PInt32=^Int32;
    begin
      Result := if (attribList<>nil) and (attribList.Length<>0) then
        z_ChooseVisual_2(dpy, screen, attribList[0]) else
        z_ChooseVisual_2(dpy, screen, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ChooseVisual(dpy: x_p_display; screen: Int32; var attribList: Int32): x_p_visual_info :=
    z_ChooseVisual_2(dpy, screen, attribList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ChooseVisual(dpy: x_p_display; screen: Int32; attribList: IntPtr): x_p_visual_info :=
    z_ChooseVisual_1(dpy, screen, attribList);
    
    // added in glx1.0
    private static procedure z_CopyContext_1(dpy: x_p_display; src: glx_context; dst: glx_context; mask: UInt64);
    external 'libGL.so.1' name 'glXCopyContext';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static procedure CopyContext(dpy: x_p_display; src: glx_context; dst: glx_context; mask: UInt64) :=
    z_CopyContext_1(dpy, src, dst, mask);
    
    // added in glx1.0
    private static function z_CreateContext_1(dpy: x_p_display; vis: x_p_visual_info; shareList: glx_context; direct: Bool): glx_context;
    external 'libGL.so.1' name 'glXCreateContext';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateContext(dpy: x_p_display; vis: x_p_visual_info; shareList: glx_context; direct: Bool): glx_context :=
    z_CreateContext_1(dpy, vis, shareList, direct);
    
    // added in glx1.0
    private static function z_CreateGLXPixmap_1(dpy: x_p_display; visual: x_p_visual_info; pixmap: x_pixmap): glx_pixmap;
    external 'libGL.so.1' name 'glXCreateGLXPixmap';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateGLXPixmap(dpy: x_p_display; visual: x_p_visual_info; pixmap: x_pixmap): glx_pixmap :=
    z_CreateGLXPixmap_1(dpy, visual, pixmap);
    
    // added in glx1.3
    private static function z_CreateNewContext_1(dpy: x_p_display; config: glx_fb_config; render_type: Int32; share_list: glx_context; direct: Bool): glx_context;
    external 'libGL.so.1' name 'glXCreateNewContext';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateNewContext(dpy: x_p_display; config: glx_fb_config; render_type: Int32; share_list: glx_context; direct: Bool): glx_context :=
    z_CreateNewContext_1(dpy, config, render_type, share_list, direct);
    
    // added in glx1.3
    private static function z_CreatePbuffer_1(dpy: x_p_display; config: glx_fb_config; attrib_list: IntPtr): glx_pbuffer;
    external 'libGL.so.1' name 'glXCreatePbuffer';
    private static function z_CreatePbuffer_2(dpy: x_p_display; config: glx_fb_config; var attrib_list: Int32): glx_pbuffer;
    external 'libGL.so.1' name 'glXCreatePbuffer';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreatePbuffer(dpy: x_p_display; config: glx_fb_config; attrib_list: array of Int32): glx_pbuffer;
    type PInt32=^Int32;
    begin
      Result := if (attrib_list<>nil) and (attrib_list.Length<>0) then
        z_CreatePbuffer_2(dpy, config, attrib_list[0]) else
        z_CreatePbuffer_2(dpy, config, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreatePbuffer(dpy: x_p_display; config: glx_fb_config; var attrib_list: Int32): glx_pbuffer :=
    z_CreatePbuffer_2(dpy, config, attrib_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreatePbuffer(dpy: x_p_display; config: glx_fb_config; attrib_list: IntPtr): glx_pbuffer :=
    z_CreatePbuffer_1(dpy, config, attrib_list);
    
    // added in glx1.3
    private static function z_CreatePixmap_1(dpy: x_p_display; config: glx_fb_config; pixmap: x_pixmap; attrib_list: IntPtr): glx_pixmap;
    external 'libGL.so.1' name 'glXCreatePixmap';
    private static function z_CreatePixmap_2(dpy: x_p_display; config: glx_fb_config; pixmap: x_pixmap; var attrib_list: Int32): glx_pixmap;
    external 'libGL.so.1' name 'glXCreatePixmap';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreatePixmap(dpy: x_p_display; config: glx_fb_config; pixmap: x_pixmap; attrib_list: array of Int32): glx_pixmap;
    type PInt32=^Int32;
    begin
      Result := if (attrib_list<>nil) and (attrib_list.Length<>0) then
        z_CreatePixmap_2(dpy, config, pixmap, attrib_list[0]) else
        z_CreatePixmap_2(dpy, config, pixmap, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreatePixmap(dpy: x_p_display; config: glx_fb_config; pixmap: x_pixmap; var attrib_list: Int32): glx_pixmap :=
    z_CreatePixmap_2(dpy, config, pixmap, attrib_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreatePixmap(dpy: x_p_display; config: glx_fb_config; pixmap: x_pixmap; attrib_list: IntPtr): glx_pixmap :=
    z_CreatePixmap_1(dpy, config, pixmap, attrib_list);
    
    // added in glx1.3
    private static function z_CreateWindow_1(dpy: x_p_display; config: glx_fb_config; win: x_window; attrib_list: IntPtr): glx_window;
    external 'libGL.so.1' name 'glXCreateWindow';
    private static function z_CreateWindow_2(dpy: x_p_display; config: glx_fb_config; win: x_window; var attrib_list: Int32): glx_window;
    external 'libGL.so.1' name 'glXCreateWindow';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateWindow(dpy: x_p_display; config: glx_fb_config; win: x_window; attrib_list: array of Int32): glx_window;
    type PInt32=^Int32;
    begin
      Result := if (attrib_list<>nil) and (attrib_list.Length<>0) then
        z_CreateWindow_2(dpy, config, win, attrib_list[0]) else
        z_CreateWindow_2(dpy, config, win, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateWindow(dpy: x_p_display; config: glx_fb_config; win: x_window; var attrib_list: Int32): glx_window :=
    z_CreateWindow_2(dpy, config, win, attrib_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateWindow(dpy: x_p_display; config: glx_fb_config; win: x_window; attrib_list: IntPtr): glx_window :=
    z_CreateWindow_1(dpy, config, win, attrib_list);
    
    // added in glx1.0
    private static procedure z_DestroyContext_1(dpy: x_p_display; ctx: glx_context);
    external 'libGL.so.1' name 'glXDestroyContext';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static procedure DestroyContext(dpy: x_p_display; ctx: glx_context) :=
    z_DestroyContext_1(dpy, ctx);
    
    // added in glx1.0
    private static procedure z_DestroyGLXPixmap_1(dpy: x_p_display; pixmap: glx_pixmap);
    external 'libGL.so.1' name 'glXDestroyGLXPixmap';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static procedure DestroyGLXPixmap(dpy: x_p_display; pixmap: glx_pixmap) :=
    z_DestroyGLXPixmap_1(dpy, pixmap);
    
    // added in glx1.3
    private static procedure z_DestroyPbuffer_1(dpy: x_p_display; pbuf: glx_pbuffer);
    external 'libGL.so.1' name 'glXDestroyPbuffer';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static procedure DestroyPbuffer(dpy: x_p_display; pbuf: glx_pbuffer) :=
    z_DestroyPbuffer_1(dpy, pbuf);
    
    // added in glx1.3
    private static procedure z_DestroyPixmap_1(dpy: x_p_display; pixmap: glx_pixmap);
    external 'libGL.so.1' name 'glXDestroyPixmap';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static procedure DestroyPixmap(dpy: x_p_display; pixmap: glx_pixmap) :=
    z_DestroyPixmap_1(dpy, pixmap);
    
    // added in glx1.3
    private static procedure z_DestroyWindow_1(dpy: x_p_display; win: glx_window);
    external 'libGL.so.1' name 'glXDestroyWindow';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static procedure DestroyWindow(dpy: x_p_display; win: glx_window) :=
    z_DestroyWindow_1(dpy, win);
    
    // added in glx1.1
    private static function z_GetClientString_1(dpy: x_p_display; name: Int32): IntPtr;
    external 'libGL.so.1' name 'glXGetClientString';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetClientString(dpy: x_p_display; name: Int32): string;
    begin
      var Result_str_ptr: IntPtr;
      Result_str_ptr := z_GetClientString_1(dpy, name);
      Result := Marshal.PtrToStringAnsi(Result_str_ptr);
    end;
    
    // added in glx1.0
    private static function z_GetConfig_1(dpy: x_p_display; visual: x_p_visual_info; attrib: Int32; value: IntPtr): Int32;
    external 'libGL.so.1' name 'glXGetConfig';
    private static function z_GetConfig_2(dpy: x_p_display; visual: x_p_visual_info; attrib: Int32; var value: Int32): Int32;
    external 'libGL.so.1' name 'glXGetConfig';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetConfig(dpy: x_p_display; visual: x_p_visual_info; attrib: Int32; var value: Int32): Int32 :=
    z_GetConfig_2(dpy, visual, attrib, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetConfig(dpy: x_p_display; visual: x_p_visual_info; attrib: Int32; value: IntPtr): Int32 :=
    z_GetConfig_1(dpy, visual, attrib, value);
    
    // added in glx1.0
    private static function z_GetCurrentContext_1: glx_context;
    external 'libGL.so.1' name 'glXGetCurrentContext';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCurrentContext: glx_context :=
    z_GetCurrentContext_1();
    
    // added in glx1.2
    private static function z_GetCurrentDisplay_1: x_p_display;
    external 'libGL.so.1' name 'glXGetCurrentDisplay';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCurrentDisplay: x_p_display :=
    z_GetCurrentDisplay_1();
    
    // added in glx1.0
    private static function z_GetCurrentDrawable_1: glx_drawable;
    external 'libGL.so.1' name 'glXGetCurrentDrawable';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCurrentDrawable: glx_drawable :=
    z_GetCurrentDrawable_1();
    
    // added in glx1.3
    private static function z_GetCurrentReadDrawable_1: glx_drawable;
    external 'libGL.so.1' name 'glXGetCurrentReadDrawable';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCurrentReadDrawable: glx_drawable :=
    z_GetCurrentReadDrawable_1();
    
    // added in glx1.3
    private static function z_GetFBConfigAttrib_1(dpy: x_p_display; config: glx_fb_config; attribute: Int32; value: IntPtr): Int32;
    external 'libGL.so.1' name 'glXGetFBConfigAttrib';
    private static function z_GetFBConfigAttrib_2(dpy: x_p_display; config: glx_fb_config; attribute: Int32; var value: Int32): Int32;
    external 'libGL.so.1' name 'glXGetFBConfigAttrib';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetFBConfigAttrib(dpy: x_p_display; config: glx_fb_config; attribute: Int32; var value: Int32): Int32 :=
    z_GetFBConfigAttrib_2(dpy, config, attribute, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetFBConfigAttrib(dpy: x_p_display; config: glx_fb_config; attribute: Int32; value: IntPtr): Int32 :=
    z_GetFBConfigAttrib_1(dpy, config, attribute, value);
    
    // added in glx1.3
    private static function z_GetFBConfigs_1(dpy: x_p_display; screen: Int32; nelements: IntPtr): ^glx_fb_config;
    external 'libGL.so.1' name 'glXGetFBConfigs';
    private static function z_GetFBConfigs_2(dpy: x_p_display; screen: Int32; var nelements: Int32): ^glx_fb_config;
    external 'libGL.so.1' name 'glXGetFBConfigs';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetFBConfigs(dpy: x_p_display; screen: Int32; var nelements: Int32): ^glx_fb_config :=
    z_GetFBConfigs_2(dpy, screen, nelements);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetFBConfigs(dpy: x_p_display; screen: Int32; nelements: IntPtr): ^glx_fb_config :=
    z_GetFBConfigs_1(dpy, screen, nelements);
    
    // added in glx1.4
    private static function z_GetProcAddress_1(procName: IntPtr): IntPtr;
    external 'libGL.so.1' name 'glXGetProcAddress';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProcAddress(procName: string): IntPtr;
    begin
      var procName_str_ptr: IntPtr;
      try
        procName_str_ptr := Marshal.StringToHGlobalAnsi(procName);
        Result := z_GetProcAddress_1(procName_str_ptr);
      finally
        Marshal.FreeHGlobal(procName_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProcAddress(procName: IntPtr): IntPtr :=
    z_GetProcAddress_1(procName);
    
    // added in glx1.3
    private static procedure z_GetSelectedEvent_1(dpy: x_p_display; draw: glx_drawable; event_mask: IntPtr);
    external 'libGL.so.1' name 'glXGetSelectedEvent';
    private static procedure z_GetSelectedEvent_2(dpy: x_p_display; draw: glx_drawable; var event_mask: UInt64);
    external 'libGL.so.1' name 'glXGetSelectedEvent';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static procedure GetSelectedEvent(dpy: x_p_display; draw: glx_drawable; var event_mask: UInt64) :=
    z_GetSelectedEvent_2(dpy, draw, event_mask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static procedure GetSelectedEvent(dpy: x_p_display; draw: glx_drawable; event_mask: IntPtr) :=
    z_GetSelectedEvent_1(dpy, draw, event_mask);
    
    // added in glx1.3
    private static function z_GetVisualFromFBConfig_1(dpy: x_p_display; config: glx_fb_config): x_p_visual_info;
    external 'libGL.so.1' name 'glXGetVisualFromFBConfig';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetVisualFromFBConfig(dpy: x_p_display; config: glx_fb_config): x_p_visual_info :=
    z_GetVisualFromFBConfig_1(dpy, config);
    
    // added in glx1.0
    private static function z_IsDirect_1(dpy: x_p_display; ctx: glx_context): Bool;
    external 'libGL.so.1' name 'glXIsDirect';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function IsDirect(dpy: x_p_display; ctx: glx_context): Bool :=
    z_IsDirect_1(dpy, ctx);
    
    // added in glx1.3
    private static function z_MakeContextCurrent_1(dpy: x_p_display; draw: glx_drawable; read: glx_drawable; ctx: glx_context): Bool;
    external 'libGL.so.1' name 'glXMakeContextCurrent';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function MakeContextCurrent(dpy: x_p_display; draw: glx_drawable; read: glx_drawable; ctx: glx_context): Bool :=
    z_MakeContextCurrent_1(dpy, draw, read, ctx);
    
    // added in glx1.0
    private static function z_MakeCurrent_1(dpy: x_p_display; drawable: glx_drawable; ctx: glx_context): Bool;
    external 'libGL.so.1' name 'glXMakeCurrent';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function MakeCurrent(dpy: x_p_display; drawable: glx_drawable; ctx: glx_context): Bool :=
    z_MakeCurrent_1(dpy, drawable, ctx);
    
    // added in glx1.3
    private static function z_QueryContext_1(dpy: x_p_display; ctx: glx_context; attribute: Int32; value: IntPtr): Int32;
    external 'libGL.so.1' name 'glXQueryContext';
    private static function z_QueryContext_2(dpy: x_p_display; ctx: glx_context; attribute: Int32; var value: Int32): Int32;
    external 'libGL.so.1' name 'glXQueryContext';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function QueryContext(dpy: x_p_display; ctx: glx_context; attribute: Int32; value: array of Int32): Int32;
    type PInt32=^Int32;
    begin
      Result := if (value<>nil) and (value.Length<>0) then
        z_QueryContext_2(dpy, ctx, attribute, value[0]) else
        z_QueryContext_2(dpy, ctx, attribute, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function QueryContext(dpy: x_p_display; ctx: glx_context; attribute: Int32; var value: Int32): Int32 :=
    z_QueryContext_2(dpy, ctx, attribute, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function QueryContext(dpy: x_p_display; ctx: glx_context; attribute: Int32; value: IntPtr): Int32 :=
    z_QueryContext_1(dpy, ctx, attribute, value);
    
    // added in glx1.3
    private static procedure z_QueryDrawable_1(dpy: x_p_display; draw: glx_drawable; attribute: Int32; value: IntPtr);
    external 'libGL.so.1' name 'glXQueryDrawable';
    private static procedure z_QueryDrawable_2(dpy: x_p_display; draw: glx_drawable; attribute: Int32; var value: UInt32);
    external 'libGL.so.1' name 'glXQueryDrawable';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static procedure QueryDrawable(dpy: x_p_display; draw: glx_drawable; attribute: Int32; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_QueryDrawable_2(dpy, draw, attribute, value[0]) else
        z_QueryDrawable_2(dpy, draw, attribute, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static procedure QueryDrawable(dpy: x_p_display; draw: glx_drawable; attribute: Int32; var value: UInt32) :=
    z_QueryDrawable_2(dpy, draw, attribute, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static procedure QueryDrawable(dpy: x_p_display; draw: glx_drawable; attribute: Int32; value: IntPtr) :=
    z_QueryDrawable_1(dpy, draw, attribute, value);
    
    // added in glx1.0
    private static function z_QueryExtension_1(dpy: x_p_display; errorb: IntPtr; &event: IntPtr): Bool;
    external 'libGL.so.1' name 'glXQueryExtension';
    private static function z_QueryExtension_2(dpy: x_p_display; errorb: IntPtr; var &event: Int32): Bool;
    external 'libGL.so.1' name 'glXQueryExtension';
    private static function z_QueryExtension_3(dpy: x_p_display; var errorb: Int32; &event: IntPtr): Bool;
    external 'libGL.so.1' name 'glXQueryExtension';
    private static function z_QueryExtension_4(dpy: x_p_display; var errorb: Int32; var &event: Int32): Bool;
    external 'libGL.so.1' name 'glXQueryExtension';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function QueryExtension(dpy: x_p_display; errorb: array of Int32; &event: array of Int32): Bool;
    type PInt32=^Int32;
    begin
      Result := if (&event<>nil) and (&event.Length<>0) then
        if (errorb<>nil) and (errorb.Length<>0) then
          z_QueryExtension_4(dpy, errorb[0], &event[0]) else
          z_QueryExtension_4(dpy, PInt32(nil)^, &event[0]) else
        if (errorb<>nil) and (errorb.Length<>0) then
          z_QueryExtension_4(dpy, errorb[0], PInt32(nil)^) else
          z_QueryExtension_4(dpy, PInt32(nil)^, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function QueryExtension(dpy: x_p_display; var errorb: Int32; var &event: Int32): Bool :=
    z_QueryExtension_4(dpy, errorb, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function QueryExtension(dpy: x_p_display; var errorb: Int32; &event: IntPtr): Bool :=
    z_QueryExtension_3(dpy, errorb, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function QueryExtension(dpy: x_p_display; errorb: IntPtr; var &event: Int32): Bool :=
    z_QueryExtension_2(dpy, errorb, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function QueryExtension(dpy: x_p_display; errorb: IntPtr; &event: IntPtr): Bool :=
    z_QueryExtension_1(dpy, errorb, &event);
    
    // added in glx1.1
    private static function z_QueryExtensionsString_1(dpy: x_p_display; screen: Int32): IntPtr;
    external 'libGL.so.1' name 'glXQueryExtensionsString';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function QueryExtensionsString(dpy: x_p_display; screen: Int32): string;
    begin
      var Result_str_ptr: IntPtr;
      Result_str_ptr := z_QueryExtensionsString_1(dpy, screen);
      Result := Marshal.PtrToStringAnsi(Result_str_ptr);
    end;
    
    // added in glx1.1
    private static function z_QueryServerString_1(dpy: x_p_display; screen: Int32; name: Int32): IntPtr;
    external 'libGL.so.1' name 'glXQueryServerString';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function QueryServerString(dpy: x_p_display; screen: Int32; name: Int32): string;
    begin
      var Result_str_ptr: IntPtr;
      Result_str_ptr := z_QueryServerString_1(dpy, screen, name);
      Result := Marshal.PtrToStringAnsi(Result_str_ptr);
    end;
    
    // added in glx1.0
    private static function z_QueryVersion_1(dpy: x_p_display; maj: IntPtr; min: IntPtr): Bool;
    external 'libGL.so.1' name 'glXQueryVersion';
    private static function z_QueryVersion_2(dpy: x_p_display; maj: IntPtr; var min: Int32): Bool;
    external 'libGL.so.1' name 'glXQueryVersion';
    private static function z_QueryVersion_3(dpy: x_p_display; var maj: Int32; min: IntPtr): Bool;
    external 'libGL.so.1' name 'glXQueryVersion';
    private static function z_QueryVersion_4(dpy: x_p_display; var maj: Int32; var min: Int32): Bool;
    external 'libGL.so.1' name 'glXQueryVersion';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function QueryVersion(dpy: x_p_display; maj: array of Int32; min: array of Int32): Bool;
    type PInt32=^Int32;
    begin
      Result := if (min<>nil) and (min.Length<>0) then
        if (maj<>nil) and (maj.Length<>0) then
          z_QueryVersion_4(dpy, maj[0], min[0]) else
          z_QueryVersion_4(dpy, PInt32(nil)^, min[0]) else
        if (maj<>nil) and (maj.Length<>0) then
          z_QueryVersion_4(dpy, maj[0], PInt32(nil)^) else
          z_QueryVersion_4(dpy, PInt32(nil)^, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function QueryVersion(dpy: x_p_display; var maj: Int32; var min: Int32): Bool :=
    z_QueryVersion_4(dpy, maj, min);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function QueryVersion(dpy: x_p_display; var maj: Int32; min: IntPtr): Bool :=
    z_QueryVersion_3(dpy, maj, min);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function QueryVersion(dpy: x_p_display; maj: IntPtr; var min: Int32): Bool :=
    z_QueryVersion_2(dpy, maj, min);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function QueryVersion(dpy: x_p_display; maj: IntPtr; min: IntPtr): Bool :=
    z_QueryVersion_1(dpy, maj, min);
    
    // added in glx1.3
    private static procedure z_SelectEvent_1(dpy: x_p_display; draw: glx_drawable; event_mask: UInt64);
    external 'libGL.so.1' name 'glXSelectEvent';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static procedure SelectEvent(dpy: x_p_display; draw: glx_drawable; event_mask: UInt64) :=
    z_SelectEvent_1(dpy, draw, event_mask);
    
    // added in glx1.0
    private static procedure z_SwapBuffers_1(dpy: x_p_display; drawable: glx_drawable);
    external 'libGL.so.1' name 'glXSwapBuffers';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static procedure SwapBuffers(dpy: x_p_display; drawable: glx_drawable) :=
    z_SwapBuffers_1(dpy, drawable);
    
    // added in glx1.0
    private static procedure z_UseXFont_1(font: x_font; first: Int32; count: Int32; list: Int32);
    external 'libGL.so.1' name 'glXUseXFont';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static procedure UseXFont(font: x_font; first: Int32; count: Int32; list: Int32) :=
    z_UseXFont_1(font, first, count, list);
    
    // added in glx1.0
    private static procedure z_WaitGL_1;
    external 'libGL.so.1' name 'glXWaitGL';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static procedure WaitGL :=
    z_WaitGL_1();
    
    // added in glx1.0
    private static procedure z_WaitX_1;
    external 'libGL.so.1' name 'glXWaitX';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static procedure WaitX :=
    z_WaitX_1();
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  gdi = static class
    
    private static function z_ChoosePixelFormat_1(hDc: gdi_device_context; pPfd: IntPtr): Int32;
    external 'gdi32.dll' name 'ChoosePixelFormat';
    private static function z_ChoosePixelFormat_2(hDc: gdi_device_context; var pPfd: gdi_pixel_format_descriptor): Int32;
    external 'gdi32.dll' name 'ChoosePixelFormat';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ChoosePixelFormat(hDc: gdi_device_context; pPfd: array of gdi_pixel_format_descriptor): Int32;
    type Pgdi_pixel_format_descriptor=^gdi_pixel_format_descriptor;
    begin
      Result := if (pPfd<>nil) and (pPfd.Length<>0) then
        z_ChoosePixelFormat_2(hDc, pPfd[0]) else
        z_ChoosePixelFormat_2(hDc, Pgdi_pixel_format_descriptor(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ChoosePixelFormat(hDc: gdi_device_context; var pPfd: gdi_pixel_format_descriptor): Int32 :=
    z_ChoosePixelFormat_2(hDc, pPfd);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ChoosePixelFormat(hDc: gdi_device_context; pPfd: IntPtr): Int32 :=
    z_ChoosePixelFormat_1(hDc, pPfd);
    
    private static function z_DescribePixelFormat_1(hdc: gdi_device_context; ipfd: Int32; cjpfd: UInt32; ppfd: IntPtr): Int32;
    external 'gdi32.dll' name 'DescribePixelFormat';
    private static function z_DescribePixelFormat_2(hdc: gdi_device_context; ipfd: Int32; cjpfd: UInt32; var ppfd: gdi_pixel_format_descriptor): Int32;
    external 'gdi32.dll' name 'DescribePixelFormat';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function DescribePixelFormat(hdc: gdi_device_context; ipfd: Int32; cjpfd: UInt32; ppfd: array of gdi_pixel_format_descriptor): Int32;
    type Pgdi_pixel_format_descriptor=^gdi_pixel_format_descriptor;
    begin
      Result := if (ppfd<>nil) and (ppfd.Length<>0) then
        z_DescribePixelFormat_2(hdc, ipfd, cjpfd, ppfd[0]) else
        z_DescribePixelFormat_2(hdc, ipfd, cjpfd, Pgdi_pixel_format_descriptor(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function DescribePixelFormat(hdc: gdi_device_context; ipfd: Int32; cjpfd: UInt32; var ppfd: gdi_pixel_format_descriptor): Int32 :=
    z_DescribePixelFormat_2(hdc, ipfd, cjpfd, ppfd);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function DescribePixelFormat(hdc: gdi_device_context; ipfd: Int32; cjpfd: UInt32; ppfd: IntPtr): Int32 :=
    z_DescribePixelFormat_1(hdc, ipfd, cjpfd, ppfd);
    
    private static function z_GetEnhMetaFilePixelFormat_1(hemf: gdi_h_enh_metafile; ppfd: IntPtr): UInt32;
    external 'gdi32.dll' name 'GetEnhMetaFilePixelFormat';
    private static function z_GetEnhMetaFilePixelFormat_2(hemf: gdi_h_enh_metafile; var ppfd: gdi_pixel_format_descriptor): UInt32;
    external 'gdi32.dll' name 'GetEnhMetaFilePixelFormat';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEnhMetaFilePixelFormat(hemf: gdi_h_enh_metafile; ppfd: array of gdi_pixel_format_descriptor): UInt32;
    type Pgdi_pixel_format_descriptor=^gdi_pixel_format_descriptor;
    begin
      Result := if (ppfd<>nil) and (ppfd.Length<>0) then
        z_GetEnhMetaFilePixelFormat_2(hemf, ppfd[0]) else
        z_GetEnhMetaFilePixelFormat_2(hemf, Pgdi_pixel_format_descriptor(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEnhMetaFilePixelFormat(hemf: gdi_h_enh_metafile; var ppfd: gdi_pixel_format_descriptor): UInt32 :=
    z_GetEnhMetaFilePixelFormat_2(hemf, ppfd);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEnhMetaFilePixelFormat(hemf: gdi_h_enh_metafile; ppfd: IntPtr): UInt32 :=
    z_GetEnhMetaFilePixelFormat_1(hemf, ppfd);
    
    private static function z_GetPixelFormat_1(hdc: gdi_device_context): Int32;
    external 'gdi32.dll' name 'GetPixelFormat';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPixelFormat(hdc: gdi_device_context): Int32 :=
    z_GetPixelFormat_1(hdc);
    
    private static function z_SetPixelFormat_1(hdc: gdi_device_context; ipfd: Int32; ppfd: IntPtr): Bool;
    external 'gdi32.dll' name 'SetPixelFormat';
    private static function z_SetPixelFormat_2(hdc: gdi_device_context; ipfd: Int32; var ppfd: gdi_pixel_format_descriptor): Bool;
    external 'gdi32.dll' name 'SetPixelFormat';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetPixelFormat(hdc: gdi_device_context; ipfd: Int32; ppfd: array of gdi_pixel_format_descriptor): Bool;
    type Pgdi_pixel_format_descriptor=^gdi_pixel_format_descriptor;
    begin
      Result := if (ppfd<>nil) and (ppfd.Length<>0) then
        z_SetPixelFormat_2(hdc, ipfd, ppfd[0]) else
        z_SetPixelFormat_2(hdc, ipfd, Pgdi_pixel_format_descriptor(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetPixelFormat(hdc: gdi_device_context; ipfd: Int32; var ppfd: gdi_pixel_format_descriptor): Bool :=
    z_SetPixelFormat_2(hdc, ipfd, ppfd);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetPixelFormat(hdc: gdi_device_context; ipfd: Int32; ppfd: IntPtr): Bool :=
    z_SetPixelFormat_1(hdc, ipfd, ppfd);
    
    private static function z_SwapBuffers_1(hdc: gdi_device_context): Bool;
    external 'gdi32.dll' name 'SwapBuffers';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SwapBuffers(hdc: gdi_device_context): Bool :=
    z_SwapBuffers_1(hdc);
    
  end;
  
  {$region Extensions}
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glTbuffer3DFX = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_3dfx_tbuffer';
    
    private z_TbufferMask3DFX_adr := GetProcAddress('glTbufferMask3DFX');
    private z_TbufferMask3DFX_1 := GetProcOrNil&<procedure(mask: UInt32)>(z_TbufferMask3DFX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TbufferMask3DFX(mask: UInt32) :=
    z_TbufferMask3DFX_1(mask);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glDebugOutputAMD = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_amd_debug_output';
    
    private z_DebugMessageEnableAMD_adr := GetProcAddress('glDebugMessageEnableAMD');
    private z_DebugMessageEnableAMD_1 := GetProcOrNil&<procedure(category: DummyEnum; severity: DebugSeverity; count: Int32; ids: IntPtr; enabled: boolean)>(z_DebugMessageEnableAMD_adr);
    private z_DebugMessageEnableAMD_2 := GetProcOrNil&<procedure(category: DummyEnum; severity: DebugSeverity; count: Int32; var ids: UInt32; enabled: boolean)>(z_DebugMessageEnableAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageEnableAMD(category: DummyEnum; severity: DebugSeverity; count: Int32; ids: array of UInt32; enabled: boolean);
    type PUInt32=^UInt32;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        z_DebugMessageEnableAMD_2(category, severity, count, ids[0], enabled) else
        z_DebugMessageEnableAMD_2(category, severity, count, PUInt32(nil)^, enabled);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageEnableAMD(category: DummyEnum; severity: DebugSeverity; count: Int32; var ids: UInt32; enabled: boolean) :=
    z_DebugMessageEnableAMD_2(category, severity, count, ids, enabled);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageEnableAMD(category: DummyEnum; severity: DebugSeverity; count: Int32; ids: IntPtr; enabled: boolean) :=
    z_DebugMessageEnableAMD_1(category, severity, count, ids, enabled);
    
    private z_DebugMessageInsertAMD_adr := GetProcAddress('glDebugMessageInsertAMD');
    private z_DebugMessageInsertAMD_1 := GetProcOrNil&<procedure(category: DummyEnum; severity: DebugSeverity; id: UInt32; length: Int32; buf: IntPtr)>(z_DebugMessageInsertAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageInsertAMD(category: DummyEnum; severity: DebugSeverity; id: UInt32; length: Int32; buf: string);
    begin
      var buf_str_ptr: IntPtr;
      try
        buf_str_ptr := Marshal.StringToHGlobalAnsi(buf);
        z_DebugMessageInsertAMD_1(category, severity, id, length, buf_str_ptr);
      finally
        Marshal.FreeHGlobal(buf_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageInsertAMD(category: DummyEnum; severity: DebugSeverity; id: UInt32; length: Int32; buf: IntPtr) :=
    z_DebugMessageInsertAMD_1(category, severity, id, length, buf);
    
    private z_DebugMessageCallbackAMD_adr := GetProcAddress('glDebugMessageCallbackAMD');
    private z_DebugMessageCallbackAMD_1 := GetProcOrNil&<procedure(callback: GL_DEBUG_PROC; userParam: IntPtr)>(z_DebugMessageCallbackAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageCallbackAMD(callback: GL_DEBUG_PROC; userParam: IntPtr) :=
    z_DebugMessageCallbackAMD_1(callback, userParam);
    
    private z_GetDebugMessageLogAMD_adr := GetProcAddress('glGetDebugMessageLogAMD');
    private z_GetDebugMessageLogAMD_1 := GetProcOrNil&<function(count: UInt32; bufSize: Int32; categories: IntPtr; severities: IntPtr; ids: IntPtr; lengths: IntPtr; message: IntPtr): UInt32>(z_GetDebugMessageLogAMD_adr);
    private z_GetDebugMessageLogAMD_2 := GetProcOrNil&<function(count: UInt32; bufSize: Int32; var categories: DummyEnum; var severities: DebugSeverity; var ids: UInt32; var lengths: Int32; message: IntPtr): UInt32>(z_GetDebugMessageLogAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDebugMessageLogAMD(count: UInt32; bufSize: Int32; var categories: DummyEnum; var severities: DebugSeverity; var ids: UInt32; var lengths: Int32; message: IntPtr): UInt32 :=
    z_GetDebugMessageLogAMD_2(count, bufSize, categories, severities, ids, lengths, message);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDebugMessageLogAMD(count: UInt32; bufSize: Int32; categories: IntPtr; severities: IntPtr; ids: IntPtr; lengths: IntPtr; message: IntPtr): UInt32 :=
    z_GetDebugMessageLogAMD_1(count, bufSize, categories, severities, ids, lengths, message);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glDrawBuffersBlendAMD = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_amd_draw_buffers_blend';
    
    private z_BlendFuncIndexedAMD_adr := GetProcAddress('glBlendFuncIndexedAMD');
    private z_BlendFuncIndexedAMD_1 := GetProcOrNil&<procedure(buf: UInt32; src: DummyEnum; dst: DummyEnum)>(z_BlendFuncIndexedAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendFuncIndexedAMD(buf: UInt32; src: DummyEnum; dst: DummyEnum) :=
    z_BlendFuncIndexedAMD_1(buf, src, dst);
    
    private z_BlendFuncSeparateIndexedAMD_adr := GetProcAddress('glBlendFuncSeparateIndexedAMD');
    private z_BlendFuncSeparateIndexedAMD_1 := GetProcOrNil&<procedure(buf: UInt32; srcRGB: BlendingFactor; dstRGB: BlendingFactor; srcAlpha: BlendingFactor; dstAlpha: BlendingFactor)>(z_BlendFuncSeparateIndexedAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendFuncSeparateIndexedAMD(buf: UInt32; srcRGB: BlendingFactor; dstRGB: BlendingFactor; srcAlpha: BlendingFactor; dstAlpha: BlendingFactor) :=
    z_BlendFuncSeparateIndexedAMD_1(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
    
    private z_BlendEquationIndexedAMD_adr := GetProcAddress('glBlendEquationIndexedAMD');
    private z_BlendEquationIndexedAMD_1 := GetProcOrNil&<procedure(buf: UInt32; mode: BlendEquationMode)>(z_BlendEquationIndexedAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquationIndexedAMD(buf: UInt32; mode: BlendEquationMode) :=
    z_BlendEquationIndexedAMD_1(buf, mode);
    
    private z_BlendEquationSeparateIndexedAMD_adr := GetProcAddress('glBlendEquationSeparateIndexedAMD');
    private z_BlendEquationSeparateIndexedAMD_1 := GetProcOrNil&<procedure(buf: UInt32; modeRGB: BlendEquationMode; modeAlpha: BlendEquationMode)>(z_BlendEquationSeparateIndexedAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquationSeparateIndexedAMD(buf: UInt32; modeRGB: BlendEquationMode; modeAlpha: BlendEquationMode) :=
    z_BlendEquationSeparateIndexedAMD_1(buf, modeRGB, modeAlpha);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glFramebufferMultisampleAdvancedAMD = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_amd_framebuffer_multisample_advanced';
    
    private z_RenderbufferStorageMultisampleAdvancedAMD_adr := GetProcAddress('glRenderbufferStorageMultisampleAdvancedAMD');
    private z_RenderbufferStorageMultisampleAdvancedAMD_1 := GetProcOrNil&<procedure(target: RenderbufferTarget; samples: Int32; storageSamples: Int32; _internalformat: InternalFormat; width: Int32; height: Int32)>(z_RenderbufferStorageMultisampleAdvancedAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RenderbufferStorageMultisampleAdvancedAMD(target: RenderbufferTarget; samples: Int32; storageSamples: Int32; _internalformat: InternalFormat; width: Int32; height: Int32) :=
    z_RenderbufferStorageMultisampleAdvancedAMD_1(target, samples, storageSamples, _internalformat, width, height);
    
    private z_NamedRenderbufferStorageMultisampleAdvancedAMD_adr := GetProcAddress('glNamedRenderbufferStorageMultisampleAdvancedAMD');
    private z_NamedRenderbufferStorageMultisampleAdvancedAMD_1 := GetProcOrNil&<procedure(renderbuffer: gl_renderbuffer; samples: Int32; storageSamples: Int32; _internalformat: InternalFormat; width: Int32; height: Int32)>(z_NamedRenderbufferStorageMultisampleAdvancedAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedRenderbufferStorageMultisampleAdvancedAMD(renderbuffer: gl_renderbuffer; samples: Int32; storageSamples: Int32; _internalformat: InternalFormat; width: Int32; height: Int32) :=
    z_NamedRenderbufferStorageMultisampleAdvancedAMD_1(renderbuffer, samples, storageSamples, _internalformat, width, height);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glFramebufferSamplePositionsAMD = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_amd_framebuffer_sample_positions';
    
    private z_FramebufferSamplePositionsfvAMD_adr := GetProcAddress('glFramebufferSamplePositionsfvAMD');
    private z_FramebufferSamplePositionsfvAMD_1 := GetProcOrNil&<procedure(target: FramebufferTarget; numsamples: UInt32; pixelindex: UInt32; values: IntPtr)>(z_FramebufferSamplePositionsfvAMD_adr);
    private z_FramebufferSamplePositionsfvAMD_2 := GetProcOrNil&<procedure(target: FramebufferTarget; numsamples: UInt32; pixelindex: UInt32; var values: single)>(z_FramebufferSamplePositionsfvAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferSamplePositionsfvAMD(target: FramebufferTarget; numsamples: UInt32; pixelindex: UInt32; values: array of single);
    type Psingle=^single;
    begin
      if (values<>nil) and (values.Length<>0) then
        z_FramebufferSamplePositionsfvAMD_2(target, numsamples, pixelindex, values[0]) else
        z_FramebufferSamplePositionsfvAMD_2(target, numsamples, pixelindex, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferSamplePositionsfvAMD(target: FramebufferTarget; numsamples: UInt32; pixelindex: UInt32; var values: single) :=
    z_FramebufferSamplePositionsfvAMD_2(target, numsamples, pixelindex, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferSamplePositionsfvAMD(target: FramebufferTarget; numsamples: UInt32; pixelindex: UInt32; values: IntPtr) :=
    z_FramebufferSamplePositionsfvAMD_1(target, numsamples, pixelindex, values);
    
    private z_NamedFramebufferSamplePositionsfvAMD_adr := GetProcAddress('glNamedFramebufferSamplePositionsfvAMD');
    private z_NamedFramebufferSamplePositionsfvAMD_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; numsamples: UInt32; pixelindex: UInt32; values: IntPtr)>(z_NamedFramebufferSamplePositionsfvAMD_adr);
    private z_NamedFramebufferSamplePositionsfvAMD_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; numsamples: UInt32; pixelindex: UInt32; var values: single)>(z_NamedFramebufferSamplePositionsfvAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferSamplePositionsfvAMD(framebuffer: gl_framebuffer; numsamples: UInt32; pixelindex: UInt32; values: array of single);
    type Psingle=^single;
    begin
      if (values<>nil) and (values.Length<>0) then
        z_NamedFramebufferSamplePositionsfvAMD_2(framebuffer, numsamples, pixelindex, values[0]) else
        z_NamedFramebufferSamplePositionsfvAMD_2(framebuffer, numsamples, pixelindex, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferSamplePositionsfvAMD(framebuffer: gl_framebuffer; numsamples: UInt32; pixelindex: UInt32; var values: single) :=
    z_NamedFramebufferSamplePositionsfvAMD_2(framebuffer, numsamples, pixelindex, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferSamplePositionsfvAMD(framebuffer: gl_framebuffer; numsamples: UInt32; pixelindex: UInt32; values: IntPtr) :=
    z_NamedFramebufferSamplePositionsfvAMD_1(framebuffer, numsamples, pixelindex, values);
    
    private z_GetFramebufferParameterfvAMD_adr := GetProcAddress('glGetFramebufferParameterfvAMD');
    private z_GetFramebufferParameterfvAMD_1 := GetProcOrNil&<procedure(target: FramebufferTarget; pname: FramebufferAttachmentParameterName; numsamples: UInt32; pixelindex: UInt32; size: Int32; values: IntPtr)>(z_GetFramebufferParameterfvAMD_adr);
    private z_GetFramebufferParameterfvAMD_2 := GetProcOrNil&<procedure(target: FramebufferTarget; pname: FramebufferAttachmentParameterName; numsamples: UInt32; pixelindex: UInt32; size: Int32; var values: single)>(z_GetFramebufferParameterfvAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferParameterfvAMD(target: FramebufferTarget; pname: FramebufferAttachmentParameterName; numsamples: UInt32; pixelindex: UInt32; size: Int32; var values: single) :=
    z_GetFramebufferParameterfvAMD_2(target, pname, numsamples, pixelindex, size, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferParameterfvAMD(target: FramebufferTarget; pname: FramebufferAttachmentParameterName; numsamples: UInt32; pixelindex: UInt32; size: Int32; values: IntPtr) :=
    z_GetFramebufferParameterfvAMD_1(target, pname, numsamples, pixelindex, size, values);
    
    private z_GetNamedFramebufferParameterfvAMD_adr := GetProcAddress('glGetNamedFramebufferParameterfvAMD');
    private z_GetNamedFramebufferParameterfvAMD_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; pname: DummyEnum; numsamples: UInt32; pixelindex: UInt32; size: Int32; values: IntPtr)>(z_GetNamedFramebufferParameterfvAMD_adr);
    private z_GetNamedFramebufferParameterfvAMD_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; pname: DummyEnum; numsamples: UInt32; pixelindex: UInt32; size: Int32; var values: single)>(z_GetNamedFramebufferParameterfvAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferParameterfvAMD(framebuffer: gl_framebuffer; pname: DummyEnum; numsamples: UInt32; pixelindex: UInt32; size: Int32; var values: single) :=
    z_GetNamedFramebufferParameterfvAMD_2(framebuffer, pname, numsamples, pixelindex, size, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferParameterfvAMD(framebuffer: gl_framebuffer; pname: DummyEnum; numsamples: UInt32; pixelindex: UInt32; size: Int32; values: IntPtr) :=
    z_GetNamedFramebufferParameterfvAMD_1(framebuffer, pname, numsamples, pixelindex, size, values);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glGpuShaderInt64AMD = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_amd_gpu_shader_int64';
    
    private z_Uniform1i64NV_adr := GetProcAddress('glUniform1i64NV');
    private z_Uniform1i64NV_1 := GetProcOrNil&<procedure(location: Int32; x: Int64)>(z_Uniform1i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i64NV(location: Int32; x: Int64) :=
    z_Uniform1i64NV_1(location, x);
    
    private z_Uniform2i64NV_adr := GetProcAddress('glUniform2i64NV');
    private z_Uniform2i64NV_1 := GetProcOrNil&<procedure(location: Int32; x: Int64; y: Int64)>(z_Uniform2i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64NV(location: Int32; x: Int64; y: Int64) :=
    z_Uniform2i64NV_1(location, x, y);
    
    private z_Uniform3i64NV_adr := GetProcAddress('glUniform3i64NV');
    private z_Uniform3i64NV_1 := GetProcOrNil&<procedure(location: Int32; x: Int64; y: Int64; z: Int64)>(z_Uniform3i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64NV(location: Int32; x: Int64; y: Int64; z: Int64) :=
    z_Uniform3i64NV_1(location, x, y, z);
    
    private z_Uniform4i64NV_adr := GetProcAddress('glUniform4i64NV');
    private z_Uniform4i64NV_1 := GetProcOrNil&<procedure(location: Int32; x: Int64; y: Int64; z: Int64; w: Int64)>(z_Uniform4i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64NV(location: Int32; x: Int64; y: Int64; z: Int64; w: Int64) :=
    z_Uniform4i64NV_1(location, x, y, z, w);
    
    private z_Uniform1i64vNV_adr := GetProcAddress('glUniform1i64vNV');
    private z_Uniform1i64vNV_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform1i64vNV_adr);
    private z_Uniform1i64vNV_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int64)>(z_Uniform1i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i64vNV(location: Int32; count: Int32; value: array of Int64);
    type PInt64=^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform1i64vNV_2(location, count, value[0]) else
        z_Uniform1i64vNV_2(location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i64vNV(location: Int32; count: Int32; var value: Int64) :=
    z_Uniform1i64vNV_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i64vNV(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform1i64vNV_1(location, count, value);
    
    private z_Uniform2i64vNV_adr := GetProcAddress('glUniform2i64vNV');
    private z_Uniform2i64vNV_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform2i64vNV_adr);
    private z_Uniform2i64vNV_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int64)>(z_Uniform2i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64vNV(location: Int32; count: Int32; value: array of Int64);
    type PInt64=^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform2i64vNV_2(location, count, value[0]) else
        z_Uniform2i64vNV_2(location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64vNV(location: Int32; count: Int32; var value: Int64) :=
    z_Uniform2i64vNV_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64vNV(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform2i64vNV_1(location, count, value);
    
    private z_Uniform3i64vNV_adr := GetProcAddress('glUniform3i64vNV');
    private z_Uniform3i64vNV_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform3i64vNV_adr);
    private z_Uniform3i64vNV_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int64)>(z_Uniform3i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64vNV(location: Int32; count: Int32; value: array of Int64);
    type PInt64=^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform3i64vNV_2(location, count, value[0]) else
        z_Uniform3i64vNV_2(location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64vNV(location: Int32; count: Int32; var value: Int64) :=
    z_Uniform3i64vNV_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64vNV(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform3i64vNV_1(location, count, value);
    
    private z_Uniform4i64vNV_adr := GetProcAddress('glUniform4i64vNV');
    private z_Uniform4i64vNV_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform4i64vNV_adr);
    private z_Uniform4i64vNV_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int64)>(z_Uniform4i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64vNV(location: Int32; count: Int32; value: array of Int64);
    type PInt64=^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform4i64vNV_2(location, count, value[0]) else
        z_Uniform4i64vNV_2(location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64vNV(location: Int32; count: Int32; var value: Int64) :=
    z_Uniform4i64vNV_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64vNV(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform4i64vNV_1(location, count, value);
    
    private z_Uniform1ui64NV_adr := GetProcAddress('glUniform1ui64NV');
    private z_Uniform1ui64NV_1 := GetProcOrNil&<procedure(location: Int32; x: UInt64)>(z_Uniform1ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui64NV(location: Int32; x: UInt64) :=
    z_Uniform1ui64NV_1(location, x);
    
    private z_Uniform2ui64NV_adr := GetProcAddress('glUniform2ui64NV');
    private z_Uniform2ui64NV_1 := GetProcOrNil&<procedure(location: Int32; x: UInt64; y: UInt64)>(z_Uniform2ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64NV(location: Int32; x: UInt64; y: UInt64) :=
    z_Uniform2ui64NV_1(location, x, y);
    
    private z_Uniform3ui64NV_adr := GetProcAddress('glUniform3ui64NV');
    private z_Uniform3ui64NV_1 := GetProcOrNil&<procedure(location: Int32; x: UInt64; y: UInt64; z: UInt64)>(z_Uniform3ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64NV(location: Int32; x: UInt64; y: UInt64; z: UInt64) :=
    z_Uniform3ui64NV_1(location, x, y, z);
    
    private z_Uniform4ui64NV_adr := GetProcAddress('glUniform4ui64NV');
    private z_Uniform4ui64NV_1 := GetProcOrNil&<procedure(location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64)>(z_Uniform4ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64NV(location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64) :=
    z_Uniform4ui64NV_1(location, x, y, z, w);
    
    private z_Uniform1ui64vNV_adr := GetProcAddress('glUniform1ui64vNV');
    private z_Uniform1ui64vNV_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform1ui64vNV_adr);
    private z_Uniform1ui64vNV_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt64)>(z_Uniform1ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui64vNV(location: Int32; count: Int32; value: array of UInt64);
    type PUInt64=^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform1ui64vNV_2(location, count, value[0]) else
        z_Uniform1ui64vNV_2(location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui64vNV(location: Int32; count: Int32; var value: UInt64) :=
    z_Uniform1ui64vNV_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui64vNV(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform1ui64vNV_1(location, count, value);
    
    private z_Uniform2ui64vNV_adr := GetProcAddress('glUniform2ui64vNV');
    private z_Uniform2ui64vNV_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform2ui64vNV_adr);
    private z_Uniform2ui64vNV_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt64)>(z_Uniform2ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64vNV(location: Int32; count: Int32; value: array of UInt64);
    type PUInt64=^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform2ui64vNV_2(location, count, value[0]) else
        z_Uniform2ui64vNV_2(location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64vNV(location: Int32; count: Int32; var value: UInt64) :=
    z_Uniform2ui64vNV_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64vNV(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform2ui64vNV_1(location, count, value);
    
    private z_Uniform3ui64vNV_adr := GetProcAddress('glUniform3ui64vNV');
    private z_Uniform3ui64vNV_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform3ui64vNV_adr);
    private z_Uniform3ui64vNV_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt64)>(z_Uniform3ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64vNV(location: Int32; count: Int32; value: array of UInt64);
    type PUInt64=^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform3ui64vNV_2(location, count, value[0]) else
        z_Uniform3ui64vNV_2(location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64vNV(location: Int32; count: Int32; var value: UInt64) :=
    z_Uniform3ui64vNV_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64vNV(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform3ui64vNV_1(location, count, value);
    
    private z_Uniform4ui64vNV_adr := GetProcAddress('glUniform4ui64vNV');
    private z_Uniform4ui64vNV_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform4ui64vNV_adr);
    private z_Uniform4ui64vNV_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt64)>(z_Uniform4ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64vNV(location: Int32; count: Int32; value: array of UInt64);
    type PUInt64=^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform4ui64vNV_2(location, count, value[0]) else
        z_Uniform4ui64vNV_2(location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64vNV(location: Int32; count: Int32; var value: UInt64) :=
    z_Uniform4ui64vNV_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64vNV(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform4ui64vNV_1(location, count, value);
    
    private z_GetUniformi64vNV_adr := GetProcAddress('glGetUniformi64vNV');
    private z_GetUniformi64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; &params: IntPtr)>(z_GetUniformi64vNV_adr);
    private z_GetUniformi64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; var &params: Int64)>(z_GetUniformi64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformi64vNV(&program: gl_program; location: Int32; var &params: Int64) :=
    z_GetUniformi64vNV_2(&program, location, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformi64vNV(&program: gl_program; location: Int32; &params: IntPtr) :=
    z_GetUniformi64vNV_1(&program, location, &params);
    
    private z_GetUniformui64vNV_adr := GetProcAddress('glGetUniformui64vNV');
    private z_GetUniformui64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; &params: IntPtr)>(z_GetUniformui64vNV_adr);
    private z_GetUniformui64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; var &params: UInt64)>(z_GetUniformui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformui64vNV(&program: gl_program; location: Int32; var &params: UInt64) :=
    z_GetUniformui64vNV_2(&program, location, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformui64vNV(&program: gl_program; location: Int32; &params: IntPtr) :=
    z_GetUniformui64vNV_1(&program, location, &params);
    
    private z_ProgramUniform1i64NV_adr := GetProcAddress('glProgramUniform1i64NV');
    private z_ProgramUniform1i64NV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: Int64)>(z_ProgramUniform1i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i64NV(&program: gl_program; location: Int32; x: Int64) :=
    z_ProgramUniform1i64NV_1(&program, location, x);
    
    private z_ProgramUniform2i64NV_adr := GetProcAddress('glProgramUniform2i64NV');
    private z_ProgramUniform2i64NV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: Int64; y: Int64)>(z_ProgramUniform2i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64NV(&program: gl_program; location: Int32; x: Int64; y: Int64) :=
    z_ProgramUniform2i64NV_1(&program, location, x, y);
    
    private z_ProgramUniform3i64NV_adr := GetProcAddress('glProgramUniform3i64NV');
    private z_ProgramUniform3i64NV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: Int64; y: Int64; z: Int64)>(z_ProgramUniform3i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64NV(&program: gl_program; location: Int32; x: Int64; y: Int64; z: Int64) :=
    z_ProgramUniform3i64NV_1(&program, location, x, y, z);
    
    private z_ProgramUniform4i64NV_adr := GetProcAddress('glProgramUniform4i64NV');
    private z_ProgramUniform4i64NV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: Int64; y: Int64; z: Int64; w: Int64)>(z_ProgramUniform4i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64NV(&program: gl_program; location: Int32; x: Int64; y: Int64; z: Int64; w: Int64) :=
    z_ProgramUniform4i64NV_1(&program, location, x, y, z, w);
    
    private z_ProgramUniform1i64vNV_adr := GetProcAddress('glProgramUniform1i64vNV');
    private z_ProgramUniform1i64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform1i64vNV_adr);
    private z_ProgramUniform1i64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int64)>(z_ProgramUniform1i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i64vNV(&program: gl_program; location: Int32; count: Int32; value: array of Int64);
    type PInt64=^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform1i64vNV_2(&program, location, count, value[0]) else
        z_ProgramUniform1i64vNV_2(&program, location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i64vNV(&program: gl_program; location: Int32; count: Int32; var value: Int64) :=
    z_ProgramUniform1i64vNV_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i64vNV(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform1i64vNV_1(&program, location, count, value);
    
    private z_ProgramUniform2i64vNV_adr := GetProcAddress('glProgramUniform2i64vNV');
    private z_ProgramUniform2i64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform2i64vNV_adr);
    private z_ProgramUniform2i64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int64)>(z_ProgramUniform2i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64vNV(&program: gl_program; location: Int32; count: Int32; value: array of Int64);
    type PInt64=^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform2i64vNV_2(&program, location, count, value[0]) else
        z_ProgramUniform2i64vNV_2(&program, location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64vNV(&program: gl_program; location: Int32; count: Int32; var value: Int64) :=
    z_ProgramUniform2i64vNV_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64vNV(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform2i64vNV_1(&program, location, count, value);
    
    private z_ProgramUniform3i64vNV_adr := GetProcAddress('glProgramUniform3i64vNV');
    private z_ProgramUniform3i64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform3i64vNV_adr);
    private z_ProgramUniform3i64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int64)>(z_ProgramUniform3i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64vNV(&program: gl_program; location: Int32; count: Int32; value: array of Int64);
    type PInt64=^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform3i64vNV_2(&program, location, count, value[0]) else
        z_ProgramUniform3i64vNV_2(&program, location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64vNV(&program: gl_program; location: Int32; count: Int32; var value: Int64) :=
    z_ProgramUniform3i64vNV_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64vNV(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform3i64vNV_1(&program, location, count, value);
    
    private z_ProgramUniform4i64vNV_adr := GetProcAddress('glProgramUniform4i64vNV');
    private z_ProgramUniform4i64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform4i64vNV_adr);
    private z_ProgramUniform4i64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int64)>(z_ProgramUniform4i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64vNV(&program: gl_program; location: Int32; count: Int32; value: array of Int64);
    type PInt64=^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform4i64vNV_2(&program, location, count, value[0]) else
        z_ProgramUniform4i64vNV_2(&program, location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64vNV(&program: gl_program; location: Int32; count: Int32; var value: Int64) :=
    z_ProgramUniform4i64vNV_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64vNV(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform4i64vNV_1(&program, location, count, value);
    
    private z_ProgramUniform1ui64NV_adr := GetProcAddress('glProgramUniform1ui64NV');
    private z_ProgramUniform1ui64NV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: UInt64)>(z_ProgramUniform1ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui64NV(&program: gl_program; location: Int32; x: UInt64) :=
    z_ProgramUniform1ui64NV_1(&program, location, x);
    
    private z_ProgramUniform2ui64NV_adr := GetProcAddress('glProgramUniform2ui64NV');
    private z_ProgramUniform2ui64NV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: UInt64; y: UInt64)>(z_ProgramUniform2ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64NV(&program: gl_program; location: Int32; x: UInt64; y: UInt64) :=
    z_ProgramUniform2ui64NV_1(&program, location, x, y);
    
    private z_ProgramUniform3ui64NV_adr := GetProcAddress('glProgramUniform3ui64NV');
    private z_ProgramUniform3ui64NV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: UInt64; y: UInt64; z: UInt64)>(z_ProgramUniform3ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64NV(&program: gl_program; location: Int32; x: UInt64; y: UInt64; z: UInt64) :=
    z_ProgramUniform3ui64NV_1(&program, location, x, y, z);
    
    private z_ProgramUniform4ui64NV_adr := GetProcAddress('glProgramUniform4ui64NV');
    private z_ProgramUniform4ui64NV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64)>(z_ProgramUniform4ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64NV(&program: gl_program; location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64) :=
    z_ProgramUniform4ui64NV_1(&program, location, x, y, z, w);
    
    private z_ProgramUniform1ui64vNV_adr := GetProcAddress('glProgramUniform1ui64vNV');
    private z_ProgramUniform1ui64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform1ui64vNV_adr);
    private z_ProgramUniform1ui64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt64)>(z_ProgramUniform1ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui64vNV(&program: gl_program; location: Int32; count: Int32; value: array of UInt64);
    type PUInt64=^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform1ui64vNV_2(&program, location, count, value[0]) else
        z_ProgramUniform1ui64vNV_2(&program, location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui64vNV(&program: gl_program; location: Int32; count: Int32; var value: UInt64) :=
    z_ProgramUniform1ui64vNV_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui64vNV(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform1ui64vNV_1(&program, location, count, value);
    
    private z_ProgramUniform2ui64vNV_adr := GetProcAddress('glProgramUniform2ui64vNV');
    private z_ProgramUniform2ui64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform2ui64vNV_adr);
    private z_ProgramUniform2ui64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt64)>(z_ProgramUniform2ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64vNV(&program: gl_program; location: Int32; count: Int32; value: array of UInt64);
    type PUInt64=^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform2ui64vNV_2(&program, location, count, value[0]) else
        z_ProgramUniform2ui64vNV_2(&program, location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64vNV(&program: gl_program; location: Int32; count: Int32; var value: UInt64) :=
    z_ProgramUniform2ui64vNV_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64vNV(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform2ui64vNV_1(&program, location, count, value);
    
    private z_ProgramUniform3ui64vNV_adr := GetProcAddress('glProgramUniform3ui64vNV');
    private z_ProgramUniform3ui64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform3ui64vNV_adr);
    private z_ProgramUniform3ui64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt64)>(z_ProgramUniform3ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64vNV(&program: gl_program; location: Int32; count: Int32; value: array of UInt64);
    type PUInt64=^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform3ui64vNV_2(&program, location, count, value[0]) else
        z_ProgramUniform3ui64vNV_2(&program, location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64vNV(&program: gl_program; location: Int32; count: Int32; var value: UInt64) :=
    z_ProgramUniform3ui64vNV_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64vNV(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform3ui64vNV_1(&program, location, count, value);
    
    private z_ProgramUniform4ui64vNV_adr := GetProcAddress('glProgramUniform4ui64vNV');
    private z_ProgramUniform4ui64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform4ui64vNV_adr);
    private z_ProgramUniform4ui64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt64)>(z_ProgramUniform4ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64vNV(&program: gl_program; location: Int32; count: Int32; value: array of UInt64);
    type PUInt64=^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform4ui64vNV_2(&program, location, count, value[0]) else
        z_ProgramUniform4ui64vNV_2(&program, location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64vNV(&program: gl_program; location: Int32; count: Int32; var value: UInt64) :=
    z_ProgramUniform4ui64vNV_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64vNV(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform4ui64vNV_1(&program, location, count, value);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glInterleavedElementsAMD = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_amd_interleaved_elements';
    
    private z_VertexAttribParameteriAMD_adr := GetProcAddress('glVertexAttribParameteriAMD');
    private z_VertexAttribParameteriAMD_1 := GetProcOrNil&<procedure(index: UInt32; pname: DummyEnum; param: Int32)>(z_VertexAttribParameteriAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribParameteriAMD(index: UInt32; pname: DummyEnum; param: Int32) :=
    z_VertexAttribParameteriAMD_1(index, pname, param);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glMultiDrawIndirectAMD = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_amd_multi_draw_indirect';
    
    private z_MultiDrawArraysIndirectAMD_adr := GetProcAddress('glMultiDrawArraysIndirectAMD');
    private z_MultiDrawArraysIndirectAMD_1 := GetProcOrNil&<procedure(mode: PrimitiveType; indirect: IntPtr; primcount: Int32; stride: Int32)>(z_MultiDrawArraysIndirectAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysIndirectAMD(mode: PrimitiveType; indirect: IntPtr; primcount: Int32; stride: Int32) :=
    z_MultiDrawArraysIndirectAMD_1(mode, indirect, primcount, stride);
    
    private z_MultiDrawElementsIndirectAMD_adr := GetProcAddress('glMultiDrawElementsIndirectAMD');
    private z_MultiDrawElementsIndirectAMD_1 := GetProcOrNil&<procedure(mode: PrimitiveType; &type: DrawElementsType; indirect: IntPtr; primcount: Int32; stride: Int32)>(z_MultiDrawElementsIndirectAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsIndirectAMD(mode: PrimitiveType; &type: DrawElementsType; indirect: IntPtr; primcount: Int32; stride: Int32) :=
    z_MultiDrawElementsIndirectAMD_1(mode, &type, indirect, primcount, stride);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glNameGenDeleteAMD = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_amd_name_gen_delete';
    
    private z_GenNamesAMD_adr := GetProcAddress('glGenNamesAMD');
    private z_GenNamesAMD_1 := GetProcOrNil&<procedure(identifier: DummyEnum; num: UInt32; names: IntPtr)>(z_GenNamesAMD_adr);
    private z_GenNamesAMD_2 := GetProcOrNil&<procedure(identifier: DummyEnum; num: UInt32; var names: UInt32)>(z_GenNamesAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenNamesAMD(identifier: DummyEnum; num: UInt32; names: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (names<>nil) and (names.Length<>0) then
        z_GenNamesAMD_2(identifier, num, names[0]) else
        z_GenNamesAMD_2(identifier, num, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenNamesAMD(identifier: DummyEnum; num: UInt32; var names: UInt32) :=
    z_GenNamesAMD_2(identifier, num, names);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenNamesAMD(identifier: DummyEnum; num: UInt32; names: IntPtr) :=
    z_GenNamesAMD_1(identifier, num, names);
    
    private z_DeleteNamesAMD_adr := GetProcAddress('glDeleteNamesAMD');
    private z_DeleteNamesAMD_1 := GetProcOrNil&<procedure(identifier: DummyEnum; num: UInt32; names: IntPtr)>(z_DeleteNamesAMD_adr);
    private z_DeleteNamesAMD_2 := GetProcOrNil&<procedure(identifier: DummyEnum; num: UInt32; var names: UInt32)>(z_DeleteNamesAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteNamesAMD(identifier: DummyEnum; num: UInt32; names: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (names<>nil) and (names.Length<>0) then
        z_DeleteNamesAMD_2(identifier, num, names[0]) else
        z_DeleteNamesAMD_2(identifier, num, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteNamesAMD(identifier: DummyEnum; num: UInt32; var names: UInt32) :=
    z_DeleteNamesAMD_2(identifier, num, names);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteNamesAMD(identifier: DummyEnum; num: UInt32; names: IntPtr) :=
    z_DeleteNamesAMD_1(identifier, num, names);
    
    private z_IsNameAMD_adr := GetProcAddress('glIsNameAMD');
    private z_IsNameAMD_1 := GetProcOrNil&<function(identifier: DummyEnum; name: UInt32): boolean>(z_IsNameAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsNameAMD(identifier: DummyEnum; name: UInt32): boolean :=
    z_IsNameAMD_1(identifier, name);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glOcclusionQueryEventAMD = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_amd_occlusion_query_event';
    
    private z_QueryObjectParameteruiAMD_adr := GetProcAddress('glQueryObjectParameteruiAMD');
    private z_QueryObjectParameteruiAMD_1 := GetProcOrNil&<procedure(target: QueryTarget; id: gl_query; pname: DummyEnum; param: OcclusionQueryEventMask)>(z_QueryObjectParameteruiAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure QueryObjectParameteruiAMD(target: QueryTarget; id: gl_query; pname: DummyEnum; param: OcclusionQueryEventMask) :=
    z_QueryObjectParameteruiAMD_1(target, id, pname, param);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glPerformanceMonitorAMD = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_amd_performance_monitor';
    
    private z_GetPerfMonitorGroupsAMD_adr := GetProcAddress('glGetPerfMonitorGroupsAMD');
    private z_GetPerfMonitorGroupsAMD_1 := GetProcOrNil&<procedure(numGroups: IntPtr; groupsSize: Int32; groups: IntPtr)>(z_GetPerfMonitorGroupsAMD_adr);
    private z_GetPerfMonitorGroupsAMD_2 := GetProcOrNil&<procedure(numGroups: IntPtr; groupsSize: Int32; var groups: UInt32)>(z_GetPerfMonitorGroupsAMD_adr);
    private z_GetPerfMonitorGroupsAMD_3 := GetProcOrNil&<procedure(var numGroups: Int32; groupsSize: Int32; groups: IntPtr)>(z_GetPerfMonitorGroupsAMD_adr);
    private z_GetPerfMonitorGroupsAMD_4 := GetProcOrNil&<procedure(var numGroups: Int32; groupsSize: Int32; var groups: UInt32)>(z_GetPerfMonitorGroupsAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupsAMD(var numGroups: Int32; groupsSize: Int32; var groups: UInt32) :=
    z_GetPerfMonitorGroupsAMD_4(numGroups, groupsSize, groups);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupsAMD(var numGroups: Int32; groupsSize: Int32; groups: IntPtr) :=
    z_GetPerfMonitorGroupsAMD_3(numGroups, groupsSize, groups);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupsAMD(numGroups: IntPtr; groupsSize: Int32; var groups: UInt32) :=
    z_GetPerfMonitorGroupsAMD_2(numGroups, groupsSize, groups);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupsAMD(numGroups: IntPtr; groupsSize: Int32; groups: IntPtr) :=
    z_GetPerfMonitorGroupsAMD_1(numGroups, groupsSize, groups);
    
    private z_GetPerfMonitorCountersAMD_adr := GetProcAddress('glGetPerfMonitorCountersAMD');
    private z_GetPerfMonitorCountersAMD_1 := GetProcOrNil&<procedure(group: UInt32; numCounters: IntPtr; maxActiveCounters: IntPtr; counterSize: Int32; counters: IntPtr)>(z_GetPerfMonitorCountersAMD_adr);
    private z_GetPerfMonitorCountersAMD_2 := GetProcOrNil&<procedure(group: UInt32; numCounters: IntPtr; maxActiveCounters: IntPtr; counterSize: Int32; var counters: UInt32)>(z_GetPerfMonitorCountersAMD_adr);
    private z_GetPerfMonitorCountersAMD_3 := GetProcOrNil&<procedure(group: UInt32; numCounters: IntPtr; var maxActiveCounters: Int32; counterSize: Int32; counters: IntPtr)>(z_GetPerfMonitorCountersAMD_adr);
    private z_GetPerfMonitorCountersAMD_4 := GetProcOrNil&<procedure(group: UInt32; numCounters: IntPtr; var maxActiveCounters: Int32; counterSize: Int32; var counters: UInt32)>(z_GetPerfMonitorCountersAMD_adr);
    private z_GetPerfMonitorCountersAMD_5 := GetProcOrNil&<procedure(group: UInt32; var numCounters: Int32; maxActiveCounters: IntPtr; counterSize: Int32; counters: IntPtr)>(z_GetPerfMonitorCountersAMD_adr);
    private z_GetPerfMonitorCountersAMD_6 := GetProcOrNil&<procedure(group: UInt32; var numCounters: Int32; maxActiveCounters: IntPtr; counterSize: Int32; var counters: UInt32)>(z_GetPerfMonitorCountersAMD_adr);
    private z_GetPerfMonitorCountersAMD_7 := GetProcOrNil&<procedure(group: UInt32; var numCounters: Int32; var maxActiveCounters: Int32; counterSize: Int32; counters: IntPtr)>(z_GetPerfMonitorCountersAMD_adr);
    private z_GetPerfMonitorCountersAMD_8 := GetProcOrNil&<procedure(group: UInt32; var numCounters: Int32; var maxActiveCounters: Int32; counterSize: Int32; var counters: UInt32)>(z_GetPerfMonitorCountersAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; var numCounters: Int32; var maxActiveCounters: Int32; counterSize: Int32; var counters: UInt32) :=
    z_GetPerfMonitorCountersAMD_8(group, numCounters, maxActiveCounters, counterSize, counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; var numCounters: Int32; var maxActiveCounters: Int32; counterSize: Int32; counters: IntPtr) :=
    z_GetPerfMonitorCountersAMD_7(group, numCounters, maxActiveCounters, counterSize, counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; var numCounters: Int32; maxActiveCounters: IntPtr; counterSize: Int32; var counters: UInt32) :=
    z_GetPerfMonitorCountersAMD_6(group, numCounters, maxActiveCounters, counterSize, counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; var numCounters: Int32; maxActiveCounters: IntPtr; counterSize: Int32; counters: IntPtr) :=
    z_GetPerfMonitorCountersAMD_5(group, numCounters, maxActiveCounters, counterSize, counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: IntPtr; var maxActiveCounters: Int32; counterSize: Int32; var counters: UInt32) :=
    z_GetPerfMonitorCountersAMD_4(group, numCounters, maxActiveCounters, counterSize, counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: IntPtr; var maxActiveCounters: Int32; counterSize: Int32; counters: IntPtr) :=
    z_GetPerfMonitorCountersAMD_3(group, numCounters, maxActiveCounters, counterSize, counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: IntPtr; maxActiveCounters: IntPtr; counterSize: Int32; var counters: UInt32) :=
    z_GetPerfMonitorCountersAMD_2(group, numCounters, maxActiveCounters, counterSize, counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: IntPtr; maxActiveCounters: IntPtr; counterSize: Int32; counters: IntPtr) :=
    z_GetPerfMonitorCountersAMD_1(group, numCounters, maxActiveCounters, counterSize, counters);
    
    private z_GetPerfMonitorGroupStringAMD_adr := GetProcAddress('glGetPerfMonitorGroupStringAMD');
    private z_GetPerfMonitorGroupStringAMD_1 := GetProcOrNil&<procedure(group: UInt32; bufSize: Int32; length: IntPtr; groupString: IntPtr)>(z_GetPerfMonitorGroupStringAMD_adr);
    private z_GetPerfMonitorGroupStringAMD_2 := GetProcOrNil&<procedure(group: UInt32; bufSize: Int32; var length: Int32; groupString: IntPtr)>(z_GetPerfMonitorGroupStringAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupStringAMD(group: UInt32; bufSize: Int32; var length: Int32; groupString: IntPtr) :=
    z_GetPerfMonitorGroupStringAMD_2(group, bufSize, length, groupString);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupStringAMD(group: UInt32; bufSize: Int32; length: IntPtr; groupString: IntPtr) :=
    z_GetPerfMonitorGroupStringAMD_1(group, bufSize, length, groupString);
    
    private z_GetPerfMonitorCounterStringAMD_adr := GetProcAddress('glGetPerfMonitorCounterStringAMD');
    private z_GetPerfMonitorCounterStringAMD_1 := GetProcOrNil&<procedure(group: UInt32; counter: UInt32; bufSize: Int32; length: IntPtr; counterString: IntPtr)>(z_GetPerfMonitorCounterStringAMD_adr);
    private z_GetPerfMonitorCounterStringAMD_2 := GetProcOrNil&<procedure(group: UInt32; counter: UInt32; bufSize: Int32; var length: Int32; counterString: IntPtr)>(z_GetPerfMonitorCounterStringAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterStringAMD(group: UInt32; counter: UInt32; bufSize: Int32; var length: Int32; counterString: IntPtr) :=
    z_GetPerfMonitorCounterStringAMD_2(group, counter, bufSize, length, counterString);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterStringAMD(group: UInt32; counter: UInt32; bufSize: Int32; length: IntPtr; counterString: IntPtr) :=
    z_GetPerfMonitorCounterStringAMD_1(group, counter, bufSize, length, counterString);
    
    private z_GetPerfMonitorCounterInfoAMD_adr := GetProcAddress('glGetPerfMonitorCounterInfoAMD');
    private z_GetPerfMonitorCounterInfoAMD_1 := GetProcOrNil&<procedure(group: UInt32; counter: UInt32; pname: DummyEnum; data: IntPtr)>(z_GetPerfMonitorCounterInfoAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterInfoAMD(group: UInt32; counter: UInt32; pname: DummyEnum; data: IntPtr) :=
    z_GetPerfMonitorCounterInfoAMD_1(group, counter, pname, data);
    
    private z_GenPerfMonitorsAMD_adr := GetProcAddress('glGenPerfMonitorsAMD');
    private z_GenPerfMonitorsAMD_1 := GetProcOrNil&<procedure(n: Int32; monitors: IntPtr)>(z_GenPerfMonitorsAMD_adr);
    private z_GenPerfMonitorsAMD_2 := GetProcOrNil&<procedure(n: Int32; var monitors: UInt32)>(z_GenPerfMonitorsAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenPerfMonitorsAMD(n: Int32; monitors: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (monitors<>nil) and (monitors.Length<>0) then
        z_GenPerfMonitorsAMD_2(n, monitors[0]) else
        z_GenPerfMonitorsAMD_2(n, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenPerfMonitorsAMD(n: Int32; var monitors: UInt32) :=
    z_GenPerfMonitorsAMD_2(n, monitors);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenPerfMonitorsAMD(n: Int32; monitors: IntPtr) :=
    z_GenPerfMonitorsAMD_1(n, monitors);
    
    private z_DeletePerfMonitorsAMD_adr := GetProcAddress('glDeletePerfMonitorsAMD');
    private z_DeletePerfMonitorsAMD_1 := GetProcOrNil&<procedure(n: Int32; monitors: IntPtr)>(z_DeletePerfMonitorsAMD_adr);
    private z_DeletePerfMonitorsAMD_2 := GetProcOrNil&<procedure(n: Int32; var monitors: UInt32)>(z_DeletePerfMonitorsAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeletePerfMonitorsAMD(n: Int32; monitors: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (monitors<>nil) and (monitors.Length<>0) then
        z_DeletePerfMonitorsAMD_2(n, monitors[0]) else
        z_DeletePerfMonitorsAMD_2(n, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeletePerfMonitorsAMD(n: Int32; var monitors: UInt32) :=
    z_DeletePerfMonitorsAMD_2(n, monitors);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeletePerfMonitorsAMD(n: Int32; monitors: IntPtr) :=
    z_DeletePerfMonitorsAMD_1(n, monitors);
    
    private z_SelectPerfMonitorCountersAMD_adr := GetProcAddress('glSelectPerfMonitorCountersAMD');
    private z_SelectPerfMonitorCountersAMD_1 := GetProcOrNil&<procedure(monitor: UInt32; enable: boolean; group: UInt32; numCounters: Int32; counterList: IntPtr)>(z_SelectPerfMonitorCountersAMD_adr);
    private z_SelectPerfMonitorCountersAMD_2 := GetProcOrNil&<procedure(monitor: UInt32; enable: boolean; group: UInt32; numCounters: Int32; var counterList: UInt32)>(z_SelectPerfMonitorCountersAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SelectPerfMonitorCountersAMD(monitor: UInt32; enable: boolean; group: UInt32; numCounters: Int32; counterList: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (counterList<>nil) and (counterList.Length<>0) then
        z_SelectPerfMonitorCountersAMD_2(monitor, enable, group, numCounters, counterList[0]) else
        z_SelectPerfMonitorCountersAMD_2(monitor, enable, group, numCounters, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SelectPerfMonitorCountersAMD(monitor: UInt32; enable: boolean; group: UInt32; numCounters: Int32; var counterList: UInt32) :=
    z_SelectPerfMonitorCountersAMD_2(monitor, enable, group, numCounters, counterList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SelectPerfMonitorCountersAMD(monitor: UInt32; enable: boolean; group: UInt32; numCounters: Int32; counterList: IntPtr) :=
    z_SelectPerfMonitorCountersAMD_1(monitor, enable, group, numCounters, counterList);
    
    private z_BeginPerfMonitorAMD_adr := GetProcAddress('glBeginPerfMonitorAMD');
    private z_BeginPerfMonitorAMD_1 := GetProcOrNil&<procedure(monitor: UInt32)>(z_BeginPerfMonitorAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginPerfMonitorAMD(monitor: UInt32) :=
    z_BeginPerfMonitorAMD_1(monitor);
    
    private z_EndPerfMonitorAMD_adr := GetProcAddress('glEndPerfMonitorAMD');
    private z_EndPerfMonitorAMD_1 := GetProcOrNil&<procedure(monitor: UInt32)>(z_EndPerfMonitorAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndPerfMonitorAMD(monitor: UInt32) :=
    z_EndPerfMonitorAMD_1(monitor);
    
    private z_GetPerfMonitorCounterDataAMD_adr := GetProcAddress('glGetPerfMonitorCounterDataAMD');
    private z_GetPerfMonitorCounterDataAMD_1 := GetProcOrNil&<procedure(monitor: UInt32; pname: DummyEnum; dataSize: Int32; data: IntPtr; bytesWritten: IntPtr)>(z_GetPerfMonitorCounterDataAMD_adr);
    private z_GetPerfMonitorCounterDataAMD_2 := GetProcOrNil&<procedure(monitor: UInt32; pname: DummyEnum; dataSize: Int32; data: IntPtr; var bytesWritten: Int32)>(z_GetPerfMonitorCounterDataAMD_adr);
    private z_GetPerfMonitorCounterDataAMD_3 := GetProcOrNil&<procedure(monitor: UInt32; pname: DummyEnum; dataSize: Int32; var data: UInt32; bytesWritten: IntPtr)>(z_GetPerfMonitorCounterDataAMD_adr);
    private z_GetPerfMonitorCounterDataAMD_4 := GetProcOrNil&<procedure(monitor: UInt32; pname: DummyEnum; dataSize: Int32; var data: UInt32; var bytesWritten: Int32)>(z_GetPerfMonitorCounterDataAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterDataAMD(monitor: UInt32; pname: DummyEnum; dataSize: Int32; var data: UInt32; var bytesWritten: Int32) :=
    z_GetPerfMonitorCounterDataAMD_4(monitor, pname, dataSize, data, bytesWritten);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterDataAMD(monitor: UInt32; pname: DummyEnum; dataSize: Int32; var data: UInt32; bytesWritten: IntPtr) :=
    z_GetPerfMonitorCounterDataAMD_3(monitor, pname, dataSize, data, bytesWritten);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterDataAMD(monitor: UInt32; pname: DummyEnum; dataSize: Int32; data: IntPtr; var bytesWritten: Int32) :=
    z_GetPerfMonitorCounterDataAMD_2(monitor, pname, dataSize, data, bytesWritten);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterDataAMD(monitor: UInt32; pname: DummyEnum; dataSize: Int32; data: IntPtr; bytesWritten: IntPtr) :=
    z_GetPerfMonitorCounterDataAMD_1(monitor, pname, dataSize, data, bytesWritten);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glSamplePositionsAMD = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_amd_sample_positions';
    
    private z_SetMultisamplefvAMD_adr := GetProcAddress('glSetMultisamplefvAMD');
    private z_SetMultisamplefvAMD_1 := GetProcOrNil&<procedure(pname: DummyEnum; index: UInt32; val: IntPtr)>(z_SetMultisamplefvAMD_adr);
    private z_SetMultisamplefvAMD_2 := GetProcOrNil&<procedure(pname: DummyEnum; index: UInt32; var val: single)>(z_SetMultisamplefvAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetMultisamplefvAMD(pname: DummyEnum; index: UInt32; val: array of single);
    type Psingle=^single;
    begin
      if (val<>nil) and (val.Length<>0) then
        z_SetMultisamplefvAMD_2(pname, index, val[0]) else
        z_SetMultisamplefvAMD_2(pname, index, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetMultisamplefvAMD(pname: DummyEnum; index: UInt32; var val: single) :=
    z_SetMultisamplefvAMD_2(pname, index, val);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetMultisamplefvAMD(pname: DummyEnum; index: UInt32; val: IntPtr) :=
    z_SetMultisamplefvAMD_1(pname, index, val);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glSparseTextureAMD = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_amd_sparse_texture';
    
    private z_TexStorageSparseAMD_adr := GetProcAddress('glTexStorageSparseAMD');
    private z_TexStorageSparseAMD_1 := GetProcOrNil&<procedure(target: TextureTarget; internalFormat: SizedInternalFormat; width: Int32; height: Int32; depth: Int32; layers: Int32; flags: TextureStorageMask)>(z_TexStorageSparseAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorageSparseAMD(target: TextureTarget; internalFormat: SizedInternalFormat; width: Int32; height: Int32; depth: Int32; layers: Int32; flags: TextureStorageMask) :=
    z_TexStorageSparseAMD_1(target, internalFormat, width, height, depth, layers, flags);
    
    private z_TextureStorageSparseAMD_adr := GetProcAddress('glTextureStorageSparseAMD');
    private z_TextureStorageSparseAMD_1 := GetProcOrNil&<procedure(texture: gl_texture; target: DummyEnum; internalFormat: SizedInternalFormat; width: Int32; height: Int32; depth: Int32; layers: Int32; flags: TextureStorageMask)>(z_TextureStorageSparseAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorageSparseAMD(texture: gl_texture; target: DummyEnum; internalFormat: SizedInternalFormat; width: Int32; height: Int32; depth: Int32; layers: Int32; flags: TextureStorageMask) :=
    z_TextureStorageSparseAMD_1(texture, target, internalFormat, width, height, depth, layers, flags);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glStencilOperationExtendedAMD = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_amd_stencil_operation_extended';
    
    private z_StencilOpValueAMD_adr := GetProcAddress('glStencilOpValueAMD');
    private z_StencilOpValueAMD_1 := GetProcOrNil&<procedure(face: MaterialFace; value: UInt32)>(z_StencilOpValueAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilOpValueAMD(face: MaterialFace; value: UInt32) :=
    z_StencilOpValueAMD_1(face, value);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glVertexShaderTessellatorAMD = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_amd_vertex_shader_tessellator';
    
    private z_TessellationFactorAMD_adr := GetProcAddress('glTessellationFactorAMD');
    private z_TessellationFactorAMD_1 := GetProcOrNil&<procedure(factor: single)>(z_TessellationFactorAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TessellationFactorAMD(factor: single) :=
    z_TessellationFactorAMD_1(factor);
    
    private z_TessellationModeAMD_adr := GetProcAddress('glTessellationModeAMD');
    private z_TessellationModeAMD_1 := GetProcOrNil&<procedure(mode: DummyEnum)>(z_TessellationModeAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TessellationModeAMD(mode: DummyEnum) :=
    z_TessellationModeAMD_1(mode);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glElementArrayAPPLE = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_apple_element_array';
    
    private z_ElementPointerAPPLE_adr := GetProcAddress('glElementPointerAPPLE');
    private z_ElementPointerAPPLE_1 := GetProcOrNil&<procedure(&type: ElementPointerType; pointer: IntPtr)>(z_ElementPointerAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ElementPointerAPPLE(&type: ElementPointerType; pointer: IntPtr) :=
    z_ElementPointerAPPLE_1(&type, pointer);
    
    private z_DrawElementArrayAPPLE_adr := GetProcAddress('glDrawElementArrayAPPLE');
    private z_DrawElementArrayAPPLE_1 := GetProcOrNil&<procedure(mode: PrimitiveType; first: Int32; count: Int32)>(z_DrawElementArrayAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementArrayAPPLE(mode: PrimitiveType; first: Int32; count: Int32) :=
    z_DrawElementArrayAPPLE_1(mode, first, count);
    
    private z_DrawRangeElementArrayAPPLE_adr := GetProcAddress('glDrawRangeElementArrayAPPLE');
    private z_DrawRangeElementArrayAPPLE_1 := GetProcOrNil&<procedure(mode: PrimitiveType; start: UInt32; &end: UInt32; first: Int32; count: Int32)>(z_DrawRangeElementArrayAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawRangeElementArrayAPPLE(mode: PrimitiveType; start: UInt32; &end: UInt32; first: Int32; count: Int32) :=
    z_DrawRangeElementArrayAPPLE_1(mode, start, &end, first, count);
    
    private z_MultiDrawElementArrayAPPLE_adr := GetProcAddress('glMultiDrawElementArrayAPPLE');
    private z_MultiDrawElementArrayAPPLE_1 := GetProcOrNil&<procedure(mode: PrimitiveType; first: IntPtr; count: IntPtr; primcount: Int32)>(z_MultiDrawElementArrayAPPLE_adr);
    private z_MultiDrawElementArrayAPPLE_2 := GetProcOrNil&<procedure(mode: PrimitiveType; first: IntPtr; var count: Int32; primcount: Int32)>(z_MultiDrawElementArrayAPPLE_adr);
    private z_MultiDrawElementArrayAPPLE_3 := GetProcOrNil&<procedure(mode: PrimitiveType; var first: Int32; count: IntPtr; primcount: Int32)>(z_MultiDrawElementArrayAPPLE_adr);
    private z_MultiDrawElementArrayAPPLE_4 := GetProcOrNil&<procedure(mode: PrimitiveType; var first: Int32; var count: Int32; primcount: Int32)>(z_MultiDrawElementArrayAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementArrayAPPLE(mode: PrimitiveType; first: array of Int32; count: array of Int32; primcount: Int32);
    type PInt32=^Int32;
    begin
      if (count<>nil) and (count.Length<>0) then
        if (first<>nil) and (first.Length<>0) then
          z_MultiDrawElementArrayAPPLE_4(mode, first[0], count[0], primcount) else
          z_MultiDrawElementArrayAPPLE_4(mode, PInt32(nil)^, count[0], primcount) else
        if (first<>nil) and (first.Length<>0) then
          z_MultiDrawElementArrayAPPLE_4(mode, first[0], PInt32(nil)^, primcount) else
          z_MultiDrawElementArrayAPPLE_4(mode, PInt32(nil)^, PInt32(nil)^, primcount);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementArrayAPPLE(mode: PrimitiveType; var first: Int32; var count: Int32; primcount: Int32) :=
    z_MultiDrawElementArrayAPPLE_4(mode, first, count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementArrayAPPLE(mode: PrimitiveType; var first: Int32; count: IntPtr; primcount: Int32) :=
    z_MultiDrawElementArrayAPPLE_3(mode, first, count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementArrayAPPLE(mode: PrimitiveType; first: IntPtr; var count: Int32; primcount: Int32) :=
    z_MultiDrawElementArrayAPPLE_2(mode, first, count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementArrayAPPLE(mode: PrimitiveType; first: IntPtr; count: IntPtr; primcount: Int32) :=
    z_MultiDrawElementArrayAPPLE_1(mode, first, count, primcount);
    
    private z_MultiDrawRangeElementArrayAPPLE_adr := GetProcAddress('glMultiDrawRangeElementArrayAPPLE');
    private z_MultiDrawRangeElementArrayAPPLE_1 := GetProcOrNil&<procedure(mode: PrimitiveType; start: UInt32; &end: UInt32; first: IntPtr; count: IntPtr; primcount: Int32)>(z_MultiDrawRangeElementArrayAPPLE_adr);
    private z_MultiDrawRangeElementArrayAPPLE_2 := GetProcOrNil&<procedure(mode: PrimitiveType; start: UInt32; &end: UInt32; first: IntPtr; var count: Int32; primcount: Int32)>(z_MultiDrawRangeElementArrayAPPLE_adr);
    private z_MultiDrawRangeElementArrayAPPLE_3 := GetProcOrNil&<procedure(mode: PrimitiveType; start: UInt32; &end: UInt32; var first: Int32; count: IntPtr; primcount: Int32)>(z_MultiDrawRangeElementArrayAPPLE_adr);
    private z_MultiDrawRangeElementArrayAPPLE_4 := GetProcOrNil&<procedure(mode: PrimitiveType; start: UInt32; &end: UInt32; var first: Int32; var count: Int32; primcount: Int32)>(z_MultiDrawRangeElementArrayAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawRangeElementArrayAPPLE(mode: PrimitiveType; start: UInt32; &end: UInt32; first: array of Int32; count: array of Int32; primcount: Int32);
    type PInt32=^Int32;
    begin
      if (count<>nil) and (count.Length<>0) then
        if (first<>nil) and (first.Length<>0) then
          z_MultiDrawRangeElementArrayAPPLE_4(mode, start, &end, first[0], count[0], primcount) else
          z_MultiDrawRangeElementArrayAPPLE_4(mode, start, &end, PInt32(nil)^, count[0], primcount) else
        if (first<>nil) and (first.Length<>0) then
          z_MultiDrawRangeElementArrayAPPLE_4(mode, start, &end, first[0], PInt32(nil)^, primcount) else
          z_MultiDrawRangeElementArrayAPPLE_4(mode, start, &end, PInt32(nil)^, PInt32(nil)^, primcount);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawRangeElementArrayAPPLE(mode: PrimitiveType; start: UInt32; &end: UInt32; var first: Int32; var count: Int32; primcount: Int32) :=
    z_MultiDrawRangeElementArrayAPPLE_4(mode, start, &end, first, count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawRangeElementArrayAPPLE(mode: PrimitiveType; start: UInt32; &end: UInt32; var first: Int32; count: IntPtr; primcount: Int32) :=
    z_MultiDrawRangeElementArrayAPPLE_3(mode, start, &end, first, count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawRangeElementArrayAPPLE(mode: PrimitiveType; start: UInt32; &end: UInt32; first: IntPtr; var count: Int32; primcount: Int32) :=
    z_MultiDrawRangeElementArrayAPPLE_2(mode, start, &end, first, count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawRangeElementArrayAPPLE(mode: PrimitiveType; start: UInt32; &end: UInt32; first: IntPtr; count: IntPtr; primcount: Int32) :=
    z_MultiDrawRangeElementArrayAPPLE_1(mode, start, &end, first, count, primcount);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glFenceAPPLE = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_apple_fence';
    
    private z_GenFencesAPPLE_adr := GetProcAddress('glGenFencesAPPLE');
    private z_GenFencesAPPLE_1 := GetProcOrNil&<procedure(n: Int32; fences: IntPtr)>(z_GenFencesAPPLE_adr);
    private z_GenFencesAPPLE_2 := GetProcOrNil&<procedure(n: Int32; var fences: UInt32)>(z_GenFencesAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFencesAPPLE(n: Int32; fences: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (fences<>nil) and (fences.Length<>0) then
        z_GenFencesAPPLE_2(n, fences[0]) else
        z_GenFencesAPPLE_2(n, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFencesAPPLE(n: Int32; var fences: UInt32) :=
    z_GenFencesAPPLE_2(n, fences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFencesAPPLE(n: Int32; fences: IntPtr) :=
    z_GenFencesAPPLE_1(n, fences);
    
    private z_DeleteFencesAPPLE_adr := GetProcAddress('glDeleteFencesAPPLE');
    private z_DeleteFencesAPPLE_1 := GetProcOrNil&<procedure(n: Int32; fences: IntPtr)>(z_DeleteFencesAPPLE_adr);
    private z_DeleteFencesAPPLE_2 := GetProcOrNil&<procedure(n: Int32; var fences: UInt32)>(z_DeleteFencesAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFencesAPPLE(n: Int32; fences: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (fences<>nil) and (fences.Length<>0) then
        z_DeleteFencesAPPLE_2(n, fences[0]) else
        z_DeleteFencesAPPLE_2(n, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFencesAPPLE(n: Int32; var fences: UInt32) :=
    z_DeleteFencesAPPLE_2(n, fences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFencesAPPLE(n: Int32; fences: IntPtr) :=
    z_DeleteFencesAPPLE_1(n, fences);
    
    private z_SetFenceAPPLE_adr := GetProcAddress('glSetFenceAPPLE');
    private z_SetFenceAPPLE_1 := GetProcOrNil&<procedure(fence: UInt32)>(z_SetFenceAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetFenceAPPLE(fence: UInt32) :=
    z_SetFenceAPPLE_1(fence);
    
    private z_IsFenceAPPLE_adr := GetProcAddress('glIsFenceAPPLE');
    private z_IsFenceAPPLE_1 := GetProcOrNil&<function(fence: UInt32): boolean>(z_IsFenceAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsFenceAPPLE(fence: UInt32): boolean :=
    z_IsFenceAPPLE_1(fence);
    
    private z_TestFenceAPPLE_adr := GetProcAddress('glTestFenceAPPLE');
    private z_TestFenceAPPLE_1 := GetProcOrNil&<function(fence: UInt32): boolean>(z_TestFenceAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function TestFenceAPPLE(fence: UInt32): boolean :=
    z_TestFenceAPPLE_1(fence);
    
    private z_FinishFenceAPPLE_adr := GetProcAddress('glFinishFenceAPPLE');
    private z_FinishFenceAPPLE_1 := GetProcOrNil&<procedure(fence: UInt32)>(z_FinishFenceAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FinishFenceAPPLE(fence: UInt32) :=
    z_FinishFenceAPPLE_1(fence);
    
    private z_TestObjectAPPLE_adr := GetProcAddress('glTestObjectAPPLE');
    private z_TestObjectAPPLE_1 := GetProcOrNil&<function(object: ObjectType; name: UInt32): boolean>(z_TestObjectAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function TestObjectAPPLE(object: ObjectType; name: UInt32): boolean :=
    z_TestObjectAPPLE_1(object, name);
    
    private z_FinishObjectAPPLE_adr := GetProcAddress('glFinishObjectAPPLE');
    private z_FinishObjectAPPLE_1 := GetProcOrNil&<procedure(object: ObjectType; name: Int32)>(z_FinishObjectAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FinishObjectAPPLE(object: ObjectType; name: Int32) :=
    z_FinishObjectAPPLE_1(object, name);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glFlushBufferRangeAPPLE = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_apple_flush_buffer_range';
    
    private z_BufferParameteriAPPLE_adr := GetProcAddress('glBufferParameteriAPPLE');
    private z_BufferParameteriAPPLE_1 := GetProcOrNil&<procedure(target: DummyEnum; pname: DummyEnum; param: Int32)>(z_BufferParameteriAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferParameteriAPPLE(target: DummyEnum; pname: DummyEnum; param: Int32) :=
    z_BufferParameteriAPPLE_1(target, pname, param);
    
    private z_FlushMappedBufferRangeAPPLE_adr := GetProcAddress('glFlushMappedBufferRangeAPPLE');
    private z_FlushMappedBufferRangeAPPLE_1 := GetProcOrNil&<procedure(target: BufferTarget; offset: IntPtr; size: UIntPtr)>(z_FlushMappedBufferRangeAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FlushMappedBufferRangeAPPLE(target: BufferTarget; offset: IntPtr; size: UIntPtr) :=
    z_FlushMappedBufferRangeAPPLE_1(target, offset, size);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glObjectPurgeableAPPLE = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_apple_object_purgeable';
    
    private z_ObjectPurgeableAPPLE_adr := GetProcAddress('glObjectPurgeableAPPLE');
    private z_ObjectPurgeableAPPLE_1 := GetProcOrNil&<function(objectType: DummyEnum; name: UInt32; option: DummyEnum): DummyEnum>(z_ObjectPurgeableAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ObjectPurgeableAPPLE(objectType: DummyEnum; name: UInt32; option: DummyEnum): DummyEnum :=
    z_ObjectPurgeableAPPLE_1(objectType, name, option);
    
    private z_ObjectUnpurgeableAPPLE_adr := GetProcAddress('glObjectUnpurgeableAPPLE');
    private z_ObjectUnpurgeableAPPLE_1 := GetProcOrNil&<function(objectType: DummyEnum; name: UInt32; option: DummyEnum): DummyEnum>(z_ObjectUnpurgeableAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ObjectUnpurgeableAPPLE(objectType: DummyEnum; name: UInt32; option: DummyEnum): DummyEnum :=
    z_ObjectUnpurgeableAPPLE_1(objectType, name, option);
    
    private z_GetObjectParameterivAPPLE_adr := GetProcAddress('glGetObjectParameterivAPPLE');
    private z_GetObjectParameterivAPPLE_1 := GetProcOrNil&<procedure(objectType: DummyEnum; name: UInt32; pname: DummyEnum; &params: IntPtr)>(z_GetObjectParameterivAPPLE_adr);
    private z_GetObjectParameterivAPPLE_2 := GetProcOrNil&<procedure(objectType: DummyEnum; name: UInt32; pname: DummyEnum; var &params: Int32)>(z_GetObjectParameterivAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectParameterivAPPLE(objectType: DummyEnum; name: UInt32; pname: DummyEnum; var &params: Int32) :=
    z_GetObjectParameterivAPPLE_2(objectType, name, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectParameterivAPPLE(objectType: DummyEnum; name: UInt32; pname: DummyEnum; &params: IntPtr) :=
    z_GetObjectParameterivAPPLE_1(objectType, name, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glTextureRangeAPPLE = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_apple_texture_range';
    
    private z_TextureRangeAPPLE_adr := GetProcAddress('glTextureRangeAPPLE');
    private z_TextureRangeAPPLE_1 := GetProcOrNil&<procedure(target: DummyEnum; length: Int32; pointer: IntPtr)>(z_TextureRangeAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureRangeAPPLE(target: DummyEnum; length: Int32; pointer: IntPtr) :=
    z_TextureRangeAPPLE_1(target, length, pointer);
    
    private z_GetTexParameterPointervAPPLE_adr := GetProcAddress('glGetTexParameterPointervAPPLE');
    private z_GetTexParameterPointervAPPLE_1 := GetProcOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(z_GetTexParameterPointervAPPLE_adr);
    private z_GetTexParameterPointervAPPLE_2 := GetProcOrNil&<procedure(target: DummyEnum; pname: DummyEnum; var &params: IntPtr)>(z_GetTexParameterPointervAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterPointervAPPLE(target: DummyEnum; pname: DummyEnum; var &params: IntPtr) :=
    z_GetTexParameterPointervAPPLE_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterPointervAPPLE(target: DummyEnum; pname: DummyEnum; &params: pointer) :=
    z_GetTexParameterPointervAPPLE_1(target, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glVertexArrayObjectAPPLE = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_apple_vertex_array_object';
    
    private z_BindVertexArrayAPPLE_adr := GetProcAddress('glBindVertexArrayAPPLE');
    private z_BindVertexArrayAPPLE_1 := GetProcOrNil&<procedure(&array: gl_vertex_array)>(z_BindVertexArrayAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexArrayAPPLE(&array: gl_vertex_array) :=
    z_BindVertexArrayAPPLE_1(&array);
    
    private z_DeleteVertexArraysAPPLE_adr := GetProcAddress('glDeleteVertexArraysAPPLE');
    private z_DeleteVertexArraysAPPLE_1 := GetProcOrNil&<procedure(n: Int32; arrays: IntPtr)>(z_DeleteVertexArraysAPPLE_adr);
    private z_DeleteVertexArraysAPPLE_2 := GetProcOrNil&<procedure(n: Int32; var arrays: gl_vertex_array)>(z_DeleteVertexArraysAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteVertexArraysAPPLE(n: Int32; arrays: array of gl_vertex_array);
    type Pgl_vertex_array=^gl_vertex_array;
    begin
      if (arrays<>nil) and (arrays.Length<>0) then
        z_DeleteVertexArraysAPPLE_2(n, arrays[0]) else
        z_DeleteVertexArraysAPPLE_2(n, Pgl_vertex_array(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteVertexArraysAPPLE(n: Int32; var arrays: gl_vertex_array) :=
    z_DeleteVertexArraysAPPLE_2(n, arrays);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteVertexArraysAPPLE(n: Int32; arrays: IntPtr) :=
    z_DeleteVertexArraysAPPLE_1(n, arrays);
    
    private z_GenVertexArraysAPPLE_adr := GetProcAddress('glGenVertexArraysAPPLE');
    private z_GenVertexArraysAPPLE_1 := GetProcOrNil&<procedure(n: Int32; arrays: IntPtr)>(z_GenVertexArraysAPPLE_adr);
    private z_GenVertexArraysAPPLE_2 := GetProcOrNil&<procedure(n: Int32; var arrays: gl_vertex_array)>(z_GenVertexArraysAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenVertexArraysAPPLE(n: Int32; arrays: array of gl_vertex_array);
    type Pgl_vertex_array=^gl_vertex_array;
    begin
      if (arrays<>nil) and (arrays.Length<>0) then
        z_GenVertexArraysAPPLE_2(n, arrays[0]) else
        z_GenVertexArraysAPPLE_2(n, Pgl_vertex_array(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenVertexArraysAPPLE(n: Int32; var arrays: gl_vertex_array) :=
    z_GenVertexArraysAPPLE_2(n, arrays);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenVertexArraysAPPLE(n: Int32; arrays: IntPtr) :=
    z_GenVertexArraysAPPLE_1(n, arrays);
    
    private z_IsVertexArrayAPPLE_adr := GetProcAddress('glIsVertexArrayAPPLE');
    private z_IsVertexArrayAPPLE_1 := GetProcOrNil&<function(&array: gl_vertex_array): boolean>(z_IsVertexArrayAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsVertexArrayAPPLE(&array: gl_vertex_array): boolean :=
    z_IsVertexArrayAPPLE_1(&array);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glVertexArrayRangeAPPLE = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_apple_vertex_array_range';
    
    private z_VertexArrayRangeAPPLE_adr := GetProcAddress('glVertexArrayRangeAPPLE');
    private z_VertexArrayRangeAPPLE_1 := GetProcOrNil&<procedure(length: Int32; pointer: IntPtr)>(z_VertexArrayRangeAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayRangeAPPLE(length: Int32; pointer: IntPtr) :=
    z_VertexArrayRangeAPPLE_1(length, pointer);
    
    private z_FlushVertexArrayRangeAPPLE_adr := GetProcAddress('glFlushVertexArrayRangeAPPLE');
    private z_FlushVertexArrayRangeAPPLE_1 := GetProcOrNil&<procedure(length: Int32; pointer: IntPtr)>(z_FlushVertexArrayRangeAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FlushVertexArrayRangeAPPLE(length: Int32; pointer: IntPtr) :=
    z_FlushVertexArrayRangeAPPLE_1(length, pointer);
    
    private z_VertexArrayParameteriAPPLE_adr := GetProcAddress('glVertexArrayParameteriAPPLE');
    private z_VertexArrayParameteriAPPLE_1 := GetProcOrNil&<procedure(pname: VertexArrayPNameAPPLE; param: Int32)>(z_VertexArrayParameteriAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayParameteriAPPLE(pname: VertexArrayPNameAPPLE; param: Int32) :=
    z_VertexArrayParameteriAPPLE_1(pname, param);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glVertexProgramEvaluatorsAPPLE = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_apple_vertex_program_evaluators';
    
    private z_EnableVertexAttribAPPLE_adr := GetProcAddress('glEnableVertexAttribAPPLE');
    private z_EnableVertexAttribAPPLE_1 := GetProcOrNil&<procedure(index: UInt32; pname: DummyEnum)>(z_EnableVertexAttribAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableVertexAttribAPPLE(index: UInt32; pname: DummyEnum) :=
    z_EnableVertexAttribAPPLE_1(index, pname);
    
    private z_DisableVertexAttribAPPLE_adr := GetProcAddress('glDisableVertexAttribAPPLE');
    private z_DisableVertexAttribAPPLE_1 := GetProcOrNil&<procedure(index: UInt32; pname: DummyEnum)>(z_DisableVertexAttribAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableVertexAttribAPPLE(index: UInt32; pname: DummyEnum) :=
    z_DisableVertexAttribAPPLE_1(index, pname);
    
    private z_IsVertexAttribEnabledAPPLE_adr := GetProcAddress('glIsVertexAttribEnabledAPPLE');
    private z_IsVertexAttribEnabledAPPLE_1 := GetProcOrNil&<function(index: UInt32; pname: DummyEnum): boolean>(z_IsVertexAttribEnabledAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsVertexAttribEnabledAPPLE(index: UInt32; pname: DummyEnum): boolean :=
    z_IsVertexAttribEnabledAPPLE_1(index, pname);
    
    private z_MapVertexAttrib1dAPPLE_adr := GetProcAddress('glMapVertexAttrib1dAPPLE');
    private z_MapVertexAttrib1dAPPLE_1 := GetProcOrNil&<procedure(index: UInt32; size: UInt32; u1: real; u2: real; stride: Int32; order: Int32; points: IntPtr)>(z_MapVertexAttrib1dAPPLE_adr);
    private z_MapVertexAttrib1dAPPLE_2 := GetProcOrNil&<procedure(index: UInt32; size: UInt32; u1: real; u2: real; stride: Int32; order: Int32; var points: real)>(z_MapVertexAttrib1dAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib1dAPPLE(index: UInt32; size: UInt32; u1: real; u2: real; stride: Int32; order: Int32; points: array of real);
    type Preal=^real;
    begin
      if (points<>nil) and (points.Length<>0) then
        z_MapVertexAttrib1dAPPLE_2(index, size, u1, u2, stride, order, points[0]) else
        z_MapVertexAttrib1dAPPLE_2(index, size, u1, u2, stride, order, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib1dAPPLE(index: UInt32; size: UInt32; u1: real; u2: real; stride: Int32; order: Int32; var points: real) :=
    z_MapVertexAttrib1dAPPLE_2(index, size, u1, u2, stride, order, points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib1dAPPLE(index: UInt32; size: UInt32; u1: real; u2: real; stride: Int32; order: Int32; points: IntPtr) :=
    z_MapVertexAttrib1dAPPLE_1(index, size, u1, u2, stride, order, points);
    
    private z_MapVertexAttrib1fAPPLE_adr := GetProcAddress('glMapVertexAttrib1fAPPLE');
    private z_MapVertexAttrib1fAPPLE_1 := GetProcOrNil&<procedure(index: UInt32; size: UInt32; u1: single; u2: single; stride: Int32; order: Int32; points: IntPtr)>(z_MapVertexAttrib1fAPPLE_adr);
    private z_MapVertexAttrib1fAPPLE_2 := GetProcOrNil&<procedure(index: UInt32; size: UInt32; u1: single; u2: single; stride: Int32; order: Int32; var points: single)>(z_MapVertexAttrib1fAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib1fAPPLE(index: UInt32; size: UInt32; u1: single; u2: single; stride: Int32; order: Int32; points: array of single);
    type Psingle=^single;
    begin
      if (points<>nil) and (points.Length<>0) then
        z_MapVertexAttrib1fAPPLE_2(index, size, u1, u2, stride, order, points[0]) else
        z_MapVertexAttrib1fAPPLE_2(index, size, u1, u2, stride, order, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib1fAPPLE(index: UInt32; size: UInt32; u1: single; u2: single; stride: Int32; order: Int32; var points: single) :=
    z_MapVertexAttrib1fAPPLE_2(index, size, u1, u2, stride, order, points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib1fAPPLE(index: UInt32; size: UInt32; u1: single; u2: single; stride: Int32; order: Int32; points: IntPtr) :=
    z_MapVertexAttrib1fAPPLE_1(index, size, u1, u2, stride, order, points);
    
    private z_MapVertexAttrib2dAPPLE_adr := GetProcAddress('glMapVertexAttrib2dAPPLE');
    private z_MapVertexAttrib2dAPPLE_1 := GetProcOrNil&<procedure(index: UInt32; size: UInt32; u1: real; u2: real; ustride: Int32; uorder: Int32; v1: real; v2: real; vstride: Int32; vorder: Int32; points: IntPtr)>(z_MapVertexAttrib2dAPPLE_adr);
    private z_MapVertexAttrib2dAPPLE_2 := GetProcOrNil&<procedure(index: UInt32; size: UInt32; u1: real; u2: real; ustride: Int32; uorder: Int32; v1: real; v2: real; vstride: Int32; vorder: Int32; var points: real)>(z_MapVertexAttrib2dAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib2dAPPLE(index: UInt32; size: UInt32; u1: real; u2: real; ustride: Int32; uorder: Int32; v1: real; v2: real; vstride: Int32; vorder: Int32; points: array of real);
    type Preal=^real;
    begin
      if (points<>nil) and (points.Length<>0) then
        z_MapVertexAttrib2dAPPLE_2(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points[0]) else
        z_MapVertexAttrib2dAPPLE_2(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib2dAPPLE(index: UInt32; size: UInt32; u1: real; u2: real; ustride: Int32; uorder: Int32; v1: real; v2: real; vstride: Int32; vorder: Int32; var points: real) :=
    z_MapVertexAttrib2dAPPLE_2(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib2dAPPLE(index: UInt32; size: UInt32; u1: real; u2: real; ustride: Int32; uorder: Int32; v1: real; v2: real; vstride: Int32; vorder: Int32; points: IntPtr) :=
    z_MapVertexAttrib2dAPPLE_1(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    
    private z_MapVertexAttrib2fAPPLE_adr := GetProcAddress('glMapVertexAttrib2fAPPLE');
    private z_MapVertexAttrib2fAPPLE_1 := GetProcOrNil&<procedure(index: UInt32; size: UInt32; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; points: IntPtr)>(z_MapVertexAttrib2fAPPLE_adr);
    private z_MapVertexAttrib2fAPPLE_2 := GetProcOrNil&<procedure(index: UInt32; size: UInt32; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; var points: single)>(z_MapVertexAttrib2fAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib2fAPPLE(index: UInt32; size: UInt32; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; points: array of single);
    type Psingle=^single;
    begin
      if (points<>nil) and (points.Length<>0) then
        z_MapVertexAttrib2fAPPLE_2(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points[0]) else
        z_MapVertexAttrib2fAPPLE_2(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib2fAPPLE(index: UInt32; size: UInt32; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; var points: single) :=
    z_MapVertexAttrib2fAPPLE_2(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib2fAPPLE(index: UInt32; size: UInt32; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; points: IntPtr) :=
    z_MapVertexAttrib2fAPPLE_1(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glES2CompatibilityARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_es2_compatibility';
    
    private z_ReleaseShaderCompiler_adr := GetProcAddress('glReleaseShaderCompiler');
    private z_ReleaseShaderCompiler_1 := GetProcOrNil&<procedure>(z_ReleaseShaderCompiler_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReleaseShaderCompiler :=
    z_ReleaseShaderCompiler_1();
    
    private z_ShaderBinary_adr := GetProcAddress('glShaderBinary');
    private z_ShaderBinary_1 := GetProcOrNil&<procedure(count: Int32; shaders: IntPtr; binaryFormat: ShaderBinaryFormat; binary: IntPtr; length: Int32)>(z_ShaderBinary_adr);
    private z_ShaderBinary_2 := GetProcOrNil&<procedure(count: Int32; var shaders: gl_shader; binaryFormat: ShaderBinaryFormat; binary: IntPtr; length: Int32)>(z_ShaderBinary_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderBinary(count: Int32; shaders: array of gl_shader; binaryFormat: ShaderBinaryFormat; binary: IntPtr; length: Int32);
    type Pgl_shader=^gl_shader;
    begin
      if (shaders<>nil) and (shaders.Length<>0) then
        z_ShaderBinary_2(count, shaders[0], binaryFormat, binary, length) else
        z_ShaderBinary_2(count, Pgl_shader(nil)^, binaryFormat, binary, length);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderBinary(count: Int32; var shaders: gl_shader; binaryFormat: ShaderBinaryFormat; binary: IntPtr; length: Int32) :=
    z_ShaderBinary_2(count, shaders, binaryFormat, binary, length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderBinary(count: Int32; shaders: IntPtr; binaryFormat: ShaderBinaryFormat; binary: IntPtr; length: Int32) :=
    z_ShaderBinary_1(count, shaders, binaryFormat, binary, length);
    
    private z_GetShaderPrecisionFormat_adr := GetProcAddress('glGetShaderPrecisionFormat');
    private z_GetShaderPrecisionFormat_1 := GetProcOrNil&<procedure(_shadertype: ShaderType; _precisiontype: PrecisionType; range: IntPtr; precision: IntPtr)>(z_GetShaderPrecisionFormat_adr);
    private z_GetShaderPrecisionFormat_2 := GetProcOrNil&<procedure(_shadertype: ShaderType; _precisiontype: PrecisionType; range: IntPtr; var precision: Int32)>(z_GetShaderPrecisionFormat_adr);
    private z_GetShaderPrecisionFormat_3 := GetProcOrNil&<procedure(_shadertype: ShaderType; _precisiontype: PrecisionType; var range: Int32; precision: IntPtr)>(z_GetShaderPrecisionFormat_adr);
    private z_GetShaderPrecisionFormat_4 := GetProcOrNil&<procedure(_shadertype: ShaderType; _precisiontype: PrecisionType; var range: Int32; var precision: Int32)>(z_GetShaderPrecisionFormat_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderPrecisionFormat(_shadertype: ShaderType; _precisiontype: PrecisionType; var range: Int32; var precision: Int32) :=
    z_GetShaderPrecisionFormat_4(_shadertype, _precisiontype, range, precision);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderPrecisionFormat(_shadertype: ShaderType; _precisiontype: PrecisionType; var range: Int32; precision: IntPtr) :=
    z_GetShaderPrecisionFormat_3(_shadertype, _precisiontype, range, precision);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderPrecisionFormat(_shadertype: ShaderType; _precisiontype: PrecisionType; range: IntPtr; var precision: Int32) :=
    z_GetShaderPrecisionFormat_2(_shadertype, _precisiontype, range, precision);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderPrecisionFormat(_shadertype: ShaderType; _precisiontype: PrecisionType; range: IntPtr; precision: IntPtr) :=
    z_GetShaderPrecisionFormat_1(_shadertype, _precisiontype, range, precision);
    
    private z_DepthRangef_adr := GetProcAddress('glDepthRangef');
    private z_DepthRangef_1 := GetProcOrNil&<procedure(n: single; f: single)>(z_DepthRangef_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangef(n: single; f: single) :=
    z_DepthRangef_1(n, f);
    
    private z_ClearDepthf_adr := GetProcAddress('glClearDepthf');
    private z_ClearDepthf_1 := GetProcOrNil&<procedure(d: single)>(z_ClearDepthf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearDepthf(d: single) :=
    z_ClearDepthf_1(d);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glES31CompatibilityARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_es3_1_compatibility';
    
    private z_MemoryBarrierByRegion_adr := GetProcAddress('glMemoryBarrierByRegion');
    private z_MemoryBarrierByRegion_1 := GetProcOrNil&<procedure(barriers: MemoryBarrierMask)>(z_MemoryBarrierByRegion_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MemoryBarrierByRegion(barriers: MemoryBarrierMask) :=
    z_MemoryBarrierByRegion_1(barriers);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glES32CompatibilityARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_es3_2_compatibility';
    
    private z_PrimitiveBoundingBoxARB_adr := GetProcAddress('glPrimitiveBoundingBoxARB');
    private z_PrimitiveBoundingBoxARB_1 := GetProcOrNil&<procedure(minX: single; minY: single; minZ: single; minW: single; maxX: single; maxY: single; maxZ: single; maxW: single)>(z_PrimitiveBoundingBoxARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrimitiveBoundingBoxARB(minX: single; minY: single; minZ: single; minW: single; maxX: single; maxY: single; maxZ: single; maxW: single) :=
    z_PrimitiveBoundingBoxARB_1(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glBaseInstanceARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_base_instance';
    
    private z_DrawArraysInstancedBaseInstance_adr := GetProcAddress('glDrawArraysInstancedBaseInstance');
    private z_DrawArraysInstancedBaseInstance_1 := GetProcOrNil&<procedure(mode: PrimitiveType; first: Int32; count: Int32; instancecount: Int32; baseinstance: UInt32)>(z_DrawArraysInstancedBaseInstance_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawArraysInstancedBaseInstance(mode: PrimitiveType; first: Int32; count: Int32; instancecount: Int32; baseinstance: UInt32) :=
    z_DrawArraysInstancedBaseInstance_1(mode, first, count, instancecount, baseinstance);
    
    private z_DrawElementsInstancedBaseInstance_adr := GetProcAddress('glDrawElementsInstancedBaseInstance');
    private z_DrawElementsInstancedBaseInstance_1 := GetProcOrNil&<procedure(mode: PrimitiveType; count: Int32; &type: PrimitiveType; indices: IntPtr; instancecount: Int32; baseinstance: UInt32)>(z_DrawElementsInstancedBaseInstance_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedBaseInstance(mode: PrimitiveType; count: Int32; &type: PrimitiveType; indices: IntPtr; instancecount: Int32; baseinstance: UInt32) :=
    z_DrawElementsInstancedBaseInstance_1(mode, count, &type, indices, instancecount, baseinstance);
    
    private z_DrawElementsInstancedBaseVertexBaseInstance_adr := GetProcAddress('glDrawElementsInstancedBaseVertexBaseInstance');
    private z_DrawElementsInstancedBaseVertexBaseInstance_1 := GetProcOrNil&<procedure(mode: PrimitiveType; count: Int32; &type: DrawElementsType; indices: IntPtr; instancecount: Int32; basevertex: Int32; baseinstance: UInt32)>(z_DrawElementsInstancedBaseVertexBaseInstance_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedBaseVertexBaseInstance(mode: PrimitiveType; count: Int32; &type: DrawElementsType; indices: IntPtr; instancecount: Int32; basevertex: Int32; baseinstance: UInt32) :=
    z_DrawElementsInstancedBaseVertexBaseInstance_1(mode, count, &type, indices, instancecount, basevertex, baseinstance);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glBindlessTextureARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_bindless_texture';
    
    private z_GetTextureHandleARB_adr := GetProcAddress('glGetTextureHandleARB');
    private z_GetTextureHandleARB_1 := GetProcOrNil&<function(texture: gl_texture): UInt64>(z_GetTextureHandleARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetTextureHandleARB(texture: gl_texture): UInt64 :=
    z_GetTextureHandleARB_1(texture);
    
    private z_GetTextureSamplerHandleARB_adr := GetProcAddress('glGetTextureSamplerHandleARB');
    private z_GetTextureSamplerHandleARB_1 := GetProcOrNil&<function(texture: gl_texture; sampler: gl_sampler): UInt64>(z_GetTextureSamplerHandleARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetTextureSamplerHandleARB(texture: gl_texture; sampler: gl_sampler): UInt64 :=
    z_GetTextureSamplerHandleARB_1(texture, sampler);
    
    private z_MakeTextureHandleResidentARB_adr := GetProcAddress('glMakeTextureHandleResidentARB');
    private z_MakeTextureHandleResidentARB_1 := GetProcOrNil&<procedure(handle: UInt64)>(z_MakeTextureHandleResidentARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeTextureHandleResidentARB(handle: UInt64) :=
    z_MakeTextureHandleResidentARB_1(handle);
    
    private z_MakeTextureHandleNonResidentARB_adr := GetProcAddress('glMakeTextureHandleNonResidentARB');
    private z_MakeTextureHandleNonResidentARB_1 := GetProcOrNil&<procedure(handle: UInt64)>(z_MakeTextureHandleNonResidentARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeTextureHandleNonResidentARB(handle: UInt64) :=
    z_MakeTextureHandleNonResidentARB_1(handle);
    
    private z_GetImageHandleARB_adr := GetProcAddress('glGetImageHandleARB');
    private z_GetImageHandleARB_1 := GetProcOrNil&<function(texture: gl_texture; level: Int32; layered: boolean; layer: Int32; format: PixelFormat): UInt64>(z_GetImageHandleARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetImageHandleARB(texture: gl_texture; level: Int32; layered: boolean; layer: Int32; format: PixelFormat): UInt64 :=
    z_GetImageHandleARB_1(texture, level, layered, layer, format);
    
    private z_MakeImageHandleResidentARB_adr := GetProcAddress('glMakeImageHandleResidentARB');
    private z_MakeImageHandleResidentARB_1 := GetProcOrNil&<procedure(handle: UInt64; access: DummyEnum)>(z_MakeImageHandleResidentARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeImageHandleResidentARB(handle: UInt64; access: DummyEnum) :=
    z_MakeImageHandleResidentARB_1(handle, access);
    
    private z_MakeImageHandleNonResidentARB_adr := GetProcAddress('glMakeImageHandleNonResidentARB');
    private z_MakeImageHandleNonResidentARB_1 := GetProcOrNil&<procedure(handle: UInt64)>(z_MakeImageHandleNonResidentARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeImageHandleNonResidentARB(handle: UInt64) :=
    z_MakeImageHandleNonResidentARB_1(handle);
    
    private z_UniformHandleui64ARB_adr := GetProcAddress('glUniformHandleui64ARB');
    private z_UniformHandleui64ARB_1 := GetProcOrNil&<procedure(location: Int32; value: UInt64)>(z_UniformHandleui64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformHandleui64ARB(location: Int32; value: UInt64) :=
    z_UniformHandleui64ARB_1(location, value);
    
    private z_UniformHandleui64vARB_adr := GetProcAddress('glUniformHandleui64vARB');
    private z_UniformHandleui64vARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_UniformHandleui64vARB_adr);
    private z_UniformHandleui64vARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt64)>(z_UniformHandleui64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformHandleui64vARB(location: Int32; count: Int32; value: array of UInt64);
    type PUInt64=^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_UniformHandleui64vARB_2(location, count, value[0]) else
        z_UniformHandleui64vARB_2(location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformHandleui64vARB(location: Int32; count: Int32; var value: UInt64) :=
    z_UniformHandleui64vARB_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformHandleui64vARB(location: Int32; count: Int32; value: IntPtr) :=
    z_UniformHandleui64vARB_1(location, count, value);
    
    private z_ProgramUniformHandleui64ARB_adr := GetProcAddress('glProgramUniformHandleui64ARB');
    private z_ProgramUniformHandleui64ARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; value: UInt64)>(z_ProgramUniformHandleui64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformHandleui64ARB(&program: gl_program; location: Int32; value: UInt64) :=
    z_ProgramUniformHandleui64ARB_1(&program, location, value);
    
    private z_ProgramUniformHandleui64vARB_adr := GetProcAddress('glProgramUniformHandleui64vARB');
    private z_ProgramUniformHandleui64vARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; values: IntPtr)>(z_ProgramUniformHandleui64vARB_adr);
    private z_ProgramUniformHandleui64vARB_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var values: UInt64)>(z_ProgramUniformHandleui64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformHandleui64vARB(&program: gl_program; location: Int32; count: Int32; values: array of UInt64);
    type PUInt64=^UInt64;
    begin
      if (values<>nil) and (values.Length<>0) then
        z_ProgramUniformHandleui64vARB_2(&program, location, count, values[0]) else
        z_ProgramUniformHandleui64vARB_2(&program, location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformHandleui64vARB(&program: gl_program; location: Int32; count: Int32; var values: UInt64) :=
    z_ProgramUniformHandleui64vARB_2(&program, location, count, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformHandleui64vARB(&program: gl_program; location: Int32; count: Int32; values: IntPtr) :=
    z_ProgramUniformHandleui64vARB_1(&program, location, count, values);
    
    private z_IsTextureHandleResidentARB_adr := GetProcAddress('glIsTextureHandleResidentARB');
    private z_IsTextureHandleResidentARB_1 := GetProcOrNil&<function(handle: UInt64): boolean>(z_IsTextureHandleResidentARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsTextureHandleResidentARB(handle: UInt64): boolean :=
    z_IsTextureHandleResidentARB_1(handle);
    
    private z_IsImageHandleResidentARB_adr := GetProcAddress('glIsImageHandleResidentARB');
    private z_IsImageHandleResidentARB_1 := GetProcOrNil&<function(handle: UInt64): boolean>(z_IsImageHandleResidentARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsImageHandleResidentARB(handle: UInt64): boolean :=
    z_IsImageHandleResidentARB_1(handle);
    
    private z_VertexAttribL1ui64ARB_adr := GetProcAddress('glVertexAttribL1ui64ARB');
    private z_VertexAttribL1ui64ARB_1 := GetProcOrNil&<procedure(index: UInt32; x: UInt64)>(z_VertexAttribL1ui64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1ui64ARB(index: UInt32; x: UInt64) :=
    z_VertexAttribL1ui64ARB_1(index, x);
    
    private z_VertexAttribL1ui64vARB_adr := GetProcAddress('glVertexAttribL1ui64vARB');
    private z_VertexAttribL1ui64vARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribL1ui64vARB_adr);
    private z_VertexAttribL1ui64vARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: UInt64)>(z_VertexAttribL1ui64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1ui64vARB(index: UInt32; v: array of UInt64);
    type PUInt64=^UInt64;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribL1ui64vARB_2(index, v[0]) else
        z_VertexAttribL1ui64vARB_2(index, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1ui64vARB(index: UInt32; var v: UInt64) :=
    z_VertexAttribL1ui64vARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1ui64vARB(index: UInt32; v: IntPtr) :=
    z_VertexAttribL1ui64vARB_1(index, v);
    
    private z_GetVertexAttribLui64vARB_adr := GetProcAddress('glGetVertexAttribLui64vARB');
    private z_GetVertexAttribLui64vARB_1 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribEnum; &params: IntPtr)>(z_GetVertexAttribLui64vARB_adr);
    private z_GetVertexAttribLui64vARB_2 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribEnum; var &params: UInt64)>(z_GetVertexAttribLui64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLui64vARB(index: UInt32; pname: VertexAttribEnum; var &params: UInt64) :=
    z_GetVertexAttribLui64vARB_2(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLui64vARB(index: UInt32; pname: VertexAttribEnum; &params: IntPtr) :=
    z_GetVertexAttribLui64vARB_1(index, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glBlendFuncExtendedARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_blend_func_extended';
    
    private z_BindFragDataLocationIndexed_adr := GetProcAddress('glBindFragDataLocationIndexed');
    private z_BindFragDataLocationIndexed_1 := GetProcOrNil&<procedure(&program: gl_program; colorNumber: UInt32; index: UInt32; name: IntPtr)>(z_BindFragDataLocationIndexed_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindFragDataLocationIndexed(&program: gl_program; colorNumber: UInt32; index: UInt32; name: string);
    begin
      var name_str_ptr: IntPtr;
      try
        name_str_ptr := Marshal.StringToHGlobalAnsi(name);
        z_BindFragDataLocationIndexed_1(&program, colorNumber, index, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindFragDataLocationIndexed(&program: gl_program; colorNumber: UInt32; index: UInt32; name: IntPtr) :=
    z_BindFragDataLocationIndexed_1(&program, colorNumber, index, name);
    
    private z_GetFragDataIndex_adr := GetProcAddress('glGetFragDataIndex');
    private z_GetFragDataIndex_1 := GetProcOrNil&<function(&program: gl_program; name: IntPtr): Int32>(z_GetFragDataIndex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFragDataIndex(&program: gl_program; name: string): Int32;
    begin
      var name_str_ptr: IntPtr;
      try
        name_str_ptr := Marshal.StringToHGlobalAnsi(name);
        Result := z_GetFragDataIndex_1(&program, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFragDataIndex(&program: gl_program; name: IntPtr): Int32 :=
    z_GetFragDataIndex_1(&program, name);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glBufferStorageARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_buffer_storage';
    
    private z_BufferStorage_adr := GetProcAddress('glBufferStorage');
    private z_BufferStorage_1 := GetProcOrNil&<procedure(target: BufferStorageTarget; size: UIntPtr; data: pointer; flags: BufferStorageMask)>(z_BufferStorage_adr);
    private z_BufferStorage_2 := GetProcOrNil&<procedure(target: BufferStorageTarget; size: UIntPtr; var data: Byte; flags: BufferStorageMask)>(z_BufferStorage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferStorage<T>(target: BufferStorageTarget; size: UIntPtr; data: array of T; flags: BufferStorageMask); where T: record;
    type PT=^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        BufferStorage(target, size, data[0], flags) else
        BufferStorage(target, size, PT(nil)^, flags);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferStorage<T>(target: BufferStorageTarget; size: UIntPtr; var data: T; flags: BufferStorageMask); where T: record;
    begin
      z_BufferStorage_2(target, size, PByte(pointer(@data))^, flags);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferStorage(target: BufferStorageTarget; size: UIntPtr; data: pointer; flags: BufferStorageMask) :=
    z_BufferStorage_1(target, size, data, flags);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glClEventARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_cl_event';
    
    private z_CreateSyncFromCLeventARB_adr := GetProcAddress('glCreateSyncFromCLeventARB');
    private z_CreateSyncFromCLeventARB_1 := GetProcOrNil&<function(context: IntPtr; &event: IntPtr; flags: DummyFlags): gl_sync>(z_CreateSyncFromCLeventARB_adr);
    private z_CreateSyncFromCLeventARB_2 := GetProcOrNil&<function(context: IntPtr; var &event: gl_cl_event; flags: DummyFlags): gl_sync>(z_CreateSyncFromCLeventARB_adr);
    private z_CreateSyncFromCLeventARB_3 := GetProcOrNil&<function(var context: gl_cl_context; &event: IntPtr; flags: DummyFlags): gl_sync>(z_CreateSyncFromCLeventARB_adr);
    private z_CreateSyncFromCLeventARB_4 := GetProcOrNil&<function(var context: gl_cl_context; var &event: gl_cl_event; flags: DummyFlags): gl_sync>(z_CreateSyncFromCLeventARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSyncFromCLeventARB(context: array of gl_cl_context; &event: array of gl_cl_event; flags: DummyFlags): gl_sync;
    type Pgl_cl_context=^gl_cl_context;
    type Pgl_cl_event=^gl_cl_event;
    begin
      Result := if (&event<>nil) and (&event.Length<>0) then
        if (context<>nil) and (context.Length<>0) then
          z_CreateSyncFromCLeventARB_4(context[0], &event[0], flags) else
          z_CreateSyncFromCLeventARB_4(Pgl_cl_context(nil)^, &event[0], flags) else
        if (context<>nil) and (context.Length<>0) then
          z_CreateSyncFromCLeventARB_4(context[0], Pgl_cl_event(nil)^, flags) else
          z_CreateSyncFromCLeventARB_4(Pgl_cl_context(nil)^, Pgl_cl_event(nil)^, flags);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSyncFromCLeventARB(var context: gl_cl_context; var &event: gl_cl_event; flags: DummyFlags): gl_sync :=
    z_CreateSyncFromCLeventARB_4(context, &event, flags);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSyncFromCLeventARB(var context: gl_cl_context; &event: IntPtr; flags: DummyFlags): gl_sync :=
    z_CreateSyncFromCLeventARB_3(context, &event, flags);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSyncFromCLeventARB(context: IntPtr; var &event: gl_cl_event; flags: DummyFlags): gl_sync :=
    z_CreateSyncFromCLeventARB_2(context, &event, flags);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSyncFromCLeventARB(context: IntPtr; &event: IntPtr; flags: DummyFlags): gl_sync :=
    z_CreateSyncFromCLeventARB_1(context, &event, flags);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glClearBufferObjectARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_clear_buffer_object';
    
    private z_ClearBufferData_adr := GetProcAddress('glClearBufferData');
    private z_ClearBufferData_1 := GetProcOrNil&<procedure(target: BufferStorageTarget; internalformat: SizedInternalFormat; format: PixelFormat; &type: PixelType; data: pointer)>(z_ClearBufferData_adr);
    private z_ClearBufferData_2 := GetProcOrNil&<procedure(target: BufferStorageTarget; internalformat: SizedInternalFormat; format: PixelFormat; &type: PixelType; var data: Byte)>(z_ClearBufferData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferData<T>(target: BufferStorageTarget; internalformat: SizedInternalFormat; format: PixelFormat; &type: PixelType; data: array of T); where T: record;
    type PT=^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        ClearBufferData(target, internalformat, format, &type, data[0]) else
        ClearBufferData(target, internalformat, format, &type, PT(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferData<T>(target: BufferStorageTarget; internalformat: SizedInternalFormat; format: PixelFormat; &type: PixelType; var data: T); where T: record;
    begin
      z_ClearBufferData_2(target, internalformat, format, &type, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferData(target: BufferStorageTarget; internalformat: SizedInternalFormat; format: PixelFormat; &type: PixelType; data: pointer) :=
    z_ClearBufferData_1(target, internalformat, format, &type, data);
    
    private z_ClearBufferSubData_adr := GetProcAddress('glClearBufferSubData');
    private z_ClearBufferSubData_1 := GetProcOrNil&<procedure(target: BufferTarget; internalformat: SizedInternalFormat; offset: IntPtr; size: UIntPtr; format: PixelFormat; &type: PixelType; data: pointer)>(z_ClearBufferSubData_adr);
    private z_ClearBufferSubData_2 := GetProcOrNil&<procedure(target: BufferTarget; internalformat: SizedInternalFormat; offset: IntPtr; size: UIntPtr; format: PixelFormat; &type: PixelType; var data: Byte)>(z_ClearBufferSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferSubData<T>(target: BufferTarget; internalformat: SizedInternalFormat; offset: IntPtr; size: UIntPtr; format: PixelFormat; &type: PixelType; data: array of T); where T: record;
    type PT=^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        ClearBufferSubData(target, internalformat, offset, size, format, &type, data[0]) else
        ClearBufferSubData(target, internalformat, offset, size, format, &type, PT(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferSubData<T>(target: BufferTarget; internalformat: SizedInternalFormat; offset: IntPtr; size: UIntPtr; format: PixelFormat; &type: PixelType; var data: T); where T: record;
    begin
      z_ClearBufferSubData_2(target, internalformat, offset, size, format, &type, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferSubData(target: BufferTarget; internalformat: SizedInternalFormat; offset: IntPtr; size: UIntPtr; format: PixelFormat; &type: PixelType; data: pointer) :=
    z_ClearBufferSubData_1(target, internalformat, offset, size, format, &type, data);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glClearTextureARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_clear_texture';
    
    private z_ClearTexImage_adr := GetProcAddress('glClearTexImage');
    private z_ClearTexImage_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; format: PixelFormat; &type: PixelType; data: IntPtr)>(z_ClearTexImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearTexImage(texture: gl_texture; level: Int32; format: PixelFormat; &type: PixelType; data: IntPtr) :=
    z_ClearTexImage_1(texture, level, format, &type, data);
    
    private z_ClearTexSubImage_adr := GetProcAddress('glClearTexSubImage');
    private z_ClearTexSubImage_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: PixelFormat; &type: PixelType; data: IntPtr)>(z_ClearTexSubImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearTexSubImage(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: PixelFormat; &type: PixelType; data: IntPtr) :=
    z_ClearTexSubImage_1(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, data);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glClipControlARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_clip_control';
    
    private z_ClipControl_adr := GetProcAddress('glClipControl');
    private z_ClipControl_1 := GetProcOrNil&<procedure(origin: ClipControlOrigin; depth: ClipControlDepth)>(z_ClipControl_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipControl(origin: ClipControlOrigin; depth: ClipControlDepth) :=
    z_ClipControl_1(origin, depth);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glColorBufferFloatARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_color_buffer_float';
    
    private z_ClampColorARB_adr := GetProcAddress('glClampColorARB');
    private z_ClampColorARB_1 := GetProcOrNil&<procedure(target: ClampColorTarget; clamp: ClampColorMode)>(z_ClampColorARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClampColorARB(target: ClampColorTarget; clamp: ClampColorMode) :=
    z_ClampColorARB_1(target, clamp);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glComputeShaderARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_compute_shader';
    
    private z_DispatchCompute_adr := GetProcAddress('glDispatchCompute');
    private z_DispatchCompute_1 := GetProcOrNil&<procedure(num_groups_x: UInt32; num_groups_y: UInt32; num_groups_z: UInt32)>(z_DispatchCompute_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DispatchCompute(num_groups_x: UInt32; num_groups_y: UInt32; num_groups_z: UInt32) :=
    z_DispatchCompute_1(num_groups_x, num_groups_y, num_groups_z);
    
    private z_DispatchComputeIndirect_adr := GetProcAddress('glDispatchComputeIndirect');
    private z_DispatchComputeIndirect_1 := GetProcOrNil&<procedure(indirect: IntPtr)>(z_DispatchComputeIndirect_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DispatchComputeIndirect(indirect: IntPtr) :=
    z_DispatchComputeIndirect_1(indirect);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glComputeVariableGroupSizeARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_compute_variable_group_size';
    
    private z_DispatchComputeGroupSizeARB_adr := GetProcAddress('glDispatchComputeGroupSizeARB');
    private z_DispatchComputeGroupSizeARB_1 := GetProcOrNil&<procedure(num_groups_x: UInt32; num_groups_y: UInt32; num_groups_z: UInt32; group_size_x: UInt32; group_size_y: UInt32; group_size_z: UInt32)>(z_DispatchComputeGroupSizeARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DispatchComputeGroupSizeARB(num_groups_x: UInt32; num_groups_y: UInt32; num_groups_z: UInt32; group_size_x: UInt32; group_size_y: UInt32; group_size_z: UInt32) :=
    z_DispatchComputeGroupSizeARB_1(num_groups_x, num_groups_y, num_groups_z, group_size_x, group_size_y, group_size_z);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glCopyBufferARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_copy_buffer';
    
    private z_CopyBufferSubData_adr := GetProcAddress('glCopyBufferSubData');
    private z_CopyBufferSubData_1 := GetProcOrNil&<procedure(readTarget: CopyBufferSubDataTarget; writeTarget: CopyBufferSubDataTarget; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr)>(z_CopyBufferSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyBufferSubData(readTarget: CopyBufferSubDataTarget; writeTarget: CopyBufferSubDataTarget; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr) :=
    z_CopyBufferSubData_1(readTarget, writeTarget, readOffset, writeOffset, size);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glCopyImageARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_copy_image';
    
    private z_CopyImageSubData_adr := GetProcAddress('glCopyImageSubData');
    private z_CopyImageSubData_1 := GetProcOrNil&<procedure(srcName: UInt32; srcTarget: CopyImageSubDataTarget; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: CopyImageSubDataTarget; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32)>(z_CopyImageSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyImageSubData(srcName: UInt32; srcTarget: CopyImageSubDataTarget; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: CopyImageSubDataTarget; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32) :=
    z_CopyImageSubData_1(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glDebugOutputARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_debug_output';
    
    private z_DebugMessageControlARB_adr := GetProcAddress('glDebugMessageControlARB');
    private z_DebugMessageControlARB_1 := GetProcOrNil&<procedure(source: DebugSource; &type: DebugType; severity: DebugSeverity; count: Int32; ids: IntPtr; enabled: boolean)>(z_DebugMessageControlARB_adr);
    private z_DebugMessageControlARB_2 := GetProcOrNil&<procedure(source: DebugSource; &type: DebugType; severity: DebugSeverity; count: Int32; var ids: UInt32; enabled: boolean)>(z_DebugMessageControlARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageControlARB(source: DebugSource; &type: DebugType; severity: DebugSeverity; count: Int32; ids: array of UInt32; enabled: boolean);
    type PUInt32=^UInt32;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        z_DebugMessageControlARB_2(source, &type, severity, count, ids[0], enabled) else
        z_DebugMessageControlARB_2(source, &type, severity, count, PUInt32(nil)^, enabled);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageControlARB(source: DebugSource; &type: DebugType; severity: DebugSeverity; count: Int32; var ids: UInt32; enabled: boolean) :=
    z_DebugMessageControlARB_2(source, &type, severity, count, ids, enabled);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageControlARB(source: DebugSource; &type: DebugType; severity: DebugSeverity; count: Int32; ids: IntPtr; enabled: boolean) :=
    z_DebugMessageControlARB_1(source, &type, severity, count, ids, enabled);
    
    private z_DebugMessageInsertARB_adr := GetProcAddress('glDebugMessageInsertARB');
    private z_DebugMessageInsertARB_1 := GetProcOrNil&<procedure(source: DebugSource; &type: DebugType; id: UInt32; severity: DebugSeverity; length: Int32; buf: IntPtr)>(z_DebugMessageInsertARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageInsertARB(source: DebugSource; &type: DebugType; id: UInt32; severity: DebugSeverity; length: Int32; buf: string);
    begin
      var buf_str_ptr: IntPtr;
      try
        buf_str_ptr := Marshal.StringToHGlobalAnsi(buf);
        z_DebugMessageInsertARB_1(source, &type, id, severity, length, buf_str_ptr);
      finally
        Marshal.FreeHGlobal(buf_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageInsertARB(source: DebugSource; &type: DebugType; id: UInt32; severity: DebugSeverity; length: Int32; buf: IntPtr) :=
    z_DebugMessageInsertARB_1(source, &type, id, severity, length, buf);
    
    private z_DebugMessageCallbackARB_adr := GetProcAddress('glDebugMessageCallbackARB');
    private z_DebugMessageCallbackARB_1 := GetProcOrNil&<procedure(callback: GL_DEBUG_PROC; userParam: IntPtr)>(z_DebugMessageCallbackARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageCallbackARB(callback: GL_DEBUG_PROC; userParam: IntPtr) :=
    z_DebugMessageCallbackARB_1(callback, userParam);
    
    private z_GetDebugMessageLogARB_adr := GetProcAddress('glGetDebugMessageLogARB');
    private z_GetDebugMessageLogARB_1 := GetProcOrNil&<function(count: UInt32; bufSize: Int32; sources: IntPtr; types: IntPtr; ids: IntPtr; severities: IntPtr; lengths: IntPtr; messageLog: IntPtr): UInt32>(z_GetDebugMessageLogARB_adr);
    private z_GetDebugMessageLogARB_2 := GetProcOrNil&<function(count: UInt32; bufSize: Int32; var sources: DebugSource; var types: DebugType; var ids: UInt32; var severities: DebugSeverity; var lengths: Int32; messageLog: IntPtr): UInt32>(z_GetDebugMessageLogARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDebugMessageLogARB(count: UInt32; bufSize: Int32; var sources: DebugSource; var types: DebugType; var ids: UInt32; var severities: DebugSeverity; var lengths: Int32; messageLog: IntPtr): UInt32 :=
    z_GetDebugMessageLogARB_2(count, bufSize, sources, types, ids, severities, lengths, messageLog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDebugMessageLogARB(count: UInt32; bufSize: Int32; sources: IntPtr; types: IntPtr; ids: IntPtr; severities: IntPtr; lengths: IntPtr; messageLog: IntPtr): UInt32 :=
    z_GetDebugMessageLogARB_1(count, bufSize, sources, types, ids, severities, lengths, messageLog);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glDirectStateAccessARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_direct_state_access';
    
    private z_CreateTransformFeedbacks_adr := GetProcAddress('glCreateTransformFeedbacks');
    private z_CreateTransformFeedbacks_1 := GetProcOrNil&<procedure(n: Int32; ids: IntPtr)>(z_CreateTransformFeedbacks_adr);
    private z_CreateTransformFeedbacks_2 := GetProcOrNil&<procedure(n: Int32; var ids: gl_transform_feedback)>(z_CreateTransformFeedbacks_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateTransformFeedbacks(n: Int32; ids: array of gl_transform_feedback);
    type Pgl_transform_feedback=^gl_transform_feedback;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        z_CreateTransformFeedbacks_2(n, ids[0]) else
        z_CreateTransformFeedbacks_2(n, Pgl_transform_feedback(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateTransformFeedbacks(n: Int32; var ids: gl_transform_feedback) :=
    z_CreateTransformFeedbacks_2(n, ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateTransformFeedbacks(n: Int32; ids: IntPtr) :=
    z_CreateTransformFeedbacks_1(n, ids);
    
    private z_TransformFeedbackBufferBase_adr := GetProcAddress('glTransformFeedbackBufferBase');
    private z_TransformFeedbackBufferBase_1 := GetProcOrNil&<procedure(xfb: gl_transform_feedback; index: UInt32; buffer: gl_buffer)>(z_TransformFeedbackBufferBase_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackBufferBase(xfb: gl_transform_feedback; index: UInt32; buffer: gl_buffer) :=
    z_TransformFeedbackBufferBase_1(xfb, index, buffer);
    
    private z_TransformFeedbackBufferRange_adr := GetProcAddress('glTransformFeedbackBufferRange');
    private z_TransformFeedbackBufferRange_1 := GetProcOrNil&<procedure(xfb: gl_transform_feedback; index: UInt32; buffer: gl_buffer; offset: IntPtr; size: UIntPtr)>(z_TransformFeedbackBufferRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackBufferRange(xfb: gl_transform_feedback; index: UInt32; buffer: gl_buffer; offset: IntPtr; size: UIntPtr) :=
    z_TransformFeedbackBufferRange_1(xfb, index, buffer, offset, size);
    
    private z_GetTransformFeedbackiv_adr := GetProcAddress('glGetTransformFeedbackiv');
    private z_GetTransformFeedbackiv_1 := GetProcOrNil&<procedure(xfb: gl_transform_feedback; pname: TransformFeedbackPName; param: IntPtr)>(z_GetTransformFeedbackiv_adr);
    private z_GetTransformFeedbackiv_2 := GetProcOrNil&<procedure(xfb: gl_transform_feedback; pname: TransformFeedbackPName; var param: Int32)>(z_GetTransformFeedbackiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackiv(xfb: gl_transform_feedback; pname: TransformFeedbackPName; var param: Int32) :=
    z_GetTransformFeedbackiv_2(xfb, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackiv(xfb: gl_transform_feedback; pname: TransformFeedbackPName; param: IntPtr) :=
    z_GetTransformFeedbackiv_1(xfb, pname, param);
    
    private z_GetTransformFeedbacki_v_adr := GetProcAddress('glGetTransformFeedbacki_v');
    private z_GetTransformFeedbacki_v_1 := GetProcOrNil&<procedure(xfb: gl_transform_feedback; pname: TransformFeedbackPName; index: UInt32; param: IntPtr)>(z_GetTransformFeedbacki_v_adr);
    private z_GetTransformFeedbacki_v_2 := GetProcOrNil&<procedure(xfb: gl_transform_feedback; pname: TransformFeedbackPName; index: UInt32; var param: Int32)>(z_GetTransformFeedbacki_v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbacki_v(xfb: gl_transform_feedback; pname: TransformFeedbackPName; index: UInt32; var param: Int32) :=
    z_GetTransformFeedbacki_v_2(xfb, pname, index, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbacki_v(xfb: gl_transform_feedback; pname: TransformFeedbackPName; index: UInt32; param: IntPtr) :=
    z_GetTransformFeedbacki_v_1(xfb, pname, index, param);
    
    private z_GetTransformFeedbacki64_v_adr := GetProcAddress('glGetTransformFeedbacki64_v');
    private z_GetTransformFeedbacki64_v_1 := GetProcOrNil&<procedure(xfb: gl_transform_feedback; pname: TransformFeedbackPName; index: UInt32; param: IntPtr)>(z_GetTransformFeedbacki64_v_adr);
    private z_GetTransformFeedbacki64_v_2 := GetProcOrNil&<procedure(xfb: gl_transform_feedback; pname: TransformFeedbackPName; index: UInt32; var param: Int64)>(z_GetTransformFeedbacki64_v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbacki64_v(xfb: gl_transform_feedback; pname: TransformFeedbackPName; index: UInt32; var param: Int64) :=
    z_GetTransformFeedbacki64_v_2(xfb, pname, index, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbacki64_v(xfb: gl_transform_feedback; pname: TransformFeedbackPName; index: UInt32; param: IntPtr) :=
    z_GetTransformFeedbacki64_v_1(xfb, pname, index, param);
    
    private z_CreateBuffers_adr := GetProcAddress('glCreateBuffers');
    private z_CreateBuffers_1 := GetProcOrNil&<procedure(n: Int32; buffers: IntPtr)>(z_CreateBuffers_adr);
    private z_CreateBuffers_2 := GetProcOrNil&<procedure(n: Int32; var buffers: gl_buffer)>(z_CreateBuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateBuffers(n: Int32; buffers: array of gl_buffer);
    type Pgl_buffer=^gl_buffer;
    begin
      if (buffers<>nil) and (buffers.Length<>0) then
        z_CreateBuffers_2(n, buffers[0]) else
        z_CreateBuffers_2(n, Pgl_buffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateBuffers(n: Int32; var buffers: gl_buffer) :=
    z_CreateBuffers_2(n, buffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateBuffers(n: Int32; buffers: IntPtr) :=
    z_CreateBuffers_1(n, buffers);
    
    private z_NamedBufferStorage_adr := GetProcAddress('glNamedBufferStorage');
    private z_NamedBufferStorage_1 := GetProcOrNil&<procedure(buffer: gl_buffer; size: UIntPtr; data: pointer; flags: BufferStorageMask)>(z_NamedBufferStorage_adr);
    private z_NamedBufferStorage_2 := GetProcOrNil&<procedure(buffer: gl_buffer; size: UIntPtr; var data: Byte; flags: BufferStorageMask)>(z_NamedBufferStorage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferStorage<T>(buffer: gl_buffer; size: UIntPtr; data: array of T; flags: BufferStorageMask); where T: record;
    type PT=^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        NamedBufferStorage(buffer, size, data[0], flags) else
        NamedBufferStorage(buffer, size, PT(nil)^, flags);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferStorage<T>(buffer: gl_buffer; size: UIntPtr; var data: T; flags: BufferStorageMask); where T: record;
    begin
      z_NamedBufferStorage_2(buffer, size, PByte(pointer(@data))^, flags);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferStorage(buffer: gl_buffer; size: UIntPtr; data: pointer; flags: BufferStorageMask) :=
    z_NamedBufferStorage_1(buffer, size, data, flags);
    
    private z_NamedBufferData_adr := GetProcAddress('glNamedBufferData');
    private z_NamedBufferData_1 := GetProcOrNil&<procedure(buffer: gl_buffer; size: UIntPtr; data: pointer; usage: VertexBufferObjectUsage)>(z_NamedBufferData_adr);
    private z_NamedBufferData_2 := GetProcOrNil&<procedure(buffer: gl_buffer; size: UIntPtr; var data: Byte; usage: VertexBufferObjectUsage)>(z_NamedBufferData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferData<T>(buffer: gl_buffer; size: UIntPtr; data: array of T; usage: VertexBufferObjectUsage); where T: record;
    type PT=^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        NamedBufferData(buffer, size, data[0], usage) else
        NamedBufferData(buffer, size, PT(nil)^, usage);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferData<T>(buffer: gl_buffer; size: UIntPtr; var data: T; usage: VertexBufferObjectUsage); where T: record;
    begin
      z_NamedBufferData_2(buffer, size, PByte(pointer(@data))^, usage);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferData(buffer: gl_buffer; size: UIntPtr; data: pointer; usage: VertexBufferObjectUsage) :=
    z_NamedBufferData_1(buffer, size, data, usage);
    
    private z_NamedBufferSubData_adr := GetProcAddress('glNamedBufferSubData');
    private z_NamedBufferSubData_1 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: pointer)>(z_NamedBufferSubData_adr);
    private z_NamedBufferSubData_2 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; var data: Byte)>(z_NamedBufferSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferSubData<T>(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: array of T); where T: record;
    type PT=^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        NamedBufferSubData(buffer, offset, size, data[0]) else
        NamedBufferSubData(buffer, offset, size, PT(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferSubData<T>(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; var data: T); where T: record;
    begin
      z_NamedBufferSubData_2(buffer, offset, size, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferSubData(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: pointer) :=
    z_NamedBufferSubData_1(buffer, offset, size, data);
    
    private z_CopyNamedBufferSubData_adr := GetProcAddress('glCopyNamedBufferSubData');
    private z_CopyNamedBufferSubData_1 := GetProcOrNil&<procedure(readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr)>(z_CopyNamedBufferSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyNamedBufferSubData(readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr) :=
    z_CopyNamedBufferSubData_1(readBuffer, writeBuffer, readOffset, writeOffset, size);
    
    private z_ClearNamedBufferData_adr := GetProcAddress('glClearNamedBufferData');
    private z_ClearNamedBufferData_1 := GetProcOrNil&<procedure(buffer: gl_buffer; internalformat: SizedInternalFormat; format: PixelFormat; &type: PixelType; data: pointer)>(z_ClearNamedBufferData_adr);
    private z_ClearNamedBufferData_2 := GetProcOrNil&<procedure(buffer: gl_buffer; internalformat: SizedInternalFormat; format: PixelFormat; &type: PixelType; var data: Byte)>(z_ClearNamedBufferData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferData<T>(buffer: gl_buffer; internalformat: SizedInternalFormat; format: PixelFormat; &type: PixelType; data: array of T); where T: record;
    type PT=^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        ClearNamedBufferData(buffer, internalformat, format, &type, data[0]) else
        ClearNamedBufferData(buffer, internalformat, format, &type, PT(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferData<T>(buffer: gl_buffer; internalformat: SizedInternalFormat; format: PixelFormat; &type: PixelType; var data: T); where T: record;
    begin
      z_ClearNamedBufferData_2(buffer, internalformat, format, &type, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferData(buffer: gl_buffer; internalformat: SizedInternalFormat; format: PixelFormat; &type: PixelType; data: pointer) :=
    z_ClearNamedBufferData_1(buffer, internalformat, format, &type, data);
    
    private z_ClearNamedBufferSubData_adr := GetProcAddress('glClearNamedBufferSubData');
    private z_ClearNamedBufferSubData_1 := GetProcOrNil&<procedure(buffer: gl_buffer; internalformat: SizedInternalFormat; offset: IntPtr; size: UIntPtr; format: PixelFormat; &type: PixelType; data: pointer)>(z_ClearNamedBufferSubData_adr);
    private z_ClearNamedBufferSubData_2 := GetProcOrNil&<procedure(buffer: gl_buffer; internalformat: SizedInternalFormat; offset: IntPtr; size: UIntPtr; format: PixelFormat; &type: PixelType; var data: Byte)>(z_ClearNamedBufferSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferSubData<T>(buffer: gl_buffer; internalformat: SizedInternalFormat; offset: IntPtr; size: UIntPtr; format: PixelFormat; &type: PixelType; data: array of T); where T: record;
    type PT=^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        ClearNamedBufferSubData(buffer, internalformat, offset, size, format, &type, data[0]) else
        ClearNamedBufferSubData(buffer, internalformat, offset, size, format, &type, PT(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferSubData<T>(buffer: gl_buffer; internalformat: SizedInternalFormat; offset: IntPtr; size: UIntPtr; format: PixelFormat; &type: PixelType; var data: T); where T: record;
    begin
      z_ClearNamedBufferSubData_2(buffer, internalformat, offset, size, format, &type, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferSubData(buffer: gl_buffer; internalformat: SizedInternalFormat; offset: IntPtr; size: UIntPtr; format: PixelFormat; &type: PixelType; data: pointer) :=
    z_ClearNamedBufferSubData_1(buffer, internalformat, offset, size, format, &type, data);
    
    private z_MapNamedBuffer_adr := GetProcAddress('glMapNamedBuffer');
    private z_MapNamedBuffer_1 := GetProcOrNil&<function(buffer: gl_buffer; access: BufferAccess): IntPtr>(z_MapNamedBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapNamedBuffer(buffer: gl_buffer; access: BufferAccess): IntPtr :=
    z_MapNamedBuffer_1(buffer, access);
    
    private z_MapNamedBufferRange_adr := GetProcAddress('glMapNamedBufferRange');
    private z_MapNamedBufferRange_1 := GetProcOrNil&<function(buffer: gl_buffer; offset: IntPtr; length: UIntPtr; access: MapBufferAccessMask): IntPtr>(z_MapNamedBufferRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapNamedBufferRange(buffer: gl_buffer; offset: IntPtr; length: UIntPtr; access: MapBufferAccessMask): IntPtr :=
    z_MapNamedBufferRange_1(buffer, offset, length, access);
    
    private z_UnmapNamedBuffer_adr := GetProcAddress('glUnmapNamedBuffer');
    private z_UnmapNamedBuffer_1 := GetProcOrNil&<function(buffer: gl_buffer): boolean>(z_UnmapNamedBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function UnmapNamedBuffer(buffer: gl_buffer): boolean :=
    z_UnmapNamedBuffer_1(buffer);
    
    private z_FlushMappedNamedBufferRange_adr := GetProcAddress('glFlushMappedNamedBufferRange');
    private z_FlushMappedNamedBufferRange_1 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; length: UIntPtr)>(z_FlushMappedNamedBufferRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FlushMappedNamedBufferRange(buffer: gl_buffer; offset: IntPtr; length: UIntPtr) :=
    z_FlushMappedNamedBufferRange_1(buffer, offset, length);
    
    private z_GetNamedBufferParameteriv_adr := GetProcAddress('glGetNamedBufferParameteriv');
    private z_GetNamedBufferParameteriv_1 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: BufferPName; &params: IntPtr)>(z_GetNamedBufferParameteriv_adr);
    private z_GetNamedBufferParameteriv_2 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: BufferPName; var &params: Int32)>(z_GetNamedBufferParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameteriv(buffer: gl_buffer; pname: BufferPName; var &params: Int32) :=
    z_GetNamedBufferParameteriv_2(buffer, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameteriv(buffer: gl_buffer; pname: BufferPName; &params: IntPtr) :=
    z_GetNamedBufferParameteriv_1(buffer, pname, &params);
    
    private z_GetNamedBufferParameteri64v_adr := GetProcAddress('glGetNamedBufferParameteri64v');
    private z_GetNamedBufferParameteri64v_1 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: BufferPName; &params: IntPtr)>(z_GetNamedBufferParameteri64v_adr);
    private z_GetNamedBufferParameteri64v_2 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: BufferPName; var &params: Int64)>(z_GetNamedBufferParameteri64v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameteri64v(buffer: gl_buffer; pname: BufferPName; var &params: Int64) :=
    z_GetNamedBufferParameteri64v_2(buffer, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameteri64v(buffer: gl_buffer; pname: BufferPName; &params: IntPtr) :=
    z_GetNamedBufferParameteri64v_1(buffer, pname, &params);
    
    private z_GetNamedBufferPointerv_adr := GetProcAddress('glGetNamedBufferPointerv');
    private z_GetNamedBufferPointerv_1 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: BufferPointerName; &params: pointer)>(z_GetNamedBufferPointerv_adr);
    private z_GetNamedBufferPointerv_2 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: BufferPointerName; var &params: IntPtr)>(z_GetNamedBufferPointerv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferPointerv(buffer: gl_buffer; pname: BufferPointerName; var &params: IntPtr) :=
    z_GetNamedBufferPointerv_2(buffer, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferPointerv(buffer: gl_buffer; pname: BufferPointerName; &params: pointer) :=
    z_GetNamedBufferPointerv_1(buffer, pname, &params);
    
    private z_GetNamedBufferSubData_adr := GetProcAddress('glGetNamedBufferSubData');
    private z_GetNamedBufferSubData_1 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: pointer)>(z_GetNamedBufferSubData_adr);
    private z_GetNamedBufferSubData_2 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; var data: Byte)>(z_GetNamedBufferSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferSubData<T>(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; var data: T); where T: record;
    begin
      z_GetNamedBufferSubData_2(buffer, offset, size, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferSubData(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: pointer) :=
    z_GetNamedBufferSubData_1(buffer, offset, size, data);
    
    private z_CreateFramebuffers_adr := GetProcAddress('glCreateFramebuffers');
    private z_CreateFramebuffers_1 := GetProcOrNil&<procedure(n: Int32; framebuffers: IntPtr)>(z_CreateFramebuffers_adr);
    private z_CreateFramebuffers_2 := GetProcOrNil&<procedure(n: Int32; var framebuffers: gl_framebuffer)>(z_CreateFramebuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateFramebuffers(n: Int32; framebuffers: array of gl_framebuffer);
    type Pgl_framebuffer=^gl_framebuffer;
    begin
      if (framebuffers<>nil) and (framebuffers.Length<>0) then
        z_CreateFramebuffers_2(n, framebuffers[0]) else
        z_CreateFramebuffers_2(n, Pgl_framebuffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateFramebuffers(n: Int32; var framebuffers: gl_framebuffer) :=
    z_CreateFramebuffers_2(n, framebuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateFramebuffers(n: Int32; framebuffers: IntPtr) :=
    z_CreateFramebuffers_1(n, framebuffers);
    
    private z_NamedFramebufferRenderbuffer_adr := GetProcAddress('glNamedFramebufferRenderbuffer');
    private z_NamedFramebufferRenderbuffer_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; _renderbuffertarget: RenderbufferTarget; renderbuffer: gl_renderbuffer)>(z_NamedFramebufferRenderbuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferRenderbuffer(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; _renderbuffertarget: RenderbufferTarget; renderbuffer: gl_renderbuffer) :=
    z_NamedFramebufferRenderbuffer_1(framebuffer, attachment, _renderbuffertarget, renderbuffer);
    
    private z_NamedFramebufferParameteri_adr := GetProcAddress('glNamedFramebufferParameteri');
    private z_NamedFramebufferParameteri_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; pname: FramebufferParameterName; param: Int32)>(z_NamedFramebufferParameteri_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferParameteri(framebuffer: gl_framebuffer; pname: FramebufferParameterName; param: Int32) :=
    z_NamedFramebufferParameteri_1(framebuffer, pname, param);
    
    private z_NamedFramebufferTexture_adr := GetProcAddress('glNamedFramebufferTexture');
    private z_NamedFramebufferTexture_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; texture: gl_texture; level: Int32)>(z_NamedFramebufferTexture_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferTexture(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; texture: gl_texture; level: Int32) :=
    z_NamedFramebufferTexture_1(framebuffer, attachment, texture, level);
    
    private z_NamedFramebufferTextureLayer_adr := GetProcAddress('glNamedFramebufferTextureLayer');
    private z_NamedFramebufferTextureLayer_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; texture: gl_texture; level: Int32; layer: Int32)>(z_NamedFramebufferTextureLayer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferTextureLayer(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; texture: gl_texture; level: Int32; layer: Int32) :=
    z_NamedFramebufferTextureLayer_1(framebuffer, attachment, texture, level, layer);
    
    private z_NamedFramebufferDrawBuffer_adr := GetProcAddress('glNamedFramebufferDrawBuffer');
    private z_NamedFramebufferDrawBuffer_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; buf: ColorBuffer)>(z_NamedFramebufferDrawBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferDrawBuffer(framebuffer: gl_framebuffer; buf: ColorBuffer) :=
    z_NamedFramebufferDrawBuffer_1(framebuffer, buf);
    
    private z_NamedFramebufferDrawBuffers_adr := GetProcAddress('glNamedFramebufferDrawBuffers');
    private z_NamedFramebufferDrawBuffers_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; n: Int32; bufs: IntPtr)>(z_NamedFramebufferDrawBuffers_adr);
    private z_NamedFramebufferDrawBuffers_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; n: Int32; var bufs: ColorBuffer)>(z_NamedFramebufferDrawBuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferDrawBuffers(framebuffer: gl_framebuffer; n: Int32; bufs: array of ColorBuffer);
    type PColorBuffer=^ColorBuffer;
    begin
      if (bufs<>nil) and (bufs.Length<>0) then
        z_NamedFramebufferDrawBuffers_2(framebuffer, n, bufs[0]) else
        z_NamedFramebufferDrawBuffers_2(framebuffer, n, PColorBuffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferDrawBuffers(framebuffer: gl_framebuffer; n: Int32; var bufs: ColorBuffer) :=
    z_NamedFramebufferDrawBuffers_2(framebuffer, n, bufs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferDrawBuffers(framebuffer: gl_framebuffer; n: Int32; bufs: IntPtr) :=
    z_NamedFramebufferDrawBuffers_1(framebuffer, n, bufs);
    
    private z_NamedFramebufferReadBuffer_adr := GetProcAddress('glNamedFramebufferReadBuffer');
    private z_NamedFramebufferReadBuffer_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; src: ColorBuffer)>(z_NamedFramebufferReadBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferReadBuffer(framebuffer: gl_framebuffer; src: ColorBuffer) :=
    z_NamedFramebufferReadBuffer_1(framebuffer, src);
    
    private z_InvalidateNamedFramebufferData_adr := GetProcAddress('glInvalidateNamedFramebufferData');
    private z_InvalidateNamedFramebufferData_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; numAttachments: Int32; attachments: IntPtr)>(z_InvalidateNamedFramebufferData_adr);
    private z_InvalidateNamedFramebufferData_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; numAttachments: Int32; var attachments: FramebufferAttachment)>(z_InvalidateNamedFramebufferData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateNamedFramebufferData(framebuffer: gl_framebuffer; numAttachments: Int32; attachments: array of FramebufferAttachment);
    type PFramebufferAttachment=^FramebufferAttachment;
    begin
      if (attachments<>nil) and (attachments.Length<>0) then
        z_InvalidateNamedFramebufferData_2(framebuffer, numAttachments, attachments[0]) else
        z_InvalidateNamedFramebufferData_2(framebuffer, numAttachments, PFramebufferAttachment(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateNamedFramebufferData(framebuffer: gl_framebuffer; numAttachments: Int32; var attachments: FramebufferAttachment) :=
    z_InvalidateNamedFramebufferData_2(framebuffer, numAttachments, attachments);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateNamedFramebufferData(framebuffer: gl_framebuffer; numAttachments: Int32; attachments: IntPtr) :=
    z_InvalidateNamedFramebufferData_1(framebuffer, numAttachments, attachments);
    
    private z_InvalidateNamedFramebufferSubData_adr := GetProcAddress('glInvalidateNamedFramebufferSubData');
    private z_InvalidateNamedFramebufferSubData_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; numAttachments: Int32; attachments: IntPtr; x: Int32; y: Int32; width: Int32; height: Int32)>(z_InvalidateNamedFramebufferSubData_adr);
    private z_InvalidateNamedFramebufferSubData_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; numAttachments: Int32; var attachments: FramebufferAttachment; x: Int32; y: Int32; width: Int32; height: Int32)>(z_InvalidateNamedFramebufferSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateNamedFramebufferSubData(framebuffer: gl_framebuffer; numAttachments: Int32; attachments: array of FramebufferAttachment; x: Int32; y: Int32; width: Int32; height: Int32);
    type PFramebufferAttachment=^FramebufferAttachment;
    begin
      if (attachments<>nil) and (attachments.Length<>0) then
        z_InvalidateNamedFramebufferSubData_2(framebuffer, numAttachments, attachments[0], x, y, width, height) else
        z_InvalidateNamedFramebufferSubData_2(framebuffer, numAttachments, PFramebufferAttachment(nil)^, x, y, width, height);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateNamedFramebufferSubData(framebuffer: gl_framebuffer; numAttachments: Int32; var attachments: FramebufferAttachment; x: Int32; y: Int32; width: Int32; height: Int32) :=
    z_InvalidateNamedFramebufferSubData_2(framebuffer, numAttachments, attachments, x, y, width, height);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateNamedFramebufferSubData(framebuffer: gl_framebuffer; numAttachments: Int32; attachments: IntPtr; x: Int32; y: Int32; width: Int32; height: Int32) :=
    z_InvalidateNamedFramebufferSubData_1(framebuffer, numAttachments, attachments, x, y, width, height);
    
    private z_ClearNamedFramebufferiv_adr := GetProcAddress('glClearNamedFramebufferiv');
    private z_ClearNamedFramebufferiv_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; _buffer: Buffer; drawbuffer: Int32; value: IntPtr)>(z_ClearNamedFramebufferiv_adr);
    private z_ClearNamedFramebufferiv_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; _buffer: Buffer; drawbuffer: Int32; var value: Int32)>(z_ClearNamedFramebufferiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferiv(framebuffer: gl_framebuffer; _buffer: Buffer; drawbuffer: Int32; value: array of Int32);
    type PInt32=^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ClearNamedFramebufferiv_2(framebuffer, _buffer, drawbuffer, value[0]) else
        z_ClearNamedFramebufferiv_2(framebuffer, _buffer, drawbuffer, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferiv(framebuffer: gl_framebuffer; _buffer: Buffer; drawbuffer: Int32; var value: Int32) :=
    z_ClearNamedFramebufferiv_2(framebuffer, _buffer, drawbuffer, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferiv(framebuffer: gl_framebuffer; _buffer: Buffer; drawbuffer: Int32; value: IntPtr) :=
    z_ClearNamedFramebufferiv_1(framebuffer, _buffer, drawbuffer, value);
    
    private z_ClearNamedFramebufferuiv_adr := GetProcAddress('glClearNamedFramebufferuiv');
    private z_ClearNamedFramebufferuiv_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; _buffer: Buffer; drawbuffer: Int32; value: IntPtr)>(z_ClearNamedFramebufferuiv_adr);
    private z_ClearNamedFramebufferuiv_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; _buffer: Buffer; drawbuffer: Int32; var value: UInt32)>(z_ClearNamedFramebufferuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferuiv(framebuffer: gl_framebuffer; _buffer: Buffer; drawbuffer: Int32; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ClearNamedFramebufferuiv_2(framebuffer, _buffer, drawbuffer, value[0]) else
        z_ClearNamedFramebufferuiv_2(framebuffer, _buffer, drawbuffer, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferuiv(framebuffer: gl_framebuffer; _buffer: Buffer; drawbuffer: Int32; var value: UInt32) :=
    z_ClearNamedFramebufferuiv_2(framebuffer, _buffer, drawbuffer, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferuiv(framebuffer: gl_framebuffer; _buffer: Buffer; drawbuffer: Int32; value: IntPtr) :=
    z_ClearNamedFramebufferuiv_1(framebuffer, _buffer, drawbuffer, value);
    
    private z_ClearNamedFramebufferfv_adr := GetProcAddress('glClearNamedFramebufferfv');
    private z_ClearNamedFramebufferfv_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; _buffer: Buffer; drawbuffer: Int32; value: IntPtr)>(z_ClearNamedFramebufferfv_adr);
    private z_ClearNamedFramebufferfv_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; _buffer: Buffer; drawbuffer: Int32; var value: single)>(z_ClearNamedFramebufferfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferfv(framebuffer: gl_framebuffer; _buffer: Buffer; drawbuffer: Int32; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ClearNamedFramebufferfv_2(framebuffer, _buffer, drawbuffer, value[0]) else
        z_ClearNamedFramebufferfv_2(framebuffer, _buffer, drawbuffer, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferfv(framebuffer: gl_framebuffer; _buffer: Buffer; drawbuffer: Int32; var value: single) :=
    z_ClearNamedFramebufferfv_2(framebuffer, _buffer, drawbuffer, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferfv(framebuffer: gl_framebuffer; _buffer: Buffer; drawbuffer: Int32; value: IntPtr) :=
    z_ClearNamedFramebufferfv_1(framebuffer, _buffer, drawbuffer, value);
    
    private z_ClearNamedFramebufferfi_adr := GetProcAddress('glClearNamedFramebufferfi');
    private z_ClearNamedFramebufferfi_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; _buffer: Buffer; drawbuffer: Int32; depth: single; stencil: Int32)>(z_ClearNamedFramebufferfi_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferfi(framebuffer: gl_framebuffer; _buffer: Buffer; drawbuffer: Int32; depth: single; stencil: Int32) :=
    z_ClearNamedFramebufferfi_1(framebuffer, _buffer, drawbuffer, depth, stencil);
    
    private z_BlitNamedFramebuffer_adr := GetProcAddress('glBlitNamedFramebuffer');
    private z_BlitNamedFramebuffer_1 := GetProcOrNil&<procedure(readFramebuffer: gl_framebuffer; drawFramebuffer: gl_framebuffer; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: ClearBufferMask; filter: BlitFramebufferFilter)>(z_BlitNamedFramebuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlitNamedFramebuffer(readFramebuffer: gl_framebuffer; drawFramebuffer: gl_framebuffer; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: ClearBufferMask; filter: BlitFramebufferFilter) :=
    z_BlitNamedFramebuffer_1(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    
    private z_CheckNamedFramebufferStatus_adr := GetProcAddress('glCheckNamedFramebufferStatus');
    private z_CheckNamedFramebufferStatus_1 := GetProcOrNil&<function(framebuffer: gl_framebuffer; target: FramebufferTarget): FramebufferStatus>(z_CheckNamedFramebufferStatus_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CheckNamedFramebufferStatus(framebuffer: gl_framebuffer; target: FramebufferTarget): FramebufferStatus :=
    z_CheckNamedFramebufferStatus_1(framebuffer, target);
    
    private z_GetNamedFramebufferParameteriv_adr := GetProcAddress('glGetNamedFramebufferParameteriv');
    private z_GetNamedFramebufferParameteriv_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; pname: GetFramebufferParameter; param: IntPtr)>(z_GetNamedFramebufferParameteriv_adr);
    private z_GetNamedFramebufferParameteriv_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; pname: GetFramebufferParameter; var param: Int32)>(z_GetNamedFramebufferParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferParameteriv(framebuffer: gl_framebuffer; pname: GetFramebufferParameter; var param: Int32) :=
    z_GetNamedFramebufferParameteriv_2(framebuffer, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferParameteriv(framebuffer: gl_framebuffer; pname: GetFramebufferParameter; param: IntPtr) :=
    z_GetNamedFramebufferParameteriv_1(framebuffer, pname, param);
    
    private z_GetNamedFramebufferAttachmentParameteriv_adr := GetProcAddress('glGetNamedFramebufferAttachmentParameteriv');
    private z_GetNamedFramebufferAttachmentParameteriv_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; pname: FramebufferAttachmentParameterName; &params: IntPtr)>(z_GetNamedFramebufferAttachmentParameteriv_adr);
    private z_GetNamedFramebufferAttachmentParameteriv_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; pname: FramebufferAttachmentParameterName; var &params: Int32)>(z_GetNamedFramebufferAttachmentParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferAttachmentParameteriv(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; pname: FramebufferAttachmentParameterName; var &params: Int32) :=
    z_GetNamedFramebufferAttachmentParameteriv_2(framebuffer, attachment, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferAttachmentParameteriv(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; pname: FramebufferAttachmentParameterName; &params: IntPtr) :=
    z_GetNamedFramebufferAttachmentParameteriv_1(framebuffer, attachment, pname, &params);
    
    private z_CreateRenderbuffers_adr := GetProcAddress('glCreateRenderbuffers');
    private z_CreateRenderbuffers_1 := GetProcOrNil&<procedure(n: Int32; renderbuffers: IntPtr)>(z_CreateRenderbuffers_adr);
    private z_CreateRenderbuffers_2 := GetProcOrNil&<procedure(n: Int32; var renderbuffers: gl_renderbuffer)>(z_CreateRenderbuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateRenderbuffers(n: Int32; renderbuffers: array of gl_renderbuffer);
    type Pgl_renderbuffer=^gl_renderbuffer;
    begin
      if (renderbuffers<>nil) and (renderbuffers.Length<>0) then
        z_CreateRenderbuffers_2(n, renderbuffers[0]) else
        z_CreateRenderbuffers_2(n, Pgl_renderbuffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateRenderbuffers(n: Int32; var renderbuffers: gl_renderbuffer) :=
    z_CreateRenderbuffers_2(n, renderbuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateRenderbuffers(n: Int32; renderbuffers: IntPtr) :=
    z_CreateRenderbuffers_1(n, renderbuffers);
    
    private z_NamedRenderbufferStorage_adr := GetProcAddress('glNamedRenderbufferStorage');
    private z_NamedRenderbufferStorage_1 := GetProcOrNil&<procedure(renderbuffer: gl_renderbuffer; _internalformat: InternalFormat; width: Int32; height: Int32)>(z_NamedRenderbufferStorage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedRenderbufferStorage(renderbuffer: gl_renderbuffer; _internalformat: InternalFormat; width: Int32; height: Int32) :=
    z_NamedRenderbufferStorage_1(renderbuffer, _internalformat, width, height);
    
    private z_NamedRenderbufferStorageMultisample_adr := GetProcAddress('glNamedRenderbufferStorageMultisample');
    private z_NamedRenderbufferStorageMultisample_1 := GetProcOrNil&<procedure(renderbuffer: gl_renderbuffer; samples: Int32; _internalformat: InternalFormat; width: Int32; height: Int32)>(z_NamedRenderbufferStorageMultisample_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedRenderbufferStorageMultisample(renderbuffer: gl_renderbuffer; samples: Int32; _internalformat: InternalFormat; width: Int32; height: Int32) :=
    z_NamedRenderbufferStorageMultisample_1(renderbuffer, samples, _internalformat, width, height);
    
    private z_GetNamedRenderbufferParameteriv_adr := GetProcAddress('glGetNamedRenderbufferParameteriv');
    private z_GetNamedRenderbufferParameteriv_1 := GetProcOrNil&<procedure(renderbuffer: gl_renderbuffer; pname: RenderbufferParameterName; &params: IntPtr)>(z_GetNamedRenderbufferParameteriv_adr);
    private z_GetNamedRenderbufferParameteriv_2 := GetProcOrNil&<procedure(renderbuffer: gl_renderbuffer; pname: RenderbufferParameterName; var &params: Int32)>(z_GetNamedRenderbufferParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedRenderbufferParameteriv(renderbuffer: gl_renderbuffer; pname: RenderbufferParameterName; var &params: Int32) :=
    z_GetNamedRenderbufferParameteriv_2(renderbuffer, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedRenderbufferParameteriv(renderbuffer: gl_renderbuffer; pname: RenderbufferParameterName; &params: IntPtr) :=
    z_GetNamedRenderbufferParameteriv_1(renderbuffer, pname, &params);
    
    private z_CreateTextures_adr := GetProcAddress('glCreateTextures');
    private z_CreateTextures_1 := GetProcOrNil&<procedure(target: TextureTarget; n: Int32; textures: IntPtr)>(z_CreateTextures_adr);
    private z_CreateTextures_2 := GetProcOrNil&<procedure(target: TextureTarget; n: Int32; var textures: gl_texture)>(z_CreateTextures_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateTextures(target: TextureTarget; n: Int32; textures: array of gl_texture);
    type Pgl_texture=^gl_texture;
    begin
      if (textures<>nil) and (textures.Length<>0) then
        z_CreateTextures_2(target, n, textures[0]) else
        z_CreateTextures_2(target, n, Pgl_texture(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateTextures(target: TextureTarget; n: Int32; var textures: gl_texture) :=
    z_CreateTextures_2(target, n, textures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateTextures(target: TextureTarget; n: Int32; textures: IntPtr) :=
    z_CreateTextures_1(target, n, textures);
    
    private z_TextureBuffer_adr := GetProcAddress('glTextureBuffer');
    private z_TextureBuffer_1 := GetProcOrNil&<procedure(texture: gl_texture; internalformat: SizedInternalFormat; buffer: gl_buffer)>(z_TextureBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureBuffer(texture: gl_texture; internalformat: SizedInternalFormat; buffer: gl_buffer) :=
    z_TextureBuffer_1(texture, internalformat, buffer);
    
    private z_TextureBufferRange_adr := GetProcAddress('glTextureBufferRange');
    private z_TextureBufferRange_1 := GetProcOrNil&<procedure(texture: gl_texture; internalformat: SizedInternalFormat; buffer: gl_buffer; offset: IntPtr; size: UIntPtr)>(z_TextureBufferRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureBufferRange(texture: gl_texture; internalformat: SizedInternalFormat; buffer: gl_buffer; offset: IntPtr; size: UIntPtr) :=
    z_TextureBufferRange_1(texture, internalformat, buffer, offset, size);
    
    private z_TextureStorage1D_adr := GetProcAddress('glTextureStorage1D');
    private z_TextureStorage1D_1 := GetProcOrNil&<procedure(texture: gl_texture; levels: Int32; internalformat: SizedInternalFormat; width: Int32)>(z_TextureStorage1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage1D(texture: gl_texture; levels: Int32; internalformat: SizedInternalFormat; width: Int32) :=
    z_TextureStorage1D_1(texture, levels, internalformat, width);
    
    private z_TextureStorage2D_adr := GetProcAddress('glTextureStorage2D');
    private z_TextureStorage2D_1 := GetProcOrNil&<procedure(texture: gl_texture; levels: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32)>(z_TextureStorage2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage2D(texture: gl_texture; levels: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32) :=
    z_TextureStorage2D_1(texture, levels, internalformat, width, height);
    
    private z_TextureStorage3D_adr := GetProcAddress('glTextureStorage3D');
    private z_TextureStorage3D_1 := GetProcOrNil&<procedure(texture: gl_texture; levels: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32; depth: Int32)>(z_TextureStorage3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage3D(texture: gl_texture; levels: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32; depth: Int32) :=
    z_TextureStorage3D_1(texture, levels, internalformat, width, height, depth);
    
    private z_TextureStorage2DMultisample_adr := GetProcAddress('glTextureStorage2DMultisample');
    private z_TextureStorage2DMultisample_1 := GetProcOrNil&<procedure(texture: gl_texture; samples: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32; fixedsamplelocations: boolean)>(z_TextureStorage2DMultisample_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage2DMultisample(texture: gl_texture; samples: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32; fixedsamplelocations: boolean) :=
    z_TextureStorage2DMultisample_1(texture, samples, internalformat, width, height, fixedsamplelocations);
    
    private z_TextureStorage3DMultisample_adr := GetProcAddress('glTextureStorage3DMultisample');
    private z_TextureStorage3DMultisample_1 := GetProcOrNil&<procedure(texture: gl_texture; samples: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: boolean)>(z_TextureStorage3DMultisample_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage3DMultisample(texture: gl_texture; samples: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: boolean) :=
    z_TextureStorage3DMultisample_1(texture, samples, internalformat, width, height, depth, fixedsamplelocations);
    
    private z_TextureSubImage1D_adr := GetProcAddress('glTextureSubImage1D');
    private z_TextureSubImage1D_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; width: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr)>(z_TextureSubImage1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureSubImage1D(texture: gl_texture; level: Int32; xoffset: Int32; width: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr) :=
    z_TextureSubImage1D_1(texture, level, xoffset, width, format, &type, pixels);
    
    private z_TextureSubImage2D_adr := GetProcAddress('glTextureSubImage2D');
    private z_TextureSubImage2D_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr)>(z_TextureSubImage2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureSubImage2D(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr) :=
    z_TextureSubImage2D_1(texture, level, xoffset, yoffset, width, height, format, &type, pixels);
    
    private z_TextureSubImage3D_adr := GetProcAddress('glTextureSubImage3D');
    private z_TextureSubImage3D_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr)>(z_TextureSubImage3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureSubImage3D(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr) :=
    z_TextureSubImage3D_1(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, pixels);
    
    private z_CompressedTextureSubImage1D_adr := GetProcAddress('glCompressedTextureSubImage1D');
    private z_CompressedTextureSubImage1D_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; width: Int32; format: InternalFormat; imageSize: Int32; data: IntPtr)>(z_CompressedTextureSubImage1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureSubImage1D(texture: gl_texture; level: Int32; xoffset: Int32; width: Int32; format: InternalFormat; imageSize: Int32; data: IntPtr) :=
    z_CompressedTextureSubImage1D_1(texture, level, xoffset, width, format, imageSize, data);
    
    private z_CompressedTextureSubImage2D_adr := GetProcAddress('glCompressedTextureSubImage2D');
    private z_CompressedTextureSubImage2D_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: InternalFormat; imageSize: Int32; data: IntPtr)>(z_CompressedTextureSubImage2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureSubImage2D(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: InternalFormat; imageSize: Int32; data: IntPtr) :=
    z_CompressedTextureSubImage2D_1(texture, level, xoffset, yoffset, width, height, format, imageSize, data);
    
    private z_CompressedTextureSubImage3D_adr := GetProcAddress('glCompressedTextureSubImage3D');
    private z_CompressedTextureSubImage3D_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: InternalFormat; imageSize: Int32; data: IntPtr)>(z_CompressedTextureSubImage3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureSubImage3D(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: InternalFormat; imageSize: Int32; data: IntPtr) :=
    z_CompressedTextureSubImage3D_1(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
    
    private z_CopyTextureSubImage1D_adr := GetProcAddress('glCopyTextureSubImage1D');
    private z_CopyTextureSubImage1D_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32)>(z_CopyTextureSubImage1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTextureSubImage1D(texture: gl_texture; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32) :=
    z_CopyTextureSubImage1D_1(texture, level, xoffset, x, y, width);
    
    private z_CopyTextureSubImage2D_adr := GetProcAddress('glCopyTextureSubImage2D');
    private z_CopyTextureSubImage2D_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32)>(z_CopyTextureSubImage2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTextureSubImage2D(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) :=
    z_CopyTextureSubImage2D_1(texture, level, xoffset, yoffset, x, y, width, height);
    
    private z_CopyTextureSubImage3D_adr := GetProcAddress('glCopyTextureSubImage3D');
    private z_CopyTextureSubImage3D_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32)>(z_CopyTextureSubImage3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTextureSubImage3D(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) :=
    z_CopyTextureSubImage3D_1(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
    
    private z_TextureParameterf_adr := GetProcAddress('glTextureParameterf');
    private z_TextureParameterf_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; param: single)>(z_TextureParameterf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterf(texture: gl_texture; pname: TextureParameterName; param: single) :=
    z_TextureParameterf_1(texture, pname, param);
    
    private z_TextureParameterfv_adr := GetProcAddress('glTextureParameterfv');
    private z_TextureParameterfv_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; param: IntPtr)>(z_TextureParameterfv_adr);
    private z_TextureParameterfv_2 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; var param: single)>(z_TextureParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterfv(texture: gl_texture; pname: TextureParameterName; param: array of single);
    type Psingle=^single;
    begin
      if (param<>nil) and (param.Length<>0) then
        z_TextureParameterfv_2(texture, pname, param[0]) else
        z_TextureParameterfv_2(texture, pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterfv(texture: gl_texture; pname: TextureParameterName; var param: single) :=
    z_TextureParameterfv_2(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterfv(texture: gl_texture; pname: TextureParameterName; param: IntPtr) :=
    z_TextureParameterfv_1(texture, pname, param);
    
    private z_TextureParameteri_adr := GetProcAddress('glTextureParameteri');
    private z_TextureParameteri_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; param: Int32)>(z_TextureParameteri_adr);
    private z_TextureParameteri_2 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; param: TextureWrapMode)>(z_TextureParameteri_adr);
    private z_TextureParameteri_3 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; param: TextureSwizzle)>(z_TextureParameteri_adr);
    private z_TextureParameteri_4 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; param: TextureMinFilter)>(z_TextureParameteri_adr);
    private z_TextureParameteri_5 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; param: TextureMagFilter)>(z_TextureParameteri_adr);
    private z_TextureParameteri_6 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; param: TextureCompareMode)>(z_TextureParameteri_adr);
    private z_TextureParameteri_7 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; param: MapTextureFormat)>(z_TextureParameteri_adr);
    private z_TextureParameteri_8 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; param: FoveationConfigBit)>(z_TextureParameteri_adr);
    private z_TextureParameteri_9 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; param: DepthStencilTextureMode)>(z_TextureParameteri_adr);
    private z_TextureParameteri_10 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; param: ConvolutionBorderMode)>(z_TextureParameteri_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: TextureParameterName; param: ConvolutionBorderMode) :=
    z_TextureParameteri_10(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: TextureParameterName; param: DepthStencilTextureMode) :=
    z_TextureParameteri_9(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: TextureParameterName; param: FoveationConfigBit) :=
    z_TextureParameteri_8(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: TextureParameterName; param: MapTextureFormat) :=
    z_TextureParameteri_7(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: TextureParameterName; param: TextureCompareMode) :=
    z_TextureParameteri_6(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: TextureParameterName; param: TextureMagFilter) :=
    z_TextureParameteri_5(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: TextureParameterName; param: TextureMinFilter) :=
    z_TextureParameteri_4(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: TextureParameterName; param: TextureSwizzle) :=
    z_TextureParameteri_3(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: TextureParameterName; param: TextureWrapMode) :=
    z_TextureParameteri_2(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: gl_texture; pname: TextureParameterName; param: Int32) :=
    z_TextureParameteri_1(texture, pname, param);
    
    private z_TextureParameterIiv_adr := GetProcAddress('glTextureParameterIiv');
    private z_TextureParameterIiv_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; &params: IntPtr)>(z_TextureParameterIiv_adr);
    private z_TextureParameterIiv_2 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; var &params: Int32)>(z_TextureParameterIiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIiv(texture: gl_texture; pname: TextureParameterName; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_TextureParameterIiv_2(texture, pname, &params[0]) else
        z_TextureParameterIiv_2(texture, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIiv(texture: gl_texture; pname: TextureParameterName; var &params: Int32) :=
    z_TextureParameterIiv_2(texture, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIiv(texture: gl_texture; pname: TextureParameterName; &params: IntPtr) :=
    z_TextureParameterIiv_1(texture, pname, &params);
    
    private z_TextureParameterIuiv_adr := GetProcAddress('glTextureParameterIuiv');
    private z_TextureParameterIuiv_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; &params: IntPtr)>(z_TextureParameterIuiv_adr);
    private z_TextureParameterIuiv_2 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; var &params: UInt32)>(z_TextureParameterIuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIuiv(texture: gl_texture; pname: TextureParameterName; &params: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_TextureParameterIuiv_2(texture, pname, &params[0]) else
        z_TextureParameterIuiv_2(texture, pname, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIuiv(texture: gl_texture; pname: TextureParameterName; var &params: UInt32) :=
    z_TextureParameterIuiv_2(texture, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIuiv(texture: gl_texture; pname: TextureParameterName; &params: IntPtr) :=
    z_TextureParameterIuiv_1(texture, pname, &params);
    
    private z_TextureParameteriv_adr := GetProcAddress('glTextureParameteriv');
    private z_TextureParameteriv_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; param: IntPtr)>(z_TextureParameteriv_adr);
    private z_TextureParameteriv_2 := GetProcOrNil&<procedure(texture: gl_texture; pname: TextureParameterName; var param: Int32)>(z_TextureParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriv(texture: gl_texture; pname: TextureParameterName; param: array of Int32);
    type PInt32=^Int32;
    begin
      if (param<>nil) and (param.Length<>0) then
        z_TextureParameteriv_2(texture, pname, param[0]) else
        z_TextureParameteriv_2(texture, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriv(texture: gl_texture; pname: TextureParameterName; var param: Int32) :=
    z_TextureParameteriv_2(texture, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriv(texture: gl_texture; pname: TextureParameterName; param: IntPtr) :=
    z_TextureParameteriv_1(texture, pname, param);
    
    private z_GenerateTextureMipmap_adr := GetProcAddress('glGenerateTextureMipmap');
    private z_GenerateTextureMipmap_1 := GetProcOrNil&<procedure(texture: gl_texture)>(z_GenerateTextureMipmap_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenerateTextureMipmap(texture: gl_texture) :=
    z_GenerateTextureMipmap_1(texture);
    
    private z_BindTextureUnit_adr := GetProcAddress('glBindTextureUnit');
    private z_BindTextureUnit_1 := GetProcOrNil&<procedure(&unit: UInt32; texture: gl_texture)>(z_BindTextureUnit_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTextureUnit(&unit: UInt32; texture: gl_texture) :=
    z_BindTextureUnit_1(&unit, texture);
    
    private z_GetTextureImage_adr := GetProcAddress('glGetTextureImage');
    private z_GetTextureImage_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; format: PixelFormat; &type: PixelType; bufSize: Int32; pixels: IntPtr)>(z_GetTextureImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureImage(texture: gl_texture; level: Int32; format: PixelFormat; &type: PixelType; bufSize: Int32; pixels: IntPtr) :=
    z_GetTextureImage_1(texture, level, format, &type, bufSize, pixels);
    
    private z_GetCompressedTextureImage_adr := GetProcAddress('glGetCompressedTextureImage');
    private z_GetCompressedTextureImage_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; bufSize: Int32; pixels: IntPtr)>(z_GetCompressedTextureImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCompressedTextureImage(texture: gl_texture; level: Int32; bufSize: Int32; pixels: IntPtr) :=
    z_GetCompressedTextureImage_1(texture, level, bufSize, pixels);
    
    private z_GetTextureLevelParameterfv_adr := GetProcAddress('glGetTextureLevelParameterfv');
    private z_GetTextureLevelParameterfv_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; pname: GetTextureParameter; &params: IntPtr)>(z_GetTextureLevelParameterfv_adr);
    private z_GetTextureLevelParameterfv_2 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; pname: GetTextureParameter; var &params: single)>(z_GetTextureLevelParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureLevelParameterfv(texture: gl_texture; level: Int32; pname: GetTextureParameter; var &params: single) :=
    z_GetTextureLevelParameterfv_2(texture, level, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureLevelParameterfv(texture: gl_texture; level: Int32; pname: GetTextureParameter; &params: IntPtr) :=
    z_GetTextureLevelParameterfv_1(texture, level, pname, &params);
    
    private z_GetTextureLevelParameteriv_adr := GetProcAddress('glGetTextureLevelParameteriv');
    private z_GetTextureLevelParameteriv_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; pname: GetTextureParameter; &params: IntPtr)>(z_GetTextureLevelParameteriv_adr);
    private z_GetTextureLevelParameteriv_2 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; pname: GetTextureParameter; var &params: Int32)>(z_GetTextureLevelParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureLevelParameteriv(texture: gl_texture; level: Int32; pname: GetTextureParameter; var &params: Int32) :=
    z_GetTextureLevelParameteriv_2(texture, level, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureLevelParameteriv(texture: gl_texture; level: Int32; pname: GetTextureParameter; &params: IntPtr) :=
    z_GetTextureLevelParameteriv_1(texture, level, pname, &params);
    
    private z_GetTextureParameterfv_adr := GetProcAddress('glGetTextureParameterfv');
    private z_GetTextureParameterfv_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: GetTextureParameter; &params: IntPtr)>(z_GetTextureParameterfv_adr);
    private z_GetTextureParameterfv_2 := GetProcOrNil&<procedure(texture: gl_texture; pname: GetTextureParameter; var &params: single)>(z_GetTextureParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterfv(texture: gl_texture; pname: GetTextureParameter; var &params: single) :=
    z_GetTextureParameterfv_2(texture, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterfv(texture: gl_texture; pname: GetTextureParameter; &params: IntPtr) :=
    z_GetTextureParameterfv_1(texture, pname, &params);
    
    private z_GetTextureParameterIiv_adr := GetProcAddress('glGetTextureParameterIiv');
    private z_GetTextureParameterIiv_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: GetTextureParameter; &params: IntPtr)>(z_GetTextureParameterIiv_adr);
    private z_GetTextureParameterIiv_2 := GetProcOrNil&<procedure(texture: gl_texture; pname: GetTextureParameter; var &params: Int32)>(z_GetTextureParameterIiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIiv(texture: gl_texture; pname: GetTextureParameter; var &params: Int32) :=
    z_GetTextureParameterIiv_2(texture, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIiv(texture: gl_texture; pname: GetTextureParameter; &params: IntPtr) :=
    z_GetTextureParameterIiv_1(texture, pname, &params);
    
    private z_GetTextureParameterIuiv_adr := GetProcAddress('glGetTextureParameterIuiv');
    private z_GetTextureParameterIuiv_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: GetTextureParameter; &params: IntPtr)>(z_GetTextureParameterIuiv_adr);
    private z_GetTextureParameterIuiv_2 := GetProcOrNil&<procedure(texture: gl_texture; pname: GetTextureParameter; var &params: UInt32)>(z_GetTextureParameterIuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIuiv(texture: gl_texture; pname: GetTextureParameter; var &params: UInt32) :=
    z_GetTextureParameterIuiv_2(texture, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIuiv(texture: gl_texture; pname: GetTextureParameter; &params: IntPtr) :=
    z_GetTextureParameterIuiv_1(texture, pname, &params);
    
    private z_GetTextureParameteriv_adr := GetProcAddress('glGetTextureParameteriv');
    private z_GetTextureParameteriv_1 := GetProcOrNil&<procedure(texture: gl_texture; pname: GetTextureParameter; &params: IntPtr)>(z_GetTextureParameteriv_adr);
    private z_GetTextureParameteriv_2 := GetProcOrNil&<procedure(texture: gl_texture; pname: GetTextureParameter; var &params: Int32)>(z_GetTextureParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameteriv(texture: gl_texture; pname: GetTextureParameter; var &params: Int32) :=
    z_GetTextureParameteriv_2(texture, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameteriv(texture: gl_texture; pname: GetTextureParameter; &params: IntPtr) :=
    z_GetTextureParameteriv_1(texture, pname, &params);
    
    private z_CreateVertexArrays_adr := GetProcAddress('glCreateVertexArrays');
    private z_CreateVertexArrays_1 := GetProcOrNil&<procedure(n: Int32; arrays: IntPtr)>(z_CreateVertexArrays_adr);
    private z_CreateVertexArrays_2 := GetProcOrNil&<procedure(n: Int32; var arrays: gl_vertex_array)>(z_CreateVertexArrays_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateVertexArrays(n: Int32; arrays: array of gl_vertex_array);
    type Pgl_vertex_array=^gl_vertex_array;
    begin
      if (arrays<>nil) and (arrays.Length<>0) then
        z_CreateVertexArrays_2(n, arrays[0]) else
        z_CreateVertexArrays_2(n, Pgl_vertex_array(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateVertexArrays(n: Int32; var arrays: gl_vertex_array) :=
    z_CreateVertexArrays_2(n, arrays);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateVertexArrays(n: Int32; arrays: IntPtr) :=
    z_CreateVertexArrays_1(n, arrays);
    
    private z_DisableVertexArrayAttrib_adr := GetProcAddress('glDisableVertexArrayAttrib');
    private z_DisableVertexArrayAttrib_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32)>(z_DisableVertexArrayAttrib_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableVertexArrayAttrib(vaobj: gl_vertex_array; index: UInt32) :=
    z_DisableVertexArrayAttrib_1(vaobj, index);
    
    private z_EnableVertexArrayAttrib_adr := GetProcAddress('glEnableVertexArrayAttrib');
    private z_EnableVertexArrayAttrib_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32)>(z_EnableVertexArrayAttrib_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableVertexArrayAttrib(vaobj: gl_vertex_array; index: UInt32) :=
    z_EnableVertexArrayAttrib_1(vaobj, index);
    
    private z_VertexArrayElementBuffer_adr := GetProcAddress('glVertexArrayElementBuffer');
    private z_VertexArrayElementBuffer_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; buffer: gl_buffer)>(z_VertexArrayElementBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayElementBuffer(vaobj: gl_vertex_array; buffer: gl_buffer) :=
    z_VertexArrayElementBuffer_1(vaobj, buffer);
    
    private z_VertexArrayVertexBuffer_adr := GetProcAddress('glVertexArrayVertexBuffer');
    private z_VertexArrayVertexBuffer_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; bindingindex: UInt32; buffer: gl_buffer; offset: IntPtr; stride: Int32)>(z_VertexArrayVertexBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffer(vaobj: gl_vertex_array; bindingindex: UInt32; buffer: gl_buffer; offset: IntPtr; stride: Int32) :=
    z_VertexArrayVertexBuffer_1(vaobj, bindingindex, buffer, offset, stride);
    
    private z_VertexArrayVertexBuffers_adr := GetProcAddress('glVertexArrayVertexBuffers');
    private z_VertexArrayVertexBuffers_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; strides: IntPtr)>(z_VertexArrayVertexBuffers_adr);
    private z_VertexArrayVertexBuffers_2 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; var strides: Int32)>(z_VertexArrayVertexBuffers_adr);
    private z_VertexArrayVertexBuffers_3 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; strides: IntPtr)>(z_VertexArrayVertexBuffers_adr);
    private z_VertexArrayVertexBuffers_4 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; var strides: Int32)>(z_VertexArrayVertexBuffers_adr);
    private z_VertexArrayVertexBuffers_5 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; strides: IntPtr)>(z_VertexArrayVertexBuffers_adr);
    private z_VertexArrayVertexBuffers_6 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; var strides: Int32)>(z_VertexArrayVertexBuffers_adr);
    private z_VertexArrayVertexBuffers_7 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; strides: IntPtr)>(z_VertexArrayVertexBuffers_adr);
    private z_VertexArrayVertexBuffers_8 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; var strides: Int32)>(z_VertexArrayVertexBuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: gl_vertex_array; first: UInt32; count: Int32; buffers: array of gl_buffer; offsets: array of IntPtr; strides: array of Int32);
    type Pgl_buffer=^gl_buffer;
    type PIntPtr=^IntPtr;
    type PInt32=^Int32;
    begin
      if (strides<>nil) and (strides.Length<>0) then
        if (offsets<>nil) and (offsets.Length<>0) then
          if (buffers<>nil) and (buffers.Length<>0) then
            z_VertexArrayVertexBuffers_8(vaobj, first, count, buffers[0], offsets[0], strides[0]) else
            z_VertexArrayVertexBuffers_8(vaobj, first, count, Pgl_buffer(nil)^, offsets[0], strides[0]) else
          if (buffers<>nil) and (buffers.Length<>0) then
            z_VertexArrayVertexBuffers_8(vaobj, first, count, buffers[0], PIntPtr(nil)^, strides[0]) else
            z_VertexArrayVertexBuffers_8(vaobj, first, count, Pgl_buffer(nil)^, PIntPtr(nil)^, strides[0]) else
        if (offsets<>nil) and (offsets.Length<>0) then
          if (buffers<>nil) and (buffers.Length<>0) then
            z_VertexArrayVertexBuffers_8(vaobj, first, count, buffers[0], offsets[0], PInt32(nil)^) else
            z_VertexArrayVertexBuffers_8(vaobj, first, count, Pgl_buffer(nil)^, offsets[0], PInt32(nil)^) else
          if (buffers<>nil) and (buffers.Length<>0) then
            z_VertexArrayVertexBuffers_8(vaobj, first, count, buffers[0], PIntPtr(nil)^, PInt32(nil)^) else
            z_VertexArrayVertexBuffers_8(vaobj, first, count, Pgl_buffer(nil)^, PIntPtr(nil)^, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: gl_vertex_array; first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; var strides: Int32) :=
    z_VertexArrayVertexBuffers_8(vaobj, first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: gl_vertex_array; first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; strides: IntPtr) :=
    z_VertexArrayVertexBuffers_7(vaobj, first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: gl_vertex_array; first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; var strides: Int32) :=
    z_VertexArrayVertexBuffers_6(vaobj, first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: gl_vertex_array; first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; strides: IntPtr) :=
    z_VertexArrayVertexBuffers_5(vaobj, first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: gl_vertex_array; first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; var strides: Int32) :=
    z_VertexArrayVertexBuffers_4(vaobj, first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: gl_vertex_array; first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; strides: IntPtr) :=
    z_VertexArrayVertexBuffers_3(vaobj, first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: gl_vertex_array; first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; var strides: Int32) :=
    z_VertexArrayVertexBuffers_2(vaobj, first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: gl_vertex_array; first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; strides: IntPtr) :=
    z_VertexArrayVertexBuffers_1(vaobj, first, count, buffers, offsets, strides);
    
    private z_VertexArrayAttribBinding_adr := GetProcAddress('glVertexArrayAttribBinding');
    private z_VertexArrayAttribBinding_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; attribindex: UInt32; bindingindex: UInt32)>(z_VertexArrayAttribBinding_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayAttribBinding(vaobj: gl_vertex_array; attribindex: UInt32; bindingindex: UInt32) :=
    z_VertexArrayAttribBinding_1(vaobj, attribindex, bindingindex);
    
    private z_VertexArrayAttribFormat_adr := GetProcAddress('glVertexArrayAttribFormat');
    private z_VertexArrayAttribFormat_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; attribindex: UInt32; size: Int32; &type: VertexAttribType; normalized: boolean; relativeoffset: UInt32)>(z_VertexArrayAttribFormat_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayAttribFormat(vaobj: gl_vertex_array; attribindex: UInt32; size: Int32; &type: VertexAttribType; normalized: boolean; relativeoffset: UInt32) :=
    z_VertexArrayAttribFormat_1(vaobj, attribindex, size, &type, normalized, relativeoffset);
    
    private z_VertexArrayAttribIFormat_adr := GetProcAddress('glVertexArrayAttribIFormat');
    private z_VertexArrayAttribIFormat_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; attribindex: UInt32; size: Int32; &type: VertexAttribIType; relativeoffset: UInt32)>(z_VertexArrayAttribIFormat_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayAttribIFormat(vaobj: gl_vertex_array; attribindex: UInt32; size: Int32; &type: VertexAttribIType; relativeoffset: UInt32) :=
    z_VertexArrayAttribIFormat_1(vaobj, attribindex, size, &type, relativeoffset);
    
    private z_VertexArrayAttribLFormat_adr := GetProcAddress('glVertexArrayAttribLFormat');
    private z_VertexArrayAttribLFormat_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; attribindex: UInt32; size: Int32; &type: VertexAttribLType; relativeoffset: UInt32)>(z_VertexArrayAttribLFormat_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayAttribLFormat(vaobj: gl_vertex_array; attribindex: UInt32; size: Int32; &type: VertexAttribLType; relativeoffset: UInt32) :=
    z_VertexArrayAttribLFormat_1(vaobj, attribindex, size, &type, relativeoffset);
    
    private z_VertexArrayBindingDivisor_adr := GetProcAddress('glVertexArrayBindingDivisor');
    private z_VertexArrayBindingDivisor_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; bindingindex: UInt32; divisor: UInt32)>(z_VertexArrayBindingDivisor_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayBindingDivisor(vaobj: gl_vertex_array; bindingindex: UInt32; divisor: UInt32) :=
    z_VertexArrayBindingDivisor_1(vaobj, bindingindex, divisor);
    
    private z_GetVertexArrayiv_adr := GetProcAddress('glGetVertexArrayiv');
    private z_GetVertexArrayiv_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; pname: VertexArrayPName; param: IntPtr)>(z_GetVertexArrayiv_adr);
    private z_GetVertexArrayiv_2 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; pname: VertexArrayPName; var param: Int32)>(z_GetVertexArrayiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayiv(vaobj: gl_vertex_array; pname: VertexArrayPName; var param: Int32) :=
    z_GetVertexArrayiv_2(vaobj, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayiv(vaobj: gl_vertex_array; pname: VertexArrayPName; param: IntPtr) :=
    z_GetVertexArrayiv_1(vaobj, pname, param);
    
    private z_GetVertexArrayIndexediv_adr := GetProcAddress('glGetVertexArrayIndexediv');
    private z_GetVertexArrayIndexediv_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32; pname: VertexArrayPName; param: IntPtr)>(z_GetVertexArrayIndexediv_adr);
    private z_GetVertexArrayIndexediv_2 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32; pname: VertexArrayPName; var param: Int32)>(z_GetVertexArrayIndexediv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIndexediv(vaobj: gl_vertex_array; index: UInt32; pname: VertexArrayPName; var param: Int32) :=
    z_GetVertexArrayIndexediv_2(vaobj, index, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIndexediv(vaobj: gl_vertex_array; index: UInt32; pname: VertexArrayPName; param: IntPtr) :=
    z_GetVertexArrayIndexediv_1(vaobj, index, pname, param);
    
    private z_GetVertexArrayIndexed64iv_adr := GetProcAddress('glGetVertexArrayIndexed64iv');
    private z_GetVertexArrayIndexed64iv_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32; pname: VertexArrayPName; param: IntPtr)>(z_GetVertexArrayIndexed64iv_adr);
    private z_GetVertexArrayIndexed64iv_2 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32; pname: VertexArrayPName; var param: Int64)>(z_GetVertexArrayIndexed64iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIndexed64iv(vaobj: gl_vertex_array; index: UInt32; pname: VertexArrayPName; var param: Int64) :=
    z_GetVertexArrayIndexed64iv_2(vaobj, index, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIndexed64iv(vaobj: gl_vertex_array; index: UInt32; pname: VertexArrayPName; param: IntPtr) :=
    z_GetVertexArrayIndexed64iv_1(vaobj, index, pname, param);
    
    private z_CreateSamplers_adr := GetProcAddress('glCreateSamplers');
    private z_CreateSamplers_1 := GetProcOrNil&<procedure(n: Int32; samplers: IntPtr)>(z_CreateSamplers_adr);
    private z_CreateSamplers_2 := GetProcOrNil&<procedure(n: Int32; var samplers: gl_sampler)>(z_CreateSamplers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateSamplers(n: Int32; samplers: array of gl_sampler);
    type Pgl_sampler=^gl_sampler;
    begin
      if (samplers<>nil) and (samplers.Length<>0) then
        z_CreateSamplers_2(n, samplers[0]) else
        z_CreateSamplers_2(n, Pgl_sampler(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateSamplers(n: Int32; var samplers: gl_sampler) :=
    z_CreateSamplers_2(n, samplers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateSamplers(n: Int32; samplers: IntPtr) :=
    z_CreateSamplers_1(n, samplers);
    
    private z_CreateProgramPipelines_adr := GetProcAddress('glCreateProgramPipelines');
    private z_CreateProgramPipelines_1 := GetProcOrNil&<procedure(n: Int32; pipelines: IntPtr)>(z_CreateProgramPipelines_adr);
    private z_CreateProgramPipelines_2 := GetProcOrNil&<procedure(n: Int32; var pipelines: gl_program_pipeline)>(z_CreateProgramPipelines_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateProgramPipelines(n: Int32; pipelines: array of gl_program_pipeline);
    type Pgl_program_pipeline=^gl_program_pipeline;
    begin
      if (pipelines<>nil) and (pipelines.Length<>0) then
        z_CreateProgramPipelines_2(n, pipelines[0]) else
        z_CreateProgramPipelines_2(n, Pgl_program_pipeline(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateProgramPipelines(n: Int32; var pipelines: gl_program_pipeline) :=
    z_CreateProgramPipelines_2(n, pipelines);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateProgramPipelines(n: Int32; pipelines: IntPtr) :=
    z_CreateProgramPipelines_1(n, pipelines);
    
    private z_CreateQueries_adr := GetProcAddress('glCreateQueries');
    private z_CreateQueries_1 := GetProcOrNil&<procedure(target: QueryTarget; n: Int32; ids: IntPtr)>(z_CreateQueries_adr);
    private z_CreateQueries_2 := GetProcOrNil&<procedure(target: QueryTarget; n: Int32; var ids: gl_query)>(z_CreateQueries_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateQueries(target: QueryTarget; n: Int32; ids: array of gl_query);
    type Pgl_query=^gl_query;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        z_CreateQueries_2(target, n, ids[0]) else
        z_CreateQueries_2(target, n, Pgl_query(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateQueries(target: QueryTarget; n: Int32; var ids: gl_query) :=
    z_CreateQueries_2(target, n, ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateQueries(target: QueryTarget; n: Int32; ids: IntPtr) :=
    z_CreateQueries_1(target, n, ids);
    
    private z_GetQueryBufferObjecti64v_adr := GetProcAddress('glGetQueryBufferObjecti64v');
    private z_GetQueryBufferObjecti64v_1 := GetProcOrNil&<procedure(id: gl_query; buffer: gl_buffer; pname: QueryObjectParameterName; offset: IntPtr)>(z_GetQueryBufferObjecti64v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryBufferObjecti64v(id: gl_query; buffer: gl_buffer; pname: QueryObjectParameterName; offset: IntPtr) :=
    z_GetQueryBufferObjecti64v_1(id, buffer, pname, offset);
    
    private z_GetQueryBufferObjectiv_adr := GetProcAddress('glGetQueryBufferObjectiv');
    private z_GetQueryBufferObjectiv_1 := GetProcOrNil&<procedure(id: gl_query; buffer: gl_buffer; pname: QueryObjectParameterName; offset: IntPtr)>(z_GetQueryBufferObjectiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryBufferObjectiv(id: gl_query; buffer: gl_buffer; pname: QueryObjectParameterName; offset: IntPtr) :=
    z_GetQueryBufferObjectiv_1(id, buffer, pname, offset);
    
    private z_GetQueryBufferObjectui64v_adr := GetProcAddress('glGetQueryBufferObjectui64v');
    private z_GetQueryBufferObjectui64v_1 := GetProcOrNil&<procedure(id: gl_query; buffer: gl_buffer; pname: QueryObjectParameterName; offset: IntPtr)>(z_GetQueryBufferObjectui64v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryBufferObjectui64v(id: gl_query; buffer: gl_buffer; pname: QueryObjectParameterName; offset: IntPtr) :=
    z_GetQueryBufferObjectui64v_1(id, buffer, pname, offset);
    
    private z_GetQueryBufferObjectuiv_adr := GetProcAddress('glGetQueryBufferObjectuiv');
    private z_GetQueryBufferObjectuiv_1 := GetProcOrNil&<procedure(id: gl_query; buffer: gl_buffer; pname: QueryObjectParameterName; offset: IntPtr)>(z_GetQueryBufferObjectuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryBufferObjectuiv(id: gl_query; buffer: gl_buffer; pname: QueryObjectParameterName; offset: IntPtr) :=
    z_GetQueryBufferObjectuiv_1(id, buffer, pname, offset);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glDrawBuffersARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_draw_buffers';
    
    private z_DrawBuffersARB_adr := GetProcAddress('glDrawBuffersARB');
    private z_DrawBuffersARB_1 := GetProcOrNil&<procedure(n: Int32; bufs: IntPtr)>(z_DrawBuffersARB_adr);
    private z_DrawBuffersARB_2 := GetProcOrNil&<procedure(n: Int32; var bufs: DrawBufferMode)>(z_DrawBuffersARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersARB(n: Int32; bufs: array of DrawBufferMode);
    type PDrawBufferMode=^DrawBufferMode;
    begin
      if (bufs<>nil) and (bufs.Length<>0) then
        z_DrawBuffersARB_2(n, bufs[0]) else
        z_DrawBuffersARB_2(n, PDrawBufferMode(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersARB(n: Int32; var bufs: DrawBufferMode) :=
    z_DrawBuffersARB_2(n, bufs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersARB(n: Int32; bufs: IntPtr) :=
    z_DrawBuffersARB_1(n, bufs);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glDrawBuffersBlendARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_draw_buffers_blend';
    
    private z_BlendEquationiARB_adr := GetProcAddress('glBlendEquationiARB');
    private z_BlendEquationiARB_1 := GetProcOrNil&<procedure(buf: UInt32; mode: BlendEquationMode)>(z_BlendEquationiARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquationiARB(buf: UInt32; mode: BlendEquationMode) :=
    z_BlendEquationiARB_1(buf, mode);
    
    private z_BlendEquationSeparateiARB_adr := GetProcAddress('glBlendEquationSeparateiARB');
    private z_BlendEquationSeparateiARB_1 := GetProcOrNil&<procedure(buf: UInt32; modeRGB: BlendEquationMode; modeAlpha: BlendEquationMode)>(z_BlendEquationSeparateiARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquationSeparateiARB(buf: UInt32; modeRGB: BlendEquationMode; modeAlpha: BlendEquationMode) :=
    z_BlendEquationSeparateiARB_1(buf, modeRGB, modeAlpha);
    
    private z_BlendFunciARB_adr := GetProcAddress('glBlendFunciARB');
    private z_BlendFunciARB_1 := GetProcOrNil&<procedure(buf: UInt32; src: BlendingFactor; dst: BlendingFactor)>(z_BlendFunciARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendFunciARB(buf: UInt32; src: BlendingFactor; dst: BlendingFactor) :=
    z_BlendFunciARB_1(buf, src, dst);
    
    private z_BlendFuncSeparateiARB_adr := GetProcAddress('glBlendFuncSeparateiARB');
    private z_BlendFuncSeparateiARB_1 := GetProcOrNil&<procedure(buf: UInt32; srcRGB: BlendingFactor; dstRGB: BlendingFactor; srcAlpha: BlendingFactor; dstAlpha: BlendingFactor)>(z_BlendFuncSeparateiARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendFuncSeparateiARB(buf: UInt32; srcRGB: BlendingFactor; dstRGB: BlendingFactor; srcAlpha: BlendingFactor; dstAlpha: BlendingFactor) :=
    z_BlendFuncSeparateiARB_1(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glDrawElementsBaseVertexARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_draw_elements_base_vertex';
    
    private z_DrawElementsBaseVertex_adr := GetProcAddress('glDrawElementsBaseVertex');
    private z_DrawElementsBaseVertex_1 := GetProcOrNil&<procedure(mode: PrimitiveType; count: Int32; &type: DrawElementsType; indices: IntPtr; basevertex: Int32)>(z_DrawElementsBaseVertex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsBaseVertex(mode: PrimitiveType; count: Int32; &type: DrawElementsType; indices: IntPtr; basevertex: Int32) :=
    z_DrawElementsBaseVertex_1(mode, count, &type, indices, basevertex);
    
    private z_DrawRangeElementsBaseVertex_adr := GetProcAddress('glDrawRangeElementsBaseVertex');
    private z_DrawRangeElementsBaseVertex_1 := GetProcOrNil&<procedure(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DrawElementsType; indices: IntPtr; basevertex: Int32)>(z_DrawRangeElementsBaseVertex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawRangeElementsBaseVertex(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DrawElementsType; indices: IntPtr; basevertex: Int32) :=
    z_DrawRangeElementsBaseVertex_1(mode, start, &end, count, &type, indices, basevertex);
    
    private z_DrawElementsInstancedBaseVertex_adr := GetProcAddress('glDrawElementsInstancedBaseVertex');
    private z_DrawElementsInstancedBaseVertex_1 := GetProcOrNil&<procedure(mode: PrimitiveType; count: Int32; &type: DrawElementsType; indices: IntPtr; instancecount: Int32; basevertex: Int32)>(z_DrawElementsInstancedBaseVertex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedBaseVertex(mode: PrimitiveType; count: Int32; &type: DrawElementsType; indices: IntPtr; instancecount: Int32; basevertex: Int32) :=
    z_DrawElementsInstancedBaseVertex_1(mode, count, &type, indices, instancecount, basevertex);
    
    private z_MultiDrawElementsBaseVertex_adr := GetProcAddress('glMultiDrawElementsBaseVertex');
    private z_MultiDrawElementsBaseVertex_1 := GetProcOrNil&<procedure(mode: PrimitiveType; count: IntPtr; &type: DrawElementsType; indices: pointer; drawcount: Int32; basevertex: IntPtr)>(z_MultiDrawElementsBaseVertex_adr);
    private z_MultiDrawElementsBaseVertex_2 := GetProcOrNil&<procedure(mode: PrimitiveType; count: IntPtr; &type: DrawElementsType; indices: pointer; drawcount: Int32; var basevertex: Int32)>(z_MultiDrawElementsBaseVertex_adr);
    private z_MultiDrawElementsBaseVertex_3 := GetProcOrNil&<procedure(mode: PrimitiveType; count: IntPtr; &type: DrawElementsType; var indices: IntPtr; drawcount: Int32; basevertex: IntPtr)>(z_MultiDrawElementsBaseVertex_adr);
    private z_MultiDrawElementsBaseVertex_4 := GetProcOrNil&<procedure(mode: PrimitiveType; count: IntPtr; &type: DrawElementsType; var indices: IntPtr; drawcount: Int32; var basevertex: Int32)>(z_MultiDrawElementsBaseVertex_adr);
    private z_MultiDrawElementsBaseVertex_5 := GetProcOrNil&<procedure(mode: PrimitiveType; var count: Int32; &type: DrawElementsType; indices: pointer; drawcount: Int32; basevertex: IntPtr)>(z_MultiDrawElementsBaseVertex_adr);
    private z_MultiDrawElementsBaseVertex_6 := GetProcOrNil&<procedure(mode: PrimitiveType; var count: Int32; &type: DrawElementsType; indices: pointer; drawcount: Int32; var basevertex: Int32)>(z_MultiDrawElementsBaseVertex_adr);
    private z_MultiDrawElementsBaseVertex_7 := GetProcOrNil&<procedure(mode: PrimitiveType; var count: Int32; &type: DrawElementsType; var indices: IntPtr; drawcount: Int32; basevertex: IntPtr)>(z_MultiDrawElementsBaseVertex_adr);
    private z_MultiDrawElementsBaseVertex_8 := GetProcOrNil&<procedure(mode: PrimitiveType; var count: Int32; &type: DrawElementsType; var indices: IntPtr; drawcount: Int32; var basevertex: Int32)>(z_MultiDrawElementsBaseVertex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; count: array of Int32; &type: DrawElementsType; indices: array of IntPtr; drawcount: Int32; basevertex: array of Int32);
    type PInt32=^Int32;
    type PIntPtr=^IntPtr;
    begin
      if (basevertex<>nil) and (basevertex.Length<>0) then
        if (indices<>nil) and (indices.Length<>0) then
          if (count<>nil) and (count.Length<>0) then
            z_MultiDrawElementsBaseVertex_8(mode, count[0], &type, indices[0], drawcount, basevertex[0]) else
            z_MultiDrawElementsBaseVertex_8(mode, PInt32(nil)^, &type, indices[0], drawcount, basevertex[0]) else
          if (count<>nil) and (count.Length<>0) then
            z_MultiDrawElementsBaseVertex_8(mode, count[0], &type, PIntPtr(nil)^, drawcount, basevertex[0]) else
            z_MultiDrawElementsBaseVertex_8(mode, PInt32(nil)^, &type, PIntPtr(nil)^, drawcount, basevertex[0]) else
        if (indices<>nil) and (indices.Length<>0) then
          if (count<>nil) and (count.Length<>0) then
            z_MultiDrawElementsBaseVertex_8(mode, count[0], &type, indices[0], drawcount, PInt32(nil)^) else
            z_MultiDrawElementsBaseVertex_8(mode, PInt32(nil)^, &type, indices[0], drawcount, PInt32(nil)^) else
          if (count<>nil) and (count.Length<>0) then
            z_MultiDrawElementsBaseVertex_8(mode, count[0], &type, PIntPtr(nil)^, drawcount, PInt32(nil)^) else
            z_MultiDrawElementsBaseVertex_8(mode, PInt32(nil)^, &type, PIntPtr(nil)^, drawcount, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; var count: Int32; &type: DrawElementsType; var indices: IntPtr; drawcount: Int32; var basevertex: Int32) :=
    z_MultiDrawElementsBaseVertex_8(mode, count, &type, indices, drawcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; var count: Int32; &type: DrawElementsType; var indices: IntPtr; drawcount: Int32; basevertex: IntPtr) :=
    z_MultiDrawElementsBaseVertex_7(mode, count, &type, indices, drawcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; var count: Int32; &type: DrawElementsType; indices: pointer; drawcount: Int32; var basevertex: Int32) :=
    z_MultiDrawElementsBaseVertex_6(mode, count, &type, indices, drawcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; var count: Int32; &type: DrawElementsType; indices: pointer; drawcount: Int32; basevertex: IntPtr) :=
    z_MultiDrawElementsBaseVertex_5(mode, count, &type, indices, drawcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; count: IntPtr; &type: DrawElementsType; var indices: IntPtr; drawcount: Int32; var basevertex: Int32) :=
    z_MultiDrawElementsBaseVertex_4(mode, count, &type, indices, drawcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; count: IntPtr; &type: DrawElementsType; var indices: IntPtr; drawcount: Int32; basevertex: IntPtr) :=
    z_MultiDrawElementsBaseVertex_3(mode, count, &type, indices, drawcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; count: IntPtr; &type: DrawElementsType; indices: pointer; drawcount: Int32; var basevertex: Int32) :=
    z_MultiDrawElementsBaseVertex_2(mode, count, &type, indices, drawcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; count: IntPtr; &type: DrawElementsType; indices: pointer; drawcount: Int32; basevertex: IntPtr) :=
    z_MultiDrawElementsBaseVertex_1(mode, count, &type, indices, drawcount, basevertex);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glDrawIndirectARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_draw_indirect';
    
    private z_DrawArraysIndirect_adr := GetProcAddress('glDrawArraysIndirect');
    private z_DrawArraysIndirect_1 := GetProcOrNil&<procedure(mode: PrimitiveType; indirect: IntPtr)>(z_DrawArraysIndirect_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawArraysIndirect(mode: PrimitiveType; indirect: IntPtr) :=
    z_DrawArraysIndirect_1(mode, indirect);
    
    private z_DrawElementsIndirect_adr := GetProcAddress('glDrawElementsIndirect');
    private z_DrawElementsIndirect_1 := GetProcOrNil&<procedure(mode: PrimitiveType; &type: DrawElementsType; indirect: IntPtr)>(z_DrawElementsIndirect_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsIndirect(mode: PrimitiveType; &type: DrawElementsType; indirect: IntPtr) :=
    z_DrawElementsIndirect_1(mode, &type, indirect);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glDrawInstancedARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_draw_instanced';
    
    private z_DrawArraysInstancedARB_adr := GetProcAddress('glDrawArraysInstancedARB');
    private z_DrawArraysInstancedARB_1 := GetProcOrNil&<procedure(mode: PrimitiveType; first: Int32; count: Int32; primcount: Int32)>(z_DrawArraysInstancedARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawArraysInstancedARB(mode: PrimitiveType; first: Int32; count: Int32; primcount: Int32) :=
    z_DrawArraysInstancedARB_1(mode, first, count, primcount);
    
    private z_DrawElementsInstancedARB_adr := GetProcAddress('glDrawElementsInstancedARB');
    private z_DrawElementsInstancedARB_1 := GetProcOrNil&<procedure(mode: PrimitiveType; count: Int32; &type: DrawElementsType; indices: IntPtr; primcount: Int32)>(z_DrawElementsInstancedARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedARB(mode: PrimitiveType; count: Int32; &type: DrawElementsType; indices: IntPtr; primcount: Int32) :=
    z_DrawElementsInstancedARB_1(mode, count, &type, indices, primcount);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glFragmentProgramARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_fragment_program';
    
    private z_ProgramStringARB_adr := GetProcAddress('glProgramStringARB');
    private z_ProgramStringARB_1 := GetProcOrNil&<procedure(target: ProgramTarget; format: ProgramFormat; len: Int32; string: IntPtr)>(z_ProgramStringARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramStringARB(target: ProgramTarget; format: ProgramFormat; len: Int32; string: IntPtr) :=
    z_ProgramStringARB_1(target, format, len, string);
    
    private z_BindProgramARB_adr := GetProcAddress('glBindProgramARB');
    private z_BindProgramARB_1 := GetProcOrNil&<procedure(target: ProgramTarget; &program: gl_program)>(z_BindProgramARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindProgramARB(target: ProgramTarget; &program: gl_program) :=
    z_BindProgramARB_1(target, &program);
    
    private z_DeleteProgramsARB_adr := GetProcAddress('glDeleteProgramsARB');
    private z_DeleteProgramsARB_1 := GetProcOrNil&<procedure(n: Int32; programs: IntPtr)>(z_DeleteProgramsARB_adr);
    private z_DeleteProgramsARB_2 := GetProcOrNil&<procedure(n: Int32; var programs: gl_program)>(z_DeleteProgramsARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramsARB(n: Int32; programs: array of gl_program);
    type Pgl_program=^gl_program;
    begin
      if (programs<>nil) and (programs.Length<>0) then
        z_DeleteProgramsARB_2(n, programs[0]) else
        z_DeleteProgramsARB_2(n, Pgl_program(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramsARB(n: Int32; var programs: gl_program) :=
    z_DeleteProgramsARB_2(n, programs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramsARB(n: Int32; programs: IntPtr) :=
    z_DeleteProgramsARB_1(n, programs);
    
    private z_GenProgramsARB_adr := GetProcAddress('glGenProgramsARB');
    private z_GenProgramsARB_1 := GetProcOrNil&<procedure(n: Int32; programs: IntPtr)>(z_GenProgramsARB_adr);
    private z_GenProgramsARB_2 := GetProcOrNil&<procedure(n: Int32; var programs: gl_program)>(z_GenProgramsARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramsARB(n: Int32; programs: array of gl_program);
    type Pgl_program=^gl_program;
    begin
      if (programs<>nil) and (programs.Length<>0) then
        z_GenProgramsARB_2(n, programs[0]) else
        z_GenProgramsARB_2(n, Pgl_program(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramsARB(n: Int32; var programs: gl_program) :=
    z_GenProgramsARB_2(n, programs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramsARB(n: Int32; programs: IntPtr) :=
    z_GenProgramsARB_1(n, programs);
    
    private z_ProgramEnvParameter4dARB_adr := GetProcAddress('glProgramEnvParameter4dARB');
    private z_ProgramEnvParameter4dARB_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; x: real; y: real; z: real; w: real)>(z_ProgramEnvParameter4dARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4dARB(target: ProgramTarget; index: UInt32; x: real; y: real; z: real; w: real) :=
    z_ProgramEnvParameter4dARB_1(target, index, x, y, z, w);
    
    private z_ProgramEnvParameter4dvARB_adr := GetProcAddress('glProgramEnvParameter4dvARB');
    private z_ProgramEnvParameter4dvARB_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; &params: IntPtr)>(z_ProgramEnvParameter4dvARB_adr);
    private z_ProgramEnvParameter4dvARB_2 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; var &params: real)>(z_ProgramEnvParameter4dvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4dvARB(target: ProgramTarget; index: UInt32; &params: array of real);
    type Preal=^real;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_ProgramEnvParameter4dvARB_2(target, index, &params[0]) else
        z_ProgramEnvParameter4dvARB_2(target, index, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4dvARB(target: ProgramTarget; index: UInt32; var &params: real) :=
    z_ProgramEnvParameter4dvARB_2(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4dvARB(target: ProgramTarget; index: UInt32; &params: IntPtr) :=
    z_ProgramEnvParameter4dvARB_1(target, index, &params);
    
    private z_ProgramEnvParameter4fARB_adr := GetProcAddress('glProgramEnvParameter4fARB');
    private z_ProgramEnvParameter4fARB_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; x: single; y: single; z: single; w: single)>(z_ProgramEnvParameter4fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4fARB(target: ProgramTarget; index: UInt32; x: single; y: single; z: single; w: single) :=
    z_ProgramEnvParameter4fARB_1(target, index, x, y, z, w);
    
    private z_ProgramEnvParameter4fvARB_adr := GetProcAddress('glProgramEnvParameter4fvARB');
    private z_ProgramEnvParameter4fvARB_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; &params: IntPtr)>(z_ProgramEnvParameter4fvARB_adr);
    private z_ProgramEnvParameter4fvARB_2 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; var &params: single)>(z_ProgramEnvParameter4fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4fvARB(target: ProgramTarget; index: UInt32; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_ProgramEnvParameter4fvARB_2(target, index, &params[0]) else
        z_ProgramEnvParameter4fvARB_2(target, index, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4fvARB(target: ProgramTarget; index: UInt32; var &params: single) :=
    z_ProgramEnvParameter4fvARB_2(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4fvARB(target: ProgramTarget; index: UInt32; &params: IntPtr) :=
    z_ProgramEnvParameter4fvARB_1(target, index, &params);
    
    private z_ProgramLocalParameter4dARB_adr := GetProcAddress('glProgramLocalParameter4dARB');
    private z_ProgramLocalParameter4dARB_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; x: real; y: real; z: real; w: real)>(z_ProgramLocalParameter4dARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4dARB(target: ProgramTarget; index: UInt32; x: real; y: real; z: real; w: real) :=
    z_ProgramLocalParameter4dARB_1(target, index, x, y, z, w);
    
    private z_ProgramLocalParameter4dvARB_adr := GetProcAddress('glProgramLocalParameter4dvARB');
    private z_ProgramLocalParameter4dvARB_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; &params: IntPtr)>(z_ProgramLocalParameter4dvARB_adr);
    private z_ProgramLocalParameter4dvARB_2 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; var &params: real)>(z_ProgramLocalParameter4dvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4dvARB(target: ProgramTarget; index: UInt32; &params: array of real);
    type Preal=^real;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_ProgramLocalParameter4dvARB_2(target, index, &params[0]) else
        z_ProgramLocalParameter4dvARB_2(target, index, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4dvARB(target: ProgramTarget; index: UInt32; var &params: real) :=
    z_ProgramLocalParameter4dvARB_2(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4dvARB(target: ProgramTarget; index: UInt32; &params: IntPtr) :=
    z_ProgramLocalParameter4dvARB_1(target, index, &params);
    
    private z_ProgramLocalParameter4fARB_adr := GetProcAddress('glProgramLocalParameter4fARB');
    private z_ProgramLocalParameter4fARB_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; x: single; y: single; z: single; w: single)>(z_ProgramLocalParameter4fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4fARB(target: ProgramTarget; index: UInt32; x: single; y: single; z: single; w: single) :=
    z_ProgramLocalParameter4fARB_1(target, index, x, y, z, w);
    
    private z_ProgramLocalParameter4fvARB_adr := GetProcAddress('glProgramLocalParameter4fvARB');
    private z_ProgramLocalParameter4fvARB_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; &params: IntPtr)>(z_ProgramLocalParameter4fvARB_adr);
    private z_ProgramLocalParameter4fvARB_2 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; var &params: single)>(z_ProgramLocalParameter4fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4fvARB(target: ProgramTarget; index: UInt32; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_ProgramLocalParameter4fvARB_2(target, index, &params[0]) else
        z_ProgramLocalParameter4fvARB_2(target, index, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4fvARB(target: ProgramTarget; index: UInt32; var &params: single) :=
    z_ProgramLocalParameter4fvARB_2(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4fvARB(target: ProgramTarget; index: UInt32; &params: IntPtr) :=
    z_ProgramLocalParameter4fvARB_1(target, index, &params);
    
    private z_GetProgramEnvParameterdvARB_adr := GetProcAddress('glGetProgramEnvParameterdvARB');
    private z_GetProgramEnvParameterdvARB_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; &params: IntPtr)>(z_GetProgramEnvParameterdvARB_adr);
    private z_GetProgramEnvParameterdvARB_2 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; var &params: real)>(z_GetProgramEnvParameterdvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterdvARB(target: ProgramTarget; index: UInt32; var &params: real) :=
    z_GetProgramEnvParameterdvARB_2(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterdvARB(target: ProgramTarget; index: UInt32; &params: IntPtr) :=
    z_GetProgramEnvParameterdvARB_1(target, index, &params);
    
    private z_GetProgramEnvParameterfvARB_adr := GetProcAddress('glGetProgramEnvParameterfvARB');
    private z_GetProgramEnvParameterfvARB_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; &params: IntPtr)>(z_GetProgramEnvParameterfvARB_adr);
    private z_GetProgramEnvParameterfvARB_2 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; var &params: single)>(z_GetProgramEnvParameterfvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterfvARB(target: ProgramTarget; index: UInt32; var &params: single) :=
    z_GetProgramEnvParameterfvARB_2(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterfvARB(target: ProgramTarget; index: UInt32; &params: IntPtr) :=
    z_GetProgramEnvParameterfvARB_1(target, index, &params);
    
    private z_GetProgramLocalParameterdvARB_adr := GetProcAddress('glGetProgramLocalParameterdvARB');
    private z_GetProgramLocalParameterdvARB_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; &params: IntPtr)>(z_GetProgramLocalParameterdvARB_adr);
    private z_GetProgramLocalParameterdvARB_2 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; var &params: real)>(z_GetProgramLocalParameterdvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterdvARB(target: ProgramTarget; index: UInt32; var &params: real) :=
    z_GetProgramLocalParameterdvARB_2(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterdvARB(target: ProgramTarget; index: UInt32; &params: IntPtr) :=
    z_GetProgramLocalParameterdvARB_1(target, index, &params);
    
    private z_GetProgramLocalParameterfvARB_adr := GetProcAddress('glGetProgramLocalParameterfvARB');
    private z_GetProgramLocalParameterfvARB_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; &params: IntPtr)>(z_GetProgramLocalParameterfvARB_adr);
    private z_GetProgramLocalParameterfvARB_2 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; var &params: single)>(z_GetProgramLocalParameterfvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterfvARB(target: ProgramTarget; index: UInt32; var &params: single) :=
    z_GetProgramLocalParameterfvARB_2(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterfvARB(target: ProgramTarget; index: UInt32; &params: IntPtr) :=
    z_GetProgramLocalParameterfvARB_1(target, index, &params);
    
    private z_GetProgramivARB_adr := GetProcAddress('glGetProgramivARB');
    private z_GetProgramivARB_1 := GetProcOrNil&<procedure(target: ProgramTarget; pname: ProgramProperty; &params: IntPtr)>(z_GetProgramivARB_adr);
    private z_GetProgramivARB_2 := GetProcOrNil&<procedure(target: ProgramTarget; pname: ProgramProperty; var &params: Int32)>(z_GetProgramivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramivARB(target: ProgramTarget; pname: ProgramProperty; var &params: Int32) :=
    z_GetProgramivARB_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramivARB(target: ProgramTarget; pname: ProgramProperty; &params: IntPtr) :=
    z_GetProgramivARB_1(target, pname, &params);
    
    private z_GetProgramStringARB_adr := GetProcAddress('glGetProgramStringARB');
    private z_GetProgramStringARB_1 := GetProcOrNil&<procedure(target: ProgramTarget; pname: ProgramStringProperty; string: IntPtr)>(z_GetProgramStringARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramStringARB(target: ProgramTarget; pname: ProgramStringProperty; string: IntPtr) :=
    z_GetProgramStringARB_1(target, pname, string);
    
    private z_IsProgramARB_adr := GetProcAddress('glIsProgramARB');
    private z_IsProgramARB_1 := GetProcOrNil&<function(&program: gl_program): boolean>(z_IsProgramARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsProgramARB(&program: gl_program): boolean :=
    z_IsProgramARB_1(&program);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glFramebufferNoAttachmentsARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_framebuffer_no_attachments';
    
    private z_FramebufferParameteri_adr := GetProcAddress('glFramebufferParameteri');
    private z_FramebufferParameteri_1 := GetProcOrNil&<procedure(target: FramebufferTarget; pname: FramebufferParameterName; param: Int32)>(z_FramebufferParameteri_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferParameteri(target: FramebufferTarget; pname: FramebufferParameterName; param: Int32) :=
    z_FramebufferParameteri_1(target, pname, param);
    
    private z_GetFramebufferParameteriv_adr := GetProcAddress('glGetFramebufferParameteriv');
    private z_GetFramebufferParameteriv_1 := GetProcOrNil&<procedure(target: FramebufferTarget; pname: FramebufferAttachmentParameterName; &params: IntPtr)>(z_GetFramebufferParameteriv_adr);
    private z_GetFramebufferParameteriv_2 := GetProcOrNil&<procedure(target: FramebufferTarget; pname: FramebufferAttachmentParameterName; var &params: Int32)>(z_GetFramebufferParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferParameteriv(target: FramebufferTarget; pname: FramebufferAttachmentParameterName; var &params: Int32) :=
    z_GetFramebufferParameteriv_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferParameteriv(target: FramebufferTarget; pname: FramebufferAttachmentParameterName; &params: IntPtr) :=
    z_GetFramebufferParameteriv_1(target, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glFramebufferObjectARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_framebuffer_object';
    
    private z_IsRenderbuffer_adr := GetProcAddress('glIsRenderbuffer');
    private z_IsRenderbuffer_1 := GetProcOrNil&<function(renderbuffer: gl_renderbuffer): boolean>(z_IsRenderbuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsRenderbuffer(renderbuffer: gl_renderbuffer): boolean :=
    z_IsRenderbuffer_1(renderbuffer);
    
    private z_BindRenderbuffer_adr := GetProcAddress('glBindRenderbuffer');
    private z_BindRenderbuffer_1 := GetProcOrNil&<procedure(target: RenderbufferTarget; renderbuffer: gl_renderbuffer)>(z_BindRenderbuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindRenderbuffer(target: RenderbufferTarget; renderbuffer: gl_renderbuffer) :=
    z_BindRenderbuffer_1(target, renderbuffer);
    
    private z_DeleteRenderbuffers_adr := GetProcAddress('glDeleteRenderbuffers');
    private z_DeleteRenderbuffers_1 := GetProcOrNil&<procedure(n: Int32; renderbuffers: IntPtr)>(z_DeleteRenderbuffers_adr);
    private z_DeleteRenderbuffers_2 := GetProcOrNil&<procedure(n: Int32; var renderbuffers: gl_renderbuffer)>(z_DeleteRenderbuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteRenderbuffers(n: Int32; renderbuffers: array of gl_renderbuffer);
    type Pgl_renderbuffer=^gl_renderbuffer;
    begin
      if (renderbuffers<>nil) and (renderbuffers.Length<>0) then
        z_DeleteRenderbuffers_2(n, renderbuffers[0]) else
        z_DeleteRenderbuffers_2(n, Pgl_renderbuffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteRenderbuffers(n: Int32; var renderbuffers: gl_renderbuffer) :=
    z_DeleteRenderbuffers_2(n, renderbuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteRenderbuffers(n: Int32; renderbuffers: IntPtr) :=
    z_DeleteRenderbuffers_1(n, renderbuffers);
    
    private z_GenRenderbuffers_adr := GetProcAddress('glGenRenderbuffers');
    private z_GenRenderbuffers_1 := GetProcOrNil&<procedure(n: Int32; renderbuffers: IntPtr)>(z_GenRenderbuffers_adr);
    private z_GenRenderbuffers_2 := GetProcOrNil&<procedure(n: Int32; var renderbuffers: gl_renderbuffer)>(z_GenRenderbuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenRenderbuffers(n: Int32; renderbuffers: array of gl_renderbuffer);
    type Pgl_renderbuffer=^gl_renderbuffer;
    begin
      if (renderbuffers<>nil) and (renderbuffers.Length<>0) then
        z_GenRenderbuffers_2(n, renderbuffers[0]) else
        z_GenRenderbuffers_2(n, Pgl_renderbuffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenRenderbuffers(n: Int32; var renderbuffers: gl_renderbuffer) :=
    z_GenRenderbuffers_2(n, renderbuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenRenderbuffers(n: Int32; renderbuffers: IntPtr) :=
    z_GenRenderbuffers_1(n, renderbuffers);
    
    private z_RenderbufferStorage_adr := GetProcAddress('glRenderbufferStorage');
    private z_RenderbufferStorage_1 := GetProcOrNil&<procedure(target: RenderbufferTarget; _internalformat: InternalFormat; width: Int32; height: Int32)>(z_RenderbufferStorage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RenderbufferStorage(target: RenderbufferTarget; _internalformat: InternalFormat; width: Int32; height: Int32) :=
    z_RenderbufferStorage_1(target, _internalformat, width, height);
    
    private z_GetRenderbufferParameteriv_adr := GetProcAddress('glGetRenderbufferParameteriv');
    private z_GetRenderbufferParameteriv_1 := GetProcOrNil&<procedure(target: RenderbufferTarget; pname: RenderbufferParameterName; &params: IntPtr)>(z_GetRenderbufferParameteriv_adr);
    private z_GetRenderbufferParameteriv_2 := GetProcOrNil&<procedure(target: RenderbufferTarget; pname: RenderbufferParameterName; var &params: Int32)>(z_GetRenderbufferParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetRenderbufferParameteriv(target: RenderbufferTarget; pname: RenderbufferParameterName; var &params: Int32) :=
    z_GetRenderbufferParameteriv_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetRenderbufferParameteriv(target: RenderbufferTarget; pname: RenderbufferParameterName; &params: IntPtr) :=
    z_GetRenderbufferParameteriv_1(target, pname, &params);
    
    private z_IsFramebuffer_adr := GetProcAddress('glIsFramebuffer');
    private z_IsFramebuffer_1 := GetProcOrNil&<function(framebuffer: gl_framebuffer): boolean>(z_IsFramebuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsFramebuffer(framebuffer: gl_framebuffer): boolean :=
    z_IsFramebuffer_1(framebuffer);
    
    private z_BindFramebuffer_adr := GetProcAddress('glBindFramebuffer');
    private z_BindFramebuffer_1 := GetProcOrNil&<procedure(target: FramebufferTarget; framebuffer: gl_framebuffer)>(z_BindFramebuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindFramebuffer(target: FramebufferTarget; framebuffer: gl_framebuffer) :=
    z_BindFramebuffer_1(target, framebuffer);
    
    private z_DeleteFramebuffers_adr := GetProcAddress('glDeleteFramebuffers');
    private z_DeleteFramebuffers_1 := GetProcOrNil&<procedure(n: Int32; framebuffers: IntPtr)>(z_DeleteFramebuffers_adr);
    private z_DeleteFramebuffers_2 := GetProcOrNil&<procedure(n: Int32; var framebuffers: gl_framebuffer)>(z_DeleteFramebuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFramebuffers(n: Int32; framebuffers: array of gl_framebuffer);
    type Pgl_framebuffer=^gl_framebuffer;
    begin
      if (framebuffers<>nil) and (framebuffers.Length<>0) then
        z_DeleteFramebuffers_2(n, framebuffers[0]) else
        z_DeleteFramebuffers_2(n, Pgl_framebuffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFramebuffers(n: Int32; var framebuffers: gl_framebuffer) :=
    z_DeleteFramebuffers_2(n, framebuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFramebuffers(n: Int32; framebuffers: IntPtr) :=
    z_DeleteFramebuffers_1(n, framebuffers);
    
    private z_GenFramebuffers_adr := GetProcAddress('glGenFramebuffers');
    private z_GenFramebuffers_1 := GetProcOrNil&<procedure(n: Int32; framebuffers: IntPtr)>(z_GenFramebuffers_adr);
    private z_GenFramebuffers_2 := GetProcOrNil&<procedure(n: Int32; var framebuffers: gl_framebuffer)>(z_GenFramebuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFramebuffers(n: Int32; framebuffers: array of gl_framebuffer);
    type Pgl_framebuffer=^gl_framebuffer;
    begin
      if (framebuffers<>nil) and (framebuffers.Length<>0) then
        z_GenFramebuffers_2(n, framebuffers[0]) else
        z_GenFramebuffers_2(n, Pgl_framebuffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFramebuffers(n: Int32; var framebuffers: gl_framebuffer) :=
    z_GenFramebuffers_2(n, framebuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFramebuffers(n: Int32; framebuffers: IntPtr) :=
    z_GenFramebuffers_1(n, framebuffers);
    
    private z_CheckFramebufferStatus_adr := GetProcAddress('glCheckFramebufferStatus');
    private z_CheckFramebufferStatus_1 := GetProcOrNil&<function(target: FramebufferTarget): FramebufferStatus>(z_CheckFramebufferStatus_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CheckFramebufferStatus(target: FramebufferTarget): FramebufferStatus :=
    z_CheckFramebufferStatus_1(target);
    
    private z_FramebufferTexture1D_adr := GetProcAddress('glFramebufferTexture1D');
    private z_FramebufferTexture1D_1 := GetProcOrNil&<procedure(target: FramebufferTarget; attachment: FramebufferAttachment; textarget: TextureTarget; texture: gl_texture; level: Int32)>(z_FramebufferTexture1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTexture1D(target: FramebufferTarget; attachment: FramebufferAttachment; textarget: TextureTarget; texture: gl_texture; level: Int32) :=
    z_FramebufferTexture1D_1(target, attachment, textarget, texture, level);
    
    private z_FramebufferTexture2D_adr := GetProcAddress('glFramebufferTexture2D');
    private z_FramebufferTexture2D_1 := GetProcOrNil&<procedure(target: FramebufferTarget; attachment: FramebufferAttachment; textarget: TextureTarget; texture: gl_texture; level: Int32)>(z_FramebufferTexture2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTexture2D(target: FramebufferTarget; attachment: FramebufferAttachment; textarget: TextureTarget; texture: gl_texture; level: Int32) :=
    z_FramebufferTexture2D_1(target, attachment, textarget, texture, level);
    
    private z_FramebufferTexture3D_adr := GetProcAddress('glFramebufferTexture3D');
    private z_FramebufferTexture3D_1 := GetProcOrNil&<procedure(target: FramebufferTarget; attachment: FramebufferAttachment; textarget: TextureTarget; texture: gl_texture; level: Int32; zoffset: Int32)>(z_FramebufferTexture3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTexture3D(target: FramebufferTarget; attachment: FramebufferAttachment; textarget: TextureTarget; texture: gl_texture; level: Int32; zoffset: Int32) :=
    z_FramebufferTexture3D_1(target, attachment, textarget, texture, level, zoffset);
    
    private z_FramebufferRenderbuffer_adr := GetProcAddress('glFramebufferRenderbuffer');
    private z_FramebufferRenderbuffer_1 := GetProcOrNil&<procedure(target: FramebufferTarget; attachment: FramebufferAttachment; _renderbuffertarget: RenderbufferTarget; renderbuffer: gl_renderbuffer)>(z_FramebufferRenderbuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferRenderbuffer(target: FramebufferTarget; attachment: FramebufferAttachment; _renderbuffertarget: RenderbufferTarget; renderbuffer: gl_renderbuffer) :=
    z_FramebufferRenderbuffer_1(target, attachment, _renderbuffertarget, renderbuffer);
    
    private z_GetFramebufferAttachmentParameteriv_adr := GetProcAddress('glGetFramebufferAttachmentParameteriv');
    private z_GetFramebufferAttachmentParameteriv_1 := GetProcOrNil&<procedure(target: FramebufferTarget; attachment: FramebufferAttachment; pname: FramebufferAttachmentParameterName; &params: IntPtr)>(z_GetFramebufferAttachmentParameteriv_adr);
    private z_GetFramebufferAttachmentParameteriv_2 := GetProcOrNil&<procedure(target: FramebufferTarget; attachment: FramebufferAttachment; pname: FramebufferAttachmentParameterName; var &params: Int32)>(z_GetFramebufferAttachmentParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferAttachmentParameteriv(target: FramebufferTarget; attachment: FramebufferAttachment; pname: FramebufferAttachmentParameterName; var &params: Int32) :=
    z_GetFramebufferAttachmentParameteriv_2(target, attachment, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferAttachmentParameteriv(target: FramebufferTarget; attachment: FramebufferAttachment; pname: FramebufferAttachmentParameterName; &params: IntPtr) :=
    z_GetFramebufferAttachmentParameteriv_1(target, attachment, pname, &params);
    
    private z_GenerateMipmap_adr := GetProcAddress('glGenerateMipmap');
    private z_GenerateMipmap_1 := GetProcOrNil&<procedure(target: TextureTarget)>(z_GenerateMipmap_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenerateMipmap(target: TextureTarget) :=
    z_GenerateMipmap_1(target);
    
    private z_BlitFramebuffer_adr := GetProcAddress('glBlitFramebuffer');
    private z_BlitFramebuffer_1 := GetProcOrNil&<procedure(srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: ClearBufferMask; filter: BlitFramebufferFilter)>(z_BlitFramebuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlitFramebuffer(srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: ClearBufferMask; filter: BlitFramebufferFilter) :=
    z_BlitFramebuffer_1(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    
    private z_RenderbufferStorageMultisample_adr := GetProcAddress('glRenderbufferStorageMultisample');
    private z_RenderbufferStorageMultisample_1 := GetProcOrNil&<procedure(target: RenderbufferTarget; samples: Int32; _internalformat: InternalFormat; width: Int32; height: Int32)>(z_RenderbufferStorageMultisample_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RenderbufferStorageMultisample(target: RenderbufferTarget; samples: Int32; _internalformat: InternalFormat; width: Int32; height: Int32) :=
    z_RenderbufferStorageMultisample_1(target, samples, _internalformat, width, height);
    
    private z_FramebufferTextureLayer_adr := GetProcAddress('glFramebufferTextureLayer');
    private z_FramebufferTextureLayer_1 := GetProcOrNil&<procedure(target: FramebufferTarget; attachment: FramebufferAttachment; texture: gl_texture; level: Int32; layer: Int32)>(z_FramebufferTextureLayer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTextureLayer(target: FramebufferTarget; attachment: FramebufferAttachment; texture: gl_texture; level: Int32; layer: Int32) :=
    z_FramebufferTextureLayer_1(target, attachment, texture, level, layer);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glGeometryShader4ARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_geometry_shader4';
    
    private z_ProgramParameteriARB_adr := GetProcAddress('glProgramParameteriARB');
    private z_ProgramParameteriARB_1 := GetProcOrNil&<procedure(&program: gl_program; pname: ProgramParameterPName; value: Int32)>(z_ProgramParameteriARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameteriARB(&program: gl_program; pname: ProgramParameterPName; value: Int32) :=
    z_ProgramParameteriARB_1(&program, pname, value);
    
    private z_FramebufferTextureARB_adr := GetProcAddress('glFramebufferTextureARB');
    private z_FramebufferTextureARB_1 := GetProcOrNil&<procedure(target: FramebufferTarget; attachment: FramebufferAttachment; texture: gl_texture; level: Int32)>(z_FramebufferTextureARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTextureARB(target: FramebufferTarget; attachment: FramebufferAttachment; texture: gl_texture; level: Int32) :=
    z_FramebufferTextureARB_1(target, attachment, texture, level);
    
    private z_FramebufferTextureLayerARB_adr := GetProcAddress('glFramebufferTextureLayerARB');
    private z_FramebufferTextureLayerARB_1 := GetProcOrNil&<procedure(target: FramebufferTarget; attachment: FramebufferAttachment; texture: gl_texture; level: Int32; layer: Int32)>(z_FramebufferTextureLayerARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTextureLayerARB(target: FramebufferTarget; attachment: FramebufferAttachment; texture: gl_texture; level: Int32; layer: Int32) :=
    z_FramebufferTextureLayerARB_1(target, attachment, texture, level, layer);
    
    private z_FramebufferTextureFaceARB_adr := GetProcAddress('glFramebufferTextureFaceARB');
    private z_FramebufferTextureFaceARB_1 := GetProcOrNil&<procedure(target: FramebufferTarget; attachment: FramebufferAttachment; texture: gl_texture; level: Int32; face: TextureTarget)>(z_FramebufferTextureFaceARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTextureFaceARB(target: FramebufferTarget; attachment: FramebufferAttachment; texture: gl_texture; level: Int32; face: TextureTarget) :=
    z_FramebufferTextureFaceARB_1(target, attachment, texture, level, face);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glGetProgramBinaryARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_get_program_binary';
    
    private z_GetProgramBinary_adr := GetProcAddress('glGetProgramBinary');
    private z_GetProgramBinary_1 := GetProcOrNil&<procedure(&program: gl_program; bufSize: Int32; length: IntPtr; binaryFormat: IntPtr; binary: IntPtr)>(z_GetProgramBinary_adr);
    private z_GetProgramBinary_2 := GetProcOrNil&<procedure(&program: gl_program; bufSize: Int32; length: IntPtr; var binaryFormat: DummyEnum; binary: IntPtr)>(z_GetProgramBinary_adr);
    private z_GetProgramBinary_3 := GetProcOrNil&<procedure(&program: gl_program; bufSize: Int32; var length: Int32; binaryFormat: IntPtr; binary: IntPtr)>(z_GetProgramBinary_adr);
    private z_GetProgramBinary_4 := GetProcOrNil&<procedure(&program: gl_program; bufSize: Int32; var length: Int32; var binaryFormat: DummyEnum; binary: IntPtr)>(z_GetProgramBinary_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramBinary(&program: gl_program; bufSize: Int32; var length: Int32; var binaryFormat: DummyEnum; binary: IntPtr) :=
    z_GetProgramBinary_4(&program, bufSize, length, binaryFormat, binary);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramBinary(&program: gl_program; bufSize: Int32; var length: Int32; binaryFormat: IntPtr; binary: IntPtr) :=
    z_GetProgramBinary_3(&program, bufSize, length, binaryFormat, binary);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramBinary(&program: gl_program; bufSize: Int32; length: IntPtr; var binaryFormat: DummyEnum; binary: IntPtr) :=
    z_GetProgramBinary_2(&program, bufSize, length, binaryFormat, binary);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramBinary(&program: gl_program; bufSize: Int32; length: IntPtr; binaryFormat: IntPtr; binary: IntPtr) :=
    z_GetProgramBinary_1(&program, bufSize, length, binaryFormat, binary);
    
    private z_ProgramBinary_adr := GetProcAddress('glProgramBinary');
    private z_ProgramBinary_1 := GetProcOrNil&<procedure(&program: gl_program; binaryFormat: DummyEnum; binary: IntPtr; length: Int32)>(z_ProgramBinary_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBinary(&program: gl_program; binaryFormat: DummyEnum; binary: IntPtr; length: Int32) :=
    z_ProgramBinary_1(&program, binaryFormat, binary, length);
    
    private z_ProgramParameteri_adr := GetProcAddress('glProgramParameteri');
    private z_ProgramParameteri_1 := GetProcOrNil&<procedure(&program: gl_program; pname: ProgramParameterPName; value: Int32)>(z_ProgramParameteri_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameteri(&program: gl_program; pname: ProgramParameterPName; value: Int32) :=
    z_ProgramParameteri_1(&program, pname, value);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glGetTextureSubImageARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_get_texture_sub_image';
    
    private z_GetTextureSubImage_adr := GetProcAddress('glGetTextureSubImage');
    private z_GetTextureSubImage_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: PixelFormat; &type: PixelType; bufSize: Int32; pixels: IntPtr)>(z_GetTextureSubImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureSubImage(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: PixelFormat; &type: PixelType; bufSize: Int32; pixels: IntPtr) :=
    z_GetTextureSubImage_1(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, bufSize, pixels);
    
    private z_GetCompressedTextureSubImage_adr := GetProcAddress('glGetCompressedTextureSubImage');
    private z_GetCompressedTextureSubImage_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; bufSize: Int32; pixels: IntPtr)>(z_GetCompressedTextureSubImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCompressedTextureSubImage(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; bufSize: Int32; pixels: IntPtr) :=
    z_GetCompressedTextureSubImage_1(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glGlSpirvARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_gl_spirv';
    
    private z_SpecializeShaderARB_adr := GetProcAddress('glSpecializeShaderARB');
    private z_SpecializeShaderARB_1 := GetProcOrNil&<procedure(shader: gl_shader; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; pConstantIndex: IntPtr; pConstantValue: IntPtr)>(z_SpecializeShaderARB_adr);
    private z_SpecializeShaderARB_2 := GetProcOrNil&<procedure(shader: gl_shader; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; pConstantIndex: IntPtr; var pConstantValue: UInt32)>(z_SpecializeShaderARB_adr);
    private z_SpecializeShaderARB_3 := GetProcOrNil&<procedure(shader: gl_shader; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; pConstantValue: IntPtr)>(z_SpecializeShaderARB_adr);
    private z_SpecializeShaderARB_4 := GetProcOrNil&<procedure(shader: gl_shader; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; var pConstantValue: UInt32)>(z_SpecializeShaderARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: gl_shader; pEntryPoint: string; numSpecializationConstants: UInt32; pConstantIndex: array of UInt32; pConstantValue: array of UInt32);
    type PUInt32=^UInt32;
    begin
      var pEntryPoint_str_ptr: IntPtr;
      try
        pEntryPoint_str_ptr := Marshal.StringToHGlobalAnsi(pEntryPoint);
        if (pConstantValue<>nil) and (pConstantValue.Length<>0) then
          if (pConstantIndex<>nil) and (pConstantIndex.Length<>0) then
            z_SpecializeShaderARB_4(shader, pEntryPoint_str_ptr, numSpecializationConstants, pConstantIndex[0], pConstantValue[0]) else
            z_SpecializeShaderARB_4(shader, pEntryPoint_str_ptr, numSpecializationConstants, PUInt32(nil)^, pConstantValue[0]) else
          if (pConstantIndex<>nil) and (pConstantIndex.Length<>0) then
            z_SpecializeShaderARB_4(shader, pEntryPoint_str_ptr, numSpecializationConstants, pConstantIndex[0], PUInt32(nil)^) else
            z_SpecializeShaderARB_4(shader, pEntryPoint_str_ptr, numSpecializationConstants, PUInt32(nil)^, PUInt32(nil)^);
      finally
        Marshal.FreeHGlobal(pEntryPoint_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: gl_shader; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; pConstantIndex: array of UInt32; pConstantValue: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (pConstantValue<>nil) and (pConstantValue.Length<>0) then
        if (pConstantIndex<>nil) and (pConstantIndex.Length<>0) then
          z_SpecializeShaderARB_4(shader, pEntryPoint, numSpecializationConstants, pConstantIndex[0], pConstantValue[0]) else
          z_SpecializeShaderARB_4(shader, pEntryPoint, numSpecializationConstants, PUInt32(nil)^, pConstantValue[0]) else
        if (pConstantIndex<>nil) and (pConstantIndex.Length<>0) then
          z_SpecializeShaderARB_4(shader, pEntryPoint, numSpecializationConstants, pConstantIndex[0], PUInt32(nil)^) else
          z_SpecializeShaderARB_4(shader, pEntryPoint, numSpecializationConstants, PUInt32(nil)^, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: gl_shader; pEntryPoint: string; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; var pConstantValue: UInt32);
    begin
      var pEntryPoint_str_ptr: IntPtr;
      try
        pEntryPoint_str_ptr := Marshal.StringToHGlobalAnsi(pEntryPoint);
        z_SpecializeShaderARB_4(shader, pEntryPoint_str_ptr, numSpecializationConstants, pConstantIndex, pConstantValue);
      finally
        Marshal.FreeHGlobal(pEntryPoint_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: gl_shader; pEntryPoint: string; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; pConstantValue: IntPtr);
    begin
      var pEntryPoint_str_ptr: IntPtr;
      try
        pEntryPoint_str_ptr := Marshal.StringToHGlobalAnsi(pEntryPoint);
        z_SpecializeShaderARB_3(shader, pEntryPoint_str_ptr, numSpecializationConstants, pConstantIndex, pConstantValue);
      finally
        Marshal.FreeHGlobal(pEntryPoint_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: gl_shader; pEntryPoint: string; numSpecializationConstants: UInt32; pConstantIndex: IntPtr; var pConstantValue: UInt32);
    begin
      var pEntryPoint_str_ptr: IntPtr;
      try
        pEntryPoint_str_ptr := Marshal.StringToHGlobalAnsi(pEntryPoint);
        z_SpecializeShaderARB_2(shader, pEntryPoint_str_ptr, numSpecializationConstants, pConstantIndex, pConstantValue);
      finally
        Marshal.FreeHGlobal(pEntryPoint_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: gl_shader; pEntryPoint: string; numSpecializationConstants: UInt32; pConstantIndex: IntPtr; pConstantValue: IntPtr);
    begin
      var pEntryPoint_str_ptr: IntPtr;
      try
        pEntryPoint_str_ptr := Marshal.StringToHGlobalAnsi(pEntryPoint);
        z_SpecializeShaderARB_1(shader, pEntryPoint_str_ptr, numSpecializationConstants, pConstantIndex, pConstantValue);
      finally
        Marshal.FreeHGlobal(pEntryPoint_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: gl_shader; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; var pConstantValue: UInt32) :=
    z_SpecializeShaderARB_4(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: gl_shader; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; pConstantValue: IntPtr) :=
    z_SpecializeShaderARB_3(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: gl_shader; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; pConstantIndex: IntPtr; var pConstantValue: UInt32) :=
    z_SpecializeShaderARB_2(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: gl_shader; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; pConstantIndex: IntPtr; pConstantValue: IntPtr) :=
    z_SpecializeShaderARB_1(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glGpuShaderFp64ARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_gpu_shader_fp64';
    
    private z_Uniform1d_adr := GetProcAddress('glUniform1d');
    private z_Uniform1d_1 := GetProcOrNil&<procedure(location: Int32; x: real)>(z_Uniform1d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1d(location: Int32; x: real) :=
    z_Uniform1d_1(location, x);
    
    private z_Uniform2d_adr := GetProcAddress('glUniform2d');
    private z_Uniform2d_1 := GetProcOrNil&<procedure(location: Int32; x: real; y: real)>(z_Uniform2d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2d(location: Int32; x: real; y: real) :=
    z_Uniform2d_1(location, x, y);
    
    private z_Uniform3d_adr := GetProcAddress('glUniform3d');
    private z_Uniform3d_1 := GetProcOrNil&<procedure(location: Int32; x: real; y: real; z: real)>(z_Uniform3d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3d(location: Int32; x: real; y: real; z: real) :=
    z_Uniform3d_1(location, x, y, z);
    
    private z_Uniform4d_adr := GetProcAddress('glUniform4d');
    private z_Uniform4d_1 := GetProcOrNil&<procedure(location: Int32; x: real; y: real; z: real; w: real)>(z_Uniform4d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4d(location: Int32; x: real; y: real; z: real; w: real) :=
    z_Uniform4d_1(location, x, y, z, w);
    
    private z_Uniform1dv_adr := GetProcAddress('glUniform1dv');
    private z_Uniform1dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform1dv_adr);
    private z_Uniform1dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: real)>(z_Uniform1dv_adr);
    private z_Uniform1dv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec1d)>(z_Uniform1dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1dv(location: Int32; count: Int32; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform1dv_2(location, count, value[0]) else
        z_Uniform1dv_2(location, count, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1dv(location: Int32; count: Int32; var value: Vec1d) :=
    z_Uniform1dv_3(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1dv(location: Int32; count: Int32; var value: real) :=
    z_Uniform1dv_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1dv(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform1dv_1(location, count, value);
    
    private z_Uniform2dv_adr := GetProcAddress('glUniform2dv');
    private z_Uniform2dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform2dv_adr);
    private z_Uniform2dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: real)>(z_Uniform2dv_adr);
    private z_Uniform2dv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec2d)>(z_Uniform2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2dv(location: Int32; count: Int32; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform2dv_2(location, count, value[0]) else
        z_Uniform2dv_2(location, count, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2dv(location: Int32; count: Int32; var value: Vec2d) :=
    z_Uniform2dv_3(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2dv(location: Int32; count: Int32; var value: real) :=
    z_Uniform2dv_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2dv(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform2dv_1(location, count, value);
    
    private z_Uniform3dv_adr := GetProcAddress('glUniform3dv');
    private z_Uniform3dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform3dv_adr);
    private z_Uniform3dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: real)>(z_Uniform3dv_adr);
    private z_Uniform3dv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec3d)>(z_Uniform3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3dv(location: Int32; count: Int32; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform3dv_2(location, count, value[0]) else
        z_Uniform3dv_2(location, count, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3dv(location: Int32; count: Int32; var value: Vec3d) :=
    z_Uniform3dv_3(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3dv(location: Int32; count: Int32; var value: real) :=
    z_Uniform3dv_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3dv(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform3dv_1(location, count, value);
    
    private z_Uniform4dv_adr := GetProcAddress('glUniform4dv');
    private z_Uniform4dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform4dv_adr);
    private z_Uniform4dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: real)>(z_Uniform4dv_adr);
    private z_Uniform4dv_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec4d)>(z_Uniform4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4dv(location: Int32; count: Int32; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform4dv_2(location, count, value[0]) else
        z_Uniform4dv_2(location, count, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4dv(location: Int32; count: Int32; var value: Vec4d) :=
    z_Uniform4dv_3(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4dv(location: Int32; count: Int32; var value: real) :=
    z_Uniform4dv_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4dv(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform4dv_1(location, count, value);
    
    private z_UniformMatrix2dv_adr := GetProcAddress('glUniformMatrix2dv');
    private z_UniformMatrix2dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_UniformMatrix2dv_adr);
    private z_UniformMatrix2dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; var value: real)>(z_UniformMatrix2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2dv(location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_UniformMatrix2dv_2(location, count, transpose, value[0]) else
        z_UniformMatrix2dv_2(location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2dv(location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_UniformMatrix2dv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2dv(location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_UniformMatrix2dv_1(location, count, transpose, value);
    
    private z_UniformMatrix3dv_adr := GetProcAddress('glUniformMatrix3dv');
    private z_UniformMatrix3dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_UniformMatrix3dv_adr);
    private z_UniformMatrix3dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; var value: real)>(z_UniformMatrix3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3dv(location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_UniformMatrix3dv_2(location, count, transpose, value[0]) else
        z_UniformMatrix3dv_2(location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3dv(location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_UniformMatrix3dv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3dv(location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_UniformMatrix3dv_1(location, count, transpose, value);
    
    private z_UniformMatrix4dv_adr := GetProcAddress('glUniformMatrix4dv');
    private z_UniformMatrix4dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_UniformMatrix4dv_adr);
    private z_UniformMatrix4dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; var value: real)>(z_UniformMatrix4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4dv(location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_UniformMatrix4dv_2(location, count, transpose, value[0]) else
        z_UniformMatrix4dv_2(location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4dv(location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_UniformMatrix4dv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4dv(location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_UniformMatrix4dv_1(location, count, transpose, value);
    
    private z_UniformMatrix2x3dv_adr := GetProcAddress('glUniformMatrix2x3dv');
    private z_UniformMatrix2x3dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_UniformMatrix2x3dv_adr);
    private z_UniformMatrix2x3dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; var value: real)>(z_UniformMatrix2x3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x3dv(location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_UniformMatrix2x3dv_2(location, count, transpose, value[0]) else
        z_UniformMatrix2x3dv_2(location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x3dv(location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_UniformMatrix2x3dv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x3dv(location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_UniformMatrix2x3dv_1(location, count, transpose, value);
    
    private z_UniformMatrix2x4dv_adr := GetProcAddress('glUniformMatrix2x4dv');
    private z_UniformMatrix2x4dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_UniformMatrix2x4dv_adr);
    private z_UniformMatrix2x4dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; var value: real)>(z_UniformMatrix2x4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x4dv(location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_UniformMatrix2x4dv_2(location, count, transpose, value[0]) else
        z_UniformMatrix2x4dv_2(location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x4dv(location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_UniformMatrix2x4dv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x4dv(location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_UniformMatrix2x4dv_1(location, count, transpose, value);
    
    private z_UniformMatrix3x2dv_adr := GetProcAddress('glUniformMatrix3x2dv');
    private z_UniformMatrix3x2dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_UniformMatrix3x2dv_adr);
    private z_UniformMatrix3x2dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; var value: real)>(z_UniformMatrix3x2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x2dv(location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_UniformMatrix3x2dv_2(location, count, transpose, value[0]) else
        z_UniformMatrix3x2dv_2(location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x2dv(location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_UniformMatrix3x2dv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x2dv(location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_UniformMatrix3x2dv_1(location, count, transpose, value);
    
    private z_UniformMatrix3x4dv_adr := GetProcAddress('glUniformMatrix3x4dv');
    private z_UniformMatrix3x4dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_UniformMatrix3x4dv_adr);
    private z_UniformMatrix3x4dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; var value: real)>(z_UniformMatrix3x4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x4dv(location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_UniformMatrix3x4dv_2(location, count, transpose, value[0]) else
        z_UniformMatrix3x4dv_2(location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x4dv(location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_UniformMatrix3x4dv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x4dv(location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_UniformMatrix3x4dv_1(location, count, transpose, value);
    
    private z_UniformMatrix4x2dv_adr := GetProcAddress('glUniformMatrix4x2dv');
    private z_UniformMatrix4x2dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_UniformMatrix4x2dv_adr);
    private z_UniformMatrix4x2dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; var value: real)>(z_UniformMatrix4x2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x2dv(location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_UniformMatrix4x2dv_2(location, count, transpose, value[0]) else
        z_UniformMatrix4x2dv_2(location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x2dv(location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_UniformMatrix4x2dv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x2dv(location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_UniformMatrix4x2dv_1(location, count, transpose, value);
    
    private z_UniformMatrix4x3dv_adr := GetProcAddress('glUniformMatrix4x3dv');
    private z_UniformMatrix4x3dv_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_UniformMatrix4x3dv_adr);
    private z_UniformMatrix4x3dv_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; var value: real)>(z_UniformMatrix4x3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x3dv(location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_UniformMatrix4x3dv_2(location, count, transpose, value[0]) else
        z_UniformMatrix4x3dv_2(location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x3dv(location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_UniformMatrix4x3dv_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x3dv(location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_UniformMatrix4x3dv_1(location, count, transpose, value);
    
    private z_GetUniformdv_adr := GetProcAddress('glGetUniformdv');
    private z_GetUniformdv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; &params: IntPtr)>(z_GetUniformdv_adr);
    private z_GetUniformdv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; var &params: real)>(z_GetUniformdv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformdv(&program: gl_program; location: Int32; var &params: real) :=
    z_GetUniformdv_2(&program, location, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformdv(&program: gl_program; location: Int32; &params: IntPtr) :=
    z_GetUniformdv_1(&program, location, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glGpuShaderInt64ARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_gpu_shader_int64';
    
    private z_Uniform1i64ARB_adr := GetProcAddress('glUniform1i64ARB');
    private z_Uniform1i64ARB_1 := GetProcOrNil&<procedure(location: Int32; x: Int64)>(z_Uniform1i64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i64ARB(location: Int32; x: Int64) :=
    z_Uniform1i64ARB_1(location, x);
    
    private z_Uniform2i64ARB_adr := GetProcAddress('glUniform2i64ARB');
    private z_Uniform2i64ARB_1 := GetProcOrNil&<procedure(location: Int32; x: Int64; y: Int64)>(z_Uniform2i64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64ARB(location: Int32; x: Int64; y: Int64) :=
    z_Uniform2i64ARB_1(location, x, y);
    
    private z_Uniform3i64ARB_adr := GetProcAddress('glUniform3i64ARB');
    private z_Uniform3i64ARB_1 := GetProcOrNil&<procedure(location: Int32; x: Int64; y: Int64; z: Int64)>(z_Uniform3i64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64ARB(location: Int32; x: Int64; y: Int64; z: Int64) :=
    z_Uniform3i64ARB_1(location, x, y, z);
    
    private z_Uniform4i64ARB_adr := GetProcAddress('glUniform4i64ARB');
    private z_Uniform4i64ARB_1 := GetProcOrNil&<procedure(location: Int32; x: Int64; y: Int64; z: Int64; w: Int64)>(z_Uniform4i64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64ARB(location: Int32; x: Int64; y: Int64; z: Int64; w: Int64) :=
    z_Uniform4i64ARB_1(location, x, y, z, w);
    
    private z_Uniform1i64vARB_adr := GetProcAddress('glUniform1i64vARB');
    private z_Uniform1i64vARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform1i64vARB_adr);
    private z_Uniform1i64vARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int64)>(z_Uniform1i64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i64vARB(location: Int32; count: Int32; value: array of Int64);
    type PInt64=^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform1i64vARB_2(location, count, value[0]) else
        z_Uniform1i64vARB_2(location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i64vARB(location: Int32; count: Int32; var value: Int64) :=
    z_Uniform1i64vARB_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i64vARB(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform1i64vARB_1(location, count, value);
    
    private z_Uniform2i64vARB_adr := GetProcAddress('glUniform2i64vARB');
    private z_Uniform2i64vARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform2i64vARB_adr);
    private z_Uniform2i64vARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int64)>(z_Uniform2i64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64vARB(location: Int32; count: Int32; value: array of Int64);
    type PInt64=^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform2i64vARB_2(location, count, value[0]) else
        z_Uniform2i64vARB_2(location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64vARB(location: Int32; count: Int32; var value: Int64) :=
    z_Uniform2i64vARB_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64vARB(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform2i64vARB_1(location, count, value);
    
    private z_Uniform3i64vARB_adr := GetProcAddress('glUniform3i64vARB');
    private z_Uniform3i64vARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform3i64vARB_adr);
    private z_Uniform3i64vARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int64)>(z_Uniform3i64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64vARB(location: Int32; count: Int32; value: array of Int64);
    type PInt64=^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform3i64vARB_2(location, count, value[0]) else
        z_Uniform3i64vARB_2(location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64vARB(location: Int32; count: Int32; var value: Int64) :=
    z_Uniform3i64vARB_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64vARB(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform3i64vARB_1(location, count, value);
    
    private z_Uniform4i64vARB_adr := GetProcAddress('glUniform4i64vARB');
    private z_Uniform4i64vARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform4i64vARB_adr);
    private z_Uniform4i64vARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int64)>(z_Uniform4i64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64vARB(location: Int32; count: Int32; value: array of Int64);
    type PInt64=^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform4i64vARB_2(location, count, value[0]) else
        z_Uniform4i64vARB_2(location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64vARB(location: Int32; count: Int32; var value: Int64) :=
    z_Uniform4i64vARB_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64vARB(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform4i64vARB_1(location, count, value);
    
    private z_Uniform1ui64ARB_adr := GetProcAddress('glUniform1ui64ARB');
    private z_Uniform1ui64ARB_1 := GetProcOrNil&<procedure(location: Int32; x: UInt64)>(z_Uniform1ui64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui64ARB(location: Int32; x: UInt64) :=
    z_Uniform1ui64ARB_1(location, x);
    
    private z_Uniform2ui64ARB_adr := GetProcAddress('glUniform2ui64ARB');
    private z_Uniform2ui64ARB_1 := GetProcOrNil&<procedure(location: Int32; x: UInt64; y: UInt64)>(z_Uniform2ui64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64ARB(location: Int32; x: UInt64; y: UInt64) :=
    z_Uniform2ui64ARB_1(location, x, y);
    
    private z_Uniform3ui64ARB_adr := GetProcAddress('glUniform3ui64ARB');
    private z_Uniform3ui64ARB_1 := GetProcOrNil&<procedure(location: Int32; x: UInt64; y: UInt64; z: UInt64)>(z_Uniform3ui64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64ARB(location: Int32; x: UInt64; y: UInt64; z: UInt64) :=
    z_Uniform3ui64ARB_1(location, x, y, z);
    
    private z_Uniform4ui64ARB_adr := GetProcAddress('glUniform4ui64ARB');
    private z_Uniform4ui64ARB_1 := GetProcOrNil&<procedure(location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64)>(z_Uniform4ui64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64ARB(location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64) :=
    z_Uniform4ui64ARB_1(location, x, y, z, w);
    
    private z_Uniform1ui64vARB_adr := GetProcAddress('glUniform1ui64vARB');
    private z_Uniform1ui64vARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform1ui64vARB_adr);
    private z_Uniform1ui64vARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt64)>(z_Uniform1ui64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui64vARB(location: Int32; count: Int32; value: array of UInt64);
    type PUInt64=^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform1ui64vARB_2(location, count, value[0]) else
        z_Uniform1ui64vARB_2(location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui64vARB(location: Int32; count: Int32; var value: UInt64) :=
    z_Uniform1ui64vARB_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui64vARB(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform1ui64vARB_1(location, count, value);
    
    private z_Uniform2ui64vARB_adr := GetProcAddress('glUniform2ui64vARB');
    private z_Uniform2ui64vARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform2ui64vARB_adr);
    private z_Uniform2ui64vARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt64)>(z_Uniform2ui64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64vARB(location: Int32; count: Int32; value: array of UInt64);
    type PUInt64=^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform2ui64vARB_2(location, count, value[0]) else
        z_Uniform2ui64vARB_2(location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64vARB(location: Int32; count: Int32; var value: UInt64) :=
    z_Uniform2ui64vARB_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64vARB(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform2ui64vARB_1(location, count, value);
    
    private z_Uniform3ui64vARB_adr := GetProcAddress('glUniform3ui64vARB');
    private z_Uniform3ui64vARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform3ui64vARB_adr);
    private z_Uniform3ui64vARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt64)>(z_Uniform3ui64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64vARB(location: Int32; count: Int32; value: array of UInt64);
    type PUInt64=^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform3ui64vARB_2(location, count, value[0]) else
        z_Uniform3ui64vARB_2(location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64vARB(location: Int32; count: Int32; var value: UInt64) :=
    z_Uniform3ui64vARB_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64vARB(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform3ui64vARB_1(location, count, value);
    
    private z_Uniform4ui64vARB_adr := GetProcAddress('glUniform4ui64vARB');
    private z_Uniform4ui64vARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform4ui64vARB_adr);
    private z_Uniform4ui64vARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt64)>(z_Uniform4ui64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64vARB(location: Int32; count: Int32; value: array of UInt64);
    type PUInt64=^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform4ui64vARB_2(location, count, value[0]) else
        z_Uniform4ui64vARB_2(location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64vARB(location: Int32; count: Int32; var value: UInt64) :=
    z_Uniform4ui64vARB_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64vARB(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform4ui64vARB_1(location, count, value);
    
    private z_GetUniformi64vARB_adr := GetProcAddress('glGetUniformi64vARB');
    private z_GetUniformi64vARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; &params: IntPtr)>(z_GetUniformi64vARB_adr);
    private z_GetUniformi64vARB_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; var &params: Int64)>(z_GetUniformi64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformi64vARB(&program: gl_program; location: Int32; var &params: Int64) :=
    z_GetUniformi64vARB_2(&program, location, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformi64vARB(&program: gl_program; location: Int32; &params: IntPtr) :=
    z_GetUniformi64vARB_1(&program, location, &params);
    
    private z_GetUniformui64vARB_adr := GetProcAddress('glGetUniformui64vARB');
    private z_GetUniformui64vARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; &params: IntPtr)>(z_GetUniformui64vARB_adr);
    private z_GetUniformui64vARB_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; var &params: UInt64)>(z_GetUniformui64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformui64vARB(&program: gl_program; location: Int32; var &params: UInt64) :=
    z_GetUniformui64vARB_2(&program, location, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformui64vARB(&program: gl_program; location: Int32; &params: IntPtr) :=
    z_GetUniformui64vARB_1(&program, location, &params);
    
    private z_GetnUniformi64vARB_adr := GetProcAddress('glGetnUniformi64vARB');
    private z_GetnUniformi64vARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr)>(z_GetnUniformi64vARB_adr);
    private z_GetnUniformi64vARB_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; var &params: Int64)>(z_GetnUniformi64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformi64vARB(&program: gl_program; location: Int32; bufSize: Int32; var &params: Int64) :=
    z_GetnUniformi64vARB_2(&program, location, bufSize, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformi64vARB(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr) :=
    z_GetnUniformi64vARB_1(&program, location, bufSize, &params);
    
    private z_GetnUniformui64vARB_adr := GetProcAddress('glGetnUniformui64vARB');
    private z_GetnUniformui64vARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr)>(z_GetnUniformui64vARB_adr);
    private z_GetnUniformui64vARB_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; var &params: UInt64)>(z_GetnUniformui64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformui64vARB(&program: gl_program; location: Int32; bufSize: Int32; var &params: UInt64) :=
    z_GetnUniformui64vARB_2(&program, location, bufSize, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformui64vARB(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr) :=
    z_GetnUniformui64vARB_1(&program, location, bufSize, &params);
    
    private z_ProgramUniform1i64ARB_adr := GetProcAddress('glProgramUniform1i64ARB');
    private z_ProgramUniform1i64ARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: Int64)>(z_ProgramUniform1i64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i64ARB(&program: gl_program; location: Int32; x: Int64) :=
    z_ProgramUniform1i64ARB_1(&program, location, x);
    
    private z_ProgramUniform2i64ARB_adr := GetProcAddress('glProgramUniform2i64ARB');
    private z_ProgramUniform2i64ARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: Int64; y: Int64)>(z_ProgramUniform2i64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64ARB(&program: gl_program; location: Int32; x: Int64; y: Int64) :=
    z_ProgramUniform2i64ARB_1(&program, location, x, y);
    
    private z_ProgramUniform3i64ARB_adr := GetProcAddress('glProgramUniform3i64ARB');
    private z_ProgramUniform3i64ARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: Int64; y: Int64; z: Int64)>(z_ProgramUniform3i64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64ARB(&program: gl_program; location: Int32; x: Int64; y: Int64; z: Int64) :=
    z_ProgramUniform3i64ARB_1(&program, location, x, y, z);
    
    private z_ProgramUniform4i64ARB_adr := GetProcAddress('glProgramUniform4i64ARB');
    private z_ProgramUniform4i64ARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: Int64; y: Int64; z: Int64; w: Int64)>(z_ProgramUniform4i64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64ARB(&program: gl_program; location: Int32; x: Int64; y: Int64; z: Int64; w: Int64) :=
    z_ProgramUniform4i64ARB_1(&program, location, x, y, z, w);
    
    private z_ProgramUniform1i64vARB_adr := GetProcAddress('glProgramUniform1i64vARB');
    private z_ProgramUniform1i64vARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform1i64vARB_adr);
    private z_ProgramUniform1i64vARB_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int64)>(z_ProgramUniform1i64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i64vARB(&program: gl_program; location: Int32; count: Int32; value: array of Int64);
    type PInt64=^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform1i64vARB_2(&program, location, count, value[0]) else
        z_ProgramUniform1i64vARB_2(&program, location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i64vARB(&program: gl_program; location: Int32; count: Int32; var value: Int64) :=
    z_ProgramUniform1i64vARB_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i64vARB(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform1i64vARB_1(&program, location, count, value);
    
    private z_ProgramUniform2i64vARB_adr := GetProcAddress('glProgramUniform2i64vARB');
    private z_ProgramUniform2i64vARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform2i64vARB_adr);
    private z_ProgramUniform2i64vARB_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int64)>(z_ProgramUniform2i64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64vARB(&program: gl_program; location: Int32; count: Int32; value: array of Int64);
    type PInt64=^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform2i64vARB_2(&program, location, count, value[0]) else
        z_ProgramUniform2i64vARB_2(&program, location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64vARB(&program: gl_program; location: Int32; count: Int32; var value: Int64) :=
    z_ProgramUniform2i64vARB_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64vARB(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform2i64vARB_1(&program, location, count, value);
    
    private z_ProgramUniform3i64vARB_adr := GetProcAddress('glProgramUniform3i64vARB');
    private z_ProgramUniform3i64vARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform3i64vARB_adr);
    private z_ProgramUniform3i64vARB_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int64)>(z_ProgramUniform3i64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64vARB(&program: gl_program; location: Int32; count: Int32; value: array of Int64);
    type PInt64=^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform3i64vARB_2(&program, location, count, value[0]) else
        z_ProgramUniform3i64vARB_2(&program, location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64vARB(&program: gl_program; location: Int32; count: Int32; var value: Int64) :=
    z_ProgramUniform3i64vARB_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64vARB(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform3i64vARB_1(&program, location, count, value);
    
    private z_ProgramUniform4i64vARB_adr := GetProcAddress('glProgramUniform4i64vARB');
    private z_ProgramUniform4i64vARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform4i64vARB_adr);
    private z_ProgramUniform4i64vARB_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int64)>(z_ProgramUniform4i64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64vARB(&program: gl_program; location: Int32; count: Int32; value: array of Int64);
    type PInt64=^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform4i64vARB_2(&program, location, count, value[0]) else
        z_ProgramUniform4i64vARB_2(&program, location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64vARB(&program: gl_program; location: Int32; count: Int32; var value: Int64) :=
    z_ProgramUniform4i64vARB_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64vARB(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform4i64vARB_1(&program, location, count, value);
    
    private z_ProgramUniform1ui64ARB_adr := GetProcAddress('glProgramUniform1ui64ARB');
    private z_ProgramUniform1ui64ARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: UInt64)>(z_ProgramUniform1ui64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui64ARB(&program: gl_program; location: Int32; x: UInt64) :=
    z_ProgramUniform1ui64ARB_1(&program, location, x);
    
    private z_ProgramUniform2ui64ARB_adr := GetProcAddress('glProgramUniform2ui64ARB');
    private z_ProgramUniform2ui64ARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: UInt64; y: UInt64)>(z_ProgramUniform2ui64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64ARB(&program: gl_program; location: Int32; x: UInt64; y: UInt64) :=
    z_ProgramUniform2ui64ARB_1(&program, location, x, y);
    
    private z_ProgramUniform3ui64ARB_adr := GetProcAddress('glProgramUniform3ui64ARB');
    private z_ProgramUniform3ui64ARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: UInt64; y: UInt64; z: UInt64)>(z_ProgramUniform3ui64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64ARB(&program: gl_program; location: Int32; x: UInt64; y: UInt64; z: UInt64) :=
    z_ProgramUniform3ui64ARB_1(&program, location, x, y, z);
    
    private z_ProgramUniform4ui64ARB_adr := GetProcAddress('glProgramUniform4ui64ARB');
    private z_ProgramUniform4ui64ARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64)>(z_ProgramUniform4ui64ARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64ARB(&program: gl_program; location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64) :=
    z_ProgramUniform4ui64ARB_1(&program, location, x, y, z, w);
    
    private z_ProgramUniform1ui64vARB_adr := GetProcAddress('glProgramUniform1ui64vARB');
    private z_ProgramUniform1ui64vARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform1ui64vARB_adr);
    private z_ProgramUniform1ui64vARB_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt64)>(z_ProgramUniform1ui64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui64vARB(&program: gl_program; location: Int32; count: Int32; value: array of UInt64);
    type PUInt64=^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform1ui64vARB_2(&program, location, count, value[0]) else
        z_ProgramUniform1ui64vARB_2(&program, location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui64vARB(&program: gl_program; location: Int32; count: Int32; var value: UInt64) :=
    z_ProgramUniform1ui64vARB_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui64vARB(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform1ui64vARB_1(&program, location, count, value);
    
    private z_ProgramUniform2ui64vARB_adr := GetProcAddress('glProgramUniform2ui64vARB');
    private z_ProgramUniform2ui64vARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform2ui64vARB_adr);
    private z_ProgramUniform2ui64vARB_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt64)>(z_ProgramUniform2ui64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64vARB(&program: gl_program; location: Int32; count: Int32; value: array of UInt64);
    type PUInt64=^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform2ui64vARB_2(&program, location, count, value[0]) else
        z_ProgramUniform2ui64vARB_2(&program, location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64vARB(&program: gl_program; location: Int32; count: Int32; var value: UInt64) :=
    z_ProgramUniform2ui64vARB_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64vARB(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform2ui64vARB_1(&program, location, count, value);
    
    private z_ProgramUniform3ui64vARB_adr := GetProcAddress('glProgramUniform3ui64vARB');
    private z_ProgramUniform3ui64vARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform3ui64vARB_adr);
    private z_ProgramUniform3ui64vARB_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt64)>(z_ProgramUniform3ui64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64vARB(&program: gl_program; location: Int32; count: Int32; value: array of UInt64);
    type PUInt64=^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform3ui64vARB_2(&program, location, count, value[0]) else
        z_ProgramUniform3ui64vARB_2(&program, location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64vARB(&program: gl_program; location: Int32; count: Int32; var value: UInt64) :=
    z_ProgramUniform3ui64vARB_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64vARB(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform3ui64vARB_1(&program, location, count, value);
    
    private z_ProgramUniform4ui64vARB_adr := GetProcAddress('glProgramUniform4ui64vARB');
    private z_ProgramUniform4ui64vARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform4ui64vARB_adr);
    private z_ProgramUniform4ui64vARB_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt64)>(z_ProgramUniform4ui64vARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64vARB(&program: gl_program; location: Int32; count: Int32; value: array of UInt64);
    type PUInt64=^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform4ui64vARB_2(&program, location, count, value[0]) else
        z_ProgramUniform4ui64vARB_2(&program, location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64vARB(&program: gl_program; location: Int32; count: Int32; var value: UInt64) :=
    z_ProgramUniform4ui64vARB_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64vARB(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform4ui64vARB_1(&program, location, count, value);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glImagingARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_imaging';
    
    private z_BlendColor_adr := GetProcAddress('glBlendColor');
    private z_BlendColor_1 := GetProcOrNil&<procedure(red: single; green: single; blue: single; alpha: single)>(z_BlendColor_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendColor(red: single; green: single; blue: single; alpha: single) :=
    z_BlendColor_1(red, green, blue, alpha);
    
    private z_BlendEquation_adr := GetProcAddress('glBlendEquation');
    private z_BlendEquation_1 := GetProcOrNil&<procedure(mode: BlendEquationMode)>(z_BlendEquation_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquation(mode: BlendEquationMode) :=
    z_BlendEquation_1(mode);
    
    private z_ColorTable_adr := GetProcAddress('glColorTable');
    private z_ColorTable_1 := GetProcOrNil&<procedure(target: ColorTableTarget; _internalformat: InternalFormat; width: Int32; format: PixelFormat; &type: PixelType; table: IntPtr)>(z_ColorTable_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTable(target: ColorTableTarget; _internalformat: InternalFormat; width: Int32; format: PixelFormat; &type: PixelType; table: IntPtr) :=
    z_ColorTable_1(target, _internalformat, width, format, &type, table);
    
    private z_ColorTableParameterfv_adr := GetProcAddress('glColorTableParameterfv');
    private z_ColorTableParameterfv_1 := GetProcOrNil&<procedure(target: ColorTableTarget; pname: ColorTableParameterPName; &params: IntPtr)>(z_ColorTableParameterfv_adr);
    private z_ColorTableParameterfv_2 := GetProcOrNil&<procedure(target: ColorTableTarget; pname: ColorTableParameterPName; var &params: single)>(z_ColorTableParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameterfv(target: ColorTableTarget; pname: ColorTableParameterPName; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_ColorTableParameterfv_2(target, pname, &params[0]) else
        z_ColorTableParameterfv_2(target, pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameterfv(target: ColorTableTarget; pname: ColorTableParameterPName; var &params: single) :=
    z_ColorTableParameterfv_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameterfv(target: ColorTableTarget; pname: ColorTableParameterPName; &params: IntPtr) :=
    z_ColorTableParameterfv_1(target, pname, &params);
    
    private z_ColorTableParameteriv_adr := GetProcAddress('glColorTableParameteriv');
    private z_ColorTableParameteriv_1 := GetProcOrNil&<procedure(target: ColorTableTarget; pname: ColorTableParameterPName; &params: IntPtr)>(z_ColorTableParameteriv_adr);
    private z_ColorTableParameteriv_2 := GetProcOrNil&<procedure(target: ColorTableTarget; pname: ColorTableParameterPName; var &params: Int32)>(z_ColorTableParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameteriv(target: ColorTableTarget; pname: ColorTableParameterPName; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_ColorTableParameteriv_2(target, pname, &params[0]) else
        z_ColorTableParameteriv_2(target, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameteriv(target: ColorTableTarget; pname: ColorTableParameterPName; var &params: Int32) :=
    z_ColorTableParameteriv_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameteriv(target: ColorTableTarget; pname: ColorTableParameterPName; &params: IntPtr) :=
    z_ColorTableParameteriv_1(target, pname, &params);
    
    private z_CopyColorTable_adr := GetProcAddress('glCopyColorTable');
    private z_CopyColorTable_1 := GetProcOrNil&<procedure(target: ColorTableTarget; _internalformat: InternalFormat; x: Int32; y: Int32; width: Int32)>(z_CopyColorTable_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyColorTable(target: ColorTableTarget; _internalformat: InternalFormat; x: Int32; y: Int32; width: Int32) :=
    z_CopyColorTable_1(target, _internalformat, x, y, width);
    
    private z_GetColorTable_adr := GetProcAddress('glGetColorTable');
    private z_GetColorTable_1 := GetProcOrNil&<procedure(target: ColorTableTarget; format: PixelFormat; &type: PixelType; table: IntPtr)>(z_GetColorTable_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTable(target: ColorTableTarget; format: PixelFormat; &type: PixelType; table: IntPtr) :=
    z_GetColorTable_1(target, format, &type, table);
    
    private z_GetColorTableParameterfv_adr := GetProcAddress('glGetColorTableParameterfv');
    private z_GetColorTableParameterfv_1 := GetProcOrNil&<procedure(target: ColorTableTarget; pname: ColorTableParameterPName; &params: IntPtr)>(z_GetColorTableParameterfv_adr);
    private z_GetColorTableParameterfv_2 := GetProcOrNil&<procedure(target: ColorTableTarget; pname: ColorTableParameterPName; var &params: single)>(z_GetColorTableParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterfv(target: ColorTableTarget; pname: ColorTableParameterPName; var &params: single) :=
    z_GetColorTableParameterfv_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterfv(target: ColorTableTarget; pname: ColorTableParameterPName; &params: IntPtr) :=
    z_GetColorTableParameterfv_1(target, pname, &params);
    
    private z_GetColorTableParameteriv_adr := GetProcAddress('glGetColorTableParameteriv');
    private z_GetColorTableParameteriv_1 := GetProcOrNil&<procedure(target: ColorTableTarget; pname: ColorTableParameterPName; &params: IntPtr)>(z_GetColorTableParameteriv_adr);
    private z_GetColorTableParameteriv_2 := GetProcOrNil&<procedure(target: ColorTableTarget; pname: ColorTableParameterPName; var &params: Int32)>(z_GetColorTableParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameteriv(target: ColorTableTarget; pname: ColorTableParameterPName; var &params: Int32) :=
    z_GetColorTableParameteriv_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameteriv(target: ColorTableTarget; pname: ColorTableParameterPName; &params: IntPtr) :=
    z_GetColorTableParameteriv_1(target, pname, &params);
    
    private z_ColorSubTable_adr := GetProcAddress('glColorSubTable');
    private z_ColorSubTable_1 := GetProcOrNil&<procedure(target: ColorTableTarget; start: Int32; count: Int32; format: PixelFormat; &type: PixelType; data: IntPtr)>(z_ColorSubTable_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorSubTable(target: ColorTableTarget; start: Int32; count: Int32; format: PixelFormat; &type: PixelType; data: IntPtr) :=
    z_ColorSubTable_1(target, start, count, format, &type, data);
    
    private z_CopyColorSubTable_adr := GetProcAddress('glCopyColorSubTable');
    private z_CopyColorSubTable_1 := GetProcOrNil&<procedure(target: ColorTableTarget; start: Int32; x: Int32; y: Int32; width: Int32)>(z_CopyColorSubTable_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyColorSubTable(target: ColorTableTarget; start: Int32; x: Int32; y: Int32; width: Int32) :=
    z_CopyColorSubTable_1(target, start, x, y, width);
    
    private z_ConvolutionFilter1D_adr := GetProcAddress('glConvolutionFilter1D');
    private z_ConvolutionFilter1D_1 := GetProcOrNil&<procedure(target: ConvolutionTarget; _internalformat: InternalFormat; width: Int32; format: PixelFormat; &type: PixelType; image: IntPtr)>(z_ConvolutionFilter1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionFilter1D(target: ConvolutionTarget; _internalformat: InternalFormat; width: Int32; format: PixelFormat; &type: PixelType; image: IntPtr) :=
    z_ConvolutionFilter1D_1(target, _internalformat, width, format, &type, image);
    
    private z_ConvolutionFilter2D_adr := GetProcAddress('glConvolutionFilter2D');
    private z_ConvolutionFilter2D_1 := GetProcOrNil&<procedure(target: ConvolutionTarget; _internalformat: InternalFormat; width: Int32; height: Int32; format: PixelFormat; &type: PixelType; image: IntPtr)>(z_ConvolutionFilter2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionFilter2D(target: ConvolutionTarget; _internalformat: InternalFormat; width: Int32; height: Int32; format: PixelFormat; &type: PixelType; image: IntPtr) :=
    z_ConvolutionFilter2D_1(target, _internalformat, width, height, format, &type, image);
    
    private z_ConvolutionParameterf_adr := GetProcAddress('glConvolutionParameterf');
    private z_ConvolutionParameterf_1 := GetProcOrNil&<procedure(target: ConvolutionTarget; pname: ConvolutionParameter; &params: single)>(z_ConvolutionParameterf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterf(target: ConvolutionTarget; pname: ConvolutionParameter; &params: single) :=
    z_ConvolutionParameterf_1(target, pname, &params);
    
    private z_ConvolutionParameterfv_adr := GetProcAddress('glConvolutionParameterfv');
    private z_ConvolutionParameterfv_1 := GetProcOrNil&<procedure(target: ConvolutionTarget; pname: ConvolutionParameter; &params: IntPtr)>(z_ConvolutionParameterfv_adr);
    private z_ConvolutionParameterfv_2 := GetProcOrNil&<procedure(target: ConvolutionTarget; pname: ConvolutionParameter; var &params: single)>(z_ConvolutionParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterfv(target: ConvolutionTarget; pname: ConvolutionParameter; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_ConvolutionParameterfv_2(target, pname, &params[0]) else
        z_ConvolutionParameterfv_2(target, pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterfv(target: ConvolutionTarget; pname: ConvolutionParameter; var &params: single) :=
    z_ConvolutionParameterfv_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterfv(target: ConvolutionTarget; pname: ConvolutionParameter; &params: IntPtr) :=
    z_ConvolutionParameterfv_1(target, pname, &params);
    
    private z_ConvolutionParameteri_adr := GetProcAddress('glConvolutionParameteri');
    private z_ConvolutionParameteri_1 := GetProcOrNil&<procedure(target: ConvolutionTarget; pname: ConvolutionParameter; &params: Int32)>(z_ConvolutionParameteri_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameteri(target: ConvolutionTarget; pname: ConvolutionParameter; &params: Int32) :=
    z_ConvolutionParameteri_1(target, pname, &params);
    
    private z_ConvolutionParameteriv_adr := GetProcAddress('glConvolutionParameteriv');
    private z_ConvolutionParameteriv_1 := GetProcOrNil&<procedure(target: ConvolutionTarget; pname: ConvolutionParameter; &params: IntPtr)>(z_ConvolutionParameteriv_adr);
    private z_ConvolutionParameteriv_2 := GetProcOrNil&<procedure(target: ConvolutionTarget; pname: ConvolutionParameter; var &params: Int32)>(z_ConvolutionParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameteriv(target: ConvolutionTarget; pname: ConvolutionParameter; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_ConvolutionParameteriv_2(target, pname, &params[0]) else
        z_ConvolutionParameteriv_2(target, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameteriv(target: ConvolutionTarget; pname: ConvolutionParameter; var &params: Int32) :=
    z_ConvolutionParameteriv_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameteriv(target: ConvolutionTarget; pname: ConvolutionParameter; &params: IntPtr) :=
    z_ConvolutionParameteriv_1(target, pname, &params);
    
    private z_CopyConvolutionFilter1D_adr := GetProcAddress('glCopyConvolutionFilter1D');
    private z_CopyConvolutionFilter1D_1 := GetProcOrNil&<procedure(target: ConvolutionTarget; _internalformat: InternalFormat; x: Int32; y: Int32; width: Int32)>(z_CopyConvolutionFilter1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyConvolutionFilter1D(target: ConvolutionTarget; _internalformat: InternalFormat; x: Int32; y: Int32; width: Int32) :=
    z_CopyConvolutionFilter1D_1(target, _internalformat, x, y, width);
    
    private z_CopyConvolutionFilter2D_adr := GetProcAddress('glCopyConvolutionFilter2D');
    private z_CopyConvolutionFilter2D_1 := GetProcOrNil&<procedure(target: ConvolutionTarget; _internalformat: InternalFormat; x: Int32; y: Int32; width: Int32; height: Int32)>(z_CopyConvolutionFilter2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyConvolutionFilter2D(target: ConvolutionTarget; _internalformat: InternalFormat; x: Int32; y: Int32; width: Int32; height: Int32) :=
    z_CopyConvolutionFilter2D_1(target, _internalformat, x, y, width, height);
    
    private z_GetConvolutionFilter_adr := GetProcAddress('glGetConvolutionFilter');
    private z_GetConvolutionFilter_1 := GetProcOrNil&<procedure(target: ConvolutionTarget; format: PixelFormat; &type: PixelType; image: IntPtr)>(z_GetConvolutionFilter_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionFilter(target: ConvolutionTarget; format: PixelFormat; &type: PixelType; image: IntPtr) :=
    z_GetConvolutionFilter_1(target, format, &type, image);
    
    private z_GetConvolutionParameterfv_adr := GetProcAddress('glGetConvolutionParameterfv');
    private z_GetConvolutionParameterfv_1 := GetProcOrNil&<procedure(target: ConvolutionTarget; pname: ConvolutionParameter; &params: IntPtr)>(z_GetConvolutionParameterfv_adr);
    private z_GetConvolutionParameterfv_2 := GetProcOrNil&<procedure(target: ConvolutionTarget; pname: ConvolutionParameter; var &params: single)>(z_GetConvolutionParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameterfv(target: ConvolutionTarget; pname: ConvolutionParameter; var &params: single) :=
    z_GetConvolutionParameterfv_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameterfv(target: ConvolutionTarget; pname: ConvolutionParameter; &params: IntPtr) :=
    z_GetConvolutionParameterfv_1(target, pname, &params);
    
    private z_GetConvolutionParameteriv_adr := GetProcAddress('glGetConvolutionParameteriv');
    private z_GetConvolutionParameteriv_1 := GetProcOrNil&<procedure(target: ConvolutionTarget; pname: ConvolutionParameter; &params: IntPtr)>(z_GetConvolutionParameteriv_adr);
    private z_GetConvolutionParameteriv_2 := GetProcOrNil&<procedure(target: ConvolutionTarget; pname: ConvolutionParameter; var &params: Int32)>(z_GetConvolutionParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameteriv(target: ConvolutionTarget; pname: ConvolutionParameter; var &params: Int32) :=
    z_GetConvolutionParameteriv_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameteriv(target: ConvolutionTarget; pname: ConvolutionParameter; &params: IntPtr) :=
    z_GetConvolutionParameteriv_1(target, pname, &params);
    
    private z_GetSeparableFilter_adr := GetProcAddress('glGetSeparableFilter');
    private z_GetSeparableFilter_1 := GetProcOrNil&<procedure(target: SeparableTargetEXT; format: PixelFormat; &type: PixelType; row: IntPtr; column: IntPtr; span: IntPtr)>(z_GetSeparableFilter_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSeparableFilter(target: SeparableTargetEXT; format: PixelFormat; &type: PixelType; row: IntPtr; column: IntPtr; span: IntPtr) :=
    z_GetSeparableFilter_1(target, format, &type, row, column, span);
    
    private z_SeparableFilter2D_adr := GetProcAddress('glSeparableFilter2D');
    private z_SeparableFilter2D_1 := GetProcOrNil&<procedure(target: SeparableTargetEXT; _internalformat: InternalFormat; width: Int32; height: Int32; format: PixelFormat; &type: PixelType; row: IntPtr; column: IntPtr)>(z_SeparableFilter2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SeparableFilter2D(target: SeparableTargetEXT; _internalformat: InternalFormat; width: Int32; height: Int32; format: PixelFormat; &type: PixelType; row: IntPtr; column: IntPtr) :=
    z_SeparableFilter2D_1(target, _internalformat, width, height, format, &type, row, column);
    
    private z_GetHistogram_adr := GetProcAddress('glGetHistogram');
    private z_GetHistogram_1 := GetProcOrNil&<procedure(target: HistogramTargetEXT; reset: boolean; format: PixelFormat; &type: PixelType; values: IntPtr)>(z_GetHistogram_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogram(target: HistogramTargetEXT; reset: boolean; format: PixelFormat; &type: PixelType; values: IntPtr) :=
    z_GetHistogram_1(target, reset, format, &type, values);
    
    private z_GetHistogramParameterfv_adr := GetProcAddress('glGetHistogramParameterfv');
    private z_GetHistogramParameterfv_1 := GetProcOrNil&<procedure(target: HistogramTargetEXT; pname: GetHistogramParameterPName; &params: IntPtr)>(z_GetHistogramParameterfv_adr);
    private z_GetHistogramParameterfv_2 := GetProcOrNil&<procedure(target: HistogramTargetEXT; pname: GetHistogramParameterPName; var &params: single)>(z_GetHistogramParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameterfv(target: HistogramTargetEXT; pname: GetHistogramParameterPName; var &params: single) :=
    z_GetHistogramParameterfv_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameterfv(target: HistogramTargetEXT; pname: GetHistogramParameterPName; &params: IntPtr) :=
    z_GetHistogramParameterfv_1(target, pname, &params);
    
    private z_GetHistogramParameteriv_adr := GetProcAddress('glGetHistogramParameteriv');
    private z_GetHistogramParameteriv_1 := GetProcOrNil&<procedure(target: HistogramTargetEXT; pname: GetHistogramParameterPName; &params: IntPtr)>(z_GetHistogramParameteriv_adr);
    private z_GetHistogramParameteriv_2 := GetProcOrNil&<procedure(target: HistogramTargetEXT; pname: GetHistogramParameterPName; var &params: Int32)>(z_GetHistogramParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameteriv(target: HistogramTargetEXT; pname: GetHistogramParameterPName; var &params: Int32) :=
    z_GetHistogramParameteriv_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameteriv(target: HistogramTargetEXT; pname: GetHistogramParameterPName; &params: IntPtr) :=
    z_GetHistogramParameteriv_1(target, pname, &params);
    
    private z_GetMinmax_adr := GetProcAddress('glGetMinmax');
    private z_GetMinmax_1 := GetProcOrNil&<procedure(target: MinmaxTargetEXT; reset: boolean; format: PixelFormat; &type: PixelType; values: IntPtr)>(z_GetMinmax_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmax(target: MinmaxTargetEXT; reset: boolean; format: PixelFormat; &type: PixelType; values: IntPtr) :=
    z_GetMinmax_1(target, reset, format, &type, values);
    
    private z_GetMinmaxParameterfv_adr := GetProcAddress('glGetMinmaxParameterfv');
    private z_GetMinmaxParameterfv_1 := GetProcOrNil&<procedure(target: MinmaxTargetEXT; pname: GetMinmaxParameterPName; &params: IntPtr)>(z_GetMinmaxParameterfv_adr);
    private z_GetMinmaxParameterfv_2 := GetProcOrNil&<procedure(target: MinmaxTargetEXT; pname: GetMinmaxParameterPName; var &params: single)>(z_GetMinmaxParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmaxParameterfv(target: MinmaxTargetEXT; pname: GetMinmaxParameterPName; var &params: single) :=
    z_GetMinmaxParameterfv_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmaxParameterfv(target: MinmaxTargetEXT; pname: GetMinmaxParameterPName; &params: IntPtr) :=
    z_GetMinmaxParameterfv_1(target, pname, &params);
    
    private z_GetMinmaxParameteriv_adr := GetProcAddress('glGetMinmaxParameteriv');
    private z_GetMinmaxParameteriv_1 := GetProcOrNil&<procedure(target: MinmaxTargetEXT; pname: GetMinmaxParameterPName; &params: IntPtr)>(z_GetMinmaxParameteriv_adr);
    private z_GetMinmaxParameteriv_2 := GetProcOrNil&<procedure(target: MinmaxTargetEXT; pname: GetMinmaxParameterPName; var &params: Int32)>(z_GetMinmaxParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmaxParameteriv(target: MinmaxTargetEXT; pname: GetMinmaxParameterPName; var &params: Int32) :=
    z_GetMinmaxParameteriv_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmaxParameteriv(target: MinmaxTargetEXT; pname: GetMinmaxParameterPName; &params: IntPtr) :=
    z_GetMinmaxParameteriv_1(target, pname, &params);
    
    private z_Histogram_adr := GetProcAddress('glHistogram');
    private z_Histogram_1 := GetProcOrNil&<procedure(target: HistogramTargetEXT; width: Int32; _internalformat: InternalFormat; sink: boolean)>(z_Histogram_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Histogram(target: HistogramTargetEXT; width: Int32; _internalformat: InternalFormat; sink: boolean) :=
    z_Histogram_1(target, width, _internalformat, sink);
    
    private z_Minmax_adr := GetProcAddress('glMinmax');
    private z_Minmax_1 := GetProcOrNil&<procedure(target: MinmaxTargetEXT; _internalformat: InternalFormat; sink: boolean)>(z_Minmax_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Minmax(target: MinmaxTargetEXT; _internalformat: InternalFormat; sink: boolean) :=
    z_Minmax_1(target, _internalformat, sink);
    
    private z_ResetHistogram_adr := GetProcAddress('glResetHistogram');
    private z_ResetHistogram_1 := GetProcOrNil&<procedure(target: HistogramTargetEXT)>(z_ResetHistogram_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ResetHistogram(target: HistogramTargetEXT) :=
    z_ResetHistogram_1(target);
    
    private z_ResetMinmax_adr := GetProcAddress('glResetMinmax');
    private z_ResetMinmax_1 := GetProcOrNil&<procedure(target: MinmaxTargetEXT)>(z_ResetMinmax_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ResetMinmax(target: MinmaxTargetEXT) :=
    z_ResetMinmax_1(target);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glIndirectParametersARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_indirect_parameters';
    
    private z_MultiDrawArraysIndirectCountARB_adr := GetProcAddress('glMultiDrawArraysIndirectCountARB');
    private z_MultiDrawArraysIndirectCountARB_1 := GetProcOrNil&<procedure(mode: PrimitiveType; indirect: IntPtr; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32)>(z_MultiDrawArraysIndirectCountARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysIndirectCountARB(mode: PrimitiveType; indirect: IntPtr; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32) :=
    z_MultiDrawArraysIndirectCountARB_1(mode, indirect, drawcount, maxdrawcount, stride);
    
    private z_MultiDrawElementsIndirectCountARB_adr := GetProcAddress('glMultiDrawElementsIndirectCountARB');
    private z_MultiDrawElementsIndirectCountARB_1 := GetProcOrNil&<procedure(mode: PrimitiveType; &type: DrawElementsType; indirect: IntPtr; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32)>(z_MultiDrawElementsIndirectCountARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsIndirectCountARB(mode: PrimitiveType; &type: DrawElementsType; indirect: IntPtr; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32) :=
    z_MultiDrawElementsIndirectCountARB_1(mode, &type, indirect, drawcount, maxdrawcount, stride);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glInstancedArraysARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_instanced_arrays';
    
    private z_VertexAttribDivisorARB_adr := GetProcAddress('glVertexAttribDivisorARB');
    private z_VertexAttribDivisorARB_1 := GetProcOrNil&<procedure(index: UInt32; divisor: UInt32)>(z_VertexAttribDivisorARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribDivisorARB(index: UInt32; divisor: UInt32) :=
    z_VertexAttribDivisorARB_1(index, divisor);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glInternalformatQueryARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_internalformat_query';
    
    private z_GetInternalformativ_adr := GetProcAddress('glGetInternalformativ');
    private z_GetInternalformativ_1 := GetProcOrNil&<procedure(target: TextureTarget; _internalformat: InternalFormat; pname: InternalFormatPName; count: Int32; &params: IntPtr)>(z_GetInternalformativ_adr);
    private z_GetInternalformativ_2 := GetProcOrNil&<procedure(target: TextureTarget; _internalformat: InternalFormat; pname: InternalFormatPName; count: Int32; var &params: Int32)>(z_GetInternalformativ_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInternalformativ(target: TextureTarget; _internalformat: InternalFormat; pname: InternalFormatPName; count: Int32; var &params: Int32) :=
    z_GetInternalformativ_2(target, _internalformat, pname, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInternalformativ(target: TextureTarget; _internalformat: InternalFormat; pname: InternalFormatPName; count: Int32; &params: IntPtr) :=
    z_GetInternalformativ_1(target, _internalformat, pname, count, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glInternalformatQuery2ARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_internalformat_query2';
    
    private z_GetInternalformati64v_adr := GetProcAddress('glGetInternalformati64v');
    private z_GetInternalformati64v_1 := GetProcOrNil&<procedure(target: TextureTarget; _internalformat: InternalFormat; pname: InternalFormatPName; count: Int32; &params: IntPtr)>(z_GetInternalformati64v_adr);
    private z_GetInternalformati64v_2 := GetProcOrNil&<procedure(target: TextureTarget; _internalformat: InternalFormat; pname: InternalFormatPName; count: Int32; var &params: Int64)>(z_GetInternalformati64v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInternalformati64v(target: TextureTarget; _internalformat: InternalFormat; pname: InternalFormatPName; count: Int32; var &params: Int64) :=
    z_GetInternalformati64v_2(target, _internalformat, pname, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInternalformati64v(target: TextureTarget; _internalformat: InternalFormat; pname: InternalFormatPName; count: Int32; &params: IntPtr) :=
    z_GetInternalformati64v_1(target, _internalformat, pname, count, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glInvalidateSubdataARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_invalidate_subdata';
    
    private z_InvalidateTexSubImage_adr := GetProcAddress('glInvalidateTexSubImage');
    private z_InvalidateTexSubImage_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32)>(z_InvalidateTexSubImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateTexSubImage(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32) :=
    z_InvalidateTexSubImage_1(texture, level, xoffset, yoffset, zoffset, width, height, depth);
    
    private z_InvalidateTexImage_adr := GetProcAddress('glInvalidateTexImage');
    private z_InvalidateTexImage_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32)>(z_InvalidateTexImage_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateTexImage(texture: gl_texture; level: Int32) :=
    z_InvalidateTexImage_1(texture, level);
    
    private z_InvalidateBufferSubData_adr := GetProcAddress('glInvalidateBufferSubData');
    private z_InvalidateBufferSubData_1 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; length: UIntPtr)>(z_InvalidateBufferSubData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateBufferSubData(buffer: gl_buffer; offset: IntPtr; length: UIntPtr) :=
    z_InvalidateBufferSubData_1(buffer, offset, length);
    
    private z_InvalidateBufferData_adr := GetProcAddress('glInvalidateBufferData');
    private z_InvalidateBufferData_1 := GetProcOrNil&<procedure(buffer: gl_buffer)>(z_InvalidateBufferData_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateBufferData(buffer: gl_buffer) :=
    z_InvalidateBufferData_1(buffer);
    
    private z_InvalidateFramebuffer_adr := GetProcAddress('glInvalidateFramebuffer');
    private z_InvalidateFramebuffer_1 := GetProcOrNil&<procedure(target: FramebufferTarget; numAttachments: Int32; attachments: IntPtr)>(z_InvalidateFramebuffer_adr);
    private z_InvalidateFramebuffer_2 := GetProcOrNil&<procedure(target: FramebufferTarget; numAttachments: Int32; var attachments: InvalidateFramebufferAttachment)>(z_InvalidateFramebuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateFramebuffer(target: FramebufferTarget; numAttachments: Int32; attachments: array of InvalidateFramebufferAttachment);
    type PInvalidateFramebufferAttachment=^InvalidateFramebufferAttachment;
    begin
      if (attachments<>nil) and (attachments.Length<>0) then
        z_InvalidateFramebuffer_2(target, numAttachments, attachments[0]) else
        z_InvalidateFramebuffer_2(target, numAttachments, PInvalidateFramebufferAttachment(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateFramebuffer(target: FramebufferTarget; numAttachments: Int32; var attachments: InvalidateFramebufferAttachment) :=
    z_InvalidateFramebuffer_2(target, numAttachments, attachments);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateFramebuffer(target: FramebufferTarget; numAttachments: Int32; attachments: IntPtr) :=
    z_InvalidateFramebuffer_1(target, numAttachments, attachments);
    
    private z_InvalidateSubFramebuffer_adr := GetProcAddress('glInvalidateSubFramebuffer');
    private z_InvalidateSubFramebuffer_1 := GetProcOrNil&<procedure(target: FramebufferTarget; numAttachments: Int32; attachments: IntPtr; x: Int32; y: Int32; width: Int32; height: Int32)>(z_InvalidateSubFramebuffer_adr);
    private z_InvalidateSubFramebuffer_2 := GetProcOrNil&<procedure(target: FramebufferTarget; numAttachments: Int32; var attachments: InvalidateFramebufferAttachment; x: Int32; y: Int32; width: Int32; height: Int32)>(z_InvalidateSubFramebuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateSubFramebuffer(target: FramebufferTarget; numAttachments: Int32; attachments: array of InvalidateFramebufferAttachment; x: Int32; y: Int32; width: Int32; height: Int32);
    type PInvalidateFramebufferAttachment=^InvalidateFramebufferAttachment;
    begin
      if (attachments<>nil) and (attachments.Length<>0) then
        z_InvalidateSubFramebuffer_2(target, numAttachments, attachments[0], x, y, width, height) else
        z_InvalidateSubFramebuffer_2(target, numAttachments, PInvalidateFramebufferAttachment(nil)^, x, y, width, height);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateSubFramebuffer(target: FramebufferTarget; numAttachments: Int32; var attachments: InvalidateFramebufferAttachment; x: Int32; y: Int32; width: Int32; height: Int32) :=
    z_InvalidateSubFramebuffer_2(target, numAttachments, attachments, x, y, width, height);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateSubFramebuffer(target: FramebufferTarget; numAttachments: Int32; attachments: IntPtr; x: Int32; y: Int32; width: Int32; height: Int32) :=
    z_InvalidateSubFramebuffer_1(target, numAttachments, attachments, x, y, width, height);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glMapBufferRangeARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_map_buffer_range';
    
    private z_MapBufferRange_adr := GetProcAddress('glMapBufferRange');
    private z_MapBufferRange_1 := GetProcOrNil&<function(target: BufferTarget; offset: IntPtr; length: UIntPtr; access: MapBufferAccessMask): IntPtr>(z_MapBufferRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapBufferRange(target: BufferTarget; offset: IntPtr; length: UIntPtr; access: MapBufferAccessMask): IntPtr :=
    z_MapBufferRange_1(target, offset, length, access);
    
    private z_FlushMappedBufferRange_adr := GetProcAddress('glFlushMappedBufferRange');
    private z_FlushMappedBufferRange_1 := GetProcOrNil&<procedure(target: BufferTarget; offset: IntPtr; length: UIntPtr)>(z_FlushMappedBufferRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FlushMappedBufferRange(target: BufferTarget; offset: IntPtr; length: UIntPtr) :=
    z_FlushMappedBufferRange_1(target, offset, length);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glMatrixPaletteARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_matrix_palette';
    
    private z_CurrentPaletteMatrixARB_adr := GetProcAddress('glCurrentPaletteMatrixARB');
    private z_CurrentPaletteMatrixARB_1 := GetProcOrNil&<procedure(index: Int32)>(z_CurrentPaletteMatrixARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CurrentPaletteMatrixARB(index: Int32) :=
    z_CurrentPaletteMatrixARB_1(index);
    
    private z_MatrixIndexubvARB_adr := GetProcAddress('glMatrixIndexubvARB');
    private z_MatrixIndexubvARB_1 := GetProcOrNil&<procedure(size: Int32; indices: IntPtr)>(z_MatrixIndexubvARB_adr);
    private z_MatrixIndexubvARB_2 := GetProcOrNil&<procedure(size: Int32; var indices: Byte)>(z_MatrixIndexubvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexubvARB(size: Int32; indices: array of Byte);
    type PByte=^Byte;
    begin
      if (indices<>nil) and (indices.Length<>0) then
        z_MatrixIndexubvARB_2(size, indices[0]) else
        z_MatrixIndexubvARB_2(size, PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexubvARB(size: Int32; var indices: Byte) :=
    z_MatrixIndexubvARB_2(size, indices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexubvARB(size: Int32; indices: IntPtr) :=
    z_MatrixIndexubvARB_1(size, indices);
    
    private z_MatrixIndexusvARB_adr := GetProcAddress('glMatrixIndexusvARB');
    private z_MatrixIndexusvARB_1 := GetProcOrNil&<procedure(size: Int32; indices: IntPtr)>(z_MatrixIndexusvARB_adr);
    private z_MatrixIndexusvARB_2 := GetProcOrNil&<procedure(size: Int32; var indices: UInt16)>(z_MatrixIndexusvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexusvARB(size: Int32; indices: array of UInt16);
    type PUInt16=^UInt16;
    begin
      if (indices<>nil) and (indices.Length<>0) then
        z_MatrixIndexusvARB_2(size, indices[0]) else
        z_MatrixIndexusvARB_2(size, PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexusvARB(size: Int32; var indices: UInt16) :=
    z_MatrixIndexusvARB_2(size, indices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexusvARB(size: Int32; indices: IntPtr) :=
    z_MatrixIndexusvARB_1(size, indices);
    
    private z_MatrixIndexuivARB_adr := GetProcAddress('glMatrixIndexuivARB');
    private z_MatrixIndexuivARB_1 := GetProcOrNil&<procedure(size: Int32; indices: IntPtr)>(z_MatrixIndexuivARB_adr);
    private z_MatrixIndexuivARB_2 := GetProcOrNil&<procedure(size: Int32; var indices: UInt32)>(z_MatrixIndexuivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexuivARB(size: Int32; indices: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (indices<>nil) and (indices.Length<>0) then
        z_MatrixIndexuivARB_2(size, indices[0]) else
        z_MatrixIndexuivARB_2(size, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexuivARB(size: Int32; var indices: UInt32) :=
    z_MatrixIndexuivARB_2(size, indices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexuivARB(size: Int32; indices: IntPtr) :=
    z_MatrixIndexuivARB_1(size, indices);
    
    private z_MatrixIndexPointerARB_adr := GetProcAddress('glMatrixIndexPointerARB');
    private z_MatrixIndexPointerARB_1 := GetProcOrNil&<procedure(size: Int32; &type: MatrixIndexPointerType; stride: Int32; pointer: IntPtr)>(z_MatrixIndexPointerARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexPointerARB(size: Int32; &type: MatrixIndexPointerType; stride: Int32; pointer: IntPtr) :=
    z_MatrixIndexPointerARB_1(size, &type, stride, pointer);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glMultiBindARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_multi_bind';
    
    private z_BindBuffersBase_adr := GetProcAddress('glBindBuffersBase');
    private z_BindBuffersBase_1 := GetProcOrNil&<procedure(target: BufferTarget; first: UInt32; count: Int32; buffers: IntPtr)>(z_BindBuffersBase_adr);
    private z_BindBuffersBase_2 := GetProcOrNil&<procedure(target: BufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer)>(z_BindBuffersBase_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersBase(target: BufferTarget; first: UInt32; count: Int32; buffers: array of gl_buffer);
    type Pgl_buffer=^gl_buffer;
    begin
      if (buffers<>nil) and (buffers.Length<>0) then
        z_BindBuffersBase_2(target, first, count, buffers[0]) else
        z_BindBuffersBase_2(target, first, count, Pgl_buffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersBase(target: BufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer) :=
    z_BindBuffersBase_2(target, first, count, buffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersBase(target: BufferTarget; first: UInt32; count: Int32; buffers: IntPtr) :=
    z_BindBuffersBase_1(target, first, count, buffers);
    
    private z_BindBuffersRange_adr := GetProcAddress('glBindBuffersRange');
    private z_BindBuffersRange_1 := GetProcOrNil&<procedure(target: BufferTarget; first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; sizes: IntPtr)>(z_BindBuffersRange_adr);
    private z_BindBuffersRange_2 := GetProcOrNil&<procedure(target: BufferTarget; first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; var sizes: UIntPtr)>(z_BindBuffersRange_adr);
    private z_BindBuffersRange_3 := GetProcOrNil&<procedure(target: BufferTarget; first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; sizes: IntPtr)>(z_BindBuffersRange_adr);
    private z_BindBuffersRange_4 := GetProcOrNil&<procedure(target: BufferTarget; first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; var sizes: UIntPtr)>(z_BindBuffersRange_adr);
    private z_BindBuffersRange_5 := GetProcOrNil&<procedure(target: BufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; sizes: IntPtr)>(z_BindBuffersRange_adr);
    private z_BindBuffersRange_6 := GetProcOrNil&<procedure(target: BufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; var sizes: UIntPtr)>(z_BindBuffersRange_adr);
    private z_BindBuffersRange_7 := GetProcOrNil&<procedure(target: BufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; sizes: IntPtr)>(z_BindBuffersRange_adr);
    private z_BindBuffersRange_8 := GetProcOrNil&<procedure(target: BufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; var sizes: UIntPtr)>(z_BindBuffersRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: BufferTarget; first: UInt32; count: Int32; buffers: array of gl_buffer; offsets: array of IntPtr; sizes: array of UIntPtr);
    type Pgl_buffer=^gl_buffer;
    type PIntPtr=^IntPtr;
    type PUIntPtr=^UIntPtr;
    begin
      if (sizes<>nil) and (sizes.Length<>0) then
        if (offsets<>nil) and (offsets.Length<>0) then
          if (buffers<>nil) and (buffers.Length<>0) then
            z_BindBuffersRange_8(target, first, count, buffers[0], offsets[0], sizes[0]) else
            z_BindBuffersRange_8(target, first, count, Pgl_buffer(nil)^, offsets[0], sizes[0]) else
          if (buffers<>nil) and (buffers.Length<>0) then
            z_BindBuffersRange_8(target, first, count, buffers[0], PIntPtr(nil)^, sizes[0]) else
            z_BindBuffersRange_8(target, first, count, Pgl_buffer(nil)^, PIntPtr(nil)^, sizes[0]) else
        if (offsets<>nil) and (offsets.Length<>0) then
          if (buffers<>nil) and (buffers.Length<>0) then
            z_BindBuffersRange_8(target, first, count, buffers[0], offsets[0], PUIntPtr(nil)^) else
            z_BindBuffersRange_8(target, first, count, Pgl_buffer(nil)^, offsets[0], PUIntPtr(nil)^) else
          if (buffers<>nil) and (buffers.Length<>0) then
            z_BindBuffersRange_8(target, first, count, buffers[0], PIntPtr(nil)^, PUIntPtr(nil)^) else
            z_BindBuffersRange_8(target, first, count, Pgl_buffer(nil)^, PIntPtr(nil)^, PUIntPtr(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: BufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; var sizes: UIntPtr) :=
    z_BindBuffersRange_8(target, first, count, buffers, offsets, sizes);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: BufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; sizes: IntPtr) :=
    z_BindBuffersRange_7(target, first, count, buffers, offsets, sizes);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: BufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; var sizes: UIntPtr) :=
    z_BindBuffersRange_6(target, first, count, buffers, offsets, sizes);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: BufferTarget; first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; sizes: IntPtr) :=
    z_BindBuffersRange_5(target, first, count, buffers, offsets, sizes);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: BufferTarget; first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; var sizes: UIntPtr) :=
    z_BindBuffersRange_4(target, first, count, buffers, offsets, sizes);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: BufferTarget; first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; sizes: IntPtr) :=
    z_BindBuffersRange_3(target, first, count, buffers, offsets, sizes);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: BufferTarget; first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; var sizes: UIntPtr) :=
    z_BindBuffersRange_2(target, first, count, buffers, offsets, sizes);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: BufferTarget; first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; sizes: IntPtr) :=
    z_BindBuffersRange_1(target, first, count, buffers, offsets, sizes);
    
    private z_BindTextures_adr := GetProcAddress('glBindTextures');
    private z_BindTextures_1 := GetProcOrNil&<procedure(first: UInt32; count: Int32; textures: IntPtr)>(z_BindTextures_adr);
    private z_BindTextures_2 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var textures: gl_texture)>(z_BindTextures_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTextures(first: UInt32; count: Int32; textures: array of gl_texture);
    type Pgl_texture=^gl_texture;
    begin
      if (textures<>nil) and (textures.Length<>0) then
        z_BindTextures_2(first, count, textures[0]) else
        z_BindTextures_2(first, count, Pgl_texture(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTextures(first: UInt32; count: Int32; var textures: gl_texture) :=
    z_BindTextures_2(first, count, textures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTextures(first: UInt32; count: Int32; textures: IntPtr) :=
    z_BindTextures_1(first, count, textures);
    
    private z_BindSamplers_adr := GetProcAddress('glBindSamplers');
    private z_BindSamplers_1 := GetProcOrNil&<procedure(first: UInt32; count: Int32; samplers: IntPtr)>(z_BindSamplers_adr);
    private z_BindSamplers_2 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var samplers: gl_sampler)>(z_BindSamplers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindSamplers(first: UInt32; count: Int32; samplers: array of gl_sampler);
    type Pgl_sampler=^gl_sampler;
    begin
      if (samplers<>nil) and (samplers.Length<>0) then
        z_BindSamplers_2(first, count, samplers[0]) else
        z_BindSamplers_2(first, count, Pgl_sampler(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindSamplers(first: UInt32; count: Int32; var samplers: gl_sampler) :=
    z_BindSamplers_2(first, count, samplers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindSamplers(first: UInt32; count: Int32; samplers: IntPtr) :=
    z_BindSamplers_1(first, count, samplers);
    
    private z_BindImageTextures_adr := GetProcAddress('glBindImageTextures');
    private z_BindImageTextures_1 := GetProcOrNil&<procedure(first: UInt32; count: Int32; textures: IntPtr)>(z_BindImageTextures_adr);
    private z_BindImageTextures_2 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var textures: gl_texture)>(z_BindImageTextures_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindImageTextures(first: UInt32; count: Int32; textures: array of gl_texture);
    type Pgl_texture=^gl_texture;
    begin
      if (textures<>nil) and (textures.Length<>0) then
        z_BindImageTextures_2(first, count, textures[0]) else
        z_BindImageTextures_2(first, count, Pgl_texture(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindImageTextures(first: UInt32; count: Int32; var textures: gl_texture) :=
    z_BindImageTextures_2(first, count, textures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindImageTextures(first: UInt32; count: Int32; textures: IntPtr) :=
    z_BindImageTextures_1(first, count, textures);
    
    private z_BindVertexBuffers_adr := GetProcAddress('glBindVertexBuffers');
    private z_BindVertexBuffers_1 := GetProcOrNil&<procedure(first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; strides: IntPtr)>(z_BindVertexBuffers_adr);
    private z_BindVertexBuffers_2 := GetProcOrNil&<procedure(first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; var strides: Int32)>(z_BindVertexBuffers_adr);
    private z_BindVertexBuffers_3 := GetProcOrNil&<procedure(first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; strides: IntPtr)>(z_BindVertexBuffers_adr);
    private z_BindVertexBuffers_4 := GetProcOrNil&<procedure(first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; var strides: Int32)>(z_BindVertexBuffers_adr);
    private z_BindVertexBuffers_5 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; strides: IntPtr)>(z_BindVertexBuffers_adr);
    private z_BindVertexBuffers_6 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; var strides: Int32)>(z_BindVertexBuffers_adr);
    private z_BindVertexBuffers_7 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; strides: IntPtr)>(z_BindVertexBuffers_adr);
    private z_BindVertexBuffers_8 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; var strides: Int32)>(z_BindVertexBuffers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; buffers: array of gl_buffer; offsets: array of IntPtr; strides: array of Int32);
    type Pgl_buffer=^gl_buffer;
    type PIntPtr=^IntPtr;
    type PInt32=^Int32;
    begin
      if (strides<>nil) and (strides.Length<>0) then
        if (offsets<>nil) and (offsets.Length<>0) then
          if (buffers<>nil) and (buffers.Length<>0) then
            z_BindVertexBuffers_8(first, count, buffers[0], offsets[0], strides[0]) else
            z_BindVertexBuffers_8(first, count, Pgl_buffer(nil)^, offsets[0], strides[0]) else
          if (buffers<>nil) and (buffers.Length<>0) then
            z_BindVertexBuffers_8(first, count, buffers[0], PIntPtr(nil)^, strides[0]) else
            z_BindVertexBuffers_8(first, count, Pgl_buffer(nil)^, PIntPtr(nil)^, strides[0]) else
        if (offsets<>nil) and (offsets.Length<>0) then
          if (buffers<>nil) and (buffers.Length<>0) then
            z_BindVertexBuffers_8(first, count, buffers[0], offsets[0], PInt32(nil)^) else
            z_BindVertexBuffers_8(first, count, Pgl_buffer(nil)^, offsets[0], PInt32(nil)^) else
          if (buffers<>nil) and (buffers.Length<>0) then
            z_BindVertexBuffers_8(first, count, buffers[0], PIntPtr(nil)^, PInt32(nil)^) else
            z_BindVertexBuffers_8(first, count, Pgl_buffer(nil)^, PIntPtr(nil)^, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; var strides: Int32) :=
    z_BindVertexBuffers_8(first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; var buffers: gl_buffer; var offsets: IntPtr; strides: IntPtr) :=
    z_BindVertexBuffers_7(first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; var strides: Int32) :=
    z_BindVertexBuffers_6(first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; var buffers: gl_buffer; offsets: pointer; strides: IntPtr) :=
    z_BindVertexBuffers_5(first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; var strides: Int32) :=
    z_BindVertexBuffers_4(first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; buffers: IntPtr; var offsets: IntPtr; strides: IntPtr) :=
    z_BindVertexBuffers_3(first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; var strides: Int32) :=
    z_BindVertexBuffers_2(first, count, buffers, offsets, strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; buffers: IntPtr; offsets: pointer; strides: IntPtr) :=
    z_BindVertexBuffers_1(first, count, buffers, offsets, strides);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glMultiDrawIndirectARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_multi_draw_indirect';
    
    private z_MultiDrawArraysIndirect_adr := GetProcAddress('glMultiDrawArraysIndirect');
    private z_MultiDrawArraysIndirect_1 := GetProcOrNil&<procedure(mode: PrimitiveType; indirect: IntPtr; drawcount: Int32; stride: Int32)>(z_MultiDrawArraysIndirect_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysIndirect(mode: PrimitiveType; indirect: IntPtr; drawcount: Int32; stride: Int32) :=
    z_MultiDrawArraysIndirect_1(mode, indirect, drawcount, stride);
    
    private z_MultiDrawElementsIndirect_adr := GetProcAddress('glMultiDrawElementsIndirect');
    private z_MultiDrawElementsIndirect_1 := GetProcOrNil&<procedure(mode: PrimitiveType; &type: DrawElementsType; indirect: IntPtr; drawcount: Int32; stride: Int32)>(z_MultiDrawElementsIndirect_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsIndirect(mode: PrimitiveType; &type: DrawElementsType; indirect: IntPtr; drawcount: Int32; stride: Int32) :=
    z_MultiDrawElementsIndirect_1(mode, &type, indirect, drawcount, stride);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glMultisampleARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_multisample';
    
    private z_SampleCoverageARB_adr := GetProcAddress('glSampleCoverageARB');
    private z_SampleCoverageARB_1 := GetProcOrNil&<procedure(value: single; invert: boolean)>(z_SampleCoverageARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SampleCoverageARB(value: single; invert: boolean) :=
    z_SampleCoverageARB_1(value, invert);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glMultitextureARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_multitexture';
    
    private z_ActiveTextureARB_adr := GetProcAddress('glActiveTextureARB');
    private z_ActiveTextureARB_1 := GetProcOrNil&<procedure(texture: TextureUnit)>(z_ActiveTextureARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ActiveTextureARB(texture: TextureUnit) :=
    z_ActiveTextureARB_1(texture);
    
    private z_ClientActiveTextureARB_adr := GetProcAddress('glClientActiveTextureARB');
    private z_ClientActiveTextureARB_1 := GetProcOrNil&<procedure(texture: TextureUnit)>(z_ClientActiveTextureARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientActiveTextureARB(texture: TextureUnit) :=
    z_ClientActiveTextureARB_1(texture);
    
    private z_MultiTexCoord1dARB_adr := GetProcAddress('glMultiTexCoord1dARB');
    private z_MultiTexCoord1dARB_1 := GetProcOrNil&<procedure(target: TextureUnit; s: real)>(z_MultiTexCoord1dARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1dARB(target: TextureUnit; s: real) :=
    z_MultiTexCoord1dARB_1(target, s);
    
    private z_MultiTexCoord1dvARB_adr := GetProcAddress('glMultiTexCoord1dvARB');
    private z_MultiTexCoord1dvARB_1 := GetProcOrNil&<procedure(target: TextureUnit; v: IntPtr)>(z_MultiTexCoord1dvARB_adr);
    private z_MultiTexCoord1dvARB_2 := GetProcOrNil&<procedure(target: TextureUnit; var v: real)>(z_MultiTexCoord1dvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1dvARB(target: TextureUnit; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MultiTexCoord1dvARB_2(target, v[0]) else
        z_MultiTexCoord1dvARB_2(target, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1dvARB(target: TextureUnit; var v: real) :=
    z_MultiTexCoord1dvARB_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1dvARB(target: TextureUnit; v: IntPtr) :=
    z_MultiTexCoord1dvARB_1(target, v);
    
    private z_MultiTexCoord1fARB_adr := GetProcAddress('glMultiTexCoord1fARB');
    private z_MultiTexCoord1fARB_1 := GetProcOrNil&<procedure(target: TextureUnit; s: single)>(z_MultiTexCoord1fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1fARB(target: TextureUnit; s: single) :=
    z_MultiTexCoord1fARB_1(target, s);
    
    private z_MultiTexCoord1fvARB_adr := GetProcAddress('glMultiTexCoord1fvARB');
    private z_MultiTexCoord1fvARB_1 := GetProcOrNil&<procedure(target: TextureUnit; v: IntPtr)>(z_MultiTexCoord1fvARB_adr);
    private z_MultiTexCoord1fvARB_2 := GetProcOrNil&<procedure(target: TextureUnit; var v: single)>(z_MultiTexCoord1fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1fvARB(target: TextureUnit; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MultiTexCoord1fvARB_2(target, v[0]) else
        z_MultiTexCoord1fvARB_2(target, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1fvARB(target: TextureUnit; var v: single) :=
    z_MultiTexCoord1fvARB_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1fvARB(target: TextureUnit; v: IntPtr) :=
    z_MultiTexCoord1fvARB_1(target, v);
    
    private z_MultiTexCoord1iARB_adr := GetProcAddress('glMultiTexCoord1iARB');
    private z_MultiTexCoord1iARB_1 := GetProcOrNil&<procedure(target: TextureUnit; s: Int32)>(z_MultiTexCoord1iARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1iARB(target: TextureUnit; s: Int32) :=
    z_MultiTexCoord1iARB_1(target, s);
    
    private z_MultiTexCoord1ivARB_adr := GetProcAddress('glMultiTexCoord1ivARB');
    private z_MultiTexCoord1ivARB_1 := GetProcOrNil&<procedure(target: TextureUnit; v: IntPtr)>(z_MultiTexCoord1ivARB_adr);
    private z_MultiTexCoord1ivARB_2 := GetProcOrNil&<procedure(target: TextureUnit; var v: Int32)>(z_MultiTexCoord1ivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1ivARB(target: TextureUnit; v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MultiTexCoord1ivARB_2(target, v[0]) else
        z_MultiTexCoord1ivARB_2(target, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1ivARB(target: TextureUnit; var v: Int32) :=
    z_MultiTexCoord1ivARB_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1ivARB(target: TextureUnit; v: IntPtr) :=
    z_MultiTexCoord1ivARB_1(target, v);
    
    private z_MultiTexCoord1sARB_adr := GetProcAddress('glMultiTexCoord1sARB');
    private z_MultiTexCoord1sARB_1 := GetProcOrNil&<procedure(target: TextureUnit; s: Int16)>(z_MultiTexCoord1sARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1sARB(target: TextureUnit; s: Int16) :=
    z_MultiTexCoord1sARB_1(target, s);
    
    private z_MultiTexCoord1svARB_adr := GetProcAddress('glMultiTexCoord1svARB');
    private z_MultiTexCoord1svARB_1 := GetProcOrNil&<procedure(target: TextureUnit; v: IntPtr)>(z_MultiTexCoord1svARB_adr);
    private z_MultiTexCoord1svARB_2 := GetProcOrNil&<procedure(target: TextureUnit; var v: Int16)>(z_MultiTexCoord1svARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1svARB(target: TextureUnit; v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MultiTexCoord1svARB_2(target, v[0]) else
        z_MultiTexCoord1svARB_2(target, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1svARB(target: TextureUnit; var v: Int16) :=
    z_MultiTexCoord1svARB_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1svARB(target: TextureUnit; v: IntPtr) :=
    z_MultiTexCoord1svARB_1(target, v);
    
    private z_MultiTexCoord2dARB_adr := GetProcAddress('glMultiTexCoord2dARB');
    private z_MultiTexCoord2dARB_1 := GetProcOrNil&<procedure(target: TextureUnit; s: real; t: real)>(z_MultiTexCoord2dARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2dARB(target: TextureUnit; s: real; t: real) :=
    z_MultiTexCoord2dARB_1(target, s, t);
    
    private z_MultiTexCoord2dvARB_adr := GetProcAddress('glMultiTexCoord2dvARB');
    private z_MultiTexCoord2dvARB_1 := GetProcOrNil&<procedure(target: TextureUnit; v: IntPtr)>(z_MultiTexCoord2dvARB_adr);
    private z_MultiTexCoord2dvARB_2 := GetProcOrNil&<procedure(target: TextureUnit; var v: real)>(z_MultiTexCoord2dvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2dvARB(target: TextureUnit; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MultiTexCoord2dvARB_2(target, v[0]) else
        z_MultiTexCoord2dvARB_2(target, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2dvARB(target: TextureUnit; var v: real) :=
    z_MultiTexCoord2dvARB_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2dvARB(target: TextureUnit; v: IntPtr) :=
    z_MultiTexCoord2dvARB_1(target, v);
    
    private z_MultiTexCoord2fARB_adr := GetProcAddress('glMultiTexCoord2fARB');
    private z_MultiTexCoord2fARB_1 := GetProcOrNil&<procedure(target: TextureUnit; s: single; t: single)>(z_MultiTexCoord2fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2fARB(target: TextureUnit; s: single; t: single) :=
    z_MultiTexCoord2fARB_1(target, s, t);
    
    private z_MultiTexCoord2fvARB_adr := GetProcAddress('glMultiTexCoord2fvARB');
    private z_MultiTexCoord2fvARB_1 := GetProcOrNil&<procedure(target: TextureUnit; v: IntPtr)>(z_MultiTexCoord2fvARB_adr);
    private z_MultiTexCoord2fvARB_2 := GetProcOrNil&<procedure(target: TextureUnit; var v: single)>(z_MultiTexCoord2fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2fvARB(target: TextureUnit; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MultiTexCoord2fvARB_2(target, v[0]) else
        z_MultiTexCoord2fvARB_2(target, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2fvARB(target: TextureUnit; var v: single) :=
    z_MultiTexCoord2fvARB_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2fvARB(target: TextureUnit; v: IntPtr) :=
    z_MultiTexCoord2fvARB_1(target, v);
    
    private z_MultiTexCoord2iARB_adr := GetProcAddress('glMultiTexCoord2iARB');
    private z_MultiTexCoord2iARB_1 := GetProcOrNil&<procedure(target: TextureUnit; s: Int32; t: Int32)>(z_MultiTexCoord2iARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2iARB(target: TextureUnit; s: Int32; t: Int32) :=
    z_MultiTexCoord2iARB_1(target, s, t);
    
    private z_MultiTexCoord2ivARB_adr := GetProcAddress('glMultiTexCoord2ivARB');
    private z_MultiTexCoord2ivARB_1 := GetProcOrNil&<procedure(target: TextureUnit; v: IntPtr)>(z_MultiTexCoord2ivARB_adr);
    private z_MultiTexCoord2ivARB_2 := GetProcOrNil&<procedure(target: TextureUnit; var v: Int32)>(z_MultiTexCoord2ivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2ivARB(target: TextureUnit; v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MultiTexCoord2ivARB_2(target, v[0]) else
        z_MultiTexCoord2ivARB_2(target, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2ivARB(target: TextureUnit; var v: Int32) :=
    z_MultiTexCoord2ivARB_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2ivARB(target: TextureUnit; v: IntPtr) :=
    z_MultiTexCoord2ivARB_1(target, v);
    
    private z_MultiTexCoord2sARB_adr := GetProcAddress('glMultiTexCoord2sARB');
    private z_MultiTexCoord2sARB_1 := GetProcOrNil&<procedure(target: TextureUnit; s: Int16; t: Int16)>(z_MultiTexCoord2sARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2sARB(target: TextureUnit; s: Int16; t: Int16) :=
    z_MultiTexCoord2sARB_1(target, s, t);
    
    private z_MultiTexCoord2svARB_adr := GetProcAddress('glMultiTexCoord2svARB');
    private z_MultiTexCoord2svARB_1 := GetProcOrNil&<procedure(target: TextureUnit; v: IntPtr)>(z_MultiTexCoord2svARB_adr);
    private z_MultiTexCoord2svARB_2 := GetProcOrNil&<procedure(target: TextureUnit; var v: Int16)>(z_MultiTexCoord2svARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2svARB(target: TextureUnit; v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MultiTexCoord2svARB_2(target, v[0]) else
        z_MultiTexCoord2svARB_2(target, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2svARB(target: TextureUnit; var v: Int16) :=
    z_MultiTexCoord2svARB_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2svARB(target: TextureUnit; v: IntPtr) :=
    z_MultiTexCoord2svARB_1(target, v);
    
    private z_MultiTexCoord3dARB_adr := GetProcAddress('glMultiTexCoord3dARB');
    private z_MultiTexCoord3dARB_1 := GetProcOrNil&<procedure(target: TextureUnit; s: real; t: real; r: real)>(z_MultiTexCoord3dARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3dARB(target: TextureUnit; s: real; t: real; r: real) :=
    z_MultiTexCoord3dARB_1(target, s, t, r);
    
    private z_MultiTexCoord3dvARB_adr := GetProcAddress('glMultiTexCoord3dvARB');
    private z_MultiTexCoord3dvARB_1 := GetProcOrNil&<procedure(target: TextureUnit; v: IntPtr)>(z_MultiTexCoord3dvARB_adr);
    private z_MultiTexCoord3dvARB_2 := GetProcOrNil&<procedure(target: TextureUnit; var v: real)>(z_MultiTexCoord3dvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3dvARB(target: TextureUnit; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MultiTexCoord3dvARB_2(target, v[0]) else
        z_MultiTexCoord3dvARB_2(target, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3dvARB(target: TextureUnit; var v: real) :=
    z_MultiTexCoord3dvARB_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3dvARB(target: TextureUnit; v: IntPtr) :=
    z_MultiTexCoord3dvARB_1(target, v);
    
    private z_MultiTexCoord3fARB_adr := GetProcAddress('glMultiTexCoord3fARB');
    private z_MultiTexCoord3fARB_1 := GetProcOrNil&<procedure(target: TextureUnit; s: single; t: single; r: single)>(z_MultiTexCoord3fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3fARB(target: TextureUnit; s: single; t: single; r: single) :=
    z_MultiTexCoord3fARB_1(target, s, t, r);
    
    private z_MultiTexCoord3fvARB_adr := GetProcAddress('glMultiTexCoord3fvARB');
    private z_MultiTexCoord3fvARB_1 := GetProcOrNil&<procedure(target: TextureUnit; v: IntPtr)>(z_MultiTexCoord3fvARB_adr);
    private z_MultiTexCoord3fvARB_2 := GetProcOrNil&<procedure(target: TextureUnit; var v: single)>(z_MultiTexCoord3fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3fvARB(target: TextureUnit; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MultiTexCoord3fvARB_2(target, v[0]) else
        z_MultiTexCoord3fvARB_2(target, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3fvARB(target: TextureUnit; var v: single) :=
    z_MultiTexCoord3fvARB_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3fvARB(target: TextureUnit; v: IntPtr) :=
    z_MultiTexCoord3fvARB_1(target, v);
    
    private z_MultiTexCoord3iARB_adr := GetProcAddress('glMultiTexCoord3iARB');
    private z_MultiTexCoord3iARB_1 := GetProcOrNil&<procedure(target: TextureUnit; s: Int32; t: Int32; r: Int32)>(z_MultiTexCoord3iARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3iARB(target: TextureUnit; s: Int32; t: Int32; r: Int32) :=
    z_MultiTexCoord3iARB_1(target, s, t, r);
    
    private z_MultiTexCoord3ivARB_adr := GetProcAddress('glMultiTexCoord3ivARB');
    private z_MultiTexCoord3ivARB_1 := GetProcOrNil&<procedure(target: TextureUnit; v: IntPtr)>(z_MultiTexCoord3ivARB_adr);
    private z_MultiTexCoord3ivARB_2 := GetProcOrNil&<procedure(target: TextureUnit; var v: Int32)>(z_MultiTexCoord3ivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3ivARB(target: TextureUnit; v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MultiTexCoord3ivARB_2(target, v[0]) else
        z_MultiTexCoord3ivARB_2(target, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3ivARB(target: TextureUnit; var v: Int32) :=
    z_MultiTexCoord3ivARB_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3ivARB(target: TextureUnit; v: IntPtr) :=
    z_MultiTexCoord3ivARB_1(target, v);
    
    private z_MultiTexCoord3sARB_adr := GetProcAddress('glMultiTexCoord3sARB');
    private z_MultiTexCoord3sARB_1 := GetProcOrNil&<procedure(target: TextureUnit; s: Int16; t: Int16; r: Int16)>(z_MultiTexCoord3sARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3sARB(target: TextureUnit; s: Int16; t: Int16; r: Int16) :=
    z_MultiTexCoord3sARB_1(target, s, t, r);
    
    private z_MultiTexCoord3svARB_adr := GetProcAddress('glMultiTexCoord3svARB');
    private z_MultiTexCoord3svARB_1 := GetProcOrNil&<procedure(target: TextureUnit; v: IntPtr)>(z_MultiTexCoord3svARB_adr);
    private z_MultiTexCoord3svARB_2 := GetProcOrNil&<procedure(target: TextureUnit; var v: Int16)>(z_MultiTexCoord3svARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3svARB(target: TextureUnit; v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MultiTexCoord3svARB_2(target, v[0]) else
        z_MultiTexCoord3svARB_2(target, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3svARB(target: TextureUnit; var v: Int16) :=
    z_MultiTexCoord3svARB_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3svARB(target: TextureUnit; v: IntPtr) :=
    z_MultiTexCoord3svARB_1(target, v);
    
    private z_MultiTexCoord4dARB_adr := GetProcAddress('glMultiTexCoord4dARB');
    private z_MultiTexCoord4dARB_1 := GetProcOrNil&<procedure(target: TextureUnit; s: real; t: real; r: real; q: real)>(z_MultiTexCoord4dARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4dARB(target: TextureUnit; s: real; t: real; r: real; q: real) :=
    z_MultiTexCoord4dARB_1(target, s, t, r, q);
    
    private z_MultiTexCoord4dvARB_adr := GetProcAddress('glMultiTexCoord4dvARB');
    private z_MultiTexCoord4dvARB_1 := GetProcOrNil&<procedure(target: TextureUnit; v: IntPtr)>(z_MultiTexCoord4dvARB_adr);
    private z_MultiTexCoord4dvARB_2 := GetProcOrNil&<procedure(target: TextureUnit; var v: real)>(z_MultiTexCoord4dvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4dvARB(target: TextureUnit; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MultiTexCoord4dvARB_2(target, v[0]) else
        z_MultiTexCoord4dvARB_2(target, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4dvARB(target: TextureUnit; var v: real) :=
    z_MultiTexCoord4dvARB_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4dvARB(target: TextureUnit; v: IntPtr) :=
    z_MultiTexCoord4dvARB_1(target, v);
    
    private z_MultiTexCoord4fARB_adr := GetProcAddress('glMultiTexCoord4fARB');
    private z_MultiTexCoord4fARB_1 := GetProcOrNil&<procedure(target: TextureUnit; s: single; t: single; r: single; q: single)>(z_MultiTexCoord4fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4fARB(target: TextureUnit; s: single; t: single; r: single; q: single) :=
    z_MultiTexCoord4fARB_1(target, s, t, r, q);
    
    private z_MultiTexCoord4fvARB_adr := GetProcAddress('glMultiTexCoord4fvARB');
    private z_MultiTexCoord4fvARB_1 := GetProcOrNil&<procedure(target: TextureUnit; v: IntPtr)>(z_MultiTexCoord4fvARB_adr);
    private z_MultiTexCoord4fvARB_2 := GetProcOrNil&<procedure(target: TextureUnit; var v: single)>(z_MultiTexCoord4fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4fvARB(target: TextureUnit; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MultiTexCoord4fvARB_2(target, v[0]) else
        z_MultiTexCoord4fvARB_2(target, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4fvARB(target: TextureUnit; var v: single) :=
    z_MultiTexCoord4fvARB_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4fvARB(target: TextureUnit; v: IntPtr) :=
    z_MultiTexCoord4fvARB_1(target, v);
    
    private z_MultiTexCoord4iARB_adr := GetProcAddress('glMultiTexCoord4iARB');
    private z_MultiTexCoord4iARB_1 := GetProcOrNil&<procedure(target: TextureUnit; s: Int32; t: Int32; r: Int32; q: Int32)>(z_MultiTexCoord4iARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4iARB(target: TextureUnit; s: Int32; t: Int32; r: Int32; q: Int32) :=
    z_MultiTexCoord4iARB_1(target, s, t, r, q);
    
    private z_MultiTexCoord4ivARB_adr := GetProcAddress('glMultiTexCoord4ivARB');
    private z_MultiTexCoord4ivARB_1 := GetProcOrNil&<procedure(target: TextureUnit; v: IntPtr)>(z_MultiTexCoord4ivARB_adr);
    private z_MultiTexCoord4ivARB_2 := GetProcOrNil&<procedure(target: TextureUnit; var v: Int32)>(z_MultiTexCoord4ivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4ivARB(target: TextureUnit; v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MultiTexCoord4ivARB_2(target, v[0]) else
        z_MultiTexCoord4ivARB_2(target, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4ivARB(target: TextureUnit; var v: Int32) :=
    z_MultiTexCoord4ivARB_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4ivARB(target: TextureUnit; v: IntPtr) :=
    z_MultiTexCoord4ivARB_1(target, v);
    
    private z_MultiTexCoord4sARB_adr := GetProcAddress('glMultiTexCoord4sARB');
    private z_MultiTexCoord4sARB_1 := GetProcOrNil&<procedure(target: TextureUnit; s: Int16; t: Int16; r: Int16; q: Int16)>(z_MultiTexCoord4sARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4sARB(target: TextureUnit; s: Int16; t: Int16; r: Int16; q: Int16) :=
    z_MultiTexCoord4sARB_1(target, s, t, r, q);
    
    private z_MultiTexCoord4svARB_adr := GetProcAddress('glMultiTexCoord4svARB');
    private z_MultiTexCoord4svARB_1 := GetProcOrNil&<procedure(target: TextureUnit; v: IntPtr)>(z_MultiTexCoord4svARB_adr);
    private z_MultiTexCoord4svARB_2 := GetProcOrNil&<procedure(target: TextureUnit; var v: Int16)>(z_MultiTexCoord4svARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4svARB(target: TextureUnit; v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MultiTexCoord4svARB_2(target, v[0]) else
        z_MultiTexCoord4svARB_2(target, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4svARB(target: TextureUnit; var v: Int16) :=
    z_MultiTexCoord4svARB_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4svARB(target: TextureUnit; v: IntPtr) :=
    z_MultiTexCoord4svARB_1(target, v);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glOcclusionQueryARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_occlusion_query';
    
    private z_GenQueriesARB_adr := GetProcAddress('glGenQueriesARB');
    private z_GenQueriesARB_1 := GetProcOrNil&<procedure(n: Int32; ids: IntPtr)>(z_GenQueriesARB_adr);
    private z_GenQueriesARB_2 := GetProcOrNil&<procedure(n: Int32; var ids: gl_query)>(z_GenQueriesARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenQueriesARB(n: Int32; ids: array of gl_query);
    type Pgl_query=^gl_query;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        z_GenQueriesARB_2(n, ids[0]) else
        z_GenQueriesARB_2(n, Pgl_query(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenQueriesARB(n: Int32; var ids: gl_query) :=
    z_GenQueriesARB_2(n, ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenQueriesARB(n: Int32; ids: IntPtr) :=
    z_GenQueriesARB_1(n, ids);
    
    private z_DeleteQueriesARB_adr := GetProcAddress('glDeleteQueriesARB');
    private z_DeleteQueriesARB_1 := GetProcOrNil&<procedure(n: Int32; ids: IntPtr)>(z_DeleteQueriesARB_adr);
    private z_DeleteQueriesARB_2 := GetProcOrNil&<procedure(n: Int32; var ids: gl_query)>(z_DeleteQueriesARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteQueriesARB(n: Int32; ids: array of gl_query);
    type Pgl_query=^gl_query;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        z_DeleteQueriesARB_2(n, ids[0]) else
        z_DeleteQueriesARB_2(n, Pgl_query(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteQueriesARB(n: Int32; var ids: gl_query) :=
    z_DeleteQueriesARB_2(n, ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteQueriesARB(n: Int32; ids: IntPtr) :=
    z_DeleteQueriesARB_1(n, ids);
    
    private z_IsQueryARB_adr := GetProcAddress('glIsQueryARB');
    private z_IsQueryARB_1 := GetProcOrNil&<function(id: gl_query): boolean>(z_IsQueryARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsQueryARB(id: gl_query): boolean :=
    z_IsQueryARB_1(id);
    
    private z_BeginQueryARB_adr := GetProcAddress('glBeginQueryARB');
    private z_BeginQueryARB_1 := GetProcOrNil&<procedure(target: QueryTarget; id: gl_query)>(z_BeginQueryARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginQueryARB(target: QueryTarget; id: gl_query) :=
    z_BeginQueryARB_1(target, id);
    
    private z_EndQueryARB_adr := GetProcAddress('glEndQueryARB');
    private z_EndQueryARB_1 := GetProcOrNil&<procedure(target: QueryTarget)>(z_EndQueryARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndQueryARB(target: QueryTarget) :=
    z_EndQueryARB_1(target);
    
    private z_GetQueryivARB_adr := GetProcAddress('glGetQueryivARB');
    private z_GetQueryivARB_1 := GetProcOrNil&<procedure(target: QueryTarget; pname: QueryParameterName; &params: IntPtr)>(z_GetQueryivARB_adr);
    private z_GetQueryivARB_2 := GetProcOrNil&<procedure(target: QueryTarget; pname: QueryParameterName; var &params: Int32)>(z_GetQueryivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryivARB(target: QueryTarget; pname: QueryParameterName; var &params: Int32) :=
    z_GetQueryivARB_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryivARB(target: QueryTarget; pname: QueryParameterName; &params: IntPtr) :=
    z_GetQueryivARB_1(target, pname, &params);
    
    private z_GetQueryObjectivARB_adr := GetProcAddress('glGetQueryObjectivARB');
    private z_GetQueryObjectivARB_1 := GetProcOrNil&<procedure(id: gl_query; pname: QueryObjectParameterName; &params: IntPtr)>(z_GetQueryObjectivARB_adr);
    private z_GetQueryObjectivARB_2 := GetProcOrNil&<procedure(id: gl_query; pname: QueryObjectParameterName; var &params: Int32)>(z_GetQueryObjectivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectivARB(id: gl_query; pname: QueryObjectParameterName; var &params: Int32) :=
    z_GetQueryObjectivARB_2(id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectivARB(id: gl_query; pname: QueryObjectParameterName; &params: IntPtr) :=
    z_GetQueryObjectivARB_1(id, pname, &params);
    
    private z_GetQueryObjectuivARB_adr := GetProcAddress('glGetQueryObjectuivARB');
    private z_GetQueryObjectuivARB_1 := GetProcOrNil&<procedure(id: gl_query; pname: QueryObjectParameterName; &params: IntPtr)>(z_GetQueryObjectuivARB_adr);
    private z_GetQueryObjectuivARB_2 := GetProcOrNil&<procedure(id: gl_query; pname: QueryObjectParameterName; var &params: UInt32)>(z_GetQueryObjectuivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectuivARB(id: gl_query; pname: QueryObjectParameterName; var &params: UInt32) :=
    z_GetQueryObjectuivARB_2(id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectuivARB(id: gl_query; pname: QueryObjectParameterName; &params: IntPtr) :=
    z_GetQueryObjectuivARB_1(id, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glParallelShaderCompileARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_parallel_shader_compile';
    
    private z_MaxShaderCompilerThreadsARB_adr := GetProcAddress('glMaxShaderCompilerThreadsARB');
    private z_MaxShaderCompilerThreadsARB_1 := GetProcOrNil&<procedure(count: UInt32)>(z_MaxShaderCompilerThreadsARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MaxShaderCompilerThreadsARB(count: UInt32) :=
    z_MaxShaderCompilerThreadsARB_1(count);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glPointParametersARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_point_parameters';
    
    private z_PointParameterfARB_adr := GetProcAddress('glPointParameterfARB');
    private z_PointParameterfARB_1 := GetProcOrNil&<procedure(pname: PointParameterName; param: single)>(z_PointParameterfARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfARB(pname: PointParameterName; param: single) :=
    z_PointParameterfARB_1(pname, param);
    
    private z_PointParameterfvARB_adr := GetProcAddress('glPointParameterfvARB');
    private z_PointParameterfvARB_1 := GetProcOrNil&<procedure(pname: PointParameterName; &params: IntPtr)>(z_PointParameterfvARB_adr);
    private z_PointParameterfvARB_2 := GetProcOrNil&<procedure(pname: PointParameterName; var &params: single)>(z_PointParameterfvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfvARB(pname: PointParameterName; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_PointParameterfvARB_2(pname, &params[0]) else
        z_PointParameterfvARB_2(pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfvARB(pname: PointParameterName; var &params: single) :=
    z_PointParameterfvARB_2(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfvARB(pname: PointParameterName; &params: IntPtr) :=
    z_PointParameterfvARB_1(pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glPolygonOffsetClampARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_polygon_offset_clamp';
    
    private z_PolygonOffsetClamp_adr := GetProcAddress('glPolygonOffsetClamp');
    private z_PolygonOffsetClamp_1 := GetProcOrNil&<procedure(factor: single; units: single; clamp: single)>(z_PolygonOffsetClamp_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PolygonOffsetClamp(factor: single; units: single; clamp: single) :=
    z_PolygonOffsetClamp_1(factor, units, clamp);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glProgramInterfaceQueryARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_program_interface_query';
    
    private z_GetProgramInterfaceiv_adr := GetProcAddress('glGetProgramInterfaceiv');
    private z_GetProgramInterfaceiv_1 := GetProcOrNil&<procedure(&program: gl_program; _programInterface: ProgramInterface; pname: ProgramInterfacePName; &params: IntPtr)>(z_GetProgramInterfaceiv_adr);
    private z_GetProgramInterfaceiv_2 := GetProcOrNil&<procedure(&program: gl_program; _programInterface: ProgramInterface; pname: ProgramInterfacePName; var &params: Int32)>(z_GetProgramInterfaceiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramInterfaceiv(&program: gl_program; _programInterface: ProgramInterface; pname: ProgramInterfacePName; var &params: Int32) :=
    z_GetProgramInterfaceiv_2(&program, _programInterface, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramInterfaceiv(&program: gl_program; _programInterface: ProgramInterface; pname: ProgramInterfacePName; &params: IntPtr) :=
    z_GetProgramInterfaceiv_1(&program, _programInterface, pname, &params);
    
    private z_GetProgramResourceIndex_adr := GetProcAddress('glGetProgramResourceIndex');
    private z_GetProgramResourceIndex_1 := GetProcOrNil&<function(&program: gl_program; _programInterface: ProgramInterface; name: IntPtr): UInt32>(z_GetProgramResourceIndex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProgramResourceIndex(&program: gl_program; _programInterface: ProgramInterface; name: string): UInt32;
    begin
      var name_str_ptr: IntPtr;
      try
        name_str_ptr := Marshal.StringToHGlobalAnsi(name);
        Result := z_GetProgramResourceIndex_1(&program, _programInterface, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProgramResourceIndex(&program: gl_program; _programInterface: ProgramInterface; name: IntPtr): UInt32 :=
    z_GetProgramResourceIndex_1(&program, _programInterface, name);
    
    private z_GetProgramResourceName_adr := GetProcAddress('glGetProgramResourceName');
    private z_GetProgramResourceName_1 := GetProcOrNil&<procedure(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; bufSize: Int32; length: IntPtr; name: IntPtr)>(z_GetProgramResourceName_adr);
    private z_GetProgramResourceName_2 := GetProcOrNil&<procedure(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; bufSize: Int32; var length: Int32; name: IntPtr)>(z_GetProgramResourceName_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceName(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; bufSize: Int32; var length: Int32; name: IntPtr) :=
    z_GetProgramResourceName_2(&program, _programInterface, index, bufSize, length, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceName(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; bufSize: Int32; length: IntPtr; name: IntPtr) :=
    z_GetProgramResourceName_1(&program, _programInterface, index, bufSize, length, name);
    
    private z_GetProgramResourceiv_adr := GetProcAddress('glGetProgramResourceiv');
    private z_GetProgramResourceiv_1 := GetProcOrNil&<procedure(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; length: IntPtr; &params: IntPtr)>(z_GetProgramResourceiv_adr);
    private z_GetProgramResourceiv_2 := GetProcOrNil&<procedure(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; length: IntPtr; var &params: Int32)>(z_GetProgramResourceiv_adr);
    private z_GetProgramResourceiv_3 := GetProcOrNil&<procedure(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; var length: Int32; &params: IntPtr)>(z_GetProgramResourceiv_adr);
    private z_GetProgramResourceiv_4 := GetProcOrNil&<procedure(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; var length: Int32; var &params: Int32)>(z_GetProgramResourceiv_adr);
    private z_GetProgramResourceiv_5 := GetProcOrNil&<procedure(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; var props: ProgramResourceProperty; count: Int32; length: IntPtr; &params: IntPtr)>(z_GetProgramResourceiv_adr);
    private z_GetProgramResourceiv_6 := GetProcOrNil&<procedure(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; var props: ProgramResourceProperty; count: Int32; length: IntPtr; var &params: Int32)>(z_GetProgramResourceiv_adr);
    private z_GetProgramResourceiv_7 := GetProcOrNil&<procedure(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; var props: ProgramResourceProperty; count: Int32; var length: Int32; &params: IntPtr)>(z_GetProgramResourceiv_adr);
    private z_GetProgramResourceiv_8 := GetProcOrNil&<procedure(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; var props: ProgramResourceProperty; count: Int32; var length: Int32; var &params: Int32)>(z_GetProgramResourceiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; props: array of ProgramResourceProperty; count: Int32; var length: Int32; var &params: Int32);
    type PProgramResourceProperty=^ProgramResourceProperty;
    begin
      if (props<>nil) and (props.Length<>0) then
        z_GetProgramResourceiv_8(&program, _programInterface, index, propCount, props[0], count, length, &params) else
        z_GetProgramResourceiv_8(&program, _programInterface, index, propCount, PProgramResourceProperty(nil)^, count, length, &params);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; props: array of ProgramResourceProperty; count: Int32; var length: Int32; &params: IntPtr);
    type PProgramResourceProperty=^ProgramResourceProperty;
    begin
      if (props<>nil) and (props.Length<>0) then
        z_GetProgramResourceiv_7(&program, _programInterface, index, propCount, props[0], count, length, &params) else
        z_GetProgramResourceiv_7(&program, _programInterface, index, propCount, PProgramResourceProperty(nil)^, count, length, &params);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; props: array of ProgramResourceProperty; count: Int32; length: IntPtr; var &params: Int32);
    type PProgramResourceProperty=^ProgramResourceProperty;
    begin
      if (props<>nil) and (props.Length<>0) then
        z_GetProgramResourceiv_6(&program, _programInterface, index, propCount, props[0], count, length, &params) else
        z_GetProgramResourceiv_6(&program, _programInterface, index, propCount, PProgramResourceProperty(nil)^, count, length, &params);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; props: array of ProgramResourceProperty; count: Int32; length: IntPtr; &params: IntPtr);
    type PProgramResourceProperty=^ProgramResourceProperty;
    begin
      if (props<>nil) and (props.Length<>0) then
        z_GetProgramResourceiv_5(&program, _programInterface, index, propCount, props[0], count, length, &params) else
        z_GetProgramResourceiv_5(&program, _programInterface, index, propCount, PProgramResourceProperty(nil)^, count, length, &params);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; var props: ProgramResourceProperty; count: Int32; var length: Int32; var &params: Int32) :=
    z_GetProgramResourceiv_8(&program, _programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; var props: ProgramResourceProperty; count: Int32; var length: Int32; &params: IntPtr) :=
    z_GetProgramResourceiv_7(&program, _programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; var props: ProgramResourceProperty; count: Int32; length: IntPtr; var &params: Int32) :=
    z_GetProgramResourceiv_6(&program, _programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; var props: ProgramResourceProperty; count: Int32; length: IntPtr; &params: IntPtr) :=
    z_GetProgramResourceiv_5(&program, _programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; var length: Int32; var &params: Int32) :=
    z_GetProgramResourceiv_4(&program, _programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; var length: Int32; &params: IntPtr) :=
    z_GetProgramResourceiv_3(&program, _programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; length: IntPtr; var &params: Int32) :=
    z_GetProgramResourceiv_2(&program, _programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; length: IntPtr; &params: IntPtr) :=
    z_GetProgramResourceiv_1(&program, _programInterface, index, propCount, props, count, length, &params);
    
    private z_GetProgramResourceLocation_adr := GetProcAddress('glGetProgramResourceLocation');
    private z_GetProgramResourceLocation_1 := GetProcOrNil&<function(&program: gl_program; _programInterface: ProgramInterface; name: IntPtr): Int32>(z_GetProgramResourceLocation_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProgramResourceLocation(&program: gl_program; _programInterface: ProgramInterface; name: string): Int32;
    begin
      var name_str_ptr: IntPtr;
      try
        name_str_ptr := Marshal.StringToHGlobalAnsi(name);
        Result := z_GetProgramResourceLocation_1(&program, _programInterface, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProgramResourceLocation(&program: gl_program; _programInterface: ProgramInterface; name: IntPtr): Int32 :=
    z_GetProgramResourceLocation_1(&program, _programInterface, name);
    
    private z_GetProgramResourceLocationIndex_adr := GetProcAddress('glGetProgramResourceLocationIndex');
    private z_GetProgramResourceLocationIndex_1 := GetProcOrNil&<function(&program: gl_program; _programInterface: ProgramInterface; name: IntPtr): Int32>(z_GetProgramResourceLocationIndex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProgramResourceLocationIndex(&program: gl_program; _programInterface: ProgramInterface; name: string): Int32;
    begin
      var name_str_ptr: IntPtr;
      try
        name_str_ptr := Marshal.StringToHGlobalAnsi(name);
        Result := z_GetProgramResourceLocationIndex_1(&program, _programInterface, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProgramResourceLocationIndex(&program: gl_program; _programInterface: ProgramInterface; name: IntPtr): Int32 :=
    z_GetProgramResourceLocationIndex_1(&program, _programInterface, name);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glProvokingVertexARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_provoking_vertex';
    
    private z_ProvokingVertex_adr := GetProcAddress('glProvokingVertex');
    private z_ProvokingVertex_1 := GetProcOrNil&<procedure(mode: VertexProvokingMode)>(z_ProvokingVertex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProvokingVertex(mode: VertexProvokingMode) :=
    z_ProvokingVertex_1(mode);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glRobustnessARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_robustness';
    
    private z_GetGraphicsResetStatusARB_adr := GetProcAddress('glGetGraphicsResetStatusARB');
    private z_GetGraphicsResetStatusARB_1 := GetProcOrNil&<function: GraphicsResetStatus>(z_GetGraphicsResetStatusARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGraphicsResetStatusARB: GraphicsResetStatus :=
    z_GetGraphicsResetStatusARB_1();
    
    private z_GetnTexImageARB_adr := GetProcAddress('glGetnTexImageARB');
    private z_GetnTexImageARB_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; format: PixelFormat; &type: PixelType; bufSize: Int32; img: IntPtr)>(z_GetnTexImageARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnTexImageARB(target: TextureTarget; level: Int32; format: PixelFormat; &type: PixelType; bufSize: Int32; img: IntPtr) :=
    z_GetnTexImageARB_1(target, level, format, &type, bufSize, img);
    
    private z_ReadnPixelsARB_adr := GetProcAddress('glReadnPixelsARB');
    private z_ReadnPixelsARB_1 := GetProcOrNil&<procedure(x: Int32; y: Int32; width: Int32; height: Int32; format: PixelFormat; &type: PixelType; bufSize: Int32; data: IntPtr)>(z_ReadnPixelsARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReadnPixelsARB(x: Int32; y: Int32; width: Int32; height: Int32; format: PixelFormat; &type: PixelType; bufSize: Int32; data: IntPtr) :=
    z_ReadnPixelsARB_1(x, y, width, height, format, &type, bufSize, data);
    
    private z_GetnCompressedTexImageARB_adr := GetProcAddress('glGetnCompressedTexImageARB');
    private z_GetnCompressedTexImageARB_1 := GetProcOrNil&<procedure(target: TextureTarget; lod: Int32; bufSize: Int32; img: IntPtr)>(z_GetnCompressedTexImageARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnCompressedTexImageARB(target: TextureTarget; lod: Int32; bufSize: Int32; img: IntPtr) :=
    z_GetnCompressedTexImageARB_1(target, lod, bufSize, img);
    
    private z_GetnUniformfvARB_adr := GetProcAddress('glGetnUniformfvARB');
    private z_GetnUniformfvARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr)>(z_GetnUniformfvARB_adr);
    private z_GetnUniformfvARB_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; var &params: single)>(z_GetnUniformfvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformfvARB(&program: gl_program; location: Int32; bufSize: Int32; var &params: single) :=
    z_GetnUniformfvARB_2(&program, location, bufSize, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformfvARB(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr) :=
    z_GetnUniformfvARB_1(&program, location, bufSize, &params);
    
    private z_GetnUniformivARB_adr := GetProcAddress('glGetnUniformivARB');
    private z_GetnUniformivARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr)>(z_GetnUniformivARB_adr);
    private z_GetnUniformivARB_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; var &params: Int32)>(z_GetnUniformivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformivARB(&program: gl_program; location: Int32; bufSize: Int32; var &params: Int32) :=
    z_GetnUniformivARB_2(&program, location, bufSize, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformivARB(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr) :=
    z_GetnUniformivARB_1(&program, location, bufSize, &params);
    
    private z_GetnUniformuivARB_adr := GetProcAddress('glGetnUniformuivARB');
    private z_GetnUniformuivARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr)>(z_GetnUniformuivARB_adr);
    private z_GetnUniformuivARB_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; var &params: UInt32)>(z_GetnUniformuivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformuivARB(&program: gl_program; location: Int32; bufSize: Int32; var &params: UInt32) :=
    z_GetnUniformuivARB_2(&program, location, bufSize, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformuivARB(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr) :=
    z_GetnUniformuivARB_1(&program, location, bufSize, &params);
    
    private z_GetnUniformdvARB_adr := GetProcAddress('glGetnUniformdvARB');
    private z_GetnUniformdvARB_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr)>(z_GetnUniformdvARB_adr);
    private z_GetnUniformdvARB_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; var &params: real)>(z_GetnUniformdvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformdvARB(&program: gl_program; location: Int32; bufSize: Int32; var &params: real) :=
    z_GetnUniformdvARB_2(&program, location, bufSize, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformdvARB(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr) :=
    z_GetnUniformdvARB_1(&program, location, bufSize, &params);
    
    private z_GetnMapdvARB_adr := GetProcAddress('glGetnMapdvARB');
    private z_GetnMapdvARB_1 := GetProcOrNil&<procedure(target: MapTarget; query: MapQuery; bufSize: Int32; v: IntPtr)>(z_GetnMapdvARB_adr);
    private z_GetnMapdvARB_2 := GetProcOrNil&<procedure(target: MapTarget; query: MapQuery; bufSize: Int32; var v: real)>(z_GetnMapdvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapdvARB(target: MapTarget; query: MapQuery; bufSize: Int32; var v: real) :=
    z_GetnMapdvARB_2(target, query, bufSize, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapdvARB(target: MapTarget; query: MapQuery; bufSize: Int32; v: IntPtr) :=
    z_GetnMapdvARB_1(target, query, bufSize, v);
    
    private z_GetnMapfvARB_adr := GetProcAddress('glGetnMapfvARB');
    private z_GetnMapfvARB_1 := GetProcOrNil&<procedure(target: MapTarget; query: MapQuery; bufSize: Int32; v: IntPtr)>(z_GetnMapfvARB_adr);
    private z_GetnMapfvARB_2 := GetProcOrNil&<procedure(target: MapTarget; query: MapQuery; bufSize: Int32; var v: single)>(z_GetnMapfvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapfvARB(target: MapTarget; query: MapQuery; bufSize: Int32; var v: single) :=
    z_GetnMapfvARB_2(target, query, bufSize, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapfvARB(target: MapTarget; query: MapQuery; bufSize: Int32; v: IntPtr) :=
    z_GetnMapfvARB_1(target, query, bufSize, v);
    
    private z_GetnMapivARB_adr := GetProcAddress('glGetnMapivARB');
    private z_GetnMapivARB_1 := GetProcOrNil&<procedure(target: MapTarget; query: MapQuery; bufSize: Int32; v: IntPtr)>(z_GetnMapivARB_adr);
    private z_GetnMapivARB_2 := GetProcOrNil&<procedure(target: MapTarget; query: MapQuery; bufSize: Int32; var v: Int32)>(z_GetnMapivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapivARB(target: MapTarget; query: MapQuery; bufSize: Int32; var v: Int32) :=
    z_GetnMapivARB_2(target, query, bufSize, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapivARB(target: MapTarget; query: MapQuery; bufSize: Int32; v: IntPtr) :=
    z_GetnMapivARB_1(target, query, bufSize, v);
    
    private z_GetnPixelMapfvARB_adr := GetProcAddress('glGetnPixelMapfvARB');
    private z_GetnPixelMapfvARB_1 := GetProcOrNil&<procedure(map: PixelMap; bufSize: Int32; values: IntPtr)>(z_GetnPixelMapfvARB_adr);
    private z_GetnPixelMapfvARB_2 := GetProcOrNil&<procedure(map: PixelMap; bufSize: Int32; var values: single)>(z_GetnPixelMapfvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapfvARB(map: PixelMap; bufSize: Int32; var values: single) :=
    z_GetnPixelMapfvARB_2(map, bufSize, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapfvARB(map: PixelMap; bufSize: Int32; values: IntPtr) :=
    z_GetnPixelMapfvARB_1(map, bufSize, values);
    
    private z_GetnPixelMapuivARB_adr := GetProcAddress('glGetnPixelMapuivARB');
    private z_GetnPixelMapuivARB_1 := GetProcOrNil&<procedure(map: PixelMap; bufSize: Int32; values: IntPtr)>(z_GetnPixelMapuivARB_adr);
    private z_GetnPixelMapuivARB_2 := GetProcOrNil&<procedure(map: PixelMap; bufSize: Int32; var values: UInt32)>(z_GetnPixelMapuivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapuivARB(map: PixelMap; bufSize: Int32; var values: UInt32) :=
    z_GetnPixelMapuivARB_2(map, bufSize, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapuivARB(map: PixelMap; bufSize: Int32; values: IntPtr) :=
    z_GetnPixelMapuivARB_1(map, bufSize, values);
    
    private z_GetnPixelMapusvARB_adr := GetProcAddress('glGetnPixelMapusvARB');
    private z_GetnPixelMapusvARB_1 := GetProcOrNil&<procedure(map: PixelMap; bufSize: Int32; values: IntPtr)>(z_GetnPixelMapusvARB_adr);
    private z_GetnPixelMapusvARB_2 := GetProcOrNil&<procedure(map: PixelMap; bufSize: Int32; var values: UInt16)>(z_GetnPixelMapusvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapusvARB(map: PixelMap; bufSize: Int32; var values: UInt16) :=
    z_GetnPixelMapusvARB_2(map, bufSize, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapusvARB(map: PixelMap; bufSize: Int32; values: IntPtr) :=
    z_GetnPixelMapusvARB_1(map, bufSize, values);
    
    private z_GetnPolygonStippleARB_adr := GetProcAddress('glGetnPolygonStippleARB');
    private z_GetnPolygonStippleARB_1 := GetProcOrNil&<procedure(bufSize: Int32; pattern: IntPtr)>(z_GetnPolygonStippleARB_adr);
    private z_GetnPolygonStippleARB_2 := GetProcOrNil&<procedure(bufSize: Int32; var pattern: Byte)>(z_GetnPolygonStippleARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPolygonStippleARB(bufSize: Int32; var pattern: Byte) :=
    z_GetnPolygonStippleARB_2(bufSize, pattern);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPolygonStippleARB(bufSize: Int32; pattern: IntPtr) :=
    z_GetnPolygonStippleARB_1(bufSize, pattern);
    
    private z_GetnColorTableARB_adr := GetProcAddress('glGetnColorTableARB');
    private z_GetnColorTableARB_1 := GetProcOrNil&<procedure(target: ColorTableTarget; format: PixelFormat; &type: PixelType; bufSize: Int32; table: IntPtr)>(z_GetnColorTableARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnColorTableARB(target: ColorTableTarget; format: PixelFormat; &type: PixelType; bufSize: Int32; table: IntPtr) :=
    z_GetnColorTableARB_1(target, format, &type, bufSize, table);
    
    private z_GetnConvolutionFilterARB_adr := GetProcAddress('glGetnConvolutionFilterARB');
    private z_GetnConvolutionFilterARB_1 := GetProcOrNil&<procedure(target: ConvolutionTarget; format: PixelFormat; &type: PixelType; bufSize: Int32; image: IntPtr)>(z_GetnConvolutionFilterARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnConvolutionFilterARB(target: ConvolutionTarget; format: PixelFormat; &type: PixelType; bufSize: Int32; image: IntPtr) :=
    z_GetnConvolutionFilterARB_1(target, format, &type, bufSize, image);
    
    private z_GetnSeparableFilterARB_adr := GetProcAddress('glGetnSeparableFilterARB');
    private z_GetnSeparableFilterARB_1 := GetProcOrNil&<procedure(target: SeparableTargetEXT; format: PixelFormat; &type: PixelType; rowBufSize: Int32; row: IntPtr; columnBufSize: Int32; column: IntPtr; span: IntPtr)>(z_GetnSeparableFilterARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnSeparableFilterARB(target: SeparableTargetEXT; format: PixelFormat; &type: PixelType; rowBufSize: Int32; row: IntPtr; columnBufSize: Int32; column: IntPtr; span: IntPtr) :=
    z_GetnSeparableFilterARB_1(target, format, &type, rowBufSize, row, columnBufSize, column, span);
    
    private z_GetnHistogramARB_adr := GetProcAddress('glGetnHistogramARB');
    private z_GetnHistogramARB_1 := GetProcOrNil&<procedure(target: HistogramTargetEXT; reset: boolean; format: PixelFormat; &type: PixelType; bufSize: Int32; values: IntPtr)>(z_GetnHistogramARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnHistogramARB(target: HistogramTargetEXT; reset: boolean; format: PixelFormat; &type: PixelType; bufSize: Int32; values: IntPtr) :=
    z_GetnHistogramARB_1(target, reset, format, &type, bufSize, values);
    
    private z_GetnMinmaxARB_adr := GetProcAddress('glGetnMinmaxARB');
    private z_GetnMinmaxARB_1 := GetProcOrNil&<procedure(target: MinmaxTargetEXT; reset: boolean; format: PixelFormat; &type: PixelType; bufSize: Int32; values: IntPtr)>(z_GetnMinmaxARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMinmaxARB(target: MinmaxTargetEXT; reset: boolean; format: PixelFormat; &type: PixelType; bufSize: Int32; values: IntPtr) :=
    z_GetnMinmaxARB_1(target, reset, format, &type, bufSize, values);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glSampleLocationsARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_sample_locations';
    
    private z_FramebufferSampleLocationsfvARB_adr := GetProcAddress('glFramebufferSampleLocationsfvARB');
    private z_FramebufferSampleLocationsfvARB_1 := GetProcOrNil&<procedure(target: FramebufferTarget; start: UInt32; count: Int32; v: IntPtr)>(z_FramebufferSampleLocationsfvARB_adr);
    private z_FramebufferSampleLocationsfvARB_2 := GetProcOrNil&<procedure(target: FramebufferTarget; start: UInt32; count: Int32; var v: single)>(z_FramebufferSampleLocationsfvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferSampleLocationsfvARB(target: FramebufferTarget; start: UInt32; count: Int32; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_FramebufferSampleLocationsfvARB_2(target, start, count, v[0]) else
        z_FramebufferSampleLocationsfvARB_2(target, start, count, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferSampleLocationsfvARB(target: FramebufferTarget; start: UInt32; count: Int32; var v: single) :=
    z_FramebufferSampleLocationsfvARB_2(target, start, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferSampleLocationsfvARB(target: FramebufferTarget; start: UInt32; count: Int32; v: IntPtr) :=
    z_FramebufferSampleLocationsfvARB_1(target, start, count, v);
    
    private z_NamedFramebufferSampleLocationsfvARB_adr := GetProcAddress('glNamedFramebufferSampleLocationsfvARB');
    private z_NamedFramebufferSampleLocationsfvARB_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; start: UInt32; count: Int32; v: IntPtr)>(z_NamedFramebufferSampleLocationsfvARB_adr);
    private z_NamedFramebufferSampleLocationsfvARB_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; start: UInt32; count: Int32; var v: single)>(z_NamedFramebufferSampleLocationsfvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferSampleLocationsfvARB(framebuffer: gl_framebuffer; start: UInt32; count: Int32; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_NamedFramebufferSampleLocationsfvARB_2(framebuffer, start, count, v[0]) else
        z_NamedFramebufferSampleLocationsfvARB_2(framebuffer, start, count, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferSampleLocationsfvARB(framebuffer: gl_framebuffer; start: UInt32; count: Int32; var v: single) :=
    z_NamedFramebufferSampleLocationsfvARB_2(framebuffer, start, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferSampleLocationsfvARB(framebuffer: gl_framebuffer; start: UInt32; count: Int32; v: IntPtr) :=
    z_NamedFramebufferSampleLocationsfvARB_1(framebuffer, start, count, v);
    
    private z_EvaluateDepthValuesARB_adr := GetProcAddress('glEvaluateDepthValuesARB');
    private z_EvaluateDepthValuesARB_1 := GetProcOrNil&<procedure>(z_EvaluateDepthValuesARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvaluateDepthValuesARB :=
    z_EvaluateDepthValuesARB_1();
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glSampleShadingARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_sample_shading';
    
    private z_MinSampleShadingARB_adr := GetProcAddress('glMinSampleShadingARB');
    private z_MinSampleShadingARB_1 := GetProcOrNil&<procedure(value: single)>(z_MinSampleShadingARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MinSampleShadingARB(value: single) :=
    z_MinSampleShadingARB_1(value);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glSamplerObjectsARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_sampler_objects';
    
    private z_GenSamplers_adr := GetProcAddress('glGenSamplers');
    private z_GenSamplers_1 := GetProcOrNil&<procedure(count: Int32; samplers: IntPtr)>(z_GenSamplers_adr);
    private z_GenSamplers_2 := GetProcOrNil&<procedure(count: Int32; var samplers: gl_sampler)>(z_GenSamplers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenSamplers(count: Int32; samplers: array of gl_sampler);
    type Pgl_sampler=^gl_sampler;
    begin
      if (samplers<>nil) and (samplers.Length<>0) then
        z_GenSamplers_2(count, samplers[0]) else
        z_GenSamplers_2(count, Pgl_sampler(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenSamplers(count: Int32; var samplers: gl_sampler) :=
    z_GenSamplers_2(count, samplers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenSamplers(count: Int32; samplers: IntPtr) :=
    z_GenSamplers_1(count, samplers);
    
    private z_DeleteSamplers_adr := GetProcAddress('glDeleteSamplers');
    private z_DeleteSamplers_1 := GetProcOrNil&<procedure(count: Int32; samplers: IntPtr)>(z_DeleteSamplers_adr);
    private z_DeleteSamplers_2 := GetProcOrNil&<procedure(count: Int32; var samplers: gl_sampler)>(z_DeleteSamplers_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteSamplers(count: Int32; samplers: array of gl_sampler);
    type Pgl_sampler=^gl_sampler;
    begin
      if (samplers<>nil) and (samplers.Length<>0) then
        z_DeleteSamplers_2(count, samplers[0]) else
        z_DeleteSamplers_2(count, Pgl_sampler(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteSamplers(count: Int32; var samplers: gl_sampler) :=
    z_DeleteSamplers_2(count, samplers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteSamplers(count: Int32; samplers: IntPtr) :=
    z_DeleteSamplers_1(count, samplers);
    
    private z_IsSampler_adr := GetProcAddress('glIsSampler');
    private z_IsSampler_1 := GetProcOrNil&<function(sampler: gl_sampler): boolean>(z_IsSampler_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsSampler(sampler: gl_sampler): boolean :=
    z_IsSampler_1(sampler);
    
    private z_BindSampler_adr := GetProcAddress('glBindSampler');
    private z_BindSampler_1 := GetProcOrNil&<procedure(&unit: UInt32; sampler: gl_sampler)>(z_BindSampler_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindSampler(&unit: UInt32; sampler: gl_sampler) :=
    z_BindSampler_1(&unit, sampler);
    
    private z_SamplerParameteri_adr := GetProcAddress('glSamplerParameteri');
    private z_SamplerParameteri_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; param: Int32)>(z_SamplerParameteri_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameteri(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; param: Int32) :=
    z_SamplerParameteri_1(sampler, pname, param);
    
    private z_SamplerParameteriv_adr := GetProcAddress('glSamplerParameteriv');
    private z_SamplerParameteriv_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; param: IntPtr)>(z_SamplerParameteriv_adr);
    private z_SamplerParameteriv_2 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; var param: Int32)>(z_SamplerParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameteriv(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; param: array of Int32);
    type PInt32=^Int32;
    begin
      if (param<>nil) and (param.Length<>0) then
        z_SamplerParameteriv_2(sampler, pname, param[0]) else
        z_SamplerParameteriv_2(sampler, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameteriv(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; var param: Int32) :=
    z_SamplerParameteriv_2(sampler, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameteriv(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; param: IntPtr) :=
    z_SamplerParameteriv_1(sampler, pname, param);
    
    private z_SamplerParameterf_adr := GetProcAddress('glSamplerParameterf');
    private z_SamplerParameterf_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: OpenGL.SamplerParameterF; param: single)>(z_SamplerParameterf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterf(sampler: gl_sampler; pname: OpenGL.SamplerParameterF; param: single) :=
    z_SamplerParameterf_1(sampler, pname, param);
    
    private z_SamplerParameterfv_adr := GetProcAddress('glSamplerParameterfv');
    private z_SamplerParameterfv_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: OpenGL.SamplerParameterF; param: IntPtr)>(z_SamplerParameterfv_adr);
    private z_SamplerParameterfv_2 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: OpenGL.SamplerParameterF; var param: single)>(z_SamplerParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterfv(sampler: gl_sampler; pname: OpenGL.SamplerParameterF; param: array of single);
    type Psingle=^single;
    begin
      if (param<>nil) and (param.Length<>0) then
        z_SamplerParameterfv_2(sampler, pname, param[0]) else
        z_SamplerParameterfv_2(sampler, pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterfv(sampler: gl_sampler; pname: OpenGL.SamplerParameterF; var param: single) :=
    z_SamplerParameterfv_2(sampler, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterfv(sampler: gl_sampler; pname: OpenGL.SamplerParameterF; param: IntPtr) :=
    z_SamplerParameterfv_1(sampler, pname, param);
    
    private z_SamplerParameterIiv_adr := GetProcAddress('glSamplerParameterIiv');
    private z_SamplerParameterIiv_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; param: IntPtr)>(z_SamplerParameterIiv_adr);
    private z_SamplerParameterIiv_2 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; var param: Int32)>(z_SamplerParameterIiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIiv(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; param: array of Int32);
    type PInt32=^Int32;
    begin
      if (param<>nil) and (param.Length<>0) then
        z_SamplerParameterIiv_2(sampler, pname, param[0]) else
        z_SamplerParameterIiv_2(sampler, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIiv(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; var param: Int32) :=
    z_SamplerParameterIiv_2(sampler, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIiv(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; param: IntPtr) :=
    z_SamplerParameterIiv_1(sampler, pname, param);
    
    private z_SamplerParameterIuiv_adr := GetProcAddress('glSamplerParameterIuiv');
    private z_SamplerParameterIuiv_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; param: IntPtr)>(z_SamplerParameterIuiv_adr);
    private z_SamplerParameterIuiv_2 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; var param: UInt32)>(z_SamplerParameterIuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIuiv(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; param: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (param<>nil) and (param.Length<>0) then
        z_SamplerParameterIuiv_2(sampler, pname, param[0]) else
        z_SamplerParameterIuiv_2(sampler, pname, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIuiv(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; var param: UInt32) :=
    z_SamplerParameterIuiv_2(sampler, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIuiv(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; param: IntPtr) :=
    z_SamplerParameterIuiv_1(sampler, pname, param);
    
    private z_GetSamplerParameteriv_adr := GetProcAddress('glGetSamplerParameteriv');
    private z_GetSamplerParameteriv_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; &params: IntPtr)>(z_GetSamplerParameteriv_adr);
    private z_GetSamplerParameteriv_2 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; var &params: Int32)>(z_GetSamplerParameteriv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameteriv(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; var &params: Int32) :=
    z_GetSamplerParameteriv_2(sampler, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameteriv(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; &params: IntPtr) :=
    z_GetSamplerParameteriv_1(sampler, pname, &params);
    
    private z_GetSamplerParameterIiv_adr := GetProcAddress('glGetSamplerParameterIiv');
    private z_GetSamplerParameterIiv_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; &params: IntPtr)>(z_GetSamplerParameterIiv_adr);
    private z_GetSamplerParameterIiv_2 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; var &params: Int32)>(z_GetSamplerParameterIiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterIiv(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; var &params: Int32) :=
    z_GetSamplerParameterIiv_2(sampler, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterIiv(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; &params: IntPtr) :=
    z_GetSamplerParameterIiv_1(sampler, pname, &params);
    
    private z_GetSamplerParameterfv_adr := GetProcAddress('glGetSamplerParameterfv');
    private z_GetSamplerParameterfv_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: OpenGL.SamplerParameterF; &params: IntPtr)>(z_GetSamplerParameterfv_adr);
    private z_GetSamplerParameterfv_2 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: OpenGL.SamplerParameterF; var &params: single)>(z_GetSamplerParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterfv(sampler: gl_sampler; pname: OpenGL.SamplerParameterF; var &params: single) :=
    z_GetSamplerParameterfv_2(sampler, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterfv(sampler: gl_sampler; pname: OpenGL.SamplerParameterF; &params: IntPtr) :=
    z_GetSamplerParameterfv_1(sampler, pname, &params);
    
    private z_GetSamplerParameterIuiv_adr := GetProcAddress('glGetSamplerParameterIuiv');
    private z_GetSamplerParameterIuiv_1 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; &params: IntPtr)>(z_GetSamplerParameterIuiv_adr);
    private z_GetSamplerParameterIuiv_2 := GetProcOrNil&<procedure(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; var &params: UInt32)>(z_GetSamplerParameterIuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterIuiv(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; var &params: UInt32) :=
    z_GetSamplerParameterIuiv_2(sampler, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterIuiv(sampler: gl_sampler; pname: OpenGL.SamplerParameterI; &params: IntPtr) :=
    z_GetSamplerParameterIuiv_1(sampler, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glSeparateShaderObjectsARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_separate_shader_objects';
    
    private z_UseProgramStages_adr := GetProcAddress('glUseProgramStages');
    private z_UseProgramStages_1 := GetProcOrNil&<procedure(pipeline: gl_program_pipeline; stages: UseProgramStageMask; &program: gl_program)>(z_UseProgramStages_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseProgramStages(pipeline: gl_program_pipeline; stages: UseProgramStageMask; &program: gl_program) :=
    z_UseProgramStages_1(pipeline, stages, &program);
    
    private z_ActiveShaderProgram_adr := GetProcAddress('glActiveShaderProgram');
    private z_ActiveShaderProgram_1 := GetProcOrNil&<procedure(pipeline: gl_program_pipeline; &program: gl_program)>(z_ActiveShaderProgram_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ActiveShaderProgram(pipeline: gl_program_pipeline; &program: gl_program) :=
    z_ActiveShaderProgram_1(pipeline, &program);
    
    private z_CreateShaderProgramv_adr := GetProcAddress('glCreateShaderProgramv');
    private z_CreateShaderProgramv_1 := GetProcOrNil&<function(&type: ShaderType; count: Int32; strings: pointer): gl_program>(z_CreateShaderProgramv_adr);
    private z_CreateShaderProgramv_2 := GetProcOrNil&<function(&type: ShaderType; count: Int32; var strings: IntPtr): gl_program>(z_CreateShaderProgramv_adr);
    private [MethodImpl(MethodImplOptions.AggressiveInlining)] function temp_CreateShaderProgramv_1(&type: ShaderType; count: Int32; strings: array of IntPtr): gl_program;
    type PIntPtr=^IntPtr;
    begin
      Result := if (strings<>nil) and (strings.Length<>0) then
        z_CreateShaderProgramv_2(&type, count, strings[0]) else
        z_CreateShaderProgramv_2(&type, count, PIntPtr(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateShaderProgramv(&type: ShaderType; count: Int32; strings: array of string): gl_program;
    begin
      var strings_str_ptrs: array of IntPtr;
      try
        strings_str_ptrs := strings?.ConvertAll(arr_el1->
          Marshal.StringToHGlobalAnsi(arr_el1)
        );
        Result := temp_CreateShaderProgramv_1(&type, count, strings_str_ptrs);
      finally
        if strings_str_ptrs<>nil then foreach var arr_el1 in strings_str_ptrs do
          Marshal.FreeHGlobal(arr_el1);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateShaderProgramv(&type: ShaderType; count: Int32; var strings: IntPtr): gl_program :=
    z_CreateShaderProgramv_2(&type, count, strings);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateShaderProgramv(&type: ShaderType; count: Int32; strings: pointer): gl_program :=
    z_CreateShaderProgramv_1(&type, count, strings);
    
    private z_BindProgramPipeline_adr := GetProcAddress('glBindProgramPipeline');
    private z_BindProgramPipeline_1 := GetProcOrNil&<procedure(pipeline: gl_program_pipeline)>(z_BindProgramPipeline_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindProgramPipeline(pipeline: gl_program_pipeline) :=
    z_BindProgramPipeline_1(pipeline);
    
    private z_DeleteProgramPipelines_adr := GetProcAddress('glDeleteProgramPipelines');
    private z_DeleteProgramPipelines_1 := GetProcOrNil&<procedure(n: Int32; pipelines: IntPtr)>(z_DeleteProgramPipelines_adr);
    private z_DeleteProgramPipelines_2 := GetProcOrNil&<procedure(n: Int32; var pipelines: gl_program_pipeline)>(z_DeleteProgramPipelines_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramPipelines(n: Int32; pipelines: array of gl_program_pipeline);
    type Pgl_program_pipeline=^gl_program_pipeline;
    begin
      if (pipelines<>nil) and (pipelines.Length<>0) then
        z_DeleteProgramPipelines_2(n, pipelines[0]) else
        z_DeleteProgramPipelines_2(n, Pgl_program_pipeline(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramPipelines(n: Int32; var pipelines: gl_program_pipeline) :=
    z_DeleteProgramPipelines_2(n, pipelines);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramPipelines(n: Int32; pipelines: IntPtr) :=
    z_DeleteProgramPipelines_1(n, pipelines);
    
    private z_GenProgramPipelines_adr := GetProcAddress('glGenProgramPipelines');
    private z_GenProgramPipelines_1 := GetProcOrNil&<procedure(n: Int32; pipelines: IntPtr)>(z_GenProgramPipelines_adr);
    private z_GenProgramPipelines_2 := GetProcOrNil&<procedure(n: Int32; var pipelines: gl_program_pipeline)>(z_GenProgramPipelines_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramPipelines(n: Int32; pipelines: array of gl_program_pipeline);
    type Pgl_program_pipeline=^gl_program_pipeline;
    begin
      if (pipelines<>nil) and (pipelines.Length<>0) then
        z_GenProgramPipelines_2(n, pipelines[0]) else
        z_GenProgramPipelines_2(n, Pgl_program_pipeline(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramPipelines(n: Int32; var pipelines: gl_program_pipeline) :=
    z_GenProgramPipelines_2(n, pipelines);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramPipelines(n: Int32; pipelines: IntPtr) :=
    z_GenProgramPipelines_1(n, pipelines);
    
    private z_IsProgramPipeline_adr := GetProcAddress('glIsProgramPipeline');
    private z_IsProgramPipeline_1 := GetProcOrNil&<function(pipeline: gl_program_pipeline): boolean>(z_IsProgramPipeline_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsProgramPipeline(pipeline: gl_program_pipeline): boolean :=
    z_IsProgramPipeline_1(pipeline);
    
    private z_GetProgramPipelineiv_adr := GetProcAddress('glGetProgramPipelineiv');
    private z_GetProgramPipelineiv_1 := GetProcOrNil&<procedure(pipeline: gl_program_pipeline; pname: PipelineParameterName; &params: IntPtr)>(z_GetProgramPipelineiv_adr);
    private z_GetProgramPipelineiv_2 := GetProcOrNil&<procedure(pipeline: gl_program_pipeline; pname: PipelineParameterName; var &params: Int32)>(z_GetProgramPipelineiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramPipelineiv(pipeline: gl_program_pipeline; pname: PipelineParameterName; var &params: Int32) :=
    z_GetProgramPipelineiv_2(pipeline, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramPipelineiv(pipeline: gl_program_pipeline; pname: PipelineParameterName; &params: IntPtr) :=
    z_GetProgramPipelineiv_1(pipeline, pname, &params);
    
    private z_ProgramParameteri_adr := GetProcAddress('glProgramParameteri');
    private z_ProgramParameteri_1 := GetProcOrNil&<procedure(&program: gl_program; pname: ProgramParameterPName; value: Int32)>(z_ProgramParameteri_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameteri(&program: gl_program; pname: ProgramParameterPName; value: Int32) :=
    z_ProgramParameteri_1(&program, pname, value);
    
    private z_ProgramUniform1i_adr := GetProcAddress('glProgramUniform1i');
    private z_ProgramUniform1i_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: Int32)>(z_ProgramUniform1i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i(&program: gl_program; location: Int32; v0: Int32) :=
    z_ProgramUniform1i_1(&program, location, v0);
    
    private z_ProgramUniform1iv_adr := GetProcAddress('glProgramUniform1iv');
    private z_ProgramUniform1iv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform1iv_adr);
    private z_ProgramUniform1iv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int32)>(z_ProgramUniform1iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1iv(&program: gl_program; location: Int32; count: Int32; value: array of Int32);
    type PInt32=^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform1iv_2(&program, location, count, value[0]) else
        z_ProgramUniform1iv_2(&program, location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1iv(&program: gl_program; location: Int32; count: Int32; var value: Int32) :=
    z_ProgramUniform1iv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1iv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform1iv_1(&program, location, count, value);
    
    private z_ProgramUniform1f_adr := GetProcAddress('glProgramUniform1f');
    private z_ProgramUniform1f_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: single)>(z_ProgramUniform1f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1f(&program: gl_program; location: Int32; v0: single) :=
    z_ProgramUniform1f_1(&program, location, v0);
    
    private z_ProgramUniform1fv_adr := GetProcAddress('glProgramUniform1fv');
    private z_ProgramUniform1fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform1fv_adr);
    private z_ProgramUniform1fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: single)>(z_ProgramUniform1fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1fv(&program: gl_program; location: Int32; count: Int32; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform1fv_2(&program, location, count, value[0]) else
        z_ProgramUniform1fv_2(&program, location, count, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1fv(&program: gl_program; location: Int32; count: Int32; var value: single) :=
    z_ProgramUniform1fv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1fv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform1fv_1(&program, location, count, value);
    
    private z_ProgramUniform1d_adr := GetProcAddress('glProgramUniform1d');
    private z_ProgramUniform1d_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: real)>(z_ProgramUniform1d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1d(&program: gl_program; location: Int32; v0: real) :=
    z_ProgramUniform1d_1(&program, location, v0);
    
    private z_ProgramUniform1dv_adr := GetProcAddress('glProgramUniform1dv');
    private z_ProgramUniform1dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform1dv_adr);
    private z_ProgramUniform1dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: real)>(z_ProgramUniform1dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1dv(&program: gl_program; location: Int32; count: Int32; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform1dv_2(&program, location, count, value[0]) else
        z_ProgramUniform1dv_2(&program, location, count, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1dv(&program: gl_program; location: Int32; count: Int32; var value: real) :=
    z_ProgramUniform1dv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1dv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform1dv_1(&program, location, count, value);
    
    private z_ProgramUniform1ui_adr := GetProcAddress('glProgramUniform1ui');
    private z_ProgramUniform1ui_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: UInt32)>(z_ProgramUniform1ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui(&program: gl_program; location: Int32; v0: UInt32) :=
    z_ProgramUniform1ui_1(&program, location, v0);
    
    private z_ProgramUniform1uiv_adr := GetProcAddress('glProgramUniform1uiv');
    private z_ProgramUniform1uiv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform1uiv_adr);
    private z_ProgramUniform1uiv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt32)>(z_ProgramUniform1uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1uiv(&program: gl_program; location: Int32; count: Int32; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform1uiv_2(&program, location, count, value[0]) else
        z_ProgramUniform1uiv_2(&program, location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1uiv(&program: gl_program; location: Int32; count: Int32; var value: UInt32) :=
    z_ProgramUniform1uiv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1uiv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform1uiv_1(&program, location, count, value);
    
    private z_ProgramUniform2i_adr := GetProcAddress('glProgramUniform2i');
    private z_ProgramUniform2i_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: Int32; v1: Int32)>(z_ProgramUniform2i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i(&program: gl_program; location: Int32; v0: Int32; v1: Int32) :=
    z_ProgramUniform2i_1(&program, location, v0, v1);
    
    private z_ProgramUniform2iv_adr := GetProcAddress('glProgramUniform2iv');
    private z_ProgramUniform2iv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform2iv_adr);
    private z_ProgramUniform2iv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int32)>(z_ProgramUniform2iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2iv(&program: gl_program; location: Int32; count: Int32; value: array of Int32);
    type PInt32=^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform2iv_2(&program, location, count, value[0]) else
        z_ProgramUniform2iv_2(&program, location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2iv(&program: gl_program; location: Int32; count: Int32; var value: Int32) :=
    z_ProgramUniform2iv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2iv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform2iv_1(&program, location, count, value);
    
    private z_ProgramUniform2f_adr := GetProcAddress('glProgramUniform2f');
    private z_ProgramUniform2f_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: single; v1: single)>(z_ProgramUniform2f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2f(&program: gl_program; location: Int32; v0: single; v1: single) :=
    z_ProgramUniform2f_1(&program, location, v0, v1);
    
    private z_ProgramUniform2fv_adr := GetProcAddress('glProgramUniform2fv');
    private z_ProgramUniform2fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform2fv_adr);
    private z_ProgramUniform2fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: single)>(z_ProgramUniform2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2fv(&program: gl_program; location: Int32; count: Int32; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform2fv_2(&program, location, count, value[0]) else
        z_ProgramUniform2fv_2(&program, location, count, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2fv(&program: gl_program; location: Int32; count: Int32; var value: single) :=
    z_ProgramUniform2fv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2fv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform2fv_1(&program, location, count, value);
    
    private z_ProgramUniform2d_adr := GetProcAddress('glProgramUniform2d');
    private z_ProgramUniform2d_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: real; v1: real)>(z_ProgramUniform2d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2d(&program: gl_program; location: Int32; v0: real; v1: real) :=
    z_ProgramUniform2d_1(&program, location, v0, v1);
    
    private z_ProgramUniform2dv_adr := GetProcAddress('glProgramUniform2dv');
    private z_ProgramUniform2dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform2dv_adr);
    private z_ProgramUniform2dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: real)>(z_ProgramUniform2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2dv(&program: gl_program; location: Int32; count: Int32; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform2dv_2(&program, location, count, value[0]) else
        z_ProgramUniform2dv_2(&program, location, count, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2dv(&program: gl_program; location: Int32; count: Int32; var value: real) :=
    z_ProgramUniform2dv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2dv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform2dv_1(&program, location, count, value);
    
    private z_ProgramUniform2ui_adr := GetProcAddress('glProgramUniform2ui');
    private z_ProgramUniform2ui_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: UInt32; v1: UInt32)>(z_ProgramUniform2ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui(&program: gl_program; location: Int32; v0: UInt32; v1: UInt32) :=
    z_ProgramUniform2ui_1(&program, location, v0, v1);
    
    private z_ProgramUniform2uiv_adr := GetProcAddress('glProgramUniform2uiv');
    private z_ProgramUniform2uiv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform2uiv_adr);
    private z_ProgramUniform2uiv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt32)>(z_ProgramUniform2uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2uiv(&program: gl_program; location: Int32; count: Int32; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform2uiv_2(&program, location, count, value[0]) else
        z_ProgramUniform2uiv_2(&program, location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2uiv(&program: gl_program; location: Int32; count: Int32; var value: UInt32) :=
    z_ProgramUniform2uiv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2uiv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform2uiv_1(&program, location, count, value);
    
    private z_ProgramUniform3i_adr := GetProcAddress('glProgramUniform3i');
    private z_ProgramUniform3i_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: Int32; v1: Int32; v2: Int32)>(z_ProgramUniform3i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i(&program: gl_program; location: Int32; v0: Int32; v1: Int32; v2: Int32) :=
    z_ProgramUniform3i_1(&program, location, v0, v1, v2);
    
    private z_ProgramUniform3iv_adr := GetProcAddress('glProgramUniform3iv');
    private z_ProgramUniform3iv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform3iv_adr);
    private z_ProgramUniform3iv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int32)>(z_ProgramUniform3iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3iv(&program: gl_program; location: Int32; count: Int32; value: array of Int32);
    type PInt32=^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform3iv_2(&program, location, count, value[0]) else
        z_ProgramUniform3iv_2(&program, location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3iv(&program: gl_program; location: Int32; count: Int32; var value: Int32) :=
    z_ProgramUniform3iv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3iv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform3iv_1(&program, location, count, value);
    
    private z_ProgramUniform3f_adr := GetProcAddress('glProgramUniform3f');
    private z_ProgramUniform3f_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: single; v1: single; v2: single)>(z_ProgramUniform3f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3f(&program: gl_program; location: Int32; v0: single; v1: single; v2: single) :=
    z_ProgramUniform3f_1(&program, location, v0, v1, v2);
    
    private z_ProgramUniform3fv_adr := GetProcAddress('glProgramUniform3fv');
    private z_ProgramUniform3fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform3fv_adr);
    private z_ProgramUniform3fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: single)>(z_ProgramUniform3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3fv(&program: gl_program; location: Int32; count: Int32; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform3fv_2(&program, location, count, value[0]) else
        z_ProgramUniform3fv_2(&program, location, count, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3fv(&program: gl_program; location: Int32; count: Int32; var value: single) :=
    z_ProgramUniform3fv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3fv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform3fv_1(&program, location, count, value);
    
    private z_ProgramUniform3d_adr := GetProcAddress('glProgramUniform3d');
    private z_ProgramUniform3d_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: real; v1: real; v2: real)>(z_ProgramUniform3d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3d(&program: gl_program; location: Int32; v0: real; v1: real; v2: real) :=
    z_ProgramUniform3d_1(&program, location, v0, v1, v2);
    
    private z_ProgramUniform3dv_adr := GetProcAddress('glProgramUniform3dv');
    private z_ProgramUniform3dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform3dv_adr);
    private z_ProgramUniform3dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: real)>(z_ProgramUniform3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3dv(&program: gl_program; location: Int32; count: Int32; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform3dv_2(&program, location, count, value[0]) else
        z_ProgramUniform3dv_2(&program, location, count, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3dv(&program: gl_program; location: Int32; count: Int32; var value: real) :=
    z_ProgramUniform3dv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3dv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform3dv_1(&program, location, count, value);
    
    private z_ProgramUniform3ui_adr := GetProcAddress('glProgramUniform3ui');
    private z_ProgramUniform3ui_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32)>(z_ProgramUniform3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui(&program: gl_program; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32) :=
    z_ProgramUniform3ui_1(&program, location, v0, v1, v2);
    
    private z_ProgramUniform3uiv_adr := GetProcAddress('glProgramUniform3uiv');
    private z_ProgramUniform3uiv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform3uiv_adr);
    private z_ProgramUniform3uiv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt32)>(z_ProgramUniform3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3uiv(&program: gl_program; location: Int32; count: Int32; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform3uiv_2(&program, location, count, value[0]) else
        z_ProgramUniform3uiv_2(&program, location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3uiv(&program: gl_program; location: Int32; count: Int32; var value: UInt32) :=
    z_ProgramUniform3uiv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3uiv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform3uiv_1(&program, location, count, value);
    
    private z_ProgramUniform4i_adr := GetProcAddress('glProgramUniform4i');
    private z_ProgramUniform4i_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: Int32; v1: Int32; v2: Int32; v3: Int32)>(z_ProgramUniform4i_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i(&program: gl_program; location: Int32; v0: Int32; v1: Int32; v2: Int32; v3: Int32) :=
    z_ProgramUniform4i_1(&program, location, v0, v1, v2, v3);
    
    private z_ProgramUniform4iv_adr := GetProcAddress('glProgramUniform4iv');
    private z_ProgramUniform4iv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform4iv_adr);
    private z_ProgramUniform4iv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int32)>(z_ProgramUniform4iv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4iv(&program: gl_program; location: Int32; count: Int32; value: array of Int32);
    type PInt32=^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform4iv_2(&program, location, count, value[0]) else
        z_ProgramUniform4iv_2(&program, location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4iv(&program: gl_program; location: Int32; count: Int32; var value: Int32) :=
    z_ProgramUniform4iv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4iv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform4iv_1(&program, location, count, value);
    
    private z_ProgramUniform4f_adr := GetProcAddress('glProgramUniform4f');
    private z_ProgramUniform4f_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: single; v1: single; v2: single; v3: single)>(z_ProgramUniform4f_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4f(&program: gl_program; location: Int32; v0: single; v1: single; v2: single; v3: single) :=
    z_ProgramUniform4f_1(&program, location, v0, v1, v2, v3);
    
    private z_ProgramUniform4fv_adr := GetProcAddress('glProgramUniform4fv');
    private z_ProgramUniform4fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform4fv_adr);
    private z_ProgramUniform4fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: single)>(z_ProgramUniform4fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4fv(&program: gl_program; location: Int32; count: Int32; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform4fv_2(&program, location, count, value[0]) else
        z_ProgramUniform4fv_2(&program, location, count, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4fv(&program: gl_program; location: Int32; count: Int32; var value: single) :=
    z_ProgramUniform4fv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4fv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform4fv_1(&program, location, count, value);
    
    private z_ProgramUniform4d_adr := GetProcAddress('glProgramUniform4d');
    private z_ProgramUniform4d_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: real; v1: real; v2: real; v3: real)>(z_ProgramUniform4d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4d(&program: gl_program; location: Int32; v0: real; v1: real; v2: real; v3: real) :=
    z_ProgramUniform4d_1(&program, location, v0, v1, v2, v3);
    
    private z_ProgramUniform4dv_adr := GetProcAddress('glProgramUniform4dv');
    private z_ProgramUniform4dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform4dv_adr);
    private z_ProgramUniform4dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: real)>(z_ProgramUniform4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4dv(&program: gl_program; location: Int32; count: Int32; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform4dv_2(&program, location, count, value[0]) else
        z_ProgramUniform4dv_2(&program, location, count, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4dv(&program: gl_program; location: Int32; count: Int32; var value: real) :=
    z_ProgramUniform4dv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4dv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform4dv_1(&program, location, count, value);
    
    private z_ProgramUniform4ui_adr := GetProcAddress('glProgramUniform4ui');
    private z_ProgramUniform4ui_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32; v3: UInt32)>(z_ProgramUniform4ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui(&program: gl_program; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32; v3: UInt32) :=
    z_ProgramUniform4ui_1(&program, location, v0, v1, v2, v3);
    
    private z_ProgramUniform4uiv_adr := GetProcAddress('glProgramUniform4uiv');
    private z_ProgramUniform4uiv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform4uiv_adr);
    private z_ProgramUniform4uiv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt32)>(z_ProgramUniform4uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4uiv(&program: gl_program; location: Int32; count: Int32; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform4uiv_2(&program, location, count, value[0]) else
        z_ProgramUniform4uiv_2(&program, location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4uiv(&program: gl_program; location: Int32; count: Int32; var value: UInt32) :=
    z_ProgramUniform4uiv_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4uiv(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform4uiv_1(&program, location, count, value);
    
    private z_ProgramUniformMatrix2fv_adr := GetProcAddress('glProgramUniformMatrix2fv');
    private z_ProgramUniformMatrix2fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix2fv_adr);
    private z_ProgramUniformMatrix2fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single)>(z_ProgramUniformMatrix2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix2fv_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix2fv_2(&program, location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_ProgramUniformMatrix2fv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix2fv_1(&program, location, count, transpose, value);
    
    private z_ProgramUniformMatrix3fv_adr := GetProcAddress('glProgramUniformMatrix3fv');
    private z_ProgramUniformMatrix3fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix3fv_adr);
    private z_ProgramUniformMatrix3fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single)>(z_ProgramUniformMatrix3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix3fv_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix3fv_2(&program, location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_ProgramUniformMatrix3fv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix3fv_1(&program, location, count, transpose, value);
    
    private z_ProgramUniformMatrix4fv_adr := GetProcAddress('glProgramUniformMatrix4fv');
    private z_ProgramUniformMatrix4fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix4fv_adr);
    private z_ProgramUniformMatrix4fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single)>(z_ProgramUniformMatrix4fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix4fv_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix4fv_2(&program, location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_ProgramUniformMatrix4fv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix4fv_1(&program, location, count, transpose, value);
    
    private z_ProgramUniformMatrix2dv_adr := GetProcAddress('glProgramUniformMatrix2dv');
    private z_ProgramUniformMatrix2dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix2dv_adr);
    private z_ProgramUniformMatrix2dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real)>(z_ProgramUniformMatrix2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix2dv_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix2dv_2(&program, location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_ProgramUniformMatrix2dv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix2dv_1(&program, location, count, transpose, value);
    
    private z_ProgramUniformMatrix3dv_adr := GetProcAddress('glProgramUniformMatrix3dv');
    private z_ProgramUniformMatrix3dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix3dv_adr);
    private z_ProgramUniformMatrix3dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real)>(z_ProgramUniformMatrix3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix3dv_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix3dv_2(&program, location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_ProgramUniformMatrix3dv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix3dv_1(&program, location, count, transpose, value);
    
    private z_ProgramUniformMatrix4dv_adr := GetProcAddress('glProgramUniformMatrix4dv');
    private z_ProgramUniformMatrix4dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix4dv_adr);
    private z_ProgramUniformMatrix4dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real)>(z_ProgramUniformMatrix4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix4dv_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix4dv_2(&program, location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_ProgramUniformMatrix4dv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix4dv_1(&program, location, count, transpose, value);
    
    private z_ProgramUniformMatrix2x3fv_adr := GetProcAddress('glProgramUniformMatrix2x3fv');
    private z_ProgramUniformMatrix2x3fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix2x3fv_adr);
    private z_ProgramUniformMatrix2x3fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single)>(z_ProgramUniformMatrix2x3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix2x3fv_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix2x3fv_2(&program, location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_ProgramUniformMatrix2x3fv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix2x3fv_1(&program, location, count, transpose, value);
    
    private z_ProgramUniformMatrix3x2fv_adr := GetProcAddress('glProgramUniformMatrix3x2fv');
    private z_ProgramUniformMatrix3x2fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix3x2fv_adr);
    private z_ProgramUniformMatrix3x2fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single)>(z_ProgramUniformMatrix3x2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix3x2fv_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix3x2fv_2(&program, location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_ProgramUniformMatrix3x2fv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix3x2fv_1(&program, location, count, transpose, value);
    
    private z_ProgramUniformMatrix2x4fv_adr := GetProcAddress('glProgramUniformMatrix2x4fv');
    private z_ProgramUniformMatrix2x4fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix2x4fv_adr);
    private z_ProgramUniformMatrix2x4fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single)>(z_ProgramUniformMatrix2x4fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix2x4fv_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix2x4fv_2(&program, location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_ProgramUniformMatrix2x4fv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix2x4fv_1(&program, location, count, transpose, value);
    
    private z_ProgramUniformMatrix4x2fv_adr := GetProcAddress('glProgramUniformMatrix4x2fv');
    private z_ProgramUniformMatrix4x2fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix4x2fv_adr);
    private z_ProgramUniformMatrix4x2fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single)>(z_ProgramUniformMatrix4x2fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix4x2fv_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix4x2fv_2(&program, location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_ProgramUniformMatrix4x2fv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix4x2fv_1(&program, location, count, transpose, value);
    
    private z_ProgramUniformMatrix3x4fv_adr := GetProcAddress('glProgramUniformMatrix3x4fv');
    private z_ProgramUniformMatrix3x4fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix3x4fv_adr);
    private z_ProgramUniformMatrix3x4fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single)>(z_ProgramUniformMatrix3x4fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix3x4fv_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix3x4fv_2(&program, location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_ProgramUniformMatrix3x4fv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix3x4fv_1(&program, location, count, transpose, value);
    
    private z_ProgramUniformMatrix4x3fv_adr := GetProcAddress('glProgramUniformMatrix4x3fv');
    private z_ProgramUniformMatrix4x3fv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix4x3fv_adr);
    private z_ProgramUniformMatrix4x3fv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single)>(z_ProgramUniformMatrix4x3fv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix4x3fv_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix4x3fv_2(&program, location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_ProgramUniformMatrix4x3fv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3fv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix4x3fv_1(&program, location, count, transpose, value);
    
    private z_ProgramUniformMatrix2x3dv_adr := GetProcAddress('glProgramUniformMatrix2x3dv');
    private z_ProgramUniformMatrix2x3dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix2x3dv_adr);
    private z_ProgramUniformMatrix2x3dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real)>(z_ProgramUniformMatrix2x3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix2x3dv_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix2x3dv_2(&program, location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_ProgramUniformMatrix2x3dv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix2x3dv_1(&program, location, count, transpose, value);
    
    private z_ProgramUniformMatrix3x2dv_adr := GetProcAddress('glProgramUniformMatrix3x2dv');
    private z_ProgramUniformMatrix3x2dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix3x2dv_adr);
    private z_ProgramUniformMatrix3x2dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real)>(z_ProgramUniformMatrix3x2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix3x2dv_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix3x2dv_2(&program, location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_ProgramUniformMatrix3x2dv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix3x2dv_1(&program, location, count, transpose, value);
    
    private z_ProgramUniformMatrix2x4dv_adr := GetProcAddress('glProgramUniformMatrix2x4dv');
    private z_ProgramUniformMatrix2x4dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix2x4dv_adr);
    private z_ProgramUniformMatrix2x4dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real)>(z_ProgramUniformMatrix2x4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix2x4dv_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix2x4dv_2(&program, location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_ProgramUniformMatrix2x4dv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix2x4dv_1(&program, location, count, transpose, value);
    
    private z_ProgramUniformMatrix4x2dv_adr := GetProcAddress('glProgramUniformMatrix4x2dv');
    private z_ProgramUniformMatrix4x2dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix4x2dv_adr);
    private z_ProgramUniformMatrix4x2dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real)>(z_ProgramUniformMatrix4x2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix4x2dv_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix4x2dv_2(&program, location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_ProgramUniformMatrix4x2dv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix4x2dv_1(&program, location, count, transpose, value);
    
    private z_ProgramUniformMatrix3x4dv_adr := GetProcAddress('glProgramUniformMatrix3x4dv');
    private z_ProgramUniformMatrix3x4dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix3x4dv_adr);
    private z_ProgramUniformMatrix3x4dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real)>(z_ProgramUniformMatrix3x4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix3x4dv_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix3x4dv_2(&program, location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_ProgramUniformMatrix3x4dv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix3x4dv_1(&program, location, count, transpose, value);
    
    private z_ProgramUniformMatrix4x3dv_adr := GetProcAddress('glProgramUniformMatrix4x3dv');
    private z_ProgramUniformMatrix4x3dv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix4x3dv_adr);
    private z_ProgramUniformMatrix4x3dv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real)>(z_ProgramUniformMatrix4x3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix4x3dv_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix4x3dv_2(&program, location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_ProgramUniformMatrix4x3dv_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3dv(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix4x3dv_1(&program, location, count, transpose, value);
    
    private z_ValidateProgramPipeline_adr := GetProcAddress('glValidateProgramPipeline');
    private z_ValidateProgramPipeline_1 := GetProcOrNil&<procedure(pipeline: gl_program_pipeline)>(z_ValidateProgramPipeline_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ValidateProgramPipeline(pipeline: gl_program_pipeline) :=
    z_ValidateProgramPipeline_1(pipeline);
    
    private z_GetProgramPipelineInfoLog_adr := GetProcAddress('glGetProgramPipelineInfoLog');
    private z_GetProgramPipelineInfoLog_1 := GetProcOrNil&<procedure(pipeline: gl_program_pipeline; bufSize: Int32; length: IntPtr; infoLog: IntPtr)>(z_GetProgramPipelineInfoLog_adr);
    private z_GetProgramPipelineInfoLog_2 := GetProcOrNil&<procedure(pipeline: gl_program_pipeline; bufSize: Int32; var length: Int32; infoLog: IntPtr)>(z_GetProgramPipelineInfoLog_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramPipelineInfoLog(pipeline: gl_program_pipeline; bufSize: Int32; var length: Int32; infoLog: IntPtr) :=
    z_GetProgramPipelineInfoLog_2(pipeline, bufSize, length, infoLog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramPipelineInfoLog(pipeline: gl_program_pipeline; bufSize: Int32; length: IntPtr; infoLog: IntPtr) :=
    z_GetProgramPipelineInfoLog_1(pipeline, bufSize, length, infoLog);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glShaderAtomicCountersARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_shader_atomic_counters';
    
    private z_GetActiveAtomicCounterBufferiv_adr := GetProcAddress('glGetActiveAtomicCounterBufferiv');
    private z_GetActiveAtomicCounterBufferiv_1 := GetProcOrNil&<procedure(&program: gl_program; bufferIndex: UInt32; pname: AtomicCounterBufferPName; &params: IntPtr)>(z_GetActiveAtomicCounterBufferiv_adr);
    private z_GetActiveAtomicCounterBufferiv_2 := GetProcOrNil&<procedure(&program: gl_program; bufferIndex: UInt32; pname: AtomicCounterBufferPName; var &params: Int32)>(z_GetActiveAtomicCounterBufferiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAtomicCounterBufferiv(&program: gl_program; bufferIndex: UInt32; pname: AtomicCounterBufferPName; var &params: Int32) :=
    z_GetActiveAtomicCounterBufferiv_2(&program, bufferIndex, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAtomicCounterBufferiv(&program: gl_program; bufferIndex: UInt32; pname: AtomicCounterBufferPName; &params: IntPtr) :=
    z_GetActiveAtomicCounterBufferiv_1(&program, bufferIndex, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glShaderImageLoadStoreARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_shader_image_load_store';
    
    private z_BindImageTexture_adr := GetProcAddress('glBindImageTexture');
    private z_BindImageTexture_1 := GetProcOrNil&<procedure(&unit: UInt32; texture: gl_texture; level: Int32; layered: boolean; layer: Int32; access: BufferAccess; format: InternalFormat)>(z_BindImageTexture_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindImageTexture(&unit: UInt32; texture: gl_texture; level: Int32; layered: boolean; layer: Int32; access: BufferAccess; format: InternalFormat) :=
    z_BindImageTexture_1(&unit, texture, level, layered, layer, access, format);
    
    private z_MemoryBarrier_adr := GetProcAddress('glMemoryBarrier');
    private z_MemoryBarrier_1 := GetProcOrNil&<procedure(barriers: MemoryBarrierMask)>(z_MemoryBarrier_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MemoryBarrier(barriers: MemoryBarrierMask) :=
    z_MemoryBarrier_1(barriers);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glShaderObjectsARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_shader_objects';
    
    private z_DeleteObjectARB_adr := GetProcAddress('glDeleteObjectARB');
    private z_DeleteObjectARB_1 := GetProcOrNil&<procedure(obj: gl_handle_ARB)>(z_DeleteObjectARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteObjectARB(obj: gl_handle_ARB) :=
    z_DeleteObjectARB_1(obj);
    
    private z_GetHandleARB_adr := GetProcAddress('glGetHandleARB');
    private z_GetHandleARB_1 := GetProcOrNil&<function(pname: ContainerType): gl_handle_ARB>(z_GetHandleARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetHandleARB(pname: ContainerType): gl_handle_ARB :=
    z_GetHandleARB_1(pname);
    
    private z_DetachObjectARB_adr := GetProcAddress('glDetachObjectARB');
    private z_DetachObjectARB_1 := GetProcOrNil&<procedure(containerObj: gl_handle_ARB; attachedObj: gl_handle_ARB)>(z_DetachObjectARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DetachObjectARB(containerObj: gl_handle_ARB; attachedObj: gl_handle_ARB) :=
    z_DetachObjectARB_1(containerObj, attachedObj);
    
    private z_CreateShaderObjectARB_adr := GetProcAddress('glCreateShaderObjectARB');
    private z_CreateShaderObjectARB_1 := GetProcOrNil&<function(_shaderType: ShaderType): gl_handle_ARB>(z_CreateShaderObjectARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateShaderObjectARB(_shaderType: ShaderType): gl_handle_ARB :=
    z_CreateShaderObjectARB_1(_shaderType);
    
    private z_ShaderSourceARB_adr := GetProcAddress('glShaderSourceARB');
    private z_ShaderSourceARB_1 := GetProcOrNil&<procedure(shaderObj: gl_handle_ARB; count: Int32; _string: pointer; length: IntPtr)>(z_ShaderSourceARB_adr);
    private z_ShaderSourceARB_2 := GetProcOrNil&<procedure(shaderObj: gl_handle_ARB; count: Int32; _string: pointer; var length: Int32)>(z_ShaderSourceARB_adr);
    private z_ShaderSourceARB_3 := GetProcOrNil&<procedure(shaderObj: gl_handle_ARB; count: Int32; var _string: IntPtr; length: IntPtr)>(z_ShaderSourceARB_adr);
    private z_ShaderSourceARB_4 := GetProcOrNil&<procedure(shaderObj: gl_handle_ARB; count: Int32; var _string: IntPtr; var length: Int32)>(z_ShaderSourceARB_adr);
    private [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure temp_ShaderSourceARB_1(shaderObj: gl_handle_ARB; count: Int32; _string: array of IntPtr; length: array of Int32);
    type PIntPtr=^IntPtr;
    type PInt32=^Int32;
    begin
      if (length<>nil) and (length.Length<>0) then
        if (_string<>nil) and (_string.Length<>0) then
          z_ShaderSourceARB_4(shaderObj, count, _string[0], length[0]) else
          z_ShaderSourceARB_4(shaderObj, count, PIntPtr(nil)^, length[0]) else
        if (_string<>nil) and (_string.Length<>0) then
          z_ShaderSourceARB_4(shaderObj, count, _string[0], PInt32(nil)^) else
          z_ShaderSourceARB_4(shaderObj, count, PIntPtr(nil)^, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderSourceARB(shaderObj: gl_handle_ARB; count: Int32; _string: array of string; length: array of Int32);
    begin
      var _string_str_ptrs: array of IntPtr;
      try
        _string_str_ptrs := _string?.ConvertAll(arr_el1->
          Marshal.StringToHGlobalAnsi(arr_el1)
        );
        temp_ShaderSourceARB_1(shaderObj, count, _string_str_ptrs, length);
      finally
        if _string_str_ptrs<>nil then foreach var arr_el1 in _string_str_ptrs do
          Marshal.FreeHGlobal(arr_el1);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderSourceARB(shaderObj: gl_handle_ARB; count: Int32; var _string: IntPtr; var length: Int32) :=
    z_ShaderSourceARB_4(shaderObj, count, _string, length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderSourceARB(shaderObj: gl_handle_ARB; count: Int32; var _string: IntPtr; length: IntPtr) :=
    z_ShaderSourceARB_3(shaderObj, count, _string, length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderSourceARB(shaderObj: gl_handle_ARB; count: Int32; _string: pointer; var length: Int32) :=
    z_ShaderSourceARB_2(shaderObj, count, _string, length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderSourceARB(shaderObj: gl_handle_ARB; count: Int32; _string: pointer; length: IntPtr) :=
    z_ShaderSourceARB_1(shaderObj, count, _string, length);
    
    private z_CompileShaderARB_adr := GetProcAddress('glCompileShaderARB');
    private z_CompileShaderARB_1 := GetProcOrNil&<procedure(shaderObj: gl_handle_ARB)>(z_CompileShaderARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileShaderARB(shaderObj: gl_handle_ARB) :=
    z_CompileShaderARB_1(shaderObj);
    
    private z_CreateProgramObjectARB_adr := GetProcAddress('glCreateProgramObjectARB');
    private z_CreateProgramObjectARB_1 := GetProcOrNil&<function: gl_handle_ARB>(z_CreateProgramObjectARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateProgramObjectARB: gl_handle_ARB :=
    z_CreateProgramObjectARB_1();
    
    private z_AttachObjectARB_adr := GetProcAddress('glAttachObjectARB');
    private z_AttachObjectARB_1 := GetProcOrNil&<procedure(containerObj: gl_handle_ARB; obj: gl_handle_ARB)>(z_AttachObjectARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AttachObjectARB(containerObj: gl_handle_ARB; obj: gl_handle_ARB) :=
    z_AttachObjectARB_1(containerObj, obj);
    
    private z_LinkProgramARB_adr := GetProcAddress('glLinkProgramARB');
    private z_LinkProgramARB_1 := GetProcOrNil&<procedure(programObj: gl_handle_ARB)>(z_LinkProgramARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LinkProgramARB(programObj: gl_handle_ARB) :=
    z_LinkProgramARB_1(programObj);
    
    private z_UseProgramObjectARB_adr := GetProcAddress('glUseProgramObjectARB');
    private z_UseProgramObjectARB_1 := GetProcOrNil&<procedure(programObj: gl_handle_ARB)>(z_UseProgramObjectARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseProgramObjectARB(programObj: gl_handle_ARB) :=
    z_UseProgramObjectARB_1(programObj);
    
    private z_ValidateProgramARB_adr := GetProcAddress('glValidateProgramARB');
    private z_ValidateProgramARB_1 := GetProcOrNil&<procedure(programObj: gl_handle_ARB)>(z_ValidateProgramARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ValidateProgramARB(programObj: gl_handle_ARB) :=
    z_ValidateProgramARB_1(programObj);
    
    private z_Uniform1fARB_adr := GetProcAddress('glUniform1fARB');
    private z_Uniform1fARB_1 := GetProcOrNil&<procedure(location: Int32; v0: single)>(z_Uniform1fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1fARB(location: Int32; v0: single) :=
    z_Uniform1fARB_1(location, v0);
    
    private z_Uniform2fARB_adr := GetProcAddress('glUniform2fARB');
    private z_Uniform2fARB_1 := GetProcOrNil&<procedure(location: Int32; v0: single; v1: single)>(z_Uniform2fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2fARB(location: Int32; v0: single; v1: single) :=
    z_Uniform2fARB_1(location, v0, v1);
    
    private z_Uniform3fARB_adr := GetProcAddress('glUniform3fARB');
    private z_Uniform3fARB_1 := GetProcOrNil&<procedure(location: Int32; v0: single; v1: single; v2: single)>(z_Uniform3fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3fARB(location: Int32; v0: single; v1: single; v2: single) :=
    z_Uniform3fARB_1(location, v0, v1, v2);
    
    private z_Uniform4fARB_adr := GetProcAddress('glUniform4fARB');
    private z_Uniform4fARB_1 := GetProcOrNil&<procedure(location: Int32; v0: single; v1: single; v2: single; v3: single)>(z_Uniform4fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4fARB(location: Int32; v0: single; v1: single; v2: single; v3: single) :=
    z_Uniform4fARB_1(location, v0, v1, v2, v3);
    
    private z_Uniform1iARB_adr := GetProcAddress('glUniform1iARB');
    private z_Uniform1iARB_1 := GetProcOrNil&<procedure(location: Int32; v0: Int32)>(z_Uniform1iARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1iARB(location: Int32; v0: Int32) :=
    z_Uniform1iARB_1(location, v0);
    
    private z_Uniform2iARB_adr := GetProcAddress('glUniform2iARB');
    private z_Uniform2iARB_1 := GetProcOrNil&<procedure(location: Int32; v0: Int32; v1: Int32)>(z_Uniform2iARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2iARB(location: Int32; v0: Int32; v1: Int32) :=
    z_Uniform2iARB_1(location, v0, v1);
    
    private z_Uniform3iARB_adr := GetProcAddress('glUniform3iARB');
    private z_Uniform3iARB_1 := GetProcOrNil&<procedure(location: Int32; v0: Int32; v1: Int32; v2: Int32)>(z_Uniform3iARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3iARB(location: Int32; v0: Int32; v1: Int32; v2: Int32) :=
    z_Uniform3iARB_1(location, v0, v1, v2);
    
    private z_Uniform4iARB_adr := GetProcAddress('glUniform4iARB');
    private z_Uniform4iARB_1 := GetProcOrNil&<procedure(location: Int32; v0: Int32; v1: Int32; v2: Int32; v3: Int32)>(z_Uniform4iARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4iARB(location: Int32; v0: Int32; v1: Int32; v2: Int32; v3: Int32) :=
    z_Uniform4iARB_1(location, v0, v1, v2, v3);
    
    private z_Uniform1fvARB_adr := GetProcAddress('glUniform1fvARB');
    private z_Uniform1fvARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform1fvARB_adr);
    private z_Uniform1fvARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: single)>(z_Uniform1fvARB_adr);
    private z_Uniform1fvARB_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec1f)>(z_Uniform1fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1fvARB(location: Int32; count: Int32; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform1fvARB_2(location, count, value[0]) else
        z_Uniform1fvARB_2(location, count, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1fvARB(location: Int32; count: Int32; var value: Vec1f) :=
    z_Uniform1fvARB_3(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1fvARB(location: Int32; count: Int32; var value: single) :=
    z_Uniform1fvARB_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1fvARB(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform1fvARB_1(location, count, value);
    
    private z_Uniform2fvARB_adr := GetProcAddress('glUniform2fvARB');
    private z_Uniform2fvARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform2fvARB_adr);
    private z_Uniform2fvARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: single)>(z_Uniform2fvARB_adr);
    private z_Uniform2fvARB_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec2f)>(z_Uniform2fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2fvARB(location: Int32; count: Int32; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform2fvARB_2(location, count, value[0]) else
        z_Uniform2fvARB_2(location, count, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2fvARB(location: Int32; count: Int32; var value: Vec2f) :=
    z_Uniform2fvARB_3(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2fvARB(location: Int32; count: Int32; var value: single) :=
    z_Uniform2fvARB_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2fvARB(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform2fvARB_1(location, count, value);
    
    private z_Uniform3fvARB_adr := GetProcAddress('glUniform3fvARB');
    private z_Uniform3fvARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform3fvARB_adr);
    private z_Uniform3fvARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: single)>(z_Uniform3fvARB_adr);
    private z_Uniform3fvARB_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec3f)>(z_Uniform3fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3fvARB(location: Int32; count: Int32; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform3fvARB_2(location, count, value[0]) else
        z_Uniform3fvARB_2(location, count, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3fvARB(location: Int32; count: Int32; var value: Vec3f) :=
    z_Uniform3fvARB_3(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3fvARB(location: Int32; count: Int32; var value: single) :=
    z_Uniform3fvARB_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3fvARB(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform3fvARB_1(location, count, value);
    
    private z_Uniform4fvARB_adr := GetProcAddress('glUniform4fvARB');
    private z_Uniform4fvARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform4fvARB_adr);
    private z_Uniform4fvARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: single)>(z_Uniform4fvARB_adr);
    private z_Uniform4fvARB_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec4f)>(z_Uniform4fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4fvARB(location: Int32; count: Int32; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform4fvARB_2(location, count, value[0]) else
        z_Uniform4fvARB_2(location, count, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4fvARB(location: Int32; count: Int32; var value: Vec4f) :=
    z_Uniform4fvARB_3(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4fvARB(location: Int32; count: Int32; var value: single) :=
    z_Uniform4fvARB_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4fvARB(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform4fvARB_1(location, count, value);
    
    private z_Uniform1ivARB_adr := GetProcAddress('glUniform1ivARB');
    private z_Uniform1ivARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform1ivARB_adr);
    private z_Uniform1ivARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int32)>(z_Uniform1ivARB_adr);
    private z_Uniform1ivARB_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec1i)>(z_Uniform1ivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ivARB(location: Int32; count: Int32; value: array of Int32);
    type PInt32=^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform1ivARB_2(location, count, value[0]) else
        z_Uniform1ivARB_2(location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ivARB(location: Int32; count: Int32; var value: Vec1i) :=
    z_Uniform1ivARB_3(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ivARB(location: Int32; count: Int32; var value: Int32) :=
    z_Uniform1ivARB_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ivARB(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform1ivARB_1(location, count, value);
    
    private z_Uniform2ivARB_adr := GetProcAddress('glUniform2ivARB');
    private z_Uniform2ivARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform2ivARB_adr);
    private z_Uniform2ivARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int32)>(z_Uniform2ivARB_adr);
    private z_Uniform2ivARB_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec2i)>(z_Uniform2ivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ivARB(location: Int32; count: Int32; value: array of Int32);
    type PInt32=^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform2ivARB_2(location, count, value[0]) else
        z_Uniform2ivARB_2(location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ivARB(location: Int32; count: Int32; var value: Vec2i) :=
    z_Uniform2ivARB_3(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ivARB(location: Int32; count: Int32; var value: Int32) :=
    z_Uniform2ivARB_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ivARB(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform2ivARB_1(location, count, value);
    
    private z_Uniform3ivARB_adr := GetProcAddress('glUniform3ivARB');
    private z_Uniform3ivARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform3ivARB_adr);
    private z_Uniform3ivARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int32)>(z_Uniform3ivARB_adr);
    private z_Uniform3ivARB_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec3i)>(z_Uniform3ivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ivARB(location: Int32; count: Int32; value: array of Int32);
    type PInt32=^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform3ivARB_2(location, count, value[0]) else
        z_Uniform3ivARB_2(location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ivARB(location: Int32; count: Int32; var value: Vec3i) :=
    z_Uniform3ivARB_3(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ivARB(location: Int32; count: Int32; var value: Int32) :=
    z_Uniform3ivARB_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ivARB(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform3ivARB_1(location, count, value);
    
    private z_Uniform4ivARB_adr := GetProcAddress('glUniform4ivARB');
    private z_Uniform4ivARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform4ivARB_adr);
    private z_Uniform4ivARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int32)>(z_Uniform4ivARB_adr);
    private z_Uniform4ivARB_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec4i)>(z_Uniform4ivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ivARB(location: Int32; count: Int32; value: array of Int32);
    type PInt32=^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform4ivARB_2(location, count, value[0]) else
        z_Uniform4ivARB_2(location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ivARB(location: Int32; count: Int32; var value: Vec4i) :=
    z_Uniform4ivARB_3(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ivARB(location: Int32; count: Int32; var value: Int32) :=
    z_Uniform4ivARB_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ivARB(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform4ivARB_1(location, count, value);
    
    private z_UniformMatrix2fvARB_adr := GetProcAddress('glUniformMatrix2fvARB');
    private z_UniformMatrix2fvARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_UniformMatrix2fvARB_adr);
    private z_UniformMatrix2fvARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; var value: single)>(z_UniformMatrix2fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2fvARB(location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_UniformMatrix2fvARB_2(location, count, transpose, value[0]) else
        z_UniformMatrix2fvARB_2(location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2fvARB(location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_UniformMatrix2fvARB_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2fvARB(location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_UniformMatrix2fvARB_1(location, count, transpose, value);
    
    private z_UniformMatrix3fvARB_adr := GetProcAddress('glUniformMatrix3fvARB');
    private z_UniformMatrix3fvARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_UniformMatrix3fvARB_adr);
    private z_UniformMatrix3fvARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; var value: single)>(z_UniformMatrix3fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3fvARB(location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_UniformMatrix3fvARB_2(location, count, transpose, value[0]) else
        z_UniformMatrix3fvARB_2(location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3fvARB(location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_UniformMatrix3fvARB_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3fvARB(location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_UniformMatrix3fvARB_1(location, count, transpose, value);
    
    private z_UniformMatrix4fvARB_adr := GetProcAddress('glUniformMatrix4fvARB');
    private z_UniformMatrix4fvARB_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_UniformMatrix4fvARB_adr);
    private z_UniformMatrix4fvARB_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; var value: single)>(z_UniformMatrix4fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4fvARB(location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_UniformMatrix4fvARB_2(location, count, transpose, value[0]) else
        z_UniformMatrix4fvARB_2(location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4fvARB(location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_UniformMatrix4fvARB_2(location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4fvARB(location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_UniformMatrix4fvARB_1(location, count, transpose, value);
    
    private z_GetObjectParameterfvARB_adr := GetProcAddress('glGetObjectParameterfvARB');
    private z_GetObjectParameterfvARB_1 := GetProcOrNil&<procedure(obj: gl_handle_ARB; pname: DummyEnum; &params: IntPtr)>(z_GetObjectParameterfvARB_adr);
    private z_GetObjectParameterfvARB_2 := GetProcOrNil&<procedure(obj: gl_handle_ARB; pname: DummyEnum; var &params: single)>(z_GetObjectParameterfvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectParameterfvARB(obj: gl_handle_ARB; pname: DummyEnum; var &params: single) :=
    z_GetObjectParameterfvARB_2(obj, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectParameterfvARB(obj: gl_handle_ARB; pname: DummyEnum; &params: IntPtr) :=
    z_GetObjectParameterfvARB_1(obj, pname, &params);
    
    private z_GetObjectParameterivARB_adr := GetProcAddress('glGetObjectParameterivARB');
    private z_GetObjectParameterivARB_1 := GetProcOrNil&<procedure(obj: gl_handle_ARB; pname: DummyEnum; &params: IntPtr)>(z_GetObjectParameterivARB_adr);
    private z_GetObjectParameterivARB_2 := GetProcOrNil&<procedure(obj: gl_handle_ARB; pname: DummyEnum; var &params: Int32)>(z_GetObjectParameterivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectParameterivARB(obj: gl_handle_ARB; pname: DummyEnum; var &params: Int32) :=
    z_GetObjectParameterivARB_2(obj, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectParameterivARB(obj: gl_handle_ARB; pname: DummyEnum; &params: IntPtr) :=
    z_GetObjectParameterivARB_1(obj, pname, &params);
    
    private z_GetInfoLogARB_adr := GetProcAddress('glGetInfoLogARB');
    private z_GetInfoLogARB_1 := GetProcOrNil&<procedure(obj: gl_handle_ARB; maxLength: Int32; length: IntPtr; infoLog: IntPtr)>(z_GetInfoLogARB_adr);
    private z_GetInfoLogARB_2 := GetProcOrNil&<procedure(obj: gl_handle_ARB; maxLength: Int32; var length: Int32; infoLog: IntPtr)>(z_GetInfoLogARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInfoLogARB(obj: gl_handle_ARB; maxLength: Int32; var length: Int32; infoLog: IntPtr) :=
    z_GetInfoLogARB_2(obj, maxLength, length, infoLog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInfoLogARB(obj: gl_handle_ARB; maxLength: Int32; length: IntPtr; infoLog: IntPtr) :=
    z_GetInfoLogARB_1(obj, maxLength, length, infoLog);
    
    private z_GetAttachedObjectsARB_adr := GetProcAddress('glGetAttachedObjectsARB');
    private z_GetAttachedObjectsARB_1 := GetProcOrNil&<procedure(containerObj: gl_handle_ARB; maxCount: Int32; count: IntPtr; obj: IntPtr)>(z_GetAttachedObjectsARB_adr);
    private z_GetAttachedObjectsARB_2 := GetProcOrNil&<procedure(containerObj: gl_handle_ARB; maxCount: Int32; count: IntPtr; var obj: gl_handle_ARB)>(z_GetAttachedObjectsARB_adr);
    private z_GetAttachedObjectsARB_3 := GetProcOrNil&<procedure(containerObj: gl_handle_ARB; maxCount: Int32; var count: Int32; obj: IntPtr)>(z_GetAttachedObjectsARB_adr);
    private z_GetAttachedObjectsARB_4 := GetProcOrNil&<procedure(containerObj: gl_handle_ARB; maxCount: Int32; var count: Int32; var obj: gl_handle_ARB)>(z_GetAttachedObjectsARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedObjectsARB(containerObj: gl_handle_ARB; maxCount: Int32; var count: Int32; var obj: gl_handle_ARB) :=
    z_GetAttachedObjectsARB_4(containerObj, maxCount, count, obj);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedObjectsARB(containerObj: gl_handle_ARB; maxCount: Int32; var count: Int32; obj: IntPtr) :=
    z_GetAttachedObjectsARB_3(containerObj, maxCount, count, obj);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedObjectsARB(containerObj: gl_handle_ARB; maxCount: Int32; count: IntPtr; var obj: gl_handle_ARB) :=
    z_GetAttachedObjectsARB_2(containerObj, maxCount, count, obj);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedObjectsARB(containerObj: gl_handle_ARB; maxCount: Int32; count: IntPtr; obj: IntPtr) :=
    z_GetAttachedObjectsARB_1(containerObj, maxCount, count, obj);
    
    private z_GetUniformLocationARB_adr := GetProcAddress('glGetUniformLocationARB');
    private z_GetUniformLocationARB_1 := GetProcOrNil&<function(programObj: gl_handle_ARB; name: IntPtr): Int32>(z_GetUniformLocationARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetUniformLocationARB(programObj: gl_handle_ARB; name: string): Int32;
    begin
      var name_str_ptr: IntPtr;
      try
        name_str_ptr := Marshal.StringToHGlobalAnsi(name);
        Result := z_GetUniformLocationARB_1(programObj, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetUniformLocationARB(programObj: gl_handle_ARB; name: IntPtr): Int32 :=
    z_GetUniformLocationARB_1(programObj, name);
    
    private z_GetActiveUniformARB_adr := GetProcAddress('glGetActiveUniformARB');
    private z_GetActiveUniformARB_1 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; length: IntPtr; size: IntPtr; &type: IntPtr; name: IntPtr)>(z_GetActiveUniformARB_adr);
    private z_GetActiveUniformARB_2 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; length: IntPtr; size: IntPtr; var &type: UniformType; name: IntPtr)>(z_GetActiveUniformARB_adr);
    private z_GetActiveUniformARB_3 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; length: IntPtr; var size: Int32; &type: IntPtr; name: IntPtr)>(z_GetActiveUniformARB_adr);
    private z_GetActiveUniformARB_4 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; length: IntPtr; var size: Int32; var &type: UniformType; name: IntPtr)>(z_GetActiveUniformARB_adr);
    private z_GetActiveUniformARB_5 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; var length: Int32; size: IntPtr; &type: IntPtr; name: IntPtr)>(z_GetActiveUniformARB_adr);
    private z_GetActiveUniformARB_6 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; var length: Int32; size: IntPtr; var &type: UniformType; name: IntPtr)>(z_GetActiveUniformARB_adr);
    private z_GetActiveUniformARB_7 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; var length: Int32; var size: Int32; &type: IntPtr; name: IntPtr)>(z_GetActiveUniformARB_adr);
    private z_GetActiveUniformARB_8 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; var length: Int32; var size: Int32; var &type: UniformType; name: IntPtr)>(z_GetActiveUniformARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; var length: Int32; var size: Int32; var &type: UniformType; name: IntPtr) :=
    z_GetActiveUniformARB_8(programObj, index, maxLength, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; var length: Int32; var size: Int32; &type: IntPtr; name: IntPtr) :=
    z_GetActiveUniformARB_7(programObj, index, maxLength, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; var length: Int32; size: IntPtr; var &type: UniformType; name: IntPtr) :=
    z_GetActiveUniformARB_6(programObj, index, maxLength, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; var length: Int32; size: IntPtr; &type: IntPtr; name: IntPtr) :=
    z_GetActiveUniformARB_5(programObj, index, maxLength, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; length: IntPtr; var size: Int32; var &type: UniformType; name: IntPtr) :=
    z_GetActiveUniformARB_4(programObj, index, maxLength, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; length: IntPtr; var size: Int32; &type: IntPtr; name: IntPtr) :=
    z_GetActiveUniformARB_3(programObj, index, maxLength, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; length: IntPtr; size: IntPtr; var &type: UniformType; name: IntPtr) :=
    z_GetActiveUniformARB_2(programObj, index, maxLength, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; length: IntPtr; size: IntPtr; &type: IntPtr; name: IntPtr) :=
    z_GetActiveUniformARB_1(programObj, index, maxLength, length, size, &type, name);
    
    private z_GetUniformfvARB_adr := GetProcAddress('glGetUniformfvARB');
    private z_GetUniformfvARB_1 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; location: Int32; &params: IntPtr)>(z_GetUniformfvARB_adr);
    private z_GetUniformfvARB_2 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; location: Int32; var &params: single)>(z_GetUniformfvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformfvARB(programObj: gl_handle_ARB; location: Int32; var &params: single) :=
    z_GetUniformfvARB_2(programObj, location, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformfvARB(programObj: gl_handle_ARB; location: Int32; &params: IntPtr) :=
    z_GetUniformfvARB_1(programObj, location, &params);
    
    private z_GetUniformivARB_adr := GetProcAddress('glGetUniformivARB');
    private z_GetUniformivARB_1 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; location: Int32; &params: IntPtr)>(z_GetUniformivARB_adr);
    private z_GetUniformivARB_2 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; location: Int32; var &params: Int32)>(z_GetUniformivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformivARB(programObj: gl_handle_ARB; location: Int32; var &params: Int32) :=
    z_GetUniformivARB_2(programObj, location, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformivARB(programObj: gl_handle_ARB; location: Int32; &params: IntPtr) :=
    z_GetUniformivARB_1(programObj, location, &params);
    
    private z_GetShaderSourceARB_adr := GetProcAddress('glGetShaderSourceARB');
    private z_GetShaderSourceARB_1 := GetProcOrNil&<procedure(obj: gl_handle_ARB; maxLength: Int32; length: IntPtr; source: IntPtr)>(z_GetShaderSourceARB_adr);
    private z_GetShaderSourceARB_2 := GetProcOrNil&<procedure(obj: gl_handle_ARB; maxLength: Int32; var length: Int32; source: IntPtr)>(z_GetShaderSourceARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderSourceARB(obj: gl_handle_ARB; maxLength: Int32; var length: Int32; source: IntPtr) :=
    z_GetShaderSourceARB_2(obj, maxLength, length, source);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderSourceARB(obj: gl_handle_ARB; maxLength: Int32; length: IntPtr; source: IntPtr) :=
    z_GetShaderSourceARB_1(obj, maxLength, length, source);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glShaderStorageBufferObjectARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_shader_storage_buffer_object';
    
    private z_ShaderStorageBlockBinding_adr := GetProcAddress('glShaderStorageBlockBinding');
    private z_ShaderStorageBlockBinding_1 := GetProcOrNil&<procedure(&program: gl_program; storageBlockIndex: UInt32; storageBlockBinding: UInt32)>(z_ShaderStorageBlockBinding_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderStorageBlockBinding(&program: gl_program; storageBlockIndex: UInt32; storageBlockBinding: UInt32) :=
    z_ShaderStorageBlockBinding_1(&program, storageBlockIndex, storageBlockBinding);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glShaderSubroutineARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_shader_subroutine';
    
    private z_GetSubroutineUniformLocation_adr := GetProcAddress('glGetSubroutineUniformLocation');
    private z_GetSubroutineUniformLocation_1 := GetProcOrNil&<function(&program: gl_program; _shadertype: ShaderType; name: IntPtr): Int32>(z_GetSubroutineUniformLocation_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSubroutineUniformLocation(&program: gl_program; _shadertype: ShaderType; name: string): Int32;
    begin
      var name_str_ptr: IntPtr;
      try
        name_str_ptr := Marshal.StringToHGlobalAnsi(name);
        Result := z_GetSubroutineUniformLocation_1(&program, _shadertype, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSubroutineUniformLocation(&program: gl_program; _shadertype: ShaderType; name: IntPtr): Int32 :=
    z_GetSubroutineUniformLocation_1(&program, _shadertype, name);
    
    private z_GetSubroutineIndex_adr := GetProcAddress('glGetSubroutineIndex');
    private z_GetSubroutineIndex_1 := GetProcOrNil&<function(&program: gl_program; _shadertype: ShaderType; name: IntPtr): UInt32>(z_GetSubroutineIndex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSubroutineIndex(&program: gl_program; _shadertype: ShaderType; name: string): UInt32;
    begin
      var name_str_ptr: IntPtr;
      try
        name_str_ptr := Marshal.StringToHGlobalAnsi(name);
        Result := z_GetSubroutineIndex_1(&program, _shadertype, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSubroutineIndex(&program: gl_program; _shadertype: ShaderType; name: IntPtr): UInt32 :=
    z_GetSubroutineIndex_1(&program, _shadertype, name);
    
    private z_GetActiveSubroutineUniformiv_adr := GetProcAddress('glGetActiveSubroutineUniformiv');
    private z_GetActiveSubroutineUniformiv_1 := GetProcOrNil&<procedure(&program: gl_program; _shadertype: ShaderType; index: UInt32; pname: SubroutineParameterName; values: IntPtr)>(z_GetActiveSubroutineUniformiv_adr);
    private z_GetActiveSubroutineUniformiv_2 := GetProcOrNil&<procedure(&program: gl_program; _shadertype: ShaderType; index: UInt32; pname: SubroutineParameterName; var values: Int32)>(z_GetActiveSubroutineUniformiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveSubroutineUniformiv(&program: gl_program; _shadertype: ShaderType; index: UInt32; pname: SubroutineParameterName; var values: Int32) :=
    z_GetActiveSubroutineUniformiv_2(&program, _shadertype, index, pname, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveSubroutineUniformiv(&program: gl_program; _shadertype: ShaderType; index: UInt32; pname: SubroutineParameterName; values: IntPtr) :=
    z_GetActiveSubroutineUniformiv_1(&program, _shadertype, index, pname, values);
    
    private z_GetActiveSubroutineUniformName_adr := GetProcAddress('glGetActiveSubroutineUniformName');
    private z_GetActiveSubroutineUniformName_1 := GetProcOrNil&<procedure(&program: gl_program; _shadertype: ShaderType; index: UInt32; bufSize: Int32; length: IntPtr; name: IntPtr)>(z_GetActiveSubroutineUniformName_adr);
    private z_GetActiveSubroutineUniformName_2 := GetProcOrNil&<procedure(&program: gl_program; _shadertype: ShaderType; index: UInt32; bufSize: Int32; var length: Int32; name: IntPtr)>(z_GetActiveSubroutineUniformName_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveSubroutineUniformName(&program: gl_program; _shadertype: ShaderType; index: UInt32; bufSize: Int32; var length: Int32; name: IntPtr) :=
    z_GetActiveSubroutineUniformName_2(&program, _shadertype, index, bufSize, length, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveSubroutineUniformName(&program: gl_program; _shadertype: ShaderType; index: UInt32; bufSize: Int32; length: IntPtr; name: IntPtr) :=
    z_GetActiveSubroutineUniformName_1(&program, _shadertype, index, bufSize, length, name);
    
    private z_GetActiveSubroutineName_adr := GetProcAddress('glGetActiveSubroutineName');
    private z_GetActiveSubroutineName_1 := GetProcOrNil&<procedure(&program: gl_program; _shadertype: ShaderType; index: UInt32; bufSize: Int32; length: IntPtr; name: IntPtr)>(z_GetActiveSubroutineName_adr);
    private z_GetActiveSubroutineName_2 := GetProcOrNil&<procedure(&program: gl_program; _shadertype: ShaderType; index: UInt32; bufSize: Int32; var length: Int32; name: IntPtr)>(z_GetActiveSubroutineName_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveSubroutineName(&program: gl_program; _shadertype: ShaderType; index: UInt32; bufSize: Int32; var length: Int32; name: IntPtr) :=
    z_GetActiveSubroutineName_2(&program, _shadertype, index, bufSize, length, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveSubroutineName(&program: gl_program; _shadertype: ShaderType; index: UInt32; bufSize: Int32; length: IntPtr; name: IntPtr) :=
    z_GetActiveSubroutineName_1(&program, _shadertype, index, bufSize, length, name);
    
    private z_UniformSubroutinesuiv_adr := GetProcAddress('glUniformSubroutinesuiv');
    private z_UniformSubroutinesuiv_1 := GetProcOrNil&<procedure(_shadertype: ShaderType; count: Int32; indices: IntPtr)>(z_UniformSubroutinesuiv_adr);
    private z_UniformSubroutinesuiv_2 := GetProcOrNil&<procedure(_shadertype: ShaderType; count: Int32; var indices: UInt32)>(z_UniformSubroutinesuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformSubroutinesuiv(_shadertype: ShaderType; count: Int32; indices: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (indices<>nil) and (indices.Length<>0) then
        z_UniformSubroutinesuiv_2(_shadertype, count, indices[0]) else
        z_UniformSubroutinesuiv_2(_shadertype, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformSubroutinesuiv(_shadertype: ShaderType; count: Int32; var indices: UInt32) :=
    z_UniformSubroutinesuiv_2(_shadertype, count, indices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformSubroutinesuiv(_shadertype: ShaderType; count: Int32; indices: IntPtr) :=
    z_UniformSubroutinesuiv_1(_shadertype, count, indices);
    
    private z_GetUniformSubroutineuiv_adr := GetProcAddress('glGetUniformSubroutineuiv');
    private z_GetUniformSubroutineuiv_1 := GetProcOrNil&<procedure(_shadertype: ShaderType; location: Int32; &params: IntPtr)>(z_GetUniformSubroutineuiv_adr);
    private z_GetUniformSubroutineuiv_2 := GetProcOrNil&<procedure(_shadertype: ShaderType; location: Int32; var &params: UInt32)>(z_GetUniformSubroutineuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformSubroutineuiv(_shadertype: ShaderType; location: Int32; var &params: UInt32) :=
    z_GetUniformSubroutineuiv_2(_shadertype, location, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformSubroutineuiv(_shadertype: ShaderType; location: Int32; &params: IntPtr) :=
    z_GetUniformSubroutineuiv_1(_shadertype, location, &params);
    
    private z_GetProgramStageiv_adr := GetProcAddress('glGetProgramStageiv');
    private z_GetProgramStageiv_1 := GetProcOrNil&<procedure(&program: gl_program; _shadertype: ShaderType; pname: ProgramStagePName; values: IntPtr)>(z_GetProgramStageiv_adr);
    private z_GetProgramStageiv_2 := GetProcOrNil&<procedure(&program: gl_program; _shadertype: ShaderType; pname: ProgramStagePName; var values: Int32)>(z_GetProgramStageiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramStageiv(&program: gl_program; _shadertype: ShaderType; pname: ProgramStagePName; var values: Int32) :=
    z_GetProgramStageiv_2(&program, _shadertype, pname, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramStageiv(&program: gl_program; _shadertype: ShaderType; pname: ProgramStagePName; values: IntPtr) :=
    z_GetProgramStageiv_1(&program, _shadertype, pname, values);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glShadingLanguageIncludeARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_shading_language_include';
    
    private z_NamedStringARB_adr := GetProcAddress('glNamedStringARB');
    private z_NamedStringARB_1 := GetProcOrNil&<procedure(&type: DummyEnum; namelen: Int32; name: IntPtr; stringlen: Int32; _string: IntPtr)>(z_NamedStringARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedStringARB(&type: DummyEnum; namelen: Int32; name: string; stringlen: Int32; _string: string);
    begin
      var name_str_ptr, _string_str_ptr: IntPtr;
      try
        name_str_ptr := Marshal.StringToHGlobalAnsi(name);
        _string_str_ptr := Marshal.StringToHGlobalAnsi(_string);
        z_NamedStringARB_1(&type, namelen, name_str_ptr, stringlen, _string_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
        Marshal.FreeHGlobal(_string_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedStringARB(&type: DummyEnum; namelen: Int32; name: string; stringlen: Int32; _string: IntPtr);
    begin
      var name_str_ptr: IntPtr;
      try
        name_str_ptr := Marshal.StringToHGlobalAnsi(name);
        z_NamedStringARB_1(&type, namelen, name_str_ptr, stringlen, _string);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedStringARB(&type: DummyEnum; namelen: Int32; name: IntPtr; stringlen: Int32; _string: string);
    begin
      var _string_str_ptr: IntPtr;
      try
        _string_str_ptr := Marshal.StringToHGlobalAnsi(_string);
        z_NamedStringARB_1(&type, namelen, name, stringlen, _string_str_ptr);
      finally
        Marshal.FreeHGlobal(_string_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedStringARB(&type: DummyEnum; namelen: Int32; name: IntPtr; stringlen: Int32; _string: IntPtr) :=
    z_NamedStringARB_1(&type, namelen, name, stringlen, _string);
    
    private z_DeleteNamedStringARB_adr := GetProcAddress('glDeleteNamedStringARB');
    private z_DeleteNamedStringARB_1 := GetProcOrNil&<procedure(namelen: Int32; name: IntPtr)>(z_DeleteNamedStringARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteNamedStringARB(namelen: Int32; name: string);
    begin
      var name_str_ptr: IntPtr;
      try
        name_str_ptr := Marshal.StringToHGlobalAnsi(name);
        z_DeleteNamedStringARB_1(namelen, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteNamedStringARB(namelen: Int32; name: IntPtr) :=
    z_DeleteNamedStringARB_1(namelen, name);
    
    private z_CompileShaderIncludeARB_adr := GetProcAddress('glCompileShaderIncludeARB');
    private z_CompileShaderIncludeARB_1 := GetProcOrNil&<procedure(shader: gl_shader; count: Int32; path: pointer; length: IntPtr)>(z_CompileShaderIncludeARB_adr);
    private z_CompileShaderIncludeARB_2 := GetProcOrNil&<procedure(shader: gl_shader; count: Int32; path: pointer; var length: Int32)>(z_CompileShaderIncludeARB_adr);
    private z_CompileShaderIncludeARB_3 := GetProcOrNil&<procedure(shader: gl_shader; count: Int32; var path: IntPtr; length: IntPtr)>(z_CompileShaderIncludeARB_adr);
    private z_CompileShaderIncludeARB_4 := GetProcOrNil&<procedure(shader: gl_shader; count: Int32; var path: IntPtr; var length: Int32)>(z_CompileShaderIncludeARB_adr);
    private [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure temp_CompileShaderIncludeARB_1(shader: gl_shader; count: Int32; path: array of IntPtr; length: array of Int32);
    type PIntPtr=^IntPtr;
    type PInt32=^Int32;
    begin
      if (length<>nil) and (length.Length<>0) then
        if (path<>nil) and (path.Length<>0) then
          z_CompileShaderIncludeARB_4(shader, count, path[0], length[0]) else
          z_CompileShaderIncludeARB_4(shader, count, PIntPtr(nil)^, length[0]) else
        if (path<>nil) and (path.Length<>0) then
          z_CompileShaderIncludeARB_4(shader, count, path[0], PInt32(nil)^) else
          z_CompileShaderIncludeARB_4(shader, count, PIntPtr(nil)^, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileShaderIncludeARB(shader: gl_shader; count: Int32; path: array of string; length: array of Int32);
    begin
      var path_str_ptrs: array of IntPtr;
      try
        path_str_ptrs := path?.ConvertAll(arr_el1->
          Marshal.StringToHGlobalAnsi(arr_el1)
        );
        temp_CompileShaderIncludeARB_1(shader, count, path_str_ptrs, length);
      finally
        if path_str_ptrs<>nil then foreach var arr_el1 in path_str_ptrs do
          Marshal.FreeHGlobal(arr_el1);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileShaderIncludeARB(shader: gl_shader; count: Int32; var path: IntPtr; var length: Int32) :=
    z_CompileShaderIncludeARB_4(shader, count, path, length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileShaderIncludeARB(shader: gl_shader; count: Int32; var path: IntPtr; length: IntPtr) :=
    z_CompileShaderIncludeARB_3(shader, count, path, length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileShaderIncludeARB(shader: gl_shader; count: Int32; path: pointer; var length: Int32) :=
    z_CompileShaderIncludeARB_2(shader, count, path, length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileShaderIncludeARB(shader: gl_shader; count: Int32; path: pointer; length: IntPtr) :=
    z_CompileShaderIncludeARB_1(shader, count, path, length);
    
    private z_IsNamedStringARB_adr := GetProcAddress('glIsNamedStringARB');
    private z_IsNamedStringARB_1 := GetProcOrNil&<function(namelen: Int32; name: IntPtr): boolean>(z_IsNamedStringARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsNamedStringARB(namelen: Int32; name: string): boolean;
    begin
      var name_str_ptr: IntPtr;
      try
        name_str_ptr := Marshal.StringToHGlobalAnsi(name);
        Result := z_IsNamedStringARB_1(namelen, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsNamedStringARB(namelen: Int32; name: IntPtr): boolean :=
    z_IsNamedStringARB_1(namelen, name);
    
    private z_GetNamedStringARB_adr := GetProcAddress('glGetNamedStringARB');
    private z_GetNamedStringARB_1 := GetProcOrNil&<procedure(namelen: Int32; name: IntPtr; bufSize: Int32; stringlen: IntPtr; _string: IntPtr)>(z_GetNamedStringARB_adr);
    private z_GetNamedStringARB_2 := GetProcOrNil&<procedure(namelen: Int32; name: IntPtr; bufSize: Int32; var stringlen: Int32; _string: IntPtr)>(z_GetNamedStringARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringARB(namelen: Int32; name: string; bufSize: Int32; var stringlen: Int32; _string: IntPtr);
    begin
      var name_str_ptr: IntPtr;
      try
        name_str_ptr := Marshal.StringToHGlobalAnsi(name);
        z_GetNamedStringARB_2(namelen, name_str_ptr, bufSize, stringlen, _string);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringARB(namelen: Int32; name: string; bufSize: Int32; stringlen: IntPtr; _string: IntPtr);
    begin
      var name_str_ptr: IntPtr;
      try
        name_str_ptr := Marshal.StringToHGlobalAnsi(name);
        z_GetNamedStringARB_1(namelen, name_str_ptr, bufSize, stringlen, _string);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringARB(namelen: Int32; name: IntPtr; bufSize: Int32; var stringlen: Int32; _string: IntPtr) :=
    z_GetNamedStringARB_2(namelen, name, bufSize, stringlen, _string);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringARB(namelen: Int32; name: IntPtr; bufSize: Int32; stringlen: IntPtr; _string: IntPtr) :=
    z_GetNamedStringARB_1(namelen, name, bufSize, stringlen, _string);
    
    private z_GetNamedStringivARB_adr := GetProcAddress('glGetNamedStringivARB');
    private z_GetNamedStringivARB_1 := GetProcOrNil&<procedure(namelen: Int32; name: IntPtr; pname: DummyEnum; &params: IntPtr)>(z_GetNamedStringivARB_adr);
    private z_GetNamedStringivARB_2 := GetProcOrNil&<procedure(namelen: Int32; name: IntPtr; pname: DummyEnum; var &params: Int32)>(z_GetNamedStringivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringivARB(namelen: Int32; name: string; pname: DummyEnum; var &params: Int32);
    begin
      var name_str_ptr: IntPtr;
      try
        name_str_ptr := Marshal.StringToHGlobalAnsi(name);
        z_GetNamedStringivARB_2(namelen, name_str_ptr, pname, &params);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringivARB(namelen: Int32; name: string; pname: DummyEnum; &params: IntPtr);
    begin
      var name_str_ptr: IntPtr;
      try
        name_str_ptr := Marshal.StringToHGlobalAnsi(name);
        z_GetNamedStringivARB_1(namelen, name_str_ptr, pname, &params);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringivARB(namelen: Int32; name: IntPtr; pname: DummyEnum; var &params: Int32) :=
    z_GetNamedStringivARB_2(namelen, name, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringivARB(namelen: Int32; name: IntPtr; pname: DummyEnum; &params: IntPtr) :=
    z_GetNamedStringivARB_1(namelen, name, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glSparseBufferARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_sparse_buffer';
    
    private z_BufferPageCommitmentARB_adr := GetProcAddress('glBufferPageCommitmentARB');
    private z_BufferPageCommitmentARB_1 := GetProcOrNil&<procedure(target: DummyEnum; offset: IntPtr; size: UIntPtr; commit: boolean)>(z_BufferPageCommitmentARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferPageCommitmentARB(target: DummyEnum; offset: IntPtr; size: UIntPtr; commit: boolean) :=
    z_BufferPageCommitmentARB_1(target, offset, size, commit);
    
    private z_NamedBufferPageCommitmentEXT_adr := GetProcAddress('glNamedBufferPageCommitmentEXT');
    private z_NamedBufferPageCommitmentEXT_1 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; commit: boolean)>(z_NamedBufferPageCommitmentEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferPageCommitmentEXT(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; commit: boolean) :=
    z_NamedBufferPageCommitmentEXT_1(buffer, offset, size, commit);
    
    private z_NamedBufferPageCommitmentARB_adr := GetProcAddress('glNamedBufferPageCommitmentARB');
    private z_NamedBufferPageCommitmentARB_1 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; commit: boolean)>(z_NamedBufferPageCommitmentARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferPageCommitmentARB(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; commit: boolean) :=
    z_NamedBufferPageCommitmentARB_1(buffer, offset, size, commit);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glSparseTextureARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_sparse_texture';
    
    private z_TexPageCommitmentARB_adr := GetProcAddress('glTexPageCommitmentARB');
    private z_TexPageCommitmentARB_1 := GetProcOrNil&<procedure(target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; commit: boolean)>(z_TexPageCommitmentARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexPageCommitmentARB(target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; commit: boolean) :=
    z_TexPageCommitmentARB_1(target, level, xoffset, yoffset, zoffset, width, height, depth, commit);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glSyncARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_sync';
    
    private z_FenceSync_adr := GetProcAddress('glFenceSync');
    private z_FenceSync_1 := GetProcOrNil&<function(condition: SyncCondition; flags: DummyFlags): gl_sync>(z_FenceSync_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function FenceSync(condition: SyncCondition; flags: DummyFlags): gl_sync :=
    z_FenceSync_1(condition, flags);
    
    private z_IsSync_adr := GetProcAddress('glIsSync');
    private z_IsSync_1 := GetProcOrNil&<function(sync: gl_sync): boolean>(z_IsSync_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsSync(sync: gl_sync): boolean :=
    z_IsSync_1(sync);
    
    private z_DeleteSync_adr := GetProcAddress('glDeleteSync');
    private z_DeleteSync_1 := GetProcOrNil&<procedure(sync: gl_sync)>(z_DeleteSync_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteSync(sync: gl_sync) :=
    z_DeleteSync_1(sync);
    
    private z_ClientWaitSync_adr := GetProcAddress('glClientWaitSync');
    private z_ClientWaitSync_1 := GetProcOrNil&<function(sync: gl_sync; flags: SyncObjectMask; timeout: UInt64): SyncStatus>(z_ClientWaitSync_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ClientWaitSync(sync: gl_sync; flags: SyncObjectMask; timeout: UInt64): SyncStatus :=
    z_ClientWaitSync_1(sync, flags, timeout);
    
    private z_WaitSync_adr := GetProcAddress('glWaitSync');
    private z_WaitSync_1 := GetProcOrNil&<procedure(sync: gl_sync; flags: DummyFlags; timeout: UInt64)>(z_WaitSync_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSync(sync: gl_sync; flags: DummyFlags; timeout: UInt64) :=
    z_WaitSync_1(sync, flags, timeout);
    
    private z_GetInteger64v_adr := GetProcAddress('glGetInteger64v');
    private z_GetInteger64v_1 := GetProcOrNil&<procedure(pname: GetPName; data: IntPtr)>(z_GetInteger64v_adr);
    private z_GetInteger64v_2 := GetProcOrNil&<procedure(pname: GetPName; var data: Int64)>(z_GetInteger64v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInteger64v(pname: GetPName; var data: Int64) :=
    z_GetInteger64v_2(pname, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInteger64v(pname: GetPName; data: IntPtr) :=
    z_GetInteger64v_1(pname, data);
    
    private z_GetSynciv_adr := GetProcAddress('glGetSynciv');
    private z_GetSynciv_1 := GetProcOrNil&<procedure(sync: gl_sync; pname: SyncParameterName; count: Int32; length: IntPtr; values: IntPtr)>(z_GetSynciv_adr);
    private z_GetSynciv_2 := GetProcOrNil&<procedure(sync: gl_sync; pname: SyncParameterName; count: Int32; length: IntPtr; var values: Int32)>(z_GetSynciv_adr);
    private z_GetSynciv_3 := GetProcOrNil&<procedure(sync: gl_sync; pname: SyncParameterName; count: Int32; var length: Int32; values: IntPtr)>(z_GetSynciv_adr);
    private z_GetSynciv_4 := GetProcOrNil&<procedure(sync: gl_sync; pname: SyncParameterName; count: Int32; var length: Int32; var values: Int32)>(z_GetSynciv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSynciv(sync: gl_sync; pname: SyncParameterName; count: Int32; var length: Int32; var values: Int32) :=
    z_GetSynciv_4(sync, pname, count, length, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSynciv(sync: gl_sync; pname: SyncParameterName; count: Int32; var length: Int32; values: IntPtr) :=
    z_GetSynciv_3(sync, pname, count, length, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSynciv(sync: gl_sync; pname: SyncParameterName; count: Int32; length: IntPtr; var values: Int32) :=
    z_GetSynciv_2(sync, pname, count, length, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSynciv(sync: gl_sync; pname: SyncParameterName; count: Int32; length: IntPtr; values: IntPtr) :=
    z_GetSynciv_1(sync, pname, count, length, values);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glTessellationShaderARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_tessellation_shader';
    
    private z_PatchParameteri_adr := GetProcAddress('glPatchParameteri');
    private z_PatchParameteri_1 := GetProcOrNil&<procedure(pname: PatchParameterName; value: Int32)>(z_PatchParameteri_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PatchParameteri(pname: PatchParameterName; value: Int32) :=
    z_PatchParameteri_1(pname, value);
    
    private z_PatchParameterfv_adr := GetProcAddress('glPatchParameterfv');
    private z_PatchParameterfv_1 := GetProcOrNil&<procedure(pname: PatchParameterName; values: IntPtr)>(z_PatchParameterfv_adr);
    private z_PatchParameterfv_2 := GetProcOrNil&<procedure(pname: PatchParameterName; var values: single)>(z_PatchParameterfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PatchParameterfv(pname: PatchParameterName; values: array of single);
    type Psingle=^single;
    begin
      if (values<>nil) and (values.Length<>0) then
        z_PatchParameterfv_2(pname, values[0]) else
        z_PatchParameterfv_2(pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PatchParameterfv(pname: PatchParameterName; var values: single) :=
    z_PatchParameterfv_2(pname, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PatchParameterfv(pname: PatchParameterName; values: IntPtr) :=
    z_PatchParameterfv_1(pname, values);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glTextureBarrierARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_texture_barrier';
    
    private z_TextureBarrier_adr := GetProcAddress('glTextureBarrier');
    private z_TextureBarrier_1 := GetProcOrNil&<procedure>(z_TextureBarrier_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureBarrier :=
    z_TextureBarrier_1();
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glTextureBufferObjectARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_texture_buffer_object';
    
    private z_TexBufferARB_adr := GetProcAddress('glTexBufferARB');
    private z_TexBufferARB_1 := GetProcOrNil&<procedure(target: TextureTarget; internalformat: SizedInternalFormat; buffer: gl_buffer)>(z_TexBufferARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBufferARB(target: TextureTarget; internalformat: SizedInternalFormat; buffer: gl_buffer) :=
    z_TexBufferARB_1(target, internalformat, buffer);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glTextureBufferRangeARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_texture_buffer_range';
    
    private z_TexBufferRange_adr := GetProcAddress('glTexBufferRange');
    private z_TexBufferRange_1 := GetProcOrNil&<procedure(target: TextureTarget; internalformat: SizedInternalFormat; buffer: gl_buffer; offset: IntPtr; size: UIntPtr)>(z_TexBufferRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBufferRange(target: TextureTarget; internalformat: SizedInternalFormat; buffer: gl_buffer; offset: IntPtr; size: UIntPtr) :=
    z_TexBufferRange_1(target, internalformat, buffer, offset, size);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glTextureCompressionARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_texture_compression';
    
    private z_CompressedTexImage3DARB_adr := GetProcAddress('glCompressedTexImage3DARB');
    private z_CompressedTexImage3DARB_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; data: IntPtr)>(z_CompressedTexImage3DARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexImage3DARB(target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; data: IntPtr) :=
    z_CompressedTexImage3DARB_1(target, level, _internalformat, width, height, depth, border, imageSize, data);
    
    private z_CompressedTexImage2DARB_adr := GetProcAddress('glCompressedTexImage2DARB');
    private z_CompressedTexImage2DARB_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; border: Int32; imageSize: Int32; data: IntPtr)>(z_CompressedTexImage2DARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexImage2DARB(target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; border: Int32; imageSize: Int32; data: IntPtr) :=
    z_CompressedTexImage2DARB_1(target, level, _internalformat, width, height, border, imageSize, data);
    
    private z_CompressedTexImage1DARB_adr := GetProcAddress('glCompressedTexImage1DARB');
    private z_CompressedTexImage1DARB_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; border: Int32; imageSize: Int32; data: IntPtr)>(z_CompressedTexImage1DARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexImage1DARB(target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; border: Int32; imageSize: Int32; data: IntPtr) :=
    z_CompressedTexImage1DARB_1(target, level, _internalformat, width, border, imageSize, data);
    
    private z_CompressedTexSubImage3DARB_adr := GetProcAddress('glCompressedTexSubImage3DARB');
    private z_CompressedTexSubImage3DARB_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: InternalFormat; imageSize: Int32; data: IntPtr)>(z_CompressedTexSubImage3DARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexSubImage3DARB(target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: InternalFormat; imageSize: Int32; data: IntPtr) :=
    z_CompressedTexSubImage3DARB_1(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
    
    private z_CompressedTexSubImage2DARB_adr := GetProcAddress('glCompressedTexSubImage2DARB');
    private z_CompressedTexSubImage2DARB_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: InternalFormat; imageSize: Int32; data: IntPtr)>(z_CompressedTexSubImage2DARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexSubImage2DARB(target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: InternalFormat; imageSize: Int32; data: IntPtr) :=
    z_CompressedTexSubImage2DARB_1(target, level, xoffset, yoffset, width, height, format, imageSize, data);
    
    private z_CompressedTexSubImage1DARB_adr := GetProcAddress('glCompressedTexSubImage1DARB');
    private z_CompressedTexSubImage1DARB_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; xoffset: Int32; width: Int32; format: InternalFormat; imageSize: Int32; data: IntPtr)>(z_CompressedTexSubImage1DARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexSubImage1DARB(target: TextureTarget; level: Int32; xoffset: Int32; width: Int32; format: InternalFormat; imageSize: Int32; data: IntPtr) :=
    z_CompressedTexSubImage1DARB_1(target, level, xoffset, width, format, imageSize, data);
    
    private z_GetCompressedTexImageARB_adr := GetProcAddress('glGetCompressedTexImageARB');
    private z_GetCompressedTexImageARB_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; img: IntPtr)>(z_GetCompressedTexImageARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCompressedTexImageARB(target: TextureTarget; level: Int32; img: IntPtr) :=
    z_GetCompressedTexImageARB_1(target, level, img);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glTextureMultisampleARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_texture_multisample';
    
    private z_TexImage2DMultisample_adr := GetProcAddress('glTexImage2DMultisample');
    private z_TexImage2DMultisample_1 := GetProcOrNil&<procedure(target: TextureTarget; samples: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; fixedsamplelocations: boolean)>(z_TexImage2DMultisample_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage2DMultisample(target: TextureTarget; samples: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; fixedsamplelocations: boolean) :=
    z_TexImage2DMultisample_1(target, samples, _internalformat, width, height, fixedsamplelocations);
    
    private z_TexImage3DMultisample_adr := GetProcAddress('glTexImage3DMultisample');
    private z_TexImage3DMultisample_1 := GetProcOrNil&<procedure(target: TextureTarget; samples: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: boolean)>(z_TexImage3DMultisample_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage3DMultisample(target: TextureTarget; samples: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: boolean) :=
    z_TexImage3DMultisample_1(target, samples, _internalformat, width, height, depth, fixedsamplelocations);
    
    private z_GetMultisamplefv_adr := GetProcAddress('glGetMultisamplefv');
    private z_GetMultisamplefv_1 := GetProcOrNil&<procedure(pname: GetMultisamplePName; index: UInt32; val: IntPtr)>(z_GetMultisamplefv_adr);
    private z_GetMultisamplefv_2 := GetProcOrNil&<procedure(pname: GetMultisamplePName; index: UInt32; var val: single)>(z_GetMultisamplefv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultisamplefv(pname: GetMultisamplePName; index: UInt32; var val: single) :=
    z_GetMultisamplefv_2(pname, index, val);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultisamplefv(pname: GetMultisamplePName; index: UInt32; val: IntPtr) :=
    z_GetMultisamplefv_1(pname, index, val);
    
    private z_SampleMaski_adr := GetProcAddress('glSampleMaski');
    private z_SampleMaski_1 := GetProcOrNil&<procedure(maskNumber: UInt32; mask: DummyFlags)>(z_SampleMaski_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SampleMaski(maskNumber: UInt32; mask: DummyFlags) :=
    z_SampleMaski_1(maskNumber, mask);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glTextureStorageARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_texture_storage';
    
    private z_TexStorage1D_adr := GetProcAddress('glTexStorage1D');
    private z_TexStorage1D_1 := GetProcOrNil&<procedure(target: TextureTarget; levels: Int32; internalformat: SizedInternalFormat; width: Int32)>(z_TexStorage1D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorage1D(target: TextureTarget; levels: Int32; internalformat: SizedInternalFormat; width: Int32) :=
    z_TexStorage1D_1(target, levels, internalformat, width);
    
    private z_TexStorage2D_adr := GetProcAddress('glTexStorage2D');
    private z_TexStorage2D_1 := GetProcOrNil&<procedure(target: TextureTarget; levels: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32)>(z_TexStorage2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorage2D(target: TextureTarget; levels: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32) :=
    z_TexStorage2D_1(target, levels, internalformat, width, height);
    
    private z_TexStorage3D_adr := GetProcAddress('glTexStorage3D');
    private z_TexStorage3D_1 := GetProcOrNil&<procedure(target: TextureTarget; levels: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32; depth: Int32)>(z_TexStorage3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorage3D(target: TextureTarget; levels: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32; depth: Int32) :=
    z_TexStorage3D_1(target, levels, internalformat, width, height, depth);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glTextureStorageMultisampleARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_texture_storage_multisample';
    
    private z_TexStorage2DMultisample_adr := GetProcAddress('glTexStorage2DMultisample');
    private z_TexStorage2DMultisample_1 := GetProcOrNil&<procedure(target: TextureTarget; samples: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32; fixedsamplelocations: boolean)>(z_TexStorage2DMultisample_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorage2DMultisample(target: TextureTarget; samples: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32; fixedsamplelocations: boolean) :=
    z_TexStorage2DMultisample_1(target, samples, internalformat, width, height, fixedsamplelocations);
    
    private z_TexStorage3DMultisample_adr := GetProcAddress('glTexStorage3DMultisample');
    private z_TexStorage3DMultisample_1 := GetProcOrNil&<procedure(target: TextureTarget; samples: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: boolean)>(z_TexStorage3DMultisample_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorage3DMultisample(target: TextureTarget; samples: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: boolean) :=
    z_TexStorage3DMultisample_1(target, samples, internalformat, width, height, depth, fixedsamplelocations);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glTextureViewARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_texture_view';
    
    private z_TextureView_adr := GetProcAddress('glTextureView');
    private z_TextureView_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; origtexture: gl_texture; internalformat: SizedInternalFormat; minlevel: UInt32; numlevels: UInt32; minlayer: UInt32; numlayers: UInt32)>(z_TextureView_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureView(texture: gl_texture; target: TextureTarget; origtexture: gl_texture; internalformat: SizedInternalFormat; minlevel: UInt32; numlevels: UInt32; minlayer: UInt32; numlayers: UInt32) :=
    z_TextureView_1(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glTimerQueryARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_timer_query';
    
    private z_QueryCounter_adr := GetProcAddress('glQueryCounter');
    private z_QueryCounter_1 := GetProcOrNil&<procedure(id: gl_query; target: QueryCounterTarget)>(z_QueryCounter_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure QueryCounter(id: gl_query; target: QueryCounterTarget) :=
    z_QueryCounter_1(id, target);
    
    private z_GetQueryObjecti64v_adr := GetProcAddress('glGetQueryObjecti64v');
    private z_GetQueryObjecti64v_1 := GetProcOrNil&<procedure(id: gl_query; pname: QueryObjectParameterName; &params: IntPtr)>(z_GetQueryObjecti64v_adr);
    private z_GetQueryObjecti64v_2 := GetProcOrNil&<procedure(id: gl_query; pname: QueryObjectParameterName; var &params: Int64)>(z_GetQueryObjecti64v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjecti64v(id: gl_query; pname: QueryObjectParameterName; var &params: Int64) :=
    z_GetQueryObjecti64v_2(id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjecti64v(id: gl_query; pname: QueryObjectParameterName; &params: IntPtr) :=
    z_GetQueryObjecti64v_1(id, pname, &params);
    
    private z_GetQueryObjectui64v_adr := GetProcAddress('glGetQueryObjectui64v');
    private z_GetQueryObjectui64v_1 := GetProcOrNil&<procedure(id: gl_query; pname: QueryObjectParameterName; &params: IntPtr)>(z_GetQueryObjectui64v_adr);
    private z_GetQueryObjectui64v_2 := GetProcOrNil&<procedure(id: gl_query; pname: QueryObjectParameterName; var &params: UInt64)>(z_GetQueryObjectui64v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectui64v(id: gl_query; pname: QueryObjectParameterName; var &params: UInt64) :=
    z_GetQueryObjectui64v_2(id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectui64v(id: gl_query; pname: QueryObjectParameterName; &params: IntPtr) :=
    z_GetQueryObjectui64v_1(id, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glTransformFeedback2ARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_transform_feedback2';
    
    private z_BindTransformFeedback_adr := GetProcAddress('glBindTransformFeedback');
    private z_BindTransformFeedback_1 := GetProcOrNil&<procedure(target: BindTransformFeedbackTarget; id: gl_transform_feedback)>(z_BindTransformFeedback_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTransformFeedback(target: BindTransformFeedbackTarget; id: gl_transform_feedback) :=
    z_BindTransformFeedback_1(target, id);
    
    private z_DeleteTransformFeedbacks_adr := GetProcAddress('glDeleteTransformFeedbacks');
    private z_DeleteTransformFeedbacks_1 := GetProcOrNil&<procedure(n: Int32; ids: IntPtr)>(z_DeleteTransformFeedbacks_adr);
    private z_DeleteTransformFeedbacks_2 := GetProcOrNil&<procedure(n: Int32; var ids: gl_transform_feedback)>(z_DeleteTransformFeedbacks_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTransformFeedbacks(n: Int32; ids: array of gl_transform_feedback);
    type Pgl_transform_feedback=^gl_transform_feedback;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        z_DeleteTransformFeedbacks_2(n, ids[0]) else
        z_DeleteTransformFeedbacks_2(n, Pgl_transform_feedback(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTransformFeedbacks(n: Int32; var ids: gl_transform_feedback) :=
    z_DeleteTransformFeedbacks_2(n, ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTransformFeedbacks(n: Int32; ids: IntPtr) :=
    z_DeleteTransformFeedbacks_1(n, ids);
    
    private z_GenTransformFeedbacks_adr := GetProcAddress('glGenTransformFeedbacks');
    private z_GenTransformFeedbacks_1 := GetProcOrNil&<procedure(n: Int32; ids: IntPtr)>(z_GenTransformFeedbacks_adr);
    private z_GenTransformFeedbacks_2 := GetProcOrNil&<procedure(n: Int32; var ids: gl_transform_feedback)>(z_GenTransformFeedbacks_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTransformFeedbacks(n: Int32; ids: array of gl_transform_feedback);
    type Pgl_transform_feedback=^gl_transform_feedback;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        z_GenTransformFeedbacks_2(n, ids[0]) else
        z_GenTransformFeedbacks_2(n, Pgl_transform_feedback(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTransformFeedbacks(n: Int32; var ids: gl_transform_feedback) :=
    z_GenTransformFeedbacks_2(n, ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTransformFeedbacks(n: Int32; ids: IntPtr) :=
    z_GenTransformFeedbacks_1(n, ids);
    
    private z_IsTransformFeedback_adr := GetProcAddress('glIsTransformFeedback');
    private z_IsTransformFeedback_1 := GetProcOrNil&<function(id: gl_transform_feedback): boolean>(z_IsTransformFeedback_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsTransformFeedback(id: gl_transform_feedback): boolean :=
    z_IsTransformFeedback_1(id);
    
    private z_PauseTransformFeedback_adr := GetProcAddress('glPauseTransformFeedback');
    private z_PauseTransformFeedback_1 := GetProcOrNil&<procedure>(z_PauseTransformFeedback_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PauseTransformFeedback :=
    z_PauseTransformFeedback_1();
    
    private z_ResumeTransformFeedback_adr := GetProcAddress('glResumeTransformFeedback');
    private z_ResumeTransformFeedback_1 := GetProcOrNil&<procedure>(z_ResumeTransformFeedback_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ResumeTransformFeedback :=
    z_ResumeTransformFeedback_1();
    
    private z_DrawTransformFeedback_adr := GetProcAddress('glDrawTransformFeedback');
    private z_DrawTransformFeedback_1 := GetProcOrNil&<procedure(mode: PrimitiveType; id: gl_transform_feedback)>(z_DrawTransformFeedback_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTransformFeedback(mode: PrimitiveType; id: gl_transform_feedback) :=
    z_DrawTransformFeedback_1(mode, id);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glTransformFeedback3ARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_transform_feedback3';
    
    private z_DrawTransformFeedbackStream_adr := GetProcAddress('glDrawTransformFeedbackStream');
    private z_DrawTransformFeedbackStream_1 := GetProcOrNil&<procedure(mode: PrimitiveType; id: gl_transform_feedback; stream: UInt32)>(z_DrawTransformFeedbackStream_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTransformFeedbackStream(mode: PrimitiveType; id: gl_transform_feedback; stream: UInt32) :=
    z_DrawTransformFeedbackStream_1(mode, id, stream);
    
    private z_BeginQueryIndexed_adr := GetProcAddress('glBeginQueryIndexed');
    private z_BeginQueryIndexed_1 := GetProcOrNil&<procedure(target: QueryTarget; index: UInt32; id: gl_query)>(z_BeginQueryIndexed_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginQueryIndexed(target: QueryTarget; index: UInt32; id: gl_query) :=
    z_BeginQueryIndexed_1(target, index, id);
    
    private z_EndQueryIndexed_adr := GetProcAddress('glEndQueryIndexed');
    private z_EndQueryIndexed_1 := GetProcOrNil&<procedure(target: QueryTarget; index: UInt32)>(z_EndQueryIndexed_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndQueryIndexed(target: QueryTarget; index: UInt32) :=
    z_EndQueryIndexed_1(target, index);
    
    private z_GetQueryIndexediv_adr := GetProcAddress('glGetQueryIndexediv');
    private z_GetQueryIndexediv_1 := GetProcOrNil&<procedure(target: QueryTarget; index: UInt32; pname: QueryParameterName; &params: IntPtr)>(z_GetQueryIndexediv_adr);
    private z_GetQueryIndexediv_2 := GetProcOrNil&<procedure(target: QueryTarget; index: UInt32; pname: QueryParameterName; var &params: Int32)>(z_GetQueryIndexediv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryIndexediv(target: QueryTarget; index: UInt32; pname: QueryParameterName; var &params: Int32) :=
    z_GetQueryIndexediv_2(target, index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryIndexediv(target: QueryTarget; index: UInt32; pname: QueryParameterName; &params: IntPtr) :=
    z_GetQueryIndexediv_1(target, index, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glTransformFeedbackInstancedARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_transform_feedback_instanced';
    
    private z_DrawTransformFeedbackInstanced_adr := GetProcAddress('glDrawTransformFeedbackInstanced');
    private z_DrawTransformFeedbackInstanced_1 := GetProcOrNil&<procedure(mode: PrimitiveType; id: gl_transform_feedback; instancecount: Int32)>(z_DrawTransformFeedbackInstanced_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTransformFeedbackInstanced(mode: PrimitiveType; id: gl_transform_feedback; instancecount: Int32) :=
    z_DrawTransformFeedbackInstanced_1(mode, id, instancecount);
    
    private z_DrawTransformFeedbackStreamInstanced_adr := GetProcAddress('glDrawTransformFeedbackStreamInstanced');
    private z_DrawTransformFeedbackStreamInstanced_1 := GetProcOrNil&<procedure(mode: PrimitiveType; id: gl_transform_feedback; stream: UInt32; instancecount: Int32)>(z_DrawTransformFeedbackStreamInstanced_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTransformFeedbackStreamInstanced(mode: PrimitiveType; id: gl_transform_feedback; stream: UInt32; instancecount: Int32) :=
    z_DrawTransformFeedbackStreamInstanced_1(mode, id, stream, instancecount);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glTransposeMatrixARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_transpose_matrix';
    
    private z_LoadTransposeMatrixfARB_adr := GetProcAddress('glLoadTransposeMatrixfARB');
    private z_LoadTransposeMatrixfARB_1 := GetProcOrNil&<procedure(m: IntPtr)>(z_LoadTransposeMatrixfARB_adr);
    private z_LoadTransposeMatrixfARB_2 := GetProcOrNil&<procedure(var m: single)>(z_LoadTransposeMatrixfARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixfARB(m: array of single);
    type Psingle=^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_LoadTransposeMatrixfARB_2(m[0]) else
        z_LoadTransposeMatrixfARB_2(Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixfARB(var m: single) :=
    z_LoadTransposeMatrixfARB_2(m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixfARB(m: IntPtr) :=
    z_LoadTransposeMatrixfARB_1(m);
    
    private z_LoadTransposeMatrixdARB_adr := GetProcAddress('glLoadTransposeMatrixdARB');
    private z_LoadTransposeMatrixdARB_1 := GetProcOrNil&<procedure(m: IntPtr)>(z_LoadTransposeMatrixdARB_adr);
    private z_LoadTransposeMatrixdARB_2 := GetProcOrNil&<procedure(var m: real)>(z_LoadTransposeMatrixdARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixdARB(m: array of real);
    type Preal=^real;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_LoadTransposeMatrixdARB_2(m[0]) else
        z_LoadTransposeMatrixdARB_2(Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixdARB(var m: real) :=
    z_LoadTransposeMatrixdARB_2(m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixdARB(m: IntPtr) :=
    z_LoadTransposeMatrixdARB_1(m);
    
    private z_MultTransposeMatrixfARB_adr := GetProcAddress('glMultTransposeMatrixfARB');
    private z_MultTransposeMatrixfARB_1 := GetProcOrNil&<procedure(m: IntPtr)>(z_MultTransposeMatrixfARB_adr);
    private z_MultTransposeMatrixfARB_2 := GetProcOrNil&<procedure(var m: single)>(z_MultTransposeMatrixfARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixfARB(m: array of single);
    type Psingle=^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_MultTransposeMatrixfARB_2(m[0]) else
        z_MultTransposeMatrixfARB_2(Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixfARB(var m: single) :=
    z_MultTransposeMatrixfARB_2(m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixfARB(m: IntPtr) :=
    z_MultTransposeMatrixfARB_1(m);
    
    private z_MultTransposeMatrixdARB_adr := GetProcAddress('glMultTransposeMatrixdARB');
    private z_MultTransposeMatrixdARB_1 := GetProcOrNil&<procedure(m: IntPtr)>(z_MultTransposeMatrixdARB_adr);
    private z_MultTransposeMatrixdARB_2 := GetProcOrNil&<procedure(var m: real)>(z_MultTransposeMatrixdARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixdARB(m: array of real);
    type Preal=^real;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_MultTransposeMatrixdARB_2(m[0]) else
        z_MultTransposeMatrixdARB_2(Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixdARB(var m: real) :=
    z_MultTransposeMatrixdARB_2(m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixdARB(m: IntPtr) :=
    z_MultTransposeMatrixdARB_1(m);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glUniformBufferObjectARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_uniform_buffer_object';
    
    private z_GetUniformIndices_adr := GetProcAddress('glGetUniformIndices');
    private z_GetUniformIndices_1 := GetProcOrNil&<procedure(&program: gl_program; uniformCount: Int32; uniformNames: pointer; uniformIndices: IntPtr)>(z_GetUniformIndices_adr);
    private z_GetUniformIndices_2 := GetProcOrNil&<procedure(&program: gl_program; uniformCount: Int32; uniformNames: pointer; var uniformIndices: UInt32)>(z_GetUniformIndices_adr);
    private z_GetUniformIndices_3 := GetProcOrNil&<procedure(&program: gl_program; uniformCount: Int32; var uniformNames: IntPtr; uniformIndices: IntPtr)>(z_GetUniformIndices_adr);
    private z_GetUniformIndices_4 := GetProcOrNil&<procedure(&program: gl_program; uniformCount: Int32; var uniformNames: IntPtr; var uniformIndices: UInt32)>(z_GetUniformIndices_adr);
    private [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure temp_GetUniformIndices_1(&program: gl_program; uniformCount: Int32; uniformNames: array of IntPtr; uniformIndices: IntPtr);
    type PIntPtr=^IntPtr;
    begin
      if (uniformNames<>nil) and (uniformNames.Length<>0) then
        z_GetUniformIndices_3(&program, uniformCount, uniformNames[0], uniformIndices) else
        z_GetUniformIndices_3(&program, uniformCount, PIntPtr(nil)^, uniformIndices);
    end;
    private [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure temp_GetUniformIndices_2(&program: gl_program; uniformCount: Int32; uniformNames: array of IntPtr; var uniformIndices: UInt32);
    type PIntPtr=^IntPtr;
    begin
      if (uniformNames<>nil) and (uniformNames.Length<>0) then
        z_GetUniformIndices_4(&program, uniformCount, uniformNames[0], uniformIndices) else
        z_GetUniformIndices_4(&program, uniformCount, PIntPtr(nil)^, uniformIndices);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformIndices(&program: gl_program; uniformCount: Int32; uniformNames: array of string; var uniformIndices: UInt32);
    begin
      var uniformNames_str_ptrs: array of IntPtr;
      try
        uniformNames_str_ptrs := uniformNames?.ConvertAll(arr_el1->
          Marshal.StringToHGlobalAnsi(arr_el1)
        );
        temp_GetUniformIndices_2(&program, uniformCount, uniformNames_str_ptrs, uniformIndices);
      finally
        if uniformNames_str_ptrs<>nil then foreach var arr_el1 in uniformNames_str_ptrs do
          Marshal.FreeHGlobal(arr_el1);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformIndices(&program: gl_program; uniformCount: Int32; uniformNames: array of string; uniformIndices: IntPtr);
    begin
      var uniformNames_str_ptrs: array of IntPtr;
      try
        uniformNames_str_ptrs := uniformNames?.ConvertAll(arr_el1->
          Marshal.StringToHGlobalAnsi(arr_el1)
        );
        temp_GetUniformIndices_1(&program, uniformCount, uniformNames_str_ptrs, uniformIndices);
      finally
        if uniformNames_str_ptrs<>nil then foreach var arr_el1 in uniformNames_str_ptrs do
          Marshal.FreeHGlobal(arr_el1);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformIndices(&program: gl_program; uniformCount: Int32; var uniformNames: IntPtr; var uniformIndices: UInt32) :=
    z_GetUniformIndices_4(&program, uniformCount, uniformNames, uniformIndices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformIndices(&program: gl_program; uniformCount: Int32; var uniformNames: IntPtr; uniformIndices: IntPtr) :=
    z_GetUniformIndices_3(&program, uniformCount, uniformNames, uniformIndices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformIndices(&program: gl_program; uniformCount: Int32; uniformNames: pointer; var uniformIndices: UInt32) :=
    z_GetUniformIndices_2(&program, uniformCount, uniformNames, uniformIndices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformIndices(&program: gl_program; uniformCount: Int32; uniformNames: pointer; uniformIndices: IntPtr) :=
    z_GetUniformIndices_1(&program, uniformCount, uniformNames, uniformIndices);
    
    private z_GetActiveUniformsiv_adr := GetProcAddress('glGetActiveUniformsiv');
    private z_GetActiveUniformsiv_1 := GetProcOrNil&<procedure(&program: gl_program; uniformCount: Int32; uniformIndices: IntPtr; pname: UniformPName; &params: IntPtr)>(z_GetActiveUniformsiv_adr);
    private z_GetActiveUniformsiv_2 := GetProcOrNil&<procedure(&program: gl_program; uniformCount: Int32; var uniformIndices: UInt32; pname: UniformPName; var &params: Int32)>(z_GetActiveUniformsiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformsiv(&program: gl_program; uniformCount: Int32; uniformIndices: array of UInt32; pname: UniformPName; &params: array of Int32);
    type PUInt32=^UInt32;
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        if (uniformIndices<>nil) and (uniformIndices.Length<>0) then
          z_GetActiveUniformsiv_2(&program, uniformCount, uniformIndices[0], pname, &params[0]) else
          z_GetActiveUniformsiv_2(&program, uniformCount, PUInt32(nil)^, pname, &params[0]) else
        if (uniformIndices<>nil) and (uniformIndices.Length<>0) then
          z_GetActiveUniformsiv_2(&program, uniformCount, uniformIndices[0], pname, PInt32(nil)^) else
          z_GetActiveUniformsiv_2(&program, uniformCount, PUInt32(nil)^, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformsiv(&program: gl_program; uniformCount: Int32; var uniformIndices: UInt32; pname: UniformPName; var &params: Int32) :=
    z_GetActiveUniformsiv_2(&program, uniformCount, uniformIndices, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformsiv(&program: gl_program; uniformCount: Int32; uniformIndices: IntPtr; pname: UniformPName; &params: IntPtr) :=
    z_GetActiveUniformsiv_1(&program, uniformCount, uniformIndices, pname, &params);
    
    private z_GetActiveUniformName_adr := GetProcAddress('glGetActiveUniformName');
    private z_GetActiveUniformName_1 := GetProcOrNil&<procedure(&program: gl_program; uniformIndex: UInt32; bufSize: Int32; length: IntPtr; uniformName: IntPtr)>(z_GetActiveUniformName_adr);
    private z_GetActiveUniformName_2 := GetProcOrNil&<procedure(&program: gl_program; uniformIndex: UInt32; bufSize: Int32; var length: Int32; uniformName: IntPtr)>(z_GetActiveUniformName_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformName(&program: gl_program; uniformIndex: UInt32; bufSize: Int32; var length: Int32; uniformName: IntPtr) :=
    z_GetActiveUniformName_2(&program, uniformIndex, bufSize, length, uniformName);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformName(&program: gl_program; uniformIndex: UInt32; bufSize: Int32; length: IntPtr; uniformName: IntPtr) :=
    z_GetActiveUniformName_1(&program, uniformIndex, bufSize, length, uniformName);
    
    private z_GetUniformBlockIndex_adr := GetProcAddress('glGetUniformBlockIndex');
    private z_GetUniformBlockIndex_1 := GetProcOrNil&<function(&program: gl_program; uniformBlockName: IntPtr): UInt32>(z_GetUniformBlockIndex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetUniformBlockIndex(&program: gl_program; uniformBlockName: string): UInt32;
    begin
      var uniformBlockName_str_ptr: IntPtr;
      try
        uniformBlockName_str_ptr := Marshal.StringToHGlobalAnsi(uniformBlockName);
        Result := z_GetUniformBlockIndex_1(&program, uniformBlockName_str_ptr);
      finally
        Marshal.FreeHGlobal(uniformBlockName_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetUniformBlockIndex(&program: gl_program; uniformBlockName: IntPtr): UInt32 :=
    z_GetUniformBlockIndex_1(&program, uniformBlockName);
    
    private z_GetActiveUniformBlockiv_adr := GetProcAddress('glGetActiveUniformBlockiv');
    private z_GetActiveUniformBlockiv_1 := GetProcOrNil&<procedure(&program: gl_program; uniformBlockIndex: UInt32; pname: UniformBlockPName; &params: IntPtr)>(z_GetActiveUniformBlockiv_adr);
    private z_GetActiveUniformBlockiv_2 := GetProcOrNil&<procedure(&program: gl_program; uniformBlockIndex: UInt32; pname: UniformBlockPName; var &params: Int32)>(z_GetActiveUniformBlockiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformBlockiv(&program: gl_program; uniformBlockIndex: UInt32; pname: UniformBlockPName; var &params: Int32) :=
    z_GetActiveUniformBlockiv_2(&program, uniformBlockIndex, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformBlockiv(&program: gl_program; uniformBlockIndex: UInt32; pname: UniformBlockPName; &params: IntPtr) :=
    z_GetActiveUniformBlockiv_1(&program, uniformBlockIndex, pname, &params);
    
    private z_GetActiveUniformBlockName_adr := GetProcAddress('glGetActiveUniformBlockName');
    private z_GetActiveUniformBlockName_1 := GetProcOrNil&<procedure(&program: gl_program; uniformBlockIndex: UInt32; bufSize: Int32; length: IntPtr; uniformBlockName: IntPtr)>(z_GetActiveUniformBlockName_adr);
    private z_GetActiveUniformBlockName_2 := GetProcOrNil&<procedure(&program: gl_program; uniformBlockIndex: UInt32; bufSize: Int32; var length: Int32; uniformBlockName: IntPtr)>(z_GetActiveUniformBlockName_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformBlockName(&program: gl_program; uniformBlockIndex: UInt32; bufSize: Int32; var length: Int32; uniformBlockName: IntPtr) :=
    z_GetActiveUniformBlockName_2(&program, uniformBlockIndex, bufSize, length, uniformBlockName);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformBlockName(&program: gl_program; uniformBlockIndex: UInt32; bufSize: Int32; length: IntPtr; uniformBlockName: IntPtr) :=
    z_GetActiveUniformBlockName_1(&program, uniformBlockIndex, bufSize, length, uniformBlockName);
    
    private z_UniformBlockBinding_adr := GetProcAddress('glUniformBlockBinding');
    private z_UniformBlockBinding_1 := GetProcOrNil&<procedure(&program: gl_program; uniformBlockIndex: UInt32; uniformBlockBinding: UInt32)>(z_UniformBlockBinding_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformBlockBinding(&program: gl_program; uniformBlockIndex: UInt32; uniformBlockBinding: UInt32) :=
    z_UniformBlockBinding_1(&program, uniformBlockIndex, uniformBlockBinding);
    
    private z_BindBufferRange_adr := GetProcAddress('glBindBufferRange');
    private z_BindBufferRange_1 := GetProcOrNil&<procedure(target: BufferTarget; index: UInt32; buffer: gl_buffer; offset: IntPtr; size: UIntPtr)>(z_BindBufferRange_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBufferRange(target: BufferTarget; index: UInt32; buffer: gl_buffer; offset: IntPtr; size: UIntPtr) :=
    z_BindBufferRange_1(target, index, buffer, offset, size);
    
    private z_BindBufferBase_adr := GetProcAddress('glBindBufferBase');
    private z_BindBufferBase_1 := GetProcOrNil&<procedure(target: BufferTarget; index: UInt32; buffer: gl_buffer)>(z_BindBufferBase_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBufferBase(target: BufferTarget; index: UInt32; buffer: gl_buffer) :=
    z_BindBufferBase_1(target, index, buffer);
    
    private z_GetIntegeri_v_adr := GetProcAddress('glGetIntegeri_v');
    private z_GetIntegeri_v_1 := GetProcOrNil&<procedure(target: GetPName; index: UInt32; data: IntPtr)>(z_GetIntegeri_v_adr);
    private z_GetIntegeri_v_2 := GetProcOrNil&<procedure(target: GetPName; index: UInt32; var data: Int32)>(z_GetIntegeri_v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegeri_v(target: GetPName; index: UInt32; var data: Int32) :=
    z_GetIntegeri_v_2(target, index, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegeri_v(target: GetPName; index: UInt32; data: IntPtr) :=
    z_GetIntegeri_v_1(target, index, data);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glVertexArrayObjectARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_vertex_array_object';
    
    private z_BindVertexArray_adr := GetProcAddress('glBindVertexArray');
    private z_BindVertexArray_1 := GetProcOrNil&<procedure(&array: gl_vertex_array)>(z_BindVertexArray_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexArray(&array: gl_vertex_array) :=
    z_BindVertexArray_1(&array);
    
    private z_DeleteVertexArrays_adr := GetProcAddress('glDeleteVertexArrays');
    private z_DeleteVertexArrays_1 := GetProcOrNil&<procedure(n: Int32; arrays: IntPtr)>(z_DeleteVertexArrays_adr);
    private z_DeleteVertexArrays_2 := GetProcOrNil&<procedure(n: Int32; var arrays: gl_vertex_array)>(z_DeleteVertexArrays_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteVertexArrays(n: Int32; arrays: array of gl_vertex_array);
    type Pgl_vertex_array=^gl_vertex_array;
    begin
      if (arrays<>nil) and (arrays.Length<>0) then
        z_DeleteVertexArrays_2(n, arrays[0]) else
        z_DeleteVertexArrays_2(n, Pgl_vertex_array(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteVertexArrays(n: Int32; var arrays: gl_vertex_array) :=
    z_DeleteVertexArrays_2(n, arrays);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteVertexArrays(n: Int32; arrays: IntPtr) :=
    z_DeleteVertexArrays_1(n, arrays);
    
    private z_GenVertexArrays_adr := GetProcAddress('glGenVertexArrays');
    private z_GenVertexArrays_1 := GetProcOrNil&<procedure(n: Int32; arrays: IntPtr)>(z_GenVertexArrays_adr);
    private z_GenVertexArrays_2 := GetProcOrNil&<procedure(n: Int32; var arrays: gl_vertex_array)>(z_GenVertexArrays_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenVertexArrays(n: Int32; arrays: array of gl_vertex_array);
    type Pgl_vertex_array=^gl_vertex_array;
    begin
      if (arrays<>nil) and (arrays.Length<>0) then
        z_GenVertexArrays_2(n, arrays[0]) else
        z_GenVertexArrays_2(n, Pgl_vertex_array(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenVertexArrays(n: Int32; var arrays: gl_vertex_array) :=
    z_GenVertexArrays_2(n, arrays);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenVertexArrays(n: Int32; arrays: IntPtr) :=
    z_GenVertexArrays_1(n, arrays);
    
    private z_IsVertexArray_adr := GetProcAddress('glIsVertexArray');
    private z_IsVertexArray_1 := GetProcOrNil&<function(&array: gl_vertex_array): boolean>(z_IsVertexArray_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsVertexArray(&array: gl_vertex_array): boolean :=
    z_IsVertexArray_1(&array);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glVertexAttrib64bitARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_vertex_attrib_64bit';
    
    private z_VertexAttribL1d_adr := GetProcAddress('glVertexAttribL1d');
    private z_VertexAttribL1d_1 := GetProcOrNil&<procedure(index: UInt32; x: real)>(z_VertexAttribL1d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1d(index: UInt32; x: real) :=
    z_VertexAttribL1d_1(index, x);
    
    private z_VertexAttribL2d_adr := GetProcAddress('glVertexAttribL2d');
    private z_VertexAttribL2d_1 := GetProcOrNil&<procedure(index: UInt32; x: real; y: real)>(z_VertexAttribL2d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2d(index: UInt32; x: real; y: real) :=
    z_VertexAttribL2d_1(index, x, y);
    
    private z_VertexAttribL3d_adr := GetProcAddress('glVertexAttribL3d');
    private z_VertexAttribL3d_1 := GetProcOrNil&<procedure(index: UInt32; x: real; y: real; z: real)>(z_VertexAttribL3d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3d(index: UInt32; x: real; y: real; z: real) :=
    z_VertexAttribL3d_1(index, x, y, z);
    
    private z_VertexAttribL4d_adr := GetProcAddress('glVertexAttribL4d');
    private z_VertexAttribL4d_1 := GetProcOrNil&<procedure(index: UInt32; x: real; y: real; z: real; w: real)>(z_VertexAttribL4d_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4d(index: UInt32; x: real; y: real; z: real; w: real) :=
    z_VertexAttribL4d_1(index, x, y, z, w);
    
    private z_VertexAttribL1dv_adr := GetProcAddress('glVertexAttribL1dv');
    private z_VertexAttribL1dv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribL1dv_adr);
    private z_VertexAttribL1dv_2 := GetProcOrNil&<procedure(index: UInt32; var v: real)>(z_VertexAttribL1dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1dv(index: UInt32; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribL1dv_2(index, v[0]) else
        z_VertexAttribL1dv_2(index, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1dv(index: UInt32; var v: real) :=
    z_VertexAttribL1dv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1dv(index: UInt32; v: IntPtr) :=
    z_VertexAttribL1dv_1(index, v);
    
    private z_VertexAttribL2dv_adr := GetProcAddress('glVertexAttribL2dv');
    private z_VertexAttribL2dv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribL2dv_adr);
    private z_VertexAttribL2dv_2 := GetProcOrNil&<procedure(index: UInt32; var v: real)>(z_VertexAttribL2dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2dv(index: UInt32; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribL2dv_2(index, v[0]) else
        z_VertexAttribL2dv_2(index, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2dv(index: UInt32; var v: real) :=
    z_VertexAttribL2dv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2dv(index: UInt32; v: IntPtr) :=
    z_VertexAttribL2dv_1(index, v);
    
    private z_VertexAttribL3dv_adr := GetProcAddress('glVertexAttribL3dv');
    private z_VertexAttribL3dv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribL3dv_adr);
    private z_VertexAttribL3dv_2 := GetProcOrNil&<procedure(index: UInt32; var v: real)>(z_VertexAttribL3dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3dv(index: UInt32; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribL3dv_2(index, v[0]) else
        z_VertexAttribL3dv_2(index, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3dv(index: UInt32; var v: real) :=
    z_VertexAttribL3dv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3dv(index: UInt32; v: IntPtr) :=
    z_VertexAttribL3dv_1(index, v);
    
    private z_VertexAttribL4dv_adr := GetProcAddress('glVertexAttribL4dv');
    private z_VertexAttribL4dv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribL4dv_adr);
    private z_VertexAttribL4dv_2 := GetProcOrNil&<procedure(index: UInt32; var v: real)>(z_VertexAttribL4dv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4dv(index: UInt32; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribL4dv_2(index, v[0]) else
        z_VertexAttribL4dv_2(index, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4dv(index: UInt32; var v: real) :=
    z_VertexAttribL4dv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4dv(index: UInt32; v: IntPtr) :=
    z_VertexAttribL4dv_1(index, v);
    
    private z_VertexAttribLPointer_adr := GetProcAddress('glVertexAttribLPointer');
    private z_VertexAttribLPointer_1 := GetProcOrNil&<procedure(index: UInt32; size: Int32; &type: VertexAttribLType; stride: Int32; pointer: IntPtr)>(z_VertexAttribLPointer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribLPointer(index: UInt32; size: Int32; &type: VertexAttribLType; stride: Int32; pointer: IntPtr) :=
    z_VertexAttribLPointer_1(index, size, &type, stride, pointer);
    
    private z_GetVertexAttribLdv_adr := GetProcAddress('glGetVertexAttribLdv');
    private z_GetVertexAttribLdv_1 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribEnum; &params: IntPtr)>(z_GetVertexAttribLdv_adr);
    private z_GetVertexAttribLdv_2 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribEnum; var &params: real)>(z_GetVertexAttribLdv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLdv(index: UInt32; pname: VertexAttribEnum; var &params: real) :=
    z_GetVertexAttribLdv_2(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLdv(index: UInt32; pname: VertexAttribEnum; &params: IntPtr) :=
    z_GetVertexAttribLdv_1(index, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glVertexAttribBindingARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_vertex_attrib_binding';
    
    private z_BindVertexBuffer_adr := GetProcAddress('glBindVertexBuffer');
    private z_BindVertexBuffer_1 := GetProcOrNil&<procedure(bindingindex: UInt32; buffer: gl_buffer; offset: IntPtr; stride: Int32)>(z_BindVertexBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffer(bindingindex: UInt32; buffer: gl_buffer; offset: IntPtr; stride: Int32) :=
    z_BindVertexBuffer_1(bindingindex, buffer, offset, stride);
    
    private z_VertexAttribFormat_adr := GetProcAddress('glVertexAttribFormat');
    private z_VertexAttribFormat_1 := GetProcOrNil&<procedure(attribindex: UInt32; size: Int32; &type: VertexAttribType; normalized: boolean; relativeoffset: UInt32)>(z_VertexAttribFormat_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribFormat(attribindex: UInt32; size: Int32; &type: VertexAttribType; normalized: boolean; relativeoffset: UInt32) :=
    z_VertexAttribFormat_1(attribindex, size, &type, normalized, relativeoffset);
    
    private z_VertexAttribIFormat_adr := GetProcAddress('glVertexAttribIFormat');
    private z_VertexAttribIFormat_1 := GetProcOrNil&<procedure(attribindex: UInt32; size: Int32; &type: VertexAttribIType; relativeoffset: UInt32)>(z_VertexAttribIFormat_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribIFormat(attribindex: UInt32; size: Int32; &type: VertexAttribIType; relativeoffset: UInt32) :=
    z_VertexAttribIFormat_1(attribindex, size, &type, relativeoffset);
    
    private z_VertexAttribLFormat_adr := GetProcAddress('glVertexAttribLFormat');
    private z_VertexAttribLFormat_1 := GetProcOrNil&<procedure(attribindex: UInt32; size: Int32; &type: VertexAttribLType; relativeoffset: UInt32)>(z_VertexAttribLFormat_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribLFormat(attribindex: UInt32; size: Int32; &type: VertexAttribLType; relativeoffset: UInt32) :=
    z_VertexAttribLFormat_1(attribindex, size, &type, relativeoffset);
    
    private z_VertexAttribBinding_adr := GetProcAddress('glVertexAttribBinding');
    private z_VertexAttribBinding_1 := GetProcOrNil&<procedure(attribindex: UInt32; bindingindex: UInt32)>(z_VertexAttribBinding_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribBinding(attribindex: UInt32; bindingindex: UInt32) :=
    z_VertexAttribBinding_1(attribindex, bindingindex);
    
    private z_VertexBindingDivisor_adr := GetProcAddress('glVertexBindingDivisor');
    private z_VertexBindingDivisor_1 := GetProcOrNil&<procedure(bindingindex: UInt32; divisor: UInt32)>(z_VertexBindingDivisor_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexBindingDivisor(bindingindex: UInt32; divisor: UInt32) :=
    z_VertexBindingDivisor_1(bindingindex, divisor);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glVertexBlendARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_vertex_blend';
    
    private z_WeightbvARB_adr := GetProcAddress('glWeightbvARB');
    private z_WeightbvARB_1 := GetProcOrNil&<procedure(size: Int32; weights: IntPtr)>(z_WeightbvARB_adr);
    private z_WeightbvARB_2 := GetProcOrNil&<procedure(size: Int32; var weights: SByte)>(z_WeightbvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightbvARB(size: Int32; weights: array of SByte);
    type PSByte=^SByte;
    begin
      if (weights<>nil) and (weights.Length<>0) then
        z_WeightbvARB_2(size, weights[0]) else
        z_WeightbvARB_2(size, PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightbvARB(size: Int32; var weights: SByte) :=
    z_WeightbvARB_2(size, weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightbvARB(size: Int32; weights: IntPtr) :=
    z_WeightbvARB_1(size, weights);
    
    private z_WeightsvARB_adr := GetProcAddress('glWeightsvARB');
    private z_WeightsvARB_1 := GetProcOrNil&<procedure(size: Int32; weights: IntPtr)>(z_WeightsvARB_adr);
    private z_WeightsvARB_2 := GetProcOrNil&<procedure(size: Int32; var weights: Int16)>(z_WeightsvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightsvARB(size: Int32; weights: array of Int16);
    type PInt16=^Int16;
    begin
      if (weights<>nil) and (weights.Length<>0) then
        z_WeightsvARB_2(size, weights[0]) else
        z_WeightsvARB_2(size, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightsvARB(size: Int32; var weights: Int16) :=
    z_WeightsvARB_2(size, weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightsvARB(size: Int32; weights: IntPtr) :=
    z_WeightsvARB_1(size, weights);
    
    private z_WeightivARB_adr := GetProcAddress('glWeightivARB');
    private z_WeightivARB_1 := GetProcOrNil&<procedure(size: Int32; weights: IntPtr)>(z_WeightivARB_adr);
    private z_WeightivARB_2 := GetProcOrNil&<procedure(size: Int32; var weights: Int32)>(z_WeightivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightivARB(size: Int32; weights: array of Int32);
    type PInt32=^Int32;
    begin
      if (weights<>nil) and (weights.Length<>0) then
        z_WeightivARB_2(size, weights[0]) else
        z_WeightivARB_2(size, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightivARB(size: Int32; var weights: Int32) :=
    z_WeightivARB_2(size, weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightivARB(size: Int32; weights: IntPtr) :=
    z_WeightivARB_1(size, weights);
    
    private z_WeightfvARB_adr := GetProcAddress('glWeightfvARB');
    private z_WeightfvARB_1 := GetProcOrNil&<procedure(size: Int32; weights: IntPtr)>(z_WeightfvARB_adr);
    private z_WeightfvARB_2 := GetProcOrNil&<procedure(size: Int32; var weights: single)>(z_WeightfvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightfvARB(size: Int32; weights: array of single);
    type Psingle=^single;
    begin
      if (weights<>nil) and (weights.Length<>0) then
        z_WeightfvARB_2(size, weights[0]) else
        z_WeightfvARB_2(size, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightfvARB(size: Int32; var weights: single) :=
    z_WeightfvARB_2(size, weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightfvARB(size: Int32; weights: IntPtr) :=
    z_WeightfvARB_1(size, weights);
    
    private z_WeightdvARB_adr := GetProcAddress('glWeightdvARB');
    private z_WeightdvARB_1 := GetProcOrNil&<procedure(size: Int32; weights: IntPtr)>(z_WeightdvARB_adr);
    private z_WeightdvARB_2 := GetProcOrNil&<procedure(size: Int32; var weights: real)>(z_WeightdvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightdvARB(size: Int32; weights: array of real);
    type Preal=^real;
    begin
      if (weights<>nil) and (weights.Length<>0) then
        z_WeightdvARB_2(size, weights[0]) else
        z_WeightdvARB_2(size, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightdvARB(size: Int32; var weights: real) :=
    z_WeightdvARB_2(size, weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightdvARB(size: Int32; weights: IntPtr) :=
    z_WeightdvARB_1(size, weights);
    
    private z_WeightubvARB_adr := GetProcAddress('glWeightubvARB');
    private z_WeightubvARB_1 := GetProcOrNil&<procedure(size: Int32; weights: IntPtr)>(z_WeightubvARB_adr);
    private z_WeightubvARB_2 := GetProcOrNil&<procedure(size: Int32; var weights: Byte)>(z_WeightubvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightubvARB(size: Int32; weights: array of Byte);
    type PByte=^Byte;
    begin
      if (weights<>nil) and (weights.Length<>0) then
        z_WeightubvARB_2(size, weights[0]) else
        z_WeightubvARB_2(size, PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightubvARB(size: Int32; var weights: Byte) :=
    z_WeightubvARB_2(size, weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightubvARB(size: Int32; weights: IntPtr) :=
    z_WeightubvARB_1(size, weights);
    
    private z_WeightusvARB_adr := GetProcAddress('glWeightusvARB');
    private z_WeightusvARB_1 := GetProcOrNil&<procedure(size: Int32; weights: IntPtr)>(z_WeightusvARB_adr);
    private z_WeightusvARB_2 := GetProcOrNil&<procedure(size: Int32; var weights: UInt16)>(z_WeightusvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightusvARB(size: Int32; weights: array of UInt16);
    type PUInt16=^UInt16;
    begin
      if (weights<>nil) and (weights.Length<>0) then
        z_WeightusvARB_2(size, weights[0]) else
        z_WeightusvARB_2(size, PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightusvARB(size: Int32; var weights: UInt16) :=
    z_WeightusvARB_2(size, weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightusvARB(size: Int32; weights: IntPtr) :=
    z_WeightusvARB_1(size, weights);
    
    private z_WeightuivARB_adr := GetProcAddress('glWeightuivARB');
    private z_WeightuivARB_1 := GetProcOrNil&<procedure(size: Int32; weights: IntPtr)>(z_WeightuivARB_adr);
    private z_WeightuivARB_2 := GetProcOrNil&<procedure(size: Int32; var weights: UInt32)>(z_WeightuivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightuivARB(size: Int32; weights: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (weights<>nil) and (weights.Length<>0) then
        z_WeightuivARB_2(size, weights[0]) else
        z_WeightuivARB_2(size, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightuivARB(size: Int32; var weights: UInt32) :=
    z_WeightuivARB_2(size, weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightuivARB(size: Int32; weights: IntPtr) :=
    z_WeightuivARB_1(size, weights);
    
    private z_WeightPointerARB_adr := GetProcAddress('glWeightPointerARB');
    private z_WeightPointerARB_1 := GetProcOrNil&<procedure(size: Int32; &type: WeightPointerType; stride: Int32; pointer: IntPtr)>(z_WeightPointerARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightPointerARB(size: Int32; &type: WeightPointerType; stride: Int32; pointer: IntPtr) :=
    z_WeightPointerARB_1(size, &type, stride, pointer);
    
    private z_VertexBlendARB_adr := GetProcAddress('glVertexBlendARB');
    private z_VertexBlendARB_1 := GetProcOrNil&<procedure(count: Int32)>(z_VertexBlendARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexBlendARB(count: Int32) :=
    z_VertexBlendARB_1(count);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glVertexBufferObjectARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_vertex_buffer_object';
    
    private z_BindBufferARB_adr := GetProcAddress('glBindBufferARB');
    private z_BindBufferARB_1 := GetProcOrNil&<procedure(target: BufferTarget; buffer: gl_buffer)>(z_BindBufferARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBufferARB(target: BufferTarget; buffer: gl_buffer) :=
    z_BindBufferARB_1(target, buffer);
    
    private z_DeleteBuffersARB_adr := GetProcAddress('glDeleteBuffersARB');
    private z_DeleteBuffersARB_1 := GetProcOrNil&<procedure(n: Int32; buffers: IntPtr)>(z_DeleteBuffersARB_adr);
    private z_DeleteBuffersARB_2 := GetProcOrNil&<procedure(n: Int32; var buffers: gl_buffer)>(z_DeleteBuffersARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteBuffersARB(n: Int32; buffers: array of gl_buffer);
    type Pgl_buffer=^gl_buffer;
    begin
      if (buffers<>nil) and (buffers.Length<>0) then
        z_DeleteBuffersARB_2(n, buffers[0]) else
        z_DeleteBuffersARB_2(n, Pgl_buffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteBuffersARB(n: Int32; var buffers: gl_buffer) :=
    z_DeleteBuffersARB_2(n, buffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteBuffersARB(n: Int32; buffers: IntPtr) :=
    z_DeleteBuffersARB_1(n, buffers);
    
    private z_GenBuffersARB_adr := GetProcAddress('glGenBuffersARB');
    private z_GenBuffersARB_1 := GetProcOrNil&<procedure(n: Int32; buffers: IntPtr)>(z_GenBuffersARB_adr);
    private z_GenBuffersARB_2 := GetProcOrNil&<procedure(n: Int32; var buffers: gl_buffer)>(z_GenBuffersARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenBuffersARB(n: Int32; buffers: array of gl_buffer);
    type Pgl_buffer=^gl_buffer;
    begin
      if (buffers<>nil) and (buffers.Length<>0) then
        z_GenBuffersARB_2(n, buffers[0]) else
        z_GenBuffersARB_2(n, Pgl_buffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenBuffersARB(n: Int32; var buffers: gl_buffer) :=
    z_GenBuffersARB_2(n, buffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenBuffersARB(n: Int32; buffers: IntPtr) :=
    z_GenBuffersARB_1(n, buffers);
    
    private z_IsBufferARB_adr := GetProcAddress('glIsBufferARB');
    private z_IsBufferARB_1 := GetProcOrNil&<function(buffer: gl_buffer): boolean>(z_IsBufferARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsBufferARB(buffer: gl_buffer): boolean :=
    z_IsBufferARB_1(buffer);
    
    private z_BufferDataARB_adr := GetProcAddress('glBufferDataARB');
    private z_BufferDataARB_1 := GetProcOrNil&<procedure(target: BufferTarget; size: UIntPtr; data: pointer; usage: BufferUsage)>(z_BufferDataARB_adr);
    private z_BufferDataARB_2 := GetProcOrNil&<procedure(target: BufferTarget; size: UIntPtr; var data: Byte; usage: BufferUsage)>(z_BufferDataARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferDataARB<T>(target: BufferTarget; size: UIntPtr; data: array of T; usage: BufferUsage); where T: record;
    type PT=^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        BufferDataARB(target, size, data[0], usage) else
        BufferDataARB(target, size, PT(nil)^, usage);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferDataARB<T>(target: BufferTarget; size: UIntPtr; var data: T; usage: BufferUsage); where T: record;
    begin
      z_BufferDataARB_2(target, size, PByte(pointer(@data))^, usage);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferDataARB(target: BufferTarget; size: UIntPtr; data: pointer; usage: BufferUsage) :=
    z_BufferDataARB_1(target, size, data, usage);
    
    private z_BufferSubDataARB_adr := GetProcAddress('glBufferSubDataARB');
    private z_BufferSubDataARB_1 := GetProcOrNil&<procedure(target: BufferTarget; offset: IntPtr; size: UIntPtr; data: pointer)>(z_BufferSubDataARB_adr);
    private z_BufferSubDataARB_2 := GetProcOrNil&<procedure(target: BufferTarget; offset: IntPtr; size: UIntPtr; var data: Byte)>(z_BufferSubDataARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferSubDataARB<T>(target: BufferTarget; offset: IntPtr; size: UIntPtr; data: array of T); where T: record;
    type PT=^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        BufferSubDataARB(target, offset, size, data[0]) else
        BufferSubDataARB(target, offset, size, PT(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferSubDataARB<T>(target: BufferTarget; offset: IntPtr; size: UIntPtr; var data: T); where T: record;
    begin
      z_BufferSubDataARB_2(target, offset, size, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferSubDataARB(target: BufferTarget; offset: IntPtr; size: UIntPtr; data: pointer) :=
    z_BufferSubDataARB_1(target, offset, size, data);
    
    private z_GetBufferSubDataARB_adr := GetProcAddress('glGetBufferSubDataARB');
    private z_GetBufferSubDataARB_1 := GetProcOrNil&<procedure(target: BufferTarget; offset: IntPtr; size: UIntPtr; data: pointer)>(z_GetBufferSubDataARB_adr);
    private z_GetBufferSubDataARB_2 := GetProcOrNil&<procedure(target: BufferTarget; offset: IntPtr; size: UIntPtr; var data: Byte)>(z_GetBufferSubDataARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferSubDataARB<T>(target: BufferTarget; offset: IntPtr; size: UIntPtr; var data: T); where T: record;
    begin
      z_GetBufferSubDataARB_2(target, offset, size, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferSubDataARB(target: BufferTarget; offset: IntPtr; size: UIntPtr; data: pointer) :=
    z_GetBufferSubDataARB_1(target, offset, size, data);
    
    private z_MapBufferARB_adr := GetProcAddress('glMapBufferARB');
    private z_MapBufferARB_1 := GetProcOrNil&<function(target: BufferTarget; access: BufferAccess): IntPtr>(z_MapBufferARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapBufferARB(target: BufferTarget; access: BufferAccess): IntPtr :=
    z_MapBufferARB_1(target, access);
    
    private z_UnmapBufferARB_adr := GetProcAddress('glUnmapBufferARB');
    private z_UnmapBufferARB_1 := GetProcOrNil&<function(target: BufferTarget): boolean>(z_UnmapBufferARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function UnmapBufferARB(target: BufferTarget): boolean :=
    z_UnmapBufferARB_1(target);
    
    private z_GetBufferParameterivARB_adr := GetProcAddress('glGetBufferParameterivARB');
    private z_GetBufferParameterivARB_1 := GetProcOrNil&<procedure(target: BufferTarget; pname: BufferPName; &params: IntPtr)>(z_GetBufferParameterivARB_adr);
    private z_GetBufferParameterivARB_2 := GetProcOrNil&<procedure(target: BufferTarget; pname: BufferPName; var &params: Int32)>(z_GetBufferParameterivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferParameterivARB(target: BufferTarget; pname: BufferPName; var &params: Int32) :=
    z_GetBufferParameterivARB_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferParameterivARB(target: BufferTarget; pname: BufferPName; &params: IntPtr) :=
    z_GetBufferParameterivARB_1(target, pname, &params);
    
    private z_GetBufferPointervARB_adr := GetProcAddress('glGetBufferPointervARB');
    private z_GetBufferPointervARB_1 := GetProcOrNil&<procedure(target: BufferTarget; pname: BufferPointerName; &params: pointer)>(z_GetBufferPointervARB_adr);
    private z_GetBufferPointervARB_2 := GetProcOrNil&<procedure(target: BufferTarget; pname: BufferPointerName; var &params: IntPtr)>(z_GetBufferPointervARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferPointervARB(target: BufferTarget; pname: BufferPointerName; var &params: IntPtr) :=
    z_GetBufferPointervARB_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferPointervARB(target: BufferTarget; pname: BufferPointerName; &params: pointer) :=
    z_GetBufferPointervARB_1(target, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glVertexProgramARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_vertex_program';
    
    private z_VertexAttrib1dARB_adr := GetProcAddress('glVertexAttrib1dARB');
    private z_VertexAttrib1dARB_1 := GetProcOrNil&<procedure(index: UInt32; x: real)>(z_VertexAttrib1dARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dARB(index: UInt32; x: real) :=
    z_VertexAttrib1dARB_1(index, x);
    
    private z_VertexAttrib1dvARB_adr := GetProcAddress('glVertexAttrib1dvARB');
    private z_VertexAttrib1dvARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib1dvARB_adr);
    private z_VertexAttrib1dvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: real)>(z_VertexAttrib1dvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dvARB(index: UInt32; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib1dvARB_2(index, v[0]) else
        z_VertexAttrib1dvARB_2(index, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dvARB(index: UInt32; var v: real) :=
    z_VertexAttrib1dvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dvARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib1dvARB_1(index, v);
    
    private z_VertexAttrib1fARB_adr := GetProcAddress('glVertexAttrib1fARB');
    private z_VertexAttrib1fARB_1 := GetProcOrNil&<procedure(index: UInt32; x: single)>(z_VertexAttrib1fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fARB(index: UInt32; x: single) :=
    z_VertexAttrib1fARB_1(index, x);
    
    private z_VertexAttrib1fvARB_adr := GetProcAddress('glVertexAttrib1fvARB');
    private z_VertexAttrib1fvARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib1fvARB_adr);
    private z_VertexAttrib1fvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: single)>(z_VertexAttrib1fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fvARB(index: UInt32; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib1fvARB_2(index, v[0]) else
        z_VertexAttrib1fvARB_2(index, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fvARB(index: UInt32; var v: single) :=
    z_VertexAttrib1fvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fvARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib1fvARB_1(index, v);
    
    private z_VertexAttrib1sARB_adr := GetProcAddress('glVertexAttrib1sARB');
    private z_VertexAttrib1sARB_1 := GetProcOrNil&<procedure(index: UInt32; x: Int16)>(z_VertexAttrib1sARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1sARB(index: UInt32; x: Int16) :=
    z_VertexAttrib1sARB_1(index, x);
    
    private z_VertexAttrib1svARB_adr := GetProcAddress('glVertexAttrib1svARB');
    private z_VertexAttrib1svARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib1svARB_adr);
    private z_VertexAttrib1svARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(z_VertexAttrib1svARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1svARB(index: UInt32; v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib1svARB_2(index, v[0]) else
        z_VertexAttrib1svARB_2(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1svARB(index: UInt32; var v: Int16) :=
    z_VertexAttrib1svARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1svARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib1svARB_1(index, v);
    
    private z_VertexAttrib2dARB_adr := GetProcAddress('glVertexAttrib2dARB');
    private z_VertexAttrib2dARB_1 := GetProcOrNil&<procedure(index: UInt32; x: real; y: real)>(z_VertexAttrib2dARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dARB(index: UInt32; x: real; y: real) :=
    z_VertexAttrib2dARB_1(index, x, y);
    
    private z_VertexAttrib2dvARB_adr := GetProcAddress('glVertexAttrib2dvARB');
    private z_VertexAttrib2dvARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib2dvARB_adr);
    private z_VertexAttrib2dvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: real)>(z_VertexAttrib2dvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dvARB(index: UInt32; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib2dvARB_2(index, v[0]) else
        z_VertexAttrib2dvARB_2(index, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dvARB(index: UInt32; var v: real) :=
    z_VertexAttrib2dvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dvARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib2dvARB_1(index, v);
    
    private z_VertexAttrib2fARB_adr := GetProcAddress('glVertexAttrib2fARB');
    private z_VertexAttrib2fARB_1 := GetProcOrNil&<procedure(index: UInt32; x: single; y: single)>(z_VertexAttrib2fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fARB(index: UInt32; x: single; y: single) :=
    z_VertexAttrib2fARB_1(index, x, y);
    
    private z_VertexAttrib2fvARB_adr := GetProcAddress('glVertexAttrib2fvARB');
    private z_VertexAttrib2fvARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib2fvARB_adr);
    private z_VertexAttrib2fvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: single)>(z_VertexAttrib2fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fvARB(index: UInt32; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib2fvARB_2(index, v[0]) else
        z_VertexAttrib2fvARB_2(index, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fvARB(index: UInt32; var v: single) :=
    z_VertexAttrib2fvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fvARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib2fvARB_1(index, v);
    
    private z_VertexAttrib2sARB_adr := GetProcAddress('glVertexAttrib2sARB');
    private z_VertexAttrib2sARB_1 := GetProcOrNil&<procedure(index: UInt32; x: Int16; y: Int16)>(z_VertexAttrib2sARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2sARB(index: UInt32; x: Int16; y: Int16) :=
    z_VertexAttrib2sARB_1(index, x, y);
    
    private z_VertexAttrib2svARB_adr := GetProcAddress('glVertexAttrib2svARB');
    private z_VertexAttrib2svARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib2svARB_adr);
    private z_VertexAttrib2svARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(z_VertexAttrib2svARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2svARB(index: UInt32; v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib2svARB_2(index, v[0]) else
        z_VertexAttrib2svARB_2(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2svARB(index: UInt32; var v: Int16) :=
    z_VertexAttrib2svARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2svARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib2svARB_1(index, v);
    
    private z_VertexAttrib3dARB_adr := GetProcAddress('glVertexAttrib3dARB');
    private z_VertexAttrib3dARB_1 := GetProcOrNil&<procedure(index: UInt32; x: real; y: real; z: real)>(z_VertexAttrib3dARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dARB(index: UInt32; x: real; y: real; z: real) :=
    z_VertexAttrib3dARB_1(index, x, y, z);
    
    private z_VertexAttrib3dvARB_adr := GetProcAddress('glVertexAttrib3dvARB');
    private z_VertexAttrib3dvARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib3dvARB_adr);
    private z_VertexAttrib3dvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: real)>(z_VertexAttrib3dvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dvARB(index: UInt32; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib3dvARB_2(index, v[0]) else
        z_VertexAttrib3dvARB_2(index, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dvARB(index: UInt32; var v: real) :=
    z_VertexAttrib3dvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dvARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib3dvARB_1(index, v);
    
    private z_VertexAttrib3fARB_adr := GetProcAddress('glVertexAttrib3fARB');
    private z_VertexAttrib3fARB_1 := GetProcOrNil&<procedure(index: UInt32; x: single; y: single; z: single)>(z_VertexAttrib3fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fARB(index: UInt32; x: single; y: single; z: single) :=
    z_VertexAttrib3fARB_1(index, x, y, z);
    
    private z_VertexAttrib3fvARB_adr := GetProcAddress('glVertexAttrib3fvARB');
    private z_VertexAttrib3fvARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib3fvARB_adr);
    private z_VertexAttrib3fvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: single)>(z_VertexAttrib3fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fvARB(index: UInt32; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib3fvARB_2(index, v[0]) else
        z_VertexAttrib3fvARB_2(index, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fvARB(index: UInt32; var v: single) :=
    z_VertexAttrib3fvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fvARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib3fvARB_1(index, v);
    
    private z_VertexAttrib3sARB_adr := GetProcAddress('glVertexAttrib3sARB');
    private z_VertexAttrib3sARB_1 := GetProcOrNil&<procedure(index: UInt32; x: Int16; y: Int16; z: Int16)>(z_VertexAttrib3sARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3sARB(index: UInt32; x: Int16; y: Int16; z: Int16) :=
    z_VertexAttrib3sARB_1(index, x, y, z);
    
    private z_VertexAttrib3svARB_adr := GetProcAddress('glVertexAttrib3svARB');
    private z_VertexAttrib3svARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib3svARB_adr);
    private z_VertexAttrib3svARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(z_VertexAttrib3svARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3svARB(index: UInt32; v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib3svARB_2(index, v[0]) else
        z_VertexAttrib3svARB_2(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3svARB(index: UInt32; var v: Int16) :=
    z_VertexAttrib3svARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3svARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib3svARB_1(index, v);
    
    private z_VertexAttrib4NbvARB_adr := GetProcAddress('glVertexAttrib4NbvARB');
    private z_VertexAttrib4NbvARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4NbvARB_adr);
    private z_VertexAttrib4NbvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: SByte)>(z_VertexAttrib4NbvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NbvARB(index: UInt32; v: array of SByte);
    type PSByte=^SByte;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4NbvARB_2(index, v[0]) else
        z_VertexAttrib4NbvARB_2(index, PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NbvARB(index: UInt32; var v: SByte) :=
    z_VertexAttrib4NbvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NbvARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4NbvARB_1(index, v);
    
    private z_VertexAttrib4NivARB_adr := GetProcAddress('glVertexAttrib4NivARB');
    private z_VertexAttrib4NivARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4NivARB_adr);
    private z_VertexAttrib4NivARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(z_VertexAttrib4NivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NivARB(index: UInt32; v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4NivARB_2(index, v[0]) else
        z_VertexAttrib4NivARB_2(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NivARB(index: UInt32; var v: Int32) :=
    z_VertexAttrib4NivARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NivARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4NivARB_1(index, v);
    
    private z_VertexAttrib4NsvARB_adr := GetProcAddress('glVertexAttrib4NsvARB');
    private z_VertexAttrib4NsvARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4NsvARB_adr);
    private z_VertexAttrib4NsvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(z_VertexAttrib4NsvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NsvARB(index: UInt32; v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4NsvARB_2(index, v[0]) else
        z_VertexAttrib4NsvARB_2(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NsvARB(index: UInt32; var v: Int16) :=
    z_VertexAttrib4NsvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NsvARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4NsvARB_1(index, v);
    
    private z_VertexAttrib4NubARB_adr := GetProcAddress('glVertexAttrib4NubARB');
    private z_VertexAttrib4NubARB_1 := GetProcOrNil&<procedure(index: UInt32; x: Byte; y: Byte; z: Byte; w: Byte)>(z_VertexAttrib4NubARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NubARB(index: UInt32; x: Byte; y: Byte; z: Byte; w: Byte) :=
    z_VertexAttrib4NubARB_1(index, x, y, z, w);
    
    private z_VertexAttrib4NubvARB_adr := GetProcAddress('glVertexAttrib4NubvARB');
    private z_VertexAttrib4NubvARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4NubvARB_adr);
    private z_VertexAttrib4NubvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Byte)>(z_VertexAttrib4NubvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NubvARB(index: UInt32; v: array of Byte);
    type PByte=^Byte;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4NubvARB_2(index, v[0]) else
        z_VertexAttrib4NubvARB_2(index, PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NubvARB(index: UInt32; var v: Byte) :=
    z_VertexAttrib4NubvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NubvARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4NubvARB_1(index, v);
    
    private z_VertexAttrib4NuivARB_adr := GetProcAddress('glVertexAttrib4NuivARB');
    private z_VertexAttrib4NuivARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4NuivARB_adr);
    private z_VertexAttrib4NuivARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: UInt32)>(z_VertexAttrib4NuivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NuivARB(index: UInt32; v: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4NuivARB_2(index, v[0]) else
        z_VertexAttrib4NuivARB_2(index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NuivARB(index: UInt32; var v: UInt32) :=
    z_VertexAttrib4NuivARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NuivARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4NuivARB_1(index, v);
    
    private z_VertexAttrib4NusvARB_adr := GetProcAddress('glVertexAttrib4NusvARB');
    private z_VertexAttrib4NusvARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4NusvARB_adr);
    private z_VertexAttrib4NusvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: UInt16)>(z_VertexAttrib4NusvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NusvARB(index: UInt32; v: array of UInt16);
    type PUInt16=^UInt16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4NusvARB_2(index, v[0]) else
        z_VertexAttrib4NusvARB_2(index, PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NusvARB(index: UInt32; var v: UInt16) :=
    z_VertexAttrib4NusvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NusvARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4NusvARB_1(index, v);
    
    private z_VertexAttrib4bvARB_adr := GetProcAddress('glVertexAttrib4bvARB');
    private z_VertexAttrib4bvARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4bvARB_adr);
    private z_VertexAttrib4bvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: SByte)>(z_VertexAttrib4bvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4bvARB(index: UInt32; v: array of SByte);
    type PSByte=^SByte;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4bvARB_2(index, v[0]) else
        z_VertexAttrib4bvARB_2(index, PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4bvARB(index: UInt32; var v: SByte) :=
    z_VertexAttrib4bvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4bvARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4bvARB_1(index, v);
    
    private z_VertexAttrib4dARB_adr := GetProcAddress('glVertexAttrib4dARB');
    private z_VertexAttrib4dARB_1 := GetProcOrNil&<procedure(index: UInt32; x: real; y: real; z: real; w: real)>(z_VertexAttrib4dARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dARB(index: UInt32; x: real; y: real; z: real; w: real) :=
    z_VertexAttrib4dARB_1(index, x, y, z, w);
    
    private z_VertexAttrib4dvARB_adr := GetProcAddress('glVertexAttrib4dvARB');
    private z_VertexAttrib4dvARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4dvARB_adr);
    private z_VertexAttrib4dvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: real)>(z_VertexAttrib4dvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dvARB(index: UInt32; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4dvARB_2(index, v[0]) else
        z_VertexAttrib4dvARB_2(index, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dvARB(index: UInt32; var v: real) :=
    z_VertexAttrib4dvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dvARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4dvARB_1(index, v);
    
    private z_VertexAttrib4fARB_adr := GetProcAddress('glVertexAttrib4fARB');
    private z_VertexAttrib4fARB_1 := GetProcOrNil&<procedure(index: UInt32; x: single; y: single; z: single; w: single)>(z_VertexAttrib4fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fARB(index: UInt32; x: single; y: single; z: single; w: single) :=
    z_VertexAttrib4fARB_1(index, x, y, z, w);
    
    private z_VertexAttrib4fvARB_adr := GetProcAddress('glVertexAttrib4fvARB');
    private z_VertexAttrib4fvARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4fvARB_adr);
    private z_VertexAttrib4fvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: single)>(z_VertexAttrib4fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fvARB(index: UInt32; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4fvARB_2(index, v[0]) else
        z_VertexAttrib4fvARB_2(index, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fvARB(index: UInt32; var v: single) :=
    z_VertexAttrib4fvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fvARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4fvARB_1(index, v);
    
    private z_VertexAttrib4ivARB_adr := GetProcAddress('glVertexAttrib4ivARB');
    private z_VertexAttrib4ivARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4ivARB_adr);
    private z_VertexAttrib4ivARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(z_VertexAttrib4ivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ivARB(index: UInt32; v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4ivARB_2(index, v[0]) else
        z_VertexAttrib4ivARB_2(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ivARB(index: UInt32; var v: Int32) :=
    z_VertexAttrib4ivARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ivARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4ivARB_1(index, v);
    
    private z_VertexAttrib4sARB_adr := GetProcAddress('glVertexAttrib4sARB');
    private z_VertexAttrib4sARB_1 := GetProcOrNil&<procedure(index: UInt32; x: Int16; y: Int16; z: Int16; w: Int16)>(z_VertexAttrib4sARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4sARB(index: UInt32; x: Int16; y: Int16; z: Int16; w: Int16) :=
    z_VertexAttrib4sARB_1(index, x, y, z, w);
    
    private z_VertexAttrib4svARB_adr := GetProcAddress('glVertexAttrib4svARB');
    private z_VertexAttrib4svARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4svARB_adr);
    private z_VertexAttrib4svARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(z_VertexAttrib4svARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4svARB(index: UInt32; v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4svARB_2(index, v[0]) else
        z_VertexAttrib4svARB_2(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4svARB(index: UInt32; var v: Int16) :=
    z_VertexAttrib4svARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4svARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4svARB_1(index, v);
    
    private z_VertexAttrib4ubvARB_adr := GetProcAddress('glVertexAttrib4ubvARB');
    private z_VertexAttrib4ubvARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4ubvARB_adr);
    private z_VertexAttrib4ubvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Byte)>(z_VertexAttrib4ubvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubvARB(index: UInt32; v: array of Byte);
    type PByte=^Byte;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4ubvARB_2(index, v[0]) else
        z_VertexAttrib4ubvARB_2(index, PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubvARB(index: UInt32; var v: Byte) :=
    z_VertexAttrib4ubvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubvARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4ubvARB_1(index, v);
    
    private z_VertexAttrib4uivARB_adr := GetProcAddress('glVertexAttrib4uivARB');
    private z_VertexAttrib4uivARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4uivARB_adr);
    private z_VertexAttrib4uivARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: UInt32)>(z_VertexAttrib4uivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4uivARB(index: UInt32; v: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4uivARB_2(index, v[0]) else
        z_VertexAttrib4uivARB_2(index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4uivARB(index: UInt32; var v: UInt32) :=
    z_VertexAttrib4uivARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4uivARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4uivARB_1(index, v);
    
    private z_VertexAttrib4usvARB_adr := GetProcAddress('glVertexAttrib4usvARB');
    private z_VertexAttrib4usvARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4usvARB_adr);
    private z_VertexAttrib4usvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: UInt16)>(z_VertexAttrib4usvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4usvARB(index: UInt32; v: array of UInt16);
    type PUInt16=^UInt16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4usvARB_2(index, v[0]) else
        z_VertexAttrib4usvARB_2(index, PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4usvARB(index: UInt32; var v: UInt16) :=
    z_VertexAttrib4usvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4usvARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4usvARB_1(index, v);
    
    private z_VertexAttribPointerARB_adr := GetProcAddress('glVertexAttribPointerARB');
    private z_VertexAttribPointerARB_1 := GetProcOrNil&<procedure(index: UInt32; size: Int32; &type: VertexAttribPointerType; normalized: boolean; stride: Int32; pointer: IntPtr)>(z_VertexAttribPointerARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribPointerARB(index: UInt32; size: Int32; &type: VertexAttribPointerType; normalized: boolean; stride: Int32; pointer: IntPtr) :=
    z_VertexAttribPointerARB_1(index, size, &type, normalized, stride, pointer);
    
    private z_EnableVertexAttribArrayARB_adr := GetProcAddress('glEnableVertexAttribArrayARB');
    private z_EnableVertexAttribArrayARB_1 := GetProcOrNil&<procedure(index: UInt32)>(z_EnableVertexAttribArrayARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableVertexAttribArrayARB(index: UInt32) :=
    z_EnableVertexAttribArrayARB_1(index);
    
    private z_DisableVertexAttribArrayARB_adr := GetProcAddress('glDisableVertexAttribArrayARB');
    private z_DisableVertexAttribArrayARB_1 := GetProcOrNil&<procedure(index: UInt32)>(z_DisableVertexAttribArrayARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableVertexAttribArrayARB(index: UInt32) :=
    z_DisableVertexAttribArrayARB_1(index);
    
    private z_ProgramStringARB_adr := GetProcAddress('glProgramStringARB');
    private z_ProgramStringARB_1 := GetProcOrNil&<procedure(target: ProgramTarget; format: ProgramFormat; len: Int32; string: IntPtr)>(z_ProgramStringARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramStringARB(target: ProgramTarget; format: ProgramFormat; len: Int32; string: IntPtr) :=
    z_ProgramStringARB_1(target, format, len, string);
    
    private z_BindProgramARB_adr := GetProcAddress('glBindProgramARB');
    private z_BindProgramARB_1 := GetProcOrNil&<procedure(target: ProgramTarget; &program: gl_program)>(z_BindProgramARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindProgramARB(target: ProgramTarget; &program: gl_program) :=
    z_BindProgramARB_1(target, &program);
    
    private z_DeleteProgramsARB_adr := GetProcAddress('glDeleteProgramsARB');
    private z_DeleteProgramsARB_1 := GetProcOrNil&<procedure(n: Int32; programs: IntPtr)>(z_DeleteProgramsARB_adr);
    private z_DeleteProgramsARB_2 := GetProcOrNil&<procedure(n: Int32; var programs: gl_program)>(z_DeleteProgramsARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramsARB(n: Int32; programs: array of gl_program);
    type Pgl_program=^gl_program;
    begin
      if (programs<>nil) and (programs.Length<>0) then
        z_DeleteProgramsARB_2(n, programs[0]) else
        z_DeleteProgramsARB_2(n, Pgl_program(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramsARB(n: Int32; var programs: gl_program) :=
    z_DeleteProgramsARB_2(n, programs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramsARB(n: Int32; programs: IntPtr) :=
    z_DeleteProgramsARB_1(n, programs);
    
    private z_GenProgramsARB_adr := GetProcAddress('glGenProgramsARB');
    private z_GenProgramsARB_1 := GetProcOrNil&<procedure(n: Int32; programs: IntPtr)>(z_GenProgramsARB_adr);
    private z_GenProgramsARB_2 := GetProcOrNil&<procedure(n: Int32; var programs: gl_program)>(z_GenProgramsARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramsARB(n: Int32; programs: array of gl_program);
    type Pgl_program=^gl_program;
    begin
      if (programs<>nil) and (programs.Length<>0) then
        z_GenProgramsARB_2(n, programs[0]) else
        z_GenProgramsARB_2(n, Pgl_program(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramsARB(n: Int32; var programs: gl_program) :=
    z_GenProgramsARB_2(n, programs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramsARB(n: Int32; programs: IntPtr) :=
    z_GenProgramsARB_1(n, programs);
    
    private z_ProgramEnvParameter4dARB_adr := GetProcAddress('glProgramEnvParameter4dARB');
    private z_ProgramEnvParameter4dARB_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; x: real; y: real; z: real; w: real)>(z_ProgramEnvParameter4dARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4dARB(target: ProgramTarget; index: UInt32; x: real; y: real; z: real; w: real) :=
    z_ProgramEnvParameter4dARB_1(target, index, x, y, z, w);
    
    private z_ProgramEnvParameter4dvARB_adr := GetProcAddress('glProgramEnvParameter4dvARB');
    private z_ProgramEnvParameter4dvARB_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; &params: IntPtr)>(z_ProgramEnvParameter4dvARB_adr);
    private z_ProgramEnvParameter4dvARB_2 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; var &params: real)>(z_ProgramEnvParameter4dvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4dvARB(target: ProgramTarget; index: UInt32; &params: array of real);
    type Preal=^real;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_ProgramEnvParameter4dvARB_2(target, index, &params[0]) else
        z_ProgramEnvParameter4dvARB_2(target, index, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4dvARB(target: ProgramTarget; index: UInt32; var &params: real) :=
    z_ProgramEnvParameter4dvARB_2(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4dvARB(target: ProgramTarget; index: UInt32; &params: IntPtr) :=
    z_ProgramEnvParameter4dvARB_1(target, index, &params);
    
    private z_ProgramEnvParameter4fARB_adr := GetProcAddress('glProgramEnvParameter4fARB');
    private z_ProgramEnvParameter4fARB_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; x: single; y: single; z: single; w: single)>(z_ProgramEnvParameter4fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4fARB(target: ProgramTarget; index: UInt32; x: single; y: single; z: single; w: single) :=
    z_ProgramEnvParameter4fARB_1(target, index, x, y, z, w);
    
    private z_ProgramEnvParameter4fvARB_adr := GetProcAddress('glProgramEnvParameter4fvARB');
    private z_ProgramEnvParameter4fvARB_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; &params: IntPtr)>(z_ProgramEnvParameter4fvARB_adr);
    private z_ProgramEnvParameter4fvARB_2 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; var &params: single)>(z_ProgramEnvParameter4fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4fvARB(target: ProgramTarget; index: UInt32; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_ProgramEnvParameter4fvARB_2(target, index, &params[0]) else
        z_ProgramEnvParameter4fvARB_2(target, index, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4fvARB(target: ProgramTarget; index: UInt32; var &params: single) :=
    z_ProgramEnvParameter4fvARB_2(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4fvARB(target: ProgramTarget; index: UInt32; &params: IntPtr) :=
    z_ProgramEnvParameter4fvARB_1(target, index, &params);
    
    private z_ProgramLocalParameter4dARB_adr := GetProcAddress('glProgramLocalParameter4dARB');
    private z_ProgramLocalParameter4dARB_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; x: real; y: real; z: real; w: real)>(z_ProgramLocalParameter4dARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4dARB(target: ProgramTarget; index: UInt32; x: real; y: real; z: real; w: real) :=
    z_ProgramLocalParameter4dARB_1(target, index, x, y, z, w);
    
    private z_ProgramLocalParameter4dvARB_adr := GetProcAddress('glProgramLocalParameter4dvARB');
    private z_ProgramLocalParameter4dvARB_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; &params: IntPtr)>(z_ProgramLocalParameter4dvARB_adr);
    private z_ProgramLocalParameter4dvARB_2 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; var &params: real)>(z_ProgramLocalParameter4dvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4dvARB(target: ProgramTarget; index: UInt32; &params: array of real);
    type Preal=^real;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_ProgramLocalParameter4dvARB_2(target, index, &params[0]) else
        z_ProgramLocalParameter4dvARB_2(target, index, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4dvARB(target: ProgramTarget; index: UInt32; var &params: real) :=
    z_ProgramLocalParameter4dvARB_2(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4dvARB(target: ProgramTarget; index: UInt32; &params: IntPtr) :=
    z_ProgramLocalParameter4dvARB_1(target, index, &params);
    
    private z_ProgramLocalParameter4fARB_adr := GetProcAddress('glProgramLocalParameter4fARB');
    private z_ProgramLocalParameter4fARB_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; x: single; y: single; z: single; w: single)>(z_ProgramLocalParameter4fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4fARB(target: ProgramTarget; index: UInt32; x: single; y: single; z: single; w: single) :=
    z_ProgramLocalParameter4fARB_1(target, index, x, y, z, w);
    
    private z_ProgramLocalParameter4fvARB_adr := GetProcAddress('glProgramLocalParameter4fvARB');
    private z_ProgramLocalParameter4fvARB_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; &params: IntPtr)>(z_ProgramLocalParameter4fvARB_adr);
    private z_ProgramLocalParameter4fvARB_2 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; var &params: single)>(z_ProgramLocalParameter4fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4fvARB(target: ProgramTarget; index: UInt32; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_ProgramLocalParameter4fvARB_2(target, index, &params[0]) else
        z_ProgramLocalParameter4fvARB_2(target, index, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4fvARB(target: ProgramTarget; index: UInt32; var &params: single) :=
    z_ProgramLocalParameter4fvARB_2(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4fvARB(target: ProgramTarget; index: UInt32; &params: IntPtr) :=
    z_ProgramLocalParameter4fvARB_1(target, index, &params);
    
    private z_GetProgramEnvParameterdvARB_adr := GetProcAddress('glGetProgramEnvParameterdvARB');
    private z_GetProgramEnvParameterdvARB_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; &params: IntPtr)>(z_GetProgramEnvParameterdvARB_adr);
    private z_GetProgramEnvParameterdvARB_2 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; var &params: real)>(z_GetProgramEnvParameterdvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterdvARB(target: ProgramTarget; index: UInt32; var &params: real) :=
    z_GetProgramEnvParameterdvARB_2(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterdvARB(target: ProgramTarget; index: UInt32; &params: IntPtr) :=
    z_GetProgramEnvParameterdvARB_1(target, index, &params);
    
    private z_GetProgramEnvParameterfvARB_adr := GetProcAddress('glGetProgramEnvParameterfvARB');
    private z_GetProgramEnvParameterfvARB_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; &params: IntPtr)>(z_GetProgramEnvParameterfvARB_adr);
    private z_GetProgramEnvParameterfvARB_2 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; var &params: single)>(z_GetProgramEnvParameterfvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterfvARB(target: ProgramTarget; index: UInt32; var &params: single) :=
    z_GetProgramEnvParameterfvARB_2(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterfvARB(target: ProgramTarget; index: UInt32; &params: IntPtr) :=
    z_GetProgramEnvParameterfvARB_1(target, index, &params);
    
    private z_GetProgramLocalParameterdvARB_adr := GetProcAddress('glGetProgramLocalParameterdvARB');
    private z_GetProgramLocalParameterdvARB_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; &params: IntPtr)>(z_GetProgramLocalParameterdvARB_adr);
    private z_GetProgramLocalParameterdvARB_2 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; var &params: real)>(z_GetProgramLocalParameterdvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterdvARB(target: ProgramTarget; index: UInt32; var &params: real) :=
    z_GetProgramLocalParameterdvARB_2(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterdvARB(target: ProgramTarget; index: UInt32; &params: IntPtr) :=
    z_GetProgramLocalParameterdvARB_1(target, index, &params);
    
    private z_GetProgramLocalParameterfvARB_adr := GetProcAddress('glGetProgramLocalParameterfvARB');
    private z_GetProgramLocalParameterfvARB_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; &params: IntPtr)>(z_GetProgramLocalParameterfvARB_adr);
    private z_GetProgramLocalParameterfvARB_2 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; var &params: single)>(z_GetProgramLocalParameterfvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterfvARB(target: ProgramTarget; index: UInt32; var &params: single) :=
    z_GetProgramLocalParameterfvARB_2(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterfvARB(target: ProgramTarget; index: UInt32; &params: IntPtr) :=
    z_GetProgramLocalParameterfvARB_1(target, index, &params);
    
    private z_GetProgramivARB_adr := GetProcAddress('glGetProgramivARB');
    private z_GetProgramivARB_1 := GetProcOrNil&<procedure(target: ProgramTarget; pname: ProgramProperty; &params: IntPtr)>(z_GetProgramivARB_adr);
    private z_GetProgramivARB_2 := GetProcOrNil&<procedure(target: ProgramTarget; pname: ProgramProperty; var &params: Int32)>(z_GetProgramivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramivARB(target: ProgramTarget; pname: ProgramProperty; var &params: Int32) :=
    z_GetProgramivARB_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramivARB(target: ProgramTarget; pname: ProgramProperty; &params: IntPtr) :=
    z_GetProgramivARB_1(target, pname, &params);
    
    private z_GetProgramStringARB_adr := GetProcAddress('glGetProgramStringARB');
    private z_GetProgramStringARB_1 := GetProcOrNil&<procedure(target: ProgramTarget; pname: ProgramStringProperty; string: IntPtr)>(z_GetProgramStringARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramStringARB(target: ProgramTarget; pname: ProgramStringProperty; string: IntPtr) :=
    z_GetProgramStringARB_1(target, pname, string);
    
    private z_GetVertexAttribdvARB_adr := GetProcAddress('glGetVertexAttribdvARB');
    private z_GetVertexAttribdvARB_1 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribProperty; &params: IntPtr)>(z_GetVertexAttribdvARB_adr);
    private z_GetVertexAttribdvARB_2 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribProperty; var &params: real)>(z_GetVertexAttribdvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribdvARB(index: UInt32; pname: VertexAttribProperty; var &params: real) :=
    z_GetVertexAttribdvARB_2(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribdvARB(index: UInt32; pname: VertexAttribProperty; &params: IntPtr) :=
    z_GetVertexAttribdvARB_1(index, pname, &params);
    
    private z_GetVertexAttribfvARB_adr := GetProcAddress('glGetVertexAttribfvARB');
    private z_GetVertexAttribfvARB_1 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribProperty; &params: IntPtr)>(z_GetVertexAttribfvARB_adr);
    private z_GetVertexAttribfvARB_2 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribProperty; var &params: single)>(z_GetVertexAttribfvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribfvARB(index: UInt32; pname: VertexAttribProperty; var &params: single) :=
    z_GetVertexAttribfvARB_2(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribfvARB(index: UInt32; pname: VertexAttribProperty; &params: IntPtr) :=
    z_GetVertexAttribfvARB_1(index, pname, &params);
    
    private z_GetVertexAttribivARB_adr := GetProcAddress('glGetVertexAttribivARB');
    private z_GetVertexAttribivARB_1 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribProperty; &params: IntPtr)>(z_GetVertexAttribivARB_adr);
    private z_GetVertexAttribivARB_2 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribProperty; var &params: Int32)>(z_GetVertexAttribivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribivARB(index: UInt32; pname: VertexAttribProperty; var &params: Int32) :=
    z_GetVertexAttribivARB_2(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribivARB(index: UInt32; pname: VertexAttribProperty; &params: IntPtr) :=
    z_GetVertexAttribivARB_1(index, pname, &params);
    
    private z_GetVertexAttribPointervARB_adr := GetProcAddress('glGetVertexAttribPointervARB');
    private z_GetVertexAttribPointervARB_1 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribPointerProperty; _pointer: pointer)>(z_GetVertexAttribPointervARB_adr);
    private z_GetVertexAttribPointervARB_2 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribPointerProperty; var _pointer: IntPtr)>(z_GetVertexAttribPointervARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribPointervARB(index: UInt32; pname: VertexAttribPointerProperty; var _pointer: IntPtr) :=
    z_GetVertexAttribPointervARB_2(index, pname, _pointer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribPointervARB(index: UInt32; pname: VertexAttribPointerProperty; _pointer: pointer) :=
    z_GetVertexAttribPointervARB_1(index, pname, _pointer);
    
    private z_IsProgramARB_adr := GetProcAddress('glIsProgramARB');
    private z_IsProgramARB_1 := GetProcOrNil&<function(&program: gl_program): boolean>(z_IsProgramARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsProgramARB(&program: gl_program): boolean :=
    z_IsProgramARB_1(&program);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glVertexShaderARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_vertex_shader';
    
    private z_VertexAttrib1fARB_adr := GetProcAddress('glVertexAttrib1fARB');
    private z_VertexAttrib1fARB_1 := GetProcOrNil&<procedure(index: UInt32; x: single)>(z_VertexAttrib1fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fARB(index: UInt32; x: single) :=
    z_VertexAttrib1fARB_1(index, x);
    
    private z_VertexAttrib1sARB_adr := GetProcAddress('glVertexAttrib1sARB');
    private z_VertexAttrib1sARB_1 := GetProcOrNil&<procedure(index: UInt32; x: Int16)>(z_VertexAttrib1sARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1sARB(index: UInt32; x: Int16) :=
    z_VertexAttrib1sARB_1(index, x);
    
    private z_VertexAttrib1dARB_adr := GetProcAddress('glVertexAttrib1dARB');
    private z_VertexAttrib1dARB_1 := GetProcOrNil&<procedure(index: UInt32; x: real)>(z_VertexAttrib1dARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dARB(index: UInt32; x: real) :=
    z_VertexAttrib1dARB_1(index, x);
    
    private z_VertexAttrib2fARB_adr := GetProcAddress('glVertexAttrib2fARB');
    private z_VertexAttrib2fARB_1 := GetProcOrNil&<procedure(index: UInt32; x: single; y: single)>(z_VertexAttrib2fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fARB(index: UInt32; x: single; y: single) :=
    z_VertexAttrib2fARB_1(index, x, y);
    
    private z_VertexAttrib2sARB_adr := GetProcAddress('glVertexAttrib2sARB');
    private z_VertexAttrib2sARB_1 := GetProcOrNil&<procedure(index: UInt32; x: Int16; y: Int16)>(z_VertexAttrib2sARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2sARB(index: UInt32; x: Int16; y: Int16) :=
    z_VertexAttrib2sARB_1(index, x, y);
    
    private z_VertexAttrib2dARB_adr := GetProcAddress('glVertexAttrib2dARB');
    private z_VertexAttrib2dARB_1 := GetProcOrNil&<procedure(index: UInt32; x: real; y: real)>(z_VertexAttrib2dARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dARB(index: UInt32; x: real; y: real) :=
    z_VertexAttrib2dARB_1(index, x, y);
    
    private z_VertexAttrib3fARB_adr := GetProcAddress('glVertexAttrib3fARB');
    private z_VertexAttrib3fARB_1 := GetProcOrNil&<procedure(index: UInt32; x: single; y: single; z: single)>(z_VertexAttrib3fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fARB(index: UInt32; x: single; y: single; z: single) :=
    z_VertexAttrib3fARB_1(index, x, y, z);
    
    private z_VertexAttrib3sARB_adr := GetProcAddress('glVertexAttrib3sARB');
    private z_VertexAttrib3sARB_1 := GetProcOrNil&<procedure(index: UInt32; x: Int16; y: Int16; z: Int16)>(z_VertexAttrib3sARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3sARB(index: UInt32; x: Int16; y: Int16; z: Int16) :=
    z_VertexAttrib3sARB_1(index, x, y, z);
    
    private z_VertexAttrib3dARB_adr := GetProcAddress('glVertexAttrib3dARB');
    private z_VertexAttrib3dARB_1 := GetProcOrNil&<procedure(index: UInt32; x: real; y: real; z: real)>(z_VertexAttrib3dARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dARB(index: UInt32; x: real; y: real; z: real) :=
    z_VertexAttrib3dARB_1(index, x, y, z);
    
    private z_VertexAttrib4fARB_adr := GetProcAddress('glVertexAttrib4fARB');
    private z_VertexAttrib4fARB_1 := GetProcOrNil&<procedure(index: UInt32; x: single; y: single; z: single; w: single)>(z_VertexAttrib4fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fARB(index: UInt32; x: single; y: single; z: single; w: single) :=
    z_VertexAttrib4fARB_1(index, x, y, z, w);
    
    private z_VertexAttrib4sARB_adr := GetProcAddress('glVertexAttrib4sARB');
    private z_VertexAttrib4sARB_1 := GetProcOrNil&<procedure(index: UInt32; x: Int16; y: Int16; z: Int16; w: Int16)>(z_VertexAttrib4sARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4sARB(index: UInt32; x: Int16; y: Int16; z: Int16; w: Int16) :=
    z_VertexAttrib4sARB_1(index, x, y, z, w);
    
    private z_VertexAttrib4dARB_adr := GetProcAddress('glVertexAttrib4dARB');
    private z_VertexAttrib4dARB_1 := GetProcOrNil&<procedure(index: UInt32; x: real; y: real; z: real; w: real)>(z_VertexAttrib4dARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dARB(index: UInt32; x: real; y: real; z: real; w: real) :=
    z_VertexAttrib4dARB_1(index, x, y, z, w);
    
    private z_VertexAttrib4NubARB_adr := GetProcAddress('glVertexAttrib4NubARB');
    private z_VertexAttrib4NubARB_1 := GetProcOrNil&<procedure(index: UInt32; x: Byte; y: Byte; z: Byte; w: Byte)>(z_VertexAttrib4NubARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NubARB(index: UInt32; x: Byte; y: Byte; z: Byte; w: Byte) :=
    z_VertexAttrib4NubARB_1(index, x, y, z, w);
    
    private z_VertexAttrib1fvARB_adr := GetProcAddress('glVertexAttrib1fvARB');
    private z_VertexAttrib1fvARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib1fvARB_adr);
    private z_VertexAttrib1fvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: single)>(z_VertexAttrib1fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fvARB(index: UInt32; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib1fvARB_2(index, v[0]) else
        z_VertexAttrib1fvARB_2(index, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fvARB(index: UInt32; var v: single) :=
    z_VertexAttrib1fvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fvARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib1fvARB_1(index, v);
    
    private z_VertexAttrib1svARB_adr := GetProcAddress('glVertexAttrib1svARB');
    private z_VertexAttrib1svARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib1svARB_adr);
    private z_VertexAttrib1svARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(z_VertexAttrib1svARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1svARB(index: UInt32; v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib1svARB_2(index, v[0]) else
        z_VertexAttrib1svARB_2(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1svARB(index: UInt32; var v: Int16) :=
    z_VertexAttrib1svARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1svARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib1svARB_1(index, v);
    
    private z_VertexAttrib1dvARB_adr := GetProcAddress('glVertexAttrib1dvARB');
    private z_VertexAttrib1dvARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib1dvARB_adr);
    private z_VertexAttrib1dvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: real)>(z_VertexAttrib1dvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dvARB(index: UInt32; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib1dvARB_2(index, v[0]) else
        z_VertexAttrib1dvARB_2(index, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dvARB(index: UInt32; var v: real) :=
    z_VertexAttrib1dvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dvARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib1dvARB_1(index, v);
    
    private z_VertexAttrib2fvARB_adr := GetProcAddress('glVertexAttrib2fvARB');
    private z_VertexAttrib2fvARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib2fvARB_adr);
    private z_VertexAttrib2fvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: single)>(z_VertexAttrib2fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fvARB(index: UInt32; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib2fvARB_2(index, v[0]) else
        z_VertexAttrib2fvARB_2(index, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fvARB(index: UInt32; var v: single) :=
    z_VertexAttrib2fvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fvARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib2fvARB_1(index, v);
    
    private z_VertexAttrib2svARB_adr := GetProcAddress('glVertexAttrib2svARB');
    private z_VertexAttrib2svARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib2svARB_adr);
    private z_VertexAttrib2svARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(z_VertexAttrib2svARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2svARB(index: UInt32; v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib2svARB_2(index, v[0]) else
        z_VertexAttrib2svARB_2(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2svARB(index: UInt32; var v: Int16) :=
    z_VertexAttrib2svARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2svARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib2svARB_1(index, v);
    
    private z_VertexAttrib2dvARB_adr := GetProcAddress('glVertexAttrib2dvARB');
    private z_VertexAttrib2dvARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib2dvARB_adr);
    private z_VertexAttrib2dvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: real)>(z_VertexAttrib2dvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dvARB(index: UInt32; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib2dvARB_2(index, v[0]) else
        z_VertexAttrib2dvARB_2(index, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dvARB(index: UInt32; var v: real) :=
    z_VertexAttrib2dvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dvARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib2dvARB_1(index, v);
    
    private z_VertexAttrib3fvARB_adr := GetProcAddress('glVertexAttrib3fvARB');
    private z_VertexAttrib3fvARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib3fvARB_adr);
    private z_VertexAttrib3fvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: single)>(z_VertexAttrib3fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fvARB(index: UInt32; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib3fvARB_2(index, v[0]) else
        z_VertexAttrib3fvARB_2(index, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fvARB(index: UInt32; var v: single) :=
    z_VertexAttrib3fvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fvARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib3fvARB_1(index, v);
    
    private z_VertexAttrib3svARB_adr := GetProcAddress('glVertexAttrib3svARB');
    private z_VertexAttrib3svARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib3svARB_adr);
    private z_VertexAttrib3svARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(z_VertexAttrib3svARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3svARB(index: UInt32; v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib3svARB_2(index, v[0]) else
        z_VertexAttrib3svARB_2(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3svARB(index: UInt32; var v: Int16) :=
    z_VertexAttrib3svARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3svARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib3svARB_1(index, v);
    
    private z_VertexAttrib3dvARB_adr := GetProcAddress('glVertexAttrib3dvARB');
    private z_VertexAttrib3dvARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib3dvARB_adr);
    private z_VertexAttrib3dvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: real)>(z_VertexAttrib3dvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dvARB(index: UInt32; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib3dvARB_2(index, v[0]) else
        z_VertexAttrib3dvARB_2(index, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dvARB(index: UInt32; var v: real) :=
    z_VertexAttrib3dvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dvARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib3dvARB_1(index, v);
    
    private z_VertexAttrib4fvARB_adr := GetProcAddress('glVertexAttrib4fvARB');
    private z_VertexAttrib4fvARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4fvARB_adr);
    private z_VertexAttrib4fvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: single)>(z_VertexAttrib4fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fvARB(index: UInt32; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4fvARB_2(index, v[0]) else
        z_VertexAttrib4fvARB_2(index, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fvARB(index: UInt32; var v: single) :=
    z_VertexAttrib4fvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fvARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4fvARB_1(index, v);
    
    private z_VertexAttrib4svARB_adr := GetProcAddress('glVertexAttrib4svARB');
    private z_VertexAttrib4svARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4svARB_adr);
    private z_VertexAttrib4svARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(z_VertexAttrib4svARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4svARB(index: UInt32; v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4svARB_2(index, v[0]) else
        z_VertexAttrib4svARB_2(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4svARB(index: UInt32; var v: Int16) :=
    z_VertexAttrib4svARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4svARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4svARB_1(index, v);
    
    private z_VertexAttrib4dvARB_adr := GetProcAddress('glVertexAttrib4dvARB');
    private z_VertexAttrib4dvARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4dvARB_adr);
    private z_VertexAttrib4dvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: real)>(z_VertexAttrib4dvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dvARB(index: UInt32; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4dvARB_2(index, v[0]) else
        z_VertexAttrib4dvARB_2(index, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dvARB(index: UInt32; var v: real) :=
    z_VertexAttrib4dvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dvARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4dvARB_1(index, v);
    
    private z_VertexAttrib4ivARB_adr := GetProcAddress('glVertexAttrib4ivARB');
    private z_VertexAttrib4ivARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4ivARB_adr);
    private z_VertexAttrib4ivARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(z_VertexAttrib4ivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ivARB(index: UInt32; v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4ivARB_2(index, v[0]) else
        z_VertexAttrib4ivARB_2(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ivARB(index: UInt32; var v: Int32) :=
    z_VertexAttrib4ivARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ivARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4ivARB_1(index, v);
    
    private z_VertexAttrib4bvARB_adr := GetProcAddress('glVertexAttrib4bvARB');
    private z_VertexAttrib4bvARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4bvARB_adr);
    private z_VertexAttrib4bvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: SByte)>(z_VertexAttrib4bvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4bvARB(index: UInt32; v: array of SByte);
    type PSByte=^SByte;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4bvARB_2(index, v[0]) else
        z_VertexAttrib4bvARB_2(index, PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4bvARB(index: UInt32; var v: SByte) :=
    z_VertexAttrib4bvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4bvARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4bvARB_1(index, v);
    
    private z_VertexAttrib4ubvARB_adr := GetProcAddress('glVertexAttrib4ubvARB');
    private z_VertexAttrib4ubvARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4ubvARB_adr);
    private z_VertexAttrib4ubvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Byte)>(z_VertexAttrib4ubvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubvARB(index: UInt32; v: array of Byte);
    type PByte=^Byte;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4ubvARB_2(index, v[0]) else
        z_VertexAttrib4ubvARB_2(index, PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubvARB(index: UInt32; var v: Byte) :=
    z_VertexAttrib4ubvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubvARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4ubvARB_1(index, v);
    
    private z_VertexAttrib4usvARB_adr := GetProcAddress('glVertexAttrib4usvARB');
    private z_VertexAttrib4usvARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4usvARB_adr);
    private z_VertexAttrib4usvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: UInt16)>(z_VertexAttrib4usvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4usvARB(index: UInt32; v: array of UInt16);
    type PUInt16=^UInt16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4usvARB_2(index, v[0]) else
        z_VertexAttrib4usvARB_2(index, PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4usvARB(index: UInt32; var v: UInt16) :=
    z_VertexAttrib4usvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4usvARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4usvARB_1(index, v);
    
    private z_VertexAttrib4uivARB_adr := GetProcAddress('glVertexAttrib4uivARB');
    private z_VertexAttrib4uivARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4uivARB_adr);
    private z_VertexAttrib4uivARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: UInt32)>(z_VertexAttrib4uivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4uivARB(index: UInt32; v: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4uivARB_2(index, v[0]) else
        z_VertexAttrib4uivARB_2(index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4uivARB(index: UInt32; var v: UInt32) :=
    z_VertexAttrib4uivARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4uivARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4uivARB_1(index, v);
    
    private z_VertexAttrib4NbvARB_adr := GetProcAddress('glVertexAttrib4NbvARB');
    private z_VertexAttrib4NbvARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4NbvARB_adr);
    private z_VertexAttrib4NbvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: SByte)>(z_VertexAttrib4NbvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NbvARB(index: UInt32; v: array of SByte);
    type PSByte=^SByte;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4NbvARB_2(index, v[0]) else
        z_VertexAttrib4NbvARB_2(index, PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NbvARB(index: UInt32; var v: SByte) :=
    z_VertexAttrib4NbvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NbvARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4NbvARB_1(index, v);
    
    private z_VertexAttrib4NsvARB_adr := GetProcAddress('glVertexAttrib4NsvARB');
    private z_VertexAttrib4NsvARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4NsvARB_adr);
    private z_VertexAttrib4NsvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(z_VertexAttrib4NsvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NsvARB(index: UInt32; v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4NsvARB_2(index, v[0]) else
        z_VertexAttrib4NsvARB_2(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NsvARB(index: UInt32; var v: Int16) :=
    z_VertexAttrib4NsvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NsvARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4NsvARB_1(index, v);
    
    private z_VertexAttrib4NivARB_adr := GetProcAddress('glVertexAttrib4NivARB');
    private z_VertexAttrib4NivARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4NivARB_adr);
    private z_VertexAttrib4NivARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(z_VertexAttrib4NivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NivARB(index: UInt32; v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4NivARB_2(index, v[0]) else
        z_VertexAttrib4NivARB_2(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NivARB(index: UInt32; var v: Int32) :=
    z_VertexAttrib4NivARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NivARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4NivARB_1(index, v);
    
    private z_VertexAttrib4NubvARB_adr := GetProcAddress('glVertexAttrib4NubvARB');
    private z_VertexAttrib4NubvARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4NubvARB_adr);
    private z_VertexAttrib4NubvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: Byte)>(z_VertexAttrib4NubvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NubvARB(index: UInt32; v: array of Byte);
    type PByte=^Byte;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4NubvARB_2(index, v[0]) else
        z_VertexAttrib4NubvARB_2(index, PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NubvARB(index: UInt32; var v: Byte) :=
    z_VertexAttrib4NubvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NubvARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4NubvARB_1(index, v);
    
    private z_VertexAttrib4NusvARB_adr := GetProcAddress('glVertexAttrib4NusvARB');
    private z_VertexAttrib4NusvARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4NusvARB_adr);
    private z_VertexAttrib4NusvARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: UInt16)>(z_VertexAttrib4NusvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NusvARB(index: UInt32; v: array of UInt16);
    type PUInt16=^UInt16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4NusvARB_2(index, v[0]) else
        z_VertexAttrib4NusvARB_2(index, PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NusvARB(index: UInt32; var v: UInt16) :=
    z_VertexAttrib4NusvARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NusvARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4NusvARB_1(index, v);
    
    private z_VertexAttrib4NuivARB_adr := GetProcAddress('glVertexAttrib4NuivARB');
    private z_VertexAttrib4NuivARB_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4NuivARB_adr);
    private z_VertexAttrib4NuivARB_2 := GetProcOrNil&<procedure(index: UInt32; var v: UInt32)>(z_VertexAttrib4NuivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NuivARB(index: UInt32; v: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4NuivARB_2(index, v[0]) else
        z_VertexAttrib4NuivARB_2(index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NuivARB(index: UInt32; var v: UInt32) :=
    z_VertexAttrib4NuivARB_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NuivARB(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4NuivARB_1(index, v);
    
    private z_VertexAttribPointerARB_adr := GetProcAddress('glVertexAttribPointerARB');
    private z_VertexAttribPointerARB_1 := GetProcOrNil&<procedure(index: UInt32; size: Int32; &type: VertexAttribPointerType; normalized: boolean; stride: Int32; pointer: IntPtr)>(z_VertexAttribPointerARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribPointerARB(index: UInt32; size: Int32; &type: VertexAttribPointerType; normalized: boolean; stride: Int32; pointer: IntPtr) :=
    z_VertexAttribPointerARB_1(index, size, &type, normalized, stride, pointer);
    
    private z_EnableVertexAttribArrayARB_adr := GetProcAddress('glEnableVertexAttribArrayARB');
    private z_EnableVertexAttribArrayARB_1 := GetProcOrNil&<procedure(index: UInt32)>(z_EnableVertexAttribArrayARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableVertexAttribArrayARB(index: UInt32) :=
    z_EnableVertexAttribArrayARB_1(index);
    
    private z_DisableVertexAttribArrayARB_adr := GetProcAddress('glDisableVertexAttribArrayARB');
    private z_DisableVertexAttribArrayARB_1 := GetProcOrNil&<procedure(index: UInt32)>(z_DisableVertexAttribArrayARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableVertexAttribArrayARB(index: UInt32) :=
    z_DisableVertexAttribArrayARB_1(index);
    
    private z_BindAttribLocationARB_adr := GetProcAddress('glBindAttribLocationARB');
    private z_BindAttribLocationARB_1 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; index: UInt32; name: IntPtr)>(z_BindAttribLocationARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindAttribLocationARB(programObj: gl_handle_ARB; index: UInt32; name: string);
    begin
      var name_str_ptr: IntPtr;
      try
        name_str_ptr := Marshal.StringToHGlobalAnsi(name);
        z_BindAttribLocationARB_1(programObj, index, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindAttribLocationARB(programObj: gl_handle_ARB; index: UInt32; name: IntPtr) :=
    z_BindAttribLocationARB_1(programObj, index, name);
    
    private z_GetActiveAttribARB_adr := GetProcAddress('glGetActiveAttribARB');
    private z_GetActiveAttribARB_1 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; length: IntPtr; size: IntPtr; &type: IntPtr; name: IntPtr)>(z_GetActiveAttribARB_adr);
    private z_GetActiveAttribARB_2 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; length: IntPtr; size: IntPtr; var &type: AttributeType; name: IntPtr)>(z_GetActiveAttribARB_adr);
    private z_GetActiveAttribARB_3 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; length: IntPtr; var size: Int32; &type: IntPtr; name: IntPtr)>(z_GetActiveAttribARB_adr);
    private z_GetActiveAttribARB_4 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; length: IntPtr; var size: Int32; var &type: AttributeType; name: IntPtr)>(z_GetActiveAttribARB_adr);
    private z_GetActiveAttribARB_5 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; var length: Int32; size: IntPtr; &type: IntPtr; name: IntPtr)>(z_GetActiveAttribARB_adr);
    private z_GetActiveAttribARB_6 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; var length: Int32; size: IntPtr; var &type: AttributeType; name: IntPtr)>(z_GetActiveAttribARB_adr);
    private z_GetActiveAttribARB_7 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; var length: Int32; var size: Int32; &type: IntPtr; name: IntPtr)>(z_GetActiveAttribARB_adr);
    private z_GetActiveAttribARB_8 := GetProcOrNil&<procedure(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; var length: Int32; var size: Int32; var &type: AttributeType; name: IntPtr)>(z_GetActiveAttribARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; var length: Int32; var size: Int32; var &type: AttributeType; name: IntPtr) :=
    z_GetActiveAttribARB_8(programObj, index, maxLength, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; var length: Int32; var size: Int32; &type: IntPtr; name: IntPtr) :=
    z_GetActiveAttribARB_7(programObj, index, maxLength, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; var length: Int32; size: IntPtr; var &type: AttributeType; name: IntPtr) :=
    z_GetActiveAttribARB_6(programObj, index, maxLength, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; var length: Int32; size: IntPtr; &type: IntPtr; name: IntPtr) :=
    z_GetActiveAttribARB_5(programObj, index, maxLength, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; length: IntPtr; var size: Int32; var &type: AttributeType; name: IntPtr) :=
    z_GetActiveAttribARB_4(programObj, index, maxLength, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; length: IntPtr; var size: Int32; &type: IntPtr; name: IntPtr) :=
    z_GetActiveAttribARB_3(programObj, index, maxLength, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; length: IntPtr; size: IntPtr; var &type: AttributeType; name: IntPtr) :=
    z_GetActiveAttribARB_2(programObj, index, maxLength, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: gl_handle_ARB; index: UInt32; maxLength: Int32; length: IntPtr; size: IntPtr; &type: IntPtr; name: IntPtr) :=
    z_GetActiveAttribARB_1(programObj, index, maxLength, length, size, &type, name);
    
    private z_GetAttribLocationARB_adr := GetProcAddress('glGetAttribLocationARB');
    private z_GetAttribLocationARB_1 := GetProcOrNil&<function(programObj: gl_handle_ARB; name: IntPtr): Int32>(z_GetAttribLocationARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetAttribLocationARB(programObj: gl_handle_ARB; name: string): Int32;
    begin
      var name_str_ptr: IntPtr;
      try
        name_str_ptr := Marshal.StringToHGlobalAnsi(name);
        Result := z_GetAttribLocationARB_1(programObj, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetAttribLocationARB(programObj: gl_handle_ARB; name: IntPtr): Int32 :=
    z_GetAttribLocationARB_1(programObj, name);
    
    private z_GetVertexAttribdvARB_adr := GetProcAddress('glGetVertexAttribdvARB');
    private z_GetVertexAttribdvARB_1 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribProperty; &params: IntPtr)>(z_GetVertexAttribdvARB_adr);
    private z_GetVertexAttribdvARB_2 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribProperty; var &params: real)>(z_GetVertexAttribdvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribdvARB(index: UInt32; pname: VertexAttribProperty; var &params: real) :=
    z_GetVertexAttribdvARB_2(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribdvARB(index: UInt32; pname: VertexAttribProperty; &params: IntPtr) :=
    z_GetVertexAttribdvARB_1(index, pname, &params);
    
    private z_GetVertexAttribfvARB_adr := GetProcAddress('glGetVertexAttribfvARB');
    private z_GetVertexAttribfvARB_1 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribProperty; &params: IntPtr)>(z_GetVertexAttribfvARB_adr);
    private z_GetVertexAttribfvARB_2 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribProperty; var &params: single)>(z_GetVertexAttribfvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribfvARB(index: UInt32; pname: VertexAttribProperty; var &params: single) :=
    z_GetVertexAttribfvARB_2(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribfvARB(index: UInt32; pname: VertexAttribProperty; &params: IntPtr) :=
    z_GetVertexAttribfvARB_1(index, pname, &params);
    
    private z_GetVertexAttribivARB_adr := GetProcAddress('glGetVertexAttribivARB');
    private z_GetVertexAttribivARB_1 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribProperty; &params: IntPtr)>(z_GetVertexAttribivARB_adr);
    private z_GetVertexAttribivARB_2 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribProperty; var &params: Int32)>(z_GetVertexAttribivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribivARB(index: UInt32; pname: VertexAttribProperty; var &params: Int32) :=
    z_GetVertexAttribivARB_2(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribivARB(index: UInt32; pname: VertexAttribProperty; &params: IntPtr) :=
    z_GetVertexAttribivARB_1(index, pname, &params);
    
    private z_GetVertexAttribPointervARB_adr := GetProcAddress('glGetVertexAttribPointervARB');
    private z_GetVertexAttribPointervARB_1 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribPointerProperty; _pointer: pointer)>(z_GetVertexAttribPointervARB_adr);
    private z_GetVertexAttribPointervARB_2 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribPointerProperty; var _pointer: IntPtr)>(z_GetVertexAttribPointervARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribPointervARB(index: UInt32; pname: VertexAttribPointerProperty; var _pointer: IntPtr) :=
    z_GetVertexAttribPointervARB_2(index, pname, _pointer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribPointervARB(index: UInt32; pname: VertexAttribPointerProperty; _pointer: pointer) :=
    z_GetVertexAttribPointervARB_1(index, pname, _pointer);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glVertexType2101010RevARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_vertex_type_2_10_10_10_rev';
    
    private z_VertexAttribP1ui_adr := GetProcAddress('glVertexAttribP1ui');
    private z_VertexAttribP1ui_1 := GetProcOrNil&<procedure(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: UInt32)>(z_VertexAttribP1ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP1ui(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: UInt32) :=
    z_VertexAttribP1ui_1(index, &type, normalized, value);
    
    private z_VertexAttribP1uiv_adr := GetProcAddress('glVertexAttribP1uiv');
    private z_VertexAttribP1uiv_1 := GetProcOrNil&<procedure(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: IntPtr)>(z_VertexAttribP1uiv_adr);
    private z_VertexAttribP1uiv_2 := GetProcOrNil&<procedure(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; var value: UInt32)>(z_VertexAttribP1uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP1uiv(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_VertexAttribP1uiv_2(index, &type, normalized, value[0]) else
        z_VertexAttribP1uiv_2(index, &type, normalized, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP1uiv(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; var value: UInt32) :=
    z_VertexAttribP1uiv_2(index, &type, normalized, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP1uiv(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: IntPtr) :=
    z_VertexAttribP1uiv_1(index, &type, normalized, value);
    
    private z_VertexAttribP2ui_adr := GetProcAddress('glVertexAttribP2ui');
    private z_VertexAttribP2ui_1 := GetProcOrNil&<procedure(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: UInt32)>(z_VertexAttribP2ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP2ui(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: UInt32) :=
    z_VertexAttribP2ui_1(index, &type, normalized, value);
    
    private z_VertexAttribP2uiv_adr := GetProcAddress('glVertexAttribP2uiv');
    private z_VertexAttribP2uiv_1 := GetProcOrNil&<procedure(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: IntPtr)>(z_VertexAttribP2uiv_adr);
    private z_VertexAttribP2uiv_2 := GetProcOrNil&<procedure(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; var value: UInt32)>(z_VertexAttribP2uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP2uiv(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_VertexAttribP2uiv_2(index, &type, normalized, value[0]) else
        z_VertexAttribP2uiv_2(index, &type, normalized, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP2uiv(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; var value: UInt32) :=
    z_VertexAttribP2uiv_2(index, &type, normalized, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP2uiv(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: IntPtr) :=
    z_VertexAttribP2uiv_1(index, &type, normalized, value);
    
    private z_VertexAttribP3ui_adr := GetProcAddress('glVertexAttribP3ui');
    private z_VertexAttribP3ui_1 := GetProcOrNil&<procedure(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: UInt32)>(z_VertexAttribP3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP3ui(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: UInt32) :=
    z_VertexAttribP3ui_1(index, &type, normalized, value);
    
    private z_VertexAttribP3uiv_adr := GetProcAddress('glVertexAttribP3uiv');
    private z_VertexAttribP3uiv_1 := GetProcOrNil&<procedure(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: IntPtr)>(z_VertexAttribP3uiv_adr);
    private z_VertexAttribP3uiv_2 := GetProcOrNil&<procedure(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; var value: UInt32)>(z_VertexAttribP3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP3uiv(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_VertexAttribP3uiv_2(index, &type, normalized, value[0]) else
        z_VertexAttribP3uiv_2(index, &type, normalized, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP3uiv(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; var value: UInt32) :=
    z_VertexAttribP3uiv_2(index, &type, normalized, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP3uiv(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: IntPtr) :=
    z_VertexAttribP3uiv_1(index, &type, normalized, value);
    
    private z_VertexAttribP4ui_adr := GetProcAddress('glVertexAttribP4ui');
    private z_VertexAttribP4ui_1 := GetProcOrNil&<procedure(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: UInt32)>(z_VertexAttribP4ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP4ui(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: UInt32) :=
    z_VertexAttribP4ui_1(index, &type, normalized, value);
    
    private z_VertexAttribP4uiv_adr := GetProcAddress('glVertexAttribP4uiv');
    private z_VertexAttribP4uiv_1 := GetProcOrNil&<procedure(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: IntPtr)>(z_VertexAttribP4uiv_adr);
    private z_VertexAttribP4uiv_2 := GetProcOrNil&<procedure(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; var value: UInt32)>(z_VertexAttribP4uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP4uiv(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_VertexAttribP4uiv_2(index, &type, normalized, value[0]) else
        z_VertexAttribP4uiv_2(index, &type, normalized, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP4uiv(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; var value: UInt32) :=
    z_VertexAttribP4uiv_2(index, &type, normalized, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP4uiv(index: UInt32; &type: VertexAttribPointerType; normalized: boolean; value: IntPtr) :=
    z_VertexAttribP4uiv_1(index, &type, normalized, value);
    
    private z_VertexP2ui_adr := GetProcAddress('glVertexP2ui');
    private z_VertexP2ui_1 := GetProcOrNil&<procedure(&type: VertexPointerType; value: UInt32)>(z_VertexP2ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP2ui(&type: VertexPointerType; value: UInt32) :=
    z_VertexP2ui_1(&type, value);
    
    private z_VertexP2uiv_adr := GetProcAddress('glVertexP2uiv');
    private z_VertexP2uiv_1 := GetProcOrNil&<procedure(&type: VertexPointerType; value: IntPtr)>(z_VertexP2uiv_adr);
    private z_VertexP2uiv_2 := GetProcOrNil&<procedure(&type: VertexPointerType; var value: UInt32)>(z_VertexP2uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP2uiv(&type: VertexPointerType; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_VertexP2uiv_2(&type, value[0]) else
        z_VertexP2uiv_2(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP2uiv(&type: VertexPointerType; var value: UInt32) :=
    z_VertexP2uiv_2(&type, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP2uiv(&type: VertexPointerType; value: IntPtr) :=
    z_VertexP2uiv_1(&type, value);
    
    private z_VertexP3ui_adr := GetProcAddress('glVertexP3ui');
    private z_VertexP3ui_1 := GetProcOrNil&<procedure(&type: VertexPointerType; value: UInt32)>(z_VertexP3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP3ui(&type: VertexPointerType; value: UInt32) :=
    z_VertexP3ui_1(&type, value);
    
    private z_VertexP3uiv_adr := GetProcAddress('glVertexP3uiv');
    private z_VertexP3uiv_1 := GetProcOrNil&<procedure(&type: VertexPointerType; value: IntPtr)>(z_VertexP3uiv_adr);
    private z_VertexP3uiv_2 := GetProcOrNil&<procedure(&type: VertexPointerType; var value: UInt32)>(z_VertexP3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP3uiv(&type: VertexPointerType; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_VertexP3uiv_2(&type, value[0]) else
        z_VertexP3uiv_2(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP3uiv(&type: VertexPointerType; var value: UInt32) :=
    z_VertexP3uiv_2(&type, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP3uiv(&type: VertexPointerType; value: IntPtr) :=
    z_VertexP3uiv_1(&type, value);
    
    private z_VertexP4ui_adr := GetProcAddress('glVertexP4ui');
    private z_VertexP4ui_1 := GetProcOrNil&<procedure(&type: VertexPointerType; value: UInt32)>(z_VertexP4ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP4ui(&type: VertexPointerType; value: UInt32) :=
    z_VertexP4ui_1(&type, value);
    
    private z_VertexP4uiv_adr := GetProcAddress('glVertexP4uiv');
    private z_VertexP4uiv_1 := GetProcOrNil&<procedure(&type: VertexPointerType; value: IntPtr)>(z_VertexP4uiv_adr);
    private z_VertexP4uiv_2 := GetProcOrNil&<procedure(&type: VertexPointerType; var value: UInt32)>(z_VertexP4uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP4uiv(&type: VertexPointerType; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_VertexP4uiv_2(&type, value[0]) else
        z_VertexP4uiv_2(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP4uiv(&type: VertexPointerType; var value: UInt32) :=
    z_VertexP4uiv_2(&type, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP4uiv(&type: VertexPointerType; value: IntPtr) :=
    z_VertexP4uiv_1(&type, value);
    
    private z_TexCoordP1ui_adr := GetProcAddress('glTexCoordP1ui');
    private z_TexCoordP1ui_1 := GetProcOrNil&<procedure(&type: TexCoordPointerType; coords: UInt32)>(z_TexCoordP1ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP1ui(&type: TexCoordPointerType; coords: UInt32) :=
    z_TexCoordP1ui_1(&type, coords);
    
    private z_TexCoordP1uiv_adr := GetProcAddress('glTexCoordP1uiv');
    private z_TexCoordP1uiv_1 := GetProcOrNil&<procedure(&type: TexCoordPointerType; coords: IntPtr)>(z_TexCoordP1uiv_adr);
    private z_TexCoordP1uiv_2 := GetProcOrNil&<procedure(&type: TexCoordPointerType; var coords: UInt32)>(z_TexCoordP1uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP1uiv(&type: TexCoordPointerType; coords: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_TexCoordP1uiv_2(&type, coords[0]) else
        z_TexCoordP1uiv_2(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP1uiv(&type: TexCoordPointerType; var coords: UInt32) :=
    z_TexCoordP1uiv_2(&type, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP1uiv(&type: TexCoordPointerType; coords: IntPtr) :=
    z_TexCoordP1uiv_1(&type, coords);
    
    private z_TexCoordP2ui_adr := GetProcAddress('glTexCoordP2ui');
    private z_TexCoordP2ui_1 := GetProcOrNil&<procedure(&type: TexCoordPointerType; coords: UInt32)>(z_TexCoordP2ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP2ui(&type: TexCoordPointerType; coords: UInt32) :=
    z_TexCoordP2ui_1(&type, coords);
    
    private z_TexCoordP2uiv_adr := GetProcAddress('glTexCoordP2uiv');
    private z_TexCoordP2uiv_1 := GetProcOrNil&<procedure(&type: TexCoordPointerType; coords: IntPtr)>(z_TexCoordP2uiv_adr);
    private z_TexCoordP2uiv_2 := GetProcOrNil&<procedure(&type: TexCoordPointerType; var coords: UInt32)>(z_TexCoordP2uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP2uiv(&type: TexCoordPointerType; coords: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_TexCoordP2uiv_2(&type, coords[0]) else
        z_TexCoordP2uiv_2(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP2uiv(&type: TexCoordPointerType; var coords: UInt32) :=
    z_TexCoordP2uiv_2(&type, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP2uiv(&type: TexCoordPointerType; coords: IntPtr) :=
    z_TexCoordP2uiv_1(&type, coords);
    
    private z_TexCoordP3ui_adr := GetProcAddress('glTexCoordP3ui');
    private z_TexCoordP3ui_1 := GetProcOrNil&<procedure(&type: TexCoordPointerType; coords: UInt32)>(z_TexCoordP3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP3ui(&type: TexCoordPointerType; coords: UInt32) :=
    z_TexCoordP3ui_1(&type, coords);
    
    private z_TexCoordP3uiv_adr := GetProcAddress('glTexCoordP3uiv');
    private z_TexCoordP3uiv_1 := GetProcOrNil&<procedure(&type: TexCoordPointerType; coords: IntPtr)>(z_TexCoordP3uiv_adr);
    private z_TexCoordP3uiv_2 := GetProcOrNil&<procedure(&type: TexCoordPointerType; var coords: UInt32)>(z_TexCoordP3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP3uiv(&type: TexCoordPointerType; coords: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_TexCoordP3uiv_2(&type, coords[0]) else
        z_TexCoordP3uiv_2(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP3uiv(&type: TexCoordPointerType; var coords: UInt32) :=
    z_TexCoordP3uiv_2(&type, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP3uiv(&type: TexCoordPointerType; coords: IntPtr) :=
    z_TexCoordP3uiv_1(&type, coords);
    
    private z_TexCoordP4ui_adr := GetProcAddress('glTexCoordP4ui');
    private z_TexCoordP4ui_1 := GetProcOrNil&<procedure(&type: TexCoordPointerType; coords: UInt32)>(z_TexCoordP4ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP4ui(&type: TexCoordPointerType; coords: UInt32) :=
    z_TexCoordP4ui_1(&type, coords);
    
    private z_TexCoordP4uiv_adr := GetProcAddress('glTexCoordP4uiv');
    private z_TexCoordP4uiv_1 := GetProcOrNil&<procedure(&type: TexCoordPointerType; coords: IntPtr)>(z_TexCoordP4uiv_adr);
    private z_TexCoordP4uiv_2 := GetProcOrNil&<procedure(&type: TexCoordPointerType; var coords: UInt32)>(z_TexCoordP4uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP4uiv(&type: TexCoordPointerType; coords: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_TexCoordP4uiv_2(&type, coords[0]) else
        z_TexCoordP4uiv_2(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP4uiv(&type: TexCoordPointerType; var coords: UInt32) :=
    z_TexCoordP4uiv_2(&type, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP4uiv(&type: TexCoordPointerType; coords: IntPtr) :=
    z_TexCoordP4uiv_1(&type, coords);
    
    private z_MultiTexCoordP1ui_adr := GetProcAddress('glMultiTexCoordP1ui');
    private z_MultiTexCoordP1ui_1 := GetProcOrNil&<procedure(texture: TextureUnit; &type: TexCoordPointerType; coords: UInt32)>(z_MultiTexCoordP1ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP1ui(texture: TextureUnit; &type: TexCoordPointerType; coords: UInt32) :=
    z_MultiTexCoordP1ui_1(texture, &type, coords);
    
    private z_MultiTexCoordP1uiv_adr := GetProcAddress('glMultiTexCoordP1uiv');
    private z_MultiTexCoordP1uiv_1 := GetProcOrNil&<procedure(texture: TextureUnit; &type: TexCoordPointerType; coords: IntPtr)>(z_MultiTexCoordP1uiv_adr);
    private z_MultiTexCoordP1uiv_2 := GetProcOrNil&<procedure(texture: TextureUnit; &type: TexCoordPointerType; var coords: UInt32)>(z_MultiTexCoordP1uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP1uiv(texture: TextureUnit; &type: TexCoordPointerType; coords: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_MultiTexCoordP1uiv_2(texture, &type, coords[0]) else
        z_MultiTexCoordP1uiv_2(texture, &type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP1uiv(texture: TextureUnit; &type: TexCoordPointerType; var coords: UInt32) :=
    z_MultiTexCoordP1uiv_2(texture, &type, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP1uiv(texture: TextureUnit; &type: TexCoordPointerType; coords: IntPtr) :=
    z_MultiTexCoordP1uiv_1(texture, &type, coords);
    
    private z_MultiTexCoordP2ui_adr := GetProcAddress('glMultiTexCoordP2ui');
    private z_MultiTexCoordP2ui_1 := GetProcOrNil&<procedure(texture: TextureUnit; &type: TexCoordPointerType; coords: UInt32)>(z_MultiTexCoordP2ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP2ui(texture: TextureUnit; &type: TexCoordPointerType; coords: UInt32) :=
    z_MultiTexCoordP2ui_1(texture, &type, coords);
    
    private z_MultiTexCoordP2uiv_adr := GetProcAddress('glMultiTexCoordP2uiv');
    private z_MultiTexCoordP2uiv_1 := GetProcOrNil&<procedure(texture: TextureUnit; &type: TexCoordPointerType; coords: IntPtr)>(z_MultiTexCoordP2uiv_adr);
    private z_MultiTexCoordP2uiv_2 := GetProcOrNil&<procedure(texture: TextureUnit; &type: TexCoordPointerType; var coords: UInt32)>(z_MultiTexCoordP2uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP2uiv(texture: TextureUnit; &type: TexCoordPointerType; coords: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_MultiTexCoordP2uiv_2(texture, &type, coords[0]) else
        z_MultiTexCoordP2uiv_2(texture, &type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP2uiv(texture: TextureUnit; &type: TexCoordPointerType; var coords: UInt32) :=
    z_MultiTexCoordP2uiv_2(texture, &type, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP2uiv(texture: TextureUnit; &type: TexCoordPointerType; coords: IntPtr) :=
    z_MultiTexCoordP2uiv_1(texture, &type, coords);
    
    private z_MultiTexCoordP3ui_adr := GetProcAddress('glMultiTexCoordP3ui');
    private z_MultiTexCoordP3ui_1 := GetProcOrNil&<procedure(texture: TextureUnit; &type: TexCoordPointerType; coords: UInt32)>(z_MultiTexCoordP3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP3ui(texture: TextureUnit; &type: TexCoordPointerType; coords: UInt32) :=
    z_MultiTexCoordP3ui_1(texture, &type, coords);
    
    private z_MultiTexCoordP3uiv_adr := GetProcAddress('glMultiTexCoordP3uiv');
    private z_MultiTexCoordP3uiv_1 := GetProcOrNil&<procedure(texture: TextureUnit; &type: TexCoordPointerType; coords: IntPtr)>(z_MultiTexCoordP3uiv_adr);
    private z_MultiTexCoordP3uiv_2 := GetProcOrNil&<procedure(texture: TextureUnit; &type: TexCoordPointerType; var coords: UInt32)>(z_MultiTexCoordP3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP3uiv(texture: TextureUnit; &type: TexCoordPointerType; coords: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_MultiTexCoordP3uiv_2(texture, &type, coords[0]) else
        z_MultiTexCoordP3uiv_2(texture, &type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP3uiv(texture: TextureUnit; &type: TexCoordPointerType; var coords: UInt32) :=
    z_MultiTexCoordP3uiv_2(texture, &type, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP3uiv(texture: TextureUnit; &type: TexCoordPointerType; coords: IntPtr) :=
    z_MultiTexCoordP3uiv_1(texture, &type, coords);
    
    private z_MultiTexCoordP4ui_adr := GetProcAddress('glMultiTexCoordP4ui');
    private z_MultiTexCoordP4ui_1 := GetProcOrNil&<procedure(texture: TextureUnit; &type: TexCoordPointerType; coords: UInt32)>(z_MultiTexCoordP4ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP4ui(texture: TextureUnit; &type: TexCoordPointerType; coords: UInt32) :=
    z_MultiTexCoordP4ui_1(texture, &type, coords);
    
    private z_MultiTexCoordP4uiv_adr := GetProcAddress('glMultiTexCoordP4uiv');
    private z_MultiTexCoordP4uiv_1 := GetProcOrNil&<procedure(texture: TextureUnit; &type: TexCoordPointerType; coords: IntPtr)>(z_MultiTexCoordP4uiv_adr);
    private z_MultiTexCoordP4uiv_2 := GetProcOrNil&<procedure(texture: TextureUnit; &type: TexCoordPointerType; var coords: UInt32)>(z_MultiTexCoordP4uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP4uiv(texture: TextureUnit; &type: TexCoordPointerType; coords: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_MultiTexCoordP4uiv_2(texture, &type, coords[0]) else
        z_MultiTexCoordP4uiv_2(texture, &type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP4uiv(texture: TextureUnit; &type: TexCoordPointerType; var coords: UInt32) :=
    z_MultiTexCoordP4uiv_2(texture, &type, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP4uiv(texture: TextureUnit; &type: TexCoordPointerType; coords: IntPtr) :=
    z_MultiTexCoordP4uiv_1(texture, &type, coords);
    
    private z_NormalP3ui_adr := GetProcAddress('glNormalP3ui');
    private z_NormalP3ui_1 := GetProcOrNil&<procedure(&type: NormalPointerType; coords: UInt32)>(z_NormalP3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalP3ui(&type: NormalPointerType; coords: UInt32) :=
    z_NormalP3ui_1(&type, coords);
    
    private z_NormalP3uiv_adr := GetProcAddress('glNormalP3uiv');
    private z_NormalP3uiv_1 := GetProcOrNil&<procedure(&type: NormalPointerType; coords: IntPtr)>(z_NormalP3uiv_adr);
    private z_NormalP3uiv_2 := GetProcOrNil&<procedure(&type: NormalPointerType; var coords: UInt32)>(z_NormalP3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalP3uiv(&type: NormalPointerType; coords: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_NormalP3uiv_2(&type, coords[0]) else
        z_NormalP3uiv_2(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalP3uiv(&type: NormalPointerType; var coords: UInt32) :=
    z_NormalP3uiv_2(&type, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalP3uiv(&type: NormalPointerType; coords: IntPtr) :=
    z_NormalP3uiv_1(&type, coords);
    
    private z_ColorP3ui_adr := GetProcAddress('glColorP3ui');
    private z_ColorP3ui_1 := GetProcOrNil&<procedure(&type: ColorPointerType; color: UInt32)>(z_ColorP3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP3ui(&type: ColorPointerType; color: UInt32) :=
    z_ColorP3ui_1(&type, color);
    
    private z_ColorP3uiv_adr := GetProcAddress('glColorP3uiv');
    private z_ColorP3uiv_1 := GetProcOrNil&<procedure(&type: ColorPointerType; color: IntPtr)>(z_ColorP3uiv_adr);
    private z_ColorP3uiv_2 := GetProcOrNil&<procedure(&type: ColorPointerType; var color: UInt32)>(z_ColorP3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP3uiv(&type: ColorPointerType; color: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (color<>nil) and (color.Length<>0) then
        z_ColorP3uiv_2(&type, color[0]) else
        z_ColorP3uiv_2(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP3uiv(&type: ColorPointerType; var color: UInt32) :=
    z_ColorP3uiv_2(&type, color);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP3uiv(&type: ColorPointerType; color: IntPtr) :=
    z_ColorP3uiv_1(&type, color);
    
    private z_ColorP4ui_adr := GetProcAddress('glColorP4ui');
    private z_ColorP4ui_1 := GetProcOrNil&<procedure(&type: ColorPointerType; color: UInt32)>(z_ColorP4ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP4ui(&type: ColorPointerType; color: UInt32) :=
    z_ColorP4ui_1(&type, color);
    
    private z_ColorP4uiv_adr := GetProcAddress('glColorP4uiv');
    private z_ColorP4uiv_1 := GetProcOrNil&<procedure(&type: ColorPointerType; color: IntPtr)>(z_ColorP4uiv_adr);
    private z_ColorP4uiv_2 := GetProcOrNil&<procedure(&type: ColorPointerType; var color: UInt32)>(z_ColorP4uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP4uiv(&type: ColorPointerType; color: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (color<>nil) and (color.Length<>0) then
        z_ColorP4uiv_2(&type, color[0]) else
        z_ColorP4uiv_2(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP4uiv(&type: ColorPointerType; var color: UInt32) :=
    z_ColorP4uiv_2(&type, color);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP4uiv(&type: ColorPointerType; color: IntPtr) :=
    z_ColorP4uiv_1(&type, color);
    
    private z_SecondaryColorP3ui_adr := GetProcAddress('glSecondaryColorP3ui');
    private z_SecondaryColorP3ui_1 := GetProcOrNil&<procedure(&type: ColorPointerType; color: UInt32)>(z_SecondaryColorP3ui_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorP3ui(&type: ColorPointerType; color: UInt32) :=
    z_SecondaryColorP3ui_1(&type, color);
    
    private z_SecondaryColorP3uiv_adr := GetProcAddress('glSecondaryColorP3uiv');
    private z_SecondaryColorP3uiv_1 := GetProcOrNil&<procedure(&type: ColorPointerType; color: IntPtr)>(z_SecondaryColorP3uiv_adr);
    private z_SecondaryColorP3uiv_2 := GetProcOrNil&<procedure(&type: ColorPointerType; var color: UInt32)>(z_SecondaryColorP3uiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorP3uiv(&type: ColorPointerType; color: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (color<>nil) and (color.Length<>0) then
        z_SecondaryColorP3uiv_2(&type, color[0]) else
        z_SecondaryColorP3uiv_2(&type, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorP3uiv(&type: ColorPointerType; var color: UInt32) :=
    z_SecondaryColorP3uiv_2(&type, color);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorP3uiv(&type: ColorPointerType; color: IntPtr) :=
    z_SecondaryColorP3uiv_1(&type, color);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glViewportArrayARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_viewport_array';
    
    private z_ViewportArrayv_adr := GetProcAddress('glViewportArrayv');
    private z_ViewportArrayv_1 := GetProcOrNil&<procedure(first: UInt32; count: Int32; v: IntPtr)>(z_ViewportArrayv_adr);
    private z_ViewportArrayv_2 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var v: single)>(z_ViewportArrayv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportArrayv(first: UInt32; count: Int32; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_ViewportArrayv_2(first, count, v[0]) else
        z_ViewportArrayv_2(first, count, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportArrayv(first: UInt32; count: Int32; var v: single) :=
    z_ViewportArrayv_2(first, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportArrayv(first: UInt32; count: Int32; v: IntPtr) :=
    z_ViewportArrayv_1(first, count, v);
    
    private z_ViewportIndexedf_adr := GetProcAddress('glViewportIndexedf');
    private z_ViewportIndexedf_1 := GetProcOrNil&<procedure(index: UInt32; x: single; y: single; w: single; h: single)>(z_ViewportIndexedf_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportIndexedf(index: UInt32; x: single; y: single; w: single; h: single) :=
    z_ViewportIndexedf_1(index, x, y, w, h);
    
    private z_ViewportIndexedfv_adr := GetProcAddress('glViewportIndexedfv');
    private z_ViewportIndexedfv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_ViewportIndexedfv_adr);
    private z_ViewportIndexedfv_2 := GetProcOrNil&<procedure(index: UInt32; var v: single)>(z_ViewportIndexedfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportIndexedfv(index: UInt32; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_ViewportIndexedfv_2(index, v[0]) else
        z_ViewportIndexedfv_2(index, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportIndexedfv(index: UInt32; var v: single) :=
    z_ViewportIndexedfv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportIndexedfv(index: UInt32; v: IntPtr) :=
    z_ViewportIndexedfv_1(index, v);
    
    private z_ScissorArrayv_adr := GetProcAddress('glScissorArrayv');
    private z_ScissorArrayv_1 := GetProcOrNil&<procedure(first: UInt32; count: Int32; v: IntPtr)>(z_ScissorArrayv_adr);
    private z_ScissorArrayv_2 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var v: Int32)>(z_ScissorArrayv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorArrayv(first: UInt32; count: Int32; v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_ScissorArrayv_2(first, count, v[0]) else
        z_ScissorArrayv_2(first, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorArrayv(first: UInt32; count: Int32; var v: Int32) :=
    z_ScissorArrayv_2(first, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorArrayv(first: UInt32; count: Int32; v: IntPtr) :=
    z_ScissorArrayv_1(first, count, v);
    
    private z_ScissorIndexed_adr := GetProcAddress('glScissorIndexed');
    private z_ScissorIndexed_1 := GetProcOrNil&<procedure(index: UInt32; left: Int32; bottom: Int32; width: Int32; height: Int32)>(z_ScissorIndexed_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorIndexed(index: UInt32; left: Int32; bottom: Int32; width: Int32; height: Int32) :=
    z_ScissorIndexed_1(index, left, bottom, width, height);
    
    private z_ScissorIndexedv_adr := GetProcAddress('glScissorIndexedv');
    private z_ScissorIndexedv_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_ScissorIndexedv_adr);
    private z_ScissorIndexedv_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(z_ScissorIndexedv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorIndexedv(index: UInt32; v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_ScissorIndexedv_2(index, v[0]) else
        z_ScissorIndexedv_2(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorIndexedv(index: UInt32; var v: Int32) :=
    z_ScissorIndexedv_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorIndexedv(index: UInt32; v: IntPtr) :=
    z_ScissorIndexedv_1(index, v);
    
    private z_DepthRangeArrayv_adr := GetProcAddress('glDepthRangeArrayv');
    private z_DepthRangeArrayv_1 := GetProcOrNil&<procedure(first: UInt32; count: Int32; v: IntPtr)>(z_DepthRangeArrayv_adr);
    private z_DepthRangeArrayv_2 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var v: real)>(z_DepthRangeArrayv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeArrayv(first: UInt32; count: Int32; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_DepthRangeArrayv_2(first, count, v[0]) else
        z_DepthRangeArrayv_2(first, count, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeArrayv(first: UInt32; count: Int32; var v: real) :=
    z_DepthRangeArrayv_2(first, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeArrayv(first: UInt32; count: Int32; v: IntPtr) :=
    z_DepthRangeArrayv_1(first, count, v);
    
    private z_DepthRangeIndexed_adr := GetProcAddress('glDepthRangeIndexed');
    private z_DepthRangeIndexed_1 := GetProcOrNil&<procedure(index: UInt32; n: real; f: real)>(z_DepthRangeIndexed_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeIndexed(index: UInt32; n: real; f: real) :=
    z_DepthRangeIndexed_1(index, n, f);
    
    private z_GetFloati_v_adr := GetProcAddress('glGetFloati_v');
    private z_GetFloati_v_1 := GetProcOrNil&<procedure(target: GetPName; index: UInt32; data: IntPtr)>(z_GetFloati_v_adr);
    private z_GetFloati_v_2 := GetProcOrNil&<procedure(target: GetPName; index: UInt32; var data: single)>(z_GetFloati_v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloati_v(target: GetPName; index: UInt32; var data: single) :=
    z_GetFloati_v_2(target, index, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloati_v(target: GetPName; index: UInt32; data: IntPtr) :=
    z_GetFloati_v_1(target, index, data);
    
    private z_GetDoublei_v_adr := GetProcAddress('glGetDoublei_v');
    private z_GetDoublei_v_1 := GetProcOrNil&<procedure(target: GetPName; index: UInt32; data: IntPtr)>(z_GetDoublei_v_adr);
    private z_GetDoublei_v_2 := GetProcOrNil&<procedure(target: GetPName; index: UInt32; var data: real)>(z_GetDoublei_v_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDoublei_v(target: GetPName; index: UInt32; var data: real) :=
    z_GetDoublei_v_2(target, index, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDoublei_v(target: GetPName; index: UInt32; data: IntPtr) :=
    z_GetDoublei_v_1(target, index, data);
    
    private z_DepthRangeArraydvNV_adr := GetProcAddress('glDepthRangeArraydvNV');
    private z_DepthRangeArraydvNV_1 := GetProcOrNil&<procedure(first: UInt32; count: Int32; v: IntPtr)>(z_DepthRangeArraydvNV_adr);
    private z_DepthRangeArraydvNV_2 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var v: real)>(z_DepthRangeArraydvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeArraydvNV(first: UInt32; count: Int32; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_DepthRangeArraydvNV_2(first, count, v[0]) else
        z_DepthRangeArraydvNV_2(first, count, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeArraydvNV(first: UInt32; count: Int32; var v: real) :=
    z_DepthRangeArraydvNV_2(first, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeArraydvNV(first: UInt32; count: Int32; v: IntPtr) :=
    z_DepthRangeArraydvNV_1(first, count, v);
    
    private z_DepthRangeIndexeddNV_adr := GetProcAddress('glDepthRangeIndexeddNV');
    private z_DepthRangeIndexeddNV_1 := GetProcOrNil&<procedure(index: UInt32; n: real; f: real)>(z_DepthRangeIndexeddNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeIndexeddNV(index: UInt32; n: real; f: real) :=
    z_DepthRangeIndexeddNV_1(index, n, f);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glWindowPosARB = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_arb_window_pos';
    
    private z_WindowPos2dARB_adr := GetProcAddress('glWindowPos2dARB');
    private z_WindowPos2dARB_1 := GetProcOrNil&<procedure(x: real; y: real)>(z_WindowPos2dARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dARB(x: real; y: real) :=
    z_WindowPos2dARB_1(x, y);
    
    private z_WindowPos2dvARB_adr := GetProcAddress('glWindowPos2dvARB');
    private z_WindowPos2dvARB_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_WindowPos2dvARB_adr);
    private z_WindowPos2dvARB_2 := GetProcOrNil&<procedure(var v: real)>(z_WindowPos2dvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dvARB(v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_WindowPos2dvARB_2(v[0]) else
        z_WindowPos2dvARB_2(Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dvARB(var v: real) :=
    z_WindowPos2dvARB_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dvARB(v: IntPtr) :=
    z_WindowPos2dvARB_1(v);
    
    private z_WindowPos2fARB_adr := GetProcAddress('glWindowPos2fARB');
    private z_WindowPos2fARB_1 := GetProcOrNil&<procedure(x: single; y: single)>(z_WindowPos2fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fARB(x: single; y: single) :=
    z_WindowPos2fARB_1(x, y);
    
    private z_WindowPos2fvARB_adr := GetProcAddress('glWindowPos2fvARB');
    private z_WindowPos2fvARB_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_WindowPos2fvARB_adr);
    private z_WindowPos2fvARB_2 := GetProcOrNil&<procedure(var v: single)>(z_WindowPos2fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fvARB(v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_WindowPos2fvARB_2(v[0]) else
        z_WindowPos2fvARB_2(Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fvARB(var v: single) :=
    z_WindowPos2fvARB_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fvARB(v: IntPtr) :=
    z_WindowPos2fvARB_1(v);
    
    private z_WindowPos2iARB_adr := GetProcAddress('glWindowPos2iARB');
    private z_WindowPos2iARB_1 := GetProcOrNil&<procedure(x: Int32; y: Int32)>(z_WindowPos2iARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2iARB(x: Int32; y: Int32) :=
    z_WindowPos2iARB_1(x, y);
    
    private z_WindowPos2ivARB_adr := GetProcAddress('glWindowPos2ivARB');
    private z_WindowPos2ivARB_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_WindowPos2ivARB_adr);
    private z_WindowPos2ivARB_2 := GetProcOrNil&<procedure(var v: Int32)>(z_WindowPos2ivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2ivARB(v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_WindowPos2ivARB_2(v[0]) else
        z_WindowPos2ivARB_2(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2ivARB(var v: Int32) :=
    z_WindowPos2ivARB_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2ivARB(v: IntPtr) :=
    z_WindowPos2ivARB_1(v);
    
    private z_WindowPos2sARB_adr := GetProcAddress('glWindowPos2sARB');
    private z_WindowPos2sARB_1 := GetProcOrNil&<procedure(x: Int16; y: Int16)>(z_WindowPos2sARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2sARB(x: Int16; y: Int16) :=
    z_WindowPos2sARB_1(x, y);
    
    private z_WindowPos2svARB_adr := GetProcAddress('glWindowPos2svARB');
    private z_WindowPos2svARB_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_WindowPos2svARB_adr);
    private z_WindowPos2svARB_2 := GetProcOrNil&<procedure(var v: Int16)>(z_WindowPos2svARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2svARB(v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_WindowPos2svARB_2(v[0]) else
        z_WindowPos2svARB_2(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2svARB(var v: Int16) :=
    z_WindowPos2svARB_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2svARB(v: IntPtr) :=
    z_WindowPos2svARB_1(v);
    
    private z_WindowPos3dARB_adr := GetProcAddress('glWindowPos3dARB');
    private z_WindowPos3dARB_1 := GetProcOrNil&<procedure(x: real; y: real; z: real)>(z_WindowPos3dARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dARB(x: real; y: real; z: real) :=
    z_WindowPos3dARB_1(x, y, z);
    
    private z_WindowPos3dvARB_adr := GetProcAddress('glWindowPos3dvARB');
    private z_WindowPos3dvARB_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_WindowPos3dvARB_adr);
    private z_WindowPos3dvARB_2 := GetProcOrNil&<procedure(var v: real)>(z_WindowPos3dvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dvARB(v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_WindowPos3dvARB_2(v[0]) else
        z_WindowPos3dvARB_2(Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dvARB(var v: real) :=
    z_WindowPos3dvARB_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dvARB(v: IntPtr) :=
    z_WindowPos3dvARB_1(v);
    
    private z_WindowPos3fARB_adr := GetProcAddress('glWindowPos3fARB');
    private z_WindowPos3fARB_1 := GetProcOrNil&<procedure(x: single; y: single; z: single)>(z_WindowPos3fARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fARB(x: single; y: single; z: single) :=
    z_WindowPos3fARB_1(x, y, z);
    
    private z_WindowPos3fvARB_adr := GetProcAddress('glWindowPos3fvARB');
    private z_WindowPos3fvARB_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_WindowPos3fvARB_adr);
    private z_WindowPos3fvARB_2 := GetProcOrNil&<procedure(var v: single)>(z_WindowPos3fvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fvARB(v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_WindowPos3fvARB_2(v[0]) else
        z_WindowPos3fvARB_2(Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fvARB(var v: single) :=
    z_WindowPos3fvARB_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fvARB(v: IntPtr) :=
    z_WindowPos3fvARB_1(v);
    
    private z_WindowPos3iARB_adr := GetProcAddress('glWindowPos3iARB');
    private z_WindowPos3iARB_1 := GetProcOrNil&<procedure(x: Int32; y: Int32; z: Int32)>(z_WindowPos3iARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3iARB(x: Int32; y: Int32; z: Int32) :=
    z_WindowPos3iARB_1(x, y, z);
    
    private z_WindowPos3ivARB_adr := GetProcAddress('glWindowPos3ivARB');
    private z_WindowPos3ivARB_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_WindowPos3ivARB_adr);
    private z_WindowPos3ivARB_2 := GetProcOrNil&<procedure(var v: Int32)>(z_WindowPos3ivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3ivARB(v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_WindowPos3ivARB_2(v[0]) else
        z_WindowPos3ivARB_2(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3ivARB(var v: Int32) :=
    z_WindowPos3ivARB_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3ivARB(v: IntPtr) :=
    z_WindowPos3ivARB_1(v);
    
    private z_WindowPos3sARB_adr := GetProcAddress('glWindowPos3sARB');
    private z_WindowPos3sARB_1 := GetProcOrNil&<procedure(x: Int16; y: Int16; z: Int16)>(z_WindowPos3sARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3sARB(x: Int16; y: Int16; z: Int16) :=
    z_WindowPos3sARB_1(x, y, z);
    
    private z_WindowPos3svARB_adr := GetProcAddress('glWindowPos3svARB');
    private z_WindowPos3svARB_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_WindowPos3svARB_adr);
    private z_WindowPos3svARB_2 := GetProcOrNil&<procedure(var v: Int16)>(z_WindowPos3svARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3svARB(v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_WindowPos3svARB_2(v[0]) else
        z_WindowPos3svARB_2(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3svARB(var v: Int16) :=
    z_WindowPos3svARB_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3svARB(v: IntPtr) :=
    z_WindowPos3svARB_1(v);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glDrawBuffersATI = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ati_draw_buffers';
    
    private z_DrawBuffersATI_adr := GetProcAddress('glDrawBuffersATI');
    private z_DrawBuffersATI_1 := GetProcOrNil&<procedure(n: Int32; bufs: IntPtr)>(z_DrawBuffersATI_adr);
    private z_DrawBuffersATI_2 := GetProcOrNil&<procedure(n: Int32; var bufs: DrawBufferMode)>(z_DrawBuffersATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersATI(n: Int32; bufs: array of DrawBufferMode);
    type PDrawBufferMode=^DrawBufferMode;
    begin
      if (bufs<>nil) and (bufs.Length<>0) then
        z_DrawBuffersATI_2(n, bufs[0]) else
        z_DrawBuffersATI_2(n, PDrawBufferMode(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersATI(n: Int32; var bufs: DrawBufferMode) :=
    z_DrawBuffersATI_2(n, bufs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersATI(n: Int32; bufs: IntPtr) :=
    z_DrawBuffersATI_1(n, bufs);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glElementArrayATI = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ati_element_array';
    
    private z_ElementPointerATI_adr := GetProcAddress('glElementPointerATI');
    private z_ElementPointerATI_1 := GetProcOrNil&<procedure(&type: ElementPointerType; pointer: IntPtr)>(z_ElementPointerATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ElementPointerATI(&type: ElementPointerType; pointer: IntPtr) :=
    z_ElementPointerATI_1(&type, pointer);
    
    private z_DrawElementArrayATI_adr := GetProcAddress('glDrawElementArrayATI');
    private z_DrawElementArrayATI_1 := GetProcOrNil&<procedure(mode: PrimitiveType; count: Int32)>(z_DrawElementArrayATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementArrayATI(mode: PrimitiveType; count: Int32) :=
    z_DrawElementArrayATI_1(mode, count);
    
    private z_DrawRangeElementArrayATI_adr := GetProcAddress('glDrawRangeElementArrayATI');
    private z_DrawRangeElementArrayATI_1 := GetProcOrNil&<procedure(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32)>(z_DrawRangeElementArrayATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawRangeElementArrayATI(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32) :=
    z_DrawRangeElementArrayATI_1(mode, start, &end, count);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glEnvmapBumpmapATI = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ati_envmap_bumpmap';
    
    private z_TexBumpParameterivATI_adr := GetProcAddress('glTexBumpParameterivATI');
    private z_TexBumpParameterivATI_1 := GetProcOrNil&<procedure(pname: TexBumpParameter; param: IntPtr)>(z_TexBumpParameterivATI_adr);
    private z_TexBumpParameterivATI_2 := GetProcOrNil&<procedure(pname: TexBumpParameter; var param: Int32)>(z_TexBumpParameterivATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBumpParameterivATI(pname: TexBumpParameter; param: array of Int32);
    type PInt32=^Int32;
    begin
      if (param<>nil) and (param.Length<>0) then
        z_TexBumpParameterivATI_2(pname, param[0]) else
        z_TexBumpParameterivATI_2(pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBumpParameterivATI(pname: TexBumpParameter; var param: Int32) :=
    z_TexBumpParameterivATI_2(pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBumpParameterivATI(pname: TexBumpParameter; param: IntPtr) :=
    z_TexBumpParameterivATI_1(pname, param);
    
    private z_TexBumpParameterfvATI_adr := GetProcAddress('glTexBumpParameterfvATI');
    private z_TexBumpParameterfvATI_1 := GetProcOrNil&<procedure(pname: TexBumpParameter; param: IntPtr)>(z_TexBumpParameterfvATI_adr);
    private z_TexBumpParameterfvATI_2 := GetProcOrNil&<procedure(pname: TexBumpParameter; var param: single)>(z_TexBumpParameterfvATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBumpParameterfvATI(pname: TexBumpParameter; param: array of single);
    type Psingle=^single;
    begin
      if (param<>nil) and (param.Length<>0) then
        z_TexBumpParameterfvATI_2(pname, param[0]) else
        z_TexBumpParameterfvATI_2(pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBumpParameterfvATI(pname: TexBumpParameter; var param: single) :=
    z_TexBumpParameterfvATI_2(pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBumpParameterfvATI(pname: TexBumpParameter; param: IntPtr) :=
    z_TexBumpParameterfvATI_1(pname, param);
    
    private z_GetTexBumpParameterivATI_adr := GetProcAddress('glGetTexBumpParameterivATI');
    private z_GetTexBumpParameterivATI_1 := GetProcOrNil&<procedure(pname: GetTexBumpParameter; param: IntPtr)>(z_GetTexBumpParameterivATI_adr);
    private z_GetTexBumpParameterivATI_2 := GetProcOrNil&<procedure(pname: GetTexBumpParameter; var param: Int32)>(z_GetTexBumpParameterivATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexBumpParameterivATI(pname: GetTexBumpParameter; var param: Int32) :=
    z_GetTexBumpParameterivATI_2(pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexBumpParameterivATI(pname: GetTexBumpParameter; param: IntPtr) :=
    z_GetTexBumpParameterivATI_1(pname, param);
    
    private z_GetTexBumpParameterfvATI_adr := GetProcAddress('glGetTexBumpParameterfvATI');
    private z_GetTexBumpParameterfvATI_1 := GetProcOrNil&<procedure(pname: GetTexBumpParameter; param: IntPtr)>(z_GetTexBumpParameterfvATI_adr);
    private z_GetTexBumpParameterfvATI_2 := GetProcOrNil&<procedure(pname: GetTexBumpParameter; var param: single)>(z_GetTexBumpParameterfvATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexBumpParameterfvATI(pname: GetTexBumpParameter; var param: single) :=
    z_GetTexBumpParameterfvATI_2(pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexBumpParameterfvATI(pname: GetTexBumpParameter; param: IntPtr) :=
    z_GetTexBumpParameterfvATI_1(pname, param);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glFragmentShaderATI = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ati_fragment_shader';
    
    private z_GenFragmentShadersATI_adr := GetProcAddress('glGenFragmentShadersATI');
    private z_GenFragmentShadersATI_1 := GetProcOrNil&<function(range: UInt32): UInt32>(z_GenFragmentShadersATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenFragmentShadersATI(range: UInt32): UInt32 :=
    z_GenFragmentShadersATI_1(range);
    
    private z_BindFragmentShaderATI_adr := GetProcAddress('glBindFragmentShaderATI');
    private z_BindFragmentShaderATI_1 := GetProcOrNil&<procedure(id: UInt32)>(z_BindFragmentShaderATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindFragmentShaderATI(id: UInt32) :=
    z_BindFragmentShaderATI_1(id);
    
    private z_DeleteFragmentShaderATI_adr := GetProcAddress('glDeleteFragmentShaderATI');
    private z_DeleteFragmentShaderATI_1 := GetProcOrNil&<procedure(id: UInt32)>(z_DeleteFragmentShaderATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFragmentShaderATI(id: UInt32) :=
    z_DeleteFragmentShaderATI_1(id);
    
    private z_BeginFragmentShaderATI_adr := GetProcAddress('glBeginFragmentShaderATI');
    private z_BeginFragmentShaderATI_1 := GetProcOrNil&<procedure>(z_BeginFragmentShaderATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginFragmentShaderATI :=
    z_BeginFragmentShaderATI_1();
    
    private z_EndFragmentShaderATI_adr := GetProcAddress('glEndFragmentShaderATI');
    private z_EndFragmentShaderATI_1 := GetProcOrNil&<procedure>(z_EndFragmentShaderATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndFragmentShaderATI :=
    z_EndFragmentShaderATI_1();
    
    private z_PassTexCoordATI_adr := GetProcAddress('glPassTexCoordATI');
    private z_PassTexCoordATI_1 := GetProcOrNil&<procedure(dst: UInt32; coord: UInt32; swizzle: SwizzleOp)>(z_PassTexCoordATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PassTexCoordATI(dst: UInt32; coord: UInt32; swizzle: SwizzleOp) :=
    z_PassTexCoordATI_1(dst, coord, swizzle);
    
    private z_SampleMapATI_adr := GetProcAddress('glSampleMapATI');
    private z_SampleMapATI_1 := GetProcOrNil&<procedure(dst: UInt32; interp: UInt32; swizzle: SwizzleOp)>(z_SampleMapATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SampleMapATI(dst: UInt32; interp: UInt32; swizzle: SwizzleOp) :=
    z_SampleMapATI_1(dst, interp, swizzle);
    
    private z_ColorFragmentOp1ATI_adr := GetProcAddress('glColorFragmentOp1ATI');
    private z_ColorFragmentOp1ATI_1 := GetProcOrNil&<procedure(op: FragmentOp; dst: UInt32; dstMask: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32)>(z_ColorFragmentOp1ATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorFragmentOp1ATI(op: FragmentOp; dst: UInt32; dstMask: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32) :=
    z_ColorFragmentOp1ATI_1(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod);
    
    private z_ColorFragmentOp2ATI_adr := GetProcAddress('glColorFragmentOp2ATI');
    private z_ColorFragmentOp2ATI_1 := GetProcOrNil&<procedure(op: FragmentOp; dst: UInt32; dstMask: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32; arg2: UInt32; arg2Rep: UInt32; arg2Mod: UInt32)>(z_ColorFragmentOp2ATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorFragmentOp2ATI(op: FragmentOp; dst: UInt32; dstMask: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32; arg2: UInt32; arg2Rep: UInt32; arg2Mod: UInt32) :=
    z_ColorFragmentOp2ATI_1(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
    
    private z_ColorFragmentOp3ATI_adr := GetProcAddress('glColorFragmentOp3ATI');
    private z_ColorFragmentOp3ATI_1 := GetProcOrNil&<procedure(op: FragmentOp; dst: UInt32; dstMask: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32; arg2: UInt32; arg2Rep: UInt32; arg2Mod: UInt32; arg3: UInt32; arg3Rep: UInt32; arg3Mod: UInt32)>(z_ColorFragmentOp3ATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorFragmentOp3ATI(op: FragmentOp; dst: UInt32; dstMask: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32; arg2: UInt32; arg2Rep: UInt32; arg2Mod: UInt32; arg3: UInt32; arg3Rep: UInt32; arg3Mod: UInt32) :=
    z_ColorFragmentOp3ATI_1(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
    
    private z_AlphaFragmentOp1ATI_adr := GetProcAddress('glAlphaFragmentOp1ATI');
    private z_AlphaFragmentOp1ATI_1 := GetProcOrNil&<procedure(op: FragmentOp; dst: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32)>(z_AlphaFragmentOp1ATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AlphaFragmentOp1ATI(op: FragmentOp; dst: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32) :=
    z_AlphaFragmentOp1ATI_1(op, dst, dstMod, arg1, arg1Rep, arg1Mod);
    
    private z_AlphaFragmentOp2ATI_adr := GetProcAddress('glAlphaFragmentOp2ATI');
    private z_AlphaFragmentOp2ATI_1 := GetProcOrNil&<procedure(op: FragmentOp; dst: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32; arg2: UInt32; arg2Rep: UInt32; arg2Mod: UInt32)>(z_AlphaFragmentOp2ATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AlphaFragmentOp2ATI(op: FragmentOp; dst: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32; arg2: UInt32; arg2Rep: UInt32; arg2Mod: UInt32) :=
    z_AlphaFragmentOp2ATI_1(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
    
    private z_AlphaFragmentOp3ATI_adr := GetProcAddress('glAlphaFragmentOp3ATI');
    private z_AlphaFragmentOp3ATI_1 := GetProcOrNil&<procedure(op: FragmentOp; dst: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32; arg2: UInt32; arg2Rep: UInt32; arg2Mod: UInt32; arg3: UInt32; arg3Rep: UInt32; arg3Mod: UInt32)>(z_AlphaFragmentOp3ATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AlphaFragmentOp3ATI(op: FragmentOp; dst: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32; arg2: UInt32; arg2Rep: UInt32; arg2Mod: UInt32; arg3: UInt32; arg3Rep: UInt32; arg3Mod: UInt32) :=
    z_AlphaFragmentOp3ATI_1(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
    
    private z_SetFragmentShaderConstantATI_adr := GetProcAddress('glSetFragmentShaderConstantATI');
    private z_SetFragmentShaderConstantATI_1 := GetProcOrNil&<procedure(dst: UInt32; value: IntPtr)>(z_SetFragmentShaderConstantATI_adr);
    private z_SetFragmentShaderConstantATI_2 := GetProcOrNil&<procedure(dst: UInt32; var value: single)>(z_SetFragmentShaderConstantATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetFragmentShaderConstantATI(dst: UInt32; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_SetFragmentShaderConstantATI_2(dst, value[0]) else
        z_SetFragmentShaderConstantATI_2(dst, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetFragmentShaderConstantATI(dst: UInt32; var value: single) :=
    z_SetFragmentShaderConstantATI_2(dst, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetFragmentShaderConstantATI(dst: UInt32; value: IntPtr) :=
    z_SetFragmentShaderConstantATI_1(dst, value);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glMapObjectBufferATI = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ati_map_object_buffer';
    
    private z_MapObjectBufferATI_adr := GetProcAddress('glMapObjectBufferATI');
    private z_MapObjectBufferATI_1 := GetProcOrNil&<function(buffer: gl_buffer): IntPtr>(z_MapObjectBufferATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapObjectBufferATI(buffer: gl_buffer): IntPtr :=
    z_MapObjectBufferATI_1(buffer);
    
    private z_UnmapObjectBufferATI_adr := GetProcAddress('glUnmapObjectBufferATI');
    private z_UnmapObjectBufferATI_1 := GetProcOrNil&<procedure(buffer: gl_buffer)>(z_UnmapObjectBufferATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UnmapObjectBufferATI(buffer: gl_buffer) :=
    z_UnmapObjectBufferATI_1(buffer);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glPnTrianglesATI = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ati_pn_triangles';
    
    private z_PNTrianglesiATI_adr := GetProcAddress('glPNTrianglesiATI');
    private z_PNTrianglesiATI_1 := GetProcOrNil&<procedure(pname: PNTrianglesPName; param: Int32)>(z_PNTrianglesiATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PNTrianglesiATI(pname: PNTrianglesPName; param: Int32) :=
    z_PNTrianglesiATI_1(pname, param);
    
    private z_PNTrianglesfATI_adr := GetProcAddress('glPNTrianglesfATI');
    private z_PNTrianglesfATI_1 := GetProcOrNil&<procedure(pname: PNTrianglesPName; param: single)>(z_PNTrianglesfATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PNTrianglesfATI(pname: PNTrianglesPName; param: single) :=
    z_PNTrianglesfATI_1(pname, param);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glSeparateStencilATI = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ati_separate_stencil';
    
    private z_StencilOpSeparateATI_adr := GetProcAddress('glStencilOpSeparateATI');
    private z_StencilOpSeparateATI_1 := GetProcOrNil&<procedure(face: MaterialFace; sfail: StencilOp; dpfail: StencilOp; dppass: StencilOp)>(z_StencilOpSeparateATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilOpSeparateATI(face: MaterialFace; sfail: StencilOp; dpfail: StencilOp; dppass: StencilOp) :=
    z_StencilOpSeparateATI_1(face, sfail, dpfail, dppass);
    
    private z_StencilFuncSeparateATI_adr := GetProcAddress('glStencilFuncSeparateATI');
    private z_StencilFuncSeparateATI_1 := GetProcOrNil&<procedure(frontfunc: StencilFunction; backfunc: StencilFunction; ref: Int32; mask: UInt32)>(z_StencilFuncSeparateATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilFuncSeparateATI(frontfunc: StencilFunction; backfunc: StencilFunction; ref: Int32; mask: UInt32) :=
    z_StencilFuncSeparateATI_1(frontfunc, backfunc, ref, mask);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glVertexArrayObjectATI = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ati_vertex_array_object';
    
    private z_NewObjectBufferATI_adr := GetProcAddress('glNewObjectBufferATI');
    private z_NewObjectBufferATI_1 := GetProcOrNil&<function(size: Int32; pointer: IntPtr; usage: ArrayObjectUsage): UInt32>(z_NewObjectBufferATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function NewObjectBufferATI(size: Int32; pointer: IntPtr; usage: ArrayObjectUsage): UInt32 :=
    z_NewObjectBufferATI_1(size, pointer, usage);
    
    private z_IsObjectBufferATI_adr := GetProcAddress('glIsObjectBufferATI');
    private z_IsObjectBufferATI_1 := GetProcOrNil&<function(buffer: gl_buffer): boolean>(z_IsObjectBufferATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsObjectBufferATI(buffer: gl_buffer): boolean :=
    z_IsObjectBufferATI_1(buffer);
    
    private z_UpdateObjectBufferATI_adr := GetProcAddress('glUpdateObjectBufferATI');
    private z_UpdateObjectBufferATI_1 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: UInt32; size: Int32; pointer: IntPtr; preserve: PreserveMode)>(z_UpdateObjectBufferATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UpdateObjectBufferATI(buffer: gl_buffer; offset: UInt32; size: Int32; pointer: IntPtr; preserve: PreserveMode) :=
    z_UpdateObjectBufferATI_1(buffer, offset, size, pointer, preserve);
    
    private z_GetObjectBufferfvATI_adr := GetProcAddress('glGetObjectBufferfvATI');
    private z_GetObjectBufferfvATI_1 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: ArrayObjectPName; &params: IntPtr)>(z_GetObjectBufferfvATI_adr);
    private z_GetObjectBufferfvATI_2 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: ArrayObjectPName; var &params: single)>(z_GetObjectBufferfvATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectBufferfvATI(buffer: gl_buffer; pname: ArrayObjectPName; var &params: single) :=
    z_GetObjectBufferfvATI_2(buffer, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectBufferfvATI(buffer: gl_buffer; pname: ArrayObjectPName; &params: IntPtr) :=
    z_GetObjectBufferfvATI_1(buffer, pname, &params);
    
    private z_GetObjectBufferivATI_adr := GetProcAddress('glGetObjectBufferivATI');
    private z_GetObjectBufferivATI_1 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: ArrayObjectPName; &params: IntPtr)>(z_GetObjectBufferivATI_adr);
    private z_GetObjectBufferivATI_2 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: ArrayObjectPName; var &params: Int32)>(z_GetObjectBufferivATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectBufferivATI(buffer: gl_buffer; pname: ArrayObjectPName; var &params: Int32) :=
    z_GetObjectBufferivATI_2(buffer, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectBufferivATI(buffer: gl_buffer; pname: ArrayObjectPName; &params: IntPtr) :=
    z_GetObjectBufferivATI_1(buffer, pname, &params);
    
    private z_FreeObjectBufferATI_adr := GetProcAddress('glFreeObjectBufferATI');
    private z_FreeObjectBufferATI_1 := GetProcOrNil&<procedure(buffer: gl_buffer)>(z_FreeObjectBufferATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FreeObjectBufferATI(buffer: gl_buffer) :=
    z_FreeObjectBufferATI_1(buffer);
    
    private z_ArrayObjectATI_adr := GetProcAddress('glArrayObjectATI');
    private z_ArrayObjectATI_1 := GetProcOrNil&<procedure(&array: EnableCap; size: Int32; &type: ScalarType; stride: Int32; buffer: gl_buffer; offset: UInt32)>(z_ArrayObjectATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ArrayObjectATI(&array: EnableCap; size: Int32; &type: ScalarType; stride: Int32; buffer: gl_buffer; offset: UInt32) :=
    z_ArrayObjectATI_1(&array, size, &type, stride, buffer, offset);
    
    private z_GetArrayObjectfvATI_adr := GetProcAddress('glGetArrayObjectfvATI');
    private z_GetArrayObjectfvATI_1 := GetProcOrNil&<procedure(&array: EnableCap; pname: ArrayObjectPName; &params: IntPtr)>(z_GetArrayObjectfvATI_adr);
    private z_GetArrayObjectfvATI_2 := GetProcOrNil&<procedure(&array: EnableCap; pname: ArrayObjectPName; var &params: single)>(z_GetArrayObjectfvATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetArrayObjectfvATI(&array: EnableCap; pname: ArrayObjectPName; var &params: single) :=
    z_GetArrayObjectfvATI_2(&array, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetArrayObjectfvATI(&array: EnableCap; pname: ArrayObjectPName; &params: IntPtr) :=
    z_GetArrayObjectfvATI_1(&array, pname, &params);
    
    private z_GetArrayObjectivATI_adr := GetProcAddress('glGetArrayObjectivATI');
    private z_GetArrayObjectivATI_1 := GetProcOrNil&<procedure(&array: EnableCap; pname: ArrayObjectPName; &params: IntPtr)>(z_GetArrayObjectivATI_adr);
    private z_GetArrayObjectivATI_2 := GetProcOrNil&<procedure(&array: EnableCap; pname: ArrayObjectPName; var &params: Int32)>(z_GetArrayObjectivATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetArrayObjectivATI(&array: EnableCap; pname: ArrayObjectPName; var &params: Int32) :=
    z_GetArrayObjectivATI_2(&array, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetArrayObjectivATI(&array: EnableCap; pname: ArrayObjectPName; &params: IntPtr) :=
    z_GetArrayObjectivATI_1(&array, pname, &params);
    
    private z_VariantArrayObjectATI_adr := GetProcAddress('glVariantArrayObjectATI');
    private z_VariantArrayObjectATI_1 := GetProcOrNil&<procedure(id: UInt32; &type: ScalarType; stride: Int32; buffer: gl_buffer; offset: UInt32)>(z_VariantArrayObjectATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantArrayObjectATI(id: UInt32; &type: ScalarType; stride: Int32; buffer: gl_buffer; offset: UInt32) :=
    z_VariantArrayObjectATI_1(id, &type, stride, buffer, offset);
    
    private z_GetVariantArrayObjectfvATI_adr := GetProcAddress('glGetVariantArrayObjectfvATI');
    private z_GetVariantArrayObjectfvATI_1 := GetProcOrNil&<procedure(id: UInt32; pname: ArrayObjectPName; &params: IntPtr)>(z_GetVariantArrayObjectfvATI_adr);
    private z_GetVariantArrayObjectfvATI_2 := GetProcOrNil&<procedure(id: UInt32; pname: ArrayObjectPName; var &params: single)>(z_GetVariantArrayObjectfvATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantArrayObjectfvATI(id: UInt32; pname: ArrayObjectPName; var &params: single) :=
    z_GetVariantArrayObjectfvATI_2(id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantArrayObjectfvATI(id: UInt32; pname: ArrayObjectPName; &params: IntPtr) :=
    z_GetVariantArrayObjectfvATI_1(id, pname, &params);
    
    private z_GetVariantArrayObjectivATI_adr := GetProcAddress('glGetVariantArrayObjectivATI');
    private z_GetVariantArrayObjectivATI_1 := GetProcOrNil&<procedure(id: UInt32; pname: ArrayObjectPName; &params: IntPtr)>(z_GetVariantArrayObjectivATI_adr);
    private z_GetVariantArrayObjectivATI_2 := GetProcOrNil&<procedure(id: UInt32; pname: ArrayObjectPName; var &params: Int32)>(z_GetVariantArrayObjectivATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantArrayObjectivATI(id: UInt32; pname: ArrayObjectPName; var &params: Int32) :=
    z_GetVariantArrayObjectivATI_2(id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantArrayObjectivATI(id: UInt32; pname: ArrayObjectPName; &params: IntPtr) :=
    z_GetVariantArrayObjectivATI_1(id, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glVertexAttribArrayObjectATI = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ati_vertex_attrib_array_object';
    
    private z_VertexAttribArrayObjectATI_adr := GetProcAddress('glVertexAttribArrayObjectATI');
    private z_VertexAttribArrayObjectATI_1 := GetProcOrNil&<procedure(index: UInt32; size: Int32; &type: VertexAttribPointerType; normalized: boolean; stride: Int32; buffer: gl_buffer; offset: UInt32)>(z_VertexAttribArrayObjectATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribArrayObjectATI(index: UInt32; size: Int32; &type: VertexAttribPointerType; normalized: boolean; stride: Int32; buffer: gl_buffer; offset: UInt32) :=
    z_VertexAttribArrayObjectATI_1(index, size, &type, normalized, stride, buffer, offset);
    
    private z_GetVertexAttribArrayObjectfvATI_adr := GetProcAddress('glGetVertexAttribArrayObjectfvATI');
    private z_GetVertexAttribArrayObjectfvATI_1 := GetProcOrNil&<procedure(index: UInt32; pname: ArrayObjectPName; &params: IntPtr)>(z_GetVertexAttribArrayObjectfvATI_adr);
    private z_GetVertexAttribArrayObjectfvATI_2 := GetProcOrNil&<procedure(index: UInt32; pname: ArrayObjectPName; var &params: single)>(z_GetVertexAttribArrayObjectfvATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribArrayObjectfvATI(index: UInt32; pname: ArrayObjectPName; var &params: single) :=
    z_GetVertexAttribArrayObjectfvATI_2(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribArrayObjectfvATI(index: UInt32; pname: ArrayObjectPName; &params: IntPtr) :=
    z_GetVertexAttribArrayObjectfvATI_1(index, pname, &params);
    
    private z_GetVertexAttribArrayObjectivATI_adr := GetProcAddress('glGetVertexAttribArrayObjectivATI');
    private z_GetVertexAttribArrayObjectivATI_1 := GetProcOrNil&<procedure(index: UInt32; pname: ArrayObjectPName; &params: IntPtr)>(z_GetVertexAttribArrayObjectivATI_adr);
    private z_GetVertexAttribArrayObjectivATI_2 := GetProcOrNil&<procedure(index: UInt32; pname: ArrayObjectPName; var &params: Int32)>(z_GetVertexAttribArrayObjectivATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribArrayObjectivATI(index: UInt32; pname: ArrayObjectPName; var &params: Int32) :=
    z_GetVertexAttribArrayObjectivATI_2(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribArrayObjectivATI(index: UInt32; pname: ArrayObjectPName; &params: IntPtr) :=
    z_GetVertexAttribArrayObjectivATI_1(index, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glVertexStreamsATI = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ati_vertex_streams';
    
    private z_VertexStream1sATI_adr := GetProcAddress('glVertexStream1sATI');
    private z_VertexStream1sATI_1 := GetProcOrNil&<procedure(stream: VertexStream; x: Int16)>(z_VertexStream1sATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1sATI(stream: VertexStream; x: Int16) :=
    z_VertexStream1sATI_1(stream, x);
    
    private z_VertexStream1svATI_adr := GetProcAddress('glVertexStream1svATI');
    private z_VertexStream1svATI_1 := GetProcOrNil&<procedure(stream: VertexStream; coords: IntPtr)>(z_VertexStream1svATI_adr);
    private z_VertexStream1svATI_2 := GetProcOrNil&<procedure(stream: VertexStream; var coords: Int16)>(z_VertexStream1svATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1svATI(stream: VertexStream; coords: array of Int16);
    type PInt16=^Int16;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_VertexStream1svATI_2(stream, coords[0]) else
        z_VertexStream1svATI_2(stream, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1svATI(stream: VertexStream; var coords: Int16) :=
    z_VertexStream1svATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1svATI(stream: VertexStream; coords: IntPtr) :=
    z_VertexStream1svATI_1(stream, coords);
    
    private z_VertexStream1iATI_adr := GetProcAddress('glVertexStream1iATI');
    private z_VertexStream1iATI_1 := GetProcOrNil&<procedure(stream: VertexStream; x: Int32)>(z_VertexStream1iATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1iATI(stream: VertexStream; x: Int32) :=
    z_VertexStream1iATI_1(stream, x);
    
    private z_VertexStream1ivATI_adr := GetProcAddress('glVertexStream1ivATI');
    private z_VertexStream1ivATI_1 := GetProcOrNil&<procedure(stream: VertexStream; coords: IntPtr)>(z_VertexStream1ivATI_adr);
    private z_VertexStream1ivATI_2 := GetProcOrNil&<procedure(stream: VertexStream; var coords: Int32)>(z_VertexStream1ivATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1ivATI(stream: VertexStream; coords: array of Int32);
    type PInt32=^Int32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_VertexStream1ivATI_2(stream, coords[0]) else
        z_VertexStream1ivATI_2(stream, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1ivATI(stream: VertexStream; var coords: Int32) :=
    z_VertexStream1ivATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1ivATI(stream: VertexStream; coords: IntPtr) :=
    z_VertexStream1ivATI_1(stream, coords);
    
    private z_VertexStream1fATI_adr := GetProcAddress('glVertexStream1fATI');
    private z_VertexStream1fATI_1 := GetProcOrNil&<procedure(stream: VertexStream; x: single)>(z_VertexStream1fATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1fATI(stream: VertexStream; x: single) :=
    z_VertexStream1fATI_1(stream, x);
    
    private z_VertexStream1fvATI_adr := GetProcAddress('glVertexStream1fvATI');
    private z_VertexStream1fvATI_1 := GetProcOrNil&<procedure(stream: VertexStream; coords: IntPtr)>(z_VertexStream1fvATI_adr);
    private z_VertexStream1fvATI_2 := GetProcOrNil&<procedure(stream: VertexStream; var coords: single)>(z_VertexStream1fvATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1fvATI(stream: VertexStream; coords: array of single);
    type Psingle=^single;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_VertexStream1fvATI_2(stream, coords[0]) else
        z_VertexStream1fvATI_2(stream, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1fvATI(stream: VertexStream; var coords: single) :=
    z_VertexStream1fvATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1fvATI(stream: VertexStream; coords: IntPtr) :=
    z_VertexStream1fvATI_1(stream, coords);
    
    private z_VertexStream1dATI_adr := GetProcAddress('glVertexStream1dATI');
    private z_VertexStream1dATI_1 := GetProcOrNil&<procedure(stream: VertexStream; x: real)>(z_VertexStream1dATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1dATI(stream: VertexStream; x: real) :=
    z_VertexStream1dATI_1(stream, x);
    
    private z_VertexStream1dvATI_adr := GetProcAddress('glVertexStream1dvATI');
    private z_VertexStream1dvATI_1 := GetProcOrNil&<procedure(stream: VertexStream; coords: IntPtr)>(z_VertexStream1dvATI_adr);
    private z_VertexStream1dvATI_2 := GetProcOrNil&<procedure(stream: VertexStream; var coords: real)>(z_VertexStream1dvATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1dvATI(stream: VertexStream; coords: array of real);
    type Preal=^real;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_VertexStream1dvATI_2(stream, coords[0]) else
        z_VertexStream1dvATI_2(stream, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1dvATI(stream: VertexStream; var coords: real) :=
    z_VertexStream1dvATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1dvATI(stream: VertexStream; coords: IntPtr) :=
    z_VertexStream1dvATI_1(stream, coords);
    
    private z_VertexStream2sATI_adr := GetProcAddress('glVertexStream2sATI');
    private z_VertexStream2sATI_1 := GetProcOrNil&<procedure(stream: VertexStream; x: Int16; y: Int16)>(z_VertexStream2sATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2sATI(stream: VertexStream; x: Int16; y: Int16) :=
    z_VertexStream2sATI_1(stream, x, y);
    
    private z_VertexStream2svATI_adr := GetProcAddress('glVertexStream2svATI');
    private z_VertexStream2svATI_1 := GetProcOrNil&<procedure(stream: VertexStream; coords: IntPtr)>(z_VertexStream2svATI_adr);
    private z_VertexStream2svATI_2 := GetProcOrNil&<procedure(stream: VertexStream; var coords: Int16)>(z_VertexStream2svATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2svATI(stream: VertexStream; coords: array of Int16);
    type PInt16=^Int16;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_VertexStream2svATI_2(stream, coords[0]) else
        z_VertexStream2svATI_2(stream, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2svATI(stream: VertexStream; var coords: Int16) :=
    z_VertexStream2svATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2svATI(stream: VertexStream; coords: IntPtr) :=
    z_VertexStream2svATI_1(stream, coords);
    
    private z_VertexStream2iATI_adr := GetProcAddress('glVertexStream2iATI');
    private z_VertexStream2iATI_1 := GetProcOrNil&<procedure(stream: VertexStream; x: Int32; y: Int32)>(z_VertexStream2iATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2iATI(stream: VertexStream; x: Int32; y: Int32) :=
    z_VertexStream2iATI_1(stream, x, y);
    
    private z_VertexStream2ivATI_adr := GetProcAddress('glVertexStream2ivATI');
    private z_VertexStream2ivATI_1 := GetProcOrNil&<procedure(stream: VertexStream; coords: IntPtr)>(z_VertexStream2ivATI_adr);
    private z_VertexStream2ivATI_2 := GetProcOrNil&<procedure(stream: VertexStream; var coords: Int32)>(z_VertexStream2ivATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2ivATI(stream: VertexStream; coords: array of Int32);
    type PInt32=^Int32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_VertexStream2ivATI_2(stream, coords[0]) else
        z_VertexStream2ivATI_2(stream, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2ivATI(stream: VertexStream; var coords: Int32) :=
    z_VertexStream2ivATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2ivATI(stream: VertexStream; coords: IntPtr) :=
    z_VertexStream2ivATI_1(stream, coords);
    
    private z_VertexStream2fATI_adr := GetProcAddress('glVertexStream2fATI');
    private z_VertexStream2fATI_1 := GetProcOrNil&<procedure(stream: VertexStream; x: single; y: single)>(z_VertexStream2fATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2fATI(stream: VertexStream; x: single; y: single) :=
    z_VertexStream2fATI_1(stream, x, y);
    
    private z_VertexStream2fvATI_adr := GetProcAddress('glVertexStream2fvATI');
    private z_VertexStream2fvATI_1 := GetProcOrNil&<procedure(stream: VertexStream; coords: IntPtr)>(z_VertexStream2fvATI_adr);
    private z_VertexStream2fvATI_2 := GetProcOrNil&<procedure(stream: VertexStream; var coords: single)>(z_VertexStream2fvATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2fvATI(stream: VertexStream; coords: array of single);
    type Psingle=^single;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_VertexStream2fvATI_2(stream, coords[0]) else
        z_VertexStream2fvATI_2(stream, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2fvATI(stream: VertexStream; var coords: single) :=
    z_VertexStream2fvATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2fvATI(stream: VertexStream; coords: IntPtr) :=
    z_VertexStream2fvATI_1(stream, coords);
    
    private z_VertexStream2dATI_adr := GetProcAddress('glVertexStream2dATI');
    private z_VertexStream2dATI_1 := GetProcOrNil&<procedure(stream: VertexStream; x: real; y: real)>(z_VertexStream2dATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2dATI(stream: VertexStream; x: real; y: real) :=
    z_VertexStream2dATI_1(stream, x, y);
    
    private z_VertexStream2dvATI_adr := GetProcAddress('glVertexStream2dvATI');
    private z_VertexStream2dvATI_1 := GetProcOrNil&<procedure(stream: VertexStream; coords: IntPtr)>(z_VertexStream2dvATI_adr);
    private z_VertexStream2dvATI_2 := GetProcOrNil&<procedure(stream: VertexStream; var coords: real)>(z_VertexStream2dvATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2dvATI(stream: VertexStream; coords: array of real);
    type Preal=^real;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_VertexStream2dvATI_2(stream, coords[0]) else
        z_VertexStream2dvATI_2(stream, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2dvATI(stream: VertexStream; var coords: real) :=
    z_VertexStream2dvATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2dvATI(stream: VertexStream; coords: IntPtr) :=
    z_VertexStream2dvATI_1(stream, coords);
    
    private z_VertexStream3sATI_adr := GetProcAddress('glVertexStream3sATI');
    private z_VertexStream3sATI_1 := GetProcOrNil&<procedure(stream: VertexStream; x: Int16; y: Int16; z: Int16)>(z_VertexStream3sATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3sATI(stream: VertexStream; x: Int16; y: Int16; z: Int16) :=
    z_VertexStream3sATI_1(stream, x, y, z);
    
    private z_VertexStream3svATI_adr := GetProcAddress('glVertexStream3svATI');
    private z_VertexStream3svATI_1 := GetProcOrNil&<procedure(stream: VertexStream; coords: IntPtr)>(z_VertexStream3svATI_adr);
    private z_VertexStream3svATI_2 := GetProcOrNil&<procedure(stream: VertexStream; var coords: Int16)>(z_VertexStream3svATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3svATI(stream: VertexStream; coords: array of Int16);
    type PInt16=^Int16;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_VertexStream3svATI_2(stream, coords[0]) else
        z_VertexStream3svATI_2(stream, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3svATI(stream: VertexStream; var coords: Int16) :=
    z_VertexStream3svATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3svATI(stream: VertexStream; coords: IntPtr) :=
    z_VertexStream3svATI_1(stream, coords);
    
    private z_VertexStream3iATI_adr := GetProcAddress('glVertexStream3iATI');
    private z_VertexStream3iATI_1 := GetProcOrNil&<procedure(stream: VertexStream; x: Int32; y: Int32; z: Int32)>(z_VertexStream3iATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3iATI(stream: VertexStream; x: Int32; y: Int32; z: Int32) :=
    z_VertexStream3iATI_1(stream, x, y, z);
    
    private z_VertexStream3ivATI_adr := GetProcAddress('glVertexStream3ivATI');
    private z_VertexStream3ivATI_1 := GetProcOrNil&<procedure(stream: VertexStream; coords: IntPtr)>(z_VertexStream3ivATI_adr);
    private z_VertexStream3ivATI_2 := GetProcOrNil&<procedure(stream: VertexStream; var coords: Int32)>(z_VertexStream3ivATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3ivATI(stream: VertexStream; coords: array of Int32);
    type PInt32=^Int32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_VertexStream3ivATI_2(stream, coords[0]) else
        z_VertexStream3ivATI_2(stream, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3ivATI(stream: VertexStream; var coords: Int32) :=
    z_VertexStream3ivATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3ivATI(stream: VertexStream; coords: IntPtr) :=
    z_VertexStream3ivATI_1(stream, coords);
    
    private z_VertexStream3fATI_adr := GetProcAddress('glVertexStream3fATI');
    private z_VertexStream3fATI_1 := GetProcOrNil&<procedure(stream: VertexStream; x: single; y: single; z: single)>(z_VertexStream3fATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3fATI(stream: VertexStream; x: single; y: single; z: single) :=
    z_VertexStream3fATI_1(stream, x, y, z);
    
    private z_VertexStream3fvATI_adr := GetProcAddress('glVertexStream3fvATI');
    private z_VertexStream3fvATI_1 := GetProcOrNil&<procedure(stream: VertexStream; coords: IntPtr)>(z_VertexStream3fvATI_adr);
    private z_VertexStream3fvATI_2 := GetProcOrNil&<procedure(stream: VertexStream; var coords: single)>(z_VertexStream3fvATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3fvATI(stream: VertexStream; coords: array of single);
    type Psingle=^single;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_VertexStream3fvATI_2(stream, coords[0]) else
        z_VertexStream3fvATI_2(stream, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3fvATI(stream: VertexStream; var coords: single) :=
    z_VertexStream3fvATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3fvATI(stream: VertexStream; coords: IntPtr) :=
    z_VertexStream3fvATI_1(stream, coords);
    
    private z_VertexStream3dATI_adr := GetProcAddress('glVertexStream3dATI');
    private z_VertexStream3dATI_1 := GetProcOrNil&<procedure(stream: VertexStream; x: real; y: real; z: real)>(z_VertexStream3dATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3dATI(stream: VertexStream; x: real; y: real; z: real) :=
    z_VertexStream3dATI_1(stream, x, y, z);
    
    private z_VertexStream3dvATI_adr := GetProcAddress('glVertexStream3dvATI');
    private z_VertexStream3dvATI_1 := GetProcOrNil&<procedure(stream: VertexStream; coords: IntPtr)>(z_VertexStream3dvATI_adr);
    private z_VertexStream3dvATI_2 := GetProcOrNil&<procedure(stream: VertexStream; var coords: real)>(z_VertexStream3dvATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3dvATI(stream: VertexStream; coords: array of real);
    type Preal=^real;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_VertexStream3dvATI_2(stream, coords[0]) else
        z_VertexStream3dvATI_2(stream, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3dvATI(stream: VertexStream; var coords: real) :=
    z_VertexStream3dvATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3dvATI(stream: VertexStream; coords: IntPtr) :=
    z_VertexStream3dvATI_1(stream, coords);
    
    private z_VertexStream4sATI_adr := GetProcAddress('glVertexStream4sATI');
    private z_VertexStream4sATI_1 := GetProcOrNil&<procedure(stream: VertexStream; x: Int16; y: Int16; z: Int16; w: Int16)>(z_VertexStream4sATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4sATI(stream: VertexStream; x: Int16; y: Int16; z: Int16; w: Int16) :=
    z_VertexStream4sATI_1(stream, x, y, z, w);
    
    private z_VertexStream4svATI_adr := GetProcAddress('glVertexStream4svATI');
    private z_VertexStream4svATI_1 := GetProcOrNil&<procedure(stream: VertexStream; coords: IntPtr)>(z_VertexStream4svATI_adr);
    private z_VertexStream4svATI_2 := GetProcOrNil&<procedure(stream: VertexStream; var coords: Int16)>(z_VertexStream4svATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4svATI(stream: VertexStream; coords: array of Int16);
    type PInt16=^Int16;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_VertexStream4svATI_2(stream, coords[0]) else
        z_VertexStream4svATI_2(stream, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4svATI(stream: VertexStream; var coords: Int16) :=
    z_VertexStream4svATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4svATI(stream: VertexStream; coords: IntPtr) :=
    z_VertexStream4svATI_1(stream, coords);
    
    private z_VertexStream4iATI_adr := GetProcAddress('glVertexStream4iATI');
    private z_VertexStream4iATI_1 := GetProcOrNil&<procedure(stream: VertexStream; x: Int32; y: Int32; z: Int32; w: Int32)>(z_VertexStream4iATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4iATI(stream: VertexStream; x: Int32; y: Int32; z: Int32; w: Int32) :=
    z_VertexStream4iATI_1(stream, x, y, z, w);
    
    private z_VertexStream4ivATI_adr := GetProcAddress('glVertexStream4ivATI');
    private z_VertexStream4ivATI_1 := GetProcOrNil&<procedure(stream: VertexStream; coords: IntPtr)>(z_VertexStream4ivATI_adr);
    private z_VertexStream4ivATI_2 := GetProcOrNil&<procedure(stream: VertexStream; var coords: Int32)>(z_VertexStream4ivATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4ivATI(stream: VertexStream; coords: array of Int32);
    type PInt32=^Int32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_VertexStream4ivATI_2(stream, coords[0]) else
        z_VertexStream4ivATI_2(stream, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4ivATI(stream: VertexStream; var coords: Int32) :=
    z_VertexStream4ivATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4ivATI(stream: VertexStream; coords: IntPtr) :=
    z_VertexStream4ivATI_1(stream, coords);
    
    private z_VertexStream4fATI_adr := GetProcAddress('glVertexStream4fATI');
    private z_VertexStream4fATI_1 := GetProcOrNil&<procedure(stream: VertexStream; x: single; y: single; z: single; w: single)>(z_VertexStream4fATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4fATI(stream: VertexStream; x: single; y: single; z: single; w: single) :=
    z_VertexStream4fATI_1(stream, x, y, z, w);
    
    private z_VertexStream4fvATI_adr := GetProcAddress('glVertexStream4fvATI');
    private z_VertexStream4fvATI_1 := GetProcOrNil&<procedure(stream: VertexStream; coords: IntPtr)>(z_VertexStream4fvATI_adr);
    private z_VertexStream4fvATI_2 := GetProcOrNil&<procedure(stream: VertexStream; var coords: single)>(z_VertexStream4fvATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4fvATI(stream: VertexStream; coords: array of single);
    type Psingle=^single;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_VertexStream4fvATI_2(stream, coords[0]) else
        z_VertexStream4fvATI_2(stream, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4fvATI(stream: VertexStream; var coords: single) :=
    z_VertexStream4fvATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4fvATI(stream: VertexStream; coords: IntPtr) :=
    z_VertexStream4fvATI_1(stream, coords);
    
    private z_VertexStream4dATI_adr := GetProcAddress('glVertexStream4dATI');
    private z_VertexStream4dATI_1 := GetProcOrNil&<procedure(stream: VertexStream; x: real; y: real; z: real; w: real)>(z_VertexStream4dATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4dATI(stream: VertexStream; x: real; y: real; z: real; w: real) :=
    z_VertexStream4dATI_1(stream, x, y, z, w);
    
    private z_VertexStream4dvATI_adr := GetProcAddress('glVertexStream4dvATI');
    private z_VertexStream4dvATI_1 := GetProcOrNil&<procedure(stream: VertexStream; coords: IntPtr)>(z_VertexStream4dvATI_adr);
    private z_VertexStream4dvATI_2 := GetProcOrNil&<procedure(stream: VertexStream; var coords: real)>(z_VertexStream4dvATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4dvATI(stream: VertexStream; coords: array of real);
    type Preal=^real;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_VertexStream4dvATI_2(stream, coords[0]) else
        z_VertexStream4dvATI_2(stream, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4dvATI(stream: VertexStream; var coords: real) :=
    z_VertexStream4dvATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4dvATI(stream: VertexStream; coords: IntPtr) :=
    z_VertexStream4dvATI_1(stream, coords);
    
    private z_NormalStream3bATI_adr := GetProcAddress('glNormalStream3bATI');
    private z_NormalStream3bATI_1 := GetProcOrNil&<procedure(stream: VertexStream; nx: SByte; ny: SByte; nz: SByte)>(z_NormalStream3bATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3bATI(stream: VertexStream; nx: SByte; ny: SByte; nz: SByte) :=
    z_NormalStream3bATI_1(stream, nx, ny, nz);
    
    private z_NormalStream3bvATI_adr := GetProcAddress('glNormalStream3bvATI');
    private z_NormalStream3bvATI_1 := GetProcOrNil&<procedure(stream: VertexStream; coords: IntPtr)>(z_NormalStream3bvATI_adr);
    private z_NormalStream3bvATI_2 := GetProcOrNil&<procedure(stream: VertexStream; var coords: SByte)>(z_NormalStream3bvATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3bvATI(stream: VertexStream; coords: array of SByte);
    type PSByte=^SByte;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_NormalStream3bvATI_2(stream, coords[0]) else
        z_NormalStream3bvATI_2(stream, PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3bvATI(stream: VertexStream; var coords: SByte) :=
    z_NormalStream3bvATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3bvATI(stream: VertexStream; coords: IntPtr) :=
    z_NormalStream3bvATI_1(stream, coords);
    
    private z_NormalStream3sATI_adr := GetProcAddress('glNormalStream3sATI');
    private z_NormalStream3sATI_1 := GetProcOrNil&<procedure(stream: VertexStream; nx: Int16; ny: Int16; nz: Int16)>(z_NormalStream3sATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3sATI(stream: VertexStream; nx: Int16; ny: Int16; nz: Int16) :=
    z_NormalStream3sATI_1(stream, nx, ny, nz);
    
    private z_NormalStream3svATI_adr := GetProcAddress('glNormalStream3svATI');
    private z_NormalStream3svATI_1 := GetProcOrNil&<procedure(stream: VertexStream; coords: IntPtr)>(z_NormalStream3svATI_adr);
    private z_NormalStream3svATI_2 := GetProcOrNil&<procedure(stream: VertexStream; var coords: Int16)>(z_NormalStream3svATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3svATI(stream: VertexStream; coords: array of Int16);
    type PInt16=^Int16;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_NormalStream3svATI_2(stream, coords[0]) else
        z_NormalStream3svATI_2(stream, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3svATI(stream: VertexStream; var coords: Int16) :=
    z_NormalStream3svATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3svATI(stream: VertexStream; coords: IntPtr) :=
    z_NormalStream3svATI_1(stream, coords);
    
    private z_NormalStream3iATI_adr := GetProcAddress('glNormalStream3iATI');
    private z_NormalStream3iATI_1 := GetProcOrNil&<procedure(stream: VertexStream; nx: Int32; ny: Int32; nz: Int32)>(z_NormalStream3iATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3iATI(stream: VertexStream; nx: Int32; ny: Int32; nz: Int32) :=
    z_NormalStream3iATI_1(stream, nx, ny, nz);
    
    private z_NormalStream3ivATI_adr := GetProcAddress('glNormalStream3ivATI');
    private z_NormalStream3ivATI_1 := GetProcOrNil&<procedure(stream: VertexStream; coords: IntPtr)>(z_NormalStream3ivATI_adr);
    private z_NormalStream3ivATI_2 := GetProcOrNil&<procedure(stream: VertexStream; var coords: Int32)>(z_NormalStream3ivATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3ivATI(stream: VertexStream; coords: array of Int32);
    type PInt32=^Int32;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_NormalStream3ivATI_2(stream, coords[0]) else
        z_NormalStream3ivATI_2(stream, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3ivATI(stream: VertexStream; var coords: Int32) :=
    z_NormalStream3ivATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3ivATI(stream: VertexStream; coords: IntPtr) :=
    z_NormalStream3ivATI_1(stream, coords);
    
    private z_NormalStream3fATI_adr := GetProcAddress('glNormalStream3fATI');
    private z_NormalStream3fATI_1 := GetProcOrNil&<procedure(stream: VertexStream; nx: single; ny: single; nz: single)>(z_NormalStream3fATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3fATI(stream: VertexStream; nx: single; ny: single; nz: single) :=
    z_NormalStream3fATI_1(stream, nx, ny, nz);
    
    private z_NormalStream3fvATI_adr := GetProcAddress('glNormalStream3fvATI');
    private z_NormalStream3fvATI_1 := GetProcOrNil&<procedure(stream: VertexStream; coords: IntPtr)>(z_NormalStream3fvATI_adr);
    private z_NormalStream3fvATI_2 := GetProcOrNil&<procedure(stream: VertexStream; var coords: single)>(z_NormalStream3fvATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3fvATI(stream: VertexStream; coords: array of single);
    type Psingle=^single;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_NormalStream3fvATI_2(stream, coords[0]) else
        z_NormalStream3fvATI_2(stream, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3fvATI(stream: VertexStream; var coords: single) :=
    z_NormalStream3fvATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3fvATI(stream: VertexStream; coords: IntPtr) :=
    z_NormalStream3fvATI_1(stream, coords);
    
    private z_NormalStream3dATI_adr := GetProcAddress('glNormalStream3dATI');
    private z_NormalStream3dATI_1 := GetProcOrNil&<procedure(stream: VertexStream; nx: real; ny: real; nz: real)>(z_NormalStream3dATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3dATI(stream: VertexStream; nx: real; ny: real; nz: real) :=
    z_NormalStream3dATI_1(stream, nx, ny, nz);
    
    private z_NormalStream3dvATI_adr := GetProcAddress('glNormalStream3dvATI');
    private z_NormalStream3dvATI_1 := GetProcOrNil&<procedure(stream: VertexStream; coords: IntPtr)>(z_NormalStream3dvATI_adr);
    private z_NormalStream3dvATI_2 := GetProcOrNil&<procedure(stream: VertexStream; var coords: real)>(z_NormalStream3dvATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3dvATI(stream: VertexStream; coords: array of real);
    type Preal=^real;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_NormalStream3dvATI_2(stream, coords[0]) else
        z_NormalStream3dvATI_2(stream, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3dvATI(stream: VertexStream; var coords: real) :=
    z_NormalStream3dvATI_2(stream, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3dvATI(stream: VertexStream; coords: IntPtr) :=
    z_NormalStream3dvATI_1(stream, coords);
    
    private z_ClientActiveVertexStreamATI_adr := GetProcAddress('glClientActiveVertexStreamATI');
    private z_ClientActiveVertexStreamATI_1 := GetProcOrNil&<procedure(stream: VertexStream)>(z_ClientActiveVertexStreamATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientActiveVertexStreamATI(stream: VertexStream) :=
    z_ClientActiveVertexStreamATI_1(stream);
    
    private z_VertexBlendEnviATI_adr := GetProcAddress('glVertexBlendEnviATI');
    private z_VertexBlendEnviATI_1 := GetProcOrNil&<procedure(pname: VertexStream; param: Int32)>(z_VertexBlendEnviATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexBlendEnviATI(pname: VertexStream; param: Int32) :=
    z_VertexBlendEnviATI_1(pname, param);
    
    private z_VertexBlendEnvfATI_adr := GetProcAddress('glVertexBlendEnvfATI');
    private z_VertexBlendEnvfATI_1 := GetProcOrNil&<procedure(pname: VertexStream; param: single)>(z_VertexBlendEnvfATI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexBlendEnvfATI(pname: VertexStream; param: single) :=
    z_VertexBlendEnvfATI_1(pname, param);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glEGLImageStorageEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_egl_image_storage';
    
    private z_EGLImageTargetTexStorageEXT_adr := GetProcAddress('glEGLImageTargetTexStorageEXT');
    private z_EGLImageTargetTexStorageEXT_1 := GetProcOrNil&<procedure(target: DummyEnum; image: egl_image_OES; attrib_list: IntPtr)>(z_EGLImageTargetTexStorageEXT_adr);
    private z_EGLImageTargetTexStorageEXT_2 := GetProcOrNil&<procedure(target: DummyEnum; image: egl_image_OES; var attrib_list: Int32)>(z_EGLImageTargetTexStorageEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EGLImageTargetTexStorageEXT(target: DummyEnum; image: egl_image_OES; attrib_list: array of Int32);
    type PInt32=^Int32;
    begin
      if (attrib_list<>nil) and (attrib_list.Length<>0) then
        z_EGLImageTargetTexStorageEXT_2(target, image, attrib_list[0]) else
        z_EGLImageTargetTexStorageEXT_2(target, image, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EGLImageTargetTexStorageEXT(target: DummyEnum; image: egl_image_OES; var attrib_list: Int32) :=
    z_EGLImageTargetTexStorageEXT_2(target, image, attrib_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EGLImageTargetTexStorageEXT(target: DummyEnum; image: egl_image_OES; attrib_list: IntPtr) :=
    z_EGLImageTargetTexStorageEXT_1(target, image, attrib_list);
    
    private z_EGLImageTargetTextureStorageEXT_adr := GetProcAddress('glEGLImageTargetTextureStorageEXT');
    private z_EGLImageTargetTextureStorageEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; image: egl_image_OES; attrib_list: IntPtr)>(z_EGLImageTargetTextureStorageEXT_adr);
    private z_EGLImageTargetTextureStorageEXT_2 := GetProcOrNil&<procedure(texture: gl_texture; image: egl_image_OES; var attrib_list: Int32)>(z_EGLImageTargetTextureStorageEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EGLImageTargetTextureStorageEXT(texture: gl_texture; image: egl_image_OES; attrib_list: array of Int32);
    type PInt32=^Int32;
    begin
      if (attrib_list<>nil) and (attrib_list.Length<>0) then
        z_EGLImageTargetTextureStorageEXT_2(texture, image, attrib_list[0]) else
        z_EGLImageTargetTextureStorageEXT_2(texture, image, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EGLImageTargetTextureStorageEXT(texture: gl_texture; image: egl_image_OES; var attrib_list: Int32) :=
    z_EGLImageTargetTextureStorageEXT_2(texture, image, attrib_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EGLImageTargetTextureStorageEXT(texture: gl_texture; image: egl_image_OES; attrib_list: IntPtr) :=
    z_EGLImageTargetTextureStorageEXT_1(texture, image, attrib_list);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glBindableUniformEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_bindable_uniform';
    
    private z_UniformBufferEXT_adr := GetProcAddress('glUniformBufferEXT');
    private z_UniformBufferEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; buffer: gl_buffer)>(z_UniformBufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformBufferEXT(&program: gl_program; location: Int32; buffer: gl_buffer) :=
    z_UniformBufferEXT_1(&program, location, buffer);
    
    private z_GetUniformBufferSizeEXT_adr := GetProcAddress('glGetUniformBufferSizeEXT');
    private z_GetUniformBufferSizeEXT_1 := GetProcOrNil&<function(&program: gl_program; location: Int32): Int32>(z_GetUniformBufferSizeEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetUniformBufferSizeEXT(&program: gl_program; location: Int32): Int32 :=
    z_GetUniformBufferSizeEXT_1(&program, location);
    
    private z_GetUniformOffsetEXT_adr := GetProcAddress('glGetUniformOffsetEXT');
    private z_GetUniformOffsetEXT_1 := GetProcOrNil&<function(&program: gl_program; location: Int32): IntPtr>(z_GetUniformOffsetEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetUniformOffsetEXT(&program: gl_program; location: Int32): IntPtr :=
    z_GetUniformOffsetEXT_1(&program, location);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glBlendColorEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_blend_color';
    
    private z_BlendColorEXT_adr := GetProcAddress('glBlendColorEXT');
    private z_BlendColorEXT_1 := GetProcOrNil&<procedure(red: single; green: single; blue: single; alpha: single)>(z_BlendColorEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendColorEXT(red: single; green: single; blue: single; alpha: single) :=
    z_BlendColorEXT_1(red, green, blue, alpha);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glBlendEquationSeparateEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_blend_equation_separate';
    
    private z_BlendEquationSeparateEXT_adr := GetProcAddress('glBlendEquationSeparateEXT');
    private z_BlendEquationSeparateEXT_1 := GetProcOrNil&<procedure(modeRGB: BlendEquationMode; modeAlpha: BlendEquationMode)>(z_BlendEquationSeparateEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquationSeparateEXT(modeRGB: BlendEquationMode; modeAlpha: BlendEquationMode) :=
    z_BlendEquationSeparateEXT_1(modeRGB, modeAlpha);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glBlendFuncSeparateEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_blend_func_separate';
    
    private z_BlendFuncSeparateEXT_adr := GetProcAddress('glBlendFuncSeparateEXT');
    private z_BlendFuncSeparateEXT_1 := GetProcOrNil&<procedure(sfactorRGB: BlendingFactor; dfactorRGB: BlendingFactor; sfactorAlpha: BlendingFactor; dfactorAlpha: BlendingFactor)>(z_BlendFuncSeparateEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendFuncSeparateEXT(sfactorRGB: BlendingFactor; dfactorRGB: BlendingFactor; sfactorAlpha: BlendingFactor; dfactorAlpha: BlendingFactor) :=
    z_BlendFuncSeparateEXT_1(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glBlendMinmaxEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_blend_minmax';
    
    private z_BlendEquationEXT_adr := GetProcAddress('glBlendEquationEXT');
    private z_BlendEquationEXT_1 := GetProcOrNil&<procedure(mode: BlendEquationMode)>(z_BlendEquationEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquationEXT(mode: BlendEquationMode) :=
    z_BlendEquationEXT_1(mode);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glColorSubtableEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_color_subtable';
    
    private z_ColorSubTableEXT_adr := GetProcAddress('glColorSubTableEXT');
    private z_ColorSubTableEXT_1 := GetProcOrNil&<procedure(target: ColorTableTarget; start: Int32; count: Int32; format: PixelFormat; &type: PixelType; data: IntPtr)>(z_ColorSubTableEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorSubTableEXT(target: ColorTableTarget; start: Int32; count: Int32; format: PixelFormat; &type: PixelType; data: IntPtr) :=
    z_ColorSubTableEXT_1(target, start, count, format, &type, data);
    
    private z_CopyColorSubTableEXT_adr := GetProcAddress('glCopyColorSubTableEXT');
    private z_CopyColorSubTableEXT_1 := GetProcOrNil&<procedure(target: ColorTableTarget; start: Int32; x: Int32; y: Int32; width: Int32)>(z_CopyColorSubTableEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyColorSubTableEXT(target: ColorTableTarget; start: Int32; x: Int32; y: Int32; width: Int32) :=
    z_CopyColorSubTableEXT_1(target, start, x, y, width);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glCompiledVertexArrayEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_compiled_vertex_array';
    
    private z_LockArraysEXT_adr := GetProcAddress('glLockArraysEXT');
    private z_LockArraysEXT_1 := GetProcOrNil&<procedure(first: Int32; count: Int32)>(z_LockArraysEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LockArraysEXT(first: Int32; count: Int32) :=
    z_LockArraysEXT_1(first, count);
    
    private z_UnlockArraysEXT_adr := GetProcAddress('glUnlockArraysEXT');
    private z_UnlockArraysEXT_1 := GetProcOrNil&<procedure>(z_UnlockArraysEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UnlockArraysEXT :=
    z_UnlockArraysEXT_1();
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glConvolutionEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_convolution';
    
    private z_ConvolutionFilter1DEXT_adr := GetProcAddress('glConvolutionFilter1DEXT');
    private z_ConvolutionFilter1DEXT_1 := GetProcOrNil&<procedure(target: ConvolutionTargetEXT; _internalformat: InternalFormat; width: Int32; format: PixelFormat; &type: PixelType; image: IntPtr)>(z_ConvolutionFilter1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionFilter1DEXT(target: ConvolutionTargetEXT; _internalformat: InternalFormat; width: Int32; format: PixelFormat; &type: PixelType; image: IntPtr) :=
    z_ConvolutionFilter1DEXT_1(target, _internalformat, width, format, &type, image);
    
    private z_ConvolutionFilter2DEXT_adr := GetProcAddress('glConvolutionFilter2DEXT');
    private z_ConvolutionFilter2DEXT_1 := GetProcOrNil&<procedure(target: ConvolutionTargetEXT; _internalformat: InternalFormat; width: Int32; height: Int32; format: PixelFormat; &type: PixelType; image: IntPtr)>(z_ConvolutionFilter2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionFilter2DEXT(target: ConvolutionTargetEXT; _internalformat: InternalFormat; width: Int32; height: Int32; format: PixelFormat; &type: PixelType; image: IntPtr) :=
    z_ConvolutionFilter2DEXT_1(target, _internalformat, width, height, format, &type, image);
    
    private z_ConvolutionParameterfEXT_adr := GetProcAddress('glConvolutionParameterfEXT');
    private z_ConvolutionParameterfEXT_1 := GetProcOrNil&<procedure(target: ConvolutionTargetEXT; pname: ConvolutionParameter; &params: single)>(z_ConvolutionParameterfEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterfEXT(target: ConvolutionTargetEXT; pname: ConvolutionParameter; &params: single) :=
    z_ConvolutionParameterfEXT_1(target, pname, &params);
    
    private z_ConvolutionParameterfvEXT_adr := GetProcAddress('glConvolutionParameterfvEXT');
    private z_ConvolutionParameterfvEXT_1 := GetProcOrNil&<procedure(target: ConvolutionTargetEXT; pname: ConvolutionParameter; &params: IntPtr)>(z_ConvolutionParameterfvEXT_adr);
    private z_ConvolutionParameterfvEXT_2 := GetProcOrNil&<procedure(target: ConvolutionTargetEXT; pname: ConvolutionParameter; var &params: single)>(z_ConvolutionParameterfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterfvEXT(target: ConvolutionTargetEXT; pname: ConvolutionParameter; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_ConvolutionParameterfvEXT_2(target, pname, &params[0]) else
        z_ConvolutionParameterfvEXT_2(target, pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterfvEXT(target: ConvolutionTargetEXT; pname: ConvolutionParameter; var &params: single) :=
    z_ConvolutionParameterfvEXT_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterfvEXT(target: ConvolutionTargetEXT; pname: ConvolutionParameter; &params: IntPtr) :=
    z_ConvolutionParameterfvEXT_1(target, pname, &params);
    
    private z_ConvolutionParameteriEXT_adr := GetProcAddress('glConvolutionParameteriEXT');
    private z_ConvolutionParameteriEXT_1 := GetProcOrNil&<procedure(target: ConvolutionTargetEXT; pname: ConvolutionParameter; &params: Int32)>(z_ConvolutionParameteriEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameteriEXT(target: ConvolutionTargetEXT; pname: ConvolutionParameter; &params: Int32) :=
    z_ConvolutionParameteriEXT_1(target, pname, &params);
    
    private z_ConvolutionParameterivEXT_adr := GetProcAddress('glConvolutionParameterivEXT');
    private z_ConvolutionParameterivEXT_1 := GetProcOrNil&<procedure(target: ConvolutionTargetEXT; pname: ConvolutionParameter; &params: IntPtr)>(z_ConvolutionParameterivEXT_adr);
    private z_ConvolutionParameterivEXT_2 := GetProcOrNil&<procedure(target: ConvolutionTargetEXT; pname: ConvolutionParameter; var &params: Int32)>(z_ConvolutionParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterivEXT(target: ConvolutionTargetEXT; pname: ConvolutionParameter; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_ConvolutionParameterivEXT_2(target, pname, &params[0]) else
        z_ConvolutionParameterivEXT_2(target, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterivEXT(target: ConvolutionTargetEXT; pname: ConvolutionParameter; var &params: Int32) :=
    z_ConvolutionParameterivEXT_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterivEXT(target: ConvolutionTargetEXT; pname: ConvolutionParameter; &params: IntPtr) :=
    z_ConvolutionParameterivEXT_1(target, pname, &params);
    
    private z_CopyConvolutionFilter1DEXT_adr := GetProcAddress('glCopyConvolutionFilter1DEXT');
    private z_CopyConvolutionFilter1DEXT_1 := GetProcOrNil&<procedure(target: ConvolutionTargetEXT; _internalformat: InternalFormat; x: Int32; y: Int32; width: Int32)>(z_CopyConvolutionFilter1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyConvolutionFilter1DEXT(target: ConvolutionTargetEXT; _internalformat: InternalFormat; x: Int32; y: Int32; width: Int32) :=
    z_CopyConvolutionFilter1DEXT_1(target, _internalformat, x, y, width);
    
    private z_CopyConvolutionFilter2DEXT_adr := GetProcAddress('glCopyConvolutionFilter2DEXT');
    private z_CopyConvolutionFilter2DEXT_1 := GetProcOrNil&<procedure(target: ConvolutionTargetEXT; _internalformat: InternalFormat; x: Int32; y: Int32; width: Int32; height: Int32)>(z_CopyConvolutionFilter2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyConvolutionFilter2DEXT(target: ConvolutionTargetEXT; _internalformat: InternalFormat; x: Int32; y: Int32; width: Int32; height: Int32) :=
    z_CopyConvolutionFilter2DEXT_1(target, _internalformat, x, y, width, height);
    
    private z_GetConvolutionFilterEXT_adr := GetProcAddress('glGetConvolutionFilterEXT');
    private z_GetConvolutionFilterEXT_1 := GetProcOrNil&<procedure(target: ConvolutionTargetEXT; format: PixelFormat; &type: PixelType; image: IntPtr)>(z_GetConvolutionFilterEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionFilterEXT(target: ConvolutionTargetEXT; format: PixelFormat; &type: PixelType; image: IntPtr) :=
    z_GetConvolutionFilterEXT_1(target, format, &type, image);
    
    private z_GetConvolutionParameterfvEXT_adr := GetProcAddress('glGetConvolutionParameterfvEXT');
    private z_GetConvolutionParameterfvEXT_1 := GetProcOrNil&<procedure(target: ConvolutionTargetEXT; pname: ConvolutionParameter; &params: IntPtr)>(z_GetConvolutionParameterfvEXT_adr);
    private z_GetConvolutionParameterfvEXT_2 := GetProcOrNil&<procedure(target: ConvolutionTargetEXT; pname: ConvolutionParameter; var &params: single)>(z_GetConvolutionParameterfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameterfvEXT(target: ConvolutionTargetEXT; pname: ConvolutionParameter; var &params: single) :=
    z_GetConvolutionParameterfvEXT_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameterfvEXT(target: ConvolutionTargetEXT; pname: ConvolutionParameter; &params: IntPtr) :=
    z_GetConvolutionParameterfvEXT_1(target, pname, &params);
    
    private z_GetConvolutionParameterivEXT_adr := GetProcAddress('glGetConvolutionParameterivEXT');
    private z_GetConvolutionParameterivEXT_1 := GetProcOrNil&<procedure(target: ConvolutionTargetEXT; pname: ConvolutionParameter; &params: IntPtr)>(z_GetConvolutionParameterivEXT_adr);
    private z_GetConvolutionParameterivEXT_2 := GetProcOrNil&<procedure(target: ConvolutionTargetEXT; pname: ConvolutionParameter; var &params: Int32)>(z_GetConvolutionParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameterivEXT(target: ConvolutionTargetEXT; pname: ConvolutionParameter; var &params: Int32) :=
    z_GetConvolutionParameterivEXT_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameterivEXT(target: ConvolutionTargetEXT; pname: ConvolutionParameter; &params: IntPtr) :=
    z_GetConvolutionParameterivEXT_1(target, pname, &params);
    
    private z_GetSeparableFilterEXT_adr := GetProcAddress('glGetSeparableFilterEXT');
    private z_GetSeparableFilterEXT_1 := GetProcOrNil&<procedure(target: SeparableTargetEXT; format: PixelFormat; &type: PixelType; row: IntPtr; column: IntPtr; span: IntPtr)>(z_GetSeparableFilterEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSeparableFilterEXT(target: SeparableTargetEXT; format: PixelFormat; &type: PixelType; row: IntPtr; column: IntPtr; span: IntPtr) :=
    z_GetSeparableFilterEXT_1(target, format, &type, row, column, span);
    
    private z_SeparableFilter2DEXT_adr := GetProcAddress('glSeparableFilter2DEXT');
    private z_SeparableFilter2DEXT_1 := GetProcOrNil&<procedure(target: SeparableTargetEXT; _internalformat: InternalFormat; width: Int32; height: Int32; format: PixelFormat; &type: PixelType; row: IntPtr; column: IntPtr)>(z_SeparableFilter2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SeparableFilter2DEXT(target: SeparableTargetEXT; _internalformat: InternalFormat; width: Int32; height: Int32; format: PixelFormat; &type: PixelType; row: IntPtr; column: IntPtr) :=
    z_SeparableFilter2DEXT_1(target, _internalformat, width, height, format, &type, row, column);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glCoordinateFrameEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_coordinate_frame';
    
    private z_Tangent3bEXT_adr := GetProcAddress('glTangent3bEXT');
    private z_Tangent3bEXT_1 := GetProcOrNil&<procedure(tx: SByte; ty: SByte; tz: SByte)>(z_Tangent3bEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3bEXT(tx: SByte; ty: SByte; tz: SByte) :=
    z_Tangent3bEXT_1(tx, ty, tz);
    
    private z_Tangent3bvEXT_adr := GetProcAddress('glTangent3bvEXT');
    private z_Tangent3bvEXT_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Tangent3bvEXT_adr);
    private z_Tangent3bvEXT_2 := GetProcOrNil&<procedure(var v: SByte)>(z_Tangent3bvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3bvEXT(v: array of SByte);
    type PSByte=^SByte;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Tangent3bvEXT_2(v[0]) else
        z_Tangent3bvEXT_2(PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3bvEXT(var v: SByte) :=
    z_Tangent3bvEXT_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3bvEXT(v: IntPtr) :=
    z_Tangent3bvEXT_1(v);
    
    private z_Tangent3dEXT_adr := GetProcAddress('glTangent3dEXT');
    private z_Tangent3dEXT_1 := GetProcOrNil&<procedure(tx: real; ty: real; tz: real)>(z_Tangent3dEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3dEXT(tx: real; ty: real; tz: real) :=
    z_Tangent3dEXT_1(tx, ty, tz);
    
    private z_Tangent3dvEXT_adr := GetProcAddress('glTangent3dvEXT');
    private z_Tangent3dvEXT_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Tangent3dvEXT_adr);
    private z_Tangent3dvEXT_2 := GetProcOrNil&<procedure(var v: real)>(z_Tangent3dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3dvEXT(v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Tangent3dvEXT_2(v[0]) else
        z_Tangent3dvEXT_2(Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3dvEXT(var v: real) :=
    z_Tangent3dvEXT_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3dvEXT(v: IntPtr) :=
    z_Tangent3dvEXT_1(v);
    
    private z_Tangent3fEXT_adr := GetProcAddress('glTangent3fEXT');
    private z_Tangent3fEXT_1 := GetProcOrNil&<procedure(tx: single; ty: single; tz: single)>(z_Tangent3fEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3fEXT(tx: single; ty: single; tz: single) :=
    z_Tangent3fEXT_1(tx, ty, tz);
    
    private z_Tangent3fvEXT_adr := GetProcAddress('glTangent3fvEXT');
    private z_Tangent3fvEXT_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Tangent3fvEXT_adr);
    private z_Tangent3fvEXT_2 := GetProcOrNil&<procedure(var v: single)>(z_Tangent3fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3fvEXT(v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Tangent3fvEXT_2(v[0]) else
        z_Tangent3fvEXT_2(Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3fvEXT(var v: single) :=
    z_Tangent3fvEXT_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3fvEXT(v: IntPtr) :=
    z_Tangent3fvEXT_1(v);
    
    private z_Tangent3iEXT_adr := GetProcAddress('glTangent3iEXT');
    private z_Tangent3iEXT_1 := GetProcOrNil&<procedure(tx: Int32; ty: Int32; tz: Int32)>(z_Tangent3iEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3iEXT(tx: Int32; ty: Int32; tz: Int32) :=
    z_Tangent3iEXT_1(tx, ty, tz);
    
    private z_Tangent3ivEXT_adr := GetProcAddress('glTangent3ivEXT');
    private z_Tangent3ivEXT_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Tangent3ivEXT_adr);
    private z_Tangent3ivEXT_2 := GetProcOrNil&<procedure(var v: Int32)>(z_Tangent3ivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3ivEXT(v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Tangent3ivEXT_2(v[0]) else
        z_Tangent3ivEXT_2(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3ivEXT(var v: Int32) :=
    z_Tangent3ivEXT_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3ivEXT(v: IntPtr) :=
    z_Tangent3ivEXT_1(v);
    
    private z_Tangent3sEXT_adr := GetProcAddress('glTangent3sEXT');
    private z_Tangent3sEXT_1 := GetProcOrNil&<procedure(tx: Int16; ty: Int16; tz: Int16)>(z_Tangent3sEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3sEXT(tx: Int16; ty: Int16; tz: Int16) :=
    z_Tangent3sEXT_1(tx, ty, tz);
    
    private z_Tangent3svEXT_adr := GetProcAddress('glTangent3svEXT');
    private z_Tangent3svEXT_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Tangent3svEXT_adr);
    private z_Tangent3svEXT_2 := GetProcOrNil&<procedure(var v: Int16)>(z_Tangent3svEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3svEXT(v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Tangent3svEXT_2(v[0]) else
        z_Tangent3svEXT_2(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3svEXT(var v: Int16) :=
    z_Tangent3svEXT_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3svEXT(v: IntPtr) :=
    z_Tangent3svEXT_1(v);
    
    private z_Binormal3bEXT_adr := GetProcAddress('glBinormal3bEXT');
    private z_Binormal3bEXT_1 := GetProcOrNil&<procedure(bx: SByte; by: SByte; bz: SByte)>(z_Binormal3bEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3bEXT(bx: SByte; by: SByte; bz: SByte) :=
    z_Binormal3bEXT_1(bx, by, bz);
    
    private z_Binormal3bvEXT_adr := GetProcAddress('glBinormal3bvEXT');
    private z_Binormal3bvEXT_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Binormal3bvEXT_adr);
    private z_Binormal3bvEXT_2 := GetProcOrNil&<procedure(var v: SByte)>(z_Binormal3bvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3bvEXT(v: array of SByte);
    type PSByte=^SByte;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Binormal3bvEXT_2(v[0]) else
        z_Binormal3bvEXT_2(PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3bvEXT(var v: SByte) :=
    z_Binormal3bvEXT_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3bvEXT(v: IntPtr) :=
    z_Binormal3bvEXT_1(v);
    
    private z_Binormal3dEXT_adr := GetProcAddress('glBinormal3dEXT');
    private z_Binormal3dEXT_1 := GetProcOrNil&<procedure(bx: real; by: real; bz: real)>(z_Binormal3dEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3dEXT(bx: real; by: real; bz: real) :=
    z_Binormal3dEXT_1(bx, by, bz);
    
    private z_Binormal3dvEXT_adr := GetProcAddress('glBinormal3dvEXT');
    private z_Binormal3dvEXT_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Binormal3dvEXT_adr);
    private z_Binormal3dvEXT_2 := GetProcOrNil&<procedure(var v: real)>(z_Binormal3dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3dvEXT(v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Binormal3dvEXT_2(v[0]) else
        z_Binormal3dvEXT_2(Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3dvEXT(var v: real) :=
    z_Binormal3dvEXT_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3dvEXT(v: IntPtr) :=
    z_Binormal3dvEXT_1(v);
    
    private z_Binormal3fEXT_adr := GetProcAddress('glBinormal3fEXT');
    private z_Binormal3fEXT_1 := GetProcOrNil&<procedure(bx: single; by: single; bz: single)>(z_Binormal3fEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3fEXT(bx: single; by: single; bz: single) :=
    z_Binormal3fEXT_1(bx, by, bz);
    
    private z_Binormal3fvEXT_adr := GetProcAddress('glBinormal3fvEXT');
    private z_Binormal3fvEXT_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Binormal3fvEXT_adr);
    private z_Binormal3fvEXT_2 := GetProcOrNil&<procedure(var v: single)>(z_Binormal3fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3fvEXT(v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Binormal3fvEXT_2(v[0]) else
        z_Binormal3fvEXT_2(Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3fvEXT(var v: single) :=
    z_Binormal3fvEXT_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3fvEXT(v: IntPtr) :=
    z_Binormal3fvEXT_1(v);
    
    private z_Binormal3iEXT_adr := GetProcAddress('glBinormal3iEXT');
    private z_Binormal3iEXT_1 := GetProcOrNil&<procedure(bx: Int32; by: Int32; bz: Int32)>(z_Binormal3iEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3iEXT(bx: Int32; by: Int32; bz: Int32) :=
    z_Binormal3iEXT_1(bx, by, bz);
    
    private z_Binormal3ivEXT_adr := GetProcAddress('glBinormal3ivEXT');
    private z_Binormal3ivEXT_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Binormal3ivEXT_adr);
    private z_Binormal3ivEXT_2 := GetProcOrNil&<procedure(var v: Int32)>(z_Binormal3ivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3ivEXT(v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Binormal3ivEXT_2(v[0]) else
        z_Binormal3ivEXT_2(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3ivEXT(var v: Int32) :=
    z_Binormal3ivEXT_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3ivEXT(v: IntPtr) :=
    z_Binormal3ivEXT_1(v);
    
    private z_Binormal3sEXT_adr := GetProcAddress('glBinormal3sEXT');
    private z_Binormal3sEXT_1 := GetProcOrNil&<procedure(bx: Int16; by: Int16; bz: Int16)>(z_Binormal3sEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3sEXT(bx: Int16; by: Int16; bz: Int16) :=
    z_Binormal3sEXT_1(bx, by, bz);
    
    private z_Binormal3svEXT_adr := GetProcAddress('glBinormal3svEXT');
    private z_Binormal3svEXT_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Binormal3svEXT_adr);
    private z_Binormal3svEXT_2 := GetProcOrNil&<procedure(var v: Int16)>(z_Binormal3svEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3svEXT(v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Binormal3svEXT_2(v[0]) else
        z_Binormal3svEXT_2(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3svEXT(var v: Int16) :=
    z_Binormal3svEXT_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3svEXT(v: IntPtr) :=
    z_Binormal3svEXT_1(v);
    
    private z_TangentPointerEXT_adr := GetProcAddress('glTangentPointerEXT');
    private z_TangentPointerEXT_1 := GetProcOrNil&<procedure(&type: TangentPointerType; stride: Int32; pointer: IntPtr)>(z_TangentPointerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TangentPointerEXT(&type: TangentPointerType; stride: Int32; pointer: IntPtr) :=
    z_TangentPointerEXT_1(&type, stride, pointer);
    
    private z_BinormalPointerEXT_adr := GetProcAddress('glBinormalPointerEXT');
    private z_BinormalPointerEXT_1 := GetProcOrNil&<procedure(&type: BinormalPointerType; stride: Int32; pointer: IntPtr)>(z_BinormalPointerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BinormalPointerEXT(&type: BinormalPointerType; stride: Int32; pointer: IntPtr) :=
    z_BinormalPointerEXT_1(&type, stride, pointer);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glCopyTextureEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_copy_texture';
    
    private z_CopyTexImage1DEXT_adr := GetProcAddress('glCopyTexImage1DEXT');
    private z_CopyTexImage1DEXT_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; _internalformat: InternalFormat; x: Int32; y: Int32; width: Int32; border: Int32)>(z_CopyTexImage1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTexImage1DEXT(target: TextureTarget; level: Int32; _internalformat: InternalFormat; x: Int32; y: Int32; width: Int32; border: Int32) :=
    z_CopyTexImage1DEXT_1(target, level, _internalformat, x, y, width, border);
    
    private z_CopyTexImage2DEXT_adr := GetProcAddress('glCopyTexImage2DEXT');
    private z_CopyTexImage2DEXT_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; _internalformat: InternalFormat; x: Int32; y: Int32; width: Int32; height: Int32; border: Int32)>(z_CopyTexImage2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTexImage2DEXT(target: TextureTarget; level: Int32; _internalformat: InternalFormat; x: Int32; y: Int32; width: Int32; height: Int32; border: Int32) :=
    z_CopyTexImage2DEXT_1(target, level, _internalformat, x, y, width, height, border);
    
    private z_CopyTexSubImage1DEXT_adr := GetProcAddress('glCopyTexSubImage1DEXT');
    private z_CopyTexSubImage1DEXT_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32)>(z_CopyTexSubImage1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTexSubImage1DEXT(target: TextureTarget; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32) :=
    z_CopyTexSubImage1DEXT_1(target, level, xoffset, x, y, width);
    
    private z_CopyTexSubImage2DEXT_adr := GetProcAddress('glCopyTexSubImage2DEXT');
    private z_CopyTexSubImage2DEXT_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32)>(z_CopyTexSubImage2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTexSubImage2DEXT(target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) :=
    z_CopyTexSubImage2DEXT_1(target, level, xoffset, yoffset, x, y, width, height);
    
    private z_CopyTexSubImage3DEXT_adr := GetProcAddress('glCopyTexSubImage3DEXT');
    private z_CopyTexSubImage3DEXT_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32)>(z_CopyTexSubImage3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTexSubImage3DEXT(target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) :=
    z_CopyTexSubImage3DEXT_1(target, level, xoffset, yoffset, zoffset, x, y, width, height);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glCullVertexEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_cull_vertex';
    
    private z_CullParameterdvEXT_adr := GetProcAddress('glCullParameterdvEXT');
    private z_CullParameterdvEXT_1 := GetProcOrNil&<procedure(pname: CullParameter; &params: IntPtr)>(z_CullParameterdvEXT_adr);
    private z_CullParameterdvEXT_2 := GetProcOrNil&<procedure(pname: CullParameter; var &params: real)>(z_CullParameterdvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CullParameterdvEXT(pname: CullParameter; &params: array of real);
    type Preal=^real;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_CullParameterdvEXT_2(pname, &params[0]) else
        z_CullParameterdvEXT_2(pname, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CullParameterdvEXT(pname: CullParameter; var &params: real) :=
    z_CullParameterdvEXT_2(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CullParameterdvEXT(pname: CullParameter; &params: IntPtr) :=
    z_CullParameterdvEXT_1(pname, &params);
    
    private z_CullParameterfvEXT_adr := GetProcAddress('glCullParameterfvEXT');
    private z_CullParameterfvEXT_1 := GetProcOrNil&<procedure(pname: CullParameter; &params: IntPtr)>(z_CullParameterfvEXT_adr);
    private z_CullParameterfvEXT_2 := GetProcOrNil&<procedure(pname: CullParameter; var &params: single)>(z_CullParameterfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CullParameterfvEXT(pname: CullParameter; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_CullParameterfvEXT_2(pname, &params[0]) else
        z_CullParameterfvEXT_2(pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CullParameterfvEXT(pname: CullParameter; var &params: single) :=
    z_CullParameterfvEXT_2(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CullParameterfvEXT(pname: CullParameter; &params: IntPtr) :=
    z_CullParameterfvEXT_1(pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glDebugLabelEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_debug_label';
    
    private z_LabelObjectEXT_adr := GetProcAddress('glLabelObjectEXT');
    private z_LabelObjectEXT_1 := GetProcOrNil&<procedure(&type: DummyEnum; object: UInt32; length: Int32; &label: IntPtr)>(z_LabelObjectEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LabelObjectEXT(&type: DummyEnum; object: UInt32; length: Int32; &label: string);
    begin
      var &label_str_ptr: IntPtr;
      try
        &label_str_ptr := Marshal.StringToHGlobalAnsi(&label);
        z_LabelObjectEXT_1(&type, object, length, &label_str_ptr);
      finally
        Marshal.FreeHGlobal(&label_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LabelObjectEXT(&type: DummyEnum; object: UInt32; length: Int32; &label: IntPtr) :=
    z_LabelObjectEXT_1(&type, object, length, &label);
    
    private z_GetObjectLabelEXT_adr := GetProcAddress('glGetObjectLabelEXT');
    private z_GetObjectLabelEXT_1 := GetProcOrNil&<procedure(&type: DummyEnum; object: UInt32; bufSize: Int32; length: IntPtr; &label: IntPtr)>(z_GetObjectLabelEXT_adr);
    private z_GetObjectLabelEXT_2 := GetProcOrNil&<procedure(&type: DummyEnum; object: UInt32; bufSize: Int32; var length: Int32; &label: IntPtr)>(z_GetObjectLabelEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectLabelEXT(&type: DummyEnum; object: UInt32; bufSize: Int32; var length: Int32; &label: IntPtr) :=
    z_GetObjectLabelEXT_2(&type, object, bufSize, length, &label);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectLabelEXT(&type: DummyEnum; object: UInt32; bufSize: Int32; length: IntPtr; &label: IntPtr) :=
    z_GetObjectLabelEXT_1(&type, object, bufSize, length, &label);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glDebugMarkerEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_debug_marker';
    
    private z_InsertEventMarkerEXT_adr := GetProcAddress('glInsertEventMarkerEXT');
    private z_InsertEventMarkerEXT_1 := GetProcOrNil&<procedure(length: Int32; marker: IntPtr)>(z_InsertEventMarkerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InsertEventMarkerEXT(length: Int32; marker: string);
    begin
      var marker_str_ptr: IntPtr;
      try
        marker_str_ptr := Marshal.StringToHGlobalAnsi(marker);
        z_InsertEventMarkerEXT_1(length, marker_str_ptr);
      finally
        Marshal.FreeHGlobal(marker_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InsertEventMarkerEXT(length: Int32; marker: IntPtr) :=
    z_InsertEventMarkerEXT_1(length, marker);
    
    private z_PushGroupMarkerEXT_adr := GetProcAddress('glPushGroupMarkerEXT');
    private z_PushGroupMarkerEXT_1 := GetProcOrNil&<procedure(length: Int32; marker: IntPtr)>(z_PushGroupMarkerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PushGroupMarkerEXT(length: Int32; marker: string);
    begin
      var marker_str_ptr: IntPtr;
      try
        marker_str_ptr := Marshal.StringToHGlobalAnsi(marker);
        z_PushGroupMarkerEXT_1(length, marker_str_ptr);
      finally
        Marshal.FreeHGlobal(marker_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PushGroupMarkerEXT(length: Int32; marker: IntPtr) :=
    z_PushGroupMarkerEXT_1(length, marker);
    
    private z_PopGroupMarkerEXT_adr := GetProcAddress('glPopGroupMarkerEXT');
    private z_PopGroupMarkerEXT_1 := GetProcOrNil&<procedure>(z_PopGroupMarkerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PopGroupMarkerEXT :=
    z_PopGroupMarkerEXT_1();
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glDepthBoundsTestEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_depth_bounds_test';
    
    private z_DepthBoundsEXT_adr := GetProcAddress('glDepthBoundsEXT');
    private z_DepthBoundsEXT_1 := GetProcOrNil&<procedure(zmin: real; zmax: real)>(z_DepthBoundsEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthBoundsEXT(zmin: real; zmax: real) :=
    z_DepthBoundsEXT_1(zmin, zmax);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glDirectStateAccessEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_direct_state_access';
    
    private z_MatrixLoadfEXT_adr := GetProcAddress('glMatrixLoadfEXT');
    private z_MatrixLoadfEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode; m: IntPtr)>(z_MatrixLoadfEXT_adr);
    private z_MatrixLoadfEXT_2 := GetProcOrNil&<procedure(mode: MatrixMode; var m: single)>(z_MatrixLoadfEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadfEXT(mode: MatrixMode; m: array of single);
    type Psingle=^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_MatrixLoadfEXT_2(mode, m[0]) else
        z_MatrixLoadfEXT_2(mode, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadfEXT(mode: MatrixMode; var m: single) :=
    z_MatrixLoadfEXT_2(mode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadfEXT(mode: MatrixMode; m: IntPtr) :=
    z_MatrixLoadfEXT_1(mode, m);
    
    private z_MatrixLoaddEXT_adr := GetProcAddress('glMatrixLoaddEXT');
    private z_MatrixLoaddEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode; m: IntPtr)>(z_MatrixLoaddEXT_adr);
    private z_MatrixLoaddEXT_2 := GetProcOrNil&<procedure(mode: MatrixMode; var m: real)>(z_MatrixLoaddEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoaddEXT(mode: MatrixMode; m: array of real);
    type Preal=^real;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_MatrixLoaddEXT_2(mode, m[0]) else
        z_MatrixLoaddEXT_2(mode, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoaddEXT(mode: MatrixMode; var m: real) :=
    z_MatrixLoaddEXT_2(mode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoaddEXT(mode: MatrixMode; m: IntPtr) :=
    z_MatrixLoaddEXT_1(mode, m);
    
    private z_MatrixMultfEXT_adr := GetProcAddress('glMatrixMultfEXT');
    private z_MatrixMultfEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode; m: IntPtr)>(z_MatrixMultfEXT_adr);
    private z_MatrixMultfEXT_2 := GetProcOrNil&<procedure(mode: MatrixMode; var m: single)>(z_MatrixMultfEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultfEXT(mode: MatrixMode; m: array of single);
    type Psingle=^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_MatrixMultfEXT_2(mode, m[0]) else
        z_MatrixMultfEXT_2(mode, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultfEXT(mode: MatrixMode; var m: single) :=
    z_MatrixMultfEXT_2(mode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultfEXT(mode: MatrixMode; m: IntPtr) :=
    z_MatrixMultfEXT_1(mode, m);
    
    private z_MatrixMultdEXT_adr := GetProcAddress('glMatrixMultdEXT');
    private z_MatrixMultdEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode; m: IntPtr)>(z_MatrixMultdEXT_adr);
    private z_MatrixMultdEXT_2 := GetProcOrNil&<procedure(mode: MatrixMode; var m: real)>(z_MatrixMultdEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultdEXT(mode: MatrixMode; m: array of real);
    type Preal=^real;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_MatrixMultdEXT_2(mode, m[0]) else
        z_MatrixMultdEXT_2(mode, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultdEXT(mode: MatrixMode; var m: real) :=
    z_MatrixMultdEXT_2(mode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultdEXT(mode: MatrixMode; m: IntPtr) :=
    z_MatrixMultdEXT_1(mode, m);
    
    private z_MatrixLoadIdentityEXT_adr := GetProcAddress('glMatrixLoadIdentityEXT');
    private z_MatrixLoadIdentityEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode)>(z_MatrixLoadIdentityEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadIdentityEXT(mode: MatrixMode) :=
    z_MatrixLoadIdentityEXT_1(mode);
    
    private z_MatrixRotatefEXT_adr := GetProcAddress('glMatrixRotatefEXT');
    private z_MatrixRotatefEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode; angle: single; x: single; y: single; z: single)>(z_MatrixRotatefEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixRotatefEXT(mode: MatrixMode; angle: single; x: single; y: single; z: single) :=
    z_MatrixRotatefEXT_1(mode, angle, x, y, z);
    
    private z_MatrixRotatedEXT_adr := GetProcAddress('glMatrixRotatedEXT');
    private z_MatrixRotatedEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode; angle: real; x: real; y: real; z: real)>(z_MatrixRotatedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixRotatedEXT(mode: MatrixMode; angle: real; x: real; y: real; z: real) :=
    z_MatrixRotatedEXT_1(mode, angle, x, y, z);
    
    private z_MatrixScalefEXT_adr := GetProcAddress('glMatrixScalefEXT');
    private z_MatrixScalefEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode; x: single; y: single; z: single)>(z_MatrixScalefEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixScalefEXT(mode: MatrixMode; x: single; y: single; z: single) :=
    z_MatrixScalefEXT_1(mode, x, y, z);
    
    private z_MatrixScaledEXT_adr := GetProcAddress('glMatrixScaledEXT');
    private z_MatrixScaledEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode; x: real; y: real; z: real)>(z_MatrixScaledEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixScaledEXT(mode: MatrixMode; x: real; y: real; z: real) :=
    z_MatrixScaledEXT_1(mode, x, y, z);
    
    private z_MatrixTranslatefEXT_adr := GetProcAddress('glMatrixTranslatefEXT');
    private z_MatrixTranslatefEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode; x: single; y: single; z: single)>(z_MatrixTranslatefEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixTranslatefEXT(mode: MatrixMode; x: single; y: single; z: single) :=
    z_MatrixTranslatefEXT_1(mode, x, y, z);
    
    private z_MatrixTranslatedEXT_adr := GetProcAddress('glMatrixTranslatedEXT');
    private z_MatrixTranslatedEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode; x: real; y: real; z: real)>(z_MatrixTranslatedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixTranslatedEXT(mode: MatrixMode; x: real; y: real; z: real) :=
    z_MatrixTranslatedEXT_1(mode, x, y, z);
    
    private z_MatrixFrustumEXT_adr := GetProcAddress('glMatrixFrustumEXT');
    private z_MatrixFrustumEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode; left: real; right: real; bottom: real; top: real; zNear: real; zFar: real)>(z_MatrixFrustumEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixFrustumEXT(mode: MatrixMode; left: real; right: real; bottom: real; top: real; zNear: real; zFar: real) :=
    z_MatrixFrustumEXT_1(mode, left, right, bottom, top, zNear, zFar);
    
    private z_MatrixOrthoEXT_adr := GetProcAddress('glMatrixOrthoEXT');
    private z_MatrixOrthoEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode; left: real; right: real; bottom: real; top: real; zNear: real; zFar: real)>(z_MatrixOrthoEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixOrthoEXT(mode: MatrixMode; left: real; right: real; bottom: real; top: real; zNear: real; zFar: real) :=
    z_MatrixOrthoEXT_1(mode, left, right, bottom, top, zNear, zFar);
    
    private z_MatrixPopEXT_adr := GetProcAddress('glMatrixPopEXT');
    private z_MatrixPopEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode)>(z_MatrixPopEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixPopEXT(mode: MatrixMode) :=
    z_MatrixPopEXT_1(mode);
    
    private z_MatrixPushEXT_adr := GetProcAddress('glMatrixPushEXT');
    private z_MatrixPushEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode)>(z_MatrixPushEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixPushEXT(mode: MatrixMode) :=
    z_MatrixPushEXT_1(mode);
    
    private z_ClientAttribDefaultEXT_adr := GetProcAddress('glClientAttribDefaultEXT');
    private z_ClientAttribDefaultEXT_1 := GetProcOrNil&<procedure(mask: ClientAttribMask)>(z_ClientAttribDefaultEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientAttribDefaultEXT(mask: ClientAttribMask) :=
    z_ClientAttribDefaultEXT_1(mask);
    
    private z_PushClientAttribDefaultEXT_adr := GetProcAddress('glPushClientAttribDefaultEXT');
    private z_PushClientAttribDefaultEXT_1 := GetProcOrNil&<procedure(mask: ClientAttribMask)>(z_PushClientAttribDefaultEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PushClientAttribDefaultEXT(mask: ClientAttribMask) :=
    z_PushClientAttribDefaultEXT_1(mask);
    
    private z_TextureParameterfEXT_adr := GetProcAddress('glTextureParameterfEXT');
    private z_TextureParameterfEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; param: single)>(z_TextureParameterfEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterfEXT(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; param: single) :=
    z_TextureParameterfEXT_1(texture, target, pname, param);
    
    private z_TextureParameterfvEXT_adr := GetProcAddress('glTextureParameterfvEXT');
    private z_TextureParameterfvEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; &params: IntPtr)>(z_TextureParameterfvEXT_adr);
    private z_TextureParameterfvEXT_2 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; var &params: single)>(z_TextureParameterfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterfvEXT(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_TextureParameterfvEXT_2(texture, target, pname, &params[0]) else
        z_TextureParameterfvEXT_2(texture, target, pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterfvEXT(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; var &params: single) :=
    z_TextureParameterfvEXT_2(texture, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterfvEXT(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; &params: IntPtr) :=
    z_TextureParameterfvEXT_1(texture, target, pname, &params);
    
    private z_TextureParameteriEXT_adr := GetProcAddress('glTextureParameteriEXT');
    private z_TextureParameteriEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; param: Int32)>(z_TextureParameteriEXT_adr);
    private z_TextureParameteriEXT_2 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; param: TextureWrapMode)>(z_TextureParameteriEXT_adr);
    private z_TextureParameteriEXT_3 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; param: TextureSwizzle)>(z_TextureParameteriEXT_adr);
    private z_TextureParameteriEXT_4 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; param: TextureMinFilter)>(z_TextureParameteriEXT_adr);
    private z_TextureParameteriEXT_5 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; param: TextureMagFilter)>(z_TextureParameteriEXT_adr);
    private z_TextureParameteriEXT_6 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; param: TextureCompareMode)>(z_TextureParameteriEXT_adr);
    private z_TextureParameteriEXT_7 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; param: MapTextureFormat)>(z_TextureParameteriEXT_adr);
    private z_TextureParameteriEXT_8 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; param: FoveationConfigBit)>(z_TextureParameteriEXT_adr);
    private z_TextureParameteriEXT_9 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; param: DepthStencilTextureMode)>(z_TextureParameteriEXT_adr);
    private z_TextureParameteriEXT_10 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; param: ConvolutionBorderMode)>(z_TextureParameteriEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriEXT(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; param: ConvolutionBorderMode) :=
    z_TextureParameteriEXT_10(texture, target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriEXT(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; param: DepthStencilTextureMode) :=
    z_TextureParameteriEXT_9(texture, target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriEXT(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; param: FoveationConfigBit) :=
    z_TextureParameteriEXT_8(texture, target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriEXT(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; param: MapTextureFormat) :=
    z_TextureParameteriEXT_7(texture, target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriEXT(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; param: TextureCompareMode) :=
    z_TextureParameteriEXT_6(texture, target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriEXT(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; param: TextureMagFilter) :=
    z_TextureParameteriEXT_5(texture, target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriEXT(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; param: TextureMinFilter) :=
    z_TextureParameteriEXT_4(texture, target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriEXT(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; param: TextureSwizzle) :=
    z_TextureParameteriEXT_3(texture, target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriEXT(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; param: TextureWrapMode) :=
    z_TextureParameteriEXT_2(texture, target, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriEXT(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; param: Int32) :=
    z_TextureParameteriEXT_1(texture, target, pname, param);
    
    private z_TextureParameterivEXT_adr := GetProcAddress('glTextureParameterivEXT');
    private z_TextureParameterivEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; &params: IntPtr)>(z_TextureParameterivEXT_adr);
    private z_TextureParameterivEXT_2 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; var &params: Int32)>(z_TextureParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterivEXT(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_TextureParameterivEXT_2(texture, target, pname, &params[0]) else
        z_TextureParameterivEXT_2(texture, target, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterivEXT(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; var &params: Int32) :=
    z_TextureParameterivEXT_2(texture, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterivEXT(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; &params: IntPtr) :=
    z_TextureParameterivEXT_1(texture, target, pname, &params);
    
    private z_TextureImage1DEXT_adr := GetProcAddress('glTextureImage1DEXT');
    private z_TextureImage1DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; border: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr)>(z_TextureImage1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureImage1DEXT(texture: gl_texture; target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; border: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr) :=
    z_TextureImage1DEXT_1(texture, target, level, _internalformat, width, border, format, &type, pixels);
    
    private z_TextureImage2DEXT_adr := GetProcAddress('glTextureImage2DEXT');
    private z_TextureImage2DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; border: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr)>(z_TextureImage2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureImage2DEXT(texture: gl_texture; target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; border: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr) :=
    z_TextureImage2DEXT_1(texture, target, level, _internalformat, width, height, border, format, &type, pixels);
    
    private z_TextureSubImage1DEXT_adr := GetProcAddress('glTextureSubImage1DEXT');
    private z_TextureSubImage1DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; level: Int32; xoffset: Int32; width: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr)>(z_TextureSubImage1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureSubImage1DEXT(texture: gl_texture; target: TextureTarget; level: Int32; xoffset: Int32; width: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr) :=
    z_TextureSubImage1DEXT_1(texture, target, level, xoffset, width, format, &type, pixels);
    
    private z_TextureSubImage2DEXT_adr := GetProcAddress('glTextureSubImage2DEXT');
    private z_TextureSubImage2DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr)>(z_TextureSubImage2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureSubImage2DEXT(texture: gl_texture; target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr) :=
    z_TextureSubImage2DEXT_1(texture, target, level, xoffset, yoffset, width, height, format, &type, pixels);
    
    private z_CopyTextureImage1DEXT_adr := GetProcAddress('glCopyTextureImage1DEXT');
    private z_CopyTextureImage1DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; level: Int32; _internalformat: InternalFormat; x: Int32; y: Int32; width: Int32; border: Int32)>(z_CopyTextureImage1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTextureImage1DEXT(texture: gl_texture; target: TextureTarget; level: Int32; _internalformat: InternalFormat; x: Int32; y: Int32; width: Int32; border: Int32) :=
    z_CopyTextureImage1DEXT_1(texture, target, level, _internalformat, x, y, width, border);
    
    private z_CopyTextureImage2DEXT_adr := GetProcAddress('glCopyTextureImage2DEXT');
    private z_CopyTextureImage2DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; level: Int32; _internalformat: InternalFormat; x: Int32; y: Int32; width: Int32; height: Int32; border: Int32)>(z_CopyTextureImage2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTextureImage2DEXT(texture: gl_texture; target: TextureTarget; level: Int32; _internalformat: InternalFormat; x: Int32; y: Int32; width: Int32; height: Int32; border: Int32) :=
    z_CopyTextureImage2DEXT_1(texture, target, level, _internalformat, x, y, width, height, border);
    
    private z_CopyTextureSubImage1DEXT_adr := GetProcAddress('glCopyTextureSubImage1DEXT');
    private z_CopyTextureSubImage1DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32)>(z_CopyTextureSubImage1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTextureSubImage1DEXT(texture: gl_texture; target: TextureTarget; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32) :=
    z_CopyTextureSubImage1DEXT_1(texture, target, level, xoffset, x, y, width);
    
    private z_CopyTextureSubImage2DEXT_adr := GetProcAddress('glCopyTextureSubImage2DEXT');
    private z_CopyTextureSubImage2DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32)>(z_CopyTextureSubImage2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTextureSubImage2DEXT(texture: gl_texture; target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) :=
    z_CopyTextureSubImage2DEXT_1(texture, target, level, xoffset, yoffset, x, y, width, height);
    
    private z_GetTextureImageEXT_adr := GetProcAddress('glGetTextureImageEXT');
    private z_GetTextureImageEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; level: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr)>(z_GetTextureImageEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureImageEXT(texture: gl_texture; target: TextureTarget; level: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr) :=
    z_GetTextureImageEXT_1(texture, target, level, format, &type, pixels);
    
    private z_GetTextureParameterfvEXT_adr := GetProcAddress('glGetTextureParameterfvEXT');
    private z_GetTextureParameterfvEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; pname: GetTextureParameter; &params: IntPtr)>(z_GetTextureParameterfvEXT_adr);
    private z_GetTextureParameterfvEXT_2 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; pname: GetTextureParameter; var &params: single)>(z_GetTextureParameterfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterfvEXT(texture: gl_texture; target: TextureTarget; pname: GetTextureParameter; var &params: single) :=
    z_GetTextureParameterfvEXT_2(texture, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterfvEXT(texture: gl_texture; target: TextureTarget; pname: GetTextureParameter; &params: IntPtr) :=
    z_GetTextureParameterfvEXT_1(texture, target, pname, &params);
    
    private z_GetTextureParameterivEXT_adr := GetProcAddress('glGetTextureParameterivEXT');
    private z_GetTextureParameterivEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; pname: GetTextureParameter; &params: IntPtr)>(z_GetTextureParameterivEXT_adr);
    private z_GetTextureParameterivEXT_2 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; pname: GetTextureParameter; var &params: Int32)>(z_GetTextureParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterivEXT(texture: gl_texture; target: TextureTarget; pname: GetTextureParameter; var &params: Int32) :=
    z_GetTextureParameterivEXT_2(texture, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterivEXT(texture: gl_texture; target: TextureTarget; pname: GetTextureParameter; &params: IntPtr) :=
    z_GetTextureParameterivEXT_1(texture, target, pname, &params);
    
    private z_GetTextureLevelParameterfvEXT_adr := GetProcAddress('glGetTextureLevelParameterfvEXT');
    private z_GetTextureLevelParameterfvEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; level: Int32; pname: GetTextureParameter; &params: IntPtr)>(z_GetTextureLevelParameterfvEXT_adr);
    private z_GetTextureLevelParameterfvEXT_2 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; level: Int32; pname: GetTextureParameter; var &params: single)>(z_GetTextureLevelParameterfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureLevelParameterfvEXT(texture: gl_texture; target: TextureTarget; level: Int32; pname: GetTextureParameter; var &params: single) :=
    z_GetTextureLevelParameterfvEXT_2(texture, target, level, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureLevelParameterfvEXT(texture: gl_texture; target: TextureTarget; level: Int32; pname: GetTextureParameter; &params: IntPtr) :=
    z_GetTextureLevelParameterfvEXT_1(texture, target, level, pname, &params);
    
    private z_GetTextureLevelParameterivEXT_adr := GetProcAddress('glGetTextureLevelParameterivEXT');
    private z_GetTextureLevelParameterivEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; level: Int32; pname: GetTextureParameter; &params: IntPtr)>(z_GetTextureLevelParameterivEXT_adr);
    private z_GetTextureLevelParameterivEXT_2 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; level: Int32; pname: GetTextureParameter; var &params: Int32)>(z_GetTextureLevelParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureLevelParameterivEXT(texture: gl_texture; target: TextureTarget; level: Int32; pname: GetTextureParameter; var &params: Int32) :=
    z_GetTextureLevelParameterivEXT_2(texture, target, level, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureLevelParameterivEXT(texture: gl_texture; target: TextureTarget; level: Int32; pname: GetTextureParameter; &params: IntPtr) :=
    z_GetTextureLevelParameterivEXT_1(texture, target, level, pname, &params);
    
    private z_TextureImage3DEXT_adr := GetProcAddress('glTextureImage3DEXT');
    private z_TextureImage3DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; depth: Int32; border: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr)>(z_TextureImage3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureImage3DEXT(texture: gl_texture; target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; depth: Int32; border: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr) :=
    z_TextureImage3DEXT_1(texture, target, level, _internalformat, width, height, depth, border, format, &type, pixels);
    
    private z_TextureSubImage3DEXT_adr := GetProcAddress('glTextureSubImage3DEXT');
    private z_TextureSubImage3DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr)>(z_TextureSubImage3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureSubImage3DEXT(texture: gl_texture; target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr) :=
    z_TextureSubImage3DEXT_1(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, pixels);
    
    private z_CopyTextureSubImage3DEXT_adr := GetProcAddress('glCopyTextureSubImage3DEXT');
    private z_CopyTextureSubImage3DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32)>(z_CopyTextureSubImage3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTextureSubImage3DEXT(texture: gl_texture; target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) :=
    z_CopyTextureSubImage3DEXT_1(texture, target, level, xoffset, yoffset, zoffset, x, y, width, height);
    
    private z_BindMultiTextureEXT_adr := GetProcAddress('glBindMultiTextureEXT');
    private z_BindMultiTextureEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; texture: gl_texture)>(z_BindMultiTextureEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindMultiTextureEXT(texunit: TextureUnit; target: TextureTarget; texture: gl_texture) :=
    z_BindMultiTextureEXT_1(texunit, target, texture);
    
    private z_MultiTexCoordPointerEXT_adr := GetProcAddress('glMultiTexCoordPointerEXT');
    private z_MultiTexCoordPointerEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; size: Int32; &type: TexCoordPointerType; stride: Int32; pointer: IntPtr)>(z_MultiTexCoordPointerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordPointerEXT(texunit: TextureUnit; size: Int32; &type: TexCoordPointerType; stride: Int32; pointer: IntPtr) :=
    z_MultiTexCoordPointerEXT_1(texunit, size, &type, stride, pointer);
    
    private z_MultiTexEnvfEXT_adr := GetProcAddress('glMultiTexEnvfEXT');
    private z_MultiTexEnvfEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureEnvTarget; pname: TextureEnvParameter; param: single)>(z_MultiTexEnvfEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexEnvfEXT(texunit: TextureUnit; target: TextureEnvTarget; pname: TextureEnvParameter; param: single) :=
    z_MultiTexEnvfEXT_1(texunit, target, pname, param);
    
    private z_MultiTexEnvfvEXT_adr := GetProcAddress('glMultiTexEnvfvEXT');
    private z_MultiTexEnvfvEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureEnvTarget; pname: TextureEnvParameter; &params: IntPtr)>(z_MultiTexEnvfvEXT_adr);
    private z_MultiTexEnvfvEXT_2 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureEnvTarget; pname: TextureEnvParameter; var &params: single)>(z_MultiTexEnvfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexEnvfvEXT(texunit: TextureUnit; target: TextureEnvTarget; pname: TextureEnvParameter; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_MultiTexEnvfvEXT_2(texunit, target, pname, &params[0]) else
        z_MultiTexEnvfvEXT_2(texunit, target, pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexEnvfvEXT(texunit: TextureUnit; target: TextureEnvTarget; pname: TextureEnvParameter; var &params: single) :=
    z_MultiTexEnvfvEXT_2(texunit, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexEnvfvEXT(texunit: TextureUnit; target: TextureEnvTarget; pname: TextureEnvParameter; &params: IntPtr) :=
    z_MultiTexEnvfvEXT_1(texunit, target, pname, &params);
    
    private z_MultiTexEnviEXT_adr := GetProcAddress('glMultiTexEnviEXT');
    private z_MultiTexEnviEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureEnvTarget; pname: TextureEnvParameter; param: Int32)>(z_MultiTexEnviEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexEnviEXT(texunit: TextureUnit; target: TextureEnvTarget; pname: TextureEnvParameter; param: Int32) :=
    z_MultiTexEnviEXT_1(texunit, target, pname, param);
    
    private z_MultiTexEnvivEXT_adr := GetProcAddress('glMultiTexEnvivEXT');
    private z_MultiTexEnvivEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureEnvTarget; pname: TextureEnvParameter; &params: IntPtr)>(z_MultiTexEnvivEXT_adr);
    private z_MultiTexEnvivEXT_2 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureEnvTarget; pname: TextureEnvParameter; var &params: Int32)>(z_MultiTexEnvivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexEnvivEXT(texunit: TextureUnit; target: TextureEnvTarget; pname: TextureEnvParameter; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_MultiTexEnvivEXT_2(texunit, target, pname, &params[0]) else
        z_MultiTexEnvivEXT_2(texunit, target, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexEnvivEXT(texunit: TextureUnit; target: TextureEnvTarget; pname: TextureEnvParameter; var &params: Int32) :=
    z_MultiTexEnvivEXT_2(texunit, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexEnvivEXT(texunit: TextureUnit; target: TextureEnvTarget; pname: TextureEnvParameter; &params: IntPtr) :=
    z_MultiTexEnvivEXT_1(texunit, target, pname, &params);
    
    private z_MultiTexGendEXT_adr := GetProcAddress('glMultiTexGendEXT');
    private z_MultiTexGendEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; coord: TextureCoordName; pname: TextureGenParameter; param: real)>(z_MultiTexGendEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGendEXT(texunit: TextureUnit; coord: TextureCoordName; pname: TextureGenParameter; param: real) :=
    z_MultiTexGendEXT_1(texunit, coord, pname, param);
    
    private z_MultiTexGendvEXT_adr := GetProcAddress('glMultiTexGendvEXT');
    private z_MultiTexGendvEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; coord: TextureCoordName; pname: TextureGenParameter; &params: IntPtr)>(z_MultiTexGendvEXT_adr);
    private z_MultiTexGendvEXT_2 := GetProcOrNil&<procedure(texunit: TextureUnit; coord: TextureCoordName; pname: TextureGenParameter; var &params: real)>(z_MultiTexGendvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGendvEXT(texunit: TextureUnit; coord: TextureCoordName; pname: TextureGenParameter; &params: array of real);
    type Preal=^real;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_MultiTexGendvEXT_2(texunit, coord, pname, &params[0]) else
        z_MultiTexGendvEXT_2(texunit, coord, pname, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGendvEXT(texunit: TextureUnit; coord: TextureCoordName; pname: TextureGenParameter; var &params: real) :=
    z_MultiTexGendvEXT_2(texunit, coord, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGendvEXT(texunit: TextureUnit; coord: TextureCoordName; pname: TextureGenParameter; &params: IntPtr) :=
    z_MultiTexGendvEXT_1(texunit, coord, pname, &params);
    
    private z_MultiTexGenfEXT_adr := GetProcAddress('glMultiTexGenfEXT');
    private z_MultiTexGenfEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; coord: TextureCoordName; pname: TextureGenParameter; param: single)>(z_MultiTexGenfEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGenfEXT(texunit: TextureUnit; coord: TextureCoordName; pname: TextureGenParameter; param: single) :=
    z_MultiTexGenfEXT_1(texunit, coord, pname, param);
    
    private z_MultiTexGenfvEXT_adr := GetProcAddress('glMultiTexGenfvEXT');
    private z_MultiTexGenfvEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; coord: TextureCoordName; pname: TextureGenParameter; &params: IntPtr)>(z_MultiTexGenfvEXT_adr);
    private z_MultiTexGenfvEXT_2 := GetProcOrNil&<procedure(texunit: TextureUnit; coord: TextureCoordName; pname: TextureGenParameter; var &params: single)>(z_MultiTexGenfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGenfvEXT(texunit: TextureUnit; coord: TextureCoordName; pname: TextureGenParameter; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_MultiTexGenfvEXT_2(texunit, coord, pname, &params[0]) else
        z_MultiTexGenfvEXT_2(texunit, coord, pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGenfvEXT(texunit: TextureUnit; coord: TextureCoordName; pname: TextureGenParameter; var &params: single) :=
    z_MultiTexGenfvEXT_2(texunit, coord, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGenfvEXT(texunit: TextureUnit; coord: TextureCoordName; pname: TextureGenParameter; &params: IntPtr) :=
    z_MultiTexGenfvEXT_1(texunit, coord, pname, &params);
    
    private z_MultiTexGeniEXT_adr := GetProcAddress('glMultiTexGeniEXT');
    private z_MultiTexGeniEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; coord: TextureCoordName; pname: TextureGenParameter; param: Int32)>(z_MultiTexGeniEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGeniEXT(texunit: TextureUnit; coord: TextureCoordName; pname: TextureGenParameter; param: Int32) :=
    z_MultiTexGeniEXT_1(texunit, coord, pname, param);
    
    private z_MultiTexGenivEXT_adr := GetProcAddress('glMultiTexGenivEXT');
    private z_MultiTexGenivEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; coord: TextureCoordName; pname: TextureGenParameter; &params: IntPtr)>(z_MultiTexGenivEXT_adr);
    private z_MultiTexGenivEXT_2 := GetProcOrNil&<procedure(texunit: TextureUnit; coord: TextureCoordName; pname: TextureGenParameter; var &params: Int32)>(z_MultiTexGenivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGenivEXT(texunit: TextureUnit; coord: TextureCoordName; pname: TextureGenParameter; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_MultiTexGenivEXT_2(texunit, coord, pname, &params[0]) else
        z_MultiTexGenivEXT_2(texunit, coord, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGenivEXT(texunit: TextureUnit; coord: TextureCoordName; pname: TextureGenParameter; var &params: Int32) :=
    z_MultiTexGenivEXT_2(texunit, coord, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGenivEXT(texunit: TextureUnit; coord: TextureCoordName; pname: TextureGenParameter; &params: IntPtr) :=
    z_MultiTexGenivEXT_1(texunit, coord, pname, &params);
    
    private z_GetMultiTexEnvfvEXT_adr := GetProcAddress('glGetMultiTexEnvfvEXT');
    private z_GetMultiTexEnvfvEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureEnvTarget; pname: TextureEnvParameter; &params: IntPtr)>(z_GetMultiTexEnvfvEXT_adr);
    private z_GetMultiTexEnvfvEXT_2 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureEnvTarget; pname: TextureEnvParameter; var &params: single)>(z_GetMultiTexEnvfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexEnvfvEXT(texunit: TextureUnit; target: TextureEnvTarget; pname: TextureEnvParameter; var &params: single) :=
    z_GetMultiTexEnvfvEXT_2(texunit, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexEnvfvEXT(texunit: TextureUnit; target: TextureEnvTarget; pname: TextureEnvParameter; &params: IntPtr) :=
    z_GetMultiTexEnvfvEXT_1(texunit, target, pname, &params);
    
    private z_GetMultiTexEnvivEXT_adr := GetProcAddress('glGetMultiTexEnvivEXT');
    private z_GetMultiTexEnvivEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureEnvTarget; pname: TextureEnvParameter; &params: IntPtr)>(z_GetMultiTexEnvivEXT_adr);
    private z_GetMultiTexEnvivEXT_2 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureEnvTarget; pname: TextureEnvParameter; var &params: Int32)>(z_GetMultiTexEnvivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexEnvivEXT(texunit: TextureUnit; target: TextureEnvTarget; pname: TextureEnvParameter; var &params: Int32) :=
    z_GetMultiTexEnvivEXT_2(texunit, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexEnvivEXT(texunit: TextureUnit; target: TextureEnvTarget; pname: TextureEnvParameter; &params: IntPtr) :=
    z_GetMultiTexEnvivEXT_1(texunit, target, pname, &params);
    
    private z_GetMultiTexGendvEXT_adr := GetProcAddress('glGetMultiTexGendvEXT');
    private z_GetMultiTexGendvEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; coord: TextureCoordName; pname: TextureGenParameter; &params: IntPtr)>(z_GetMultiTexGendvEXT_adr);
    private z_GetMultiTexGendvEXT_2 := GetProcOrNil&<procedure(texunit: TextureUnit; coord: TextureCoordName; pname: TextureGenParameter; var &params: real)>(z_GetMultiTexGendvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexGendvEXT(texunit: TextureUnit; coord: TextureCoordName; pname: TextureGenParameter; var &params: real) :=
    z_GetMultiTexGendvEXT_2(texunit, coord, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexGendvEXT(texunit: TextureUnit; coord: TextureCoordName; pname: TextureGenParameter; &params: IntPtr) :=
    z_GetMultiTexGendvEXT_1(texunit, coord, pname, &params);
    
    private z_GetMultiTexGenfvEXT_adr := GetProcAddress('glGetMultiTexGenfvEXT');
    private z_GetMultiTexGenfvEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; coord: TextureCoordName; pname: TextureGenParameter; &params: IntPtr)>(z_GetMultiTexGenfvEXT_adr);
    private z_GetMultiTexGenfvEXT_2 := GetProcOrNil&<procedure(texunit: TextureUnit; coord: TextureCoordName; pname: TextureGenParameter; var &params: single)>(z_GetMultiTexGenfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexGenfvEXT(texunit: TextureUnit; coord: TextureCoordName; pname: TextureGenParameter; var &params: single) :=
    z_GetMultiTexGenfvEXT_2(texunit, coord, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexGenfvEXT(texunit: TextureUnit; coord: TextureCoordName; pname: TextureGenParameter; &params: IntPtr) :=
    z_GetMultiTexGenfvEXT_1(texunit, coord, pname, &params);
    
    private z_GetMultiTexGenivEXT_adr := GetProcAddress('glGetMultiTexGenivEXT');
    private z_GetMultiTexGenivEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; coord: TextureCoordName; pname: TextureGenParameter; &params: IntPtr)>(z_GetMultiTexGenivEXT_adr);
    private z_GetMultiTexGenivEXT_2 := GetProcOrNil&<procedure(texunit: TextureUnit; coord: TextureCoordName; pname: TextureGenParameter; var &params: Int32)>(z_GetMultiTexGenivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexGenivEXT(texunit: TextureUnit; coord: TextureCoordName; pname: TextureGenParameter; var &params: Int32) :=
    z_GetMultiTexGenivEXT_2(texunit, coord, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexGenivEXT(texunit: TextureUnit; coord: TextureCoordName; pname: TextureGenParameter; &params: IntPtr) :=
    z_GetMultiTexGenivEXT_1(texunit, coord, pname, &params);
    
    private z_MultiTexParameteriEXT_adr := GetProcAddress('glMultiTexParameteriEXT');
    private z_MultiTexParameteriEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; pname: TextureParameterName; param: Int32)>(z_MultiTexParameteriEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameteriEXT(texunit: TextureUnit; target: TextureTarget; pname: TextureParameterName; param: Int32) :=
    z_MultiTexParameteriEXT_1(texunit, target, pname, param);
    
    private z_MultiTexParameterivEXT_adr := GetProcAddress('glMultiTexParameterivEXT');
    private z_MultiTexParameterivEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; pname: TextureParameterName; &params: IntPtr)>(z_MultiTexParameterivEXT_adr);
    private z_MultiTexParameterivEXT_2 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; pname: TextureParameterName; var &params: Int32)>(z_MultiTexParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterivEXT(texunit: TextureUnit; target: TextureTarget; pname: TextureParameterName; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_MultiTexParameterivEXT_2(texunit, target, pname, &params[0]) else
        z_MultiTexParameterivEXT_2(texunit, target, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterivEXT(texunit: TextureUnit; target: TextureTarget; pname: TextureParameterName; var &params: Int32) :=
    z_MultiTexParameterivEXT_2(texunit, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterivEXT(texunit: TextureUnit; target: TextureTarget; pname: TextureParameterName; &params: IntPtr) :=
    z_MultiTexParameterivEXT_1(texunit, target, pname, &params);
    
    private z_MultiTexParameterfEXT_adr := GetProcAddress('glMultiTexParameterfEXT');
    private z_MultiTexParameterfEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; pname: TextureParameterName; param: single)>(z_MultiTexParameterfEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterfEXT(texunit: TextureUnit; target: TextureTarget; pname: TextureParameterName; param: single) :=
    z_MultiTexParameterfEXT_1(texunit, target, pname, param);
    
    private z_MultiTexParameterfvEXT_adr := GetProcAddress('glMultiTexParameterfvEXT');
    private z_MultiTexParameterfvEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; pname: TextureParameterName; &params: IntPtr)>(z_MultiTexParameterfvEXT_adr);
    private z_MultiTexParameterfvEXT_2 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; pname: TextureParameterName; var &params: single)>(z_MultiTexParameterfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterfvEXT(texunit: TextureUnit; target: TextureTarget; pname: TextureParameterName; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_MultiTexParameterfvEXT_2(texunit, target, pname, &params[0]) else
        z_MultiTexParameterfvEXT_2(texunit, target, pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterfvEXT(texunit: TextureUnit; target: TextureTarget; pname: TextureParameterName; var &params: single) :=
    z_MultiTexParameterfvEXT_2(texunit, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterfvEXT(texunit: TextureUnit; target: TextureTarget; pname: TextureParameterName; &params: IntPtr) :=
    z_MultiTexParameterfvEXT_1(texunit, target, pname, &params);
    
    private z_MultiTexImage1DEXT_adr := GetProcAddress('glMultiTexImage1DEXT');
    private z_MultiTexImage1DEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; border: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr)>(z_MultiTexImage1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexImage1DEXT(texunit: TextureUnit; target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; border: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr) :=
    z_MultiTexImage1DEXT_1(texunit, target, level, _internalformat, width, border, format, &type, pixels);
    
    private z_MultiTexImage2DEXT_adr := GetProcAddress('glMultiTexImage2DEXT');
    private z_MultiTexImage2DEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; border: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr)>(z_MultiTexImage2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexImage2DEXT(texunit: TextureUnit; target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; border: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr) :=
    z_MultiTexImage2DEXT_1(texunit, target, level, _internalformat, width, height, border, format, &type, pixels);
    
    private z_MultiTexSubImage1DEXT_adr := GetProcAddress('glMultiTexSubImage1DEXT');
    private z_MultiTexSubImage1DEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; level: Int32; xoffset: Int32; width: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr)>(z_MultiTexSubImage1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexSubImage1DEXT(texunit: TextureUnit; target: TextureTarget; level: Int32; xoffset: Int32; width: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr) :=
    z_MultiTexSubImage1DEXT_1(texunit, target, level, xoffset, width, format, &type, pixels);
    
    private z_MultiTexSubImage2DEXT_adr := GetProcAddress('glMultiTexSubImage2DEXT');
    private z_MultiTexSubImage2DEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr)>(z_MultiTexSubImage2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexSubImage2DEXT(texunit: TextureUnit; target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr) :=
    z_MultiTexSubImage2DEXT_1(texunit, target, level, xoffset, yoffset, width, height, format, &type, pixels);
    
    private z_CopyMultiTexImage1DEXT_adr := GetProcAddress('glCopyMultiTexImage1DEXT');
    private z_CopyMultiTexImage1DEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; level: Int32; _internalformat: InternalFormat; x: Int32; y: Int32; width: Int32; border: Int32)>(z_CopyMultiTexImage1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyMultiTexImage1DEXT(texunit: TextureUnit; target: TextureTarget; level: Int32; _internalformat: InternalFormat; x: Int32; y: Int32; width: Int32; border: Int32) :=
    z_CopyMultiTexImage1DEXT_1(texunit, target, level, _internalformat, x, y, width, border);
    
    private z_CopyMultiTexImage2DEXT_adr := GetProcAddress('glCopyMultiTexImage2DEXT');
    private z_CopyMultiTexImage2DEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; level: Int32; _internalformat: InternalFormat; x: Int32; y: Int32; width: Int32; height: Int32; border: Int32)>(z_CopyMultiTexImage2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyMultiTexImage2DEXT(texunit: TextureUnit; target: TextureTarget; level: Int32; _internalformat: InternalFormat; x: Int32; y: Int32; width: Int32; height: Int32; border: Int32) :=
    z_CopyMultiTexImage2DEXT_1(texunit, target, level, _internalformat, x, y, width, height, border);
    
    private z_CopyMultiTexSubImage1DEXT_adr := GetProcAddress('glCopyMultiTexSubImage1DEXT');
    private z_CopyMultiTexSubImage1DEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32)>(z_CopyMultiTexSubImage1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyMultiTexSubImage1DEXT(texunit: TextureUnit; target: TextureTarget; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32) :=
    z_CopyMultiTexSubImage1DEXT_1(texunit, target, level, xoffset, x, y, width);
    
    private z_CopyMultiTexSubImage2DEXT_adr := GetProcAddress('glCopyMultiTexSubImage2DEXT');
    private z_CopyMultiTexSubImage2DEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32)>(z_CopyMultiTexSubImage2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyMultiTexSubImage2DEXT(texunit: TextureUnit; target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) :=
    z_CopyMultiTexSubImage2DEXT_1(texunit, target, level, xoffset, yoffset, x, y, width, height);
    
    private z_GetMultiTexImageEXT_adr := GetProcAddress('glGetMultiTexImageEXT');
    private z_GetMultiTexImageEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; level: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr)>(z_GetMultiTexImageEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexImageEXT(texunit: TextureUnit; target: TextureTarget; level: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr) :=
    z_GetMultiTexImageEXT_1(texunit, target, level, format, &type, pixels);
    
    private z_GetMultiTexParameterfvEXT_adr := GetProcAddress('glGetMultiTexParameterfvEXT');
    private z_GetMultiTexParameterfvEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; pname: GetTextureParameter; &params: IntPtr)>(z_GetMultiTexParameterfvEXT_adr);
    private z_GetMultiTexParameterfvEXT_2 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; pname: GetTextureParameter; var &params: single)>(z_GetMultiTexParameterfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterfvEXT(texunit: TextureUnit; target: TextureTarget; pname: GetTextureParameter; var &params: single) :=
    z_GetMultiTexParameterfvEXT_2(texunit, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterfvEXT(texunit: TextureUnit; target: TextureTarget; pname: GetTextureParameter; &params: IntPtr) :=
    z_GetMultiTexParameterfvEXT_1(texunit, target, pname, &params);
    
    private z_GetMultiTexParameterivEXT_adr := GetProcAddress('glGetMultiTexParameterivEXT');
    private z_GetMultiTexParameterivEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; pname: GetTextureParameter; &params: IntPtr)>(z_GetMultiTexParameterivEXT_adr);
    private z_GetMultiTexParameterivEXT_2 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; pname: GetTextureParameter; var &params: Int32)>(z_GetMultiTexParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterivEXT(texunit: TextureUnit; target: TextureTarget; pname: GetTextureParameter; var &params: Int32) :=
    z_GetMultiTexParameterivEXT_2(texunit, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterivEXT(texunit: TextureUnit; target: TextureTarget; pname: GetTextureParameter; &params: IntPtr) :=
    z_GetMultiTexParameterivEXT_1(texunit, target, pname, &params);
    
    private z_GetMultiTexLevelParameterfvEXT_adr := GetProcAddress('glGetMultiTexLevelParameterfvEXT');
    private z_GetMultiTexLevelParameterfvEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; level: Int32; pname: GetTextureParameter; &params: IntPtr)>(z_GetMultiTexLevelParameterfvEXT_adr);
    private z_GetMultiTexLevelParameterfvEXT_2 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; level: Int32; pname: GetTextureParameter; var &params: single)>(z_GetMultiTexLevelParameterfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexLevelParameterfvEXT(texunit: TextureUnit; target: TextureTarget; level: Int32; pname: GetTextureParameter; var &params: single) :=
    z_GetMultiTexLevelParameterfvEXT_2(texunit, target, level, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexLevelParameterfvEXT(texunit: TextureUnit; target: TextureTarget; level: Int32; pname: GetTextureParameter; &params: IntPtr) :=
    z_GetMultiTexLevelParameterfvEXT_1(texunit, target, level, pname, &params);
    
    private z_GetMultiTexLevelParameterivEXT_adr := GetProcAddress('glGetMultiTexLevelParameterivEXT');
    private z_GetMultiTexLevelParameterivEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; level: Int32; pname: GetTextureParameter; &params: IntPtr)>(z_GetMultiTexLevelParameterivEXT_adr);
    private z_GetMultiTexLevelParameterivEXT_2 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; level: Int32; pname: GetTextureParameter; var &params: Int32)>(z_GetMultiTexLevelParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexLevelParameterivEXT(texunit: TextureUnit; target: TextureTarget; level: Int32; pname: GetTextureParameter; var &params: Int32) :=
    z_GetMultiTexLevelParameterivEXT_2(texunit, target, level, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexLevelParameterivEXT(texunit: TextureUnit; target: TextureTarget; level: Int32; pname: GetTextureParameter; &params: IntPtr) :=
    z_GetMultiTexLevelParameterivEXT_1(texunit, target, level, pname, &params);
    
    private z_MultiTexImage3DEXT_adr := GetProcAddress('glMultiTexImage3DEXT');
    private z_MultiTexImage3DEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; depth: Int32; border: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr)>(z_MultiTexImage3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexImage3DEXT(texunit: TextureUnit; target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; depth: Int32; border: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr) :=
    z_MultiTexImage3DEXT_1(texunit, target, level, _internalformat, width, height, depth, border, format, &type, pixels);
    
    private z_MultiTexSubImage3DEXT_adr := GetProcAddress('glMultiTexSubImage3DEXT');
    private z_MultiTexSubImage3DEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr)>(z_MultiTexSubImage3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexSubImage3DEXT(texunit: TextureUnit; target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr) :=
    z_MultiTexSubImage3DEXT_1(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, pixels);
    
    private z_CopyMultiTexSubImage3DEXT_adr := GetProcAddress('glCopyMultiTexSubImage3DEXT');
    private z_CopyMultiTexSubImage3DEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32)>(z_CopyMultiTexSubImage3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyMultiTexSubImage3DEXT(texunit: TextureUnit; target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) :=
    z_CopyMultiTexSubImage3DEXT_1(texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height);
    
    private z_EnableClientStateIndexedEXT_adr := GetProcAddress('glEnableClientStateIndexedEXT');
    private z_EnableClientStateIndexedEXT_1 := GetProcOrNil&<procedure(&array: EnableCap; index: UInt32)>(z_EnableClientStateIndexedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableClientStateIndexedEXT(&array: EnableCap; index: UInt32) :=
    z_EnableClientStateIndexedEXT_1(&array, index);
    
    private z_DisableClientStateIndexedEXT_adr := GetProcAddress('glDisableClientStateIndexedEXT');
    private z_DisableClientStateIndexedEXT_1 := GetProcOrNil&<procedure(&array: EnableCap; index: UInt32)>(z_DisableClientStateIndexedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableClientStateIndexedEXT(&array: EnableCap; index: UInt32) :=
    z_DisableClientStateIndexedEXT_1(&array, index);
    
    private z_GetFloatIndexedvEXT_adr := GetProcAddress('glGetFloatIndexedvEXT');
    private z_GetFloatIndexedvEXT_1 := GetProcOrNil&<procedure(target: GetPName; index: UInt32; data: IntPtr)>(z_GetFloatIndexedvEXT_adr);
    private z_GetFloatIndexedvEXT_2 := GetProcOrNil&<procedure(target: GetPName; index: UInt32; var data: single)>(z_GetFloatIndexedvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloatIndexedvEXT(target: GetPName; index: UInt32; var data: single) :=
    z_GetFloatIndexedvEXT_2(target, index, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloatIndexedvEXT(target: GetPName; index: UInt32; data: IntPtr) :=
    z_GetFloatIndexedvEXT_1(target, index, data);
    
    private z_GetDoubleIndexedvEXT_adr := GetProcAddress('glGetDoubleIndexedvEXT');
    private z_GetDoubleIndexedvEXT_1 := GetProcOrNil&<procedure(target: GetPName; index: UInt32; data: IntPtr)>(z_GetDoubleIndexedvEXT_adr);
    private z_GetDoubleIndexedvEXT_2 := GetProcOrNil&<procedure(target: GetPName; index: UInt32; var data: real)>(z_GetDoubleIndexedvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDoubleIndexedvEXT(target: GetPName; index: UInt32; var data: real) :=
    z_GetDoubleIndexedvEXT_2(target, index, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDoubleIndexedvEXT(target: GetPName; index: UInt32; data: IntPtr) :=
    z_GetDoubleIndexedvEXT_1(target, index, data);
    
    private z_GetPointerIndexedvEXT_adr := GetProcAddress('glGetPointerIndexedvEXT');
    private z_GetPointerIndexedvEXT_1 := GetProcOrNil&<procedure(target: DummyEnum; index: UInt32; data: pointer)>(z_GetPointerIndexedvEXT_adr);
    private z_GetPointerIndexedvEXT_2 := GetProcOrNil&<procedure(target: DummyEnum; index: UInt32; var data: IntPtr)>(z_GetPointerIndexedvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointerIndexedvEXT(target: DummyEnum; index: UInt32; var data: IntPtr) :=
    z_GetPointerIndexedvEXT_2(target, index, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointerIndexedvEXT(target: DummyEnum; index: UInt32; data: pointer) :=
    z_GetPointerIndexedvEXT_1(target, index, data);
    
    private z_EnableIndexedEXT_adr := GetProcAddress('glEnableIndexedEXT');
    private z_EnableIndexedEXT_1 := GetProcOrNil&<procedure(target: EnableCap; index: UInt32)>(z_EnableIndexedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableIndexedEXT(target: EnableCap; index: UInt32) :=
    z_EnableIndexedEXT_1(target, index);
    
    private z_DisableIndexedEXT_adr := GetProcAddress('glDisableIndexedEXT');
    private z_DisableIndexedEXT_1 := GetProcOrNil&<procedure(target: EnableCap; index: UInt32)>(z_DisableIndexedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableIndexedEXT(target: EnableCap; index: UInt32) :=
    z_DisableIndexedEXT_1(target, index);
    
    private z_IsEnabledIndexedEXT_adr := GetProcAddress('glIsEnabledIndexedEXT');
    private z_IsEnabledIndexedEXT_1 := GetProcOrNil&<function(target: EnableCap; index: UInt32): boolean>(z_IsEnabledIndexedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnabledIndexedEXT(target: EnableCap; index: UInt32): boolean :=
    z_IsEnabledIndexedEXT_1(target, index);
    
    private z_GetIntegerIndexedvEXT_adr := GetProcAddress('glGetIntegerIndexedvEXT');
    private z_GetIntegerIndexedvEXT_1 := GetProcOrNil&<procedure(target: GetPName; index: UInt32; data: IntPtr)>(z_GetIntegerIndexedvEXT_adr);
    private z_GetIntegerIndexedvEXT_2 := GetProcOrNil&<procedure(target: GetPName; index: UInt32; var data: Int32)>(z_GetIntegerIndexedvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerIndexedvEXT(target: GetPName; index: UInt32; var data: Int32) :=
    z_GetIntegerIndexedvEXT_2(target, index, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerIndexedvEXT(target: GetPName; index: UInt32; data: IntPtr) :=
    z_GetIntegerIndexedvEXT_1(target, index, data);
    
    private z_GetBooleanIndexedvEXT_adr := GetProcAddress('glGetBooleanIndexedvEXT');
    private z_GetBooleanIndexedvEXT_1 := GetProcOrNil&<procedure(target: BufferTarget; index: UInt32; data: IntPtr)>(z_GetBooleanIndexedvEXT_adr);
    private z_GetBooleanIndexedvEXT_2 := GetProcOrNil&<procedure(target: BufferTarget; index: UInt32; var data: boolean)>(z_GetBooleanIndexedvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBooleanIndexedvEXT(target: BufferTarget; index: UInt32; var data: boolean) :=
    z_GetBooleanIndexedvEXT_2(target, index, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBooleanIndexedvEXT(target: BufferTarget; index: UInt32; data: IntPtr) :=
    z_GetBooleanIndexedvEXT_1(target, index, data);
    
    private z_CompressedTextureImage3DEXT_adr := GetProcAddress('glCompressedTextureImage3DEXT');
    private z_CompressedTextureImage3DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; bits: IntPtr)>(z_CompressedTextureImage3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureImage3DEXT(texture: gl_texture; target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; bits: IntPtr) :=
    z_CompressedTextureImage3DEXT_1(texture, target, level, _internalformat, width, height, depth, border, imageSize, bits);
    
    private z_CompressedTextureImage2DEXT_adr := GetProcAddress('glCompressedTextureImage2DEXT');
    private z_CompressedTextureImage2DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; border: Int32; imageSize: Int32; bits: IntPtr)>(z_CompressedTextureImage2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureImage2DEXT(texture: gl_texture; target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; border: Int32; imageSize: Int32; bits: IntPtr) :=
    z_CompressedTextureImage2DEXT_1(texture, target, level, _internalformat, width, height, border, imageSize, bits);
    
    private z_CompressedTextureImage1DEXT_adr := GetProcAddress('glCompressedTextureImage1DEXT');
    private z_CompressedTextureImage1DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; border: Int32; imageSize: Int32; bits: IntPtr)>(z_CompressedTextureImage1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureImage1DEXT(texture: gl_texture; target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; border: Int32; imageSize: Int32; bits: IntPtr) :=
    z_CompressedTextureImage1DEXT_1(texture, target, level, _internalformat, width, border, imageSize, bits);
    
    private z_CompressedTextureSubImage3DEXT_adr := GetProcAddress('glCompressedTextureSubImage3DEXT');
    private z_CompressedTextureSubImage3DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: InternalFormat; imageSize: Int32; bits: IntPtr)>(z_CompressedTextureSubImage3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureSubImage3DEXT(texture: gl_texture; target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: InternalFormat; imageSize: Int32; bits: IntPtr) :=
    z_CompressedTextureSubImage3DEXT_1(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
    
    private z_CompressedTextureSubImage2DEXT_adr := GetProcAddress('glCompressedTextureSubImage2DEXT');
    private z_CompressedTextureSubImage2DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: InternalFormat; imageSize: Int32; bits: IntPtr)>(z_CompressedTextureSubImage2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureSubImage2DEXT(texture: gl_texture; target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: InternalFormat; imageSize: Int32; bits: IntPtr) :=
    z_CompressedTextureSubImage2DEXT_1(texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
    
    private z_CompressedTextureSubImage1DEXT_adr := GetProcAddress('glCompressedTextureSubImage1DEXT');
    private z_CompressedTextureSubImage1DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; level: Int32; xoffset: Int32; width: Int32; format: InternalFormat; imageSize: Int32; bits: IntPtr)>(z_CompressedTextureSubImage1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureSubImage1DEXT(texture: gl_texture; target: TextureTarget; level: Int32; xoffset: Int32; width: Int32; format: InternalFormat; imageSize: Int32; bits: IntPtr) :=
    z_CompressedTextureSubImage1DEXT_1(texture, target, level, xoffset, width, format, imageSize, bits);
    
    private z_GetCompressedTextureImageEXT_adr := GetProcAddress('glGetCompressedTextureImageEXT');
    private z_GetCompressedTextureImageEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; lod: Int32; img: IntPtr)>(z_GetCompressedTextureImageEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCompressedTextureImageEXT(texture: gl_texture; target: TextureTarget; lod: Int32; img: IntPtr) :=
    z_GetCompressedTextureImageEXT_1(texture, target, lod, img);
    
    private z_CompressedMultiTexImage3DEXT_adr := GetProcAddress('glCompressedMultiTexImage3DEXT');
    private z_CompressedMultiTexImage3DEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; bits: IntPtr)>(z_CompressedMultiTexImage3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedMultiTexImage3DEXT(texunit: TextureUnit; target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; bits: IntPtr) :=
    z_CompressedMultiTexImage3DEXT_1(texunit, target, level, _internalformat, width, height, depth, border, imageSize, bits);
    
    private z_CompressedMultiTexImage2DEXT_adr := GetProcAddress('glCompressedMultiTexImage2DEXT');
    private z_CompressedMultiTexImage2DEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; border: Int32; imageSize: Int32; bits: IntPtr)>(z_CompressedMultiTexImage2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedMultiTexImage2DEXT(texunit: TextureUnit; target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; border: Int32; imageSize: Int32; bits: IntPtr) :=
    z_CompressedMultiTexImage2DEXT_1(texunit, target, level, _internalformat, width, height, border, imageSize, bits);
    
    private z_CompressedMultiTexImage1DEXT_adr := GetProcAddress('glCompressedMultiTexImage1DEXT');
    private z_CompressedMultiTexImage1DEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; border: Int32; imageSize: Int32; bits: IntPtr)>(z_CompressedMultiTexImage1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedMultiTexImage1DEXT(texunit: TextureUnit; target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; border: Int32; imageSize: Int32; bits: IntPtr) :=
    z_CompressedMultiTexImage1DEXT_1(texunit, target, level, _internalformat, width, border, imageSize, bits);
    
    private z_CompressedMultiTexSubImage3DEXT_adr := GetProcAddress('glCompressedMultiTexSubImage3DEXT');
    private z_CompressedMultiTexSubImage3DEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: InternalFormat; imageSize: Int32; bits: IntPtr)>(z_CompressedMultiTexSubImage3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedMultiTexSubImage3DEXT(texunit: TextureUnit; target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: InternalFormat; imageSize: Int32; bits: IntPtr) :=
    z_CompressedMultiTexSubImage3DEXT_1(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
    
    private z_CompressedMultiTexSubImage2DEXT_adr := GetProcAddress('glCompressedMultiTexSubImage2DEXT');
    private z_CompressedMultiTexSubImage2DEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: InternalFormat; imageSize: Int32; bits: IntPtr)>(z_CompressedMultiTexSubImage2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedMultiTexSubImage2DEXT(texunit: TextureUnit; target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: InternalFormat; imageSize: Int32; bits: IntPtr) :=
    z_CompressedMultiTexSubImage2DEXT_1(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
    
    private z_CompressedMultiTexSubImage1DEXT_adr := GetProcAddress('glCompressedMultiTexSubImage1DEXT');
    private z_CompressedMultiTexSubImage1DEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; level: Int32; xoffset: Int32; width: Int32; format: InternalFormat; imageSize: Int32; bits: IntPtr)>(z_CompressedMultiTexSubImage1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedMultiTexSubImage1DEXT(texunit: TextureUnit; target: TextureTarget; level: Int32; xoffset: Int32; width: Int32; format: InternalFormat; imageSize: Int32; bits: IntPtr) :=
    z_CompressedMultiTexSubImage1DEXT_1(texunit, target, level, xoffset, width, format, imageSize, bits);
    
    private z_GetCompressedMultiTexImageEXT_adr := GetProcAddress('glGetCompressedMultiTexImageEXT');
    private z_GetCompressedMultiTexImageEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; lod: Int32; img: IntPtr)>(z_GetCompressedMultiTexImageEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCompressedMultiTexImageEXT(texunit: TextureUnit; target: TextureTarget; lod: Int32; img: IntPtr) :=
    z_GetCompressedMultiTexImageEXT_1(texunit, target, lod, img);
    
    private z_MatrixLoadTransposefEXT_adr := GetProcAddress('glMatrixLoadTransposefEXT');
    private z_MatrixLoadTransposefEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode; m: IntPtr)>(z_MatrixLoadTransposefEXT_adr);
    private z_MatrixLoadTransposefEXT_2 := GetProcOrNil&<procedure(mode: MatrixMode; var m: single)>(z_MatrixLoadTransposefEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTransposefEXT(mode: MatrixMode; m: array of single);
    type Psingle=^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_MatrixLoadTransposefEXT_2(mode, m[0]) else
        z_MatrixLoadTransposefEXT_2(mode, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTransposefEXT(mode: MatrixMode; var m: single) :=
    z_MatrixLoadTransposefEXT_2(mode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTransposefEXT(mode: MatrixMode; m: IntPtr) :=
    z_MatrixLoadTransposefEXT_1(mode, m);
    
    private z_MatrixLoadTransposedEXT_adr := GetProcAddress('glMatrixLoadTransposedEXT');
    private z_MatrixLoadTransposedEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode; m: IntPtr)>(z_MatrixLoadTransposedEXT_adr);
    private z_MatrixLoadTransposedEXT_2 := GetProcOrNil&<procedure(mode: MatrixMode; var m: real)>(z_MatrixLoadTransposedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTransposedEXT(mode: MatrixMode; m: array of real);
    type Preal=^real;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_MatrixLoadTransposedEXT_2(mode, m[0]) else
        z_MatrixLoadTransposedEXT_2(mode, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTransposedEXT(mode: MatrixMode; var m: real) :=
    z_MatrixLoadTransposedEXT_2(mode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTransposedEXT(mode: MatrixMode; m: IntPtr) :=
    z_MatrixLoadTransposedEXT_1(mode, m);
    
    private z_MatrixMultTransposefEXT_adr := GetProcAddress('glMatrixMultTransposefEXT');
    private z_MatrixMultTransposefEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode; m: IntPtr)>(z_MatrixMultTransposefEXT_adr);
    private z_MatrixMultTransposefEXT_2 := GetProcOrNil&<procedure(mode: MatrixMode; var m: single)>(z_MatrixMultTransposefEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTransposefEXT(mode: MatrixMode; m: array of single);
    type Psingle=^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_MatrixMultTransposefEXT_2(mode, m[0]) else
        z_MatrixMultTransposefEXT_2(mode, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTransposefEXT(mode: MatrixMode; var m: single) :=
    z_MatrixMultTransposefEXT_2(mode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTransposefEXT(mode: MatrixMode; m: IntPtr) :=
    z_MatrixMultTransposefEXT_1(mode, m);
    
    private z_MatrixMultTransposedEXT_adr := GetProcAddress('glMatrixMultTransposedEXT');
    private z_MatrixMultTransposedEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode; m: IntPtr)>(z_MatrixMultTransposedEXT_adr);
    private z_MatrixMultTransposedEXT_2 := GetProcOrNil&<procedure(mode: MatrixMode; var m: real)>(z_MatrixMultTransposedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTransposedEXT(mode: MatrixMode; m: array of real);
    type Preal=^real;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_MatrixMultTransposedEXT_2(mode, m[0]) else
        z_MatrixMultTransposedEXT_2(mode, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTransposedEXT(mode: MatrixMode; var m: real) :=
    z_MatrixMultTransposedEXT_2(mode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTransposedEXT(mode: MatrixMode; m: IntPtr) :=
    z_MatrixMultTransposedEXT_1(mode, m);
    
    private z_NamedBufferDataEXT_adr := GetProcAddress('glNamedBufferDataEXT');
    private z_NamedBufferDataEXT_1 := GetProcOrNil&<procedure(buffer: gl_buffer; size: UIntPtr; data: pointer; usage: VertexBufferObjectUsage)>(z_NamedBufferDataEXT_adr);
    private z_NamedBufferDataEXT_2 := GetProcOrNil&<procedure(buffer: gl_buffer; size: UIntPtr; var data: Byte; usage: VertexBufferObjectUsage)>(z_NamedBufferDataEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferDataEXT<T>(buffer: gl_buffer; size: UIntPtr; data: array of T; usage: VertexBufferObjectUsage); where T: record;
    type PT=^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        NamedBufferDataEXT(buffer, size, data[0], usage) else
        NamedBufferDataEXT(buffer, size, PT(nil)^, usage);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferDataEXT<T>(buffer: gl_buffer; size: UIntPtr; var data: T; usage: VertexBufferObjectUsage); where T: record;
    begin
      z_NamedBufferDataEXT_2(buffer, size, PByte(pointer(@data))^, usage);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferDataEXT(buffer: gl_buffer; size: UIntPtr; data: pointer; usage: VertexBufferObjectUsage) :=
    z_NamedBufferDataEXT_1(buffer, size, data, usage);
    
    private z_NamedBufferSubDataEXT_adr := GetProcAddress('glNamedBufferSubDataEXT');
    private z_NamedBufferSubDataEXT_1 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: pointer)>(z_NamedBufferSubDataEXT_adr);
    private z_NamedBufferSubDataEXT_2 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; var data: Byte)>(z_NamedBufferSubDataEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferSubDataEXT<T>(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: array of T); where T: record;
    type PT=^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        NamedBufferSubDataEXT(buffer, offset, size, data[0]) else
        NamedBufferSubDataEXT(buffer, offset, size, PT(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferSubDataEXT<T>(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; var data: T); where T: record;
    begin
      z_NamedBufferSubDataEXT_2(buffer, offset, size, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferSubDataEXT(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: pointer) :=
    z_NamedBufferSubDataEXT_1(buffer, offset, size, data);
    
    private z_MapNamedBufferEXT_adr := GetProcAddress('glMapNamedBufferEXT');
    private z_MapNamedBufferEXT_1 := GetProcOrNil&<function(buffer: gl_buffer; access: BufferAccess): IntPtr>(z_MapNamedBufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapNamedBufferEXT(buffer: gl_buffer; access: BufferAccess): IntPtr :=
    z_MapNamedBufferEXT_1(buffer, access);
    
    private z_UnmapNamedBufferEXT_adr := GetProcAddress('glUnmapNamedBufferEXT');
    private z_UnmapNamedBufferEXT_1 := GetProcOrNil&<function(buffer: gl_buffer): boolean>(z_UnmapNamedBufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function UnmapNamedBufferEXT(buffer: gl_buffer): boolean :=
    z_UnmapNamedBufferEXT_1(buffer);
    
    private z_GetNamedBufferParameterivEXT_adr := GetProcAddress('glGetNamedBufferParameterivEXT');
    private z_GetNamedBufferParameterivEXT_1 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: BufferPName; &params: IntPtr)>(z_GetNamedBufferParameterivEXT_adr);
    private z_GetNamedBufferParameterivEXT_2 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: BufferPName; var &params: Int32)>(z_GetNamedBufferParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameterivEXT(buffer: gl_buffer; pname: BufferPName; var &params: Int32) :=
    z_GetNamedBufferParameterivEXT_2(buffer, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameterivEXT(buffer: gl_buffer; pname: BufferPName; &params: IntPtr) :=
    z_GetNamedBufferParameterivEXT_1(buffer, pname, &params);
    
    private z_GetNamedBufferPointervEXT_adr := GetProcAddress('glGetNamedBufferPointervEXT');
    private z_GetNamedBufferPointervEXT_1 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: BufferPointerName; &params: pointer)>(z_GetNamedBufferPointervEXT_adr);
    private z_GetNamedBufferPointervEXT_2 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: BufferPointerName; var &params: IntPtr)>(z_GetNamedBufferPointervEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferPointervEXT(buffer: gl_buffer; pname: BufferPointerName; var &params: IntPtr) :=
    z_GetNamedBufferPointervEXT_2(buffer, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferPointervEXT(buffer: gl_buffer; pname: BufferPointerName; &params: pointer) :=
    z_GetNamedBufferPointervEXT_1(buffer, pname, &params);
    
    private z_GetNamedBufferSubDataEXT_adr := GetProcAddress('glGetNamedBufferSubDataEXT');
    private z_GetNamedBufferSubDataEXT_1 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: pointer)>(z_GetNamedBufferSubDataEXT_adr);
    private z_GetNamedBufferSubDataEXT_2 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; var data: Byte)>(z_GetNamedBufferSubDataEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferSubDataEXT<T>(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; var data: T); where T: record;
    begin
      z_GetNamedBufferSubDataEXT_2(buffer, offset, size, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferSubDataEXT(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: pointer) :=
    z_GetNamedBufferSubDataEXT_1(buffer, offset, size, data);
    
    private z_ProgramUniform1fEXT_adr := GetProcAddress('glProgramUniform1fEXT');
    private z_ProgramUniform1fEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: single)>(z_ProgramUniform1fEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1fEXT(&program: gl_program; location: Int32; v0: single) :=
    z_ProgramUniform1fEXT_1(&program, location, v0);
    
    private z_ProgramUniform2fEXT_adr := GetProcAddress('glProgramUniform2fEXT');
    private z_ProgramUniform2fEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: single; v1: single)>(z_ProgramUniform2fEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2fEXT(&program: gl_program; location: Int32; v0: single; v1: single) :=
    z_ProgramUniform2fEXT_1(&program, location, v0, v1);
    
    private z_ProgramUniform3fEXT_adr := GetProcAddress('glProgramUniform3fEXT');
    private z_ProgramUniform3fEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: single; v1: single; v2: single)>(z_ProgramUniform3fEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3fEXT(&program: gl_program; location: Int32; v0: single; v1: single; v2: single) :=
    z_ProgramUniform3fEXT_1(&program, location, v0, v1, v2);
    
    private z_ProgramUniform4fEXT_adr := GetProcAddress('glProgramUniform4fEXT');
    private z_ProgramUniform4fEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: single; v1: single; v2: single; v3: single)>(z_ProgramUniform4fEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4fEXT(&program: gl_program; location: Int32; v0: single; v1: single; v2: single; v3: single) :=
    z_ProgramUniform4fEXT_1(&program, location, v0, v1, v2, v3);
    
    private z_ProgramUniform1iEXT_adr := GetProcAddress('glProgramUniform1iEXT');
    private z_ProgramUniform1iEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: Int32)>(z_ProgramUniform1iEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1iEXT(&program: gl_program; location: Int32; v0: Int32) :=
    z_ProgramUniform1iEXT_1(&program, location, v0);
    
    private z_ProgramUniform2iEXT_adr := GetProcAddress('glProgramUniform2iEXT');
    private z_ProgramUniform2iEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: Int32; v1: Int32)>(z_ProgramUniform2iEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2iEXT(&program: gl_program; location: Int32; v0: Int32; v1: Int32) :=
    z_ProgramUniform2iEXT_1(&program, location, v0, v1);
    
    private z_ProgramUniform3iEXT_adr := GetProcAddress('glProgramUniform3iEXT');
    private z_ProgramUniform3iEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: Int32; v1: Int32; v2: Int32)>(z_ProgramUniform3iEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3iEXT(&program: gl_program; location: Int32; v0: Int32; v1: Int32; v2: Int32) :=
    z_ProgramUniform3iEXT_1(&program, location, v0, v1, v2);
    
    private z_ProgramUniform4iEXT_adr := GetProcAddress('glProgramUniform4iEXT');
    private z_ProgramUniform4iEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: Int32; v1: Int32; v2: Int32; v3: Int32)>(z_ProgramUniform4iEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4iEXT(&program: gl_program; location: Int32; v0: Int32; v1: Int32; v2: Int32; v3: Int32) :=
    z_ProgramUniform4iEXT_1(&program, location, v0, v1, v2, v3);
    
    private z_ProgramUniform1fvEXT_adr := GetProcAddress('glProgramUniform1fvEXT');
    private z_ProgramUniform1fvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform1fvEXT_adr);
    private z_ProgramUniform1fvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: single)>(z_ProgramUniform1fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1fvEXT(&program: gl_program; location: Int32; count: Int32; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform1fvEXT_2(&program, location, count, value[0]) else
        z_ProgramUniform1fvEXT_2(&program, location, count, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1fvEXT(&program: gl_program; location: Int32; count: Int32; var value: single) :=
    z_ProgramUniform1fvEXT_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1fvEXT(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform1fvEXT_1(&program, location, count, value);
    
    private z_ProgramUniform2fvEXT_adr := GetProcAddress('glProgramUniform2fvEXT');
    private z_ProgramUniform2fvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform2fvEXT_adr);
    private z_ProgramUniform2fvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: single)>(z_ProgramUniform2fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2fvEXT(&program: gl_program; location: Int32; count: Int32; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform2fvEXT_2(&program, location, count, value[0]) else
        z_ProgramUniform2fvEXT_2(&program, location, count, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2fvEXT(&program: gl_program; location: Int32; count: Int32; var value: single) :=
    z_ProgramUniform2fvEXT_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2fvEXT(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform2fvEXT_1(&program, location, count, value);
    
    private z_ProgramUniform3fvEXT_adr := GetProcAddress('glProgramUniform3fvEXT');
    private z_ProgramUniform3fvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform3fvEXT_adr);
    private z_ProgramUniform3fvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: single)>(z_ProgramUniform3fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3fvEXT(&program: gl_program; location: Int32; count: Int32; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform3fvEXT_2(&program, location, count, value[0]) else
        z_ProgramUniform3fvEXT_2(&program, location, count, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3fvEXT(&program: gl_program; location: Int32; count: Int32; var value: single) :=
    z_ProgramUniform3fvEXT_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3fvEXT(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform3fvEXT_1(&program, location, count, value);
    
    private z_ProgramUniform4fvEXT_adr := GetProcAddress('glProgramUniform4fvEXT');
    private z_ProgramUniform4fvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform4fvEXT_adr);
    private z_ProgramUniform4fvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: single)>(z_ProgramUniform4fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4fvEXT(&program: gl_program; location: Int32; count: Int32; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform4fvEXT_2(&program, location, count, value[0]) else
        z_ProgramUniform4fvEXT_2(&program, location, count, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4fvEXT(&program: gl_program; location: Int32; count: Int32; var value: single) :=
    z_ProgramUniform4fvEXT_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4fvEXT(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform4fvEXT_1(&program, location, count, value);
    
    private z_ProgramUniform1ivEXT_adr := GetProcAddress('glProgramUniform1ivEXT');
    private z_ProgramUniform1ivEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform1ivEXT_adr);
    private z_ProgramUniform1ivEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int32)>(z_ProgramUniform1ivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ivEXT(&program: gl_program; location: Int32; count: Int32; value: array of Int32);
    type PInt32=^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform1ivEXT_2(&program, location, count, value[0]) else
        z_ProgramUniform1ivEXT_2(&program, location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ivEXT(&program: gl_program; location: Int32; count: Int32; var value: Int32) :=
    z_ProgramUniform1ivEXT_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ivEXT(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform1ivEXT_1(&program, location, count, value);
    
    private z_ProgramUniform2ivEXT_adr := GetProcAddress('glProgramUniform2ivEXT');
    private z_ProgramUniform2ivEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform2ivEXT_adr);
    private z_ProgramUniform2ivEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int32)>(z_ProgramUniform2ivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ivEXT(&program: gl_program; location: Int32; count: Int32; value: array of Int32);
    type PInt32=^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform2ivEXT_2(&program, location, count, value[0]) else
        z_ProgramUniform2ivEXT_2(&program, location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ivEXT(&program: gl_program; location: Int32; count: Int32; var value: Int32) :=
    z_ProgramUniform2ivEXT_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ivEXT(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform2ivEXT_1(&program, location, count, value);
    
    private z_ProgramUniform3ivEXT_adr := GetProcAddress('glProgramUniform3ivEXT');
    private z_ProgramUniform3ivEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform3ivEXT_adr);
    private z_ProgramUniform3ivEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int32)>(z_ProgramUniform3ivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ivEXT(&program: gl_program; location: Int32; count: Int32; value: array of Int32);
    type PInt32=^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform3ivEXT_2(&program, location, count, value[0]) else
        z_ProgramUniform3ivEXT_2(&program, location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ivEXT(&program: gl_program; location: Int32; count: Int32; var value: Int32) :=
    z_ProgramUniform3ivEXT_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ivEXT(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform3ivEXT_1(&program, location, count, value);
    
    private z_ProgramUniform4ivEXT_adr := GetProcAddress('glProgramUniform4ivEXT');
    private z_ProgramUniform4ivEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform4ivEXT_adr);
    private z_ProgramUniform4ivEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int32)>(z_ProgramUniform4ivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ivEXT(&program: gl_program; location: Int32; count: Int32; value: array of Int32);
    type PInt32=^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform4ivEXT_2(&program, location, count, value[0]) else
        z_ProgramUniform4ivEXT_2(&program, location, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ivEXT(&program: gl_program; location: Int32; count: Int32; var value: Int32) :=
    z_ProgramUniform4ivEXT_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ivEXT(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform4ivEXT_1(&program, location, count, value);
    
    private z_ProgramUniformMatrix2fvEXT_adr := GetProcAddress('glProgramUniformMatrix2fvEXT');
    private z_ProgramUniformMatrix2fvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix2fvEXT_adr);
    private z_ProgramUniformMatrix2fvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single)>(z_ProgramUniformMatrix2fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix2fvEXT_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix2fvEXT_2(&program, location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_ProgramUniformMatrix2fvEXT_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix2fvEXT_1(&program, location, count, transpose, value);
    
    private z_ProgramUniformMatrix3fvEXT_adr := GetProcAddress('glProgramUniformMatrix3fvEXT');
    private z_ProgramUniformMatrix3fvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix3fvEXT_adr);
    private z_ProgramUniformMatrix3fvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single)>(z_ProgramUniformMatrix3fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix3fvEXT_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix3fvEXT_2(&program, location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_ProgramUniformMatrix3fvEXT_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix3fvEXT_1(&program, location, count, transpose, value);
    
    private z_ProgramUniformMatrix4fvEXT_adr := GetProcAddress('glProgramUniformMatrix4fvEXT');
    private z_ProgramUniformMatrix4fvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix4fvEXT_adr);
    private z_ProgramUniformMatrix4fvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single)>(z_ProgramUniformMatrix4fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix4fvEXT_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix4fvEXT_2(&program, location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_ProgramUniformMatrix4fvEXT_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix4fvEXT_1(&program, location, count, transpose, value);
    
    private z_ProgramUniformMatrix2x3fvEXT_adr := GetProcAddress('glProgramUniformMatrix2x3fvEXT');
    private z_ProgramUniformMatrix2x3fvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix2x3fvEXT_adr);
    private z_ProgramUniformMatrix2x3fvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single)>(z_ProgramUniformMatrix2x3fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix2x3fvEXT_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix2x3fvEXT_2(&program, location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_ProgramUniformMatrix2x3fvEXT_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix2x3fvEXT_1(&program, location, count, transpose, value);
    
    private z_ProgramUniformMatrix3x2fvEXT_adr := GetProcAddress('glProgramUniformMatrix3x2fvEXT');
    private z_ProgramUniformMatrix3x2fvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix3x2fvEXT_adr);
    private z_ProgramUniformMatrix3x2fvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single)>(z_ProgramUniformMatrix3x2fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix3x2fvEXT_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix3x2fvEXT_2(&program, location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_ProgramUniformMatrix3x2fvEXT_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix3x2fvEXT_1(&program, location, count, transpose, value);
    
    private z_ProgramUniformMatrix2x4fvEXT_adr := GetProcAddress('glProgramUniformMatrix2x4fvEXT');
    private z_ProgramUniformMatrix2x4fvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix2x4fvEXT_adr);
    private z_ProgramUniformMatrix2x4fvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single)>(z_ProgramUniformMatrix2x4fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix2x4fvEXT_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix2x4fvEXT_2(&program, location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_ProgramUniformMatrix2x4fvEXT_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix2x4fvEXT_1(&program, location, count, transpose, value);
    
    private z_ProgramUniformMatrix4x2fvEXT_adr := GetProcAddress('glProgramUniformMatrix4x2fvEXT');
    private z_ProgramUniformMatrix4x2fvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix4x2fvEXT_adr);
    private z_ProgramUniformMatrix4x2fvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single)>(z_ProgramUniformMatrix4x2fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix4x2fvEXT_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix4x2fvEXT_2(&program, location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_ProgramUniformMatrix4x2fvEXT_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix4x2fvEXT_1(&program, location, count, transpose, value);
    
    private z_ProgramUniformMatrix3x4fvEXT_adr := GetProcAddress('glProgramUniformMatrix3x4fvEXT');
    private z_ProgramUniformMatrix3x4fvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix3x4fvEXT_adr);
    private z_ProgramUniformMatrix3x4fvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single)>(z_ProgramUniformMatrix3x4fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix3x4fvEXT_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix3x4fvEXT_2(&program, location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_ProgramUniformMatrix3x4fvEXT_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix3x4fvEXT_1(&program, location, count, transpose, value);
    
    private z_ProgramUniformMatrix4x3fvEXT_adr := GetProcAddress('glProgramUniformMatrix4x3fvEXT');
    private z_ProgramUniformMatrix4x3fvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix4x3fvEXT_adr);
    private z_ProgramUniformMatrix4x3fvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single)>(z_ProgramUniformMatrix4x3fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix4x3fvEXT_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix4x3fvEXT_2(&program, location, count, transpose, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: single) :=
    z_ProgramUniformMatrix4x3fvEXT_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3fvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix4x3fvEXT_1(&program, location, count, transpose, value);
    
    private z_TextureBufferEXT_adr := GetProcAddress('glTextureBufferEXT');
    private z_TextureBufferEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; internalformat: SizedInternalFormat; buffer: gl_buffer)>(z_TextureBufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureBufferEXT(texture: gl_texture; target: TextureTarget; internalformat: SizedInternalFormat; buffer: gl_buffer) :=
    z_TextureBufferEXT_1(texture, target, internalformat, buffer);
    
    private z_MultiTexBufferEXT_adr := GetProcAddress('glMultiTexBufferEXT');
    private z_MultiTexBufferEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; _internalformat: InternalFormat; buffer: gl_buffer)>(z_MultiTexBufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexBufferEXT(texunit: TextureUnit; target: TextureTarget; _internalformat: InternalFormat; buffer: gl_buffer) :=
    z_MultiTexBufferEXT_1(texunit, target, _internalformat, buffer);
    
    private z_TextureParameterIivEXT_adr := GetProcAddress('glTextureParameterIivEXT');
    private z_TextureParameterIivEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; &params: IntPtr)>(z_TextureParameterIivEXT_adr);
    private z_TextureParameterIivEXT_2 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; var &params: Int32)>(z_TextureParameterIivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIivEXT(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_TextureParameterIivEXT_2(texture, target, pname, &params[0]) else
        z_TextureParameterIivEXT_2(texture, target, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIivEXT(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; var &params: Int32) :=
    z_TextureParameterIivEXT_2(texture, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIivEXT(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; &params: IntPtr) :=
    z_TextureParameterIivEXT_1(texture, target, pname, &params);
    
    private z_TextureParameterIuivEXT_adr := GetProcAddress('glTextureParameterIuivEXT');
    private z_TextureParameterIuivEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; &params: IntPtr)>(z_TextureParameterIuivEXT_adr);
    private z_TextureParameterIuivEXT_2 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; var &params: UInt32)>(z_TextureParameterIuivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIuivEXT(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; &params: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_TextureParameterIuivEXT_2(texture, target, pname, &params[0]) else
        z_TextureParameterIuivEXT_2(texture, target, pname, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIuivEXT(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; var &params: UInt32) :=
    z_TextureParameterIuivEXT_2(texture, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIuivEXT(texture: gl_texture; target: TextureTarget; pname: TextureParameterName; &params: IntPtr) :=
    z_TextureParameterIuivEXT_1(texture, target, pname, &params);
    
    private z_GetTextureParameterIivEXT_adr := GetProcAddress('glGetTextureParameterIivEXT');
    private z_GetTextureParameterIivEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; pname: GetTextureParameter; &params: IntPtr)>(z_GetTextureParameterIivEXT_adr);
    private z_GetTextureParameterIivEXT_2 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; pname: GetTextureParameter; var &params: Int32)>(z_GetTextureParameterIivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIivEXT(texture: gl_texture; target: TextureTarget; pname: GetTextureParameter; var &params: Int32) :=
    z_GetTextureParameterIivEXT_2(texture, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIivEXT(texture: gl_texture; target: TextureTarget; pname: GetTextureParameter; &params: IntPtr) :=
    z_GetTextureParameterIivEXT_1(texture, target, pname, &params);
    
    private z_GetTextureParameterIuivEXT_adr := GetProcAddress('glGetTextureParameterIuivEXT');
    private z_GetTextureParameterIuivEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; pname: GetTextureParameter; &params: IntPtr)>(z_GetTextureParameterIuivEXT_adr);
    private z_GetTextureParameterIuivEXT_2 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; pname: GetTextureParameter; var &params: UInt32)>(z_GetTextureParameterIuivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIuivEXT(texture: gl_texture; target: TextureTarget; pname: GetTextureParameter; var &params: UInt32) :=
    z_GetTextureParameterIuivEXT_2(texture, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIuivEXT(texture: gl_texture; target: TextureTarget; pname: GetTextureParameter; &params: IntPtr) :=
    z_GetTextureParameterIuivEXT_1(texture, target, pname, &params);
    
    private z_MultiTexParameterIivEXT_adr := GetProcAddress('glMultiTexParameterIivEXT');
    private z_MultiTexParameterIivEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; pname: TextureParameterName; &params: IntPtr)>(z_MultiTexParameterIivEXT_adr);
    private z_MultiTexParameterIivEXT_2 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; pname: TextureParameterName; var &params: Int32)>(z_MultiTexParameterIivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterIivEXT(texunit: TextureUnit; target: TextureTarget; pname: TextureParameterName; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_MultiTexParameterIivEXT_2(texunit, target, pname, &params[0]) else
        z_MultiTexParameterIivEXT_2(texunit, target, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterIivEXT(texunit: TextureUnit; target: TextureTarget; pname: TextureParameterName; var &params: Int32) :=
    z_MultiTexParameterIivEXT_2(texunit, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterIivEXT(texunit: TextureUnit; target: TextureTarget; pname: TextureParameterName; &params: IntPtr) :=
    z_MultiTexParameterIivEXT_1(texunit, target, pname, &params);
    
    private z_MultiTexParameterIuivEXT_adr := GetProcAddress('glMultiTexParameterIuivEXT');
    private z_MultiTexParameterIuivEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; pname: TextureParameterName; &params: IntPtr)>(z_MultiTexParameterIuivEXT_adr);
    private z_MultiTexParameterIuivEXT_2 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; pname: TextureParameterName; var &params: UInt32)>(z_MultiTexParameterIuivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterIuivEXT(texunit: TextureUnit; target: TextureTarget; pname: TextureParameterName; &params: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_MultiTexParameterIuivEXT_2(texunit, target, pname, &params[0]) else
        z_MultiTexParameterIuivEXT_2(texunit, target, pname, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterIuivEXT(texunit: TextureUnit; target: TextureTarget; pname: TextureParameterName; var &params: UInt32) :=
    z_MultiTexParameterIuivEXT_2(texunit, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterIuivEXT(texunit: TextureUnit; target: TextureTarget; pname: TextureParameterName; &params: IntPtr) :=
    z_MultiTexParameterIuivEXT_1(texunit, target, pname, &params);
    
    private z_GetMultiTexParameterIivEXT_adr := GetProcAddress('glGetMultiTexParameterIivEXT');
    private z_GetMultiTexParameterIivEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; pname: GetTextureParameter; &params: IntPtr)>(z_GetMultiTexParameterIivEXT_adr);
    private z_GetMultiTexParameterIivEXT_2 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; pname: GetTextureParameter; var &params: Int32)>(z_GetMultiTexParameterIivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterIivEXT(texunit: TextureUnit; target: TextureTarget; pname: GetTextureParameter; var &params: Int32) :=
    z_GetMultiTexParameterIivEXT_2(texunit, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterIivEXT(texunit: TextureUnit; target: TextureTarget; pname: GetTextureParameter; &params: IntPtr) :=
    z_GetMultiTexParameterIivEXT_1(texunit, target, pname, &params);
    
    private z_GetMultiTexParameterIuivEXT_adr := GetProcAddress('glGetMultiTexParameterIuivEXT');
    private z_GetMultiTexParameterIuivEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; pname: GetTextureParameter; &params: IntPtr)>(z_GetMultiTexParameterIuivEXT_adr);
    private z_GetMultiTexParameterIuivEXT_2 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; pname: GetTextureParameter; var &params: UInt32)>(z_GetMultiTexParameterIuivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterIuivEXT(texunit: TextureUnit; target: TextureTarget; pname: GetTextureParameter; var &params: UInt32) :=
    z_GetMultiTexParameterIuivEXT_2(texunit, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterIuivEXT(texunit: TextureUnit; target: TextureTarget; pname: GetTextureParameter; &params: IntPtr) :=
    z_GetMultiTexParameterIuivEXT_1(texunit, target, pname, &params);
    
    private z_ProgramUniform1uiEXT_adr := GetProcAddress('glProgramUniform1uiEXT');
    private z_ProgramUniform1uiEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: UInt32)>(z_ProgramUniform1uiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1uiEXT(&program: gl_program; location: Int32; v0: UInt32) :=
    z_ProgramUniform1uiEXT_1(&program, location, v0);
    
    private z_ProgramUniform2uiEXT_adr := GetProcAddress('glProgramUniform2uiEXT');
    private z_ProgramUniform2uiEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: UInt32; v1: UInt32)>(z_ProgramUniform2uiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2uiEXT(&program: gl_program; location: Int32; v0: UInt32; v1: UInt32) :=
    z_ProgramUniform2uiEXT_1(&program, location, v0, v1);
    
    private z_ProgramUniform3uiEXT_adr := GetProcAddress('glProgramUniform3uiEXT');
    private z_ProgramUniform3uiEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32)>(z_ProgramUniform3uiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3uiEXT(&program: gl_program; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32) :=
    z_ProgramUniform3uiEXT_1(&program, location, v0, v1, v2);
    
    private z_ProgramUniform4uiEXT_adr := GetProcAddress('glProgramUniform4uiEXT');
    private z_ProgramUniform4uiEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32; v3: UInt32)>(z_ProgramUniform4uiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4uiEXT(&program: gl_program; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32; v3: UInt32) :=
    z_ProgramUniform4uiEXT_1(&program, location, v0, v1, v2, v3);
    
    private z_ProgramUniform1uivEXT_adr := GetProcAddress('glProgramUniform1uivEXT');
    private z_ProgramUniform1uivEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform1uivEXT_adr);
    private z_ProgramUniform1uivEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt32)>(z_ProgramUniform1uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1uivEXT(&program: gl_program; location: Int32; count: Int32; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform1uivEXT_2(&program, location, count, value[0]) else
        z_ProgramUniform1uivEXT_2(&program, location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1uivEXT(&program: gl_program; location: Int32; count: Int32; var value: UInt32) :=
    z_ProgramUniform1uivEXT_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1uivEXT(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform1uivEXT_1(&program, location, count, value);
    
    private z_ProgramUniform2uivEXT_adr := GetProcAddress('glProgramUniform2uivEXT');
    private z_ProgramUniform2uivEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform2uivEXT_adr);
    private z_ProgramUniform2uivEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt32)>(z_ProgramUniform2uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2uivEXT(&program: gl_program; location: Int32; count: Int32; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform2uivEXT_2(&program, location, count, value[0]) else
        z_ProgramUniform2uivEXT_2(&program, location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2uivEXT(&program: gl_program; location: Int32; count: Int32; var value: UInt32) :=
    z_ProgramUniform2uivEXT_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2uivEXT(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform2uivEXT_1(&program, location, count, value);
    
    private z_ProgramUniform3uivEXT_adr := GetProcAddress('glProgramUniform3uivEXT');
    private z_ProgramUniform3uivEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform3uivEXT_adr);
    private z_ProgramUniform3uivEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt32)>(z_ProgramUniform3uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3uivEXT(&program: gl_program; location: Int32; count: Int32; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform3uivEXT_2(&program, location, count, value[0]) else
        z_ProgramUniform3uivEXT_2(&program, location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3uivEXT(&program: gl_program; location: Int32; count: Int32; var value: UInt32) :=
    z_ProgramUniform3uivEXT_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3uivEXT(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform3uivEXT_1(&program, location, count, value);
    
    private z_ProgramUniform4uivEXT_adr := GetProcAddress('glProgramUniform4uivEXT');
    private z_ProgramUniform4uivEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform4uivEXT_adr);
    private z_ProgramUniform4uivEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt32)>(z_ProgramUniform4uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4uivEXT(&program: gl_program; location: Int32; count: Int32; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform4uivEXT_2(&program, location, count, value[0]) else
        z_ProgramUniform4uivEXT_2(&program, location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4uivEXT(&program: gl_program; location: Int32; count: Int32; var value: UInt32) :=
    z_ProgramUniform4uivEXT_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4uivEXT(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform4uivEXT_1(&program, location, count, value);
    
    private z_NamedProgramLocalParameters4fvEXT_adr := GetProcAddress('glNamedProgramLocalParameters4fvEXT');
    private z_NamedProgramLocalParameters4fvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; target: ProgramTarget; index: UInt32; count: Int32; &params: IntPtr)>(z_NamedProgramLocalParameters4fvEXT_adr);
    private z_NamedProgramLocalParameters4fvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; target: ProgramTarget; index: UInt32; count: Int32; var &params: single)>(z_NamedProgramLocalParameters4fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameters4fvEXT(&program: gl_program; target: ProgramTarget; index: UInt32; count: Int32; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_NamedProgramLocalParameters4fvEXT_2(&program, target, index, count, &params[0]) else
        z_NamedProgramLocalParameters4fvEXT_2(&program, target, index, count, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameters4fvEXT(&program: gl_program; target: ProgramTarget; index: UInt32; count: Int32; var &params: single) :=
    z_NamedProgramLocalParameters4fvEXT_2(&program, target, index, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameters4fvEXT(&program: gl_program; target: ProgramTarget; index: UInt32; count: Int32; &params: IntPtr) :=
    z_NamedProgramLocalParameters4fvEXT_1(&program, target, index, count, &params);
    
    private z_NamedProgramLocalParameterI4iEXT_adr := GetProcAddress('glNamedProgramLocalParameterI4iEXT');
    private z_NamedProgramLocalParameterI4iEXT_1 := GetProcOrNil&<procedure(&program: gl_program; target: ProgramTarget; index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32)>(z_NamedProgramLocalParameterI4iEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameterI4iEXT(&program: gl_program; target: ProgramTarget; index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32) :=
    z_NamedProgramLocalParameterI4iEXT_1(&program, target, index, x, y, z, w);
    
    private z_NamedProgramLocalParameterI4ivEXT_adr := GetProcAddress('glNamedProgramLocalParameterI4ivEXT');
    private z_NamedProgramLocalParameterI4ivEXT_1 := GetProcOrNil&<procedure(&program: gl_program; target: ProgramTarget; index: UInt32; &params: IntPtr)>(z_NamedProgramLocalParameterI4ivEXT_adr);
    private z_NamedProgramLocalParameterI4ivEXT_2 := GetProcOrNil&<procedure(&program: gl_program; target: ProgramTarget; index: UInt32; var &params: Int32)>(z_NamedProgramLocalParameterI4ivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameterI4ivEXT(&program: gl_program; target: ProgramTarget; index: UInt32; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_NamedProgramLocalParameterI4ivEXT_2(&program, target, index, &params[0]) else
        z_NamedProgramLocalParameterI4ivEXT_2(&program, target, index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameterI4ivEXT(&program: gl_program; target: ProgramTarget; index: UInt32; var &params: Int32) :=
    z_NamedProgramLocalParameterI4ivEXT_2(&program, target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameterI4ivEXT(&program: gl_program; target: ProgramTarget; index: UInt32; &params: IntPtr) :=
    z_NamedProgramLocalParameterI4ivEXT_1(&program, target, index, &params);
    
    private z_NamedProgramLocalParametersI4ivEXT_adr := GetProcAddress('glNamedProgramLocalParametersI4ivEXT');
    private z_NamedProgramLocalParametersI4ivEXT_1 := GetProcOrNil&<procedure(&program: gl_program; target: ProgramTarget; index: UInt32; count: Int32; &params: IntPtr)>(z_NamedProgramLocalParametersI4ivEXT_adr);
    private z_NamedProgramLocalParametersI4ivEXT_2 := GetProcOrNil&<procedure(&program: gl_program; target: ProgramTarget; index: UInt32; count: Int32; var &params: Int32)>(z_NamedProgramLocalParametersI4ivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParametersI4ivEXT(&program: gl_program; target: ProgramTarget; index: UInt32; count: Int32; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_NamedProgramLocalParametersI4ivEXT_2(&program, target, index, count, &params[0]) else
        z_NamedProgramLocalParametersI4ivEXT_2(&program, target, index, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParametersI4ivEXT(&program: gl_program; target: ProgramTarget; index: UInt32; count: Int32; var &params: Int32) :=
    z_NamedProgramLocalParametersI4ivEXT_2(&program, target, index, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParametersI4ivEXT(&program: gl_program; target: ProgramTarget; index: UInt32; count: Int32; &params: IntPtr) :=
    z_NamedProgramLocalParametersI4ivEXT_1(&program, target, index, count, &params);
    
    private z_NamedProgramLocalParameterI4uiEXT_adr := GetProcAddress('glNamedProgramLocalParameterI4uiEXT');
    private z_NamedProgramLocalParameterI4uiEXT_1 := GetProcOrNil&<procedure(&program: gl_program; target: ProgramTarget; index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32)>(z_NamedProgramLocalParameterI4uiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameterI4uiEXT(&program: gl_program; target: ProgramTarget; index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32) :=
    z_NamedProgramLocalParameterI4uiEXT_1(&program, target, index, x, y, z, w);
    
    private z_NamedProgramLocalParameterI4uivEXT_adr := GetProcAddress('glNamedProgramLocalParameterI4uivEXT');
    private z_NamedProgramLocalParameterI4uivEXT_1 := GetProcOrNil&<procedure(&program: gl_program; target: ProgramTarget; index: UInt32; &params: IntPtr)>(z_NamedProgramLocalParameterI4uivEXT_adr);
    private z_NamedProgramLocalParameterI4uivEXT_2 := GetProcOrNil&<procedure(&program: gl_program; target: ProgramTarget; index: UInt32; var &params: UInt32)>(z_NamedProgramLocalParameterI4uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameterI4uivEXT(&program: gl_program; target: ProgramTarget; index: UInt32; &params: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_NamedProgramLocalParameterI4uivEXT_2(&program, target, index, &params[0]) else
        z_NamedProgramLocalParameterI4uivEXT_2(&program, target, index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameterI4uivEXT(&program: gl_program; target: ProgramTarget; index: UInt32; var &params: UInt32) :=
    z_NamedProgramLocalParameterI4uivEXT_2(&program, target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameterI4uivEXT(&program: gl_program; target: ProgramTarget; index: UInt32; &params: IntPtr) :=
    z_NamedProgramLocalParameterI4uivEXT_1(&program, target, index, &params);
    
    private z_NamedProgramLocalParametersI4uivEXT_adr := GetProcAddress('glNamedProgramLocalParametersI4uivEXT');
    private z_NamedProgramLocalParametersI4uivEXT_1 := GetProcOrNil&<procedure(&program: gl_program; target: ProgramTarget; index: UInt32; count: Int32; &params: IntPtr)>(z_NamedProgramLocalParametersI4uivEXT_adr);
    private z_NamedProgramLocalParametersI4uivEXT_2 := GetProcOrNil&<procedure(&program: gl_program; target: ProgramTarget; index: UInt32; count: Int32; var &params: UInt32)>(z_NamedProgramLocalParametersI4uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParametersI4uivEXT(&program: gl_program; target: ProgramTarget; index: UInt32; count: Int32; &params: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_NamedProgramLocalParametersI4uivEXT_2(&program, target, index, count, &params[0]) else
        z_NamedProgramLocalParametersI4uivEXT_2(&program, target, index, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParametersI4uivEXT(&program: gl_program; target: ProgramTarget; index: UInt32; count: Int32; var &params: UInt32) :=
    z_NamedProgramLocalParametersI4uivEXT_2(&program, target, index, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParametersI4uivEXT(&program: gl_program; target: ProgramTarget; index: UInt32; count: Int32; &params: IntPtr) :=
    z_NamedProgramLocalParametersI4uivEXT_1(&program, target, index, count, &params);
    
    private z_GetNamedProgramLocalParameterIivEXT_adr := GetProcAddress('glGetNamedProgramLocalParameterIivEXT');
    private z_GetNamedProgramLocalParameterIivEXT_1 := GetProcOrNil&<procedure(&program: gl_program; target: ProgramTarget; index: UInt32; &params: IntPtr)>(z_GetNamedProgramLocalParameterIivEXT_adr);
    private z_GetNamedProgramLocalParameterIivEXT_2 := GetProcOrNil&<procedure(&program: gl_program; target: ProgramTarget; index: UInt32; var &params: Int32)>(z_GetNamedProgramLocalParameterIivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterIivEXT(&program: gl_program; target: ProgramTarget; index: UInt32; var &params: Int32) :=
    z_GetNamedProgramLocalParameterIivEXT_2(&program, target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterIivEXT(&program: gl_program; target: ProgramTarget; index: UInt32; &params: IntPtr) :=
    z_GetNamedProgramLocalParameterIivEXT_1(&program, target, index, &params);
    
    private z_GetNamedProgramLocalParameterIuivEXT_adr := GetProcAddress('glGetNamedProgramLocalParameterIuivEXT');
    private z_GetNamedProgramLocalParameterIuivEXT_1 := GetProcOrNil&<procedure(&program: gl_program; target: ProgramTarget; index: UInt32; &params: IntPtr)>(z_GetNamedProgramLocalParameterIuivEXT_adr);
    private z_GetNamedProgramLocalParameterIuivEXT_2 := GetProcOrNil&<procedure(&program: gl_program; target: ProgramTarget; index: UInt32; var &params: UInt32)>(z_GetNamedProgramLocalParameterIuivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterIuivEXT(&program: gl_program; target: ProgramTarget; index: UInt32; var &params: UInt32) :=
    z_GetNamedProgramLocalParameterIuivEXT_2(&program, target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterIuivEXT(&program: gl_program; target: ProgramTarget; index: UInt32; &params: IntPtr) :=
    z_GetNamedProgramLocalParameterIuivEXT_1(&program, target, index, &params);
    
    private z_EnableClientStateiEXT_adr := GetProcAddress('glEnableClientStateiEXT');
    private z_EnableClientStateiEXT_1 := GetProcOrNil&<procedure(&array: EnableCap; index: UInt32)>(z_EnableClientStateiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableClientStateiEXT(&array: EnableCap; index: UInt32) :=
    z_EnableClientStateiEXT_1(&array, index);
    
    private z_DisableClientStateiEXT_adr := GetProcAddress('glDisableClientStateiEXT');
    private z_DisableClientStateiEXT_1 := GetProcOrNil&<procedure(&array: EnableCap; index: UInt32)>(z_DisableClientStateiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableClientStateiEXT(&array: EnableCap; index: UInt32) :=
    z_DisableClientStateiEXT_1(&array, index);
    
    private z_GetFloati_vEXT_adr := GetProcAddress('glGetFloati_vEXT');
    private z_GetFloati_vEXT_1 := GetProcOrNil&<procedure(pname: GetPName; index: UInt32; &params: IntPtr)>(z_GetFloati_vEXT_adr);
    private z_GetFloati_vEXT_2 := GetProcOrNil&<procedure(pname: GetPName; index: UInt32; var &params: single)>(z_GetFloati_vEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloati_vEXT(pname: GetPName; index: UInt32; var &params: single) :=
    z_GetFloati_vEXT_2(pname, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloati_vEXT(pname: GetPName; index: UInt32; &params: IntPtr) :=
    z_GetFloati_vEXT_1(pname, index, &params);
    
    private z_GetDoublei_vEXT_adr := GetProcAddress('glGetDoublei_vEXT');
    private z_GetDoublei_vEXT_1 := GetProcOrNil&<procedure(pname: GetPName; index: UInt32; &params: IntPtr)>(z_GetDoublei_vEXT_adr);
    private z_GetDoublei_vEXT_2 := GetProcOrNil&<procedure(pname: GetPName; index: UInt32; var &params: real)>(z_GetDoublei_vEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDoublei_vEXT(pname: GetPName; index: UInt32; var &params: real) :=
    z_GetDoublei_vEXT_2(pname, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDoublei_vEXT(pname: GetPName; index: UInt32; &params: IntPtr) :=
    z_GetDoublei_vEXT_1(pname, index, &params);
    
    private z_GetPointeri_vEXT_adr := GetProcAddress('glGetPointeri_vEXT');
    private z_GetPointeri_vEXT_1 := GetProcOrNil&<procedure(pname: DummyEnum; index: UInt32; &params: pointer)>(z_GetPointeri_vEXT_adr);
    private z_GetPointeri_vEXT_2 := GetProcOrNil&<procedure(pname: DummyEnum; index: UInt32; var &params: IntPtr)>(z_GetPointeri_vEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointeri_vEXT(pname: DummyEnum; index: UInt32; var &params: IntPtr) :=
    z_GetPointeri_vEXT_2(pname, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointeri_vEXT(pname: DummyEnum; index: UInt32; &params: pointer) :=
    z_GetPointeri_vEXT_1(pname, index, &params);
    
    private z_NamedProgramStringEXT_adr := GetProcAddress('glNamedProgramStringEXT');
    private z_NamedProgramStringEXT_1 := GetProcOrNil&<procedure(&program: gl_program; target: ProgramTarget; format: ProgramFormat; len: Int32; string: IntPtr)>(z_NamedProgramStringEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramStringEXT(&program: gl_program; target: ProgramTarget; format: ProgramFormat; len: Int32; string: IntPtr) :=
    z_NamedProgramStringEXT_1(&program, target, format, len, string);
    
    private z_NamedProgramLocalParameter4dEXT_adr := GetProcAddress('glNamedProgramLocalParameter4dEXT');
    private z_NamedProgramLocalParameter4dEXT_1 := GetProcOrNil&<procedure(&program: gl_program; target: ProgramTarget; index: UInt32; x: real; y: real; z: real; w: real)>(z_NamedProgramLocalParameter4dEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameter4dEXT(&program: gl_program; target: ProgramTarget; index: UInt32; x: real; y: real; z: real; w: real) :=
    z_NamedProgramLocalParameter4dEXT_1(&program, target, index, x, y, z, w);
    
    private z_NamedProgramLocalParameter4dvEXT_adr := GetProcAddress('glNamedProgramLocalParameter4dvEXT');
    private z_NamedProgramLocalParameter4dvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; target: ProgramTarget; index: UInt32; &params: IntPtr)>(z_NamedProgramLocalParameter4dvEXT_adr);
    private z_NamedProgramLocalParameter4dvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; target: ProgramTarget; index: UInt32; var &params: real)>(z_NamedProgramLocalParameter4dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameter4dvEXT(&program: gl_program; target: ProgramTarget; index: UInt32; &params: array of real);
    type Preal=^real;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_NamedProgramLocalParameter4dvEXT_2(&program, target, index, &params[0]) else
        z_NamedProgramLocalParameter4dvEXT_2(&program, target, index, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameter4dvEXT(&program: gl_program; target: ProgramTarget; index: UInt32; var &params: real) :=
    z_NamedProgramLocalParameter4dvEXT_2(&program, target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameter4dvEXT(&program: gl_program; target: ProgramTarget; index: UInt32; &params: IntPtr) :=
    z_NamedProgramLocalParameter4dvEXT_1(&program, target, index, &params);
    
    private z_NamedProgramLocalParameter4fEXT_adr := GetProcAddress('glNamedProgramLocalParameter4fEXT');
    private z_NamedProgramLocalParameter4fEXT_1 := GetProcOrNil&<procedure(&program: gl_program; target: ProgramTarget; index: UInt32; x: single; y: single; z: single; w: single)>(z_NamedProgramLocalParameter4fEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameter4fEXT(&program: gl_program; target: ProgramTarget; index: UInt32; x: single; y: single; z: single; w: single) :=
    z_NamedProgramLocalParameter4fEXT_1(&program, target, index, x, y, z, w);
    
    private z_NamedProgramLocalParameter4fvEXT_adr := GetProcAddress('glNamedProgramLocalParameter4fvEXT');
    private z_NamedProgramLocalParameter4fvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; target: ProgramTarget; index: UInt32; &params: IntPtr)>(z_NamedProgramLocalParameter4fvEXT_adr);
    private z_NamedProgramLocalParameter4fvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; target: ProgramTarget; index: UInt32; var &params: single)>(z_NamedProgramLocalParameter4fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameter4fvEXT(&program: gl_program; target: ProgramTarget; index: UInt32; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_NamedProgramLocalParameter4fvEXT_2(&program, target, index, &params[0]) else
        z_NamedProgramLocalParameter4fvEXT_2(&program, target, index, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameter4fvEXT(&program: gl_program; target: ProgramTarget; index: UInt32; var &params: single) :=
    z_NamedProgramLocalParameter4fvEXT_2(&program, target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameter4fvEXT(&program: gl_program; target: ProgramTarget; index: UInt32; &params: IntPtr) :=
    z_NamedProgramLocalParameter4fvEXT_1(&program, target, index, &params);
    
    private z_GetNamedProgramLocalParameterdvEXT_adr := GetProcAddress('glGetNamedProgramLocalParameterdvEXT');
    private z_GetNamedProgramLocalParameterdvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; target: ProgramTarget; index: UInt32; &params: IntPtr)>(z_GetNamedProgramLocalParameterdvEXT_adr);
    private z_GetNamedProgramLocalParameterdvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; target: ProgramTarget; index: UInt32; var &params: real)>(z_GetNamedProgramLocalParameterdvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterdvEXT(&program: gl_program; target: ProgramTarget; index: UInt32; var &params: real) :=
    z_GetNamedProgramLocalParameterdvEXT_2(&program, target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterdvEXT(&program: gl_program; target: ProgramTarget; index: UInt32; &params: IntPtr) :=
    z_GetNamedProgramLocalParameterdvEXT_1(&program, target, index, &params);
    
    private z_GetNamedProgramLocalParameterfvEXT_adr := GetProcAddress('glGetNamedProgramLocalParameterfvEXT');
    private z_GetNamedProgramLocalParameterfvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; target: ProgramTarget; index: UInt32; &params: IntPtr)>(z_GetNamedProgramLocalParameterfvEXT_adr);
    private z_GetNamedProgramLocalParameterfvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; target: ProgramTarget; index: UInt32; var &params: single)>(z_GetNamedProgramLocalParameterfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterfvEXT(&program: gl_program; target: ProgramTarget; index: UInt32; var &params: single) :=
    z_GetNamedProgramLocalParameterfvEXT_2(&program, target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterfvEXT(&program: gl_program; target: ProgramTarget; index: UInt32; &params: IntPtr) :=
    z_GetNamedProgramLocalParameterfvEXT_1(&program, target, index, &params);
    
    private z_GetNamedProgramivEXT_adr := GetProcAddress('glGetNamedProgramivEXT');
    private z_GetNamedProgramivEXT_1 := GetProcOrNil&<procedure(&program: gl_program; target: ProgramTarget; pname: ProgramProperty; &params: IntPtr)>(z_GetNamedProgramivEXT_adr);
    private z_GetNamedProgramivEXT_2 := GetProcOrNil&<procedure(&program: gl_program; target: ProgramTarget; pname: ProgramProperty; var &params: Int32)>(z_GetNamedProgramivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramivEXT(&program: gl_program; target: ProgramTarget; pname: ProgramProperty; var &params: Int32) :=
    z_GetNamedProgramivEXT_2(&program, target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramivEXT(&program: gl_program; target: ProgramTarget; pname: ProgramProperty; &params: IntPtr) :=
    z_GetNamedProgramivEXT_1(&program, target, pname, &params);
    
    private z_GetNamedProgramStringEXT_adr := GetProcAddress('glGetNamedProgramStringEXT');
    private z_GetNamedProgramStringEXT_1 := GetProcOrNil&<procedure(&program: gl_program; target: ProgramTarget; pname: ProgramStringProperty; string: IntPtr)>(z_GetNamedProgramStringEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramStringEXT(&program: gl_program; target: ProgramTarget; pname: ProgramStringProperty; string: IntPtr) :=
    z_GetNamedProgramStringEXT_1(&program, target, pname, string);
    
    private z_NamedRenderbufferStorageEXT_adr := GetProcAddress('glNamedRenderbufferStorageEXT');
    private z_NamedRenderbufferStorageEXT_1 := GetProcOrNil&<procedure(renderbuffer: gl_renderbuffer; _internalformat: InternalFormat; width: Int32; height: Int32)>(z_NamedRenderbufferStorageEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedRenderbufferStorageEXT(renderbuffer: gl_renderbuffer; _internalformat: InternalFormat; width: Int32; height: Int32) :=
    z_NamedRenderbufferStorageEXT_1(renderbuffer, _internalformat, width, height);
    
    private z_GetNamedRenderbufferParameterivEXT_adr := GetProcAddress('glGetNamedRenderbufferParameterivEXT');
    private z_GetNamedRenderbufferParameterivEXT_1 := GetProcOrNil&<procedure(renderbuffer: gl_renderbuffer; pname: RenderbufferParameterName; &params: IntPtr)>(z_GetNamedRenderbufferParameterivEXT_adr);
    private z_GetNamedRenderbufferParameterivEXT_2 := GetProcOrNil&<procedure(renderbuffer: gl_renderbuffer; pname: RenderbufferParameterName; var &params: Int32)>(z_GetNamedRenderbufferParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedRenderbufferParameterivEXT(renderbuffer: gl_renderbuffer; pname: RenderbufferParameterName; var &params: Int32) :=
    z_GetNamedRenderbufferParameterivEXT_2(renderbuffer, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedRenderbufferParameterivEXT(renderbuffer: gl_renderbuffer; pname: RenderbufferParameterName; &params: IntPtr) :=
    z_GetNamedRenderbufferParameterivEXT_1(renderbuffer, pname, &params);
    
    private z_NamedRenderbufferStorageMultisampleEXT_adr := GetProcAddress('glNamedRenderbufferStorageMultisampleEXT');
    private z_NamedRenderbufferStorageMultisampleEXT_1 := GetProcOrNil&<procedure(renderbuffer: gl_renderbuffer; samples: Int32; _internalformat: InternalFormat; width: Int32; height: Int32)>(z_NamedRenderbufferStorageMultisampleEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedRenderbufferStorageMultisampleEXT(renderbuffer: gl_renderbuffer; samples: Int32; _internalformat: InternalFormat; width: Int32; height: Int32) :=
    z_NamedRenderbufferStorageMultisampleEXT_1(renderbuffer, samples, _internalformat, width, height);
    
    private z_NamedRenderbufferStorageMultisampleCoverageEXT_adr := GetProcAddress('glNamedRenderbufferStorageMultisampleCoverageEXT');
    private z_NamedRenderbufferStorageMultisampleCoverageEXT_1 := GetProcOrNil&<procedure(renderbuffer: gl_renderbuffer; coverageSamples: Int32; colorSamples: Int32; _internalformat: InternalFormat; width: Int32; height: Int32)>(z_NamedRenderbufferStorageMultisampleCoverageEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedRenderbufferStorageMultisampleCoverageEXT(renderbuffer: gl_renderbuffer; coverageSamples: Int32; colorSamples: Int32; _internalformat: InternalFormat; width: Int32; height: Int32) :=
    z_NamedRenderbufferStorageMultisampleCoverageEXT_1(renderbuffer, coverageSamples, colorSamples, _internalformat, width, height);
    
    private z_CheckNamedFramebufferStatusEXT_adr := GetProcAddress('glCheckNamedFramebufferStatusEXT');
    private z_CheckNamedFramebufferStatusEXT_1 := GetProcOrNil&<function(framebuffer: gl_framebuffer; target: FramebufferTarget): FramebufferStatus>(z_CheckNamedFramebufferStatusEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CheckNamedFramebufferStatusEXT(framebuffer: gl_framebuffer; target: FramebufferTarget): FramebufferStatus :=
    z_CheckNamedFramebufferStatusEXT_1(framebuffer, target);
    
    private z_NamedFramebufferTexture1DEXT_adr := GetProcAddress('glNamedFramebufferTexture1DEXT');
    private z_NamedFramebufferTexture1DEXT_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; textarget: TextureTarget; texture: gl_texture; level: Int32)>(z_NamedFramebufferTexture1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferTexture1DEXT(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; textarget: TextureTarget; texture: gl_texture; level: Int32) :=
    z_NamedFramebufferTexture1DEXT_1(framebuffer, attachment, textarget, texture, level);
    
    private z_NamedFramebufferTexture2DEXT_adr := GetProcAddress('glNamedFramebufferTexture2DEXT');
    private z_NamedFramebufferTexture2DEXT_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; textarget: TextureTarget; texture: gl_texture; level: Int32)>(z_NamedFramebufferTexture2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferTexture2DEXT(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; textarget: TextureTarget; texture: gl_texture; level: Int32) :=
    z_NamedFramebufferTexture2DEXT_1(framebuffer, attachment, textarget, texture, level);
    
    private z_NamedFramebufferTexture3DEXT_adr := GetProcAddress('glNamedFramebufferTexture3DEXT');
    private z_NamedFramebufferTexture3DEXT_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; textarget: TextureTarget; texture: gl_texture; level: Int32; zoffset: Int32)>(z_NamedFramebufferTexture3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferTexture3DEXT(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; textarget: TextureTarget; texture: gl_texture; level: Int32; zoffset: Int32) :=
    z_NamedFramebufferTexture3DEXT_1(framebuffer, attachment, textarget, texture, level, zoffset);
    
    private z_NamedFramebufferRenderbufferEXT_adr := GetProcAddress('glNamedFramebufferRenderbufferEXT');
    private z_NamedFramebufferRenderbufferEXT_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; _renderbuffertarget: RenderbufferTarget; renderbuffer: gl_renderbuffer)>(z_NamedFramebufferRenderbufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferRenderbufferEXT(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; _renderbuffertarget: RenderbufferTarget; renderbuffer: gl_renderbuffer) :=
    z_NamedFramebufferRenderbufferEXT_1(framebuffer, attachment, _renderbuffertarget, renderbuffer);
    
    private z_GetNamedFramebufferAttachmentParameterivEXT_adr := GetProcAddress('glGetNamedFramebufferAttachmentParameterivEXT');
    private z_GetNamedFramebufferAttachmentParameterivEXT_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; pname: FramebufferAttachmentParameterName; &params: IntPtr)>(z_GetNamedFramebufferAttachmentParameterivEXT_adr);
    private z_GetNamedFramebufferAttachmentParameterivEXT_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; pname: FramebufferAttachmentParameterName; var &params: Int32)>(z_GetNamedFramebufferAttachmentParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferAttachmentParameterivEXT(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; pname: FramebufferAttachmentParameterName; var &params: Int32) :=
    z_GetNamedFramebufferAttachmentParameterivEXT_2(framebuffer, attachment, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferAttachmentParameterivEXT(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; pname: FramebufferAttachmentParameterName; &params: IntPtr) :=
    z_GetNamedFramebufferAttachmentParameterivEXT_1(framebuffer, attachment, pname, &params);
    
    private z_GenerateTextureMipmapEXT_adr := GetProcAddress('glGenerateTextureMipmapEXT');
    private z_GenerateTextureMipmapEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget)>(z_GenerateTextureMipmapEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenerateTextureMipmapEXT(texture: gl_texture; target: TextureTarget) :=
    z_GenerateTextureMipmapEXT_1(texture, target);
    
    private z_GenerateMultiTexMipmapEXT_adr := GetProcAddress('glGenerateMultiTexMipmapEXT');
    private z_GenerateMultiTexMipmapEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget)>(z_GenerateMultiTexMipmapEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenerateMultiTexMipmapEXT(texunit: TextureUnit; target: TextureTarget) :=
    z_GenerateMultiTexMipmapEXT_1(texunit, target);
    
    private z_FramebufferDrawBufferEXT_adr := GetProcAddress('glFramebufferDrawBufferEXT');
    private z_FramebufferDrawBufferEXT_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; mode: DrawBufferMode)>(z_FramebufferDrawBufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferDrawBufferEXT(framebuffer: gl_framebuffer; mode: DrawBufferMode) :=
    z_FramebufferDrawBufferEXT_1(framebuffer, mode);
    
    private z_FramebufferDrawBuffersEXT_adr := GetProcAddress('glFramebufferDrawBuffersEXT');
    private z_FramebufferDrawBuffersEXT_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; n: Int32; bufs: IntPtr)>(z_FramebufferDrawBuffersEXT_adr);
    private z_FramebufferDrawBuffersEXT_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; n: Int32; var bufs: DrawBufferMode)>(z_FramebufferDrawBuffersEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferDrawBuffersEXT(framebuffer: gl_framebuffer; n: Int32; bufs: array of DrawBufferMode);
    type PDrawBufferMode=^DrawBufferMode;
    begin
      if (bufs<>nil) and (bufs.Length<>0) then
        z_FramebufferDrawBuffersEXT_2(framebuffer, n, bufs[0]) else
        z_FramebufferDrawBuffersEXT_2(framebuffer, n, PDrawBufferMode(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferDrawBuffersEXT(framebuffer: gl_framebuffer; n: Int32; var bufs: DrawBufferMode) :=
    z_FramebufferDrawBuffersEXT_2(framebuffer, n, bufs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferDrawBuffersEXT(framebuffer: gl_framebuffer; n: Int32; bufs: IntPtr) :=
    z_FramebufferDrawBuffersEXT_1(framebuffer, n, bufs);
    
    private z_FramebufferReadBufferEXT_adr := GetProcAddress('glFramebufferReadBufferEXT');
    private z_FramebufferReadBufferEXT_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; mode: ReadBufferMode)>(z_FramebufferReadBufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferReadBufferEXT(framebuffer: gl_framebuffer; mode: ReadBufferMode) :=
    z_FramebufferReadBufferEXT_1(framebuffer, mode);
    
    private z_GetFramebufferParameterivEXT_adr := GetProcAddress('glGetFramebufferParameterivEXT');
    private z_GetFramebufferParameterivEXT_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; pname: GetFramebufferParameter; &params: IntPtr)>(z_GetFramebufferParameterivEXT_adr);
    private z_GetFramebufferParameterivEXT_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; pname: GetFramebufferParameter; var &params: Int32)>(z_GetFramebufferParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferParameterivEXT(framebuffer: gl_framebuffer; pname: GetFramebufferParameter; var &params: Int32) :=
    z_GetFramebufferParameterivEXT_2(framebuffer, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferParameterivEXT(framebuffer: gl_framebuffer; pname: GetFramebufferParameter; &params: IntPtr) :=
    z_GetFramebufferParameterivEXT_1(framebuffer, pname, &params);
    
    private z_NamedCopyBufferSubDataEXT_adr := GetProcAddress('glNamedCopyBufferSubDataEXT');
    private z_NamedCopyBufferSubDataEXT_1 := GetProcOrNil&<procedure(readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr)>(z_NamedCopyBufferSubDataEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedCopyBufferSubDataEXT(readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr) :=
    z_NamedCopyBufferSubDataEXT_1(readBuffer, writeBuffer, readOffset, writeOffset, size);
    
    private z_NamedFramebufferTextureEXT_adr := GetProcAddress('glNamedFramebufferTextureEXT');
    private z_NamedFramebufferTextureEXT_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; texture: gl_texture; level: Int32)>(z_NamedFramebufferTextureEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferTextureEXT(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; texture: gl_texture; level: Int32) :=
    z_NamedFramebufferTextureEXT_1(framebuffer, attachment, texture, level);
    
    private z_NamedFramebufferTextureLayerEXT_adr := GetProcAddress('glNamedFramebufferTextureLayerEXT');
    private z_NamedFramebufferTextureLayerEXT_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; texture: gl_texture; level: Int32; layer: Int32)>(z_NamedFramebufferTextureLayerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferTextureLayerEXT(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; texture: gl_texture; level: Int32; layer: Int32) :=
    z_NamedFramebufferTextureLayerEXT_1(framebuffer, attachment, texture, level, layer);
    
    private z_NamedFramebufferTextureFaceEXT_adr := GetProcAddress('glNamedFramebufferTextureFaceEXT');
    private z_NamedFramebufferTextureFaceEXT_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; texture: gl_texture; level: Int32; face: TextureTarget)>(z_NamedFramebufferTextureFaceEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferTextureFaceEXT(framebuffer: gl_framebuffer; attachment: FramebufferAttachment; texture: gl_texture; level: Int32; face: TextureTarget) :=
    z_NamedFramebufferTextureFaceEXT_1(framebuffer, attachment, texture, level, face);
    
    private z_TextureRenderbufferEXT_adr := GetProcAddress('glTextureRenderbufferEXT');
    private z_TextureRenderbufferEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; renderbuffer: gl_renderbuffer)>(z_TextureRenderbufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureRenderbufferEXT(texture: gl_texture; target: TextureTarget; renderbuffer: gl_renderbuffer) :=
    z_TextureRenderbufferEXT_1(texture, target, renderbuffer);
    
    private z_MultiTexRenderbufferEXT_adr := GetProcAddress('glMultiTexRenderbufferEXT');
    private z_MultiTexRenderbufferEXT_1 := GetProcOrNil&<procedure(texunit: TextureUnit; target: TextureTarget; renderbuffer: gl_renderbuffer)>(z_MultiTexRenderbufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexRenderbufferEXT(texunit: TextureUnit; target: TextureTarget; renderbuffer: gl_renderbuffer) :=
    z_MultiTexRenderbufferEXT_1(texunit, target, renderbuffer);
    
    private z_VertexArrayVertexOffsetEXT_adr := GetProcAddress('glVertexArrayVertexOffsetEXT');
    private z_VertexArrayVertexOffsetEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; buffer: gl_buffer; size: Int32; &type: VertexPointerType; stride: Int32; offset: IntPtr)>(z_VertexArrayVertexOffsetEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexOffsetEXT(vaobj: gl_vertex_array; buffer: gl_buffer; size: Int32; &type: VertexPointerType; stride: Int32; offset: IntPtr) :=
    z_VertexArrayVertexOffsetEXT_1(vaobj, buffer, size, &type, stride, offset);
    
    private z_VertexArrayColorOffsetEXT_adr := GetProcAddress('glVertexArrayColorOffsetEXT');
    private z_VertexArrayColorOffsetEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; buffer: gl_buffer; size: Int32; &type: ColorPointerType; stride: Int32; offset: IntPtr)>(z_VertexArrayColorOffsetEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayColorOffsetEXT(vaobj: gl_vertex_array; buffer: gl_buffer; size: Int32; &type: ColorPointerType; stride: Int32; offset: IntPtr) :=
    z_VertexArrayColorOffsetEXT_1(vaobj, buffer, size, &type, stride, offset);
    
    private z_VertexArrayEdgeFlagOffsetEXT_adr := GetProcAddress('glVertexArrayEdgeFlagOffsetEXT');
    private z_VertexArrayEdgeFlagOffsetEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; buffer: gl_buffer; stride: Int32; offset: IntPtr)>(z_VertexArrayEdgeFlagOffsetEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayEdgeFlagOffsetEXT(vaobj: gl_vertex_array; buffer: gl_buffer; stride: Int32; offset: IntPtr) :=
    z_VertexArrayEdgeFlagOffsetEXT_1(vaobj, buffer, stride, offset);
    
    private z_VertexArrayIndexOffsetEXT_adr := GetProcAddress('glVertexArrayIndexOffsetEXT');
    private z_VertexArrayIndexOffsetEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; buffer: gl_buffer; &type: IndexPointerType; stride: Int32; offset: IntPtr)>(z_VertexArrayIndexOffsetEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayIndexOffsetEXT(vaobj: gl_vertex_array; buffer: gl_buffer; &type: IndexPointerType; stride: Int32; offset: IntPtr) :=
    z_VertexArrayIndexOffsetEXT_1(vaobj, buffer, &type, stride, offset);
    
    private z_VertexArrayNormalOffsetEXT_adr := GetProcAddress('glVertexArrayNormalOffsetEXT');
    private z_VertexArrayNormalOffsetEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; buffer: gl_buffer; &type: NormalPointerType; stride: Int32; offset: IntPtr)>(z_VertexArrayNormalOffsetEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayNormalOffsetEXT(vaobj: gl_vertex_array; buffer: gl_buffer; &type: NormalPointerType; stride: Int32; offset: IntPtr) :=
    z_VertexArrayNormalOffsetEXT_1(vaobj, buffer, &type, stride, offset);
    
    private z_VertexArrayTexCoordOffsetEXT_adr := GetProcAddress('glVertexArrayTexCoordOffsetEXT');
    private z_VertexArrayTexCoordOffsetEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; buffer: gl_buffer; size: Int32; &type: TexCoordPointerType; stride: Int32; offset: IntPtr)>(z_VertexArrayTexCoordOffsetEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayTexCoordOffsetEXT(vaobj: gl_vertex_array; buffer: gl_buffer; size: Int32; &type: TexCoordPointerType; stride: Int32; offset: IntPtr) :=
    z_VertexArrayTexCoordOffsetEXT_1(vaobj, buffer, size, &type, stride, offset);
    
    private z_VertexArrayMultiTexCoordOffsetEXT_adr := GetProcAddress('glVertexArrayMultiTexCoordOffsetEXT');
    private z_VertexArrayMultiTexCoordOffsetEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; buffer: gl_buffer; texunit: DummyEnum; size: Int32; &type: TexCoordPointerType; stride: Int32; offset: IntPtr)>(z_VertexArrayMultiTexCoordOffsetEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayMultiTexCoordOffsetEXT(vaobj: gl_vertex_array; buffer: gl_buffer; texunit: DummyEnum; size: Int32; &type: TexCoordPointerType; stride: Int32; offset: IntPtr) :=
    z_VertexArrayMultiTexCoordOffsetEXT_1(vaobj, buffer, texunit, size, &type, stride, offset);
    
    private z_VertexArrayFogCoordOffsetEXT_adr := GetProcAddress('glVertexArrayFogCoordOffsetEXT');
    private z_VertexArrayFogCoordOffsetEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; buffer: gl_buffer; &type: FogCoordinatePointerType; stride: Int32; offset: IntPtr)>(z_VertexArrayFogCoordOffsetEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayFogCoordOffsetEXT(vaobj: gl_vertex_array; buffer: gl_buffer; &type: FogCoordinatePointerType; stride: Int32; offset: IntPtr) :=
    z_VertexArrayFogCoordOffsetEXT_1(vaobj, buffer, &type, stride, offset);
    
    private z_VertexArraySecondaryColorOffsetEXT_adr := GetProcAddress('glVertexArraySecondaryColorOffsetEXT');
    private z_VertexArraySecondaryColorOffsetEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; buffer: gl_buffer; size: Int32; &type: ColorPointerType; stride: Int32; offset: IntPtr)>(z_VertexArraySecondaryColorOffsetEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArraySecondaryColorOffsetEXT(vaobj: gl_vertex_array; buffer: gl_buffer; size: Int32; &type: ColorPointerType; stride: Int32; offset: IntPtr) :=
    z_VertexArraySecondaryColorOffsetEXT_1(vaobj, buffer, size, &type, stride, offset);
    
    private z_VertexArrayVertexAttribOffsetEXT_adr := GetProcAddress('glVertexArrayVertexAttribOffsetEXT');
    private z_VertexArrayVertexAttribOffsetEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; buffer: gl_buffer; index: UInt32; size: Int32; &type: VertexAttribPointerType; normalized: boolean; stride: Int32; offset: IntPtr)>(z_VertexArrayVertexAttribOffsetEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexAttribOffsetEXT(vaobj: gl_vertex_array; buffer: gl_buffer; index: UInt32; size: Int32; &type: VertexAttribPointerType; normalized: boolean; stride: Int32; offset: IntPtr) :=
    z_VertexArrayVertexAttribOffsetEXT_1(vaobj, buffer, index, size, &type, normalized, stride, offset);
    
    private z_VertexArrayVertexAttribIOffsetEXT_adr := GetProcAddress('glVertexArrayVertexAttribIOffsetEXT');
    private z_VertexArrayVertexAttribIOffsetEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; buffer: gl_buffer; index: UInt32; size: Int32; &type: VertexAttribType; stride: Int32; offset: IntPtr)>(z_VertexArrayVertexAttribIOffsetEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexAttribIOffsetEXT(vaobj: gl_vertex_array; buffer: gl_buffer; index: UInt32; size: Int32; &type: VertexAttribType; stride: Int32; offset: IntPtr) :=
    z_VertexArrayVertexAttribIOffsetEXT_1(vaobj, buffer, index, size, &type, stride, offset);
    
    private z_EnableVertexArrayEXT_adr := GetProcAddress('glEnableVertexArrayEXT');
    private z_EnableVertexArrayEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; &array: EnableCap)>(z_EnableVertexArrayEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableVertexArrayEXT(vaobj: gl_vertex_array; &array: EnableCap) :=
    z_EnableVertexArrayEXT_1(vaobj, &array);
    
    private z_DisableVertexArrayEXT_adr := GetProcAddress('glDisableVertexArrayEXT');
    private z_DisableVertexArrayEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; &array: EnableCap)>(z_DisableVertexArrayEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableVertexArrayEXT(vaobj: gl_vertex_array; &array: EnableCap) :=
    z_DisableVertexArrayEXT_1(vaobj, &array);
    
    private z_EnableVertexArrayAttribEXT_adr := GetProcAddress('glEnableVertexArrayAttribEXT');
    private z_EnableVertexArrayAttribEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32)>(z_EnableVertexArrayAttribEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableVertexArrayAttribEXT(vaobj: gl_vertex_array; index: UInt32) :=
    z_EnableVertexArrayAttribEXT_1(vaobj, index);
    
    private z_DisableVertexArrayAttribEXT_adr := GetProcAddress('glDisableVertexArrayAttribEXT');
    private z_DisableVertexArrayAttribEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32)>(z_DisableVertexArrayAttribEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableVertexArrayAttribEXT(vaobj: gl_vertex_array; index: UInt32) :=
    z_DisableVertexArrayAttribEXT_1(vaobj, index);
    
    private z_GetVertexArrayIntegervEXT_adr := GetProcAddress('glGetVertexArrayIntegervEXT');
    private z_GetVertexArrayIntegervEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; pname: VertexArrayPName; param: IntPtr)>(z_GetVertexArrayIntegervEXT_adr);
    private z_GetVertexArrayIntegervEXT_2 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; pname: VertexArrayPName; var param: Int32)>(z_GetVertexArrayIntegervEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIntegervEXT(vaobj: gl_vertex_array; pname: VertexArrayPName; var param: Int32) :=
    z_GetVertexArrayIntegervEXT_2(vaobj, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIntegervEXT(vaobj: gl_vertex_array; pname: VertexArrayPName; param: IntPtr) :=
    z_GetVertexArrayIntegervEXT_1(vaobj, pname, param);
    
    private z_GetVertexArrayPointervEXT_adr := GetProcAddress('glGetVertexArrayPointervEXT');
    private z_GetVertexArrayPointervEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; pname: VertexArrayPName; param: pointer)>(z_GetVertexArrayPointervEXT_adr);
    private z_GetVertexArrayPointervEXT_2 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; pname: VertexArrayPName; var param: IntPtr)>(z_GetVertexArrayPointervEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayPointervEXT(vaobj: gl_vertex_array; pname: VertexArrayPName; var param: IntPtr) :=
    z_GetVertexArrayPointervEXT_2(vaobj, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayPointervEXT(vaobj: gl_vertex_array; pname: VertexArrayPName; param: pointer) :=
    z_GetVertexArrayPointervEXT_1(vaobj, pname, param);
    
    private z_GetVertexArrayIntegeri_vEXT_adr := GetProcAddress('glGetVertexArrayIntegeri_vEXT');
    private z_GetVertexArrayIntegeri_vEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32; pname: VertexArrayPName; param: IntPtr)>(z_GetVertexArrayIntegeri_vEXT_adr);
    private z_GetVertexArrayIntegeri_vEXT_2 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32; pname: VertexArrayPName; var param: Int32)>(z_GetVertexArrayIntegeri_vEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIntegeri_vEXT(vaobj: gl_vertex_array; index: UInt32; pname: VertexArrayPName; var param: Int32) :=
    z_GetVertexArrayIntegeri_vEXT_2(vaobj, index, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIntegeri_vEXT(vaobj: gl_vertex_array; index: UInt32; pname: VertexArrayPName; param: IntPtr) :=
    z_GetVertexArrayIntegeri_vEXT_1(vaobj, index, pname, param);
    
    private z_GetVertexArrayPointeri_vEXT_adr := GetProcAddress('glGetVertexArrayPointeri_vEXT');
    private z_GetVertexArrayPointeri_vEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32; pname: VertexArrayPName; param: pointer)>(z_GetVertexArrayPointeri_vEXT_adr);
    private z_GetVertexArrayPointeri_vEXT_2 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32; pname: VertexArrayPName; var param: IntPtr)>(z_GetVertexArrayPointeri_vEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayPointeri_vEXT(vaobj: gl_vertex_array; index: UInt32; pname: VertexArrayPName; var param: IntPtr) :=
    z_GetVertexArrayPointeri_vEXT_2(vaobj, index, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayPointeri_vEXT(vaobj: gl_vertex_array; index: UInt32; pname: VertexArrayPName; param: pointer) :=
    z_GetVertexArrayPointeri_vEXT_1(vaobj, index, pname, param);
    
    private z_MapNamedBufferRangeEXT_adr := GetProcAddress('glMapNamedBufferRangeEXT');
    private z_MapNamedBufferRangeEXT_1 := GetProcOrNil&<function(buffer: gl_buffer; offset: IntPtr; length: UIntPtr; access: MapBufferAccessMask): IntPtr>(z_MapNamedBufferRangeEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapNamedBufferRangeEXT(buffer: gl_buffer; offset: IntPtr; length: UIntPtr; access: MapBufferAccessMask): IntPtr :=
    z_MapNamedBufferRangeEXT_1(buffer, offset, length, access);
    
    private z_FlushMappedNamedBufferRangeEXT_adr := GetProcAddress('glFlushMappedNamedBufferRangeEXT');
    private z_FlushMappedNamedBufferRangeEXT_1 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; length: UIntPtr)>(z_FlushMappedNamedBufferRangeEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FlushMappedNamedBufferRangeEXT(buffer: gl_buffer; offset: IntPtr; length: UIntPtr) :=
    z_FlushMappedNamedBufferRangeEXT_1(buffer, offset, length);
    
    private z_NamedBufferStorageEXT_adr := GetProcAddress('glNamedBufferStorageEXT');
    private z_NamedBufferStorageEXT_1 := GetProcOrNil&<procedure(buffer: gl_buffer; size: UIntPtr; data: pointer; flags: BufferStorageMask)>(z_NamedBufferStorageEXT_adr);
    private z_NamedBufferStorageEXT_2 := GetProcOrNil&<procedure(buffer: gl_buffer; size: UIntPtr; var data: Byte; flags: BufferStorageMask)>(z_NamedBufferStorageEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferStorageEXT<T>(buffer: gl_buffer; size: UIntPtr; data: array of T; flags: BufferStorageMask); where T: record;
    type PT=^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        NamedBufferStorageEXT(buffer, size, data[0], flags) else
        NamedBufferStorageEXT(buffer, size, PT(nil)^, flags);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferStorageEXT<T>(buffer: gl_buffer; size: UIntPtr; var data: T; flags: BufferStorageMask); where T: record;
    begin
      z_NamedBufferStorageEXT_2(buffer, size, PByte(pointer(@data))^, flags);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferStorageEXT(buffer: gl_buffer; size: UIntPtr; data: pointer; flags: BufferStorageMask) :=
    z_NamedBufferStorageEXT_1(buffer, size, data, flags);
    
    private z_ClearNamedBufferDataEXT_adr := GetProcAddress('glClearNamedBufferDataEXT');
    private z_ClearNamedBufferDataEXT_1 := GetProcOrNil&<procedure(buffer: gl_buffer; internalformat: SizedInternalFormat; format: PixelFormat; &type: PixelType; data: pointer)>(z_ClearNamedBufferDataEXT_adr);
    private z_ClearNamedBufferDataEXT_2 := GetProcOrNil&<procedure(buffer: gl_buffer; internalformat: SizedInternalFormat; format: PixelFormat; &type: PixelType; var data: Byte)>(z_ClearNamedBufferDataEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferDataEXT<T>(buffer: gl_buffer; internalformat: SizedInternalFormat; format: PixelFormat; &type: PixelType; data: array of T); where T: record;
    type PT=^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        ClearNamedBufferDataEXT(buffer, internalformat, format, &type, data[0]) else
        ClearNamedBufferDataEXT(buffer, internalformat, format, &type, PT(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferDataEXT<T>(buffer: gl_buffer; internalformat: SizedInternalFormat; format: PixelFormat; &type: PixelType; var data: T); where T: record;
    begin
      z_ClearNamedBufferDataEXT_2(buffer, internalformat, format, &type, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferDataEXT(buffer: gl_buffer; internalformat: SizedInternalFormat; format: PixelFormat; &type: PixelType; data: pointer) :=
    z_ClearNamedBufferDataEXT_1(buffer, internalformat, format, &type, data);
    
    private z_ClearNamedBufferSubDataEXT_adr := GetProcAddress('glClearNamedBufferSubDataEXT');
    private z_ClearNamedBufferSubDataEXT_1 := GetProcOrNil&<procedure(buffer: gl_buffer; internalformat: SizedInternalFormat; offset: UIntPtr; size: UIntPtr; format: PixelFormat; &type: PixelType; data: pointer)>(z_ClearNamedBufferSubDataEXT_adr);
    private z_ClearNamedBufferSubDataEXT_2 := GetProcOrNil&<procedure(buffer: gl_buffer; internalformat: SizedInternalFormat; offset: UIntPtr; size: UIntPtr; format: PixelFormat; &type: PixelType; var data: Byte)>(z_ClearNamedBufferSubDataEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferSubDataEXT<T>(buffer: gl_buffer; internalformat: SizedInternalFormat; offset: UIntPtr; size: UIntPtr; format: PixelFormat; &type: PixelType; data: array of T); where T: record;
    type PT=^T;
    begin
      if (data<>nil) and (data.Length<>0) then
        ClearNamedBufferSubDataEXT(buffer, internalformat, offset, size, format, &type, data[0]) else
        ClearNamedBufferSubDataEXT(buffer, internalformat, offset, size, format, &type, PT(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferSubDataEXT<T>(buffer: gl_buffer; internalformat: SizedInternalFormat; offset: UIntPtr; size: UIntPtr; format: PixelFormat; &type: PixelType; var data: T); where T: record;
    begin
      z_ClearNamedBufferSubDataEXT_2(buffer, internalformat, offset, size, format, &type, PByte(pointer(@data))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferSubDataEXT(buffer: gl_buffer; internalformat: SizedInternalFormat; offset: UIntPtr; size: UIntPtr; format: PixelFormat; &type: PixelType; data: pointer) :=
    z_ClearNamedBufferSubDataEXT_1(buffer, internalformat, offset, size, format, &type, data);
    
    private z_NamedFramebufferParameteriEXT_adr := GetProcAddress('glNamedFramebufferParameteriEXT');
    private z_NamedFramebufferParameteriEXT_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; pname: FramebufferParameterName; param: Int32)>(z_NamedFramebufferParameteriEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferParameteriEXT(framebuffer: gl_framebuffer; pname: FramebufferParameterName; param: Int32) :=
    z_NamedFramebufferParameteriEXT_1(framebuffer, pname, param);
    
    private z_GetNamedFramebufferParameterivEXT_adr := GetProcAddress('glGetNamedFramebufferParameterivEXT');
    private z_GetNamedFramebufferParameterivEXT_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; pname: GetFramebufferParameter; &params: IntPtr)>(z_GetNamedFramebufferParameterivEXT_adr);
    private z_GetNamedFramebufferParameterivEXT_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; pname: GetFramebufferParameter; var &params: Int32)>(z_GetNamedFramebufferParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferParameterivEXT(framebuffer: gl_framebuffer; pname: GetFramebufferParameter; var &params: Int32) :=
    z_GetNamedFramebufferParameterivEXT_2(framebuffer, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferParameterivEXT(framebuffer: gl_framebuffer; pname: GetFramebufferParameter; &params: IntPtr) :=
    z_GetNamedFramebufferParameterivEXT_1(framebuffer, pname, &params);
    
    private z_ProgramUniform1dEXT_adr := GetProcAddress('glProgramUniform1dEXT');
    private z_ProgramUniform1dEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: real)>(z_ProgramUniform1dEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1dEXT(&program: gl_program; location: Int32; x: real) :=
    z_ProgramUniform1dEXT_1(&program, location, x);
    
    private z_ProgramUniform2dEXT_adr := GetProcAddress('glProgramUniform2dEXT');
    private z_ProgramUniform2dEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: real; y: real)>(z_ProgramUniform2dEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2dEXT(&program: gl_program; location: Int32; x: real; y: real) :=
    z_ProgramUniform2dEXT_1(&program, location, x, y);
    
    private z_ProgramUniform3dEXT_adr := GetProcAddress('glProgramUniform3dEXT');
    private z_ProgramUniform3dEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: real; y: real; z: real)>(z_ProgramUniform3dEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3dEXT(&program: gl_program; location: Int32; x: real; y: real; z: real) :=
    z_ProgramUniform3dEXT_1(&program, location, x, y, z);
    
    private z_ProgramUniform4dEXT_adr := GetProcAddress('glProgramUniform4dEXT');
    private z_ProgramUniform4dEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: real; y: real; z: real; w: real)>(z_ProgramUniform4dEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4dEXT(&program: gl_program; location: Int32; x: real; y: real; z: real; w: real) :=
    z_ProgramUniform4dEXT_1(&program, location, x, y, z, w);
    
    private z_ProgramUniform1dvEXT_adr := GetProcAddress('glProgramUniform1dvEXT');
    private z_ProgramUniform1dvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform1dvEXT_adr);
    private z_ProgramUniform1dvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: real)>(z_ProgramUniform1dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1dvEXT(&program: gl_program; location: Int32; count: Int32; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform1dvEXT_2(&program, location, count, value[0]) else
        z_ProgramUniform1dvEXT_2(&program, location, count, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1dvEXT(&program: gl_program; location: Int32; count: Int32; var value: real) :=
    z_ProgramUniform1dvEXT_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1dvEXT(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform1dvEXT_1(&program, location, count, value);
    
    private z_ProgramUniform2dvEXT_adr := GetProcAddress('glProgramUniform2dvEXT');
    private z_ProgramUniform2dvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform2dvEXT_adr);
    private z_ProgramUniform2dvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: real)>(z_ProgramUniform2dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2dvEXT(&program: gl_program; location: Int32; count: Int32; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform2dvEXT_2(&program, location, count, value[0]) else
        z_ProgramUniform2dvEXT_2(&program, location, count, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2dvEXT(&program: gl_program; location: Int32; count: Int32; var value: real) :=
    z_ProgramUniform2dvEXT_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2dvEXT(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform2dvEXT_1(&program, location, count, value);
    
    private z_ProgramUniform3dvEXT_adr := GetProcAddress('glProgramUniform3dvEXT');
    private z_ProgramUniform3dvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform3dvEXT_adr);
    private z_ProgramUniform3dvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: real)>(z_ProgramUniform3dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3dvEXT(&program: gl_program; location: Int32; count: Int32; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform3dvEXT_2(&program, location, count, value[0]) else
        z_ProgramUniform3dvEXT_2(&program, location, count, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3dvEXT(&program: gl_program; location: Int32; count: Int32; var value: real) :=
    z_ProgramUniform3dvEXT_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3dvEXT(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform3dvEXT_1(&program, location, count, value);
    
    private z_ProgramUniform4dvEXT_adr := GetProcAddress('glProgramUniform4dvEXT');
    private z_ProgramUniform4dvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform4dvEXT_adr);
    private z_ProgramUniform4dvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: real)>(z_ProgramUniform4dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4dvEXT(&program: gl_program; location: Int32; count: Int32; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform4dvEXT_2(&program, location, count, value[0]) else
        z_ProgramUniform4dvEXT_2(&program, location, count, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4dvEXT(&program: gl_program; location: Int32; count: Int32; var value: real) :=
    z_ProgramUniform4dvEXT_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4dvEXT(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform4dvEXT_1(&program, location, count, value);
    
    private z_ProgramUniformMatrix2dvEXT_adr := GetProcAddress('glProgramUniformMatrix2dvEXT');
    private z_ProgramUniformMatrix2dvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix2dvEXT_adr);
    private z_ProgramUniformMatrix2dvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real)>(z_ProgramUniformMatrix2dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix2dvEXT_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix2dvEXT_2(&program, location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_ProgramUniformMatrix2dvEXT_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix2dvEXT_1(&program, location, count, transpose, value);
    
    private z_ProgramUniformMatrix3dvEXT_adr := GetProcAddress('glProgramUniformMatrix3dvEXT');
    private z_ProgramUniformMatrix3dvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix3dvEXT_adr);
    private z_ProgramUniformMatrix3dvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real)>(z_ProgramUniformMatrix3dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix3dvEXT_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix3dvEXT_2(&program, location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_ProgramUniformMatrix3dvEXT_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix3dvEXT_1(&program, location, count, transpose, value);
    
    private z_ProgramUniformMatrix4dvEXT_adr := GetProcAddress('glProgramUniformMatrix4dvEXT');
    private z_ProgramUniformMatrix4dvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix4dvEXT_adr);
    private z_ProgramUniformMatrix4dvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real)>(z_ProgramUniformMatrix4dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix4dvEXT_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix4dvEXT_2(&program, location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_ProgramUniformMatrix4dvEXT_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix4dvEXT_1(&program, location, count, transpose, value);
    
    private z_ProgramUniformMatrix2x3dvEXT_adr := GetProcAddress('glProgramUniformMatrix2x3dvEXT');
    private z_ProgramUniformMatrix2x3dvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix2x3dvEXT_adr);
    private z_ProgramUniformMatrix2x3dvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real)>(z_ProgramUniformMatrix2x3dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix2x3dvEXT_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix2x3dvEXT_2(&program, location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_ProgramUniformMatrix2x3dvEXT_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix2x3dvEXT_1(&program, location, count, transpose, value);
    
    private z_ProgramUniformMatrix2x4dvEXT_adr := GetProcAddress('glProgramUniformMatrix2x4dvEXT');
    private z_ProgramUniformMatrix2x4dvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix2x4dvEXT_adr);
    private z_ProgramUniformMatrix2x4dvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real)>(z_ProgramUniformMatrix2x4dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix2x4dvEXT_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix2x4dvEXT_2(&program, location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_ProgramUniformMatrix2x4dvEXT_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix2x4dvEXT_1(&program, location, count, transpose, value);
    
    private z_ProgramUniformMatrix3x2dvEXT_adr := GetProcAddress('glProgramUniformMatrix3x2dvEXT');
    private z_ProgramUniformMatrix3x2dvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix3x2dvEXT_adr);
    private z_ProgramUniformMatrix3x2dvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real)>(z_ProgramUniformMatrix3x2dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix3x2dvEXT_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix3x2dvEXT_2(&program, location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_ProgramUniformMatrix3x2dvEXT_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix3x2dvEXT_1(&program, location, count, transpose, value);
    
    private z_ProgramUniformMatrix3x4dvEXT_adr := GetProcAddress('glProgramUniformMatrix3x4dvEXT');
    private z_ProgramUniformMatrix3x4dvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix3x4dvEXT_adr);
    private z_ProgramUniformMatrix3x4dvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real)>(z_ProgramUniformMatrix3x4dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix3x4dvEXT_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix3x4dvEXT_2(&program, location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_ProgramUniformMatrix3x4dvEXT_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix3x4dvEXT_1(&program, location, count, transpose, value);
    
    private z_ProgramUniformMatrix4x2dvEXT_adr := GetProcAddress('glProgramUniformMatrix4x2dvEXT');
    private z_ProgramUniformMatrix4x2dvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix4x2dvEXT_adr);
    private z_ProgramUniformMatrix4x2dvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real)>(z_ProgramUniformMatrix4x2dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix4x2dvEXT_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix4x2dvEXT_2(&program, location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_ProgramUniformMatrix4x2dvEXT_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix4x2dvEXT_1(&program, location, count, transpose, value);
    
    private z_ProgramUniformMatrix4x3dvEXT_adr := GetProcAddress('glProgramUniformMatrix4x3dvEXT');
    private z_ProgramUniformMatrix4x3dvEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr)>(z_ProgramUniformMatrix4x3dvEXT_adr);
    private z_ProgramUniformMatrix4x3dvEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real)>(z_ProgramUniformMatrix4x3dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: array of real);
    type Preal=^real;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformMatrix4x3dvEXT_2(&program, location, count, transpose, value[0]) else
        z_ProgramUniformMatrix4x3dvEXT_2(&program, location, count, transpose, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; var value: real) :=
    z_ProgramUniformMatrix4x3dvEXT_2(&program, location, count, transpose, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3dvEXT(&program: gl_program; location: Int32; count: Int32; transpose: boolean; value: IntPtr) :=
    z_ProgramUniformMatrix4x3dvEXT_1(&program, location, count, transpose, value);
    
    private z_TextureBufferRangeEXT_adr := GetProcAddress('glTextureBufferRangeEXT');
    private z_TextureBufferRangeEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; internalformat: SizedInternalFormat; buffer: gl_buffer; offset: IntPtr; size: UIntPtr)>(z_TextureBufferRangeEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureBufferRangeEXT(texture: gl_texture; target: TextureTarget; internalformat: SizedInternalFormat; buffer: gl_buffer; offset: IntPtr; size: UIntPtr) :=
    z_TextureBufferRangeEXT_1(texture, target, internalformat, buffer, offset, size);
    
    private z_TextureStorage1DEXT_adr := GetProcAddress('glTextureStorage1DEXT');
    private z_TextureStorage1DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: DummyEnum; levels: Int32; internalformat: SizedInternalFormat; width: Int32)>(z_TextureStorage1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage1DEXT(texture: gl_texture; target: DummyEnum; levels: Int32; internalformat: SizedInternalFormat; width: Int32) :=
    z_TextureStorage1DEXT_1(texture, target, levels, internalformat, width);
    
    private z_TextureStorage2DEXT_adr := GetProcAddress('glTextureStorage2DEXT');
    private z_TextureStorage2DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: DummyEnum; levels: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32)>(z_TextureStorage2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage2DEXT(texture: gl_texture; target: DummyEnum; levels: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32) :=
    z_TextureStorage2DEXT_1(texture, target, levels, internalformat, width, height);
    
    private z_TextureStorage3DEXT_adr := GetProcAddress('glTextureStorage3DEXT');
    private z_TextureStorage3DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: DummyEnum; levels: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32; depth: Int32)>(z_TextureStorage3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage3DEXT(texture: gl_texture; target: DummyEnum; levels: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32; depth: Int32) :=
    z_TextureStorage3DEXT_1(texture, target, levels, internalformat, width, height, depth);
    
    private z_TextureStorage2DMultisampleEXT_adr := GetProcAddress('glTextureStorage2DMultisampleEXT');
    private z_TextureStorage2DMultisampleEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; samples: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32; fixedsamplelocations: boolean)>(z_TextureStorage2DMultisampleEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage2DMultisampleEXT(texture: gl_texture; target: TextureTarget; samples: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32; fixedsamplelocations: boolean) :=
    z_TextureStorage2DMultisampleEXT_1(texture, target, samples, internalformat, width, height, fixedsamplelocations);
    
    private z_TextureStorage3DMultisampleEXT_adr := GetProcAddress('glTextureStorage3DMultisampleEXT');
    private z_TextureStorage3DMultisampleEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: DummyEnum; samples: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: boolean)>(z_TextureStorage3DMultisampleEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage3DMultisampleEXT(texture: gl_texture; target: DummyEnum; samples: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: boolean) :=
    z_TextureStorage3DMultisampleEXT_1(texture, target, samples, internalformat, width, height, depth, fixedsamplelocations);
    
    private z_VertexArrayBindVertexBufferEXT_adr := GetProcAddress('glVertexArrayBindVertexBufferEXT');
    private z_VertexArrayBindVertexBufferEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; bindingindex: UInt32; buffer: gl_buffer; offset: IntPtr; stride: Int32)>(z_VertexArrayBindVertexBufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayBindVertexBufferEXT(vaobj: gl_vertex_array; bindingindex: UInt32; buffer: gl_buffer; offset: IntPtr; stride: Int32) :=
    z_VertexArrayBindVertexBufferEXT_1(vaobj, bindingindex, buffer, offset, stride);
    
    private z_VertexArrayVertexAttribFormatEXT_adr := GetProcAddress('glVertexArrayVertexAttribFormatEXT');
    private z_VertexArrayVertexAttribFormatEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; attribindex: UInt32; size: Int32; &type: VertexAttribType; normalized: boolean; relativeoffset: UInt32)>(z_VertexArrayVertexAttribFormatEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexAttribFormatEXT(vaobj: gl_vertex_array; attribindex: UInt32; size: Int32; &type: VertexAttribType; normalized: boolean; relativeoffset: UInt32) :=
    z_VertexArrayVertexAttribFormatEXT_1(vaobj, attribindex, size, &type, normalized, relativeoffset);
    
    private z_VertexArrayVertexAttribIFormatEXT_adr := GetProcAddress('glVertexArrayVertexAttribIFormatEXT');
    private z_VertexArrayVertexAttribIFormatEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; attribindex: UInt32; size: Int32; &type: VertexAttribIType; relativeoffset: UInt32)>(z_VertexArrayVertexAttribIFormatEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexAttribIFormatEXT(vaobj: gl_vertex_array; attribindex: UInt32; size: Int32; &type: VertexAttribIType; relativeoffset: UInt32) :=
    z_VertexArrayVertexAttribIFormatEXT_1(vaobj, attribindex, size, &type, relativeoffset);
    
    private z_VertexArrayVertexAttribLFormatEXT_adr := GetProcAddress('glVertexArrayVertexAttribLFormatEXT');
    private z_VertexArrayVertexAttribLFormatEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; attribindex: UInt32; size: Int32; &type: VertexAttribLType; relativeoffset: UInt32)>(z_VertexArrayVertexAttribLFormatEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexAttribLFormatEXT(vaobj: gl_vertex_array; attribindex: UInt32; size: Int32; &type: VertexAttribLType; relativeoffset: UInt32) :=
    z_VertexArrayVertexAttribLFormatEXT_1(vaobj, attribindex, size, &type, relativeoffset);
    
    private z_VertexArrayVertexAttribBindingEXT_adr := GetProcAddress('glVertexArrayVertexAttribBindingEXT');
    private z_VertexArrayVertexAttribBindingEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; attribindex: UInt32; bindingindex: UInt32)>(z_VertexArrayVertexAttribBindingEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexAttribBindingEXT(vaobj: gl_vertex_array; attribindex: UInt32; bindingindex: UInt32) :=
    z_VertexArrayVertexAttribBindingEXT_1(vaobj, attribindex, bindingindex);
    
    private z_VertexArrayVertexBindingDivisorEXT_adr := GetProcAddress('glVertexArrayVertexBindingDivisorEXT');
    private z_VertexArrayVertexBindingDivisorEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; bindingindex: UInt32; divisor: UInt32)>(z_VertexArrayVertexBindingDivisorEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBindingDivisorEXT(vaobj: gl_vertex_array; bindingindex: UInt32; divisor: UInt32) :=
    z_VertexArrayVertexBindingDivisorEXT_1(vaobj, bindingindex, divisor);
    
    private z_VertexArrayVertexAttribLOffsetEXT_adr := GetProcAddress('glVertexArrayVertexAttribLOffsetEXT');
    private z_VertexArrayVertexAttribLOffsetEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; buffer: gl_buffer; index: UInt32; size: Int32; &type: VertexAttribLType; stride: Int32; offset: IntPtr)>(z_VertexArrayVertexAttribLOffsetEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexAttribLOffsetEXT(vaobj: gl_vertex_array; buffer: gl_buffer; index: UInt32; size: Int32; &type: VertexAttribLType; stride: Int32; offset: IntPtr) :=
    z_VertexArrayVertexAttribLOffsetEXT_1(vaobj, buffer, index, size, &type, stride, offset);
    
    private z_TexturePageCommitmentEXT_adr := GetProcAddress('glTexturePageCommitmentEXT');
    private z_TexturePageCommitmentEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; commit: boolean)>(z_TexturePageCommitmentEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexturePageCommitmentEXT(texture: gl_texture; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; commit: boolean) :=
    z_TexturePageCommitmentEXT_1(texture, level, xoffset, yoffset, zoffset, width, height, depth, commit);
    
    private z_VertexArrayVertexAttribDivisorEXT_adr := GetProcAddress('glVertexArrayVertexAttribDivisorEXT');
    private z_VertexArrayVertexAttribDivisorEXT_1 := GetProcOrNil&<procedure(vaobj: gl_vertex_array; index: UInt32; divisor: UInt32)>(z_VertexArrayVertexAttribDivisorEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexAttribDivisorEXT(vaobj: gl_vertex_array; index: UInt32; divisor: UInt32) :=
    z_VertexArrayVertexAttribDivisorEXT_1(vaobj, index, divisor);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glDrawBuffers2EXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_draw_buffers2';
    
    private z_ColorMaskIndexedEXT_adr := GetProcAddress('glColorMaskIndexedEXT');
    private z_ColorMaskIndexedEXT_1 := GetProcOrNil&<procedure(index: UInt32; r: boolean; g: boolean; b: boolean; a: boolean)>(z_ColorMaskIndexedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorMaskIndexedEXT(index: UInt32; r: boolean; g: boolean; b: boolean; a: boolean) :=
    z_ColorMaskIndexedEXT_1(index, r, g, b, a);
    
    private z_GetBooleanIndexedvEXT_adr := GetProcAddress('glGetBooleanIndexedvEXT');
    private z_GetBooleanIndexedvEXT_1 := GetProcOrNil&<procedure(target: BufferTarget; index: UInt32; data: IntPtr)>(z_GetBooleanIndexedvEXT_adr);
    private z_GetBooleanIndexedvEXT_2 := GetProcOrNil&<procedure(target: BufferTarget; index: UInt32; var data: boolean)>(z_GetBooleanIndexedvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBooleanIndexedvEXT(target: BufferTarget; index: UInt32; var data: boolean) :=
    z_GetBooleanIndexedvEXT_2(target, index, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBooleanIndexedvEXT(target: BufferTarget; index: UInt32; data: IntPtr) :=
    z_GetBooleanIndexedvEXT_1(target, index, data);
    
    private z_GetIntegerIndexedvEXT_adr := GetProcAddress('glGetIntegerIndexedvEXT');
    private z_GetIntegerIndexedvEXT_1 := GetProcOrNil&<procedure(target: GetPName; index: UInt32; data: IntPtr)>(z_GetIntegerIndexedvEXT_adr);
    private z_GetIntegerIndexedvEXT_2 := GetProcOrNil&<procedure(target: GetPName; index: UInt32; var data: Int32)>(z_GetIntegerIndexedvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerIndexedvEXT(target: GetPName; index: UInt32; var data: Int32) :=
    z_GetIntegerIndexedvEXT_2(target, index, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerIndexedvEXT(target: GetPName; index: UInt32; data: IntPtr) :=
    z_GetIntegerIndexedvEXT_1(target, index, data);
    
    private z_EnableIndexedEXT_adr := GetProcAddress('glEnableIndexedEXT');
    private z_EnableIndexedEXT_1 := GetProcOrNil&<procedure(target: EnableCap; index: UInt32)>(z_EnableIndexedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableIndexedEXT(target: EnableCap; index: UInt32) :=
    z_EnableIndexedEXT_1(target, index);
    
    private z_DisableIndexedEXT_adr := GetProcAddress('glDisableIndexedEXT');
    private z_DisableIndexedEXT_1 := GetProcOrNil&<procedure(target: EnableCap; index: UInt32)>(z_DisableIndexedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableIndexedEXT(target: EnableCap; index: UInt32) :=
    z_DisableIndexedEXT_1(target, index);
    
    private z_IsEnabledIndexedEXT_adr := GetProcAddress('glIsEnabledIndexedEXT');
    private z_IsEnabledIndexedEXT_1 := GetProcOrNil&<function(target: EnableCap; index: UInt32): boolean>(z_IsEnabledIndexedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnabledIndexedEXT(target: EnableCap; index: UInt32): boolean :=
    z_IsEnabledIndexedEXT_1(target, index);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glDrawInstancedEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_draw_instanced';
    
    private z_DrawArraysInstancedEXT_adr := GetProcAddress('glDrawArraysInstancedEXT');
    private z_DrawArraysInstancedEXT_1 := GetProcOrNil&<procedure(mode: PrimitiveType; start: Int32; count: Int32; primcount: Int32)>(z_DrawArraysInstancedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawArraysInstancedEXT(mode: PrimitiveType; start: Int32; count: Int32; primcount: Int32) :=
    z_DrawArraysInstancedEXT_1(mode, start, count, primcount);
    
    private z_DrawElementsInstancedEXT_adr := GetProcAddress('glDrawElementsInstancedEXT');
    private z_DrawElementsInstancedEXT_1 := GetProcOrNil&<procedure(mode: PrimitiveType; count: Int32; &type: DrawElementsType; indices: IntPtr; primcount: Int32)>(z_DrawElementsInstancedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedEXT(mode: PrimitiveType; count: Int32; &type: DrawElementsType; indices: IntPtr; primcount: Int32) :=
    z_DrawElementsInstancedEXT_1(mode, count, &type, indices, primcount);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glDrawRangeElementsEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_draw_range_elements';
    
    private z_DrawRangeElementsEXT_adr := GetProcAddress('glDrawRangeElementsEXT');
    private z_DrawRangeElementsEXT_1 := GetProcOrNil&<procedure(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DrawElementsType; indices: IntPtr)>(z_DrawRangeElementsEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawRangeElementsEXT(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DrawElementsType; indices: IntPtr) :=
    z_DrawRangeElementsEXT_1(mode, start, &end, count, &type, indices);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glExternalBufferEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_external_buffer';
    
    private z_BufferStorageExternalEXT_adr := GetProcAddress('glBufferStorageExternalEXT');
    private z_BufferStorageExternalEXT_1 := GetProcOrNil&<procedure(target: DummyEnum; offset: IntPtr; size: UIntPtr; clientBuffer: egl_chient_buffer_EXT; flags: BufferStorageMask)>(z_BufferStorageExternalEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferStorageExternalEXT(target: DummyEnum; offset: IntPtr; size: UIntPtr; clientBuffer: egl_chient_buffer_EXT; flags: BufferStorageMask) :=
    z_BufferStorageExternalEXT_1(target, offset, size, clientBuffer, flags);
    
    private z_NamedBufferStorageExternalEXT_adr := GetProcAddress('glNamedBufferStorageExternalEXT');
    private z_NamedBufferStorageExternalEXT_1 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; clientBuffer: egl_chient_buffer_EXT; flags: BufferStorageMask)>(z_NamedBufferStorageExternalEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferStorageExternalEXT(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; clientBuffer: egl_chient_buffer_EXT; flags: BufferStorageMask) :=
    z_NamedBufferStorageExternalEXT_1(buffer, offset, size, clientBuffer, flags);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glFogCoordEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_fog_coord';
    
    private z_FogCoordfEXT_adr := GetProcAddress('glFogCoordfEXT');
    private z_FogCoordfEXT_1 := GetProcOrNil&<procedure(coord: single)>(z_FogCoordfEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordfEXT(coord: single) :=
    z_FogCoordfEXT_1(coord);
    
    private z_FogCoordfvEXT_adr := GetProcAddress('glFogCoordfvEXT');
    private z_FogCoordfvEXT_1 := GetProcOrNil&<procedure(coord: IntPtr)>(z_FogCoordfvEXT_adr);
    private z_FogCoordfvEXT_2 := GetProcOrNil&<procedure(var coord: single)>(z_FogCoordfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordfvEXT(coord: array of single);
    type Psingle=^single;
    begin
      if (coord<>nil) and (coord.Length<>0) then
        z_FogCoordfvEXT_2(coord[0]) else
        z_FogCoordfvEXT_2(Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordfvEXT(var coord: single) :=
    z_FogCoordfvEXT_2(coord);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordfvEXT(coord: IntPtr) :=
    z_FogCoordfvEXT_1(coord);
    
    private z_FogCoorddEXT_adr := GetProcAddress('glFogCoorddEXT');
    private z_FogCoorddEXT_1 := GetProcOrNil&<procedure(coord: real)>(z_FogCoorddEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoorddEXT(coord: real) :=
    z_FogCoorddEXT_1(coord);
    
    private z_FogCoorddvEXT_adr := GetProcAddress('glFogCoorddvEXT');
    private z_FogCoorddvEXT_1 := GetProcOrNil&<procedure(coord: IntPtr)>(z_FogCoorddvEXT_adr);
    private z_FogCoorddvEXT_2 := GetProcOrNil&<procedure(var coord: real)>(z_FogCoorddvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoorddvEXT(coord: array of real);
    type Preal=^real;
    begin
      if (coord<>nil) and (coord.Length<>0) then
        z_FogCoorddvEXT_2(coord[0]) else
        z_FogCoorddvEXT_2(Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoorddvEXT(var coord: real) :=
    z_FogCoorddvEXT_2(coord);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoorddvEXT(coord: IntPtr) :=
    z_FogCoorddvEXT_1(coord);
    
    private z_FogCoordPointerEXT_adr := GetProcAddress('glFogCoordPointerEXT');
    private z_FogCoordPointerEXT_1 := GetProcOrNil&<procedure(&type: FogPointerType; stride: Int32; pointer: IntPtr)>(z_FogCoordPointerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordPointerEXT(&type: FogPointerType; stride: Int32; pointer: IntPtr) :=
    z_FogCoordPointerEXT_1(&type, stride, pointer);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glFramebufferBlitEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_framebuffer_blit';
    
    private z_BlitFramebufferEXT_adr := GetProcAddress('glBlitFramebufferEXT');
    private z_BlitFramebufferEXT_1 := GetProcOrNil&<procedure(srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: ClearBufferMask; filter: BlitFramebufferFilter)>(z_BlitFramebufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlitFramebufferEXT(srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: ClearBufferMask; filter: BlitFramebufferFilter) :=
    z_BlitFramebufferEXT_1(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glFramebufferMultisampleEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_framebuffer_multisample';
    
    private z_RenderbufferStorageMultisampleEXT_adr := GetProcAddress('glRenderbufferStorageMultisampleEXT');
    private z_RenderbufferStorageMultisampleEXT_1 := GetProcOrNil&<procedure(target: RenderbufferTarget; samples: Int32; _internalformat: InternalFormat; width: Int32; height: Int32)>(z_RenderbufferStorageMultisampleEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RenderbufferStorageMultisampleEXT(target: RenderbufferTarget; samples: Int32; _internalformat: InternalFormat; width: Int32; height: Int32) :=
    z_RenderbufferStorageMultisampleEXT_1(target, samples, _internalformat, width, height);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glFramebufferObjectEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_framebuffer_object';
    
    private z_IsRenderbufferEXT_adr := GetProcAddress('glIsRenderbufferEXT');
    private z_IsRenderbufferEXT_1 := GetProcOrNil&<function(renderbuffer: gl_renderbuffer): boolean>(z_IsRenderbufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsRenderbufferEXT(renderbuffer: gl_renderbuffer): boolean :=
    z_IsRenderbufferEXT_1(renderbuffer);
    
    private z_BindRenderbufferEXT_adr := GetProcAddress('glBindRenderbufferEXT');
    private z_BindRenderbufferEXT_1 := GetProcOrNil&<procedure(target: RenderbufferTarget; renderbuffer: gl_renderbuffer)>(z_BindRenderbufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindRenderbufferEXT(target: RenderbufferTarget; renderbuffer: gl_renderbuffer) :=
    z_BindRenderbufferEXT_1(target, renderbuffer);
    
    private z_DeleteRenderbuffersEXT_adr := GetProcAddress('glDeleteRenderbuffersEXT');
    private z_DeleteRenderbuffersEXT_1 := GetProcOrNil&<procedure(n: Int32; renderbuffers: IntPtr)>(z_DeleteRenderbuffersEXT_adr);
    private z_DeleteRenderbuffersEXT_2 := GetProcOrNil&<procedure(n: Int32; var renderbuffers: gl_renderbuffer)>(z_DeleteRenderbuffersEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteRenderbuffersEXT(n: Int32; renderbuffers: array of gl_renderbuffer);
    type Pgl_renderbuffer=^gl_renderbuffer;
    begin
      if (renderbuffers<>nil) and (renderbuffers.Length<>0) then
        z_DeleteRenderbuffersEXT_2(n, renderbuffers[0]) else
        z_DeleteRenderbuffersEXT_2(n, Pgl_renderbuffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteRenderbuffersEXT(n: Int32; var renderbuffers: gl_renderbuffer) :=
    z_DeleteRenderbuffersEXT_2(n, renderbuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteRenderbuffersEXT(n: Int32; renderbuffers: IntPtr) :=
    z_DeleteRenderbuffersEXT_1(n, renderbuffers);
    
    private z_GenRenderbuffersEXT_adr := GetProcAddress('glGenRenderbuffersEXT');
    private z_GenRenderbuffersEXT_1 := GetProcOrNil&<procedure(n: Int32; renderbuffers: IntPtr)>(z_GenRenderbuffersEXT_adr);
    private z_GenRenderbuffersEXT_2 := GetProcOrNil&<procedure(n: Int32; var renderbuffers: gl_renderbuffer)>(z_GenRenderbuffersEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenRenderbuffersEXT(n: Int32; renderbuffers: array of gl_renderbuffer);
    type Pgl_renderbuffer=^gl_renderbuffer;
    begin
      if (renderbuffers<>nil) and (renderbuffers.Length<>0) then
        z_GenRenderbuffersEXT_2(n, renderbuffers[0]) else
        z_GenRenderbuffersEXT_2(n, Pgl_renderbuffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenRenderbuffersEXT(n: Int32; var renderbuffers: gl_renderbuffer) :=
    z_GenRenderbuffersEXT_2(n, renderbuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenRenderbuffersEXT(n: Int32; renderbuffers: IntPtr) :=
    z_GenRenderbuffersEXT_1(n, renderbuffers);
    
    private z_RenderbufferStorageEXT_adr := GetProcAddress('glRenderbufferStorageEXT');
    private z_RenderbufferStorageEXT_1 := GetProcOrNil&<procedure(target: RenderbufferTarget; _internalformat: InternalFormat; width: Int32; height: Int32)>(z_RenderbufferStorageEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RenderbufferStorageEXT(target: RenderbufferTarget; _internalformat: InternalFormat; width: Int32; height: Int32) :=
    z_RenderbufferStorageEXT_1(target, _internalformat, width, height);
    
    private z_GetRenderbufferParameterivEXT_adr := GetProcAddress('glGetRenderbufferParameterivEXT');
    private z_GetRenderbufferParameterivEXT_1 := GetProcOrNil&<procedure(target: RenderbufferTarget; pname: RenderbufferParameterName; &params: IntPtr)>(z_GetRenderbufferParameterivEXT_adr);
    private z_GetRenderbufferParameterivEXT_2 := GetProcOrNil&<procedure(target: RenderbufferTarget; pname: RenderbufferParameterName; var &params: Int32)>(z_GetRenderbufferParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetRenderbufferParameterivEXT(target: RenderbufferTarget; pname: RenderbufferParameterName; var &params: Int32) :=
    z_GetRenderbufferParameterivEXT_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetRenderbufferParameterivEXT(target: RenderbufferTarget; pname: RenderbufferParameterName; &params: IntPtr) :=
    z_GetRenderbufferParameterivEXT_1(target, pname, &params);
    
    private z_IsFramebufferEXT_adr := GetProcAddress('glIsFramebufferEXT');
    private z_IsFramebufferEXT_1 := GetProcOrNil&<function(framebuffer: gl_framebuffer): boolean>(z_IsFramebufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsFramebufferEXT(framebuffer: gl_framebuffer): boolean :=
    z_IsFramebufferEXT_1(framebuffer);
    
    private z_BindFramebufferEXT_adr := GetProcAddress('glBindFramebufferEXT');
    private z_BindFramebufferEXT_1 := GetProcOrNil&<procedure(target: FramebufferTarget; framebuffer: gl_framebuffer)>(z_BindFramebufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindFramebufferEXT(target: FramebufferTarget; framebuffer: gl_framebuffer) :=
    z_BindFramebufferEXT_1(target, framebuffer);
    
    private z_DeleteFramebuffersEXT_adr := GetProcAddress('glDeleteFramebuffersEXT');
    private z_DeleteFramebuffersEXT_1 := GetProcOrNil&<procedure(n: Int32; framebuffers: IntPtr)>(z_DeleteFramebuffersEXT_adr);
    private z_DeleteFramebuffersEXT_2 := GetProcOrNil&<procedure(n: Int32; var framebuffers: gl_framebuffer)>(z_DeleteFramebuffersEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFramebuffersEXT(n: Int32; framebuffers: array of gl_framebuffer);
    type Pgl_framebuffer=^gl_framebuffer;
    begin
      if (framebuffers<>nil) and (framebuffers.Length<>0) then
        z_DeleteFramebuffersEXT_2(n, framebuffers[0]) else
        z_DeleteFramebuffersEXT_2(n, Pgl_framebuffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFramebuffersEXT(n: Int32; var framebuffers: gl_framebuffer) :=
    z_DeleteFramebuffersEXT_2(n, framebuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFramebuffersEXT(n: Int32; framebuffers: IntPtr) :=
    z_DeleteFramebuffersEXT_1(n, framebuffers);
    
    private z_GenFramebuffersEXT_adr := GetProcAddress('glGenFramebuffersEXT');
    private z_GenFramebuffersEXT_1 := GetProcOrNil&<procedure(n: Int32; framebuffers: IntPtr)>(z_GenFramebuffersEXT_adr);
    private z_GenFramebuffersEXT_2 := GetProcOrNil&<procedure(n: Int32; var framebuffers: gl_framebuffer)>(z_GenFramebuffersEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFramebuffersEXT(n: Int32; framebuffers: array of gl_framebuffer);
    type Pgl_framebuffer=^gl_framebuffer;
    begin
      if (framebuffers<>nil) and (framebuffers.Length<>0) then
        z_GenFramebuffersEXT_2(n, framebuffers[0]) else
        z_GenFramebuffersEXT_2(n, Pgl_framebuffer(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFramebuffersEXT(n: Int32; var framebuffers: gl_framebuffer) :=
    z_GenFramebuffersEXT_2(n, framebuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFramebuffersEXT(n: Int32; framebuffers: IntPtr) :=
    z_GenFramebuffersEXT_1(n, framebuffers);
    
    private z_CheckFramebufferStatusEXT_adr := GetProcAddress('glCheckFramebufferStatusEXT');
    private z_CheckFramebufferStatusEXT_1 := GetProcOrNil&<function(target: FramebufferTarget): FramebufferStatus>(z_CheckFramebufferStatusEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CheckFramebufferStatusEXT(target: FramebufferTarget): FramebufferStatus :=
    z_CheckFramebufferStatusEXT_1(target);
    
    private z_FramebufferTexture1DEXT_adr := GetProcAddress('glFramebufferTexture1DEXT');
    private z_FramebufferTexture1DEXT_1 := GetProcOrNil&<procedure(target: FramebufferTarget; attachment: FramebufferAttachment; textarget: TextureTarget; texture: gl_texture; level: Int32)>(z_FramebufferTexture1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTexture1DEXT(target: FramebufferTarget; attachment: FramebufferAttachment; textarget: TextureTarget; texture: gl_texture; level: Int32) :=
    z_FramebufferTexture1DEXT_1(target, attachment, textarget, texture, level);
    
    private z_FramebufferTexture2DEXT_adr := GetProcAddress('glFramebufferTexture2DEXT');
    private z_FramebufferTexture2DEXT_1 := GetProcOrNil&<procedure(target: FramebufferTarget; attachment: FramebufferAttachment; textarget: TextureTarget; texture: gl_texture; level: Int32)>(z_FramebufferTexture2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTexture2DEXT(target: FramebufferTarget; attachment: FramebufferAttachment; textarget: TextureTarget; texture: gl_texture; level: Int32) :=
    z_FramebufferTexture2DEXT_1(target, attachment, textarget, texture, level);
    
    private z_FramebufferTexture3DEXT_adr := GetProcAddress('glFramebufferTexture3DEXT');
    private z_FramebufferTexture3DEXT_1 := GetProcOrNil&<procedure(target: FramebufferTarget; attachment: FramebufferAttachment; textarget: TextureTarget; texture: gl_texture; level: Int32; zoffset: Int32)>(z_FramebufferTexture3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTexture3DEXT(target: FramebufferTarget; attachment: FramebufferAttachment; textarget: TextureTarget; texture: gl_texture; level: Int32; zoffset: Int32) :=
    z_FramebufferTexture3DEXT_1(target, attachment, textarget, texture, level, zoffset);
    
    private z_FramebufferRenderbufferEXT_adr := GetProcAddress('glFramebufferRenderbufferEXT');
    private z_FramebufferRenderbufferEXT_1 := GetProcOrNil&<procedure(target: FramebufferTarget; attachment: FramebufferAttachment; _renderbuffertarget: RenderbufferTarget; renderbuffer: gl_renderbuffer)>(z_FramebufferRenderbufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferRenderbufferEXT(target: FramebufferTarget; attachment: FramebufferAttachment; _renderbuffertarget: RenderbufferTarget; renderbuffer: gl_renderbuffer) :=
    z_FramebufferRenderbufferEXT_1(target, attachment, _renderbuffertarget, renderbuffer);
    
    private z_GetFramebufferAttachmentParameterivEXT_adr := GetProcAddress('glGetFramebufferAttachmentParameterivEXT');
    private z_GetFramebufferAttachmentParameterivEXT_1 := GetProcOrNil&<procedure(target: FramebufferTarget; attachment: FramebufferAttachment; pname: FramebufferAttachmentParameterName; &params: IntPtr)>(z_GetFramebufferAttachmentParameterivEXT_adr);
    private z_GetFramebufferAttachmentParameterivEXT_2 := GetProcOrNil&<procedure(target: FramebufferTarget; attachment: FramebufferAttachment; pname: FramebufferAttachmentParameterName; var &params: Int32)>(z_GetFramebufferAttachmentParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferAttachmentParameterivEXT(target: FramebufferTarget; attachment: FramebufferAttachment; pname: FramebufferAttachmentParameterName; var &params: Int32) :=
    z_GetFramebufferAttachmentParameterivEXT_2(target, attachment, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferAttachmentParameterivEXT(target: FramebufferTarget; attachment: FramebufferAttachment; pname: FramebufferAttachmentParameterName; &params: IntPtr) :=
    z_GetFramebufferAttachmentParameterivEXT_1(target, attachment, pname, &params);
    
    private z_GenerateMipmapEXT_adr := GetProcAddress('glGenerateMipmapEXT');
    private z_GenerateMipmapEXT_1 := GetProcOrNil&<procedure(target: TextureTarget)>(z_GenerateMipmapEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenerateMipmapEXT(target: TextureTarget) :=
    z_GenerateMipmapEXT_1(target);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glGeometryShader4EXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_geometry_shader4';
    
    private z_ProgramParameteriEXT_adr := GetProcAddress('glProgramParameteriEXT');
    private z_ProgramParameteriEXT_1 := GetProcOrNil&<procedure(&program: gl_program; pname: ProgramParameterPName; value: Int32)>(z_ProgramParameteriEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameteriEXT(&program: gl_program; pname: ProgramParameterPName; value: Int32) :=
    z_ProgramParameteriEXT_1(&program, pname, value);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glGpuProgramParametersEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_gpu_program_parameters';
    
    private z_ProgramEnvParameters4fvEXT_adr := GetProcAddress('glProgramEnvParameters4fvEXT');
    private z_ProgramEnvParameters4fvEXT_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; count: Int32; &params: IntPtr)>(z_ProgramEnvParameters4fvEXT_adr);
    private z_ProgramEnvParameters4fvEXT_2 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; count: Int32; var &params: single)>(z_ProgramEnvParameters4fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameters4fvEXT(target: ProgramTarget; index: UInt32; count: Int32; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_ProgramEnvParameters4fvEXT_2(target, index, count, &params[0]) else
        z_ProgramEnvParameters4fvEXT_2(target, index, count, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameters4fvEXT(target: ProgramTarget; index: UInt32; count: Int32; var &params: single) :=
    z_ProgramEnvParameters4fvEXT_2(target, index, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameters4fvEXT(target: ProgramTarget; index: UInt32; count: Int32; &params: IntPtr) :=
    z_ProgramEnvParameters4fvEXT_1(target, index, count, &params);
    
    private z_ProgramLocalParameters4fvEXT_adr := GetProcAddress('glProgramLocalParameters4fvEXT');
    private z_ProgramLocalParameters4fvEXT_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; count: Int32; &params: IntPtr)>(z_ProgramLocalParameters4fvEXT_adr);
    private z_ProgramLocalParameters4fvEXT_2 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; count: Int32; var &params: single)>(z_ProgramLocalParameters4fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameters4fvEXT(target: ProgramTarget; index: UInt32; count: Int32; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_ProgramLocalParameters4fvEXT_2(target, index, count, &params[0]) else
        z_ProgramLocalParameters4fvEXT_2(target, index, count, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameters4fvEXT(target: ProgramTarget; index: UInt32; count: Int32; var &params: single) :=
    z_ProgramLocalParameters4fvEXT_2(target, index, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameters4fvEXT(target: ProgramTarget; index: UInt32; count: Int32; &params: IntPtr) :=
    z_ProgramLocalParameters4fvEXT_1(target, index, count, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glGpuShader4EXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_gpu_shader4';
    
    private z_GetUniformuivEXT_adr := GetProcAddress('glGetUniformuivEXT');
    private z_GetUniformuivEXT_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; &params: IntPtr)>(z_GetUniformuivEXT_adr);
    private z_GetUniformuivEXT_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; var &params: UInt32)>(z_GetUniformuivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformuivEXT(&program: gl_program; location: Int32; var &params: UInt32) :=
    z_GetUniformuivEXT_2(&program, location, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformuivEXT(&program: gl_program; location: Int32; &params: IntPtr) :=
    z_GetUniformuivEXT_1(&program, location, &params);
    
    private z_BindFragDataLocationEXT_adr := GetProcAddress('glBindFragDataLocationEXT');
    private z_BindFragDataLocationEXT_1 := GetProcOrNil&<procedure(&program: gl_program; color: UInt32; name: IntPtr)>(z_BindFragDataLocationEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindFragDataLocationEXT(&program: gl_program; color: UInt32; name: string);
    begin
      var name_str_ptr: IntPtr;
      try
        name_str_ptr := Marshal.StringToHGlobalAnsi(name);
        z_BindFragDataLocationEXT_1(&program, color, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindFragDataLocationEXT(&program: gl_program; color: UInt32; name: IntPtr) :=
    z_BindFragDataLocationEXT_1(&program, color, name);
    
    private z_GetFragDataLocationEXT_adr := GetProcAddress('glGetFragDataLocationEXT');
    private z_GetFragDataLocationEXT_1 := GetProcOrNil&<function(&program: gl_program; name: IntPtr): Int32>(z_GetFragDataLocationEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFragDataLocationEXT(&program: gl_program; name: string): Int32;
    begin
      var name_str_ptr: IntPtr;
      try
        name_str_ptr := Marshal.StringToHGlobalAnsi(name);
        Result := z_GetFragDataLocationEXT_1(&program, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFragDataLocationEXT(&program: gl_program; name: IntPtr): Int32 :=
    z_GetFragDataLocationEXT_1(&program, name);
    
    private z_Uniform1uiEXT_adr := GetProcAddress('glUniform1uiEXT');
    private z_Uniform1uiEXT_1 := GetProcOrNil&<procedure(location: Int32; v0: UInt32)>(z_Uniform1uiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1uiEXT(location: Int32; v0: UInt32) :=
    z_Uniform1uiEXT_1(location, v0);
    
    private z_Uniform2uiEXT_adr := GetProcAddress('glUniform2uiEXT');
    private z_Uniform2uiEXT_1 := GetProcOrNil&<procedure(location: Int32; v0: UInt32; v1: UInt32)>(z_Uniform2uiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2uiEXT(location: Int32; v0: UInt32; v1: UInt32) :=
    z_Uniform2uiEXT_1(location, v0, v1);
    
    private z_Uniform3uiEXT_adr := GetProcAddress('glUniform3uiEXT');
    private z_Uniform3uiEXT_1 := GetProcOrNil&<procedure(location: Int32; v0: UInt32; v1: UInt32; v2: UInt32)>(z_Uniform3uiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3uiEXT(location: Int32; v0: UInt32; v1: UInt32; v2: UInt32) :=
    z_Uniform3uiEXT_1(location, v0, v1, v2);
    
    private z_Uniform4uiEXT_adr := GetProcAddress('glUniform4uiEXT');
    private z_Uniform4uiEXT_1 := GetProcOrNil&<procedure(location: Int32; v0: UInt32; v1: UInt32; v2: UInt32; v3: UInt32)>(z_Uniform4uiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4uiEXT(location: Int32; v0: UInt32; v1: UInt32; v2: UInt32; v3: UInt32) :=
    z_Uniform4uiEXT_1(location, v0, v1, v2, v3);
    
    private z_Uniform1uivEXT_adr := GetProcAddress('glUniform1uivEXT');
    private z_Uniform1uivEXT_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform1uivEXT_adr);
    private z_Uniform1uivEXT_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt32)>(z_Uniform1uivEXT_adr);
    private z_Uniform1uivEXT_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec1ui)>(z_Uniform1uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1uivEXT(location: Int32; count: Int32; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform1uivEXT_2(location, count, value[0]) else
        z_Uniform1uivEXT_2(location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1uivEXT(location: Int32; count: Int32; var value: Vec1ui) :=
    z_Uniform1uivEXT_3(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1uivEXT(location: Int32; count: Int32; var value: UInt32) :=
    z_Uniform1uivEXT_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1uivEXT(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform1uivEXT_1(location, count, value);
    
    private z_Uniform2uivEXT_adr := GetProcAddress('glUniform2uivEXT');
    private z_Uniform2uivEXT_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform2uivEXT_adr);
    private z_Uniform2uivEXT_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt32)>(z_Uniform2uivEXT_adr);
    private z_Uniform2uivEXT_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec2ui)>(z_Uniform2uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2uivEXT(location: Int32; count: Int32; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform2uivEXT_2(location, count, value[0]) else
        z_Uniform2uivEXT_2(location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2uivEXT(location: Int32; count: Int32; var value: Vec2ui) :=
    z_Uniform2uivEXT_3(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2uivEXT(location: Int32; count: Int32; var value: UInt32) :=
    z_Uniform2uivEXT_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2uivEXT(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform2uivEXT_1(location, count, value);
    
    private z_Uniform3uivEXT_adr := GetProcAddress('glUniform3uivEXT');
    private z_Uniform3uivEXT_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform3uivEXT_adr);
    private z_Uniform3uivEXT_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt32)>(z_Uniform3uivEXT_adr);
    private z_Uniform3uivEXT_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec3ui)>(z_Uniform3uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3uivEXT(location: Int32; count: Int32; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform3uivEXT_2(location, count, value[0]) else
        z_Uniform3uivEXT_2(location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3uivEXT(location: Int32; count: Int32; var value: Vec3ui) :=
    z_Uniform3uivEXT_3(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3uivEXT(location: Int32; count: Int32; var value: UInt32) :=
    z_Uniform3uivEXT_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3uivEXT(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform3uivEXT_1(location, count, value);
    
    private z_Uniform4uivEXT_adr := GetProcAddress('glUniform4uivEXT');
    private z_Uniform4uivEXT_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform4uivEXT_adr);
    private z_Uniform4uivEXT_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt32)>(z_Uniform4uivEXT_adr);
    private z_Uniform4uivEXT_3 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Vec4ui)>(z_Uniform4uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4uivEXT(location: Int32; count: Int32; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform4uivEXT_2(location, count, value[0]) else
        z_Uniform4uivEXT_2(location, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4uivEXT(location: Int32; count: Int32; var value: Vec4ui) :=
    z_Uniform4uivEXT_3(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4uivEXT(location: Int32; count: Int32; var value: UInt32) :=
    z_Uniform4uivEXT_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4uivEXT(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform4uivEXT_1(location, count, value);
    
    private z_VertexAttribI1iEXT_adr := GetProcAddress('glVertexAttribI1iEXT');
    private z_VertexAttribI1iEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: Int32)>(z_VertexAttribI1iEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1iEXT(index: UInt32; x: Int32) :=
    z_VertexAttribI1iEXT_1(index, x);
    
    private z_VertexAttribI2iEXT_adr := GetProcAddress('glVertexAttribI2iEXT');
    private z_VertexAttribI2iEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: Int32; y: Int32)>(z_VertexAttribI2iEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2iEXT(index: UInt32; x: Int32; y: Int32) :=
    z_VertexAttribI2iEXT_1(index, x, y);
    
    private z_VertexAttribI3iEXT_adr := GetProcAddress('glVertexAttribI3iEXT');
    private z_VertexAttribI3iEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: Int32; y: Int32; z: Int32)>(z_VertexAttribI3iEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3iEXT(index: UInt32; x: Int32; y: Int32; z: Int32) :=
    z_VertexAttribI3iEXT_1(index, x, y, z);
    
    private z_VertexAttribI4iEXT_adr := GetProcAddress('glVertexAttribI4iEXT');
    private z_VertexAttribI4iEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32)>(z_VertexAttribI4iEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4iEXT(index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32) :=
    z_VertexAttribI4iEXT_1(index, x, y, z, w);
    
    private z_VertexAttribI1uiEXT_adr := GetProcAddress('glVertexAttribI1uiEXT');
    private z_VertexAttribI1uiEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: UInt32)>(z_VertexAttribI1uiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1uiEXT(index: UInt32; x: UInt32) :=
    z_VertexAttribI1uiEXT_1(index, x);
    
    private z_VertexAttribI2uiEXT_adr := GetProcAddress('glVertexAttribI2uiEXT');
    private z_VertexAttribI2uiEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: UInt32; y: UInt32)>(z_VertexAttribI2uiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2uiEXT(index: UInt32; x: UInt32; y: UInt32) :=
    z_VertexAttribI2uiEXT_1(index, x, y);
    
    private z_VertexAttribI3uiEXT_adr := GetProcAddress('glVertexAttribI3uiEXT');
    private z_VertexAttribI3uiEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: UInt32; y: UInt32; z: UInt32)>(z_VertexAttribI3uiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3uiEXT(index: UInt32; x: UInt32; y: UInt32; z: UInt32) :=
    z_VertexAttribI3uiEXT_1(index, x, y, z);
    
    private z_VertexAttribI4uiEXT_adr := GetProcAddress('glVertexAttribI4uiEXT');
    private z_VertexAttribI4uiEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32)>(z_VertexAttribI4uiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4uiEXT(index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32) :=
    z_VertexAttribI4uiEXT_1(index, x, y, z, w);
    
    private z_VertexAttribI1ivEXT_adr := GetProcAddress('glVertexAttribI1ivEXT');
    private z_VertexAttribI1ivEXT_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribI1ivEXT_adr);
    private z_VertexAttribI1ivEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(z_VertexAttribI1ivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1ivEXT(index: UInt32; v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribI1ivEXT_2(index, v[0]) else
        z_VertexAttribI1ivEXT_2(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1ivEXT(index: UInt32; var v: Int32) :=
    z_VertexAttribI1ivEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1ivEXT(index: UInt32; v: IntPtr) :=
    z_VertexAttribI1ivEXT_1(index, v);
    
    private z_VertexAttribI2ivEXT_adr := GetProcAddress('glVertexAttribI2ivEXT');
    private z_VertexAttribI2ivEXT_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribI2ivEXT_adr);
    private z_VertexAttribI2ivEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(z_VertexAttribI2ivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2ivEXT(index: UInt32; v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribI2ivEXT_2(index, v[0]) else
        z_VertexAttribI2ivEXT_2(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2ivEXT(index: UInt32; var v: Int32) :=
    z_VertexAttribI2ivEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2ivEXT(index: UInt32; v: IntPtr) :=
    z_VertexAttribI2ivEXT_1(index, v);
    
    private z_VertexAttribI3ivEXT_adr := GetProcAddress('glVertexAttribI3ivEXT');
    private z_VertexAttribI3ivEXT_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribI3ivEXT_adr);
    private z_VertexAttribI3ivEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(z_VertexAttribI3ivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3ivEXT(index: UInt32; v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribI3ivEXT_2(index, v[0]) else
        z_VertexAttribI3ivEXT_2(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3ivEXT(index: UInt32; var v: Int32) :=
    z_VertexAttribI3ivEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3ivEXT(index: UInt32; v: IntPtr) :=
    z_VertexAttribI3ivEXT_1(index, v);
    
    private z_VertexAttribI4ivEXT_adr := GetProcAddress('glVertexAttribI4ivEXT');
    private z_VertexAttribI4ivEXT_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribI4ivEXT_adr);
    private z_VertexAttribI4ivEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(z_VertexAttribI4ivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ivEXT(index: UInt32; v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribI4ivEXT_2(index, v[0]) else
        z_VertexAttribI4ivEXT_2(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ivEXT(index: UInt32; var v: Int32) :=
    z_VertexAttribI4ivEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ivEXT(index: UInt32; v: IntPtr) :=
    z_VertexAttribI4ivEXT_1(index, v);
    
    private z_VertexAttribI1uivEXT_adr := GetProcAddress('glVertexAttribI1uivEXT');
    private z_VertexAttribI1uivEXT_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribI1uivEXT_adr);
    private z_VertexAttribI1uivEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: UInt32)>(z_VertexAttribI1uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1uivEXT(index: UInt32; v: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribI1uivEXT_2(index, v[0]) else
        z_VertexAttribI1uivEXT_2(index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1uivEXT(index: UInt32; var v: UInt32) :=
    z_VertexAttribI1uivEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1uivEXT(index: UInt32; v: IntPtr) :=
    z_VertexAttribI1uivEXT_1(index, v);
    
    private z_VertexAttribI2uivEXT_adr := GetProcAddress('glVertexAttribI2uivEXT');
    private z_VertexAttribI2uivEXT_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribI2uivEXT_adr);
    private z_VertexAttribI2uivEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: UInt32)>(z_VertexAttribI2uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2uivEXT(index: UInt32; v: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribI2uivEXT_2(index, v[0]) else
        z_VertexAttribI2uivEXT_2(index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2uivEXT(index: UInt32; var v: UInt32) :=
    z_VertexAttribI2uivEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2uivEXT(index: UInt32; v: IntPtr) :=
    z_VertexAttribI2uivEXT_1(index, v);
    
    private z_VertexAttribI3uivEXT_adr := GetProcAddress('glVertexAttribI3uivEXT');
    private z_VertexAttribI3uivEXT_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribI3uivEXT_adr);
    private z_VertexAttribI3uivEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: UInt32)>(z_VertexAttribI3uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3uivEXT(index: UInt32; v: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribI3uivEXT_2(index, v[0]) else
        z_VertexAttribI3uivEXT_2(index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3uivEXT(index: UInt32; var v: UInt32) :=
    z_VertexAttribI3uivEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3uivEXT(index: UInt32; v: IntPtr) :=
    z_VertexAttribI3uivEXT_1(index, v);
    
    private z_VertexAttribI4uivEXT_adr := GetProcAddress('glVertexAttribI4uivEXT');
    private z_VertexAttribI4uivEXT_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribI4uivEXT_adr);
    private z_VertexAttribI4uivEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: UInt32)>(z_VertexAttribI4uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4uivEXT(index: UInt32; v: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribI4uivEXT_2(index, v[0]) else
        z_VertexAttribI4uivEXT_2(index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4uivEXT(index: UInt32; var v: UInt32) :=
    z_VertexAttribI4uivEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4uivEXT(index: UInt32; v: IntPtr) :=
    z_VertexAttribI4uivEXT_1(index, v);
    
    private z_VertexAttribI4bvEXT_adr := GetProcAddress('glVertexAttribI4bvEXT');
    private z_VertexAttribI4bvEXT_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribI4bvEXT_adr);
    private z_VertexAttribI4bvEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: SByte)>(z_VertexAttribI4bvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4bvEXT(index: UInt32; v: array of SByte);
    type PSByte=^SByte;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribI4bvEXT_2(index, v[0]) else
        z_VertexAttribI4bvEXT_2(index, PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4bvEXT(index: UInt32; var v: SByte) :=
    z_VertexAttribI4bvEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4bvEXT(index: UInt32; v: IntPtr) :=
    z_VertexAttribI4bvEXT_1(index, v);
    
    private z_VertexAttribI4svEXT_adr := GetProcAddress('glVertexAttribI4svEXT');
    private z_VertexAttribI4svEXT_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribI4svEXT_adr);
    private z_VertexAttribI4svEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(z_VertexAttribI4svEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4svEXT(index: UInt32; v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribI4svEXT_2(index, v[0]) else
        z_VertexAttribI4svEXT_2(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4svEXT(index: UInt32; var v: Int16) :=
    z_VertexAttribI4svEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4svEXT(index: UInt32; v: IntPtr) :=
    z_VertexAttribI4svEXT_1(index, v);
    
    private z_VertexAttribI4ubvEXT_adr := GetProcAddress('glVertexAttribI4ubvEXT');
    private z_VertexAttribI4ubvEXT_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribI4ubvEXT_adr);
    private z_VertexAttribI4ubvEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: Byte)>(z_VertexAttribI4ubvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ubvEXT(index: UInt32; v: array of Byte);
    type PByte=^Byte;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribI4ubvEXT_2(index, v[0]) else
        z_VertexAttribI4ubvEXT_2(index, PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ubvEXT(index: UInt32; var v: Byte) :=
    z_VertexAttribI4ubvEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ubvEXT(index: UInt32; v: IntPtr) :=
    z_VertexAttribI4ubvEXT_1(index, v);
    
    private z_VertexAttribI4usvEXT_adr := GetProcAddress('glVertexAttribI4usvEXT');
    private z_VertexAttribI4usvEXT_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribI4usvEXT_adr);
    private z_VertexAttribI4usvEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: UInt16)>(z_VertexAttribI4usvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4usvEXT(index: UInt32; v: array of UInt16);
    type PUInt16=^UInt16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribI4usvEXT_2(index, v[0]) else
        z_VertexAttribI4usvEXT_2(index, PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4usvEXT(index: UInt32; var v: UInt16) :=
    z_VertexAttribI4usvEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4usvEXT(index: UInt32; v: IntPtr) :=
    z_VertexAttribI4usvEXT_1(index, v);
    
    private z_VertexAttribIPointerEXT_adr := GetProcAddress('glVertexAttribIPointerEXT');
    private z_VertexAttribIPointerEXT_1 := GetProcOrNil&<procedure(index: UInt32; size: Int32; &type: VertexAttribIType; stride: Int32; pointer: IntPtr)>(z_VertexAttribIPointerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribIPointerEXT(index: UInt32; size: Int32; &type: VertexAttribIType; stride: Int32; pointer: IntPtr) :=
    z_VertexAttribIPointerEXT_1(index, size, &type, stride, pointer);
    
    private z_GetVertexAttribIivEXT_adr := GetProcAddress('glGetVertexAttribIivEXT');
    private z_GetVertexAttribIivEXT_1 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribEnum; &params: IntPtr)>(z_GetVertexAttribIivEXT_adr);
    private z_GetVertexAttribIivEXT_2 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribEnum; var &params: Int32)>(z_GetVertexAttribIivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIivEXT(index: UInt32; pname: VertexAttribEnum; var &params: Int32) :=
    z_GetVertexAttribIivEXT_2(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIivEXT(index: UInt32; pname: VertexAttribEnum; &params: IntPtr) :=
    z_GetVertexAttribIivEXT_1(index, pname, &params);
    
    private z_GetVertexAttribIuivEXT_adr := GetProcAddress('glGetVertexAttribIuivEXT');
    private z_GetVertexAttribIuivEXT_1 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribEnum; &params: IntPtr)>(z_GetVertexAttribIuivEXT_adr);
    private z_GetVertexAttribIuivEXT_2 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribEnum; var &params: UInt32)>(z_GetVertexAttribIuivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIuivEXT(index: UInt32; pname: VertexAttribEnum; var &params: UInt32) :=
    z_GetVertexAttribIuivEXT_2(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIuivEXT(index: UInt32; pname: VertexAttribEnum; &params: IntPtr) :=
    z_GetVertexAttribIuivEXT_1(index, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glHistogramEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_histogram';
    
    private z_GetHistogramEXT_adr := GetProcAddress('glGetHistogramEXT');
    private z_GetHistogramEXT_1 := GetProcOrNil&<procedure(target: HistogramTargetEXT; reset: boolean; format: PixelFormat; &type: PixelType; values: IntPtr)>(z_GetHistogramEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramEXT(target: HistogramTargetEXT; reset: boolean; format: PixelFormat; &type: PixelType; values: IntPtr) :=
    z_GetHistogramEXT_1(target, reset, format, &type, values);
    
    private z_GetHistogramParameterfvEXT_adr := GetProcAddress('glGetHistogramParameterfvEXT');
    private z_GetHistogramParameterfvEXT_1 := GetProcOrNil&<procedure(target: HistogramTargetEXT; pname: GetHistogramParameterPName; &params: IntPtr)>(z_GetHistogramParameterfvEXT_adr);
    private z_GetHistogramParameterfvEXT_2 := GetProcOrNil&<procedure(target: HistogramTargetEXT; pname: GetHistogramParameterPName; var &params: single)>(z_GetHistogramParameterfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameterfvEXT(target: HistogramTargetEXT; pname: GetHistogramParameterPName; var &params: single) :=
    z_GetHistogramParameterfvEXT_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameterfvEXT(target: HistogramTargetEXT; pname: GetHistogramParameterPName; &params: IntPtr) :=
    z_GetHistogramParameterfvEXT_1(target, pname, &params);
    
    private z_GetHistogramParameterivEXT_adr := GetProcAddress('glGetHistogramParameterivEXT');
    private z_GetHistogramParameterivEXT_1 := GetProcOrNil&<procedure(target: HistogramTargetEXT; pname: GetHistogramParameterPName; &params: IntPtr)>(z_GetHistogramParameterivEXT_adr);
    private z_GetHistogramParameterivEXT_2 := GetProcOrNil&<procedure(target: HistogramTargetEXT; pname: GetHistogramParameterPName; var &params: Int32)>(z_GetHistogramParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameterivEXT(target: HistogramTargetEXT; pname: GetHistogramParameterPName; var &params: Int32) :=
    z_GetHistogramParameterivEXT_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameterivEXT(target: HistogramTargetEXT; pname: GetHistogramParameterPName; &params: IntPtr) :=
    z_GetHistogramParameterivEXT_1(target, pname, &params);
    
    private z_GetMinmaxEXT_adr := GetProcAddress('glGetMinmaxEXT');
    private z_GetMinmaxEXT_1 := GetProcOrNil&<procedure(target: MinmaxTargetEXT; reset: boolean; format: PixelFormat; &type: PixelType; values: IntPtr)>(z_GetMinmaxEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmaxEXT(target: MinmaxTargetEXT; reset: boolean; format: PixelFormat; &type: PixelType; values: IntPtr) :=
    z_GetMinmaxEXT_1(target, reset, format, &type, values);
    
    private z_GetMinmaxParameterfvEXT_adr := GetProcAddress('glGetMinmaxParameterfvEXT');
    private z_GetMinmaxParameterfvEXT_1 := GetProcOrNil&<procedure(target: MinmaxTargetEXT; pname: GetMinmaxParameterPName; &params: IntPtr)>(z_GetMinmaxParameterfvEXT_adr);
    private z_GetMinmaxParameterfvEXT_2 := GetProcOrNil&<procedure(target: MinmaxTargetEXT; pname: GetMinmaxParameterPName; var &params: single)>(z_GetMinmaxParameterfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmaxParameterfvEXT(target: MinmaxTargetEXT; pname: GetMinmaxParameterPName; var &params: single) :=
    z_GetMinmaxParameterfvEXT_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmaxParameterfvEXT(target: MinmaxTargetEXT; pname: GetMinmaxParameterPName; &params: IntPtr) :=
    z_GetMinmaxParameterfvEXT_1(target, pname, &params);
    
    private z_GetMinmaxParameterivEXT_adr := GetProcAddress('glGetMinmaxParameterivEXT');
    private z_GetMinmaxParameterivEXT_1 := GetProcOrNil&<procedure(target: MinmaxTargetEXT; pname: GetMinmaxParameterPName; &params: IntPtr)>(z_GetMinmaxParameterivEXT_adr);
    private z_GetMinmaxParameterivEXT_2 := GetProcOrNil&<procedure(target: MinmaxTargetEXT; pname: GetMinmaxParameterPName; var &params: Int32)>(z_GetMinmaxParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmaxParameterivEXT(target: MinmaxTargetEXT; pname: GetMinmaxParameterPName; var &params: Int32) :=
    z_GetMinmaxParameterivEXT_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmaxParameterivEXT(target: MinmaxTargetEXT; pname: GetMinmaxParameterPName; &params: IntPtr) :=
    z_GetMinmaxParameterivEXT_1(target, pname, &params);
    
    private z_HistogramEXT_adr := GetProcAddress('glHistogramEXT');
    private z_HistogramEXT_1 := GetProcOrNil&<procedure(target: HistogramTargetEXT; width: Int32; _internalformat: InternalFormat; sink: boolean)>(z_HistogramEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure HistogramEXT(target: HistogramTargetEXT; width: Int32; _internalformat: InternalFormat; sink: boolean) :=
    z_HistogramEXT_1(target, width, _internalformat, sink);
    
    private z_MinmaxEXT_adr := GetProcAddress('glMinmaxEXT');
    private z_MinmaxEXT_1 := GetProcOrNil&<procedure(target: MinmaxTargetEXT; _internalformat: InternalFormat; sink: boolean)>(z_MinmaxEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MinmaxEXT(target: MinmaxTargetEXT; _internalformat: InternalFormat; sink: boolean) :=
    z_MinmaxEXT_1(target, _internalformat, sink);
    
    private z_ResetHistogramEXT_adr := GetProcAddress('glResetHistogramEXT');
    private z_ResetHistogramEXT_1 := GetProcOrNil&<procedure(target: HistogramTargetEXT)>(z_ResetHistogramEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ResetHistogramEXT(target: HistogramTargetEXT) :=
    z_ResetHistogramEXT_1(target);
    
    private z_ResetMinmaxEXT_adr := GetProcAddress('glResetMinmaxEXT');
    private z_ResetMinmaxEXT_1 := GetProcOrNil&<procedure(target: MinmaxTargetEXT)>(z_ResetMinmaxEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ResetMinmaxEXT(target: MinmaxTargetEXT) :=
    z_ResetMinmaxEXT_1(target);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glIndexFuncEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_index_func';
    
    private z_IndexFuncEXT_adr := GetProcAddress('glIndexFuncEXT');
    private z_IndexFuncEXT_1 := GetProcOrNil&<procedure(func: IndexFunction; ref: single)>(z_IndexFuncEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexFuncEXT(func: IndexFunction; ref: single) :=
    z_IndexFuncEXT_1(func, ref);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glIndexMaterialEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_index_material';
    
    private z_IndexMaterialEXT_adr := GetProcAddress('glIndexMaterialEXT');
    private z_IndexMaterialEXT_1 := GetProcOrNil&<procedure(face: MaterialFace; mode: IndexMaterialParameter)>(z_IndexMaterialEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexMaterialEXT(face: MaterialFace; mode: IndexMaterialParameter) :=
    z_IndexMaterialEXT_1(face, mode);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glLightTextureEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_light_texture';
    
    private z_ApplyTextureEXT_adr := GetProcAddress('glApplyTextureEXT');
    private z_ApplyTextureEXT_1 := GetProcOrNil&<procedure(mode: LightTextureMode)>(z_ApplyTextureEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ApplyTextureEXT(mode: LightTextureMode) :=
    z_ApplyTextureEXT_1(mode);
    
    private z_TextureLightEXT_adr := GetProcAddress('glTextureLightEXT');
    private z_TextureLightEXT_1 := GetProcOrNil&<procedure(pname: LightTexturePName)>(z_TextureLightEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureLightEXT(pname: LightTexturePName) :=
    z_TextureLightEXT_1(pname);
    
    private z_TextureMaterialEXT_adr := GetProcAddress('glTextureMaterialEXT');
    private z_TextureMaterialEXT_1 := GetProcOrNil&<procedure(face: MaterialFace; mode: MaterialParameter)>(z_TextureMaterialEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureMaterialEXT(face: MaterialFace; mode: MaterialParameter) :=
    z_TextureMaterialEXT_1(face, mode);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glMemoryObjectEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_memory_object';
    
    private z_GetUnsignedBytevEXT_adr := GetProcAddress('glGetUnsignedBytevEXT');
    private z_GetUnsignedBytevEXT_1 := GetProcOrNil&<procedure(pname: GetPName; data: IntPtr)>(z_GetUnsignedBytevEXT_adr);
    private z_GetUnsignedBytevEXT_2 := GetProcOrNil&<procedure(pname: GetPName; var data: Byte)>(z_GetUnsignedBytevEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUnsignedBytevEXT(pname: GetPName; var data: Byte) :=
    z_GetUnsignedBytevEXT_2(pname, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUnsignedBytevEXT(pname: GetPName; data: IntPtr) :=
    z_GetUnsignedBytevEXT_1(pname, data);
    
    private z_GetUnsignedBytei_vEXT_adr := GetProcAddress('glGetUnsignedBytei_vEXT');
    private z_GetUnsignedBytei_vEXT_1 := GetProcOrNil&<procedure(target: DummyEnum; index: UInt32; data: IntPtr)>(z_GetUnsignedBytei_vEXT_adr);
    private z_GetUnsignedBytei_vEXT_2 := GetProcOrNil&<procedure(target: DummyEnum; index: UInt32; var data: Byte)>(z_GetUnsignedBytei_vEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUnsignedBytei_vEXT(target: DummyEnum; index: UInt32; var data: Byte) :=
    z_GetUnsignedBytei_vEXT_2(target, index, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUnsignedBytei_vEXT(target: DummyEnum; index: UInt32; data: IntPtr) :=
    z_GetUnsignedBytei_vEXT_1(target, index, data);
    
    private z_DeleteMemoryObjectsEXT_adr := GetProcAddress('glDeleteMemoryObjectsEXT');
    private z_DeleteMemoryObjectsEXT_1 := GetProcOrNil&<procedure(n: Int32; memoryObjects: IntPtr)>(z_DeleteMemoryObjectsEXT_adr);
    private z_DeleteMemoryObjectsEXT_2 := GetProcOrNil&<procedure(n: Int32; var memoryObjects: UInt32)>(z_DeleteMemoryObjectsEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteMemoryObjectsEXT(n: Int32; memoryObjects: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (memoryObjects<>nil) and (memoryObjects.Length<>0) then
        z_DeleteMemoryObjectsEXT_2(n, memoryObjects[0]) else
        z_DeleteMemoryObjectsEXT_2(n, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteMemoryObjectsEXT(n: Int32; var memoryObjects: UInt32) :=
    z_DeleteMemoryObjectsEXT_2(n, memoryObjects);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteMemoryObjectsEXT(n: Int32; memoryObjects: IntPtr) :=
    z_DeleteMemoryObjectsEXT_1(n, memoryObjects);
    
    private z_IsMemoryObjectEXT_adr := GetProcAddress('glIsMemoryObjectEXT');
    private z_IsMemoryObjectEXT_1 := GetProcOrNil&<function(memoryObject: UInt32): boolean>(z_IsMemoryObjectEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsMemoryObjectEXT(memoryObject: UInt32): boolean :=
    z_IsMemoryObjectEXT_1(memoryObject);
    
    private z_CreateMemoryObjectsEXT_adr := GetProcAddress('glCreateMemoryObjectsEXT');
    private z_CreateMemoryObjectsEXT_1 := GetProcOrNil&<procedure(n: Int32; memoryObjects: IntPtr)>(z_CreateMemoryObjectsEXT_adr);
    private z_CreateMemoryObjectsEXT_2 := GetProcOrNil&<procedure(n: Int32; var memoryObjects: UInt32)>(z_CreateMemoryObjectsEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateMemoryObjectsEXT(n: Int32; memoryObjects: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (memoryObjects<>nil) and (memoryObjects.Length<>0) then
        z_CreateMemoryObjectsEXT_2(n, memoryObjects[0]) else
        z_CreateMemoryObjectsEXT_2(n, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateMemoryObjectsEXT(n: Int32; var memoryObjects: UInt32) :=
    z_CreateMemoryObjectsEXT_2(n, memoryObjects);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateMemoryObjectsEXT(n: Int32; memoryObjects: IntPtr) :=
    z_CreateMemoryObjectsEXT_1(n, memoryObjects);
    
    private z_MemoryObjectParameterivEXT_adr := GetProcAddress('glMemoryObjectParameterivEXT');
    private z_MemoryObjectParameterivEXT_1 := GetProcOrNil&<procedure(memoryObject: UInt32; pname: MemoryObjectParameterName; &params: IntPtr)>(z_MemoryObjectParameterivEXT_adr);
    private z_MemoryObjectParameterivEXT_2 := GetProcOrNil&<procedure(memoryObject: UInt32; pname: MemoryObjectParameterName; var &params: Int32)>(z_MemoryObjectParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MemoryObjectParameterivEXT(memoryObject: UInt32; pname: MemoryObjectParameterName; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_MemoryObjectParameterivEXT_2(memoryObject, pname, &params[0]) else
        z_MemoryObjectParameterivEXT_2(memoryObject, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MemoryObjectParameterivEXT(memoryObject: UInt32; pname: MemoryObjectParameterName; var &params: Int32) :=
    z_MemoryObjectParameterivEXT_2(memoryObject, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MemoryObjectParameterivEXT(memoryObject: UInt32; pname: MemoryObjectParameterName; &params: IntPtr) :=
    z_MemoryObjectParameterivEXT_1(memoryObject, pname, &params);
    
    private z_GetMemoryObjectParameterivEXT_adr := GetProcAddress('glGetMemoryObjectParameterivEXT');
    private z_GetMemoryObjectParameterivEXT_1 := GetProcOrNil&<procedure(memoryObject: UInt32; pname: MemoryObjectParameterName; &params: IntPtr)>(z_GetMemoryObjectParameterivEXT_adr);
    private z_GetMemoryObjectParameterivEXT_2 := GetProcOrNil&<procedure(memoryObject: UInt32; pname: MemoryObjectParameterName; var &params: Int32)>(z_GetMemoryObjectParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMemoryObjectParameterivEXT(memoryObject: UInt32; pname: MemoryObjectParameterName; var &params: Int32) :=
    z_GetMemoryObjectParameterivEXT_2(memoryObject, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMemoryObjectParameterivEXT(memoryObject: UInt32; pname: MemoryObjectParameterName; &params: IntPtr) :=
    z_GetMemoryObjectParameterivEXT_1(memoryObject, pname, &params);
    
    private z_TexStorageMem2DEXT_adr := GetProcAddress('glTexStorageMem2DEXT');
    private z_TexStorageMem2DEXT_1 := GetProcOrNil&<procedure(target: TextureTarget; levels: Int32; internalFormat: SizedInternalFormat; width: Int32; height: Int32; memory: UInt32; offset: UInt64)>(z_TexStorageMem2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorageMem2DEXT(target: TextureTarget; levels: Int32; internalFormat: SizedInternalFormat; width: Int32; height: Int32; memory: UInt32; offset: UInt64) :=
    z_TexStorageMem2DEXT_1(target, levels, internalFormat, width, height, memory, offset);
    
    private z_TexStorageMem2DMultisampleEXT_adr := GetProcAddress('glTexStorageMem2DMultisampleEXT');
    private z_TexStorageMem2DMultisampleEXT_1 := GetProcOrNil&<procedure(target: TextureTarget; samples: Int32; internalFormat: SizedInternalFormat; width: Int32; height: Int32; fixedSampleLocations: boolean; memory: UInt32; offset: UInt64)>(z_TexStorageMem2DMultisampleEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorageMem2DMultisampleEXT(target: TextureTarget; samples: Int32; internalFormat: SizedInternalFormat; width: Int32; height: Int32; fixedSampleLocations: boolean; memory: UInt32; offset: UInt64) :=
    z_TexStorageMem2DMultisampleEXT_1(target, samples, internalFormat, width, height, fixedSampleLocations, memory, offset);
    
    private z_TexStorageMem3DEXT_adr := GetProcAddress('glTexStorageMem3DEXT');
    private z_TexStorageMem3DEXT_1 := GetProcOrNil&<procedure(target: TextureTarget; levels: Int32; internalFormat: SizedInternalFormat; width: Int32; height: Int32; depth: Int32; memory: UInt32; offset: UInt64)>(z_TexStorageMem3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorageMem3DEXT(target: TextureTarget; levels: Int32; internalFormat: SizedInternalFormat; width: Int32; height: Int32; depth: Int32; memory: UInt32; offset: UInt64) :=
    z_TexStorageMem3DEXT_1(target, levels, internalFormat, width, height, depth, memory, offset);
    
    private z_TexStorageMem3DMultisampleEXT_adr := GetProcAddress('glTexStorageMem3DMultisampleEXT');
    private z_TexStorageMem3DMultisampleEXT_1 := GetProcOrNil&<procedure(target: TextureTarget; samples: Int32; internalFormat: SizedInternalFormat; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: boolean; memory: UInt32; offset: UInt64)>(z_TexStorageMem3DMultisampleEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorageMem3DMultisampleEXT(target: TextureTarget; samples: Int32; internalFormat: SizedInternalFormat; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: boolean; memory: UInt32; offset: UInt64) :=
    z_TexStorageMem3DMultisampleEXT_1(target, samples, internalFormat, width, height, depth, fixedSampleLocations, memory, offset);
    
    private z_BufferStorageMemEXT_adr := GetProcAddress('glBufferStorageMemEXT');
    private z_BufferStorageMemEXT_1 := GetProcOrNil&<procedure(target: BufferTarget; size: UIntPtr; memory: UInt32; offset: UInt64)>(z_BufferStorageMemEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferStorageMemEXT(target: BufferTarget; size: UIntPtr; memory: UInt32; offset: UInt64) :=
    z_BufferStorageMemEXT_1(target, size, memory, offset);
    
    private z_TextureStorageMem2DEXT_adr := GetProcAddress('glTextureStorageMem2DEXT');
    private z_TextureStorageMem2DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; levels: Int32; internalFormat: SizedInternalFormat; width: Int32; height: Int32; memory: UInt32; offset: UInt64)>(z_TextureStorageMem2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorageMem2DEXT(texture: gl_texture; levels: Int32; internalFormat: SizedInternalFormat; width: Int32; height: Int32; memory: UInt32; offset: UInt64) :=
    z_TextureStorageMem2DEXT_1(texture, levels, internalFormat, width, height, memory, offset);
    
    private z_TextureStorageMem2DMultisampleEXT_adr := GetProcAddress('glTextureStorageMem2DMultisampleEXT');
    private z_TextureStorageMem2DMultisampleEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; samples: Int32; internalFormat: SizedInternalFormat; width: Int32; height: Int32; fixedSampleLocations: boolean; memory: UInt32; offset: UInt64)>(z_TextureStorageMem2DMultisampleEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorageMem2DMultisampleEXT(texture: gl_texture; samples: Int32; internalFormat: SizedInternalFormat; width: Int32; height: Int32; fixedSampleLocations: boolean; memory: UInt32; offset: UInt64) :=
    z_TextureStorageMem2DMultisampleEXT_1(texture, samples, internalFormat, width, height, fixedSampleLocations, memory, offset);
    
    private z_TextureStorageMem3DEXT_adr := GetProcAddress('glTextureStorageMem3DEXT');
    private z_TextureStorageMem3DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; levels: Int32; internalFormat: SizedInternalFormat; width: Int32; height: Int32; depth: Int32; memory: UInt32; offset: UInt64)>(z_TextureStorageMem3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorageMem3DEXT(texture: gl_texture; levels: Int32; internalFormat: SizedInternalFormat; width: Int32; height: Int32; depth: Int32; memory: UInt32; offset: UInt64) :=
    z_TextureStorageMem3DEXT_1(texture, levels, internalFormat, width, height, depth, memory, offset);
    
    private z_TextureStorageMem3DMultisampleEXT_adr := GetProcAddress('glTextureStorageMem3DMultisampleEXT');
    private z_TextureStorageMem3DMultisampleEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; samples: Int32; internalFormat: SizedInternalFormat; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: boolean; memory: UInt32; offset: UInt64)>(z_TextureStorageMem3DMultisampleEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorageMem3DMultisampleEXT(texture: gl_texture; samples: Int32; internalFormat: SizedInternalFormat; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: boolean; memory: UInt32; offset: UInt64) :=
    z_TextureStorageMem3DMultisampleEXT_1(texture, samples, internalFormat, width, height, depth, fixedSampleLocations, memory, offset);
    
    private z_NamedBufferStorageMemEXT_adr := GetProcAddress('glNamedBufferStorageMemEXT');
    private z_NamedBufferStorageMemEXT_1 := GetProcOrNil&<procedure(buffer: gl_buffer; size: UIntPtr; memory: UInt32; offset: UInt64)>(z_NamedBufferStorageMemEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferStorageMemEXT(buffer: gl_buffer; size: UIntPtr; memory: UInt32; offset: UInt64) :=
    z_NamedBufferStorageMemEXT_1(buffer, size, memory, offset);
    
    private z_TexStorageMem1DEXT_adr := GetProcAddress('glTexStorageMem1DEXT');
    private z_TexStorageMem1DEXT_1 := GetProcOrNil&<procedure(target: TextureTarget; levels: Int32; internalFormat: SizedInternalFormat; width: Int32; memory: UInt32; offset: UInt64)>(z_TexStorageMem1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorageMem1DEXT(target: TextureTarget; levels: Int32; internalFormat: SizedInternalFormat; width: Int32; memory: UInt32; offset: UInt64) :=
    z_TexStorageMem1DEXT_1(target, levels, internalFormat, width, memory, offset);
    
    private z_TextureStorageMem1DEXT_adr := GetProcAddress('glTextureStorageMem1DEXT');
    private z_TextureStorageMem1DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; levels: Int32; internalFormat: SizedInternalFormat; width: Int32; memory: UInt32; offset: UInt64)>(z_TextureStorageMem1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorageMem1DEXT(texture: gl_texture; levels: Int32; internalFormat: SizedInternalFormat; width: Int32; memory: UInt32; offset: UInt64) :=
    z_TextureStorageMem1DEXT_1(texture, levels, internalFormat, width, memory, offset);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glMemoryObjectFdEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_memory_object_fd';
    
    private z_ImportMemoryFdEXT_adr := GetProcAddress('glImportMemoryFdEXT');
    private z_ImportMemoryFdEXT_1 := GetProcOrNil&<procedure(memory: UInt32; size: UInt64; handleType: ExternalHandleType; fd: Int32)>(z_ImportMemoryFdEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImportMemoryFdEXT(memory: UInt32; size: UInt64; handleType: ExternalHandleType; fd: Int32) :=
    z_ImportMemoryFdEXT_1(memory, size, handleType, fd);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glMemoryObjectWin32EXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_memory_object_win32';
    
    private z_ImportMemoryWin32HandleEXT_adr := GetProcAddress('glImportMemoryWin32HandleEXT');
    private z_ImportMemoryWin32HandleEXT_1 := GetProcOrNil&<procedure(memory: UInt32; size: UInt64; handleType: ExternalHandleType; handle: IntPtr)>(z_ImportMemoryWin32HandleEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImportMemoryWin32HandleEXT(memory: UInt32; size: UInt64; handleType: ExternalHandleType; handle: IntPtr) :=
    z_ImportMemoryWin32HandleEXT_1(memory, size, handleType, handle);
    
    private z_ImportMemoryWin32NameEXT_adr := GetProcAddress('glImportMemoryWin32NameEXT');
    private z_ImportMemoryWin32NameEXT_1 := GetProcOrNil&<procedure(memory: UInt32; size: UInt64; handleType: ExternalHandleType; name: IntPtr)>(z_ImportMemoryWin32NameEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImportMemoryWin32NameEXT(memory: UInt32; size: UInt64; handleType: ExternalHandleType; name: IntPtr) :=
    z_ImportMemoryWin32NameEXT_1(memory, size, handleType, name);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glMultiDrawArraysEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_multi_draw_arrays';
    
    private z_MultiDrawArraysEXT_adr := GetProcAddress('glMultiDrawArraysEXT');
    private z_MultiDrawArraysEXT_1 := GetProcOrNil&<procedure(mode: PrimitiveType; first: IntPtr; count: IntPtr; primcount: Int32)>(z_MultiDrawArraysEXT_adr);
    private z_MultiDrawArraysEXT_2 := GetProcOrNil&<procedure(mode: PrimitiveType; first: IntPtr; var count: Int32; primcount: Int32)>(z_MultiDrawArraysEXT_adr);
    private z_MultiDrawArraysEXT_3 := GetProcOrNil&<procedure(mode: PrimitiveType; var first: Int32; count: IntPtr; primcount: Int32)>(z_MultiDrawArraysEXT_adr);
    private z_MultiDrawArraysEXT_4 := GetProcOrNil&<procedure(mode: PrimitiveType; var first: Int32; var count: Int32; primcount: Int32)>(z_MultiDrawArraysEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysEXT(mode: PrimitiveType; first: array of Int32; count: array of Int32; primcount: Int32);
    type PInt32=^Int32;
    begin
      if (count<>nil) and (count.Length<>0) then
        if (first<>nil) and (first.Length<>0) then
          z_MultiDrawArraysEXT_4(mode, first[0], count[0], primcount) else
          z_MultiDrawArraysEXT_4(mode, PInt32(nil)^, count[0], primcount) else
        if (first<>nil) and (first.Length<>0) then
          z_MultiDrawArraysEXT_4(mode, first[0], PInt32(nil)^, primcount) else
          z_MultiDrawArraysEXT_4(mode, PInt32(nil)^, PInt32(nil)^, primcount);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysEXT(mode: PrimitiveType; var first: Int32; var count: Int32; primcount: Int32) :=
    z_MultiDrawArraysEXT_4(mode, first, count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysEXT(mode: PrimitiveType; var first: Int32; count: IntPtr; primcount: Int32) :=
    z_MultiDrawArraysEXT_3(mode, first, count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysEXT(mode: PrimitiveType; first: IntPtr; var count: Int32; primcount: Int32) :=
    z_MultiDrawArraysEXT_2(mode, first, count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysEXT(mode: PrimitiveType; first: IntPtr; count: IntPtr; primcount: Int32) :=
    z_MultiDrawArraysEXT_1(mode, first, count, primcount);
    
    private z_MultiDrawElementsEXT_adr := GetProcAddress('glMultiDrawElementsEXT');
    private z_MultiDrawElementsEXT_1 := GetProcOrNil&<procedure(mode: PrimitiveType; count: IntPtr; &type: DrawElementsType; indices: pointer; primcount: Int32)>(z_MultiDrawElementsEXT_adr);
    private z_MultiDrawElementsEXT_2 := GetProcOrNil&<procedure(mode: PrimitiveType; count: IntPtr; &type: DrawElementsType; var indices: IntPtr; primcount: Int32)>(z_MultiDrawElementsEXT_adr);
    private z_MultiDrawElementsEXT_3 := GetProcOrNil&<procedure(mode: PrimitiveType; var count: Int32; &type: DrawElementsType; indices: pointer; primcount: Int32)>(z_MultiDrawElementsEXT_adr);
    private z_MultiDrawElementsEXT_4 := GetProcOrNil&<procedure(mode: PrimitiveType; var count: Int32; &type: DrawElementsType; var indices: IntPtr; primcount: Int32)>(z_MultiDrawElementsEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsEXT(mode: PrimitiveType; count: array of Int32; &type: DrawElementsType; indices: array of IntPtr; primcount: Int32);
    type PInt32=^Int32;
    type PIntPtr=^IntPtr;
    begin
      if (indices<>nil) and (indices.Length<>0) then
        if (count<>nil) and (count.Length<>0) then
          z_MultiDrawElementsEXT_4(mode, count[0], &type, indices[0], primcount) else
          z_MultiDrawElementsEXT_4(mode, PInt32(nil)^, &type, indices[0], primcount) else
        if (count<>nil) and (count.Length<>0) then
          z_MultiDrawElementsEXT_4(mode, count[0], &type, PIntPtr(nil)^, primcount) else
          z_MultiDrawElementsEXT_4(mode, PInt32(nil)^, &type, PIntPtr(nil)^, primcount);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsEXT(mode: PrimitiveType; var count: Int32; &type: DrawElementsType; var indices: IntPtr; primcount: Int32) :=
    z_MultiDrawElementsEXT_4(mode, count, &type, indices, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsEXT(mode: PrimitiveType; var count: Int32; &type: DrawElementsType; indices: pointer; primcount: Int32) :=
    z_MultiDrawElementsEXT_3(mode, count, &type, indices, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsEXT(mode: PrimitiveType; count: IntPtr; &type: DrawElementsType; var indices: IntPtr; primcount: Int32) :=
    z_MultiDrawElementsEXT_2(mode, count, &type, indices, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsEXT(mode: PrimitiveType; count: IntPtr; &type: DrawElementsType; indices: pointer; primcount: Int32) :=
    z_MultiDrawElementsEXT_1(mode, count, &type, indices, primcount);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glMultisampleEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_multisample';
    
    private z_SampleMaskEXT_adr := GetProcAddress('glSampleMaskEXT');
    private z_SampleMaskEXT_1 := GetProcOrNil&<procedure(value: single; invert: boolean)>(z_SampleMaskEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SampleMaskEXT(value: single; invert: boolean) :=
    z_SampleMaskEXT_1(value, invert);
    
    private z_SamplePatternEXT_adr := GetProcAddress('glSamplePatternEXT');
    private z_SamplePatternEXT_1 := GetProcOrNil&<procedure(pattern: OpenGL.SamplePatternEXT)>(z_SamplePatternEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplePatternEXT(pattern: OpenGL.SamplePatternEXT) :=
    z_SamplePatternEXT_1(pattern);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glPalettedTextureEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_paletted_texture';
    
    private z_ColorTableEXT_adr := GetProcAddress('glColorTableEXT');
    private z_ColorTableEXT_1 := GetProcOrNil&<procedure(target: ColorTableTarget; _internalFormat: InternalFormat; width: Int32; format: PixelFormat; &type: PixelType; table: IntPtr)>(z_ColorTableEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableEXT(target: ColorTableTarget; _internalFormat: InternalFormat; width: Int32; format: PixelFormat; &type: PixelType; table: IntPtr) :=
    z_ColorTableEXT_1(target, _internalFormat, width, format, &type, table);
    
    private z_GetColorTableEXT_adr := GetProcAddress('glGetColorTableEXT');
    private z_GetColorTableEXT_1 := GetProcOrNil&<procedure(target: ColorTableTarget; format: PixelFormat; &type: PixelType; data: IntPtr)>(z_GetColorTableEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableEXT(target: ColorTableTarget; format: PixelFormat; &type: PixelType; data: IntPtr) :=
    z_GetColorTableEXT_1(target, format, &type, data);
    
    private z_GetColorTableParameterivEXT_adr := GetProcAddress('glGetColorTableParameterivEXT');
    private z_GetColorTableParameterivEXT_1 := GetProcOrNil&<procedure(target: ColorTableTarget; pname: ColorTableParameterPName; &params: IntPtr)>(z_GetColorTableParameterivEXT_adr);
    private z_GetColorTableParameterivEXT_2 := GetProcOrNil&<procedure(target: ColorTableTarget; pname: ColorTableParameterPName; var &params: Int32)>(z_GetColorTableParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterivEXT(target: ColorTableTarget; pname: ColorTableParameterPName; var &params: Int32) :=
    z_GetColorTableParameterivEXT_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterivEXT(target: ColorTableTarget; pname: ColorTableParameterPName; &params: IntPtr) :=
    z_GetColorTableParameterivEXT_1(target, pname, &params);
    
    private z_GetColorTableParameterfvEXT_adr := GetProcAddress('glGetColorTableParameterfvEXT');
    private z_GetColorTableParameterfvEXT_1 := GetProcOrNil&<procedure(target: ColorTableTarget; pname: ColorTableParameterPName; &params: IntPtr)>(z_GetColorTableParameterfvEXT_adr);
    private z_GetColorTableParameterfvEXT_2 := GetProcOrNil&<procedure(target: ColorTableTarget; pname: ColorTableParameterPName; var &params: single)>(z_GetColorTableParameterfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterfvEXT(target: ColorTableTarget; pname: ColorTableParameterPName; var &params: single) :=
    z_GetColorTableParameterfvEXT_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterfvEXT(target: ColorTableTarget; pname: ColorTableParameterPName; &params: IntPtr) :=
    z_GetColorTableParameterfvEXT_1(target, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glPixelTransformEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_pixel_transform';
    
    private z_PixelTransformParameteriEXT_adr := GetProcAddress('glPixelTransformParameteriEXT');
    private z_PixelTransformParameteriEXT_1 := GetProcOrNil&<procedure(target: PixelTransformTarget; pname: PixelTransformPName; param: Int32)>(z_PixelTransformParameteriEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameteriEXT(target: PixelTransformTarget; pname: PixelTransformPName; param: Int32) :=
    z_PixelTransformParameteriEXT_1(target, pname, param);
    
    private z_PixelTransformParameterfEXT_adr := GetProcAddress('glPixelTransformParameterfEXT');
    private z_PixelTransformParameterfEXT_1 := GetProcOrNil&<procedure(target: PixelTransformTarget; pname: PixelTransformPName; param: single)>(z_PixelTransformParameterfEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameterfEXT(target: PixelTransformTarget; pname: PixelTransformPName; param: single) :=
    z_PixelTransformParameterfEXT_1(target, pname, param);
    
    private z_PixelTransformParameterivEXT_adr := GetProcAddress('glPixelTransformParameterivEXT');
    private z_PixelTransformParameterivEXT_1 := GetProcOrNil&<procedure(target: PixelTransformTarget; pname: PixelTransformPName; &params: IntPtr)>(z_PixelTransformParameterivEXT_adr);
    private z_PixelTransformParameterivEXT_2 := GetProcOrNil&<procedure(target: PixelTransformTarget; pname: PixelTransformPName; var &params: Int32)>(z_PixelTransformParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameterivEXT(target: PixelTransformTarget; pname: PixelTransformPName; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_PixelTransformParameterivEXT_2(target, pname, &params[0]) else
        z_PixelTransformParameterivEXT_2(target, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameterivEXT(target: PixelTransformTarget; pname: PixelTransformPName; var &params: Int32) :=
    z_PixelTransformParameterivEXT_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameterivEXT(target: PixelTransformTarget; pname: PixelTransformPName; &params: IntPtr) :=
    z_PixelTransformParameterivEXT_1(target, pname, &params);
    
    private z_PixelTransformParameterfvEXT_adr := GetProcAddress('glPixelTransformParameterfvEXT');
    private z_PixelTransformParameterfvEXT_1 := GetProcOrNil&<procedure(target: PixelTransformTarget; pname: PixelTransformPName; &params: IntPtr)>(z_PixelTransformParameterfvEXT_adr);
    private z_PixelTransformParameterfvEXT_2 := GetProcOrNil&<procedure(target: PixelTransformTarget; pname: PixelTransformPName; var &params: single)>(z_PixelTransformParameterfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameterfvEXT(target: PixelTransformTarget; pname: PixelTransformPName; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_PixelTransformParameterfvEXT_2(target, pname, &params[0]) else
        z_PixelTransformParameterfvEXT_2(target, pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameterfvEXT(target: PixelTransformTarget; pname: PixelTransformPName; var &params: single) :=
    z_PixelTransformParameterfvEXT_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameterfvEXT(target: PixelTransformTarget; pname: PixelTransformPName; &params: IntPtr) :=
    z_PixelTransformParameterfvEXT_1(target, pname, &params);
    
    private z_GetPixelTransformParameterivEXT_adr := GetProcAddress('glGetPixelTransformParameterivEXT');
    private z_GetPixelTransformParameterivEXT_1 := GetProcOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: IntPtr)>(z_GetPixelTransformParameterivEXT_adr);
    private z_GetPixelTransformParameterivEXT_2 := GetProcOrNil&<procedure(target: DummyEnum; pname: DummyEnum; var &params: Int32)>(z_GetPixelTransformParameterivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTransformParameterivEXT(target: DummyEnum; pname: DummyEnum; var &params: Int32) :=
    z_GetPixelTransformParameterivEXT_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTransformParameterivEXT(target: DummyEnum; pname: DummyEnum; &params: IntPtr) :=
    z_GetPixelTransformParameterivEXT_1(target, pname, &params);
    
    private z_GetPixelTransformParameterfvEXT_adr := GetProcAddress('glGetPixelTransformParameterfvEXT');
    private z_GetPixelTransformParameterfvEXT_1 := GetProcOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: IntPtr)>(z_GetPixelTransformParameterfvEXT_adr);
    private z_GetPixelTransformParameterfvEXT_2 := GetProcOrNil&<procedure(target: DummyEnum; pname: DummyEnum; var &params: single)>(z_GetPixelTransformParameterfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTransformParameterfvEXT(target: DummyEnum; pname: DummyEnum; var &params: single) :=
    z_GetPixelTransformParameterfvEXT_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTransformParameterfvEXT(target: DummyEnum; pname: DummyEnum; &params: IntPtr) :=
    z_GetPixelTransformParameterfvEXT_1(target, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glPointParametersEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_point_parameters';
    
    private z_PointParameterfEXT_adr := GetProcAddress('glPointParameterfEXT');
    private z_PointParameterfEXT_1 := GetProcOrNil&<procedure(pname: PointParameterName; param: single)>(z_PointParameterfEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfEXT(pname: PointParameterName; param: single) :=
    z_PointParameterfEXT_1(pname, param);
    
    private z_PointParameterfvEXT_adr := GetProcAddress('glPointParameterfvEXT');
    private z_PointParameterfvEXT_1 := GetProcOrNil&<procedure(pname: PointParameterName; &params: IntPtr)>(z_PointParameterfvEXT_adr);
    private z_PointParameterfvEXT_2 := GetProcOrNil&<procedure(pname: PointParameterName; var &params: single)>(z_PointParameterfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfvEXT(pname: PointParameterName; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_PointParameterfvEXT_2(pname, &params[0]) else
        z_PointParameterfvEXT_2(pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfvEXT(pname: PointParameterName; var &params: single) :=
    z_PointParameterfvEXT_2(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfvEXT(pname: PointParameterName; &params: IntPtr) :=
    z_PointParameterfvEXT_1(pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glPolygonOffsetEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_polygon_offset';
    
    private z_PolygonOffsetEXT_adr := GetProcAddress('glPolygonOffsetEXT');
    private z_PolygonOffsetEXT_1 := GetProcOrNil&<procedure(factor: single; bias: single)>(z_PolygonOffsetEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PolygonOffsetEXT(factor: single; bias: single) :=
    z_PolygonOffsetEXT_1(factor, bias);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glPolygonOffsetClampEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_polygon_offset_clamp';
    
    private z_PolygonOffsetClampEXT_adr := GetProcAddress('glPolygonOffsetClampEXT');
    private z_PolygonOffsetClampEXT_1 := GetProcOrNil&<procedure(factor: single; units: single; clamp: single)>(z_PolygonOffsetClampEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PolygonOffsetClampEXT(factor: single; units: single; clamp: single) :=
    z_PolygonOffsetClampEXT_1(factor, units, clamp);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glProvokingVertexEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_provoking_vertex';
    
    private z_ProvokingVertexEXT_adr := GetProcAddress('glProvokingVertexEXT');
    private z_ProvokingVertexEXT_1 := GetProcOrNil&<procedure(mode: VertexProvokingMode)>(z_ProvokingVertexEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProvokingVertexEXT(mode: VertexProvokingMode) :=
    z_ProvokingVertexEXT_1(mode);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glRasterMultisampleEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_raster_multisample';
    
    private z_RasterSamplesEXT_adr := GetProcAddress('glRasterSamplesEXT');
    private z_RasterSamplesEXT_1 := GetProcOrNil&<procedure(samples: UInt32; fixedsamplelocations: boolean)>(z_RasterSamplesEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterSamplesEXT(samples: UInt32; fixedsamplelocations: boolean) :=
    z_RasterSamplesEXT_1(samples, fixedsamplelocations);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glSemaphoreEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_semaphore';
    
    private z_GetUnsignedBytevEXT_adr := GetProcAddress('glGetUnsignedBytevEXT');
    private z_GetUnsignedBytevEXT_1 := GetProcOrNil&<procedure(pname: GetPName; data: IntPtr)>(z_GetUnsignedBytevEXT_adr);
    private z_GetUnsignedBytevEXT_2 := GetProcOrNil&<procedure(pname: GetPName; var data: Byte)>(z_GetUnsignedBytevEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUnsignedBytevEXT(pname: GetPName; var data: Byte) :=
    z_GetUnsignedBytevEXT_2(pname, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUnsignedBytevEXT(pname: GetPName; data: IntPtr) :=
    z_GetUnsignedBytevEXT_1(pname, data);
    
    private z_GetUnsignedBytei_vEXT_adr := GetProcAddress('glGetUnsignedBytei_vEXT');
    private z_GetUnsignedBytei_vEXT_1 := GetProcOrNil&<procedure(target: DummyEnum; index: UInt32; data: IntPtr)>(z_GetUnsignedBytei_vEXT_adr);
    private z_GetUnsignedBytei_vEXT_2 := GetProcOrNil&<procedure(target: DummyEnum; index: UInt32; var data: Byte)>(z_GetUnsignedBytei_vEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUnsignedBytei_vEXT(target: DummyEnum; index: UInt32; var data: Byte) :=
    z_GetUnsignedBytei_vEXT_2(target, index, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUnsignedBytei_vEXT(target: DummyEnum; index: UInt32; data: IntPtr) :=
    z_GetUnsignedBytei_vEXT_1(target, index, data);
    
    private z_GenSemaphoresEXT_adr := GetProcAddress('glGenSemaphoresEXT');
    private z_GenSemaphoresEXT_1 := GetProcOrNil&<procedure(n: Int32; semaphores: IntPtr)>(z_GenSemaphoresEXT_adr);
    private z_GenSemaphoresEXT_2 := GetProcOrNil&<procedure(n: Int32; var semaphores: UInt32)>(z_GenSemaphoresEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenSemaphoresEXT(n: Int32; semaphores: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (semaphores<>nil) and (semaphores.Length<>0) then
        z_GenSemaphoresEXT_2(n, semaphores[0]) else
        z_GenSemaphoresEXT_2(n, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenSemaphoresEXT(n: Int32; var semaphores: UInt32) :=
    z_GenSemaphoresEXT_2(n, semaphores);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenSemaphoresEXT(n: Int32; semaphores: IntPtr) :=
    z_GenSemaphoresEXT_1(n, semaphores);
    
    private z_DeleteSemaphoresEXT_adr := GetProcAddress('glDeleteSemaphoresEXT');
    private z_DeleteSemaphoresEXT_1 := GetProcOrNil&<procedure(n: Int32; semaphores: IntPtr)>(z_DeleteSemaphoresEXT_adr);
    private z_DeleteSemaphoresEXT_2 := GetProcOrNil&<procedure(n: Int32; var semaphores: UInt32)>(z_DeleteSemaphoresEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteSemaphoresEXT(n: Int32; semaphores: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (semaphores<>nil) and (semaphores.Length<>0) then
        z_DeleteSemaphoresEXT_2(n, semaphores[0]) else
        z_DeleteSemaphoresEXT_2(n, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteSemaphoresEXT(n: Int32; var semaphores: UInt32) :=
    z_DeleteSemaphoresEXT_2(n, semaphores);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteSemaphoresEXT(n: Int32; semaphores: IntPtr) :=
    z_DeleteSemaphoresEXT_1(n, semaphores);
    
    private z_IsSemaphoreEXT_adr := GetProcAddress('glIsSemaphoreEXT');
    private z_IsSemaphoreEXT_1 := GetProcOrNil&<function(semaphore: UInt32): boolean>(z_IsSemaphoreEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsSemaphoreEXT(semaphore: UInt32): boolean :=
    z_IsSemaphoreEXT_1(semaphore);
    
    private z_SemaphoreParameterui64vEXT_adr := GetProcAddress('glSemaphoreParameterui64vEXT');
    private z_SemaphoreParameterui64vEXT_1 := GetProcOrNil&<procedure(semaphore: UInt32; pname: SemaphoreParameterName; &params: IntPtr)>(z_SemaphoreParameterui64vEXT_adr);
    private z_SemaphoreParameterui64vEXT_2 := GetProcOrNil&<procedure(semaphore: UInt32; pname: SemaphoreParameterName; var &params: UInt64)>(z_SemaphoreParameterui64vEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SemaphoreParameterui64vEXT(semaphore: UInt32; pname: SemaphoreParameterName; &params: array of UInt64);
    type PUInt64=^UInt64;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_SemaphoreParameterui64vEXT_2(semaphore, pname, &params[0]) else
        z_SemaphoreParameterui64vEXT_2(semaphore, pname, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SemaphoreParameterui64vEXT(semaphore: UInt32; pname: SemaphoreParameterName; var &params: UInt64) :=
    z_SemaphoreParameterui64vEXT_2(semaphore, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SemaphoreParameterui64vEXT(semaphore: UInt32; pname: SemaphoreParameterName; &params: IntPtr) :=
    z_SemaphoreParameterui64vEXT_1(semaphore, pname, &params);
    
    private z_GetSemaphoreParameterui64vEXT_adr := GetProcAddress('glGetSemaphoreParameterui64vEXT');
    private z_GetSemaphoreParameterui64vEXT_1 := GetProcOrNil&<procedure(semaphore: UInt32; pname: SemaphoreParameterName; &params: IntPtr)>(z_GetSemaphoreParameterui64vEXT_adr);
    private z_GetSemaphoreParameterui64vEXT_2 := GetProcOrNil&<procedure(semaphore: UInt32; pname: SemaphoreParameterName; var &params: UInt64)>(z_GetSemaphoreParameterui64vEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSemaphoreParameterui64vEXT(semaphore: UInt32; pname: SemaphoreParameterName; var &params: UInt64) :=
    z_GetSemaphoreParameterui64vEXT_2(semaphore, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSemaphoreParameterui64vEXT(semaphore: UInt32; pname: SemaphoreParameterName; &params: IntPtr) :=
    z_GetSemaphoreParameterui64vEXT_1(semaphore, pname, &params);
    
    private z_WaitSemaphoreEXT_adr := GetProcAddress('glWaitSemaphoreEXT');
    private z_WaitSemaphoreEXT_1 := GetProcOrNil&<procedure(semaphore: UInt32; numBufferBarriers: UInt32; buffers: IntPtr; numTextureBarriers: UInt32; textures: IntPtr; srcLayouts: IntPtr)>(z_WaitSemaphoreEXT_adr);
    private z_WaitSemaphoreEXT_2 := GetProcOrNil&<procedure(semaphore: UInt32; numBufferBarriers: UInt32; buffers: IntPtr; numTextureBarriers: UInt32; textures: IntPtr; var srcLayouts: TextureLayout)>(z_WaitSemaphoreEXT_adr);
    private z_WaitSemaphoreEXT_3 := GetProcOrNil&<procedure(semaphore: UInt32; numBufferBarriers: UInt32; buffers: IntPtr; numTextureBarriers: UInt32; var textures: gl_texture; srcLayouts: IntPtr)>(z_WaitSemaphoreEXT_adr);
    private z_WaitSemaphoreEXT_4 := GetProcOrNil&<procedure(semaphore: UInt32; numBufferBarriers: UInt32; buffers: IntPtr; numTextureBarriers: UInt32; var textures: gl_texture; var srcLayouts: TextureLayout)>(z_WaitSemaphoreEXT_adr);
    private z_WaitSemaphoreEXT_5 := GetProcOrNil&<procedure(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: gl_buffer; numTextureBarriers: UInt32; textures: IntPtr; srcLayouts: IntPtr)>(z_WaitSemaphoreEXT_adr);
    private z_WaitSemaphoreEXT_6 := GetProcOrNil&<procedure(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: gl_buffer; numTextureBarriers: UInt32; textures: IntPtr; var srcLayouts: TextureLayout)>(z_WaitSemaphoreEXT_adr);
    private z_WaitSemaphoreEXT_7 := GetProcOrNil&<procedure(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: gl_buffer; numTextureBarriers: UInt32; var textures: gl_texture; srcLayouts: IntPtr)>(z_WaitSemaphoreEXT_adr);
    private z_WaitSemaphoreEXT_8 := GetProcOrNil&<procedure(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: gl_buffer; numTextureBarriers: UInt32; var textures: gl_texture; var srcLayouts: TextureLayout)>(z_WaitSemaphoreEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of gl_buffer; numTextureBarriers: UInt32; textures: array of gl_texture; srcLayouts: array of TextureLayout);
    type Pgl_buffer=^gl_buffer;
    type Pgl_texture=^gl_texture;
    type PTextureLayout=^TextureLayout;
    begin
      if (srcLayouts<>nil) and (srcLayouts.Length<>0) then
        if (textures<>nil) and (textures.Length<>0) then
          if (buffers<>nil) and (buffers.Length<>0) then
            z_WaitSemaphoreEXT_8(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, textures[0], srcLayouts[0]) else
            z_WaitSemaphoreEXT_8(semaphore, numBufferBarriers, Pgl_buffer(nil)^, numTextureBarriers, textures[0], srcLayouts[0]) else
          if (buffers<>nil) and (buffers.Length<>0) then
            z_WaitSemaphoreEXT_8(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, Pgl_texture(nil)^, srcLayouts[0]) else
            z_WaitSemaphoreEXT_8(semaphore, numBufferBarriers, Pgl_buffer(nil)^, numTextureBarriers, Pgl_texture(nil)^, srcLayouts[0]) else
        if (textures<>nil) and (textures.Length<>0) then
          if (buffers<>nil) and (buffers.Length<>0) then
            z_WaitSemaphoreEXT_8(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, textures[0], PTextureLayout(nil)^) else
            z_WaitSemaphoreEXT_8(semaphore, numBufferBarriers, Pgl_buffer(nil)^, numTextureBarriers, textures[0], PTextureLayout(nil)^) else
          if (buffers<>nil) and (buffers.Length<>0) then
            z_WaitSemaphoreEXT_8(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, Pgl_texture(nil)^, PTextureLayout(nil)^) else
            z_WaitSemaphoreEXT_8(semaphore, numBufferBarriers, Pgl_buffer(nil)^, numTextureBarriers, Pgl_texture(nil)^, PTextureLayout(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: gl_buffer; numTextureBarriers: UInt32; var textures: gl_texture; var srcLayouts: TextureLayout) :=
    z_WaitSemaphoreEXT_8(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: gl_buffer; numTextureBarriers: UInt32; var textures: gl_texture; srcLayouts: IntPtr) :=
    z_WaitSemaphoreEXT_7(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: gl_buffer; numTextureBarriers: UInt32; textures: IntPtr; var srcLayouts: TextureLayout) :=
    z_WaitSemaphoreEXT_6(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: gl_buffer; numTextureBarriers: UInt32; textures: IntPtr; srcLayouts: IntPtr) :=
    z_WaitSemaphoreEXT_5(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: IntPtr; numTextureBarriers: UInt32; var textures: gl_texture; var srcLayouts: TextureLayout) :=
    z_WaitSemaphoreEXT_4(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: IntPtr; numTextureBarriers: UInt32; var textures: gl_texture; srcLayouts: IntPtr) :=
    z_WaitSemaphoreEXT_3(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: IntPtr; numTextureBarriers: UInt32; textures: IntPtr; var srcLayouts: TextureLayout) :=
    z_WaitSemaphoreEXT_2(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: IntPtr; numTextureBarriers: UInt32; textures: IntPtr; srcLayouts: IntPtr) :=
    z_WaitSemaphoreEXT_1(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts);
    
    private z_SignalSemaphoreEXT_adr := GetProcAddress('glSignalSemaphoreEXT');
    private z_SignalSemaphoreEXT_1 := GetProcOrNil&<procedure(semaphore: UInt32; numBufferBarriers: UInt32; buffers: IntPtr; numTextureBarriers: UInt32; textures: IntPtr; dstLayouts: IntPtr)>(z_SignalSemaphoreEXT_adr);
    private z_SignalSemaphoreEXT_2 := GetProcOrNil&<procedure(semaphore: UInt32; numBufferBarriers: UInt32; buffers: IntPtr; numTextureBarriers: UInt32; textures: IntPtr; var dstLayouts: TextureLayout)>(z_SignalSemaphoreEXT_adr);
    private z_SignalSemaphoreEXT_3 := GetProcOrNil&<procedure(semaphore: UInt32; numBufferBarriers: UInt32; buffers: IntPtr; numTextureBarriers: UInt32; var textures: gl_texture; dstLayouts: IntPtr)>(z_SignalSemaphoreEXT_adr);
    private z_SignalSemaphoreEXT_4 := GetProcOrNil&<procedure(semaphore: UInt32; numBufferBarriers: UInt32; buffers: IntPtr; numTextureBarriers: UInt32; var textures: gl_texture; var dstLayouts: TextureLayout)>(z_SignalSemaphoreEXT_adr);
    private z_SignalSemaphoreEXT_5 := GetProcOrNil&<procedure(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: gl_buffer; numTextureBarriers: UInt32; textures: IntPtr; dstLayouts: IntPtr)>(z_SignalSemaphoreEXT_adr);
    private z_SignalSemaphoreEXT_6 := GetProcOrNil&<procedure(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: gl_buffer; numTextureBarriers: UInt32; textures: IntPtr; var dstLayouts: TextureLayout)>(z_SignalSemaphoreEXT_adr);
    private z_SignalSemaphoreEXT_7 := GetProcOrNil&<procedure(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: gl_buffer; numTextureBarriers: UInt32; var textures: gl_texture; dstLayouts: IntPtr)>(z_SignalSemaphoreEXT_adr);
    private z_SignalSemaphoreEXT_8 := GetProcOrNil&<procedure(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: gl_buffer; numTextureBarriers: UInt32; var textures: gl_texture; var dstLayouts: TextureLayout)>(z_SignalSemaphoreEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of gl_buffer; numTextureBarriers: UInt32; textures: array of gl_texture; dstLayouts: array of TextureLayout);
    type Pgl_buffer=^gl_buffer;
    type Pgl_texture=^gl_texture;
    type PTextureLayout=^TextureLayout;
    begin
      if (dstLayouts<>nil) and (dstLayouts.Length<>0) then
        if (textures<>nil) and (textures.Length<>0) then
          if (buffers<>nil) and (buffers.Length<>0) then
            z_SignalSemaphoreEXT_8(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, textures[0], dstLayouts[0]) else
            z_SignalSemaphoreEXT_8(semaphore, numBufferBarriers, Pgl_buffer(nil)^, numTextureBarriers, textures[0], dstLayouts[0]) else
          if (buffers<>nil) and (buffers.Length<>0) then
            z_SignalSemaphoreEXT_8(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, Pgl_texture(nil)^, dstLayouts[0]) else
            z_SignalSemaphoreEXT_8(semaphore, numBufferBarriers, Pgl_buffer(nil)^, numTextureBarriers, Pgl_texture(nil)^, dstLayouts[0]) else
        if (textures<>nil) and (textures.Length<>0) then
          if (buffers<>nil) and (buffers.Length<>0) then
            z_SignalSemaphoreEXT_8(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, textures[0], PTextureLayout(nil)^) else
            z_SignalSemaphoreEXT_8(semaphore, numBufferBarriers, Pgl_buffer(nil)^, numTextureBarriers, textures[0], PTextureLayout(nil)^) else
          if (buffers<>nil) and (buffers.Length<>0) then
            z_SignalSemaphoreEXT_8(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, Pgl_texture(nil)^, PTextureLayout(nil)^) else
            z_SignalSemaphoreEXT_8(semaphore, numBufferBarriers, Pgl_buffer(nil)^, numTextureBarriers, Pgl_texture(nil)^, PTextureLayout(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: gl_buffer; numTextureBarriers: UInt32; var textures: gl_texture; var dstLayouts: TextureLayout) :=
    z_SignalSemaphoreEXT_8(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: gl_buffer; numTextureBarriers: UInt32; var textures: gl_texture; dstLayouts: IntPtr) :=
    z_SignalSemaphoreEXT_7(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: gl_buffer; numTextureBarriers: UInt32; textures: IntPtr; var dstLayouts: TextureLayout) :=
    z_SignalSemaphoreEXT_6(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: gl_buffer; numTextureBarriers: UInt32; textures: IntPtr; dstLayouts: IntPtr) :=
    z_SignalSemaphoreEXT_5(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: IntPtr; numTextureBarriers: UInt32; var textures: gl_texture; var dstLayouts: TextureLayout) :=
    z_SignalSemaphoreEXT_4(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: IntPtr; numTextureBarriers: UInt32; var textures: gl_texture; dstLayouts: IntPtr) :=
    z_SignalSemaphoreEXT_3(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: IntPtr; numTextureBarriers: UInt32; textures: IntPtr; var dstLayouts: TextureLayout) :=
    z_SignalSemaphoreEXT_2(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: IntPtr; numTextureBarriers: UInt32; textures: IntPtr; dstLayouts: IntPtr) :=
    z_SignalSemaphoreEXT_1(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, dstLayouts);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glSemaphoreFdEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_semaphore_fd';
    
    private z_ImportSemaphoreFdEXT_adr := GetProcAddress('glImportSemaphoreFdEXT');
    private z_ImportSemaphoreFdEXT_1 := GetProcOrNil&<procedure(semaphore: UInt32; handleType: ExternalHandleType; fd: Int32)>(z_ImportSemaphoreFdEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImportSemaphoreFdEXT(semaphore: UInt32; handleType: ExternalHandleType; fd: Int32) :=
    z_ImportSemaphoreFdEXT_1(semaphore, handleType, fd);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glSemaphoreWin32EXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_semaphore_win32';
    
    private z_ImportSemaphoreWin32HandleEXT_adr := GetProcAddress('glImportSemaphoreWin32HandleEXT');
    private z_ImportSemaphoreWin32HandleEXT_1 := GetProcOrNil&<procedure(semaphore: UInt32; handleType: ExternalHandleType; handle: IntPtr)>(z_ImportSemaphoreWin32HandleEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImportSemaphoreWin32HandleEXT(semaphore: UInt32; handleType: ExternalHandleType; handle: IntPtr) :=
    z_ImportSemaphoreWin32HandleEXT_1(semaphore, handleType, handle);
    
    private z_ImportSemaphoreWin32NameEXT_adr := GetProcAddress('glImportSemaphoreWin32NameEXT');
    private z_ImportSemaphoreWin32NameEXT_1 := GetProcOrNil&<procedure(semaphore: UInt32; handleType: ExternalHandleType; name: IntPtr)>(z_ImportSemaphoreWin32NameEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImportSemaphoreWin32NameEXT(semaphore: UInt32; handleType: ExternalHandleType; name: IntPtr) :=
    z_ImportSemaphoreWin32NameEXT_1(semaphore, handleType, name);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glSecondaryColorEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_secondary_color';
    
    private z_SecondaryColor3bEXT_adr := GetProcAddress('glSecondaryColor3bEXT');
    private z_SecondaryColor3bEXT_1 := GetProcOrNil&<procedure(red: SByte; green: SByte; blue: SByte)>(z_SecondaryColor3bEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3bEXT(red: SByte; green: SByte; blue: SByte) :=
    z_SecondaryColor3bEXT_1(red, green, blue);
    
    private z_SecondaryColor3bvEXT_adr := GetProcAddress('glSecondaryColor3bvEXT');
    private z_SecondaryColor3bvEXT_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_SecondaryColor3bvEXT_adr);
    private z_SecondaryColor3bvEXT_2 := GetProcOrNil&<procedure(var v: SByte)>(z_SecondaryColor3bvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3bvEXT(v: array of SByte);
    type PSByte=^SByte;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_SecondaryColor3bvEXT_2(v[0]) else
        z_SecondaryColor3bvEXT_2(PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3bvEXT(var v: SByte) :=
    z_SecondaryColor3bvEXT_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3bvEXT(v: IntPtr) :=
    z_SecondaryColor3bvEXT_1(v);
    
    private z_SecondaryColor3dEXT_adr := GetProcAddress('glSecondaryColor3dEXT');
    private z_SecondaryColor3dEXT_1 := GetProcOrNil&<procedure(red: real; green: real; blue: real)>(z_SecondaryColor3dEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3dEXT(red: real; green: real; blue: real) :=
    z_SecondaryColor3dEXT_1(red, green, blue);
    
    private z_SecondaryColor3dvEXT_adr := GetProcAddress('glSecondaryColor3dvEXT');
    private z_SecondaryColor3dvEXT_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_SecondaryColor3dvEXT_adr);
    private z_SecondaryColor3dvEXT_2 := GetProcOrNil&<procedure(var v: real)>(z_SecondaryColor3dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3dvEXT(v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_SecondaryColor3dvEXT_2(v[0]) else
        z_SecondaryColor3dvEXT_2(Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3dvEXT(var v: real) :=
    z_SecondaryColor3dvEXT_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3dvEXT(v: IntPtr) :=
    z_SecondaryColor3dvEXT_1(v);
    
    private z_SecondaryColor3fEXT_adr := GetProcAddress('glSecondaryColor3fEXT');
    private z_SecondaryColor3fEXT_1 := GetProcOrNil&<procedure(red: single; green: single; blue: single)>(z_SecondaryColor3fEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3fEXT(red: single; green: single; blue: single) :=
    z_SecondaryColor3fEXT_1(red, green, blue);
    
    private z_SecondaryColor3fvEXT_adr := GetProcAddress('glSecondaryColor3fvEXT');
    private z_SecondaryColor3fvEXT_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_SecondaryColor3fvEXT_adr);
    private z_SecondaryColor3fvEXT_2 := GetProcOrNil&<procedure(var v: single)>(z_SecondaryColor3fvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3fvEXT(v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_SecondaryColor3fvEXT_2(v[0]) else
        z_SecondaryColor3fvEXT_2(Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3fvEXT(var v: single) :=
    z_SecondaryColor3fvEXT_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3fvEXT(v: IntPtr) :=
    z_SecondaryColor3fvEXT_1(v);
    
    private z_SecondaryColor3iEXT_adr := GetProcAddress('glSecondaryColor3iEXT');
    private z_SecondaryColor3iEXT_1 := GetProcOrNil&<procedure(red: Int32; green: Int32; blue: Int32)>(z_SecondaryColor3iEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3iEXT(red: Int32; green: Int32; blue: Int32) :=
    z_SecondaryColor3iEXT_1(red, green, blue);
    
    private z_SecondaryColor3ivEXT_adr := GetProcAddress('glSecondaryColor3ivEXT');
    private z_SecondaryColor3ivEXT_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_SecondaryColor3ivEXT_adr);
    private z_SecondaryColor3ivEXT_2 := GetProcOrNil&<procedure(var v: Int32)>(z_SecondaryColor3ivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ivEXT(v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_SecondaryColor3ivEXT_2(v[0]) else
        z_SecondaryColor3ivEXT_2(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ivEXT(var v: Int32) :=
    z_SecondaryColor3ivEXT_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ivEXT(v: IntPtr) :=
    z_SecondaryColor3ivEXT_1(v);
    
    private z_SecondaryColor3sEXT_adr := GetProcAddress('glSecondaryColor3sEXT');
    private z_SecondaryColor3sEXT_1 := GetProcOrNil&<procedure(red: Int16; green: Int16; blue: Int16)>(z_SecondaryColor3sEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3sEXT(red: Int16; green: Int16; blue: Int16) :=
    z_SecondaryColor3sEXT_1(red, green, blue);
    
    private z_SecondaryColor3svEXT_adr := GetProcAddress('glSecondaryColor3svEXT');
    private z_SecondaryColor3svEXT_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_SecondaryColor3svEXT_adr);
    private z_SecondaryColor3svEXT_2 := GetProcOrNil&<procedure(var v: Int16)>(z_SecondaryColor3svEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3svEXT(v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_SecondaryColor3svEXT_2(v[0]) else
        z_SecondaryColor3svEXT_2(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3svEXT(var v: Int16) :=
    z_SecondaryColor3svEXT_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3svEXT(v: IntPtr) :=
    z_SecondaryColor3svEXT_1(v);
    
    private z_SecondaryColor3ubEXT_adr := GetProcAddress('glSecondaryColor3ubEXT');
    private z_SecondaryColor3ubEXT_1 := GetProcOrNil&<procedure(red: Byte; green: Byte; blue: Byte)>(z_SecondaryColor3ubEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ubEXT(red: Byte; green: Byte; blue: Byte) :=
    z_SecondaryColor3ubEXT_1(red, green, blue);
    
    private z_SecondaryColor3ubvEXT_adr := GetProcAddress('glSecondaryColor3ubvEXT');
    private z_SecondaryColor3ubvEXT_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_SecondaryColor3ubvEXT_adr);
    private z_SecondaryColor3ubvEXT_2 := GetProcOrNil&<procedure(var v: Byte)>(z_SecondaryColor3ubvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ubvEXT(v: array of Byte);
    type PByte=^Byte;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_SecondaryColor3ubvEXT_2(v[0]) else
        z_SecondaryColor3ubvEXT_2(PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ubvEXT(var v: Byte) :=
    z_SecondaryColor3ubvEXT_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ubvEXT(v: IntPtr) :=
    z_SecondaryColor3ubvEXT_1(v);
    
    private z_SecondaryColor3uiEXT_adr := GetProcAddress('glSecondaryColor3uiEXT');
    private z_SecondaryColor3uiEXT_1 := GetProcOrNil&<procedure(red: UInt32; green: UInt32; blue: UInt32)>(z_SecondaryColor3uiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3uiEXT(red: UInt32; green: UInt32; blue: UInt32) :=
    z_SecondaryColor3uiEXT_1(red, green, blue);
    
    private z_SecondaryColor3uivEXT_adr := GetProcAddress('glSecondaryColor3uivEXT');
    private z_SecondaryColor3uivEXT_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_SecondaryColor3uivEXT_adr);
    private z_SecondaryColor3uivEXT_2 := GetProcOrNil&<procedure(var v: UInt32)>(z_SecondaryColor3uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3uivEXT(v: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_SecondaryColor3uivEXT_2(v[0]) else
        z_SecondaryColor3uivEXT_2(PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3uivEXT(var v: UInt32) :=
    z_SecondaryColor3uivEXT_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3uivEXT(v: IntPtr) :=
    z_SecondaryColor3uivEXT_1(v);
    
    private z_SecondaryColor3usEXT_adr := GetProcAddress('glSecondaryColor3usEXT');
    private z_SecondaryColor3usEXT_1 := GetProcOrNil&<procedure(red: UInt16; green: UInt16; blue: UInt16)>(z_SecondaryColor3usEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3usEXT(red: UInt16; green: UInt16; blue: UInt16) :=
    z_SecondaryColor3usEXT_1(red, green, blue);
    
    private z_SecondaryColor3usvEXT_adr := GetProcAddress('glSecondaryColor3usvEXT');
    private z_SecondaryColor3usvEXT_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_SecondaryColor3usvEXT_adr);
    private z_SecondaryColor3usvEXT_2 := GetProcOrNil&<procedure(var v: UInt16)>(z_SecondaryColor3usvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3usvEXT(v: array of UInt16);
    type PUInt16=^UInt16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_SecondaryColor3usvEXT_2(v[0]) else
        z_SecondaryColor3usvEXT_2(PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3usvEXT(var v: UInt16) :=
    z_SecondaryColor3usvEXT_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3usvEXT(v: IntPtr) :=
    z_SecondaryColor3usvEXT_1(v);
    
    private z_SecondaryColorPointerEXT_adr := GetProcAddress('glSecondaryColorPointerEXT');
    private z_SecondaryColorPointerEXT_1 := GetProcOrNil&<procedure(size: Int32; &type: ColorPointerType; stride: Int32; pointer: IntPtr)>(z_SecondaryColorPointerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorPointerEXT(size: Int32; &type: ColorPointerType; stride: Int32; pointer: IntPtr) :=
    z_SecondaryColorPointerEXT_1(size, &type, stride, pointer);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glSeparateShaderObjectsEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_separate_shader_objects';
    
    private z_UseShaderProgramEXT_adr := GetProcAddress('glUseShaderProgramEXT');
    private z_UseShaderProgramEXT_1 := GetProcOrNil&<procedure(&type: DummyEnum; &program: gl_program)>(z_UseShaderProgramEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseShaderProgramEXT(&type: DummyEnum; &program: gl_program) :=
    z_UseShaderProgramEXT_1(&type, &program);
    
    private z_ActiveProgramEXT_adr := GetProcAddress('glActiveProgramEXT');
    private z_ActiveProgramEXT_1 := GetProcOrNil&<procedure(&program: gl_program)>(z_ActiveProgramEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ActiveProgramEXT(&program: gl_program) :=
    z_ActiveProgramEXT_1(&program);
    
    private z_CreateShaderProgramEXT_adr := GetProcAddress('glCreateShaderProgramEXT');
    private z_CreateShaderProgramEXT_1 := GetProcOrNil&<function(&type: ShaderType; _string: IntPtr): gl_program>(z_CreateShaderProgramEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateShaderProgramEXT(&type: ShaderType; _string: string): gl_program;
    begin
      var _string_str_ptr: IntPtr;
      try
        _string_str_ptr := Marshal.StringToHGlobalAnsi(_string);
        Result := z_CreateShaderProgramEXT_1(&type, _string_str_ptr);
      finally
        Marshal.FreeHGlobal(_string_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateShaderProgramEXT(&type: ShaderType; _string: IntPtr): gl_program :=
    z_CreateShaderProgramEXT_1(&type, _string);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glShaderFramebufferFetchNonCoherentEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_shader_framebuffer_fetch_non_coherent';
    
    private z_FramebufferFetchBarrierEXT_adr := GetProcAddress('glFramebufferFetchBarrierEXT');
    private z_FramebufferFetchBarrierEXT_1 := GetProcOrNil&<procedure>(z_FramebufferFetchBarrierEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferFetchBarrierEXT :=
    z_FramebufferFetchBarrierEXT_1();
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glShaderImageLoadStoreEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_shader_image_load_store';
    
    private z_BindImageTextureEXT_adr := GetProcAddress('glBindImageTextureEXT');
    private z_BindImageTextureEXT_1 := GetProcOrNil&<procedure(index: UInt32; texture: gl_texture; level: Int32; layered: boolean; layer: Int32; access: BufferAccess; format: Int32)>(z_BindImageTextureEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindImageTextureEXT(index: UInt32; texture: gl_texture; level: Int32; layered: boolean; layer: Int32; access: BufferAccess; format: Int32) :=
    z_BindImageTextureEXT_1(index, texture, level, layered, layer, access, format);
    
    private z_MemoryBarrierEXT_adr := GetProcAddress('glMemoryBarrierEXT');
    private z_MemoryBarrierEXT_1 := GetProcOrNil&<procedure(barriers: MemoryBarrierMask)>(z_MemoryBarrierEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MemoryBarrierEXT(barriers: MemoryBarrierMask) :=
    z_MemoryBarrierEXT_1(barriers);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glStencilClearTagEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_stencil_clear_tag';
    
    private z_StencilClearTagEXT_adr := GetProcAddress('glStencilClearTagEXT');
    private z_StencilClearTagEXT_1 := GetProcOrNil&<procedure(stencilTagBits: Int32; stencilClearTag: UInt32)>(z_StencilClearTagEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilClearTagEXT(stencilTagBits: Int32; stencilClearTag: UInt32) :=
    z_StencilClearTagEXT_1(stencilTagBits, stencilClearTag);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glStencilTwoSideEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_stencil_two_side';
    
    private z_ActiveStencilFaceEXT_adr := GetProcAddress('glActiveStencilFaceEXT');
    private z_ActiveStencilFaceEXT_1 := GetProcOrNil&<procedure(face: MaterialFace)>(z_ActiveStencilFaceEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ActiveStencilFaceEXT(face: MaterialFace) :=
    z_ActiveStencilFaceEXT_1(face);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glSubtextureEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_subtexture';
    
    private z_TexSubImage1DEXT_adr := GetProcAddress('glTexSubImage1DEXT');
    private z_TexSubImage1DEXT_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; xoffset: Int32; width: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr)>(z_TexSubImage1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexSubImage1DEXT(target: TextureTarget; level: Int32; xoffset: Int32; width: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr) :=
    z_TexSubImage1DEXT_1(target, level, xoffset, width, format, &type, pixels);
    
    private z_TexSubImage2DEXT_adr := GetProcAddress('glTexSubImage2DEXT');
    private z_TexSubImage2DEXT_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr)>(z_TexSubImage2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexSubImage2DEXT(target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr) :=
    z_TexSubImage2DEXT_1(target, level, xoffset, yoffset, width, height, format, &type, pixels);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glTexture3DEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_texture3d';
    
    private z_TexImage3DEXT_adr := GetProcAddress('glTexImage3DEXT');
    private z_TexImage3DEXT_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; depth: Int32; border: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr)>(z_TexImage3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage3DEXT(target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; depth: Int32; border: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr) :=
    z_TexImage3DEXT_1(target, level, _internalformat, width, height, depth, border, format, &type, pixels);
    
    private z_TexSubImage3DEXT_adr := GetProcAddress('glTexSubImage3DEXT');
    private z_TexSubImage3DEXT_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr)>(z_TexSubImage3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexSubImage3DEXT(target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr) :=
    z_TexSubImage3DEXT_1(target, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, pixels);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glTextureArrayEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_texture_array';
    
    private z_FramebufferTextureLayerEXT_adr := GetProcAddress('glFramebufferTextureLayerEXT');
    private z_FramebufferTextureLayerEXT_1 := GetProcOrNil&<procedure(target: FramebufferTarget; attachment: FramebufferAttachment; texture: gl_texture; level: Int32; layer: Int32)>(z_FramebufferTextureLayerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTextureLayerEXT(target: FramebufferTarget; attachment: FramebufferAttachment; texture: gl_texture; level: Int32; layer: Int32) :=
    z_FramebufferTextureLayerEXT_1(target, attachment, texture, level, layer);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glTextureBufferObjectEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_texture_buffer_object';
    
    private z_TexBufferEXT_adr := GetProcAddress('glTexBufferEXT');
    private z_TexBufferEXT_1 := GetProcOrNil&<procedure(target: TextureTarget; internalformat: SizedInternalFormat; buffer: gl_buffer)>(z_TexBufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBufferEXT(target: TextureTarget; internalformat: SizedInternalFormat; buffer: gl_buffer) :=
    z_TexBufferEXT_1(target, internalformat, buffer);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glTextureIntegerEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_texture_integer';
    
    private z_TexParameterIivEXT_adr := GetProcAddress('glTexParameterIivEXT');
    private z_TexParameterIivEXT_1 := GetProcOrNil&<procedure(target: TextureTarget; pname: TextureParameterName; &params: IntPtr)>(z_TexParameterIivEXT_adr);
    private z_TexParameterIivEXT_2 := GetProcOrNil&<procedure(target: TextureTarget; pname: TextureParameterName; var &params: Int32)>(z_TexParameterIivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIivEXT(target: TextureTarget; pname: TextureParameterName; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_TexParameterIivEXT_2(target, pname, &params[0]) else
        z_TexParameterIivEXT_2(target, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIivEXT(target: TextureTarget; pname: TextureParameterName; var &params: Int32) :=
    z_TexParameterIivEXT_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIivEXT(target: TextureTarget; pname: TextureParameterName; &params: IntPtr) :=
    z_TexParameterIivEXT_1(target, pname, &params);
    
    private z_TexParameterIuivEXT_adr := GetProcAddress('glTexParameterIuivEXT');
    private z_TexParameterIuivEXT_1 := GetProcOrNil&<procedure(target: TextureTarget; pname: TextureParameterName; &params: IntPtr)>(z_TexParameterIuivEXT_adr);
    private z_TexParameterIuivEXT_2 := GetProcOrNil&<procedure(target: TextureTarget; pname: TextureParameterName; var &params: UInt32)>(z_TexParameterIuivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIuivEXT(target: TextureTarget; pname: TextureParameterName; &params: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_TexParameterIuivEXT_2(target, pname, &params[0]) else
        z_TexParameterIuivEXT_2(target, pname, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIuivEXT(target: TextureTarget; pname: TextureParameterName; var &params: UInt32) :=
    z_TexParameterIuivEXT_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIuivEXT(target: TextureTarget; pname: TextureParameterName; &params: IntPtr) :=
    z_TexParameterIuivEXT_1(target, pname, &params);
    
    private z_GetTexParameterIivEXT_adr := GetProcAddress('glGetTexParameterIivEXT');
    private z_GetTexParameterIivEXT_1 := GetProcOrNil&<procedure(target: TextureTarget; pname: GetTextureParameter; &params: IntPtr)>(z_GetTexParameterIivEXT_adr);
    private z_GetTexParameterIivEXT_2 := GetProcOrNil&<procedure(target: TextureTarget; pname: GetTextureParameter; var &params: Int32)>(z_GetTexParameterIivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIivEXT(target: TextureTarget; pname: GetTextureParameter; var &params: Int32) :=
    z_GetTexParameterIivEXT_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIivEXT(target: TextureTarget; pname: GetTextureParameter; &params: IntPtr) :=
    z_GetTexParameterIivEXT_1(target, pname, &params);
    
    private z_GetTexParameterIuivEXT_adr := GetProcAddress('glGetTexParameterIuivEXT');
    private z_GetTexParameterIuivEXT_1 := GetProcOrNil&<procedure(target: TextureTarget; pname: GetTextureParameter; &params: IntPtr)>(z_GetTexParameterIuivEXT_adr);
    private z_GetTexParameterIuivEXT_2 := GetProcOrNil&<procedure(target: TextureTarget; pname: GetTextureParameter; var &params: UInt32)>(z_GetTexParameterIuivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIuivEXT(target: TextureTarget; pname: GetTextureParameter; var &params: UInt32) :=
    z_GetTexParameterIuivEXT_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIuivEXT(target: TextureTarget; pname: GetTextureParameter; &params: IntPtr) :=
    z_GetTexParameterIuivEXT_1(target, pname, &params);
    
    private z_ClearColorIiEXT_adr := GetProcAddress('glClearColorIiEXT');
    private z_ClearColorIiEXT_1 := GetProcOrNil&<procedure(red: Int32; green: Int32; blue: Int32; alpha: Int32)>(z_ClearColorIiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearColorIiEXT(red: Int32; green: Int32; blue: Int32; alpha: Int32) :=
    z_ClearColorIiEXT_1(red, green, blue, alpha);
    
    private z_ClearColorIuiEXT_adr := GetProcAddress('glClearColorIuiEXT');
    private z_ClearColorIuiEXT_1 := GetProcOrNil&<procedure(red: UInt32; green: UInt32; blue: UInt32; alpha: UInt32)>(z_ClearColorIuiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearColorIuiEXT(red: UInt32; green: UInt32; blue: UInt32; alpha: UInt32) :=
    z_ClearColorIuiEXT_1(red, green, blue, alpha);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glTextureObjectEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_texture_object';
    
    private z_AreTexturesResidentEXT_adr := GetProcAddress('glAreTexturesResidentEXT');
    private z_AreTexturesResidentEXT_1 := GetProcOrNil&<function(n: Int32; textures: IntPtr; residences: IntPtr): boolean>(z_AreTexturesResidentEXT_adr);
    private z_AreTexturesResidentEXT_2 := GetProcOrNil&<function(n: Int32; textures: IntPtr; var residences: boolean): boolean>(z_AreTexturesResidentEXT_adr);
    private z_AreTexturesResidentEXT_3 := GetProcOrNil&<function(n: Int32; var textures: gl_texture; residences: IntPtr): boolean>(z_AreTexturesResidentEXT_adr);
    private z_AreTexturesResidentEXT_4 := GetProcOrNil&<function(n: Int32; var textures: gl_texture; var residences: boolean): boolean>(z_AreTexturesResidentEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResidentEXT(n: Int32; textures: array of gl_texture; var residences: boolean): boolean;
    type Pgl_texture=^gl_texture;
    begin
      Result := if (textures<>nil) and (textures.Length<>0) then
        z_AreTexturesResidentEXT_4(n, textures[0], residences) else
        z_AreTexturesResidentEXT_4(n, Pgl_texture(nil)^, residences);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResidentEXT(n: Int32; textures: array of gl_texture; residences: IntPtr): boolean;
    type Pgl_texture=^gl_texture;
    begin
      Result := if (textures<>nil) and (textures.Length<>0) then
        z_AreTexturesResidentEXT_3(n, textures[0], residences) else
        z_AreTexturesResidentEXT_3(n, Pgl_texture(nil)^, residences);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResidentEXT(n: Int32; var textures: gl_texture; var residences: boolean): boolean :=
    z_AreTexturesResidentEXT_4(n, textures, residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResidentEXT(n: Int32; var textures: gl_texture; residences: IntPtr): boolean :=
    z_AreTexturesResidentEXT_3(n, textures, residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResidentEXT(n: Int32; textures: IntPtr; var residences: boolean): boolean :=
    z_AreTexturesResidentEXT_2(n, textures, residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResidentEXT(n: Int32; textures: IntPtr; residences: IntPtr): boolean :=
    z_AreTexturesResidentEXT_1(n, textures, residences);
    
    private z_BindTextureEXT_adr := GetProcAddress('glBindTextureEXT');
    private z_BindTextureEXT_1 := GetProcOrNil&<procedure(target: TextureTarget; texture: gl_texture)>(z_BindTextureEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTextureEXT(target: TextureTarget; texture: gl_texture) :=
    z_BindTextureEXT_1(target, texture);
    
    private z_DeleteTexturesEXT_adr := GetProcAddress('glDeleteTexturesEXT');
    private z_DeleteTexturesEXT_1 := GetProcOrNil&<procedure(n: Int32; textures: IntPtr)>(z_DeleteTexturesEXT_adr);
    private z_DeleteTexturesEXT_2 := GetProcOrNil&<procedure(n: Int32; var textures: gl_texture)>(z_DeleteTexturesEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTexturesEXT(n: Int32; textures: array of gl_texture);
    type Pgl_texture=^gl_texture;
    begin
      if (textures<>nil) and (textures.Length<>0) then
        z_DeleteTexturesEXT_2(n, textures[0]) else
        z_DeleteTexturesEXT_2(n, Pgl_texture(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTexturesEXT(n: Int32; var textures: gl_texture) :=
    z_DeleteTexturesEXT_2(n, textures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTexturesEXT(n: Int32; textures: IntPtr) :=
    z_DeleteTexturesEXT_1(n, textures);
    
    private z_GenTexturesEXT_adr := GetProcAddress('glGenTexturesEXT');
    private z_GenTexturesEXT_1 := GetProcOrNil&<procedure(n: Int32; textures: IntPtr)>(z_GenTexturesEXT_adr);
    private z_GenTexturesEXT_2 := GetProcOrNil&<procedure(n: Int32; var textures: gl_texture)>(z_GenTexturesEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTexturesEXT(n: Int32; textures: array of gl_texture);
    type Pgl_texture=^gl_texture;
    begin
      if (textures<>nil) and (textures.Length<>0) then
        z_GenTexturesEXT_2(n, textures[0]) else
        z_GenTexturesEXT_2(n, Pgl_texture(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTexturesEXT(n: Int32; var textures: gl_texture) :=
    z_GenTexturesEXT_2(n, textures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTexturesEXT(n: Int32; textures: IntPtr) :=
    z_GenTexturesEXT_1(n, textures);
    
    private z_IsTextureEXT_adr := GetProcAddress('glIsTextureEXT');
    private z_IsTextureEXT_1 := GetProcOrNil&<function(texture: gl_texture): boolean>(z_IsTextureEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsTextureEXT(texture: gl_texture): boolean :=
    z_IsTextureEXT_1(texture);
    
    private z_PrioritizeTexturesEXT_adr := GetProcAddress('glPrioritizeTexturesEXT');
    private z_PrioritizeTexturesEXT_1 := GetProcOrNil&<procedure(n: Int32; textures: IntPtr; priorities: IntPtr)>(z_PrioritizeTexturesEXT_adr);
    private z_PrioritizeTexturesEXT_2 := GetProcOrNil&<procedure(n: Int32; textures: IntPtr; var priorities: single)>(z_PrioritizeTexturesEXT_adr);
    private z_PrioritizeTexturesEXT_3 := GetProcOrNil&<procedure(n: Int32; var textures: gl_texture; priorities: IntPtr)>(z_PrioritizeTexturesEXT_adr);
    private z_PrioritizeTexturesEXT_4 := GetProcOrNil&<procedure(n: Int32; var textures: gl_texture; var priorities: single)>(z_PrioritizeTexturesEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesEXT(n: Int32; textures: array of gl_texture; priorities: array of single);
    type Pgl_texture=^gl_texture;
    type Psingle=^single;
    begin
      if (priorities<>nil) and (priorities.Length<>0) then
        if (textures<>nil) and (textures.Length<>0) then
          z_PrioritizeTexturesEXT_4(n, textures[0], priorities[0]) else
          z_PrioritizeTexturesEXT_4(n, Pgl_texture(nil)^, priorities[0]) else
        if (textures<>nil) and (textures.Length<>0) then
          z_PrioritizeTexturesEXT_4(n, textures[0], Psingle(nil)^) else
          z_PrioritizeTexturesEXT_4(n, Pgl_texture(nil)^, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesEXT(n: Int32; var textures: gl_texture; var priorities: single) :=
    z_PrioritizeTexturesEXT_4(n, textures, priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesEXT(n: Int32; var textures: gl_texture; priorities: IntPtr) :=
    z_PrioritizeTexturesEXT_3(n, textures, priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesEXT(n: Int32; textures: IntPtr; var priorities: single) :=
    z_PrioritizeTexturesEXT_2(n, textures, priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesEXT(n: Int32; textures: IntPtr; priorities: IntPtr) :=
    z_PrioritizeTexturesEXT_1(n, textures, priorities);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glTexturePerturbNormalEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_texture_perturb_normal';
    
    private z_TextureNormalEXT_adr := GetProcAddress('glTextureNormalEXT');
    private z_TextureNormalEXT_1 := GetProcOrNil&<procedure(mode: TextureNormalMode)>(z_TextureNormalEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureNormalEXT(mode: TextureNormalMode) :=
    z_TextureNormalEXT_1(mode);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glTextureStorageEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_texture_storage';
    
    private z_TexStorage1DEXT_adr := GetProcAddress('glTexStorage1DEXT');
    private z_TexStorage1DEXT_1 := GetProcOrNil&<procedure(target: TextureTarget; levels: Int32; internalformat: SizedInternalFormat; width: Int32)>(z_TexStorage1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorage1DEXT(target: TextureTarget; levels: Int32; internalformat: SizedInternalFormat; width: Int32) :=
    z_TexStorage1DEXT_1(target, levels, internalformat, width);
    
    private z_TexStorage2DEXT_adr := GetProcAddress('glTexStorage2DEXT');
    private z_TexStorage2DEXT_1 := GetProcOrNil&<procedure(target: TextureTarget; levels: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32)>(z_TexStorage2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorage2DEXT(target: TextureTarget; levels: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32) :=
    z_TexStorage2DEXT_1(target, levels, internalformat, width, height);
    
    private z_TexStorage3DEXT_adr := GetProcAddress('glTexStorage3DEXT');
    private z_TexStorage3DEXT_1 := GetProcOrNil&<procedure(target: TextureTarget; levels: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32; depth: Int32)>(z_TexStorage3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorage3DEXT(target: TextureTarget; levels: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32; depth: Int32) :=
    z_TexStorage3DEXT_1(target, levels, internalformat, width, height, depth);
    
    private z_TextureStorage1DEXT_adr := GetProcAddress('glTextureStorage1DEXT');
    private z_TextureStorage1DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: DummyEnum; levels: Int32; internalformat: SizedInternalFormat; width: Int32)>(z_TextureStorage1DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage1DEXT(texture: gl_texture; target: DummyEnum; levels: Int32; internalformat: SizedInternalFormat; width: Int32) :=
    z_TextureStorage1DEXT_1(texture, target, levels, internalformat, width);
    
    private z_TextureStorage2DEXT_adr := GetProcAddress('glTextureStorage2DEXT');
    private z_TextureStorage2DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: DummyEnum; levels: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32)>(z_TextureStorage2DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage2DEXT(texture: gl_texture; target: DummyEnum; levels: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32) :=
    z_TextureStorage2DEXT_1(texture, target, levels, internalformat, width, height);
    
    private z_TextureStorage3DEXT_adr := GetProcAddress('glTextureStorage3DEXT');
    private z_TextureStorage3DEXT_1 := GetProcOrNil&<procedure(texture: gl_texture; target: DummyEnum; levels: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32; depth: Int32)>(z_TextureStorage3DEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage3DEXT(texture: gl_texture; target: DummyEnum; levels: Int32; internalformat: SizedInternalFormat; width: Int32; height: Int32; depth: Int32) :=
    z_TextureStorage3DEXT_1(texture, target, levels, internalformat, width, height, depth);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glTimelineSemaphoreNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_timeline_semaphore';
    
    private z_CreateSemaphoresNV_adr := GetProcAddress('glCreateSemaphoresNV');
    private z_CreateSemaphoresNV_1 := GetProcOrNil&<procedure(n: Int32; semaphores: IntPtr)>(z_CreateSemaphoresNV_adr);
    private z_CreateSemaphoresNV_2 := GetProcOrNil&<procedure(n: Int32; var semaphores: UInt32)>(z_CreateSemaphoresNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateSemaphoresNV(n: Int32; semaphores: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (semaphores<>nil) and (semaphores.Length<>0) then
        z_CreateSemaphoresNV_2(n, semaphores[0]) else
        z_CreateSemaphoresNV_2(n, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateSemaphoresNV(n: Int32; var semaphores: UInt32) :=
    z_CreateSemaphoresNV_2(n, semaphores);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateSemaphoresNV(n: Int32; semaphores: IntPtr) :=
    z_CreateSemaphoresNV_1(n, semaphores);
    
    private z_SemaphoreParameterivNV_adr := GetProcAddress('glSemaphoreParameterivNV');
    private z_SemaphoreParameterivNV_1 := GetProcOrNil&<procedure(semaphore: UInt32; pname: SemaphoreParameterName; &params: IntPtr)>(z_SemaphoreParameterivNV_adr);
    private z_SemaphoreParameterivNV_2 := GetProcOrNil&<procedure(semaphore: UInt32; pname: SemaphoreParameterName; var &params: Int32)>(z_SemaphoreParameterivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SemaphoreParameterivNV(semaphore: UInt32; pname: SemaphoreParameterName; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_SemaphoreParameterivNV_2(semaphore, pname, &params[0]) else
        z_SemaphoreParameterivNV_2(semaphore, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SemaphoreParameterivNV(semaphore: UInt32; pname: SemaphoreParameterName; var &params: Int32) :=
    z_SemaphoreParameterivNV_2(semaphore, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SemaphoreParameterivNV(semaphore: UInt32; pname: SemaphoreParameterName; &params: IntPtr) :=
    z_SemaphoreParameterivNV_1(semaphore, pname, &params);
    
    private z_GetSemaphoreParameterivNV_adr := GetProcAddress('glGetSemaphoreParameterivNV');
    private z_GetSemaphoreParameterivNV_1 := GetProcOrNil&<procedure(semaphore: UInt32; pname: SemaphoreParameterName; &params: IntPtr)>(z_GetSemaphoreParameterivNV_adr);
    private z_GetSemaphoreParameterivNV_2 := GetProcOrNil&<procedure(semaphore: UInt32; pname: SemaphoreParameterName; var &params: Int32)>(z_GetSemaphoreParameterivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSemaphoreParameterivNV(semaphore: UInt32; pname: SemaphoreParameterName; var &params: Int32) :=
    z_GetSemaphoreParameterivNV_2(semaphore, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSemaphoreParameterivNV(semaphore: UInt32; pname: SemaphoreParameterName; &params: IntPtr) :=
    z_GetSemaphoreParameterivNV_1(semaphore, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glTimerQueryEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_timer_query';
    
    private z_GetQueryObjecti64vEXT_adr := GetProcAddress('glGetQueryObjecti64vEXT');
    private z_GetQueryObjecti64vEXT_1 := GetProcOrNil&<procedure(id: gl_query; pname: QueryObjectParameterName; &params: IntPtr)>(z_GetQueryObjecti64vEXT_adr);
    private z_GetQueryObjecti64vEXT_2 := GetProcOrNil&<procedure(id: gl_query; pname: QueryObjectParameterName; var &params: Int64)>(z_GetQueryObjecti64vEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjecti64vEXT(id: gl_query; pname: QueryObjectParameterName; var &params: Int64) :=
    z_GetQueryObjecti64vEXT_2(id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjecti64vEXT(id: gl_query; pname: QueryObjectParameterName; &params: IntPtr) :=
    z_GetQueryObjecti64vEXT_1(id, pname, &params);
    
    private z_GetQueryObjectui64vEXT_adr := GetProcAddress('glGetQueryObjectui64vEXT');
    private z_GetQueryObjectui64vEXT_1 := GetProcOrNil&<procedure(id: gl_query; pname: QueryObjectParameterName; &params: IntPtr)>(z_GetQueryObjectui64vEXT_adr);
    private z_GetQueryObjectui64vEXT_2 := GetProcOrNil&<procedure(id: gl_query; pname: QueryObjectParameterName; var &params: UInt64)>(z_GetQueryObjectui64vEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectui64vEXT(id: gl_query; pname: QueryObjectParameterName; var &params: UInt64) :=
    z_GetQueryObjectui64vEXT_2(id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectui64vEXT(id: gl_query; pname: QueryObjectParameterName; &params: IntPtr) :=
    z_GetQueryObjectui64vEXT_1(id, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glTransformFeedbackEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_transform_feedback';
    
    private z_BeginTransformFeedbackEXT_adr := GetProcAddress('glBeginTransformFeedbackEXT');
    private z_BeginTransformFeedbackEXT_1 := GetProcOrNil&<procedure(primitiveMode: PrimitiveType)>(z_BeginTransformFeedbackEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginTransformFeedbackEXT(primitiveMode: PrimitiveType) :=
    z_BeginTransformFeedbackEXT_1(primitiveMode);
    
    private z_EndTransformFeedbackEXT_adr := GetProcAddress('glEndTransformFeedbackEXT');
    private z_EndTransformFeedbackEXT_1 := GetProcOrNil&<procedure>(z_EndTransformFeedbackEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndTransformFeedbackEXT :=
    z_EndTransformFeedbackEXT_1();
    
    private z_BindBufferRangeEXT_adr := GetProcAddress('glBindBufferRangeEXT');
    private z_BindBufferRangeEXT_1 := GetProcOrNil&<procedure(target: BufferTarget; index: UInt32; buffer: gl_buffer; offset: IntPtr; size: UIntPtr)>(z_BindBufferRangeEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBufferRangeEXT(target: BufferTarget; index: UInt32; buffer: gl_buffer; offset: IntPtr; size: UIntPtr) :=
    z_BindBufferRangeEXT_1(target, index, buffer, offset, size);
    
    private z_BindBufferOffsetEXT_adr := GetProcAddress('glBindBufferOffsetEXT');
    private z_BindBufferOffsetEXT_1 := GetProcOrNil&<procedure(target: BufferTarget; index: UInt32; buffer: gl_buffer; offset: IntPtr)>(z_BindBufferOffsetEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBufferOffsetEXT(target: BufferTarget; index: UInt32; buffer: gl_buffer; offset: IntPtr) :=
    z_BindBufferOffsetEXT_1(target, index, buffer, offset);
    
    private z_BindBufferBaseEXT_adr := GetProcAddress('glBindBufferBaseEXT');
    private z_BindBufferBaseEXT_1 := GetProcOrNil&<procedure(target: BufferTarget; index: UInt32; buffer: gl_buffer)>(z_BindBufferBaseEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBufferBaseEXT(target: BufferTarget; index: UInt32; buffer: gl_buffer) :=
    z_BindBufferBaseEXT_1(target, index, buffer);
    
    private z_TransformFeedbackVaryingsEXT_adr := GetProcAddress('glTransformFeedbackVaryingsEXT');
    private z_TransformFeedbackVaryingsEXT_1 := GetProcOrNil&<procedure(&program: gl_program; count: Int32; varyings: pointer; bufferMode: TransformFeedbackBufferMode)>(z_TransformFeedbackVaryingsEXT_adr);
    private z_TransformFeedbackVaryingsEXT_2 := GetProcOrNil&<procedure(&program: gl_program; count: Int32; var varyings: IntPtr; bufferMode: TransformFeedbackBufferMode)>(z_TransformFeedbackVaryingsEXT_adr);
    private [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure temp_TransformFeedbackVaryingsEXT_1(&program: gl_program; count: Int32; varyings: array of IntPtr; bufferMode: TransformFeedbackBufferMode);
    type PIntPtr=^IntPtr;
    begin
      if (varyings<>nil) and (varyings.Length<>0) then
        z_TransformFeedbackVaryingsEXT_2(&program, count, varyings[0], bufferMode) else
        z_TransformFeedbackVaryingsEXT_2(&program, count, PIntPtr(nil)^, bufferMode);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackVaryingsEXT(&program: gl_program; count: Int32; varyings: array of string; bufferMode: TransformFeedbackBufferMode);
    begin
      var varyings_str_ptrs: array of IntPtr;
      try
        varyings_str_ptrs := varyings?.ConvertAll(arr_el1->
          Marshal.StringToHGlobalAnsi(arr_el1)
        );
        temp_TransformFeedbackVaryingsEXT_1(&program, count, varyings_str_ptrs, bufferMode);
      finally
        if varyings_str_ptrs<>nil then foreach var arr_el1 in varyings_str_ptrs do
          Marshal.FreeHGlobal(arr_el1);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackVaryingsEXT(&program: gl_program; count: Int32; var varyings: IntPtr; bufferMode: TransformFeedbackBufferMode) :=
    z_TransformFeedbackVaryingsEXT_2(&program, count, varyings, bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackVaryingsEXT(&program: gl_program; count: Int32; varyings: pointer; bufferMode: TransformFeedbackBufferMode) :=
    z_TransformFeedbackVaryingsEXT_1(&program, count, varyings, bufferMode);
    
    private z_GetTransformFeedbackVaryingEXT_adr := GetProcAddress('glGetTransformFeedbackVaryingEXT');
    private z_GetTransformFeedbackVaryingEXT_1 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; &type: IntPtr; name: IntPtr)>(z_GetTransformFeedbackVaryingEXT_adr);
    private z_GetTransformFeedbackVaryingEXT_2 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; var &type: AttributeType; name: IntPtr)>(z_GetTransformFeedbackVaryingEXT_adr);
    private z_GetTransformFeedbackVaryingEXT_3 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; &type: IntPtr; name: IntPtr)>(z_GetTransformFeedbackVaryingEXT_adr);
    private z_GetTransformFeedbackVaryingEXT_4 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; var &type: AttributeType; name: IntPtr)>(z_GetTransformFeedbackVaryingEXT_adr);
    private z_GetTransformFeedbackVaryingEXT_5 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; &type: IntPtr; name: IntPtr)>(z_GetTransformFeedbackVaryingEXT_adr);
    private z_GetTransformFeedbackVaryingEXT_6 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; var &type: AttributeType; name: IntPtr)>(z_GetTransformFeedbackVaryingEXT_adr);
    private z_GetTransformFeedbackVaryingEXT_7 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: IntPtr; name: IntPtr)>(z_GetTransformFeedbackVaryingEXT_adr);
    private z_GetTransformFeedbackVaryingEXT_8 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: AttributeType; name: IntPtr)>(z_GetTransformFeedbackVaryingEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: AttributeType; name: IntPtr) :=
    z_GetTransformFeedbackVaryingEXT_8(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: IntPtr; name: IntPtr) :=
    z_GetTransformFeedbackVaryingEXT_7(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; var &type: AttributeType; name: IntPtr) :=
    z_GetTransformFeedbackVaryingEXT_6(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; &type: IntPtr; name: IntPtr) :=
    z_GetTransformFeedbackVaryingEXT_5(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; var &type: AttributeType; name: IntPtr) :=
    z_GetTransformFeedbackVaryingEXT_4(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; &type: IntPtr; name: IntPtr) :=
    z_GetTransformFeedbackVaryingEXT_3(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; var &type: AttributeType; name: IntPtr) :=
    z_GetTransformFeedbackVaryingEXT_2(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; &type: IntPtr; name: IntPtr) :=
    z_GetTransformFeedbackVaryingEXT_1(&program, index, bufSize, length, size, &type, name);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glVertexArrayEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_vertex_array';
    
    private z_ArrayElementEXT_adr := GetProcAddress('glArrayElementEXT');
    private z_ArrayElementEXT_1 := GetProcOrNil&<procedure(i: Int32)>(z_ArrayElementEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ArrayElementEXT(i: Int32) :=
    z_ArrayElementEXT_1(i);
    
    private z_ColorPointerEXT_adr := GetProcAddress('glColorPointerEXT');
    private z_ColorPointerEXT_1 := GetProcOrNil&<procedure(size: Int32; &type: ColorPointerType; stride: Int32; count: Int32; pointer: IntPtr)>(z_ColorPointerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorPointerEXT(size: Int32; &type: ColorPointerType; stride: Int32; count: Int32; pointer: IntPtr) :=
    z_ColorPointerEXT_1(size, &type, stride, count, pointer);
    
    private z_DrawArraysEXT_adr := GetProcAddress('glDrawArraysEXT');
    private z_DrawArraysEXT_1 := GetProcOrNil&<procedure(mode: PrimitiveType; first: Int32; count: Int32)>(z_DrawArraysEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawArraysEXT(mode: PrimitiveType; first: Int32; count: Int32) :=
    z_DrawArraysEXT_1(mode, first, count);
    
    private z_EdgeFlagPointerEXT_adr := GetProcAddress('glEdgeFlagPointerEXT');
    private z_EdgeFlagPointerEXT_1 := GetProcOrNil&<procedure(stride: Int32; count: Int32; pointer: IntPtr)>(z_EdgeFlagPointerEXT_adr);
    private z_EdgeFlagPointerEXT_2 := GetProcOrNil&<procedure(stride: Int32; count: Int32; var pointer: boolean)>(z_EdgeFlagPointerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlagPointerEXT(stride: Int32; count: Int32; var pointer: boolean) :=
    z_EdgeFlagPointerEXT_2(stride, count, pointer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlagPointerEXT(stride: Int32; count: Int32; pointer: IntPtr) :=
    z_EdgeFlagPointerEXT_1(stride, count, pointer);
    
    private z_GetPointervEXT_adr := GetProcAddress('glGetPointervEXT');
    private z_GetPointervEXT_1 := GetProcOrNil&<procedure(pname: GetPointervPName; &params: pointer)>(z_GetPointervEXT_adr);
    private z_GetPointervEXT_2 := GetProcOrNil&<procedure(pname: GetPointervPName; var &params: IntPtr)>(z_GetPointervEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointervEXT(pname: GetPointervPName; var &params: IntPtr) :=
    z_GetPointervEXT_2(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointervEXT(pname: GetPointervPName; &params: pointer) :=
    z_GetPointervEXT_1(pname, &params);
    
    private z_IndexPointerEXT_adr := GetProcAddress('glIndexPointerEXT');
    private z_IndexPointerEXT_1 := GetProcOrNil&<procedure(&type: IndexPointerType; stride: Int32; count: Int32; pointer: IntPtr)>(z_IndexPointerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexPointerEXT(&type: IndexPointerType; stride: Int32; count: Int32; pointer: IntPtr) :=
    z_IndexPointerEXT_1(&type, stride, count, pointer);
    
    private z_NormalPointerEXT_adr := GetProcAddress('glNormalPointerEXT');
    private z_NormalPointerEXT_1 := GetProcOrNil&<procedure(&type: NormalPointerType; stride: Int32; count: Int32; pointer: IntPtr)>(z_NormalPointerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalPointerEXT(&type: NormalPointerType; stride: Int32; count: Int32; pointer: IntPtr) :=
    z_NormalPointerEXT_1(&type, stride, count, pointer);
    
    private z_TexCoordPointerEXT_adr := GetProcAddress('glTexCoordPointerEXT');
    private z_TexCoordPointerEXT_1 := GetProcOrNil&<procedure(size: Int32; &type: TexCoordPointerType; stride: Int32; count: Int32; pointer: IntPtr)>(z_TexCoordPointerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordPointerEXT(size: Int32; &type: TexCoordPointerType; stride: Int32; count: Int32; pointer: IntPtr) :=
    z_TexCoordPointerEXT_1(size, &type, stride, count, pointer);
    
    private z_VertexPointerEXT_adr := GetProcAddress('glVertexPointerEXT');
    private z_VertexPointerEXT_1 := GetProcOrNil&<procedure(size: Int32; &type: VertexPointerType; stride: Int32; count: Int32; pointer: IntPtr)>(z_VertexPointerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexPointerEXT(size: Int32; &type: VertexPointerType; stride: Int32; count: Int32; pointer: IntPtr) :=
    z_VertexPointerEXT_1(size, &type, stride, count, pointer);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glVertexAttrib64bitEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_vertex_attrib_64bit';
    
    private z_VertexAttribL1dEXT_adr := GetProcAddress('glVertexAttribL1dEXT');
    private z_VertexAttribL1dEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: real)>(z_VertexAttribL1dEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1dEXT(index: UInt32; x: real) :=
    z_VertexAttribL1dEXT_1(index, x);
    
    private z_VertexAttribL2dEXT_adr := GetProcAddress('glVertexAttribL2dEXT');
    private z_VertexAttribL2dEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: real; y: real)>(z_VertexAttribL2dEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2dEXT(index: UInt32; x: real; y: real) :=
    z_VertexAttribL2dEXT_1(index, x, y);
    
    private z_VertexAttribL3dEXT_adr := GetProcAddress('glVertexAttribL3dEXT');
    private z_VertexAttribL3dEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: real; y: real; z: real)>(z_VertexAttribL3dEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3dEXT(index: UInt32; x: real; y: real; z: real) :=
    z_VertexAttribL3dEXT_1(index, x, y, z);
    
    private z_VertexAttribL4dEXT_adr := GetProcAddress('glVertexAttribL4dEXT');
    private z_VertexAttribL4dEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: real; y: real; z: real; w: real)>(z_VertexAttribL4dEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4dEXT(index: UInt32; x: real; y: real; z: real; w: real) :=
    z_VertexAttribL4dEXT_1(index, x, y, z, w);
    
    private z_VertexAttribL1dvEXT_adr := GetProcAddress('glVertexAttribL1dvEXT');
    private z_VertexAttribL1dvEXT_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribL1dvEXT_adr);
    private z_VertexAttribL1dvEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: real)>(z_VertexAttribL1dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1dvEXT(index: UInt32; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribL1dvEXT_2(index, v[0]) else
        z_VertexAttribL1dvEXT_2(index, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1dvEXT(index: UInt32; var v: real) :=
    z_VertexAttribL1dvEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1dvEXT(index: UInt32; v: IntPtr) :=
    z_VertexAttribL1dvEXT_1(index, v);
    
    private z_VertexAttribL2dvEXT_adr := GetProcAddress('glVertexAttribL2dvEXT');
    private z_VertexAttribL2dvEXT_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribL2dvEXT_adr);
    private z_VertexAttribL2dvEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: real)>(z_VertexAttribL2dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2dvEXT(index: UInt32; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribL2dvEXT_2(index, v[0]) else
        z_VertexAttribL2dvEXT_2(index, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2dvEXT(index: UInt32; var v: real) :=
    z_VertexAttribL2dvEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2dvEXT(index: UInt32; v: IntPtr) :=
    z_VertexAttribL2dvEXT_1(index, v);
    
    private z_VertexAttribL3dvEXT_adr := GetProcAddress('glVertexAttribL3dvEXT');
    private z_VertexAttribL3dvEXT_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribL3dvEXT_adr);
    private z_VertexAttribL3dvEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: real)>(z_VertexAttribL3dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3dvEXT(index: UInt32; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribL3dvEXT_2(index, v[0]) else
        z_VertexAttribL3dvEXT_2(index, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3dvEXT(index: UInt32; var v: real) :=
    z_VertexAttribL3dvEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3dvEXT(index: UInt32; v: IntPtr) :=
    z_VertexAttribL3dvEXT_1(index, v);
    
    private z_VertexAttribL4dvEXT_adr := GetProcAddress('glVertexAttribL4dvEXT');
    private z_VertexAttribL4dvEXT_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribL4dvEXT_adr);
    private z_VertexAttribL4dvEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: real)>(z_VertexAttribL4dvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4dvEXT(index: UInt32; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribL4dvEXT_2(index, v[0]) else
        z_VertexAttribL4dvEXT_2(index, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4dvEXT(index: UInt32; var v: real) :=
    z_VertexAttribL4dvEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4dvEXT(index: UInt32; v: IntPtr) :=
    z_VertexAttribL4dvEXT_1(index, v);
    
    private z_VertexAttribLPointerEXT_adr := GetProcAddress('glVertexAttribLPointerEXT');
    private z_VertexAttribLPointerEXT_1 := GetProcOrNil&<procedure(index: UInt32; size: Int32; &type: VertexAttribLType; stride: Int32; pointer: IntPtr)>(z_VertexAttribLPointerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribLPointerEXT(index: UInt32; size: Int32; &type: VertexAttribLType; stride: Int32; pointer: IntPtr) :=
    z_VertexAttribLPointerEXT_1(index, size, &type, stride, pointer);
    
    private z_GetVertexAttribLdvEXT_adr := GetProcAddress('glGetVertexAttribLdvEXT');
    private z_GetVertexAttribLdvEXT_1 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribEnum; &params: IntPtr)>(z_GetVertexAttribLdvEXT_adr);
    private z_GetVertexAttribLdvEXT_2 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribEnum; var &params: real)>(z_GetVertexAttribLdvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLdvEXT(index: UInt32; pname: VertexAttribEnum; var &params: real) :=
    z_GetVertexAttribLdvEXT_2(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLdvEXT(index: UInt32; pname: VertexAttribEnum; &params: IntPtr) :=
    z_GetVertexAttribLdvEXT_1(index, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glVertexShaderEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_vertex_shader';
    
    private z_BeginVertexShaderEXT_adr := GetProcAddress('glBeginVertexShaderEXT');
    private z_BeginVertexShaderEXT_1 := GetProcOrNil&<procedure>(z_BeginVertexShaderEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginVertexShaderEXT :=
    z_BeginVertexShaderEXT_1();
    
    private z_EndVertexShaderEXT_adr := GetProcAddress('glEndVertexShaderEXT');
    private z_EndVertexShaderEXT_1 := GetProcOrNil&<procedure>(z_EndVertexShaderEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndVertexShaderEXT :=
    z_EndVertexShaderEXT_1();
    
    private z_BindVertexShaderEXT_adr := GetProcAddress('glBindVertexShaderEXT');
    private z_BindVertexShaderEXT_1 := GetProcOrNil&<procedure(id: UInt32)>(z_BindVertexShaderEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexShaderEXT(id: UInt32) :=
    z_BindVertexShaderEXT_1(id);
    
    private z_GenVertexShadersEXT_adr := GetProcAddress('glGenVertexShadersEXT');
    private z_GenVertexShadersEXT_1 := GetProcOrNil&<function(range: UInt32): UInt32>(z_GenVertexShadersEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenVertexShadersEXT(range: UInt32): UInt32 :=
    z_GenVertexShadersEXT_1(range);
    
    private z_DeleteVertexShaderEXT_adr := GetProcAddress('glDeleteVertexShaderEXT');
    private z_DeleteVertexShaderEXT_1 := GetProcOrNil&<procedure(id: UInt32)>(z_DeleteVertexShaderEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteVertexShaderEXT(id: UInt32) :=
    z_DeleteVertexShaderEXT_1(id);
    
    private z_ShaderOp1EXT_adr := GetProcAddress('glShaderOp1EXT');
    private z_ShaderOp1EXT_1 := GetProcOrNil&<procedure(op: VertexShaderOp; res: UInt32; arg1: UInt32)>(z_ShaderOp1EXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderOp1EXT(op: VertexShaderOp; res: UInt32; arg1: UInt32) :=
    z_ShaderOp1EXT_1(op, res, arg1);
    
    private z_ShaderOp2EXT_adr := GetProcAddress('glShaderOp2EXT');
    private z_ShaderOp2EXT_1 := GetProcOrNil&<procedure(op: VertexShaderOp; res: UInt32; arg1: UInt32; arg2: UInt32)>(z_ShaderOp2EXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderOp2EXT(op: VertexShaderOp; res: UInt32; arg1: UInt32; arg2: UInt32) :=
    z_ShaderOp2EXT_1(op, res, arg1, arg2);
    
    private z_ShaderOp3EXT_adr := GetProcAddress('glShaderOp3EXT');
    private z_ShaderOp3EXT_1 := GetProcOrNil&<procedure(op: VertexShaderOp; res: UInt32; arg1: UInt32; arg2: UInt32; arg3: UInt32)>(z_ShaderOp3EXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderOp3EXT(op: VertexShaderOp; res: UInt32; arg1: UInt32; arg2: UInt32; arg3: UInt32) :=
    z_ShaderOp3EXT_1(op, res, arg1, arg2, arg3);
    
    private z_SwizzleEXT_adr := GetProcAddress('glSwizzleEXT');
    private z_SwizzleEXT_1 := GetProcOrNil&<procedure(res: UInt32; &in: UInt32; outX: VertexShaderCoordOut; outY: VertexShaderCoordOut; outZ: VertexShaderCoordOut; outW: VertexShaderCoordOut)>(z_SwizzleEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SwizzleEXT(res: UInt32; &in: UInt32; outX: VertexShaderCoordOut; outY: VertexShaderCoordOut; outZ: VertexShaderCoordOut; outW: VertexShaderCoordOut) :=
    z_SwizzleEXT_1(res, &in, outX, outY, outZ, outW);
    
    private z_WriteMaskEXT_adr := GetProcAddress('glWriteMaskEXT');
    private z_WriteMaskEXT_1 := GetProcOrNil&<procedure(res: UInt32; &in: UInt32; outX: VertexShaderWriteMask; outY: VertexShaderWriteMask; outZ: VertexShaderWriteMask; outW: VertexShaderWriteMask)>(z_WriteMaskEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WriteMaskEXT(res: UInt32; &in: UInt32; outX: VertexShaderWriteMask; outY: VertexShaderWriteMask; outZ: VertexShaderWriteMask; outW: VertexShaderWriteMask) :=
    z_WriteMaskEXT_1(res, &in, outX, outY, outZ, outW);
    
    private z_InsertComponentEXT_adr := GetProcAddress('glInsertComponentEXT');
    private z_InsertComponentEXT_1 := GetProcOrNil&<procedure(res: UInt32; src: UInt32; num: UInt32)>(z_InsertComponentEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InsertComponentEXT(res: UInt32; src: UInt32; num: UInt32) :=
    z_InsertComponentEXT_1(res, src, num);
    
    private z_ExtractComponentEXT_adr := GetProcAddress('glExtractComponentEXT');
    private z_ExtractComponentEXT_1 := GetProcOrNil&<procedure(res: UInt32; src: UInt32; num: UInt32)>(z_ExtractComponentEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtractComponentEXT(res: UInt32; src: UInt32; num: UInt32) :=
    z_ExtractComponentEXT_1(res, src, num);
    
    private z_GenSymbolsEXT_adr := GetProcAddress('glGenSymbolsEXT');
    private z_GenSymbolsEXT_1 := GetProcOrNil&<function(_datatype: DataType; storagetype: VertexShaderStorageType; range: ParameterRange; components: UInt32): UInt32>(z_GenSymbolsEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenSymbolsEXT(_datatype: DataType; storagetype: VertexShaderStorageType; range: ParameterRange; components: UInt32): UInt32 :=
    z_GenSymbolsEXT_1(_datatype, storagetype, range, components);
    
    private z_SetInvariantEXT_adr := GetProcAddress('glSetInvariantEXT');
    private z_SetInvariantEXT_1 := GetProcOrNil&<procedure(id: UInt32; &type: ScalarType; addr: IntPtr)>(z_SetInvariantEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetInvariantEXT(id: UInt32; &type: ScalarType; addr: IntPtr) :=
    z_SetInvariantEXT_1(id, &type, addr);
    
    private z_SetLocalConstantEXT_adr := GetProcAddress('glSetLocalConstantEXT');
    private z_SetLocalConstantEXT_1 := GetProcOrNil&<procedure(id: UInt32; &type: ScalarType; addr: IntPtr)>(z_SetLocalConstantEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetLocalConstantEXT(id: UInt32; &type: ScalarType; addr: IntPtr) :=
    z_SetLocalConstantEXT_1(id, &type, addr);
    
    private z_VariantbvEXT_adr := GetProcAddress('glVariantbvEXT');
    private z_VariantbvEXT_1 := GetProcOrNil&<procedure(id: UInt32; addr: IntPtr)>(z_VariantbvEXT_adr);
    private z_VariantbvEXT_2 := GetProcOrNil&<procedure(id: UInt32; var addr: SByte)>(z_VariantbvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantbvEXT(id: UInt32; addr: array of SByte);
    type PSByte=^SByte;
    begin
      if (addr<>nil) and (addr.Length<>0) then
        z_VariantbvEXT_2(id, addr[0]) else
        z_VariantbvEXT_2(id, PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantbvEXT(id: UInt32; var addr: SByte) :=
    z_VariantbvEXT_2(id, addr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantbvEXT(id: UInt32; addr: IntPtr) :=
    z_VariantbvEXT_1(id, addr);
    
    private z_VariantsvEXT_adr := GetProcAddress('glVariantsvEXT');
    private z_VariantsvEXT_1 := GetProcOrNil&<procedure(id: UInt32; addr: IntPtr)>(z_VariantsvEXT_adr);
    private z_VariantsvEXT_2 := GetProcOrNil&<procedure(id: UInt32; var addr: Int16)>(z_VariantsvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantsvEXT(id: UInt32; addr: array of Int16);
    type PInt16=^Int16;
    begin
      if (addr<>nil) and (addr.Length<>0) then
        z_VariantsvEXT_2(id, addr[0]) else
        z_VariantsvEXT_2(id, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantsvEXT(id: UInt32; var addr: Int16) :=
    z_VariantsvEXT_2(id, addr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantsvEXT(id: UInt32; addr: IntPtr) :=
    z_VariantsvEXT_1(id, addr);
    
    private z_VariantivEXT_adr := GetProcAddress('glVariantivEXT');
    private z_VariantivEXT_1 := GetProcOrNil&<procedure(id: UInt32; addr: IntPtr)>(z_VariantivEXT_adr);
    private z_VariantivEXT_2 := GetProcOrNil&<procedure(id: UInt32; var addr: Int32)>(z_VariantivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantivEXT(id: UInt32; addr: array of Int32);
    type PInt32=^Int32;
    begin
      if (addr<>nil) and (addr.Length<>0) then
        z_VariantivEXT_2(id, addr[0]) else
        z_VariantivEXT_2(id, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantivEXT(id: UInt32; var addr: Int32) :=
    z_VariantivEXT_2(id, addr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantivEXT(id: UInt32; addr: IntPtr) :=
    z_VariantivEXT_1(id, addr);
    
    private z_VariantfvEXT_adr := GetProcAddress('glVariantfvEXT');
    private z_VariantfvEXT_1 := GetProcOrNil&<procedure(id: UInt32; addr: IntPtr)>(z_VariantfvEXT_adr);
    private z_VariantfvEXT_2 := GetProcOrNil&<procedure(id: UInt32; var addr: single)>(z_VariantfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantfvEXT(id: UInt32; addr: array of single);
    type Psingle=^single;
    begin
      if (addr<>nil) and (addr.Length<>0) then
        z_VariantfvEXT_2(id, addr[0]) else
        z_VariantfvEXT_2(id, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantfvEXT(id: UInt32; var addr: single) :=
    z_VariantfvEXT_2(id, addr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantfvEXT(id: UInt32; addr: IntPtr) :=
    z_VariantfvEXT_1(id, addr);
    
    private z_VariantdvEXT_adr := GetProcAddress('glVariantdvEXT');
    private z_VariantdvEXT_1 := GetProcOrNil&<procedure(id: UInt32; addr: IntPtr)>(z_VariantdvEXT_adr);
    private z_VariantdvEXT_2 := GetProcOrNil&<procedure(id: UInt32; var addr: real)>(z_VariantdvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantdvEXT(id: UInt32; addr: array of real);
    type Preal=^real;
    begin
      if (addr<>nil) and (addr.Length<>0) then
        z_VariantdvEXT_2(id, addr[0]) else
        z_VariantdvEXT_2(id, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantdvEXT(id: UInt32; var addr: real) :=
    z_VariantdvEXT_2(id, addr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantdvEXT(id: UInt32; addr: IntPtr) :=
    z_VariantdvEXT_1(id, addr);
    
    private z_VariantubvEXT_adr := GetProcAddress('glVariantubvEXT');
    private z_VariantubvEXT_1 := GetProcOrNil&<procedure(id: UInt32; addr: IntPtr)>(z_VariantubvEXT_adr);
    private z_VariantubvEXT_2 := GetProcOrNil&<procedure(id: UInt32; var addr: Byte)>(z_VariantubvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantubvEXT(id: UInt32; addr: array of Byte);
    type PByte=^Byte;
    begin
      if (addr<>nil) and (addr.Length<>0) then
        z_VariantubvEXT_2(id, addr[0]) else
        z_VariantubvEXT_2(id, PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantubvEXT(id: UInt32; var addr: Byte) :=
    z_VariantubvEXT_2(id, addr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantubvEXT(id: UInt32; addr: IntPtr) :=
    z_VariantubvEXT_1(id, addr);
    
    private z_VariantusvEXT_adr := GetProcAddress('glVariantusvEXT');
    private z_VariantusvEXT_1 := GetProcOrNil&<procedure(id: UInt32; addr: IntPtr)>(z_VariantusvEXT_adr);
    private z_VariantusvEXT_2 := GetProcOrNil&<procedure(id: UInt32; var addr: UInt16)>(z_VariantusvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantusvEXT(id: UInt32; addr: array of UInt16);
    type PUInt16=^UInt16;
    begin
      if (addr<>nil) and (addr.Length<>0) then
        z_VariantusvEXT_2(id, addr[0]) else
        z_VariantusvEXT_2(id, PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantusvEXT(id: UInt32; var addr: UInt16) :=
    z_VariantusvEXT_2(id, addr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantusvEXT(id: UInt32; addr: IntPtr) :=
    z_VariantusvEXT_1(id, addr);
    
    private z_VariantuivEXT_adr := GetProcAddress('glVariantuivEXT');
    private z_VariantuivEXT_1 := GetProcOrNil&<procedure(id: UInt32; addr: IntPtr)>(z_VariantuivEXT_adr);
    private z_VariantuivEXT_2 := GetProcOrNil&<procedure(id: UInt32; var addr: UInt32)>(z_VariantuivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantuivEXT(id: UInt32; addr: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (addr<>nil) and (addr.Length<>0) then
        z_VariantuivEXT_2(id, addr[0]) else
        z_VariantuivEXT_2(id, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantuivEXT(id: UInt32; var addr: UInt32) :=
    z_VariantuivEXT_2(id, addr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantuivEXT(id: UInt32; addr: IntPtr) :=
    z_VariantuivEXT_1(id, addr);
    
    private z_VariantPointerEXT_adr := GetProcAddress('glVariantPointerEXT');
    private z_VariantPointerEXT_1 := GetProcOrNil&<procedure(id: UInt32; &type: ScalarType; stride: UInt32; addr: IntPtr)>(z_VariantPointerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantPointerEXT(id: UInt32; &type: ScalarType; stride: UInt32; addr: IntPtr) :=
    z_VariantPointerEXT_1(id, &type, stride, addr);
    
    private z_EnableVariantClientStateEXT_adr := GetProcAddress('glEnableVariantClientStateEXT');
    private z_EnableVariantClientStateEXT_1 := GetProcOrNil&<procedure(id: UInt32)>(z_EnableVariantClientStateEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableVariantClientStateEXT(id: UInt32) :=
    z_EnableVariantClientStateEXT_1(id);
    
    private z_DisableVariantClientStateEXT_adr := GetProcAddress('glDisableVariantClientStateEXT');
    private z_DisableVariantClientStateEXT_1 := GetProcOrNil&<procedure(id: UInt32)>(z_DisableVariantClientStateEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableVariantClientStateEXT(id: UInt32) :=
    z_DisableVariantClientStateEXT_1(id);
    
    private z_BindLightParameterEXT_adr := GetProcAddress('glBindLightParameterEXT');
    private z_BindLightParameterEXT_1 := GetProcOrNil&<function(light: LightName; value: LightParameter): UInt32>(z_BindLightParameterEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindLightParameterEXT(light: LightName; value: LightParameter): UInt32 :=
    z_BindLightParameterEXT_1(light, value);
    
    private z_BindMaterialParameterEXT_adr := GetProcAddress('glBindMaterialParameterEXT');
    private z_BindMaterialParameterEXT_1 := GetProcOrNil&<function(face: MaterialFace; value: MaterialParameter): UInt32>(z_BindMaterialParameterEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindMaterialParameterEXT(face: MaterialFace; value: MaterialParameter): UInt32 :=
    z_BindMaterialParameterEXT_1(face, value);
    
    private z_BindTexGenParameterEXT_adr := GetProcAddress('glBindTexGenParameterEXT');
    private z_BindTexGenParameterEXT_1 := GetProcOrNil&<function(&unit: TextureUnit; coord: TextureCoordName; value: TextureGenParameter): UInt32>(z_BindTexGenParameterEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindTexGenParameterEXT(&unit: TextureUnit; coord: TextureCoordName; value: TextureGenParameter): UInt32 :=
    z_BindTexGenParameterEXT_1(&unit, coord, value);
    
    private z_BindTextureUnitParameterEXT_adr := GetProcAddress('glBindTextureUnitParameterEXT');
    private z_BindTextureUnitParameterEXT_1 := GetProcOrNil&<function(&unit: TextureUnit; value: VertexShaderTextureUnitParameter): UInt32>(z_BindTextureUnitParameterEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindTextureUnitParameterEXT(&unit: TextureUnit; value: VertexShaderTextureUnitParameter): UInt32 :=
    z_BindTextureUnitParameterEXT_1(&unit, value);
    
    private z_BindParameterEXT_adr := GetProcAddress('glBindParameterEXT');
    private z_BindParameterEXT_1 := GetProcOrNil&<function(value: VertexShaderParameter): UInt32>(z_BindParameterEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindParameterEXT(value: VertexShaderParameter): UInt32 :=
    z_BindParameterEXT_1(value);
    
    private z_IsVariantEnabledEXT_adr := GetProcAddress('glIsVariantEnabledEXT');
    private z_IsVariantEnabledEXT_1 := GetProcOrNil&<function(id: UInt32; cap: VariantCap): boolean>(z_IsVariantEnabledEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsVariantEnabledEXT(id: UInt32; cap: VariantCap): boolean :=
    z_IsVariantEnabledEXT_1(id, cap);
    
    private z_GetVariantBooleanvEXT_adr := GetProcAddress('glGetVariantBooleanvEXT');
    private z_GetVariantBooleanvEXT_1 := GetProcOrNil&<procedure(id: UInt32; value: GetVariantValue; data: IntPtr)>(z_GetVariantBooleanvEXT_adr);
    private z_GetVariantBooleanvEXT_2 := GetProcOrNil&<procedure(id: UInt32; value: GetVariantValue; var data: boolean)>(z_GetVariantBooleanvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantBooleanvEXT(id: UInt32; value: GetVariantValue; var data: boolean) :=
    z_GetVariantBooleanvEXT_2(id, value, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantBooleanvEXT(id: UInt32; value: GetVariantValue; data: IntPtr) :=
    z_GetVariantBooleanvEXT_1(id, value, data);
    
    private z_GetVariantIntegervEXT_adr := GetProcAddress('glGetVariantIntegervEXT');
    private z_GetVariantIntegervEXT_1 := GetProcOrNil&<procedure(id: UInt32; value: GetVariantValue; data: IntPtr)>(z_GetVariantIntegervEXT_adr);
    private z_GetVariantIntegervEXT_2 := GetProcOrNil&<procedure(id: UInt32; value: GetVariantValue; var data: Int32)>(z_GetVariantIntegervEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantIntegervEXT(id: UInt32; value: GetVariantValue; var data: Int32) :=
    z_GetVariantIntegervEXT_2(id, value, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantIntegervEXT(id: UInt32; value: GetVariantValue; data: IntPtr) :=
    z_GetVariantIntegervEXT_1(id, value, data);
    
    private z_GetVariantFloatvEXT_adr := GetProcAddress('glGetVariantFloatvEXT');
    private z_GetVariantFloatvEXT_1 := GetProcOrNil&<procedure(id: UInt32; value: GetVariantValue; data: IntPtr)>(z_GetVariantFloatvEXT_adr);
    private z_GetVariantFloatvEXT_2 := GetProcOrNil&<procedure(id: UInt32; value: GetVariantValue; var data: single)>(z_GetVariantFloatvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantFloatvEXT(id: UInt32; value: GetVariantValue; var data: single) :=
    z_GetVariantFloatvEXT_2(id, value, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantFloatvEXT(id: UInt32; value: GetVariantValue; data: IntPtr) :=
    z_GetVariantFloatvEXT_1(id, value, data);
    
    private z_GetVariantPointervEXT_adr := GetProcAddress('glGetVariantPointervEXT');
    private z_GetVariantPointervEXT_1 := GetProcOrNil&<procedure(id: UInt32; value: GetVariantValue; data: pointer)>(z_GetVariantPointervEXT_adr);
    private z_GetVariantPointervEXT_2 := GetProcOrNil&<procedure(id: UInt32; value: GetVariantValue; var data: IntPtr)>(z_GetVariantPointervEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantPointervEXT(id: UInt32; value: GetVariantValue; var data: IntPtr) :=
    z_GetVariantPointervEXT_2(id, value, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantPointervEXT(id: UInt32; value: GetVariantValue; data: pointer) :=
    z_GetVariantPointervEXT_1(id, value, data);
    
    private z_GetInvariantBooleanvEXT_adr := GetProcAddress('glGetInvariantBooleanvEXT');
    private z_GetInvariantBooleanvEXT_1 := GetProcOrNil&<procedure(id: UInt32; value: GetVariantValue; data: IntPtr)>(z_GetInvariantBooleanvEXT_adr);
    private z_GetInvariantBooleanvEXT_2 := GetProcOrNil&<procedure(id: UInt32; value: GetVariantValue; var data: boolean)>(z_GetInvariantBooleanvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInvariantBooleanvEXT(id: UInt32; value: GetVariantValue; var data: boolean) :=
    z_GetInvariantBooleanvEXT_2(id, value, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInvariantBooleanvEXT(id: UInt32; value: GetVariantValue; data: IntPtr) :=
    z_GetInvariantBooleanvEXT_1(id, value, data);
    
    private z_GetInvariantIntegervEXT_adr := GetProcAddress('glGetInvariantIntegervEXT');
    private z_GetInvariantIntegervEXT_1 := GetProcOrNil&<procedure(id: UInt32; value: GetVariantValue; data: IntPtr)>(z_GetInvariantIntegervEXT_adr);
    private z_GetInvariantIntegervEXT_2 := GetProcOrNil&<procedure(id: UInt32; value: GetVariantValue; var data: Int32)>(z_GetInvariantIntegervEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInvariantIntegervEXT(id: UInt32; value: GetVariantValue; var data: Int32) :=
    z_GetInvariantIntegervEXT_2(id, value, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInvariantIntegervEXT(id: UInt32; value: GetVariantValue; data: IntPtr) :=
    z_GetInvariantIntegervEXT_1(id, value, data);
    
    private z_GetInvariantFloatvEXT_adr := GetProcAddress('glGetInvariantFloatvEXT');
    private z_GetInvariantFloatvEXT_1 := GetProcOrNil&<procedure(id: UInt32; value: GetVariantValue; data: IntPtr)>(z_GetInvariantFloatvEXT_adr);
    private z_GetInvariantFloatvEXT_2 := GetProcOrNil&<procedure(id: UInt32; value: GetVariantValue; var data: single)>(z_GetInvariantFloatvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInvariantFloatvEXT(id: UInt32; value: GetVariantValue; var data: single) :=
    z_GetInvariantFloatvEXT_2(id, value, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInvariantFloatvEXT(id: UInt32; value: GetVariantValue; data: IntPtr) :=
    z_GetInvariantFloatvEXT_1(id, value, data);
    
    private z_GetLocalConstantBooleanvEXT_adr := GetProcAddress('glGetLocalConstantBooleanvEXT');
    private z_GetLocalConstantBooleanvEXT_1 := GetProcOrNil&<procedure(id: UInt32; value: GetVariantValue; data: IntPtr)>(z_GetLocalConstantBooleanvEXT_adr);
    private z_GetLocalConstantBooleanvEXT_2 := GetProcOrNil&<procedure(id: UInt32; value: GetVariantValue; var data: boolean)>(z_GetLocalConstantBooleanvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLocalConstantBooleanvEXT(id: UInt32; value: GetVariantValue; var data: boolean) :=
    z_GetLocalConstantBooleanvEXT_2(id, value, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLocalConstantBooleanvEXT(id: UInt32; value: GetVariantValue; data: IntPtr) :=
    z_GetLocalConstantBooleanvEXT_1(id, value, data);
    
    private z_GetLocalConstantIntegervEXT_adr := GetProcAddress('glGetLocalConstantIntegervEXT');
    private z_GetLocalConstantIntegervEXT_1 := GetProcOrNil&<procedure(id: UInt32; value: GetVariantValue; data: IntPtr)>(z_GetLocalConstantIntegervEXT_adr);
    private z_GetLocalConstantIntegervEXT_2 := GetProcOrNil&<procedure(id: UInt32; value: GetVariantValue; var data: Int32)>(z_GetLocalConstantIntegervEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLocalConstantIntegervEXT(id: UInt32; value: GetVariantValue; var data: Int32) :=
    z_GetLocalConstantIntegervEXT_2(id, value, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLocalConstantIntegervEXT(id: UInt32; value: GetVariantValue; data: IntPtr) :=
    z_GetLocalConstantIntegervEXT_1(id, value, data);
    
    private z_GetLocalConstantFloatvEXT_adr := GetProcAddress('glGetLocalConstantFloatvEXT');
    private z_GetLocalConstantFloatvEXT_1 := GetProcOrNil&<procedure(id: UInt32; value: GetVariantValue; data: IntPtr)>(z_GetLocalConstantFloatvEXT_adr);
    private z_GetLocalConstantFloatvEXT_2 := GetProcOrNil&<procedure(id: UInt32; value: GetVariantValue; var data: single)>(z_GetLocalConstantFloatvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLocalConstantFloatvEXT(id: UInt32; value: GetVariantValue; var data: single) :=
    z_GetLocalConstantFloatvEXT_2(id, value, data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLocalConstantFloatvEXT(id: UInt32; value: GetVariantValue; data: IntPtr) :=
    z_GetLocalConstantFloatvEXT_1(id, value, data);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glVertexWeightingEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_vertex_weighting';
    
    private z_VertexWeightfEXT_adr := GetProcAddress('glVertexWeightfEXT');
    private z_VertexWeightfEXT_1 := GetProcOrNil&<procedure(weight: single)>(z_VertexWeightfEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexWeightfEXT(weight: single) :=
    z_VertexWeightfEXT_1(weight);
    
    private z_VertexWeightfvEXT_adr := GetProcAddress('glVertexWeightfvEXT');
    private z_VertexWeightfvEXT_1 := GetProcOrNil&<procedure(weight: IntPtr)>(z_VertexWeightfvEXT_adr);
    private z_VertexWeightfvEXT_2 := GetProcOrNil&<procedure(var weight: single)>(z_VertexWeightfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexWeightfvEXT(weight: array of single);
    type Psingle=^single;
    begin
      if (weight<>nil) and (weight.Length<>0) then
        z_VertexWeightfvEXT_2(weight[0]) else
        z_VertexWeightfvEXT_2(Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexWeightfvEXT(var weight: single) :=
    z_VertexWeightfvEXT_2(weight);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexWeightfvEXT(weight: IntPtr) :=
    z_VertexWeightfvEXT_1(weight);
    
    private z_VertexWeightPointerEXT_adr := GetProcAddress('glVertexWeightPointerEXT');
    private z_VertexWeightPointerEXT_1 := GetProcOrNil&<procedure(size: Int32; &type: VertexWeightPointerType; stride: Int32; pointer: IntPtr)>(z_VertexWeightPointerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexWeightPointerEXT(size: Int32; &type: VertexWeightPointerType; stride: Int32; pointer: IntPtr) :=
    z_VertexWeightPointerEXT_1(size, &type, stride, pointer);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glWin32KeyedMutexEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_win32_keyed_mutex';
    
    private z_AcquireKeyedMutexWin32EXT_adr := GetProcAddress('glAcquireKeyedMutexWin32EXT');
    private z_AcquireKeyedMutexWin32EXT_1 := GetProcOrNil&<function(memory: UInt32; key: UInt64; timeout: UInt32): boolean>(z_AcquireKeyedMutexWin32EXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AcquireKeyedMutexWin32EXT(memory: UInt32; key: UInt64; timeout: UInt32): boolean :=
    z_AcquireKeyedMutexWin32EXT_1(memory, key, timeout);
    
    private z_ReleaseKeyedMutexWin32EXT_adr := GetProcAddress('glReleaseKeyedMutexWin32EXT');
    private z_ReleaseKeyedMutexWin32EXT_1 := GetProcOrNil&<function(memory: UInt32; key: UInt64): boolean>(z_ReleaseKeyedMutexWin32EXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseKeyedMutexWin32EXT(memory: UInt32; key: UInt64): boolean :=
    z_ReleaseKeyedMutexWin32EXT_1(memory, key);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glWindowRectanglesEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_window_rectangles';
    
    private z_WindowRectanglesEXT_adr := GetProcAddress('glWindowRectanglesEXT');
    private z_WindowRectanglesEXT_1 := GetProcOrNil&<procedure(mode: DummyEnum; count: Int32; box: IntPtr)>(z_WindowRectanglesEXT_adr);
    private z_WindowRectanglesEXT_2 := GetProcOrNil&<procedure(mode: DummyEnum; count: Int32; var box: Int32)>(z_WindowRectanglesEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowRectanglesEXT(mode: DummyEnum; count: Int32; box: array of Int32);
    type PInt32=^Int32;
    begin
      if (box<>nil) and (box.Length<>0) then
        z_WindowRectanglesEXT_2(mode, count, box[0]) else
        z_WindowRectanglesEXT_2(mode, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowRectanglesEXT(mode: DummyEnum; count: Int32; var box: Int32) :=
    z_WindowRectanglesEXT_2(mode, count, box);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowRectanglesEXT(mode: DummyEnum; count: Int32; box: IntPtr) :=
    z_WindowRectanglesEXT_1(mode, count, box);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glX11SyncObjectEXT = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ext_x11_sync_object';
    
    private z_ImportSyncEXT_adr := GetProcAddress('glImportSyncEXT');
    private z_ImportSyncEXT_1 := GetProcOrNil&<function(external_sync_type: DummyEnum; external_sync: IntPtr; flags: DummyFlags): gl_sync>(z_ImportSyncEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ImportSyncEXT(external_sync_type: DummyEnum; external_sync: IntPtr; flags: DummyFlags): gl_sync :=
    z_ImportSyncEXT_1(external_sync_type, external_sync, flags);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glFrameTerminatorGREMEDY = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_gremedy_frame_terminator';
    
    private z_FrameTerminatorGREMEDY_adr := GetProcAddress('glFrameTerminatorGREMEDY');
    private z_FrameTerminatorGREMEDY_1 := GetProcOrNil&<procedure>(z_FrameTerminatorGREMEDY_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FrameTerminatorGREMEDY :=
    z_FrameTerminatorGREMEDY_1();
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glStringMarkerGREMEDY = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_gremedy_string_marker';
    
    private z_StringMarkerGREMEDY_adr := GetProcAddress('glStringMarkerGREMEDY');
    private z_StringMarkerGREMEDY_1 := GetProcOrNil&<procedure(len: Int32; string: IntPtr)>(z_StringMarkerGREMEDY_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StringMarkerGREMEDY(len: Int32; string: IntPtr) :=
    z_StringMarkerGREMEDY_1(len, string);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glImageTransformHP = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_hp_image_transform';
    
    private z_ImageTransformParameteriHP_adr := GetProcAddress('glImageTransformParameteriHP');
    private z_ImageTransformParameteriHP_1 := GetProcOrNil&<procedure(target: ImageTransformTarget; pname: ImageTransformPName; param: Int32)>(z_ImageTransformParameteriHP_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImageTransformParameteriHP(target: ImageTransformTarget; pname: ImageTransformPName; param: Int32) :=
    z_ImageTransformParameteriHP_1(target, pname, param);
    
    private z_ImageTransformParameterfHP_adr := GetProcAddress('glImageTransformParameterfHP');
    private z_ImageTransformParameterfHP_1 := GetProcOrNil&<procedure(target: ImageTransformTarget; pname: ImageTransformPName; param: single)>(z_ImageTransformParameterfHP_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImageTransformParameterfHP(target: ImageTransformTarget; pname: ImageTransformPName; param: single) :=
    z_ImageTransformParameterfHP_1(target, pname, param);
    
    private z_ImageTransformParameterivHP_adr := GetProcAddress('glImageTransformParameterivHP');
    private z_ImageTransformParameterivHP_1 := GetProcOrNil&<procedure(target: ImageTransformTarget; pname: ImageTransformPName; &params: IntPtr)>(z_ImageTransformParameterivHP_adr);
    private z_ImageTransformParameterivHP_2 := GetProcOrNil&<procedure(target: ImageTransformTarget; pname: ImageTransformPName; var &params: Int32)>(z_ImageTransformParameterivHP_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImageTransformParameterivHP(target: ImageTransformTarget; pname: ImageTransformPName; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_ImageTransformParameterivHP_2(target, pname, &params[0]) else
        z_ImageTransformParameterivHP_2(target, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImageTransformParameterivHP(target: ImageTransformTarget; pname: ImageTransformPName; var &params: Int32) :=
    z_ImageTransformParameterivHP_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImageTransformParameterivHP(target: ImageTransformTarget; pname: ImageTransformPName; &params: IntPtr) :=
    z_ImageTransformParameterivHP_1(target, pname, &params);
    
    private z_ImageTransformParameterfvHP_adr := GetProcAddress('glImageTransformParameterfvHP');
    private z_ImageTransformParameterfvHP_1 := GetProcOrNil&<procedure(target: ImageTransformTarget; pname: ImageTransformPName; &params: IntPtr)>(z_ImageTransformParameterfvHP_adr);
    private z_ImageTransformParameterfvHP_2 := GetProcOrNil&<procedure(target: ImageTransformTarget; pname: ImageTransformPName; var &params: single)>(z_ImageTransformParameterfvHP_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImageTransformParameterfvHP(target: ImageTransformTarget; pname: ImageTransformPName; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_ImageTransformParameterfvHP_2(target, pname, &params[0]) else
        z_ImageTransformParameterfvHP_2(target, pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImageTransformParameterfvHP(target: ImageTransformTarget; pname: ImageTransformPName; var &params: single) :=
    z_ImageTransformParameterfvHP_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImageTransformParameterfvHP(target: ImageTransformTarget; pname: ImageTransformPName; &params: IntPtr) :=
    z_ImageTransformParameterfvHP_1(target, pname, &params);
    
    private z_GetImageTransformParameterivHP_adr := GetProcAddress('glGetImageTransformParameterivHP');
    private z_GetImageTransformParameterivHP_1 := GetProcOrNil&<procedure(target: ImageTransformTarget; pname: ImageTransformPName; &params: IntPtr)>(z_GetImageTransformParameterivHP_adr);
    private z_GetImageTransformParameterivHP_2 := GetProcOrNil&<procedure(target: ImageTransformTarget; pname: ImageTransformPName; var &params: Int32)>(z_GetImageTransformParameterivHP_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetImageTransformParameterivHP(target: ImageTransformTarget; pname: ImageTransformPName; var &params: Int32) :=
    z_GetImageTransformParameterivHP_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetImageTransformParameterivHP(target: ImageTransformTarget; pname: ImageTransformPName; &params: IntPtr) :=
    z_GetImageTransformParameterivHP_1(target, pname, &params);
    
    private z_GetImageTransformParameterfvHP_adr := GetProcAddress('glGetImageTransformParameterfvHP');
    private z_GetImageTransformParameterfvHP_1 := GetProcOrNil&<procedure(target: ImageTransformTarget; pname: ImageTransformPName; &params: IntPtr)>(z_GetImageTransformParameterfvHP_adr);
    private z_GetImageTransformParameterfvHP_2 := GetProcOrNil&<procedure(target: ImageTransformTarget; pname: ImageTransformPName; var &params: single)>(z_GetImageTransformParameterfvHP_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetImageTransformParameterfvHP(target: ImageTransformTarget; pname: ImageTransformPName; var &params: single) :=
    z_GetImageTransformParameterfvHP_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetImageTransformParameterfvHP(target: ImageTransformTarget; pname: ImageTransformPName; &params: IntPtr) :=
    z_GetImageTransformParameterfvHP_1(target, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glMultimodeDrawArraysIBM = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ibm_multimode_draw_arrays';
    
    private z_MultiModeDrawArraysIBM_adr := GetProcAddress('glMultiModeDrawArraysIBM');
    private z_MultiModeDrawArraysIBM_1 := GetProcOrNil&<procedure(mode: IntPtr; first: IntPtr; count: IntPtr; primcount: Int32; modestride: Int32)>(z_MultiModeDrawArraysIBM_adr);
    private z_MultiModeDrawArraysIBM_2 := GetProcOrNil&<procedure(mode: IntPtr; first: IntPtr; var count: Int32; primcount: Int32; modestride: Int32)>(z_MultiModeDrawArraysIBM_adr);
    private z_MultiModeDrawArraysIBM_3 := GetProcOrNil&<procedure(mode: IntPtr; var first: Int32; count: IntPtr; primcount: Int32; modestride: Int32)>(z_MultiModeDrawArraysIBM_adr);
    private z_MultiModeDrawArraysIBM_4 := GetProcOrNil&<procedure(mode: IntPtr; var first: Int32; var count: Int32; primcount: Int32; modestride: Int32)>(z_MultiModeDrawArraysIBM_adr);
    private z_MultiModeDrawArraysIBM_5 := GetProcOrNil&<procedure(var mode: PrimitiveType; first: IntPtr; count: IntPtr; primcount: Int32; modestride: Int32)>(z_MultiModeDrawArraysIBM_adr);
    private z_MultiModeDrawArraysIBM_6 := GetProcOrNil&<procedure(var mode: PrimitiveType; first: IntPtr; var count: Int32; primcount: Int32; modestride: Int32)>(z_MultiModeDrawArraysIBM_adr);
    private z_MultiModeDrawArraysIBM_7 := GetProcOrNil&<procedure(var mode: PrimitiveType; var first: Int32; count: IntPtr; primcount: Int32; modestride: Int32)>(z_MultiModeDrawArraysIBM_adr);
    private z_MultiModeDrawArraysIBM_8 := GetProcOrNil&<procedure(var mode: PrimitiveType; var first: Int32; var count: Int32; primcount: Int32; modestride: Int32)>(z_MultiModeDrawArraysIBM_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: array of PrimitiveType; first: array of Int32; count: array of Int32; primcount: Int32; modestride: Int32);
    type PPrimitiveType=^PrimitiveType;
    type PInt32=^Int32;
    begin
      if (count<>nil) and (count.Length<>0) then
        if (first<>nil) and (first.Length<>0) then
          if (mode<>nil) and (mode.Length<>0) then
            z_MultiModeDrawArraysIBM_8(mode[0], first[0], count[0], primcount, modestride) else
            z_MultiModeDrawArraysIBM_8(PPrimitiveType(nil)^, first[0], count[0], primcount, modestride) else
          if (mode<>nil) and (mode.Length<>0) then
            z_MultiModeDrawArraysIBM_8(mode[0], PInt32(nil)^, count[0], primcount, modestride) else
            z_MultiModeDrawArraysIBM_8(PPrimitiveType(nil)^, PInt32(nil)^, count[0], primcount, modestride) else
        if (first<>nil) and (first.Length<>0) then
          if (mode<>nil) and (mode.Length<>0) then
            z_MultiModeDrawArraysIBM_8(mode[0], first[0], PInt32(nil)^, primcount, modestride) else
            z_MultiModeDrawArraysIBM_8(PPrimitiveType(nil)^, first[0], PInt32(nil)^, primcount, modestride) else
          if (mode<>nil) and (mode.Length<>0) then
            z_MultiModeDrawArraysIBM_8(mode[0], PInt32(nil)^, PInt32(nil)^, primcount, modestride) else
            z_MultiModeDrawArraysIBM_8(PPrimitiveType(nil)^, PInt32(nil)^, PInt32(nil)^, primcount, modestride);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(var mode: PrimitiveType; var first: Int32; var count: Int32; primcount: Int32; modestride: Int32) :=
    z_MultiModeDrawArraysIBM_8(mode, first, count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(var mode: PrimitiveType; var first: Int32; count: IntPtr; primcount: Int32; modestride: Int32) :=
    z_MultiModeDrawArraysIBM_7(mode, first, count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(var mode: PrimitiveType; first: IntPtr; var count: Int32; primcount: Int32; modestride: Int32) :=
    z_MultiModeDrawArraysIBM_6(mode, first, count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(var mode: PrimitiveType; first: IntPtr; count: IntPtr; primcount: Int32; modestride: Int32) :=
    z_MultiModeDrawArraysIBM_5(mode, first, count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: IntPtr; var first: Int32; var count: Int32; primcount: Int32; modestride: Int32) :=
    z_MultiModeDrawArraysIBM_4(mode, first, count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: IntPtr; var first: Int32; count: IntPtr; primcount: Int32; modestride: Int32) :=
    z_MultiModeDrawArraysIBM_3(mode, first, count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: IntPtr; first: IntPtr; var count: Int32; primcount: Int32; modestride: Int32) :=
    z_MultiModeDrawArraysIBM_2(mode, first, count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: IntPtr; first: IntPtr; count: IntPtr; primcount: Int32; modestride: Int32) :=
    z_MultiModeDrawArraysIBM_1(mode, first, count, primcount, modestride);
    
    private z_MultiModeDrawElementsIBM_adr := GetProcAddress('glMultiModeDrawElementsIBM');
    private z_MultiModeDrawElementsIBM_1 := GetProcOrNil&<procedure(mode: IntPtr; count: IntPtr; &type: DrawElementsType; indices: pointer; primcount: Int32; modestride: Int32)>(z_MultiModeDrawElementsIBM_adr);
    private z_MultiModeDrawElementsIBM_2 := GetProcOrNil&<procedure(mode: IntPtr; count: IntPtr; &type: DrawElementsType; var indices: IntPtr; primcount: Int32; modestride: Int32)>(z_MultiModeDrawElementsIBM_adr);
    private z_MultiModeDrawElementsIBM_3 := GetProcOrNil&<procedure(mode: IntPtr; var count: Int32; &type: DrawElementsType; indices: pointer; primcount: Int32; modestride: Int32)>(z_MultiModeDrawElementsIBM_adr);
    private z_MultiModeDrawElementsIBM_4 := GetProcOrNil&<procedure(mode: IntPtr; var count: Int32; &type: DrawElementsType; var indices: IntPtr; primcount: Int32; modestride: Int32)>(z_MultiModeDrawElementsIBM_adr);
    private z_MultiModeDrawElementsIBM_5 := GetProcOrNil&<procedure(var mode: PrimitiveType; count: IntPtr; &type: DrawElementsType; indices: pointer; primcount: Int32; modestride: Int32)>(z_MultiModeDrawElementsIBM_adr);
    private z_MultiModeDrawElementsIBM_6 := GetProcOrNil&<procedure(var mode: PrimitiveType; count: IntPtr; &type: DrawElementsType; var indices: IntPtr; primcount: Int32; modestride: Int32)>(z_MultiModeDrawElementsIBM_adr);
    private z_MultiModeDrawElementsIBM_7 := GetProcOrNil&<procedure(var mode: PrimitiveType; var count: Int32; &type: DrawElementsType; indices: pointer; primcount: Int32; modestride: Int32)>(z_MultiModeDrawElementsIBM_adr);
    private z_MultiModeDrawElementsIBM_8 := GetProcOrNil&<procedure(var mode: PrimitiveType; var count: Int32; &type: DrawElementsType; var indices: IntPtr; primcount: Int32; modestride: Int32)>(z_MultiModeDrawElementsIBM_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: array of PrimitiveType; count: array of Int32; &type: DrawElementsType; indices: array of IntPtr; primcount: Int32; modestride: Int32);
    type PPrimitiveType=^PrimitiveType;
    type PInt32=^Int32;
    type PIntPtr=^IntPtr;
    begin
      if (indices<>nil) and (indices.Length<>0) then
        if (count<>nil) and (count.Length<>0) then
          if (mode<>nil) and (mode.Length<>0) then
            z_MultiModeDrawElementsIBM_8(mode[0], count[0], &type, indices[0], primcount, modestride) else
            z_MultiModeDrawElementsIBM_8(PPrimitiveType(nil)^, count[0], &type, indices[0], primcount, modestride) else
          if (mode<>nil) and (mode.Length<>0) then
            z_MultiModeDrawElementsIBM_8(mode[0], PInt32(nil)^, &type, indices[0], primcount, modestride) else
            z_MultiModeDrawElementsIBM_8(PPrimitiveType(nil)^, PInt32(nil)^, &type, indices[0], primcount, modestride) else
        if (count<>nil) and (count.Length<>0) then
          if (mode<>nil) and (mode.Length<>0) then
            z_MultiModeDrawElementsIBM_8(mode[0], count[0], &type, PIntPtr(nil)^, primcount, modestride) else
            z_MultiModeDrawElementsIBM_8(PPrimitiveType(nil)^, count[0], &type, PIntPtr(nil)^, primcount, modestride) else
          if (mode<>nil) and (mode.Length<>0) then
            z_MultiModeDrawElementsIBM_8(mode[0], PInt32(nil)^, &type, PIntPtr(nil)^, primcount, modestride) else
            z_MultiModeDrawElementsIBM_8(PPrimitiveType(nil)^, PInt32(nil)^, &type, PIntPtr(nil)^, primcount, modestride);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(var mode: PrimitiveType; var count: Int32; &type: DrawElementsType; var indices: IntPtr; primcount: Int32; modestride: Int32) :=
    z_MultiModeDrawElementsIBM_8(mode, count, &type, indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(var mode: PrimitiveType; var count: Int32; &type: DrawElementsType; indices: pointer; primcount: Int32; modestride: Int32) :=
    z_MultiModeDrawElementsIBM_7(mode, count, &type, indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(var mode: PrimitiveType; count: IntPtr; &type: DrawElementsType; var indices: IntPtr; primcount: Int32; modestride: Int32) :=
    z_MultiModeDrawElementsIBM_6(mode, count, &type, indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(var mode: PrimitiveType; count: IntPtr; &type: DrawElementsType; indices: pointer; primcount: Int32; modestride: Int32) :=
    z_MultiModeDrawElementsIBM_5(mode, count, &type, indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: IntPtr; var count: Int32; &type: DrawElementsType; var indices: IntPtr; primcount: Int32; modestride: Int32) :=
    z_MultiModeDrawElementsIBM_4(mode, count, &type, indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: IntPtr; var count: Int32; &type: DrawElementsType; indices: pointer; primcount: Int32; modestride: Int32) :=
    z_MultiModeDrawElementsIBM_3(mode, count, &type, indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: IntPtr; count: IntPtr; &type: DrawElementsType; var indices: IntPtr; primcount: Int32; modestride: Int32) :=
    z_MultiModeDrawElementsIBM_2(mode, count, &type, indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: IntPtr; count: IntPtr; &type: DrawElementsType; indices: pointer; primcount: Int32; modestride: Int32) :=
    z_MultiModeDrawElementsIBM_1(mode, count, &type, indices, primcount, modestride);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glStaticDataIBM = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ibm_static_data';
    
    private z_FlushStaticDataIBM_adr := GetProcAddress('glFlushStaticDataIBM');
    private z_FlushStaticDataIBM_1 := GetProcOrNil&<procedure(target: DummyEnum)>(z_FlushStaticDataIBM_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FlushStaticDataIBM(target: DummyEnum) :=
    z_FlushStaticDataIBM_1(target);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glVertexArrayListsIBM = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ibm_vertex_array_lists';
    
    private z_ColorPointerListIBM_adr := GetProcAddress('glColorPointerListIBM');
    private z_ColorPointerListIBM_1 := GetProcOrNil&<procedure(size: Int32; &type: ColorPointerType; stride: Int32; _pointer: pointer; ptrstride: Int32)>(z_ColorPointerListIBM_adr);
    private z_ColorPointerListIBM_2 := GetProcOrNil&<procedure(size: Int32; &type: ColorPointerType; stride: Int32; var _pointer: IntPtr; ptrstride: Int32)>(z_ColorPointerListIBM_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorPointerListIBM(size: Int32; &type: ColorPointerType; stride: Int32; _pointer: array of IntPtr; ptrstride: Int32);
    type PIntPtr=^IntPtr;
    begin
      if (_pointer<>nil) and (_pointer.Length<>0) then
        z_ColorPointerListIBM_2(size, &type, stride, _pointer[0], ptrstride) else
        z_ColorPointerListIBM_2(size, &type, stride, PIntPtr(nil)^, ptrstride);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorPointerListIBM(size: Int32; &type: ColorPointerType; stride: Int32; var _pointer: IntPtr; ptrstride: Int32) :=
    z_ColorPointerListIBM_2(size, &type, stride, _pointer, ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorPointerListIBM(size: Int32; &type: ColorPointerType; stride: Int32; _pointer: pointer; ptrstride: Int32) :=
    z_ColorPointerListIBM_1(size, &type, stride, _pointer, ptrstride);
    
    private z_SecondaryColorPointerListIBM_adr := GetProcAddress('glSecondaryColorPointerListIBM');
    private z_SecondaryColorPointerListIBM_1 := GetProcOrNil&<procedure(size: Int32; &type: SecondaryColorPointerType; stride: Int32; _pointer: pointer; ptrstride: Int32)>(z_SecondaryColorPointerListIBM_adr);
    private z_SecondaryColorPointerListIBM_2 := GetProcOrNil&<procedure(size: Int32; &type: SecondaryColorPointerType; stride: Int32; var _pointer: IntPtr; ptrstride: Int32)>(z_SecondaryColorPointerListIBM_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorPointerListIBM(size: Int32; &type: SecondaryColorPointerType; stride: Int32; _pointer: array of IntPtr; ptrstride: Int32);
    type PIntPtr=^IntPtr;
    begin
      if (_pointer<>nil) and (_pointer.Length<>0) then
        z_SecondaryColorPointerListIBM_2(size, &type, stride, _pointer[0], ptrstride) else
        z_SecondaryColorPointerListIBM_2(size, &type, stride, PIntPtr(nil)^, ptrstride);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorPointerListIBM(size: Int32; &type: SecondaryColorPointerType; stride: Int32; var _pointer: IntPtr; ptrstride: Int32) :=
    z_SecondaryColorPointerListIBM_2(size, &type, stride, _pointer, ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorPointerListIBM(size: Int32; &type: SecondaryColorPointerType; stride: Int32; _pointer: pointer; ptrstride: Int32) :=
    z_SecondaryColorPointerListIBM_1(size, &type, stride, _pointer, ptrstride);
    
    private z_EdgeFlagPointerListIBM_adr := GetProcAddress('glEdgeFlagPointerListIBM');
    private z_EdgeFlagPointerListIBM_1 := GetProcOrNil&<procedure(stride: Int32; pointer: IntPtr; ptrstride: Int32)>(z_EdgeFlagPointerListIBM_adr);
    private z_EdgeFlagPointerListIBM_2 := GetProcOrNil&<procedure(stride: Int32; var pointer: boolean; ptrstride: Int32)>(z_EdgeFlagPointerListIBM_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlagPointerListIBM(stride: Int32; var pointer: boolean; ptrstride: Int32) :=
    z_EdgeFlagPointerListIBM_2(stride, pointer, ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlagPointerListIBM(stride: Int32; pointer: IntPtr; ptrstride: Int32) :=
    z_EdgeFlagPointerListIBM_1(stride, pointer, ptrstride);
    
    private z_FogCoordPointerListIBM_adr := GetProcAddress('glFogCoordPointerListIBM');
    private z_FogCoordPointerListIBM_1 := GetProcOrNil&<procedure(&type: FogPointerType; stride: Int32; _pointer: pointer; ptrstride: Int32)>(z_FogCoordPointerListIBM_adr);
    private z_FogCoordPointerListIBM_2 := GetProcOrNil&<procedure(&type: FogPointerType; stride: Int32; var _pointer: IntPtr; ptrstride: Int32)>(z_FogCoordPointerListIBM_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordPointerListIBM(&type: FogPointerType; stride: Int32; _pointer: array of IntPtr; ptrstride: Int32);
    type PIntPtr=^IntPtr;
    begin
      if (_pointer<>nil) and (_pointer.Length<>0) then
        z_FogCoordPointerListIBM_2(&type, stride, _pointer[0], ptrstride) else
        z_FogCoordPointerListIBM_2(&type, stride, PIntPtr(nil)^, ptrstride);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordPointerListIBM(&type: FogPointerType; stride: Int32; var _pointer: IntPtr; ptrstride: Int32) :=
    z_FogCoordPointerListIBM_2(&type, stride, _pointer, ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordPointerListIBM(&type: FogPointerType; stride: Int32; _pointer: pointer; ptrstride: Int32) :=
    z_FogCoordPointerListIBM_1(&type, stride, _pointer, ptrstride);
    
    private z_IndexPointerListIBM_adr := GetProcAddress('glIndexPointerListIBM');
    private z_IndexPointerListIBM_1 := GetProcOrNil&<procedure(&type: IndexPointerType; stride: Int32; _pointer: pointer; ptrstride: Int32)>(z_IndexPointerListIBM_adr);
    private z_IndexPointerListIBM_2 := GetProcOrNil&<procedure(&type: IndexPointerType; stride: Int32; var _pointer: IntPtr; ptrstride: Int32)>(z_IndexPointerListIBM_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexPointerListIBM(&type: IndexPointerType; stride: Int32; _pointer: array of IntPtr; ptrstride: Int32);
    type PIntPtr=^IntPtr;
    begin
      if (_pointer<>nil) and (_pointer.Length<>0) then
        z_IndexPointerListIBM_2(&type, stride, _pointer[0], ptrstride) else
        z_IndexPointerListIBM_2(&type, stride, PIntPtr(nil)^, ptrstride);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexPointerListIBM(&type: IndexPointerType; stride: Int32; var _pointer: IntPtr; ptrstride: Int32) :=
    z_IndexPointerListIBM_2(&type, stride, _pointer, ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexPointerListIBM(&type: IndexPointerType; stride: Int32; _pointer: pointer; ptrstride: Int32) :=
    z_IndexPointerListIBM_1(&type, stride, _pointer, ptrstride);
    
    private z_NormalPointerListIBM_adr := GetProcAddress('glNormalPointerListIBM');
    private z_NormalPointerListIBM_1 := GetProcOrNil&<procedure(&type: NormalPointerType; stride: Int32; _pointer: pointer; ptrstride: Int32)>(z_NormalPointerListIBM_adr);
    private z_NormalPointerListIBM_2 := GetProcOrNil&<procedure(&type: NormalPointerType; stride: Int32; var _pointer: IntPtr; ptrstride: Int32)>(z_NormalPointerListIBM_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalPointerListIBM(&type: NormalPointerType; stride: Int32; _pointer: array of IntPtr; ptrstride: Int32);
    type PIntPtr=^IntPtr;
    begin
      if (_pointer<>nil) and (_pointer.Length<>0) then
        z_NormalPointerListIBM_2(&type, stride, _pointer[0], ptrstride) else
        z_NormalPointerListIBM_2(&type, stride, PIntPtr(nil)^, ptrstride);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalPointerListIBM(&type: NormalPointerType; stride: Int32; var _pointer: IntPtr; ptrstride: Int32) :=
    z_NormalPointerListIBM_2(&type, stride, _pointer, ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalPointerListIBM(&type: NormalPointerType; stride: Int32; _pointer: pointer; ptrstride: Int32) :=
    z_NormalPointerListIBM_1(&type, stride, _pointer, ptrstride);
    
    private z_TexCoordPointerListIBM_adr := GetProcAddress('glTexCoordPointerListIBM');
    private z_TexCoordPointerListIBM_1 := GetProcOrNil&<procedure(size: Int32; &type: TexCoordPointerType; stride: Int32; _pointer: pointer; ptrstride: Int32)>(z_TexCoordPointerListIBM_adr);
    private z_TexCoordPointerListIBM_2 := GetProcOrNil&<procedure(size: Int32; &type: TexCoordPointerType; stride: Int32; var _pointer: IntPtr; ptrstride: Int32)>(z_TexCoordPointerListIBM_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordPointerListIBM(size: Int32; &type: TexCoordPointerType; stride: Int32; _pointer: array of IntPtr; ptrstride: Int32);
    type PIntPtr=^IntPtr;
    begin
      if (_pointer<>nil) and (_pointer.Length<>0) then
        z_TexCoordPointerListIBM_2(size, &type, stride, _pointer[0], ptrstride) else
        z_TexCoordPointerListIBM_2(size, &type, stride, PIntPtr(nil)^, ptrstride);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordPointerListIBM(size: Int32; &type: TexCoordPointerType; stride: Int32; var _pointer: IntPtr; ptrstride: Int32) :=
    z_TexCoordPointerListIBM_2(size, &type, stride, _pointer, ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordPointerListIBM(size: Int32; &type: TexCoordPointerType; stride: Int32; _pointer: pointer; ptrstride: Int32) :=
    z_TexCoordPointerListIBM_1(size, &type, stride, _pointer, ptrstride);
    
    private z_VertexPointerListIBM_adr := GetProcAddress('glVertexPointerListIBM');
    private z_VertexPointerListIBM_1 := GetProcOrNil&<procedure(size: Int32; &type: VertexPointerType; stride: Int32; _pointer: pointer; ptrstride: Int32)>(z_VertexPointerListIBM_adr);
    private z_VertexPointerListIBM_2 := GetProcOrNil&<procedure(size: Int32; &type: VertexPointerType; stride: Int32; var _pointer: IntPtr; ptrstride: Int32)>(z_VertexPointerListIBM_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexPointerListIBM(size: Int32; &type: VertexPointerType; stride: Int32; _pointer: array of IntPtr; ptrstride: Int32);
    type PIntPtr=^IntPtr;
    begin
      if (_pointer<>nil) and (_pointer.Length<>0) then
        z_VertexPointerListIBM_2(size, &type, stride, _pointer[0], ptrstride) else
        z_VertexPointerListIBM_2(size, &type, stride, PIntPtr(nil)^, ptrstride);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexPointerListIBM(size: Int32; &type: VertexPointerType; stride: Int32; var _pointer: IntPtr; ptrstride: Int32) :=
    z_VertexPointerListIBM_2(size, &type, stride, _pointer, ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexPointerListIBM(size: Int32; &type: VertexPointerType; stride: Int32; _pointer: pointer; ptrstride: Int32) :=
    z_VertexPointerListIBM_1(size, &type, stride, _pointer, ptrstride);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glBlendFuncSeparateINGR = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ingr_blend_func_separate';
    
    private z_BlendFuncSeparateINGR_adr := GetProcAddress('glBlendFuncSeparateINGR');
    private z_BlendFuncSeparateINGR_1 := GetProcOrNil&<procedure(sfactorRGB: BlendingFactor; dfactorRGB: BlendingFactor; sfactorAlpha: BlendingFactor; dfactorAlpha: BlendingFactor)>(z_BlendFuncSeparateINGR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendFuncSeparateINGR(sfactorRGB: BlendingFactor; dfactorRGB: BlendingFactor; sfactorAlpha: BlendingFactor; dfactorAlpha: BlendingFactor) :=
    z_BlendFuncSeparateINGR_1(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glFramebufferCMAAINTEL = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_intel_framebuffer_cmaa';
    
    private z_ApplyFramebufferAttachmentCMAAINTEL_adr := GetProcAddress('glApplyFramebufferAttachmentCMAAINTEL');
    private z_ApplyFramebufferAttachmentCMAAINTEL_1 := GetProcOrNil&<procedure>(z_ApplyFramebufferAttachmentCMAAINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ApplyFramebufferAttachmentCMAAINTEL :=
    z_ApplyFramebufferAttachmentCMAAINTEL_1();
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glMapTextureINTEL = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_intel_map_texture';
    
    private z_SyncTextureINTEL_adr := GetProcAddress('glSyncTextureINTEL');
    private z_SyncTextureINTEL_1 := GetProcOrNil&<procedure(texture: gl_texture)>(z_SyncTextureINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SyncTextureINTEL(texture: gl_texture) :=
    z_SyncTextureINTEL_1(texture);
    
    private z_UnmapTexture2DINTEL_adr := GetProcAddress('glUnmapTexture2DINTEL');
    private z_UnmapTexture2DINTEL_1 := GetProcOrNil&<procedure(texture: gl_texture; level: Int32)>(z_UnmapTexture2DINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UnmapTexture2DINTEL(texture: gl_texture; level: Int32) :=
    z_UnmapTexture2DINTEL_1(texture, level);
    
    private z_MapTexture2DINTEL_adr := GetProcAddress('glMapTexture2DINTEL');
    private z_MapTexture2DINTEL_1 := GetProcOrNil&<function(texture: gl_texture; level: Int32; access: DummyFlags; stride: IntPtr; layout: IntPtr): IntPtr>(z_MapTexture2DINTEL_adr);
    private z_MapTexture2DINTEL_2 := GetProcOrNil&<function(texture: gl_texture; level: Int32; access: DummyFlags; stride: IntPtr; var layout: DummyEnum): IntPtr>(z_MapTexture2DINTEL_adr);
    private z_MapTexture2DINTEL_3 := GetProcOrNil&<function(texture: gl_texture; level: Int32; access: DummyFlags; var stride: Int32; layout: IntPtr): IntPtr>(z_MapTexture2DINTEL_adr);
    private z_MapTexture2DINTEL_4 := GetProcOrNil&<function(texture: gl_texture; level: Int32; access: DummyFlags; var stride: Int32; var layout: DummyEnum): IntPtr>(z_MapTexture2DINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapTexture2DINTEL(texture: gl_texture; level: Int32; access: DummyFlags; stride: array of Int32; layout: array of DummyEnum): IntPtr;
    type PInt32=^Int32;
    type PDummyEnum=^DummyEnum;
    begin
      Result := if (layout<>nil) and (layout.Length<>0) then
        if (stride<>nil) and (stride.Length<>0) then
          z_MapTexture2DINTEL_4(texture, level, access, stride[0], layout[0]) else
          z_MapTexture2DINTEL_4(texture, level, access, PInt32(nil)^, layout[0]) else
        if (stride<>nil) and (stride.Length<>0) then
          z_MapTexture2DINTEL_4(texture, level, access, stride[0], PDummyEnum(nil)^) else
          z_MapTexture2DINTEL_4(texture, level, access, PInt32(nil)^, PDummyEnum(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapTexture2DINTEL(texture: gl_texture; level: Int32; access: DummyFlags; var stride: Int32; var layout: DummyEnum): IntPtr :=
    z_MapTexture2DINTEL_4(texture, level, access, stride, layout);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapTexture2DINTEL(texture: gl_texture; level: Int32; access: DummyFlags; var stride: Int32; layout: IntPtr): IntPtr :=
    z_MapTexture2DINTEL_3(texture, level, access, stride, layout);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapTexture2DINTEL(texture: gl_texture; level: Int32; access: DummyFlags; stride: IntPtr; var layout: DummyEnum): IntPtr :=
    z_MapTexture2DINTEL_2(texture, level, access, stride, layout);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapTexture2DINTEL(texture: gl_texture; level: Int32; access: DummyFlags; stride: IntPtr; layout: IntPtr): IntPtr :=
    z_MapTexture2DINTEL_1(texture, level, access, stride, layout);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glParallelArraysINTEL = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_intel_parallel_arrays';
    
    private z_VertexPointervINTEL_adr := GetProcAddress('glVertexPointervINTEL');
    private z_VertexPointervINTEL_1 := GetProcOrNil&<procedure(size: Int32; &type: VertexPointerType; _pointer: pointer)>(z_VertexPointervINTEL_adr);
    private z_VertexPointervINTEL_2 := GetProcOrNil&<procedure(size: Int32; &type: VertexPointerType; var _pointer: IntPtr)>(z_VertexPointervINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexPointervINTEL(size: Int32; &type: VertexPointerType; _pointer: array of IntPtr);
    type PIntPtr=^IntPtr;
    begin
      if (_pointer<>nil) and (_pointer.Length<>0) then
        z_VertexPointervINTEL_2(size, &type, _pointer[0]) else
        z_VertexPointervINTEL_2(size, &type, PIntPtr(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexPointervINTEL(size: Int32; &type: VertexPointerType; var _pointer: IntPtr) :=
    z_VertexPointervINTEL_2(size, &type, _pointer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexPointervINTEL(size: Int32; &type: VertexPointerType; _pointer: pointer) :=
    z_VertexPointervINTEL_1(size, &type, _pointer);
    
    private z_NormalPointervINTEL_adr := GetProcAddress('glNormalPointervINTEL');
    private z_NormalPointervINTEL_1 := GetProcOrNil&<procedure(&type: NormalPointerType; _pointer: pointer)>(z_NormalPointervINTEL_adr);
    private z_NormalPointervINTEL_2 := GetProcOrNil&<procedure(&type: NormalPointerType; var _pointer: IntPtr)>(z_NormalPointervINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalPointervINTEL(&type: NormalPointerType; _pointer: array of IntPtr);
    type PIntPtr=^IntPtr;
    begin
      if (_pointer<>nil) and (_pointer.Length<>0) then
        z_NormalPointervINTEL_2(&type, _pointer[0]) else
        z_NormalPointervINTEL_2(&type, PIntPtr(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalPointervINTEL(&type: NormalPointerType; var _pointer: IntPtr) :=
    z_NormalPointervINTEL_2(&type, _pointer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalPointervINTEL(&type: NormalPointerType; _pointer: pointer) :=
    z_NormalPointervINTEL_1(&type, _pointer);
    
    private z_ColorPointervINTEL_adr := GetProcAddress('glColorPointervINTEL');
    private z_ColorPointervINTEL_1 := GetProcOrNil&<procedure(size: Int32; &type: VertexPointerType; _pointer: pointer)>(z_ColorPointervINTEL_adr);
    private z_ColorPointervINTEL_2 := GetProcOrNil&<procedure(size: Int32; &type: VertexPointerType; var _pointer: IntPtr)>(z_ColorPointervINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorPointervINTEL(size: Int32; &type: VertexPointerType; _pointer: array of IntPtr);
    type PIntPtr=^IntPtr;
    begin
      if (_pointer<>nil) and (_pointer.Length<>0) then
        z_ColorPointervINTEL_2(size, &type, _pointer[0]) else
        z_ColorPointervINTEL_2(size, &type, PIntPtr(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorPointervINTEL(size: Int32; &type: VertexPointerType; var _pointer: IntPtr) :=
    z_ColorPointervINTEL_2(size, &type, _pointer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorPointervINTEL(size: Int32; &type: VertexPointerType; _pointer: pointer) :=
    z_ColorPointervINTEL_1(size, &type, _pointer);
    
    private z_TexCoordPointervINTEL_adr := GetProcAddress('glTexCoordPointervINTEL');
    private z_TexCoordPointervINTEL_1 := GetProcOrNil&<procedure(size: Int32; &type: VertexPointerType; _pointer: pointer)>(z_TexCoordPointervINTEL_adr);
    private z_TexCoordPointervINTEL_2 := GetProcOrNil&<procedure(size: Int32; &type: VertexPointerType; var _pointer: IntPtr)>(z_TexCoordPointervINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordPointervINTEL(size: Int32; &type: VertexPointerType; _pointer: array of IntPtr);
    type PIntPtr=^IntPtr;
    begin
      if (_pointer<>nil) and (_pointer.Length<>0) then
        z_TexCoordPointervINTEL_2(size, &type, _pointer[0]) else
        z_TexCoordPointervINTEL_2(size, &type, PIntPtr(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordPointervINTEL(size: Int32; &type: VertexPointerType; var _pointer: IntPtr) :=
    z_TexCoordPointervINTEL_2(size, &type, _pointer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordPointervINTEL(size: Int32; &type: VertexPointerType; _pointer: pointer) :=
    z_TexCoordPointervINTEL_1(size, &type, _pointer);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glPerformanceQueryINTEL = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_intel_performance_query';
    
    private z_BeginPerfQueryINTEL_adr := GetProcAddress('glBeginPerfQueryINTEL');
    private z_BeginPerfQueryINTEL_1 := GetProcOrNil&<procedure(queryHandle: gl_perf_query_handle_INTEL)>(z_BeginPerfQueryINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginPerfQueryINTEL(queryHandle: gl_perf_query_handle_INTEL) :=
    z_BeginPerfQueryINTEL_1(queryHandle);
    
    private z_CreatePerfQueryINTEL_adr := GetProcAddress('glCreatePerfQueryINTEL');
    private z_CreatePerfQueryINTEL_1 := GetProcOrNil&<procedure(queryId: gl_perf_query_id_INTEL; queryHandle: IntPtr)>(z_CreatePerfQueryINTEL_adr);
    private z_CreatePerfQueryINTEL_2 := GetProcOrNil&<procedure(queryId: gl_perf_query_id_INTEL; var queryHandle: gl_perf_query_handle_INTEL)>(z_CreatePerfQueryINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreatePerfQueryINTEL(queryId: gl_perf_query_id_INTEL; var queryHandle: gl_perf_query_handle_INTEL) :=
    z_CreatePerfQueryINTEL_2(queryId, queryHandle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreatePerfQueryINTEL(queryId: gl_perf_query_id_INTEL; queryHandle: IntPtr) :=
    z_CreatePerfQueryINTEL_1(queryId, queryHandle);
    
    private z_DeletePerfQueryINTEL_adr := GetProcAddress('glDeletePerfQueryINTEL');
    private z_DeletePerfQueryINTEL_1 := GetProcOrNil&<procedure(queryHandle: gl_perf_query_handle_INTEL)>(z_DeletePerfQueryINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeletePerfQueryINTEL(queryHandle: gl_perf_query_handle_INTEL) :=
    z_DeletePerfQueryINTEL_1(queryHandle);
    
    private z_EndPerfQueryINTEL_adr := GetProcAddress('glEndPerfQueryINTEL');
    private z_EndPerfQueryINTEL_1 := GetProcOrNil&<procedure(queryHandle: gl_perf_query_handle_INTEL)>(z_EndPerfQueryINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndPerfQueryINTEL(queryHandle: gl_perf_query_handle_INTEL) :=
    z_EndPerfQueryINTEL_1(queryHandle);
    
    private z_GetFirstPerfQueryIdINTEL_adr := GetProcAddress('glGetFirstPerfQueryIdINTEL');
    private z_GetFirstPerfQueryIdINTEL_1 := GetProcOrNil&<procedure(queryId: IntPtr)>(z_GetFirstPerfQueryIdINTEL_adr);
    private z_GetFirstPerfQueryIdINTEL_2 := GetProcOrNil&<procedure(var queryId: gl_perf_query_id_INTEL)>(z_GetFirstPerfQueryIdINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFirstPerfQueryIdINTEL(var queryId: gl_perf_query_id_INTEL) :=
    z_GetFirstPerfQueryIdINTEL_2(queryId);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFirstPerfQueryIdINTEL(queryId: IntPtr) :=
    z_GetFirstPerfQueryIdINTEL_1(queryId);
    
    private z_GetNextPerfQueryIdINTEL_adr := GetProcAddress('glGetNextPerfQueryIdINTEL');
    private z_GetNextPerfQueryIdINTEL_1 := GetProcOrNil&<procedure(queryId: gl_perf_query_id_INTEL; nextQueryId: IntPtr)>(z_GetNextPerfQueryIdINTEL_adr);
    private z_GetNextPerfQueryIdINTEL_2 := GetProcOrNil&<procedure(queryId: gl_perf_query_id_INTEL; var nextQueryId: gl_perf_query_id_INTEL)>(z_GetNextPerfQueryIdINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNextPerfQueryIdINTEL(queryId: gl_perf_query_id_INTEL; var nextQueryId: gl_perf_query_id_INTEL) :=
    z_GetNextPerfQueryIdINTEL_2(queryId, nextQueryId);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNextPerfQueryIdINTEL(queryId: gl_perf_query_id_INTEL; nextQueryId: IntPtr) :=
    z_GetNextPerfQueryIdINTEL_1(queryId, nextQueryId);
    
    private z_GetPerfCounterInfoINTEL_adr := GetProcAddress('glGetPerfCounterInfoINTEL');
    private z_GetPerfCounterInfoINTEL_1 := GetProcOrNil&<procedure(queryId: gl_perf_query_id_INTEL; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: IntPtr; counterDataSize: IntPtr; counterTypeEnum: IntPtr; counterDataTypeEnum: IntPtr; rawCounterMaxValue: IntPtr)>(z_GetPerfCounterInfoINTEL_adr);
    private z_GetPerfCounterInfoINTEL_2 := GetProcOrNil&<procedure(queryId: gl_perf_query_id_INTEL; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64)>(z_GetPerfCounterInfoINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: gl_perf_query_id_INTEL; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64) :=
    z_GetPerfCounterInfoINTEL_2(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: gl_perf_query_id_INTEL; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: IntPtr; counterDataSize: IntPtr; counterTypeEnum: IntPtr; counterDataTypeEnum: IntPtr; rawCounterMaxValue: IntPtr) :=
    z_GetPerfCounterInfoINTEL_1(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
    
    private z_GetPerfQueryDataINTEL_adr := GetProcAddress('glGetPerfQueryDataINTEL');
    private z_GetPerfQueryDataINTEL_1 := GetProcOrNil&<procedure(queryHandle: gl_perf_query_handle_INTEL; flags: PerfQueryDataFlags; dataSize: Int32; data: IntPtr; bytesWritten: IntPtr)>(z_GetPerfQueryDataINTEL_adr);
    private z_GetPerfQueryDataINTEL_2 := GetProcOrNil&<procedure(queryHandle: gl_perf_query_handle_INTEL; flags: PerfQueryDataFlags; dataSize: Int32; data: IntPtr; var bytesWritten: UInt32)>(z_GetPerfQueryDataINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryDataINTEL(queryHandle: gl_perf_query_handle_INTEL; flags: PerfQueryDataFlags; dataSize: Int32; data: IntPtr; var bytesWritten: UInt32) :=
    z_GetPerfQueryDataINTEL_2(queryHandle, flags, dataSize, data, bytesWritten);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryDataINTEL(queryHandle: gl_perf_query_handle_INTEL; flags: PerfQueryDataFlags; dataSize: Int32; data: IntPtr; bytesWritten: IntPtr) :=
    z_GetPerfQueryDataINTEL_1(queryHandle, flags, dataSize, data, bytesWritten);
    
    private z_GetPerfQueryIdByNameINTEL_adr := GetProcAddress('glGetPerfQueryIdByNameINTEL');
    private z_GetPerfQueryIdByNameINTEL_1 := GetProcOrNil&<procedure(queryName: IntPtr; queryId: IntPtr)>(z_GetPerfQueryIdByNameINTEL_adr);
    private z_GetPerfQueryIdByNameINTEL_2 := GetProcOrNil&<procedure(queryName: IntPtr; var queryId: gl_perf_query_id_INTEL)>(z_GetPerfQueryIdByNameINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryIdByNameINTEL(queryName: string; var queryId: gl_perf_query_id_INTEL);
    begin
      var queryName_str_ptr: IntPtr;
      try
        queryName_str_ptr := Marshal.StringToHGlobalAnsi(queryName);
        z_GetPerfQueryIdByNameINTEL_2(queryName_str_ptr, queryId);
      finally
        Marshal.FreeHGlobal(queryName_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryIdByNameINTEL(queryName: string; queryId: IntPtr);
    begin
      var queryName_str_ptr: IntPtr;
      try
        queryName_str_ptr := Marshal.StringToHGlobalAnsi(queryName);
        z_GetPerfQueryIdByNameINTEL_1(queryName_str_ptr, queryId);
      finally
        Marshal.FreeHGlobal(queryName_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryIdByNameINTEL(queryName: IntPtr; var queryId: gl_perf_query_id_INTEL) :=
    z_GetPerfQueryIdByNameINTEL_2(queryName, queryId);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryIdByNameINTEL(queryName: IntPtr; queryId: IntPtr) :=
    z_GetPerfQueryIdByNameINTEL_1(queryName, queryId);
    
    private z_GetPerfQueryInfoINTEL_adr := GetProcAddress('glGetPerfQueryInfoINTEL');
    private z_GetPerfQueryInfoINTEL_1 := GetProcOrNil&<procedure(queryId: gl_perf_query_id_INTEL; queryNameLength: UInt32; queryName: IntPtr; dataSize: IntPtr; noCounters: IntPtr; noInstances: IntPtr; capsMask: IntPtr)>(z_GetPerfQueryInfoINTEL_adr);
    private z_GetPerfQueryInfoINTEL_2 := GetProcOrNil&<procedure(queryId: gl_perf_query_id_INTEL; queryNameLength: UInt32; queryName: IntPtr; var dataSize: UInt32; var noCounters: UInt32; var noInstances: UInt32; var capsMask: PerformanceQueryCapsMask)>(z_GetPerfQueryInfoINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: gl_perf_query_id_INTEL; queryNameLength: UInt32; queryName: IntPtr; var dataSize: UInt32; var noCounters: UInt32; var noInstances: UInt32; var capsMask: PerformanceQueryCapsMask) :=
    z_GetPerfQueryInfoINTEL_2(queryId, queryNameLength, queryName, dataSize, noCounters, noInstances, capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: gl_perf_query_id_INTEL; queryNameLength: UInt32; queryName: IntPtr; dataSize: IntPtr; noCounters: IntPtr; noInstances: IntPtr; capsMask: IntPtr) :=
    z_GetPerfQueryInfoINTEL_1(queryId, queryNameLength, queryName, dataSize, noCounters, noInstances, capsMask);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glBlendEquationAdvancedKHR = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_khr_blend_equation_advanced';
    
    private z_BlendBarrierKHR_adr := GetProcAddress('glBlendBarrierKHR');
    private z_BlendBarrierKHR_1 := GetProcOrNil&<procedure>(z_BlendBarrierKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendBarrierKHR :=
    z_BlendBarrierKHR_1();
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glDebugKHR = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_khr_debug';
    
    private z_DebugMessageControl_adr := GetProcAddress('glDebugMessageControl');
    private z_DebugMessageControl_1 := GetProcOrNil&<procedure(source: DebugSource; &type: DebugType; severity: DebugSeverity; count: Int32; ids: IntPtr; enabled: boolean)>(z_DebugMessageControl_adr);
    private z_DebugMessageControl_2 := GetProcOrNil&<procedure(source: DebugSource; &type: DebugType; severity: DebugSeverity; count: Int32; var ids: UInt32; enabled: boolean)>(z_DebugMessageControl_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageControl(source: DebugSource; &type: DebugType; severity: DebugSeverity; count: Int32; ids: array of UInt32; enabled: boolean);
    type PUInt32=^UInt32;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        z_DebugMessageControl_2(source, &type, severity, count, ids[0], enabled) else
        z_DebugMessageControl_2(source, &type, severity, count, PUInt32(nil)^, enabled);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageControl(source: DebugSource; &type: DebugType; severity: DebugSeverity; count: Int32; var ids: UInt32; enabled: boolean) :=
    z_DebugMessageControl_2(source, &type, severity, count, ids, enabled);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageControl(source: DebugSource; &type: DebugType; severity: DebugSeverity; count: Int32; ids: IntPtr; enabled: boolean) :=
    z_DebugMessageControl_1(source, &type, severity, count, ids, enabled);
    
    private z_DebugMessageInsert_adr := GetProcAddress('glDebugMessageInsert');
    private z_DebugMessageInsert_1 := GetProcOrNil&<procedure(source: DebugSource; &type: DebugType; id: UInt32; severity: DebugSeverity; length: Int32; buf: IntPtr)>(z_DebugMessageInsert_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageInsert(source: DebugSource; &type: DebugType; id: UInt32; severity: DebugSeverity; length: Int32; buf: string);
    begin
      var buf_str_ptr: IntPtr;
      try
        buf_str_ptr := Marshal.StringToHGlobalAnsi(buf);
        z_DebugMessageInsert_1(source, &type, id, severity, length, buf_str_ptr);
      finally
        Marshal.FreeHGlobal(buf_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageInsert(source: DebugSource; &type: DebugType; id: UInt32; severity: DebugSeverity; length: Int32; buf: IntPtr) :=
    z_DebugMessageInsert_1(source, &type, id, severity, length, buf);
    
    private z_DebugMessageCallback_adr := GetProcAddress('glDebugMessageCallback');
    private z_DebugMessageCallback_1 := GetProcOrNil&<procedure(callback: GL_DEBUG_PROC; userParam: IntPtr)>(z_DebugMessageCallback_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageCallback(callback: GL_DEBUG_PROC; userParam: IntPtr) :=
    z_DebugMessageCallback_1(callback, userParam);
    
    private z_GetDebugMessageLog_adr := GetProcAddress('glGetDebugMessageLog');
    private z_GetDebugMessageLog_1 := GetProcOrNil&<function(count: UInt32; bufSize: Int32; sources: IntPtr; types: IntPtr; ids: IntPtr; severities: IntPtr; lengths: IntPtr; messageLog: IntPtr): UInt32>(z_GetDebugMessageLog_adr);
    private z_GetDebugMessageLog_2 := GetProcOrNil&<function(count: UInt32; bufSize: Int32; var sources: DebugSource; var types: DebugType; var ids: UInt32; var severities: DebugSeverity; var lengths: Int32; messageLog: IntPtr): UInt32>(z_GetDebugMessageLog_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDebugMessageLog(count: UInt32; bufSize: Int32; var sources: DebugSource; var types: DebugType; var ids: UInt32; var severities: DebugSeverity; var lengths: Int32; messageLog: IntPtr): UInt32 :=
    z_GetDebugMessageLog_2(count, bufSize, sources, types, ids, severities, lengths, messageLog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDebugMessageLog(count: UInt32; bufSize: Int32; sources: IntPtr; types: IntPtr; ids: IntPtr; severities: IntPtr; lengths: IntPtr; messageLog: IntPtr): UInt32 :=
    z_GetDebugMessageLog_1(count, bufSize, sources, types, ids, severities, lengths, messageLog);
    
    private z_PushDebugGroup_adr := GetProcAddress('glPushDebugGroup');
    private z_PushDebugGroup_1 := GetProcOrNil&<procedure(source: DebugSource; id: UInt32; length: Int32; message: IntPtr)>(z_PushDebugGroup_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PushDebugGroup(source: DebugSource; id: UInt32; length: Int32; message: string);
    begin
      var message_str_ptr: IntPtr;
      try
        message_str_ptr := Marshal.StringToHGlobalAnsi(message);
        z_PushDebugGroup_1(source, id, length, message_str_ptr);
      finally
        Marshal.FreeHGlobal(message_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PushDebugGroup(source: DebugSource; id: UInt32; length: Int32; message: IntPtr) :=
    z_PushDebugGroup_1(source, id, length, message);
    
    private z_PopDebugGroup_adr := GetProcAddress('glPopDebugGroup');
    private z_PopDebugGroup_1 := GetProcOrNil&<procedure>(z_PopDebugGroup_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PopDebugGroup :=
    z_PopDebugGroup_1();
    
    private z_ObjectLabel_adr := GetProcAddress('glObjectLabel');
    private z_ObjectLabel_1 := GetProcOrNil&<procedure(identifier: ObjectIdentifier; name: UInt32; length: Int32; &label: IntPtr)>(z_ObjectLabel_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ObjectLabel(identifier: ObjectIdentifier; name: UInt32; length: Int32; &label: string);
    begin
      var &label_str_ptr: IntPtr;
      try
        &label_str_ptr := Marshal.StringToHGlobalAnsi(&label);
        z_ObjectLabel_1(identifier, name, length, &label_str_ptr);
      finally
        Marshal.FreeHGlobal(&label_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ObjectLabel(identifier: ObjectIdentifier; name: UInt32; length: Int32; &label: IntPtr) :=
    z_ObjectLabel_1(identifier, name, length, &label);
    
    private z_GetObjectLabel_adr := GetProcAddress('glGetObjectLabel');
    private z_GetObjectLabel_1 := GetProcOrNil&<procedure(identifier: ObjectIdentifier; name: UInt32; bufSize: Int32; length: IntPtr; &label: IntPtr)>(z_GetObjectLabel_adr);
    private z_GetObjectLabel_2 := GetProcOrNil&<procedure(identifier: ObjectIdentifier; name: UInt32; bufSize: Int32; var length: Int32; &label: IntPtr)>(z_GetObjectLabel_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectLabel(identifier: ObjectIdentifier; name: UInt32; bufSize: Int32; var length: Int32; &label: IntPtr) :=
    z_GetObjectLabel_2(identifier, name, bufSize, length, &label);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectLabel(identifier: ObjectIdentifier; name: UInt32; bufSize: Int32; length: IntPtr; &label: IntPtr) :=
    z_GetObjectLabel_1(identifier, name, bufSize, length, &label);
    
    private z_ObjectPtrLabel_adr := GetProcAddress('glObjectPtrLabel');
    private z_ObjectPtrLabel_1 := GetProcOrNil&<procedure(ptr: IntPtr; length: Int32; &label: IntPtr)>(z_ObjectPtrLabel_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ObjectPtrLabel(ptr: IntPtr; length: Int32; &label: string);
    begin
      var &label_str_ptr: IntPtr;
      try
        &label_str_ptr := Marshal.StringToHGlobalAnsi(&label);
        z_ObjectPtrLabel_1(ptr, length, &label_str_ptr);
      finally
        Marshal.FreeHGlobal(&label_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ObjectPtrLabel(ptr: IntPtr; length: Int32; &label: IntPtr) :=
    z_ObjectPtrLabel_1(ptr, length, &label);
    
    private z_GetObjectPtrLabel_adr := GetProcAddress('glGetObjectPtrLabel');
    private z_GetObjectPtrLabel_1 := GetProcOrNil&<procedure(ptr: IntPtr; bufSize: Int32; length: IntPtr; &label: IntPtr)>(z_GetObjectPtrLabel_adr);
    private z_GetObjectPtrLabel_2 := GetProcOrNil&<procedure(ptr: IntPtr; bufSize: Int32; var length: Int32; &label: IntPtr)>(z_GetObjectPtrLabel_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectPtrLabel(ptr: IntPtr; bufSize: Int32; var length: Int32; &label: IntPtr) :=
    z_GetObjectPtrLabel_2(ptr, bufSize, length, &label);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectPtrLabel(ptr: IntPtr; bufSize: Int32; length: IntPtr; &label: IntPtr) :=
    z_GetObjectPtrLabel_1(ptr, bufSize, length, &label);
    
    private z_GetPointerv_adr := GetProcAddress('glGetPointerv');
    private z_GetPointerv_1 := GetProcOrNil&<procedure(pname: GetPointervPName; &params: pointer)>(z_GetPointerv_adr);
    private z_GetPointerv_2 := GetProcOrNil&<procedure(pname: GetPointervPName; var &params: IntPtr)>(z_GetPointerv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointerv(pname: GetPointervPName; var &params: IntPtr) :=
    z_GetPointerv_2(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointerv(pname: GetPointervPName; &params: pointer) :=
    z_GetPointerv_1(pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glRobustnessKHR = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_khr_robustness';
    
    private z_GetGraphicsResetStatus_adr := GetProcAddress('glGetGraphicsResetStatus');
    private z_GetGraphicsResetStatus_1 := GetProcOrNil&<function: GraphicsResetStatus>(z_GetGraphicsResetStatus_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGraphicsResetStatus: GraphicsResetStatus :=
    z_GetGraphicsResetStatus_1();
    
    private z_ReadnPixels_adr := GetProcAddress('glReadnPixels');
    private z_ReadnPixels_1 := GetProcOrNil&<procedure(x: Int32; y: Int32; width: Int32; height: Int32; format: PixelFormat; &type: PixelType; bufSize: Int32; data: IntPtr)>(z_ReadnPixels_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReadnPixels(x: Int32; y: Int32; width: Int32; height: Int32; format: PixelFormat; &type: PixelType; bufSize: Int32; data: IntPtr) :=
    z_ReadnPixels_1(x, y, width, height, format, &type, bufSize, data);
    
    private z_GetnUniformfv_adr := GetProcAddress('glGetnUniformfv');
    private z_GetnUniformfv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr)>(z_GetnUniformfv_adr);
    private z_GetnUniformfv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; var &params: single)>(z_GetnUniformfv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformfv(&program: gl_program; location: Int32; bufSize: Int32; var &params: single) :=
    z_GetnUniformfv_2(&program, location, bufSize, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformfv(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr) :=
    z_GetnUniformfv_1(&program, location, bufSize, &params);
    
    private z_GetnUniformiv_adr := GetProcAddress('glGetnUniformiv');
    private z_GetnUniformiv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr)>(z_GetnUniformiv_adr);
    private z_GetnUniformiv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; var &params: Int32)>(z_GetnUniformiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformiv(&program: gl_program; location: Int32; bufSize: Int32; var &params: Int32) :=
    z_GetnUniformiv_2(&program, location, bufSize, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformiv(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr) :=
    z_GetnUniformiv_1(&program, location, bufSize, &params);
    
    private z_GetnUniformuiv_adr := GetProcAddress('glGetnUniformuiv');
    private z_GetnUniformuiv_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr)>(z_GetnUniformuiv_adr);
    private z_GetnUniformuiv_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; bufSize: Int32; var &params: UInt32)>(z_GetnUniformuiv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformuiv(&program: gl_program; location: Int32; bufSize: Int32; var &params: UInt32) :=
    z_GetnUniformuiv_2(&program, location, bufSize, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformuiv(&program: gl_program; location: Int32; bufSize: Int32; &params: IntPtr) :=
    z_GetnUniformuiv_1(&program, location, bufSize, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glParallelShaderCompileKHR = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_khr_parallel_shader_compile';
    
    private z_MaxShaderCompilerThreadsKHR_adr := GetProcAddress('glMaxShaderCompilerThreadsKHR');
    private z_MaxShaderCompilerThreadsKHR_1 := GetProcOrNil&<procedure(count: UInt32)>(z_MaxShaderCompilerThreadsKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MaxShaderCompilerThreadsKHR(count: UInt32) :=
    z_MaxShaderCompilerThreadsKHR_1(count);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glFramebufferFlipYMESA = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_mesa_framebuffer_flip_y';
    
    private z_FramebufferParameteriMESA_adr := GetProcAddress('glFramebufferParameteriMESA');
    private z_FramebufferParameteriMESA_1 := GetProcOrNil&<procedure(target: FramebufferTarget; pname: FramebufferParameterName; param: Int32)>(z_FramebufferParameteriMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferParameteriMESA(target: FramebufferTarget; pname: FramebufferParameterName; param: Int32) :=
    z_FramebufferParameteriMESA_1(target, pname, param);
    
    private z_GetFramebufferParameterivMESA_adr := GetProcAddress('glGetFramebufferParameterivMESA');
    private z_GetFramebufferParameterivMESA_1 := GetProcOrNil&<procedure(target: FramebufferTarget; pname: FramebufferAttachmentParameterName; &params: IntPtr)>(z_GetFramebufferParameterivMESA_adr);
    private z_GetFramebufferParameterivMESA_2 := GetProcOrNil&<procedure(target: FramebufferTarget; pname: FramebufferAttachmentParameterName; var &params: Int32)>(z_GetFramebufferParameterivMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferParameterivMESA(target: FramebufferTarget; pname: FramebufferAttachmentParameterName; var &params: Int32) :=
    z_GetFramebufferParameterivMESA_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferParameterivMESA(target: FramebufferTarget; pname: FramebufferAttachmentParameterName; &params: IntPtr) :=
    z_GetFramebufferParameterivMESA_1(target, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glResizeBuffersMESA = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_mesa_resize_buffers';
    
    private z_ResizeBuffersMESA_adr := GetProcAddress('glResizeBuffersMESA');
    private z_ResizeBuffersMESA_1 := GetProcOrNil&<procedure>(z_ResizeBuffersMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ResizeBuffersMESA :=
    z_ResizeBuffersMESA_1();
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glWindowPosMESA = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_mesa_window_pos';
    
    private z_WindowPos2dMESA_adr := GetProcAddress('glWindowPos2dMESA');
    private z_WindowPos2dMESA_1 := GetProcOrNil&<procedure(x: real; y: real)>(z_WindowPos2dMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dMESA(x: real; y: real) :=
    z_WindowPos2dMESA_1(x, y);
    
    private z_WindowPos2dvMESA_adr := GetProcAddress('glWindowPos2dvMESA');
    private z_WindowPos2dvMESA_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_WindowPos2dvMESA_adr);
    private z_WindowPos2dvMESA_2 := GetProcOrNil&<procedure(var v: real)>(z_WindowPos2dvMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dvMESA(v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_WindowPos2dvMESA_2(v[0]) else
        z_WindowPos2dvMESA_2(Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dvMESA(var v: real) :=
    z_WindowPos2dvMESA_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dvMESA(v: IntPtr) :=
    z_WindowPos2dvMESA_1(v);
    
    private z_WindowPos2fMESA_adr := GetProcAddress('glWindowPos2fMESA');
    private z_WindowPos2fMESA_1 := GetProcOrNil&<procedure(x: single; y: single)>(z_WindowPos2fMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fMESA(x: single; y: single) :=
    z_WindowPos2fMESA_1(x, y);
    
    private z_WindowPos2fvMESA_adr := GetProcAddress('glWindowPos2fvMESA');
    private z_WindowPos2fvMESA_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_WindowPos2fvMESA_adr);
    private z_WindowPos2fvMESA_2 := GetProcOrNil&<procedure(var v: single)>(z_WindowPos2fvMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fvMESA(v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_WindowPos2fvMESA_2(v[0]) else
        z_WindowPos2fvMESA_2(Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fvMESA(var v: single) :=
    z_WindowPos2fvMESA_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fvMESA(v: IntPtr) :=
    z_WindowPos2fvMESA_1(v);
    
    private z_WindowPos2iMESA_adr := GetProcAddress('glWindowPos2iMESA');
    private z_WindowPos2iMESA_1 := GetProcOrNil&<procedure(x: Int32; y: Int32)>(z_WindowPos2iMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2iMESA(x: Int32; y: Int32) :=
    z_WindowPos2iMESA_1(x, y);
    
    private z_WindowPos2ivMESA_adr := GetProcAddress('glWindowPos2ivMESA');
    private z_WindowPos2ivMESA_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_WindowPos2ivMESA_adr);
    private z_WindowPos2ivMESA_2 := GetProcOrNil&<procedure(var v: Int32)>(z_WindowPos2ivMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2ivMESA(v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_WindowPos2ivMESA_2(v[0]) else
        z_WindowPos2ivMESA_2(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2ivMESA(var v: Int32) :=
    z_WindowPos2ivMESA_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2ivMESA(v: IntPtr) :=
    z_WindowPos2ivMESA_1(v);
    
    private z_WindowPos2sMESA_adr := GetProcAddress('glWindowPos2sMESA');
    private z_WindowPos2sMESA_1 := GetProcOrNil&<procedure(x: Int16; y: Int16)>(z_WindowPos2sMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2sMESA(x: Int16; y: Int16) :=
    z_WindowPos2sMESA_1(x, y);
    
    private z_WindowPos2svMESA_adr := GetProcAddress('glWindowPos2svMESA');
    private z_WindowPos2svMESA_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_WindowPos2svMESA_adr);
    private z_WindowPos2svMESA_2 := GetProcOrNil&<procedure(var v: Int16)>(z_WindowPos2svMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2svMESA(v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_WindowPos2svMESA_2(v[0]) else
        z_WindowPos2svMESA_2(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2svMESA(var v: Int16) :=
    z_WindowPos2svMESA_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2svMESA(v: IntPtr) :=
    z_WindowPos2svMESA_1(v);
    
    private z_WindowPos3dMESA_adr := GetProcAddress('glWindowPos3dMESA');
    private z_WindowPos3dMESA_1 := GetProcOrNil&<procedure(x: real; y: real; z: real)>(z_WindowPos3dMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dMESA(x: real; y: real; z: real) :=
    z_WindowPos3dMESA_1(x, y, z);
    
    private z_WindowPos3dvMESA_adr := GetProcAddress('glWindowPos3dvMESA');
    private z_WindowPos3dvMESA_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_WindowPos3dvMESA_adr);
    private z_WindowPos3dvMESA_2 := GetProcOrNil&<procedure(var v: real)>(z_WindowPos3dvMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dvMESA(v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_WindowPos3dvMESA_2(v[0]) else
        z_WindowPos3dvMESA_2(Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dvMESA(var v: real) :=
    z_WindowPos3dvMESA_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dvMESA(v: IntPtr) :=
    z_WindowPos3dvMESA_1(v);
    
    private z_WindowPos3fMESA_adr := GetProcAddress('glWindowPos3fMESA');
    private z_WindowPos3fMESA_1 := GetProcOrNil&<procedure(x: single; y: single; z: single)>(z_WindowPos3fMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fMESA(x: single; y: single; z: single) :=
    z_WindowPos3fMESA_1(x, y, z);
    
    private z_WindowPos3fvMESA_adr := GetProcAddress('glWindowPos3fvMESA');
    private z_WindowPos3fvMESA_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_WindowPos3fvMESA_adr);
    private z_WindowPos3fvMESA_2 := GetProcOrNil&<procedure(var v: single)>(z_WindowPos3fvMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fvMESA(v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_WindowPos3fvMESA_2(v[0]) else
        z_WindowPos3fvMESA_2(Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fvMESA(var v: single) :=
    z_WindowPos3fvMESA_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fvMESA(v: IntPtr) :=
    z_WindowPos3fvMESA_1(v);
    
    private z_WindowPos3iMESA_adr := GetProcAddress('glWindowPos3iMESA');
    private z_WindowPos3iMESA_1 := GetProcOrNil&<procedure(x: Int32; y: Int32; z: Int32)>(z_WindowPos3iMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3iMESA(x: Int32; y: Int32; z: Int32) :=
    z_WindowPos3iMESA_1(x, y, z);
    
    private z_WindowPos3ivMESA_adr := GetProcAddress('glWindowPos3ivMESA');
    private z_WindowPos3ivMESA_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_WindowPos3ivMESA_adr);
    private z_WindowPos3ivMESA_2 := GetProcOrNil&<procedure(var v: Int32)>(z_WindowPos3ivMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3ivMESA(v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_WindowPos3ivMESA_2(v[0]) else
        z_WindowPos3ivMESA_2(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3ivMESA(var v: Int32) :=
    z_WindowPos3ivMESA_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3ivMESA(v: IntPtr) :=
    z_WindowPos3ivMESA_1(v);
    
    private z_WindowPos3sMESA_adr := GetProcAddress('glWindowPos3sMESA');
    private z_WindowPos3sMESA_1 := GetProcOrNil&<procedure(x: Int16; y: Int16; z: Int16)>(z_WindowPos3sMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3sMESA(x: Int16; y: Int16; z: Int16) :=
    z_WindowPos3sMESA_1(x, y, z);
    
    private z_WindowPos3svMESA_adr := GetProcAddress('glWindowPos3svMESA');
    private z_WindowPos3svMESA_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_WindowPos3svMESA_adr);
    private z_WindowPos3svMESA_2 := GetProcOrNil&<procedure(var v: Int16)>(z_WindowPos3svMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3svMESA(v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_WindowPos3svMESA_2(v[0]) else
        z_WindowPos3svMESA_2(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3svMESA(var v: Int16) :=
    z_WindowPos3svMESA_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3svMESA(v: IntPtr) :=
    z_WindowPos3svMESA_1(v);
    
    private z_WindowPos4dMESA_adr := GetProcAddress('glWindowPos4dMESA');
    private z_WindowPos4dMESA_1 := GetProcOrNil&<procedure(x: real; y: real; z: real; w: real)>(z_WindowPos4dMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4dMESA(x: real; y: real; z: real; w: real) :=
    z_WindowPos4dMESA_1(x, y, z, w);
    
    private z_WindowPos4dvMESA_adr := GetProcAddress('glWindowPos4dvMESA');
    private z_WindowPos4dvMESA_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_WindowPos4dvMESA_adr);
    private z_WindowPos4dvMESA_2 := GetProcOrNil&<procedure(var v: real)>(z_WindowPos4dvMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4dvMESA(v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_WindowPos4dvMESA_2(v[0]) else
        z_WindowPos4dvMESA_2(Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4dvMESA(var v: real) :=
    z_WindowPos4dvMESA_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4dvMESA(v: IntPtr) :=
    z_WindowPos4dvMESA_1(v);
    
    private z_WindowPos4fMESA_adr := GetProcAddress('glWindowPos4fMESA');
    private z_WindowPos4fMESA_1 := GetProcOrNil&<procedure(x: single; y: single; z: single; w: single)>(z_WindowPos4fMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4fMESA(x: single; y: single; z: single; w: single) :=
    z_WindowPos4fMESA_1(x, y, z, w);
    
    private z_WindowPos4fvMESA_adr := GetProcAddress('glWindowPos4fvMESA');
    private z_WindowPos4fvMESA_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_WindowPos4fvMESA_adr);
    private z_WindowPos4fvMESA_2 := GetProcOrNil&<procedure(var v: single)>(z_WindowPos4fvMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4fvMESA(v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_WindowPos4fvMESA_2(v[0]) else
        z_WindowPos4fvMESA_2(Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4fvMESA(var v: single) :=
    z_WindowPos4fvMESA_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4fvMESA(v: IntPtr) :=
    z_WindowPos4fvMESA_1(v);
    
    private z_WindowPos4iMESA_adr := GetProcAddress('glWindowPos4iMESA');
    private z_WindowPos4iMESA_1 := GetProcOrNil&<procedure(x: Int32; y: Int32; z: Int32; w: Int32)>(z_WindowPos4iMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4iMESA(x: Int32; y: Int32; z: Int32; w: Int32) :=
    z_WindowPos4iMESA_1(x, y, z, w);
    
    private z_WindowPos4ivMESA_adr := GetProcAddress('glWindowPos4ivMESA');
    private z_WindowPos4ivMESA_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_WindowPos4ivMESA_adr);
    private z_WindowPos4ivMESA_2 := GetProcOrNil&<procedure(var v: Int32)>(z_WindowPos4ivMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4ivMESA(v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_WindowPos4ivMESA_2(v[0]) else
        z_WindowPos4ivMESA_2(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4ivMESA(var v: Int32) :=
    z_WindowPos4ivMESA_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4ivMESA(v: IntPtr) :=
    z_WindowPos4ivMESA_1(v);
    
    private z_WindowPos4sMESA_adr := GetProcAddress('glWindowPos4sMESA');
    private z_WindowPos4sMESA_1 := GetProcOrNil&<procedure(x: Int16; y: Int16; z: Int16; w: Int16)>(z_WindowPos4sMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4sMESA(x: Int16; y: Int16; z: Int16; w: Int16) :=
    z_WindowPos4sMESA_1(x, y, z, w);
    
    private z_WindowPos4svMESA_adr := GetProcAddress('glWindowPos4svMESA');
    private z_WindowPos4svMESA_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_WindowPos4svMESA_adr);
    private z_WindowPos4svMESA_2 := GetProcOrNil&<procedure(var v: Int16)>(z_WindowPos4svMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4svMESA(v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_WindowPos4svMESA_2(v[0]) else
        z_WindowPos4svMESA_2(PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4svMESA(var v: Int16) :=
    z_WindowPos4svMESA_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4svMESA(v: IntPtr) :=
    z_WindowPos4svMESA_1(v);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glConditionalRenderNVX = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nvx_conditional_render';
    
    private z_BeginConditionalRenderNVX_adr := GetProcAddress('glBeginConditionalRenderNVX');
    private z_BeginConditionalRenderNVX_1 := GetProcOrNil&<procedure(id: UInt32)>(z_BeginConditionalRenderNVX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginConditionalRenderNVX(id: UInt32) :=
    z_BeginConditionalRenderNVX_1(id);
    
    private z_EndConditionalRenderNVX_adr := GetProcAddress('glEndConditionalRenderNVX');
    private z_EndConditionalRenderNVX_1 := GetProcOrNil&<procedure>(z_EndConditionalRenderNVX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndConditionalRenderNVX :=
    z_EndConditionalRenderNVX_1();
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glLinkedGpuMulticastNVX = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nvx_linked_gpu_multicast';
    
    private z_LGPUNamedBufferSubDataNVX_adr := GetProcAddress('glLGPUNamedBufferSubDataNVX');
    private z_LGPUNamedBufferSubDataNVX_1 := GetProcOrNil&<procedure(gpuMask: DummyFlags; buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: IntPtr)>(z_LGPUNamedBufferSubDataNVX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LGPUNamedBufferSubDataNVX(gpuMask: DummyFlags; buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: IntPtr) :=
    z_LGPUNamedBufferSubDataNVX_1(gpuMask, buffer, offset, size, data);
    
    private z_LGPUCopyImageSubDataNVX_adr := GetProcAddress('glLGPUCopyImageSubDataNVX');
    private z_LGPUCopyImageSubDataNVX_1 := GetProcOrNil&<procedure(sourceGpu: UInt32; destinationGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srxY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; width: Int32; height: Int32; depth: Int32)>(z_LGPUCopyImageSubDataNVX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LGPUCopyImageSubDataNVX(sourceGpu: UInt32; destinationGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srxY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; width: Int32; height: Int32; depth: Int32) :=
    z_LGPUCopyImageSubDataNVX_1(sourceGpu, destinationGpuMask, srcName, srcTarget, srcLevel, srcX, srxY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
    
    private z_LGPUInterlockNVX_adr := GetProcAddress('glLGPUInterlockNVX');
    private z_LGPUInterlockNVX_1 := GetProcOrNil&<procedure>(z_LGPUInterlockNVX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LGPUInterlockNVX :=
    z_LGPUInterlockNVX_1();
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glAlphaToCoverageDitherControlNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_alpha_to_coverage_dither_control';
    
    private z_AlphaToCoverageDitherControlNV_adr := GetProcAddress('glAlphaToCoverageDitherControlNV');
    private z_AlphaToCoverageDitherControlNV_1 := GetProcOrNil&<procedure(mode: DummyEnum)>(z_AlphaToCoverageDitherControlNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AlphaToCoverageDitherControlNV(mode: DummyEnum) :=
    z_AlphaToCoverageDitherControlNV_1(mode);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glBindlessMultiDrawIndirectNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_bindless_multi_draw_indirect';
    
    private z_MultiDrawArraysIndirectBindlessNV_adr := GetProcAddress('glMultiDrawArraysIndirectBindlessNV');
    private z_MultiDrawArraysIndirectBindlessNV_1 := GetProcOrNil&<procedure(mode: PrimitiveType; indirect: IntPtr; drawCount: Int32; stride: Int32; vertexBufferCount: Int32)>(z_MultiDrawArraysIndirectBindlessNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysIndirectBindlessNV(mode: PrimitiveType; indirect: IntPtr; drawCount: Int32; stride: Int32; vertexBufferCount: Int32) :=
    z_MultiDrawArraysIndirectBindlessNV_1(mode, indirect, drawCount, stride, vertexBufferCount);
    
    private z_MultiDrawElementsIndirectBindlessNV_adr := GetProcAddress('glMultiDrawElementsIndirectBindlessNV');
    private z_MultiDrawElementsIndirectBindlessNV_1 := GetProcOrNil&<procedure(mode: PrimitiveType; &type: DrawElementsType; indirect: IntPtr; drawCount: Int32; stride: Int32; vertexBufferCount: Int32)>(z_MultiDrawElementsIndirectBindlessNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsIndirectBindlessNV(mode: PrimitiveType; &type: DrawElementsType; indirect: IntPtr; drawCount: Int32; stride: Int32; vertexBufferCount: Int32) :=
    z_MultiDrawElementsIndirectBindlessNV_1(mode, &type, indirect, drawCount, stride, vertexBufferCount);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glBindlessMultiDrawIndirectCountNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_bindless_multi_draw_indirect_count';
    
    private z_MultiDrawArraysIndirectBindlessCountNV_adr := GetProcAddress('glMultiDrawArraysIndirectBindlessCountNV');
    private z_MultiDrawArraysIndirectBindlessCountNV_1 := GetProcOrNil&<procedure(mode: PrimitiveType; indirect: IntPtr; drawCount: Int32; maxDrawCount: Int32; stride: Int32; vertexBufferCount: Int32)>(z_MultiDrawArraysIndirectBindlessCountNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysIndirectBindlessCountNV(mode: PrimitiveType; indirect: IntPtr; drawCount: Int32; maxDrawCount: Int32; stride: Int32; vertexBufferCount: Int32) :=
    z_MultiDrawArraysIndirectBindlessCountNV_1(mode, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
    
    private z_MultiDrawElementsIndirectBindlessCountNV_adr := GetProcAddress('glMultiDrawElementsIndirectBindlessCountNV');
    private z_MultiDrawElementsIndirectBindlessCountNV_1 := GetProcOrNil&<procedure(mode: PrimitiveType; &type: DrawElementsType; indirect: IntPtr; drawCount: Int32; maxDrawCount: Int32; stride: Int32; vertexBufferCount: Int32)>(z_MultiDrawElementsIndirectBindlessCountNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsIndirectBindlessCountNV(mode: PrimitiveType; &type: DrawElementsType; indirect: IntPtr; drawCount: Int32; maxDrawCount: Int32; stride: Int32; vertexBufferCount: Int32) :=
    z_MultiDrawElementsIndirectBindlessCountNV_1(mode, &type, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glBindlessTextureNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_bindless_texture';
    
    private z_GetTextureHandleNV_adr := GetProcAddress('glGetTextureHandleNV');
    private z_GetTextureHandleNV_1 := GetProcOrNil&<function(texture: gl_texture): UInt64>(z_GetTextureHandleNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetTextureHandleNV(texture: gl_texture): UInt64 :=
    z_GetTextureHandleNV_1(texture);
    
    private z_GetTextureSamplerHandleNV_adr := GetProcAddress('glGetTextureSamplerHandleNV');
    private z_GetTextureSamplerHandleNV_1 := GetProcOrNil&<function(texture: gl_texture; sampler: gl_sampler): UInt64>(z_GetTextureSamplerHandleNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetTextureSamplerHandleNV(texture: gl_texture; sampler: gl_sampler): UInt64 :=
    z_GetTextureSamplerHandleNV_1(texture, sampler);
    
    private z_MakeTextureHandleResidentNV_adr := GetProcAddress('glMakeTextureHandleResidentNV');
    private z_MakeTextureHandleResidentNV_1 := GetProcOrNil&<procedure(handle: UInt64)>(z_MakeTextureHandleResidentNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeTextureHandleResidentNV(handle: UInt64) :=
    z_MakeTextureHandleResidentNV_1(handle);
    
    private z_MakeTextureHandleNonResidentNV_adr := GetProcAddress('glMakeTextureHandleNonResidentNV');
    private z_MakeTextureHandleNonResidentNV_1 := GetProcOrNil&<procedure(handle: UInt64)>(z_MakeTextureHandleNonResidentNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeTextureHandleNonResidentNV(handle: UInt64) :=
    z_MakeTextureHandleNonResidentNV_1(handle);
    
    private z_GetImageHandleNV_adr := GetProcAddress('glGetImageHandleNV');
    private z_GetImageHandleNV_1 := GetProcOrNil&<function(texture: gl_texture; level: Int32; layered: boolean; layer: Int32; format: PixelFormat): UInt64>(z_GetImageHandleNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetImageHandleNV(texture: gl_texture; level: Int32; layered: boolean; layer: Int32; format: PixelFormat): UInt64 :=
    z_GetImageHandleNV_1(texture, level, layered, layer, format);
    
    private z_MakeImageHandleResidentNV_adr := GetProcAddress('glMakeImageHandleResidentNV');
    private z_MakeImageHandleResidentNV_1 := GetProcOrNil&<procedure(handle: UInt64; access: DummyEnum)>(z_MakeImageHandleResidentNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeImageHandleResidentNV(handle: UInt64; access: DummyEnum) :=
    z_MakeImageHandleResidentNV_1(handle, access);
    
    private z_MakeImageHandleNonResidentNV_adr := GetProcAddress('glMakeImageHandleNonResidentNV');
    private z_MakeImageHandleNonResidentNV_1 := GetProcOrNil&<procedure(handle: UInt64)>(z_MakeImageHandleNonResidentNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeImageHandleNonResidentNV(handle: UInt64) :=
    z_MakeImageHandleNonResidentNV_1(handle);
    
    private z_UniformHandleui64NV_adr := GetProcAddress('glUniformHandleui64NV');
    private z_UniformHandleui64NV_1 := GetProcOrNil&<procedure(location: Int32; value: UInt64)>(z_UniformHandleui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformHandleui64NV(location: Int32; value: UInt64) :=
    z_UniformHandleui64NV_1(location, value);
    
    private z_UniformHandleui64vNV_adr := GetProcAddress('glUniformHandleui64vNV');
    private z_UniformHandleui64vNV_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_UniformHandleui64vNV_adr);
    private z_UniformHandleui64vNV_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt64)>(z_UniformHandleui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformHandleui64vNV(location: Int32; count: Int32; value: array of UInt64);
    type PUInt64=^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_UniformHandleui64vNV_2(location, count, value[0]) else
        z_UniformHandleui64vNV_2(location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformHandleui64vNV(location: Int32; count: Int32; var value: UInt64) :=
    z_UniformHandleui64vNV_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformHandleui64vNV(location: Int32; count: Int32; value: IntPtr) :=
    z_UniformHandleui64vNV_1(location, count, value);
    
    private z_ProgramUniformHandleui64NV_adr := GetProcAddress('glProgramUniformHandleui64NV');
    private z_ProgramUniformHandleui64NV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; value: UInt64)>(z_ProgramUniformHandleui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformHandleui64NV(&program: gl_program; location: Int32; value: UInt64) :=
    z_ProgramUniformHandleui64NV_1(&program, location, value);
    
    private z_ProgramUniformHandleui64vNV_adr := GetProcAddress('glProgramUniformHandleui64vNV');
    private z_ProgramUniformHandleui64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; values: IntPtr)>(z_ProgramUniformHandleui64vNV_adr);
    private z_ProgramUniformHandleui64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var values: UInt64)>(z_ProgramUniformHandleui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformHandleui64vNV(&program: gl_program; location: Int32; count: Int32; values: array of UInt64);
    type PUInt64=^UInt64;
    begin
      if (values<>nil) and (values.Length<>0) then
        z_ProgramUniformHandleui64vNV_2(&program, location, count, values[0]) else
        z_ProgramUniformHandleui64vNV_2(&program, location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformHandleui64vNV(&program: gl_program; location: Int32; count: Int32; var values: UInt64) :=
    z_ProgramUniformHandleui64vNV_2(&program, location, count, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformHandleui64vNV(&program: gl_program; location: Int32; count: Int32; values: IntPtr) :=
    z_ProgramUniformHandleui64vNV_1(&program, location, count, values);
    
    private z_IsTextureHandleResidentNV_adr := GetProcAddress('glIsTextureHandleResidentNV');
    private z_IsTextureHandleResidentNV_1 := GetProcOrNil&<function(handle: UInt64): boolean>(z_IsTextureHandleResidentNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsTextureHandleResidentNV(handle: UInt64): boolean :=
    z_IsTextureHandleResidentNV_1(handle);
    
    private z_IsImageHandleResidentNV_adr := GetProcAddress('glIsImageHandleResidentNV');
    private z_IsImageHandleResidentNV_1 := GetProcOrNil&<function(handle: UInt64): boolean>(z_IsImageHandleResidentNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsImageHandleResidentNV(handle: UInt64): boolean :=
    z_IsImageHandleResidentNV_1(handle);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glBlendEquationAdvancedNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_blend_equation_advanced';
    
    private z_BlendParameteriNV_adr := GetProcAddress('glBlendParameteriNV');
    private z_BlendParameteriNV_1 := GetProcOrNil&<procedure(pname: DummyEnum; value: Int32)>(z_BlendParameteriNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendParameteriNV(pname: DummyEnum; value: Int32) :=
    z_BlendParameteriNV_1(pname, value);
    
    private z_BlendBarrierNV_adr := GetProcAddress('glBlendBarrierNV');
    private z_BlendBarrierNV_1 := GetProcOrNil&<procedure>(z_BlendBarrierNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendBarrierNV :=
    z_BlendBarrierNV_1();
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glClipSpaceWScalingNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_clip_space_w_scaling';
    
    private z_ViewportPositionWScaleNV_adr := GetProcAddress('glViewportPositionWScaleNV');
    private z_ViewportPositionWScaleNV_1 := GetProcOrNil&<procedure(index: UInt32; xcoeff: single; ycoeff: single)>(z_ViewportPositionWScaleNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportPositionWScaleNV(index: UInt32; xcoeff: single; ycoeff: single) :=
    z_ViewportPositionWScaleNV_1(index, xcoeff, ycoeff);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glCommandListNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_command_list';
    
    private z_CreateStatesNV_adr := GetProcAddress('glCreateStatesNV');
    private z_CreateStatesNV_1 := GetProcOrNil&<procedure(n: Int32; states: IntPtr)>(z_CreateStatesNV_adr);
    private z_CreateStatesNV_2 := GetProcOrNil&<procedure(n: Int32; var states: UInt32)>(z_CreateStatesNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateStatesNV(n: Int32; states: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (states<>nil) and (states.Length<>0) then
        z_CreateStatesNV_2(n, states[0]) else
        z_CreateStatesNV_2(n, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateStatesNV(n: Int32; var states: UInt32) :=
    z_CreateStatesNV_2(n, states);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateStatesNV(n: Int32; states: IntPtr) :=
    z_CreateStatesNV_1(n, states);
    
    private z_DeleteStatesNV_adr := GetProcAddress('glDeleteStatesNV');
    private z_DeleteStatesNV_1 := GetProcOrNil&<procedure(n: Int32; states: IntPtr)>(z_DeleteStatesNV_adr);
    private z_DeleteStatesNV_2 := GetProcOrNil&<procedure(n: Int32; var states: UInt32)>(z_DeleteStatesNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteStatesNV(n: Int32; states: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (states<>nil) and (states.Length<>0) then
        z_DeleteStatesNV_2(n, states[0]) else
        z_DeleteStatesNV_2(n, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteStatesNV(n: Int32; var states: UInt32) :=
    z_DeleteStatesNV_2(n, states);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteStatesNV(n: Int32; states: IntPtr) :=
    z_DeleteStatesNV_1(n, states);
    
    private z_IsStateNV_adr := GetProcAddress('glIsStateNV');
    private z_IsStateNV_1 := GetProcOrNil&<function(state: UInt32): boolean>(z_IsStateNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsStateNV(state: UInt32): boolean :=
    z_IsStateNV_1(state);
    
    private z_StateCaptureNV_adr := GetProcAddress('glStateCaptureNV');
    private z_StateCaptureNV_1 := GetProcOrNil&<procedure(state: UInt32; mode: DummyEnum)>(z_StateCaptureNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StateCaptureNV(state: UInt32; mode: DummyEnum) :=
    z_StateCaptureNV_1(state, mode);
    
    private z_GetCommandHeaderNV_adr := GetProcAddress('glGetCommandHeaderNV');
    private z_GetCommandHeaderNV_1 := GetProcOrNil&<function(tokenID: CommandOpcodes; size: UInt32): UInt32>(z_GetCommandHeaderNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCommandHeaderNV(tokenID: CommandOpcodes; size: UInt32): UInt32 :=
    z_GetCommandHeaderNV_1(tokenID, size);
    
    private z_GetStageIndexNV_adr := GetProcAddress('glGetStageIndexNV');
    private z_GetStageIndexNV_1 := GetProcOrNil&<function(_shadertype: ShaderType): UInt16>(z_GetStageIndexNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetStageIndexNV(_shadertype: ShaderType): UInt16 :=
    z_GetStageIndexNV_1(_shadertype);
    
    private z_DrawCommandsNV_adr := GetProcAddress('glDrawCommandsNV');
    private z_DrawCommandsNV_1 := GetProcOrNil&<procedure(primitiveMode: DummyEnum; buffer: UInt32; indirects: pointer; sizes: IntPtr; count: UInt32)>(z_DrawCommandsNV_adr);
    private z_DrawCommandsNV_2 := GetProcOrNil&<procedure(primitiveMode: DummyEnum; buffer: UInt32; indirects: pointer; var sizes: Int32; count: UInt32)>(z_DrawCommandsNV_adr);
    private z_DrawCommandsNV_3 := GetProcOrNil&<procedure(primitiveMode: DummyEnum; buffer: UInt32; var indirects: IntPtr; sizes: IntPtr; count: UInt32)>(z_DrawCommandsNV_adr);
    private z_DrawCommandsNV_4 := GetProcOrNil&<procedure(primitiveMode: DummyEnum; buffer: UInt32; var indirects: IntPtr; var sizes: Int32; count: UInt32)>(z_DrawCommandsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsNV(primitiveMode: DummyEnum; buffer: UInt32; indirects: array of IntPtr; sizes: array of Int32; count: UInt32);
    type PIntPtr=^IntPtr;
    type PInt32=^Int32;
    begin
      if (sizes<>nil) and (sizes.Length<>0) then
        if (indirects<>nil) and (indirects.Length<>0) then
          z_DrawCommandsNV_4(primitiveMode, buffer, indirects[0], sizes[0], count) else
          z_DrawCommandsNV_4(primitiveMode, buffer, PIntPtr(nil)^, sizes[0], count) else
        if (indirects<>nil) and (indirects.Length<>0) then
          z_DrawCommandsNV_4(primitiveMode, buffer, indirects[0], PInt32(nil)^, count) else
          z_DrawCommandsNV_4(primitiveMode, buffer, PIntPtr(nil)^, PInt32(nil)^, count);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsNV(primitiveMode: DummyEnum; buffer: UInt32; var indirects: IntPtr; var sizes: Int32; count: UInt32) :=
    z_DrawCommandsNV_4(primitiveMode, buffer, indirects, sizes, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsNV(primitiveMode: DummyEnum; buffer: UInt32; var indirects: IntPtr; sizes: IntPtr; count: UInt32) :=
    z_DrawCommandsNV_3(primitiveMode, buffer, indirects, sizes, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsNV(primitiveMode: DummyEnum; buffer: UInt32; indirects: pointer; var sizes: Int32; count: UInt32) :=
    z_DrawCommandsNV_2(primitiveMode, buffer, indirects, sizes, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsNV(primitiveMode: DummyEnum; buffer: UInt32; indirects: pointer; sizes: IntPtr; count: UInt32) :=
    z_DrawCommandsNV_1(primitiveMode, buffer, indirects, sizes, count);
    
    private z_DrawCommandsAddressNV_adr := GetProcAddress('glDrawCommandsAddressNV');
    private z_DrawCommandsAddressNV_1 := GetProcOrNil&<procedure(primitiveMode: DummyEnum; indirects: IntPtr; sizes: IntPtr; count: UInt32)>(z_DrawCommandsAddressNV_adr);
    private z_DrawCommandsAddressNV_2 := GetProcOrNil&<procedure(primitiveMode: DummyEnum; indirects: IntPtr; var sizes: Int32; count: UInt32)>(z_DrawCommandsAddressNV_adr);
    private z_DrawCommandsAddressNV_3 := GetProcOrNil&<procedure(primitiveMode: DummyEnum; var indirects: UInt64; sizes: IntPtr; count: UInt32)>(z_DrawCommandsAddressNV_adr);
    private z_DrawCommandsAddressNV_4 := GetProcOrNil&<procedure(primitiveMode: DummyEnum; var indirects: UInt64; var sizes: Int32; count: UInt32)>(z_DrawCommandsAddressNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsAddressNV(primitiveMode: DummyEnum; indirects: array of UInt64; sizes: array of Int32; count: UInt32);
    type PUInt64=^UInt64;
    type PInt32=^Int32;
    begin
      if (sizes<>nil) and (sizes.Length<>0) then
        if (indirects<>nil) and (indirects.Length<>0) then
          z_DrawCommandsAddressNV_4(primitiveMode, indirects[0], sizes[0], count) else
          z_DrawCommandsAddressNV_4(primitiveMode, PUInt64(nil)^, sizes[0], count) else
        if (indirects<>nil) and (indirects.Length<>0) then
          z_DrawCommandsAddressNV_4(primitiveMode, indirects[0], PInt32(nil)^, count) else
          z_DrawCommandsAddressNV_4(primitiveMode, PUInt64(nil)^, PInt32(nil)^, count);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsAddressNV(primitiveMode: DummyEnum; var indirects: UInt64; var sizes: Int32; count: UInt32) :=
    z_DrawCommandsAddressNV_4(primitiveMode, indirects, sizes, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsAddressNV(primitiveMode: DummyEnum; var indirects: UInt64; sizes: IntPtr; count: UInt32) :=
    z_DrawCommandsAddressNV_3(primitiveMode, indirects, sizes, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsAddressNV(primitiveMode: DummyEnum; indirects: IntPtr; var sizes: Int32; count: UInt32) :=
    z_DrawCommandsAddressNV_2(primitiveMode, indirects, sizes, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsAddressNV(primitiveMode: DummyEnum; indirects: IntPtr; sizes: IntPtr; count: UInt32) :=
    z_DrawCommandsAddressNV_1(primitiveMode, indirects, sizes, count);
    
    private z_DrawCommandsStatesNV_adr := GetProcAddress('glDrawCommandsStatesNV');
    private z_DrawCommandsStatesNV_1 := GetProcOrNil&<procedure(buffer: gl_buffer; indirects: pointer; sizes: IntPtr; states: IntPtr; fbos: IntPtr; count: UInt32)>(z_DrawCommandsStatesNV_adr);
    private z_DrawCommandsStatesNV_2 := GetProcOrNil&<procedure(buffer: gl_buffer; indirects: pointer; sizes: IntPtr; states: IntPtr; var fbos: UInt32; count: UInt32)>(z_DrawCommandsStatesNV_adr);
    private z_DrawCommandsStatesNV_3 := GetProcOrNil&<procedure(buffer: gl_buffer; indirects: pointer; sizes: IntPtr; var states: UInt32; fbos: IntPtr; count: UInt32)>(z_DrawCommandsStatesNV_adr);
    private z_DrawCommandsStatesNV_4 := GetProcOrNil&<procedure(buffer: gl_buffer; indirects: pointer; sizes: IntPtr; var states: UInt32; var fbos: UInt32; count: UInt32)>(z_DrawCommandsStatesNV_adr);
    private z_DrawCommandsStatesNV_5 := GetProcOrNil&<procedure(buffer: gl_buffer; indirects: pointer; var sizes: Int32; states: IntPtr; fbos: IntPtr; count: UInt32)>(z_DrawCommandsStatesNV_adr);
    private z_DrawCommandsStatesNV_6 := GetProcOrNil&<procedure(buffer: gl_buffer; indirects: pointer; var sizes: Int32; states: IntPtr; var fbos: UInt32; count: UInt32)>(z_DrawCommandsStatesNV_adr);
    private z_DrawCommandsStatesNV_7 := GetProcOrNil&<procedure(buffer: gl_buffer; indirects: pointer; var sizes: Int32; var states: UInt32; fbos: IntPtr; count: UInt32)>(z_DrawCommandsStatesNV_adr);
    private z_DrawCommandsStatesNV_8 := GetProcOrNil&<procedure(buffer: gl_buffer; indirects: pointer; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32)>(z_DrawCommandsStatesNV_adr);
    private z_DrawCommandsStatesNV_9 := GetProcOrNil&<procedure(buffer: gl_buffer; var indirects: IntPtr; sizes: IntPtr; states: IntPtr; fbos: IntPtr; count: UInt32)>(z_DrawCommandsStatesNV_adr);
    private z_DrawCommandsStatesNV_10 := GetProcOrNil&<procedure(buffer: gl_buffer; var indirects: IntPtr; sizes: IntPtr; states: IntPtr; var fbos: UInt32; count: UInt32)>(z_DrawCommandsStatesNV_adr);
    private z_DrawCommandsStatesNV_11 := GetProcOrNil&<procedure(buffer: gl_buffer; var indirects: IntPtr; sizes: IntPtr; var states: UInt32; fbos: IntPtr; count: UInt32)>(z_DrawCommandsStatesNV_adr);
    private z_DrawCommandsStatesNV_12 := GetProcOrNil&<procedure(buffer: gl_buffer; var indirects: IntPtr; sizes: IntPtr; var states: UInt32; var fbos: UInt32; count: UInt32)>(z_DrawCommandsStatesNV_adr);
    private z_DrawCommandsStatesNV_13 := GetProcOrNil&<procedure(buffer: gl_buffer; var indirects: IntPtr; var sizes: Int32; states: IntPtr; fbos: IntPtr; count: UInt32)>(z_DrawCommandsStatesNV_adr);
    private z_DrawCommandsStatesNV_14 := GetProcOrNil&<procedure(buffer: gl_buffer; var indirects: IntPtr; var sizes: Int32; states: IntPtr; var fbos: UInt32; count: UInt32)>(z_DrawCommandsStatesNV_adr);
    private z_DrawCommandsStatesNV_15 := GetProcOrNil&<procedure(buffer: gl_buffer; var indirects: IntPtr; var sizes: Int32; var states: UInt32; fbos: IntPtr; count: UInt32)>(z_DrawCommandsStatesNV_adr);
    private z_DrawCommandsStatesNV_16 := GetProcOrNil&<procedure(buffer: gl_buffer; var indirects: IntPtr; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32)>(z_DrawCommandsStatesNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: gl_buffer; indirects: array of IntPtr; sizes: array of Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32);
    type PIntPtr=^IntPtr;
    type PInt32=^Int32;
    type PUInt32=^UInt32;
    begin
      if (fbos<>nil) and (fbos.Length<>0) then
        if (states<>nil) and (states.Length<>0) then
          if (sizes<>nil) and (sizes.Length<>0) then
            if (indirects<>nil) and (indirects.Length<>0) then
              z_DrawCommandsStatesNV_16(buffer, indirects[0], sizes[0], states[0], fbos[0], count) else
              z_DrawCommandsStatesNV_16(buffer, PIntPtr(nil)^, sizes[0], states[0], fbos[0], count) else
            if (indirects<>nil) and (indirects.Length<>0) then
              z_DrawCommandsStatesNV_16(buffer, indirects[0], PInt32(nil)^, states[0], fbos[0], count) else
              z_DrawCommandsStatesNV_16(buffer, PIntPtr(nil)^, PInt32(nil)^, states[0], fbos[0], count) else
          if (sizes<>nil) and (sizes.Length<>0) then
            if (indirects<>nil) and (indirects.Length<>0) then
              z_DrawCommandsStatesNV_16(buffer, indirects[0], sizes[0], PUInt32(nil)^, fbos[0], count) else
              z_DrawCommandsStatesNV_16(buffer, PIntPtr(nil)^, sizes[0], PUInt32(nil)^, fbos[0], count) else
            if (indirects<>nil) and (indirects.Length<>0) then
              z_DrawCommandsStatesNV_16(buffer, indirects[0], PInt32(nil)^, PUInt32(nil)^, fbos[0], count) else
              z_DrawCommandsStatesNV_16(buffer, PIntPtr(nil)^, PInt32(nil)^, PUInt32(nil)^, fbos[0], count) else
        if (states<>nil) and (states.Length<>0) then
          if (sizes<>nil) and (sizes.Length<>0) then
            if (indirects<>nil) and (indirects.Length<>0) then
              z_DrawCommandsStatesNV_16(buffer, indirects[0], sizes[0], states[0], PUInt32(nil)^, count) else
              z_DrawCommandsStatesNV_16(buffer, PIntPtr(nil)^, sizes[0], states[0], PUInt32(nil)^, count) else
            if (indirects<>nil) and (indirects.Length<>0) then
              z_DrawCommandsStatesNV_16(buffer, indirects[0], PInt32(nil)^, states[0], PUInt32(nil)^, count) else
              z_DrawCommandsStatesNV_16(buffer, PIntPtr(nil)^, PInt32(nil)^, states[0], PUInt32(nil)^, count) else
          if (sizes<>nil) and (sizes.Length<>0) then
            if (indirects<>nil) and (indirects.Length<>0) then
              z_DrawCommandsStatesNV_16(buffer, indirects[0], sizes[0], PUInt32(nil)^, PUInt32(nil)^, count) else
              z_DrawCommandsStatesNV_16(buffer, PIntPtr(nil)^, sizes[0], PUInt32(nil)^, PUInt32(nil)^, count) else
            if (indirects<>nil) and (indirects.Length<>0) then
              z_DrawCommandsStatesNV_16(buffer, indirects[0], PInt32(nil)^, PUInt32(nil)^, PUInt32(nil)^, count) else
              z_DrawCommandsStatesNV_16(buffer, PIntPtr(nil)^, PInt32(nil)^, PUInt32(nil)^, PUInt32(nil)^, count);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: gl_buffer; var indirects: IntPtr; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32) :=
    z_DrawCommandsStatesNV_16(buffer, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: gl_buffer; var indirects: IntPtr; var sizes: Int32; var states: UInt32; fbos: IntPtr; count: UInt32) :=
    z_DrawCommandsStatesNV_15(buffer, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: gl_buffer; var indirects: IntPtr; var sizes: Int32; states: IntPtr; var fbos: UInt32; count: UInt32) :=
    z_DrawCommandsStatesNV_14(buffer, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: gl_buffer; var indirects: IntPtr; var sizes: Int32; states: IntPtr; fbos: IntPtr; count: UInt32) :=
    z_DrawCommandsStatesNV_13(buffer, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: gl_buffer; var indirects: IntPtr; sizes: IntPtr; var states: UInt32; var fbos: UInt32; count: UInt32) :=
    z_DrawCommandsStatesNV_12(buffer, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: gl_buffer; var indirects: IntPtr; sizes: IntPtr; var states: UInt32; fbos: IntPtr; count: UInt32) :=
    z_DrawCommandsStatesNV_11(buffer, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: gl_buffer; var indirects: IntPtr; sizes: IntPtr; states: IntPtr; var fbos: UInt32; count: UInt32) :=
    z_DrawCommandsStatesNV_10(buffer, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: gl_buffer; var indirects: IntPtr; sizes: IntPtr; states: IntPtr; fbos: IntPtr; count: UInt32) :=
    z_DrawCommandsStatesNV_9(buffer, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: gl_buffer; indirects: pointer; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32) :=
    z_DrawCommandsStatesNV_8(buffer, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: gl_buffer; indirects: pointer; var sizes: Int32; var states: UInt32; fbos: IntPtr; count: UInt32) :=
    z_DrawCommandsStatesNV_7(buffer, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: gl_buffer; indirects: pointer; var sizes: Int32; states: IntPtr; var fbos: UInt32; count: UInt32) :=
    z_DrawCommandsStatesNV_6(buffer, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: gl_buffer; indirects: pointer; var sizes: Int32; states: IntPtr; fbos: IntPtr; count: UInt32) :=
    z_DrawCommandsStatesNV_5(buffer, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: gl_buffer; indirects: pointer; sizes: IntPtr; var states: UInt32; var fbos: UInt32; count: UInt32) :=
    z_DrawCommandsStatesNV_4(buffer, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: gl_buffer; indirects: pointer; sizes: IntPtr; var states: UInt32; fbos: IntPtr; count: UInt32) :=
    z_DrawCommandsStatesNV_3(buffer, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: gl_buffer; indirects: pointer; sizes: IntPtr; states: IntPtr; var fbos: UInt32; count: UInt32) :=
    z_DrawCommandsStatesNV_2(buffer, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: gl_buffer; indirects: pointer; sizes: IntPtr; states: IntPtr; fbos: IntPtr; count: UInt32) :=
    z_DrawCommandsStatesNV_1(buffer, indirects, sizes, states, fbos, count);
    
    private z_DrawCommandsStatesAddressNV_adr := GetProcAddress('glDrawCommandsStatesAddressNV');
    private z_DrawCommandsStatesAddressNV_1 := GetProcOrNil&<procedure(indirects: IntPtr; sizes: IntPtr; states: IntPtr; fbos: IntPtr; count: UInt32)>(z_DrawCommandsStatesAddressNV_adr);
    private z_DrawCommandsStatesAddressNV_2 := GetProcOrNil&<procedure(indirects: IntPtr; sizes: IntPtr; states: IntPtr; var fbos: UInt32; count: UInt32)>(z_DrawCommandsStatesAddressNV_adr);
    private z_DrawCommandsStatesAddressNV_3 := GetProcOrNil&<procedure(indirects: IntPtr; sizes: IntPtr; var states: UInt32; fbos: IntPtr; count: UInt32)>(z_DrawCommandsStatesAddressNV_adr);
    private z_DrawCommandsStatesAddressNV_4 := GetProcOrNil&<procedure(indirects: IntPtr; sizes: IntPtr; var states: UInt32; var fbos: UInt32; count: UInt32)>(z_DrawCommandsStatesAddressNV_adr);
    private z_DrawCommandsStatesAddressNV_5 := GetProcOrNil&<procedure(indirects: IntPtr; var sizes: Int32; states: IntPtr; fbos: IntPtr; count: UInt32)>(z_DrawCommandsStatesAddressNV_adr);
    private z_DrawCommandsStatesAddressNV_6 := GetProcOrNil&<procedure(indirects: IntPtr; var sizes: Int32; states: IntPtr; var fbos: UInt32; count: UInt32)>(z_DrawCommandsStatesAddressNV_adr);
    private z_DrawCommandsStatesAddressNV_7 := GetProcOrNil&<procedure(indirects: IntPtr; var sizes: Int32; var states: UInt32; fbos: IntPtr; count: UInt32)>(z_DrawCommandsStatesAddressNV_adr);
    private z_DrawCommandsStatesAddressNV_8 := GetProcOrNil&<procedure(indirects: IntPtr; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32)>(z_DrawCommandsStatesAddressNV_adr);
    private z_DrawCommandsStatesAddressNV_9 := GetProcOrNil&<procedure(var indirects: UInt64; sizes: IntPtr; states: IntPtr; fbos: IntPtr; count: UInt32)>(z_DrawCommandsStatesAddressNV_adr);
    private z_DrawCommandsStatesAddressNV_10 := GetProcOrNil&<procedure(var indirects: UInt64; sizes: IntPtr; states: IntPtr; var fbos: UInt32; count: UInt32)>(z_DrawCommandsStatesAddressNV_adr);
    private z_DrawCommandsStatesAddressNV_11 := GetProcOrNil&<procedure(var indirects: UInt64; sizes: IntPtr; var states: UInt32; fbos: IntPtr; count: UInt32)>(z_DrawCommandsStatesAddressNV_adr);
    private z_DrawCommandsStatesAddressNV_12 := GetProcOrNil&<procedure(var indirects: UInt64; sizes: IntPtr; var states: UInt32; var fbos: UInt32; count: UInt32)>(z_DrawCommandsStatesAddressNV_adr);
    private z_DrawCommandsStatesAddressNV_13 := GetProcOrNil&<procedure(var indirects: UInt64; var sizes: Int32; states: IntPtr; fbos: IntPtr; count: UInt32)>(z_DrawCommandsStatesAddressNV_adr);
    private z_DrawCommandsStatesAddressNV_14 := GetProcOrNil&<procedure(var indirects: UInt64; var sizes: Int32; states: IntPtr; var fbos: UInt32; count: UInt32)>(z_DrawCommandsStatesAddressNV_adr);
    private z_DrawCommandsStatesAddressNV_15 := GetProcOrNil&<procedure(var indirects: UInt64; var sizes: Int32; var states: UInt32; fbos: IntPtr; count: UInt32)>(z_DrawCommandsStatesAddressNV_adr);
    private z_DrawCommandsStatesAddressNV_16 := GetProcOrNil&<procedure(var indirects: UInt64; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32)>(z_DrawCommandsStatesAddressNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: array of Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32);
    type PUInt64=^UInt64;
    type PInt32=^Int32;
    type PUInt32=^UInt32;
    begin
      if (fbos<>nil) and (fbos.Length<>0) then
        if (states<>nil) and (states.Length<>0) then
          if (sizes<>nil) and (sizes.Length<>0) then
            if (indirects<>nil) and (indirects.Length<>0) then
              z_DrawCommandsStatesAddressNV_16(indirects[0], sizes[0], states[0], fbos[0], count) else
              z_DrawCommandsStatesAddressNV_16(PUInt64(nil)^, sizes[0], states[0], fbos[0], count) else
            if (indirects<>nil) and (indirects.Length<>0) then
              z_DrawCommandsStatesAddressNV_16(indirects[0], PInt32(nil)^, states[0], fbos[0], count) else
              z_DrawCommandsStatesAddressNV_16(PUInt64(nil)^, PInt32(nil)^, states[0], fbos[0], count) else
          if (sizes<>nil) and (sizes.Length<>0) then
            if (indirects<>nil) and (indirects.Length<>0) then
              z_DrawCommandsStatesAddressNV_16(indirects[0], sizes[0], PUInt32(nil)^, fbos[0], count) else
              z_DrawCommandsStatesAddressNV_16(PUInt64(nil)^, sizes[0], PUInt32(nil)^, fbos[0], count) else
            if (indirects<>nil) and (indirects.Length<>0) then
              z_DrawCommandsStatesAddressNV_16(indirects[0], PInt32(nil)^, PUInt32(nil)^, fbos[0], count) else
              z_DrawCommandsStatesAddressNV_16(PUInt64(nil)^, PInt32(nil)^, PUInt32(nil)^, fbos[0], count) else
        if (states<>nil) and (states.Length<>0) then
          if (sizes<>nil) and (sizes.Length<>0) then
            if (indirects<>nil) and (indirects.Length<>0) then
              z_DrawCommandsStatesAddressNV_16(indirects[0], sizes[0], states[0], PUInt32(nil)^, count) else
              z_DrawCommandsStatesAddressNV_16(PUInt64(nil)^, sizes[0], states[0], PUInt32(nil)^, count) else
            if (indirects<>nil) and (indirects.Length<>0) then
              z_DrawCommandsStatesAddressNV_16(indirects[0], PInt32(nil)^, states[0], PUInt32(nil)^, count) else
              z_DrawCommandsStatesAddressNV_16(PUInt64(nil)^, PInt32(nil)^, states[0], PUInt32(nil)^, count) else
          if (sizes<>nil) and (sizes.Length<>0) then
            if (indirects<>nil) and (indirects.Length<>0) then
              z_DrawCommandsStatesAddressNV_16(indirects[0], sizes[0], PUInt32(nil)^, PUInt32(nil)^, count) else
              z_DrawCommandsStatesAddressNV_16(PUInt64(nil)^, sizes[0], PUInt32(nil)^, PUInt32(nil)^, count) else
            if (indirects<>nil) and (indirects.Length<>0) then
              z_DrawCommandsStatesAddressNV_16(indirects[0], PInt32(nil)^, PUInt32(nil)^, PUInt32(nil)^, count) else
              z_DrawCommandsStatesAddressNV_16(PUInt64(nil)^, PInt32(nil)^, PUInt32(nil)^, PUInt32(nil)^, count);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32) :=
    z_DrawCommandsStatesAddressNV_16(indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; var sizes: Int32; var states: UInt32; fbos: IntPtr; count: UInt32) :=
    z_DrawCommandsStatesAddressNV_15(indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; var sizes: Int32; states: IntPtr; var fbos: UInt32; count: UInt32) :=
    z_DrawCommandsStatesAddressNV_14(indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; var sizes: Int32; states: IntPtr; fbos: IntPtr; count: UInt32) :=
    z_DrawCommandsStatesAddressNV_13(indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: IntPtr; var states: UInt32; var fbos: UInt32; count: UInt32) :=
    z_DrawCommandsStatesAddressNV_12(indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: IntPtr; var states: UInt32; fbos: IntPtr; count: UInt32) :=
    z_DrawCommandsStatesAddressNV_11(indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: IntPtr; states: IntPtr; var fbos: UInt32; count: UInt32) :=
    z_DrawCommandsStatesAddressNV_10(indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: IntPtr; states: IntPtr; fbos: IntPtr; count: UInt32) :=
    z_DrawCommandsStatesAddressNV_9(indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: IntPtr; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32) :=
    z_DrawCommandsStatesAddressNV_8(indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: IntPtr; var sizes: Int32; var states: UInt32; fbos: IntPtr; count: UInt32) :=
    z_DrawCommandsStatesAddressNV_7(indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: IntPtr; var sizes: Int32; states: IntPtr; var fbos: UInt32; count: UInt32) :=
    z_DrawCommandsStatesAddressNV_6(indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: IntPtr; var sizes: Int32; states: IntPtr; fbos: IntPtr; count: UInt32) :=
    z_DrawCommandsStatesAddressNV_5(indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: IntPtr; sizes: IntPtr; var states: UInt32; var fbos: UInt32; count: UInt32) :=
    z_DrawCommandsStatesAddressNV_4(indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: IntPtr; sizes: IntPtr; var states: UInt32; fbos: IntPtr; count: UInt32) :=
    z_DrawCommandsStatesAddressNV_3(indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: IntPtr; sizes: IntPtr; states: IntPtr; var fbos: UInt32; count: UInt32) :=
    z_DrawCommandsStatesAddressNV_2(indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: IntPtr; sizes: IntPtr; states: IntPtr; fbos: IntPtr; count: UInt32) :=
    z_DrawCommandsStatesAddressNV_1(indirects, sizes, states, fbos, count);
    
    private z_CreateCommandListsNV_adr := GetProcAddress('glCreateCommandListsNV');
    private z_CreateCommandListsNV_1 := GetProcOrNil&<procedure(n: Int32; lists: IntPtr)>(z_CreateCommandListsNV_adr);
    private z_CreateCommandListsNV_2 := GetProcOrNil&<procedure(n: Int32; var lists: UInt32)>(z_CreateCommandListsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateCommandListsNV(n: Int32; lists: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (lists<>nil) and (lists.Length<>0) then
        z_CreateCommandListsNV_2(n, lists[0]) else
        z_CreateCommandListsNV_2(n, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateCommandListsNV(n: Int32; var lists: UInt32) :=
    z_CreateCommandListsNV_2(n, lists);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateCommandListsNV(n: Int32; lists: IntPtr) :=
    z_CreateCommandListsNV_1(n, lists);
    
    private z_DeleteCommandListsNV_adr := GetProcAddress('glDeleteCommandListsNV');
    private z_DeleteCommandListsNV_1 := GetProcOrNil&<procedure(n: Int32; lists: IntPtr)>(z_DeleteCommandListsNV_adr);
    private z_DeleteCommandListsNV_2 := GetProcOrNil&<procedure(n: Int32; var lists: UInt32)>(z_DeleteCommandListsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteCommandListsNV(n: Int32; lists: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (lists<>nil) and (lists.Length<>0) then
        z_DeleteCommandListsNV_2(n, lists[0]) else
        z_DeleteCommandListsNV_2(n, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteCommandListsNV(n: Int32; var lists: UInt32) :=
    z_DeleteCommandListsNV_2(n, lists);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteCommandListsNV(n: Int32; lists: IntPtr) :=
    z_DeleteCommandListsNV_1(n, lists);
    
    private z_IsCommandListNV_adr := GetProcAddress('glIsCommandListNV');
    private z_IsCommandListNV_1 := GetProcOrNil&<function(list: UInt32): boolean>(z_IsCommandListNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsCommandListNV(list: UInt32): boolean :=
    z_IsCommandListNV_1(list);
    
    private z_ListDrawCommandsStatesClientNV_adr := GetProcAddress('glListDrawCommandsStatesClientNV');
    private z_ListDrawCommandsStatesClientNV_1 := GetProcOrNil&<procedure(list: UInt32; segment: UInt32; indirects: pointer; sizes: IntPtr; states: IntPtr; fbos: IntPtr; count: UInt32)>(z_ListDrawCommandsStatesClientNV_adr);
    private z_ListDrawCommandsStatesClientNV_2 := GetProcOrNil&<procedure(list: UInt32; segment: UInt32; indirects: pointer; sizes: IntPtr; states: IntPtr; var fbos: UInt32; count: UInt32)>(z_ListDrawCommandsStatesClientNV_adr);
    private z_ListDrawCommandsStatesClientNV_3 := GetProcOrNil&<procedure(list: UInt32; segment: UInt32; indirects: pointer; sizes: IntPtr; var states: UInt32; fbos: IntPtr; count: UInt32)>(z_ListDrawCommandsStatesClientNV_adr);
    private z_ListDrawCommandsStatesClientNV_4 := GetProcOrNil&<procedure(list: UInt32; segment: UInt32; indirects: pointer; sizes: IntPtr; var states: UInt32; var fbos: UInt32; count: UInt32)>(z_ListDrawCommandsStatesClientNV_adr);
    private z_ListDrawCommandsStatesClientNV_5 := GetProcOrNil&<procedure(list: UInt32; segment: UInt32; indirects: pointer; var sizes: Int32; states: IntPtr; fbos: IntPtr; count: UInt32)>(z_ListDrawCommandsStatesClientNV_adr);
    private z_ListDrawCommandsStatesClientNV_6 := GetProcOrNil&<procedure(list: UInt32; segment: UInt32; indirects: pointer; var sizes: Int32; states: IntPtr; var fbos: UInt32; count: UInt32)>(z_ListDrawCommandsStatesClientNV_adr);
    private z_ListDrawCommandsStatesClientNV_7 := GetProcOrNil&<procedure(list: UInt32; segment: UInt32; indirects: pointer; var sizes: Int32; var states: UInt32; fbos: IntPtr; count: UInt32)>(z_ListDrawCommandsStatesClientNV_adr);
    private z_ListDrawCommandsStatesClientNV_8 := GetProcOrNil&<procedure(list: UInt32; segment: UInt32; indirects: pointer; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32)>(z_ListDrawCommandsStatesClientNV_adr);
    private z_ListDrawCommandsStatesClientNV_9 := GetProcOrNil&<procedure(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: IntPtr; states: IntPtr; fbos: IntPtr; count: UInt32)>(z_ListDrawCommandsStatesClientNV_adr);
    private z_ListDrawCommandsStatesClientNV_10 := GetProcOrNil&<procedure(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: IntPtr; states: IntPtr; var fbos: UInt32; count: UInt32)>(z_ListDrawCommandsStatesClientNV_adr);
    private z_ListDrawCommandsStatesClientNV_11 := GetProcOrNil&<procedure(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: IntPtr; var states: UInt32; fbos: IntPtr; count: UInt32)>(z_ListDrawCommandsStatesClientNV_adr);
    private z_ListDrawCommandsStatesClientNV_12 := GetProcOrNil&<procedure(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: IntPtr; var states: UInt32; var fbos: UInt32; count: UInt32)>(z_ListDrawCommandsStatesClientNV_adr);
    private z_ListDrawCommandsStatesClientNV_13 := GetProcOrNil&<procedure(list: UInt32; segment: UInt32; var indirects: IntPtr; var sizes: Int32; states: IntPtr; fbos: IntPtr; count: UInt32)>(z_ListDrawCommandsStatesClientNV_adr);
    private z_ListDrawCommandsStatesClientNV_14 := GetProcOrNil&<procedure(list: UInt32; segment: UInt32; var indirects: IntPtr; var sizes: Int32; states: IntPtr; var fbos: UInt32; count: UInt32)>(z_ListDrawCommandsStatesClientNV_adr);
    private z_ListDrawCommandsStatesClientNV_15 := GetProcOrNil&<procedure(list: UInt32; segment: UInt32; var indirects: IntPtr; var sizes: Int32; var states: UInt32; fbos: IntPtr; count: UInt32)>(z_ListDrawCommandsStatesClientNV_adr);
    private z_ListDrawCommandsStatesClientNV_16 := GetProcOrNil&<procedure(list: UInt32; segment: UInt32; var indirects: IntPtr; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32)>(z_ListDrawCommandsStatesClientNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: array of Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32);
    type PIntPtr=^IntPtr;
    type PInt32=^Int32;
    type PUInt32=^UInt32;
    begin
      if (fbos<>nil) and (fbos.Length<>0) then
        if (states<>nil) and (states.Length<>0) then
          if (sizes<>nil) and (sizes.Length<>0) then
            if (indirects<>nil) and (indirects.Length<>0) then
              z_ListDrawCommandsStatesClientNV_16(list, segment, indirects[0], sizes[0], states[0], fbos[0], count) else
              z_ListDrawCommandsStatesClientNV_16(list, segment, PIntPtr(nil)^, sizes[0], states[0], fbos[0], count) else
            if (indirects<>nil) and (indirects.Length<>0) then
              z_ListDrawCommandsStatesClientNV_16(list, segment, indirects[0], PInt32(nil)^, states[0], fbos[0], count) else
              z_ListDrawCommandsStatesClientNV_16(list, segment, PIntPtr(nil)^, PInt32(nil)^, states[0], fbos[0], count) else
          if (sizes<>nil) and (sizes.Length<>0) then
            if (indirects<>nil) and (indirects.Length<>0) then
              z_ListDrawCommandsStatesClientNV_16(list, segment, indirects[0], sizes[0], PUInt32(nil)^, fbos[0], count) else
              z_ListDrawCommandsStatesClientNV_16(list, segment, PIntPtr(nil)^, sizes[0], PUInt32(nil)^, fbos[0], count) else
            if (indirects<>nil) and (indirects.Length<>0) then
              z_ListDrawCommandsStatesClientNV_16(list, segment, indirects[0], PInt32(nil)^, PUInt32(nil)^, fbos[0], count) else
              z_ListDrawCommandsStatesClientNV_16(list, segment, PIntPtr(nil)^, PInt32(nil)^, PUInt32(nil)^, fbos[0], count) else
        if (states<>nil) and (states.Length<>0) then
          if (sizes<>nil) and (sizes.Length<>0) then
            if (indirects<>nil) and (indirects.Length<>0) then
              z_ListDrawCommandsStatesClientNV_16(list, segment, indirects[0], sizes[0], states[0], PUInt32(nil)^, count) else
              z_ListDrawCommandsStatesClientNV_16(list, segment, PIntPtr(nil)^, sizes[0], states[0], PUInt32(nil)^, count) else
            if (indirects<>nil) and (indirects.Length<>0) then
              z_ListDrawCommandsStatesClientNV_16(list, segment, indirects[0], PInt32(nil)^, states[0], PUInt32(nil)^, count) else
              z_ListDrawCommandsStatesClientNV_16(list, segment, PIntPtr(nil)^, PInt32(nil)^, states[0], PUInt32(nil)^, count) else
          if (sizes<>nil) and (sizes.Length<>0) then
            if (indirects<>nil) and (indirects.Length<>0) then
              z_ListDrawCommandsStatesClientNV_16(list, segment, indirects[0], sizes[0], PUInt32(nil)^, PUInt32(nil)^, count) else
              z_ListDrawCommandsStatesClientNV_16(list, segment, PIntPtr(nil)^, sizes[0], PUInt32(nil)^, PUInt32(nil)^, count) else
            if (indirects<>nil) and (indirects.Length<>0) then
              z_ListDrawCommandsStatesClientNV_16(list, segment, indirects[0], PInt32(nil)^, PUInt32(nil)^, PUInt32(nil)^, count) else
              z_ListDrawCommandsStatesClientNV_16(list, segment, PIntPtr(nil)^, PInt32(nil)^, PUInt32(nil)^, PUInt32(nil)^, count);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32) :=
    z_ListDrawCommandsStatesClientNV_16(list, segment, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; var sizes: Int32; var states: UInt32; fbos: IntPtr; count: UInt32) :=
    z_ListDrawCommandsStatesClientNV_15(list, segment, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; var sizes: Int32; states: IntPtr; var fbos: UInt32; count: UInt32) :=
    z_ListDrawCommandsStatesClientNV_14(list, segment, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; var sizes: Int32; states: IntPtr; fbos: IntPtr; count: UInt32) :=
    z_ListDrawCommandsStatesClientNV_13(list, segment, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: IntPtr; var states: UInt32; var fbos: UInt32; count: UInt32) :=
    z_ListDrawCommandsStatesClientNV_12(list, segment, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: IntPtr; var states: UInt32; fbos: IntPtr; count: UInt32) :=
    z_ListDrawCommandsStatesClientNV_11(list, segment, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: IntPtr; states: IntPtr; var fbos: UInt32; count: UInt32) :=
    z_ListDrawCommandsStatesClientNV_10(list, segment, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: IntPtr; states: IntPtr; fbos: IntPtr; count: UInt32) :=
    z_ListDrawCommandsStatesClientNV_9(list, segment, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32) :=
    z_ListDrawCommandsStatesClientNV_8(list, segment, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; var sizes: Int32; var states: UInt32; fbos: IntPtr; count: UInt32) :=
    z_ListDrawCommandsStatesClientNV_7(list, segment, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; var sizes: Int32; states: IntPtr; var fbos: UInt32; count: UInt32) :=
    z_ListDrawCommandsStatesClientNV_6(list, segment, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; var sizes: Int32; states: IntPtr; fbos: IntPtr; count: UInt32) :=
    z_ListDrawCommandsStatesClientNV_5(list, segment, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: IntPtr; var states: UInt32; var fbos: UInt32; count: UInt32) :=
    z_ListDrawCommandsStatesClientNV_4(list, segment, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: IntPtr; var states: UInt32; fbos: IntPtr; count: UInt32) :=
    z_ListDrawCommandsStatesClientNV_3(list, segment, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: IntPtr; states: IntPtr; var fbos: UInt32; count: UInt32) :=
    z_ListDrawCommandsStatesClientNV_2(list, segment, indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: IntPtr; states: IntPtr; fbos: IntPtr; count: UInt32) :=
    z_ListDrawCommandsStatesClientNV_1(list, segment, indirects, sizes, states, fbos, count);
    
    private z_CommandListSegmentsNV_adr := GetProcAddress('glCommandListSegmentsNV');
    private z_CommandListSegmentsNV_1 := GetProcOrNil&<procedure(list: UInt32; segments: UInt32)>(z_CommandListSegmentsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CommandListSegmentsNV(list: UInt32; segments: UInt32) :=
    z_CommandListSegmentsNV_1(list, segments);
    
    private z_CompileCommandListNV_adr := GetProcAddress('glCompileCommandListNV');
    private z_CompileCommandListNV_1 := GetProcOrNil&<procedure(list: UInt32)>(z_CompileCommandListNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileCommandListNV(list: UInt32) :=
    z_CompileCommandListNV_1(list);
    
    private z_CallCommandListNV_adr := GetProcAddress('glCallCommandListNV');
    private z_CallCommandListNV_1 := GetProcOrNil&<procedure(list: UInt32)>(z_CallCommandListNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CallCommandListNV(list: UInt32) :=
    z_CallCommandListNV_1(list);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glConditionalRenderNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_conditional_render';
    
    private z_BeginConditionalRenderNV_adr := GetProcAddress('glBeginConditionalRenderNV');
    private z_BeginConditionalRenderNV_1 := GetProcOrNil&<procedure(id: UInt32; mode: ConditionalRenderMode)>(z_BeginConditionalRenderNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginConditionalRenderNV(id: UInt32; mode: ConditionalRenderMode) :=
    z_BeginConditionalRenderNV_1(id, mode);
    
    private z_EndConditionalRenderNV_adr := GetProcAddress('glEndConditionalRenderNV');
    private z_EndConditionalRenderNV_1 := GetProcOrNil&<procedure>(z_EndConditionalRenderNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndConditionalRenderNV :=
    z_EndConditionalRenderNV_1();
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glConservativeRasterNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_conservative_raster';
    
    private z_SubpixelPrecisionBiasNV_adr := GetProcAddress('glSubpixelPrecisionBiasNV');
    private z_SubpixelPrecisionBiasNV_1 := GetProcOrNil&<procedure(xbits: UInt32; ybits: UInt32)>(z_SubpixelPrecisionBiasNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SubpixelPrecisionBiasNV(xbits: UInt32; ybits: UInt32) :=
    z_SubpixelPrecisionBiasNV_1(xbits, ybits);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glConservativeRasterDilateNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_conservative_raster_dilate';
    
    private z_ConservativeRasterParameterfNV_adr := GetProcAddress('glConservativeRasterParameterfNV');
    private z_ConservativeRasterParameterfNV_1 := GetProcOrNil&<procedure(pname: DummyEnum; value: single)>(z_ConservativeRasterParameterfNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConservativeRasterParameterfNV(pname: DummyEnum; value: single) :=
    z_ConservativeRasterParameterfNV_1(pname, value);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glConservativeRasterPreSnapTrianglesNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_conservative_raster_pre_snap_triangles';
    
    private z_ConservativeRasterParameteriNV_adr := GetProcAddress('glConservativeRasterParameteriNV');
    private z_ConservativeRasterParameteriNV_1 := GetProcOrNil&<procedure(pname: DummyEnum; param: Int32)>(z_ConservativeRasterParameteriNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConservativeRasterParameteriNV(pname: DummyEnum; param: Int32) :=
    z_ConservativeRasterParameteriNV_1(pname, param);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glCopyImageNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_copy_image';
    
    private z_CopyImageSubDataNV_adr := GetProcAddress('glCopyImageSubDataNV');
    private z_CopyImageSubDataNV_1 := GetProcOrNil&<procedure(srcName: UInt32; srcTarget: CopyBufferSubDataTarget; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: CopyBufferSubDataTarget; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; width: Int32; height: Int32; depth: Int32)>(z_CopyImageSubDataNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyImageSubDataNV(srcName: UInt32; srcTarget: CopyBufferSubDataTarget; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: CopyBufferSubDataTarget; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; width: Int32; height: Int32; depth: Int32) :=
    z_CopyImageSubDataNV_1(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glDepthBufferFloatNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_depth_buffer_float';
    
    private z_DepthRangedNV_adr := GetProcAddress('glDepthRangedNV');
    private z_DepthRangedNV_1 := GetProcOrNil&<procedure(zNear: real; zFar: real)>(z_DepthRangedNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangedNV(zNear: real; zFar: real) :=
    z_DepthRangedNV_1(zNear, zFar);
    
    private z_ClearDepthdNV_adr := GetProcAddress('glClearDepthdNV');
    private z_ClearDepthdNV_1 := GetProcOrNil&<procedure(depth: real)>(z_ClearDepthdNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearDepthdNV(depth: real) :=
    z_ClearDepthdNV_1(depth);
    
    private z_DepthBoundsdNV_adr := GetProcAddress('glDepthBoundsdNV');
    private z_DepthBoundsdNV_1 := GetProcOrNil&<procedure(zmin: real; zmax: real)>(z_DepthBoundsdNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthBoundsdNV(zmin: real; zmax: real) :=
    z_DepthBoundsdNV_1(zmin, zmax);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glDrawTextureNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_draw_texture';
    
    private z_DrawTextureNV_adr := GetProcAddress('glDrawTextureNV');
    private z_DrawTextureNV_1 := GetProcOrNil&<procedure(texture: gl_texture; sampler: gl_sampler; x0: single; y0: single; x1: single; y1: single; z: single; s0: single; t0: single; s1: single; t1: single)>(z_DrawTextureNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTextureNV(texture: gl_texture; sampler: gl_sampler; x0: single; y0: single; x1: single; y1: single; z: single; s0: single; t0: single; s1: single; t1: single) :=
    z_DrawTextureNV_1(texture, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glDrawVulkanImageNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_draw_vulkan_image';
    
    private z_DrawVkImageNV_adr := GetProcAddress('glDrawVkImageNV');
    private z_DrawVkImageNV_1 := GetProcOrNil&<procedure(vkImage: UInt64; sampler: gl_sampler; x0: single; y0: single; x1: single; y1: single; z: single; s0: single; t0: single; s1: single; t1: single)>(z_DrawVkImageNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawVkImageNV(vkImage: UInt64; sampler: gl_sampler; x0: single; y0: single; x1: single; y1: single; z: single; s0: single; t0: single; s1: single; t1: single) :=
    z_DrawVkImageNV_1(vkImage, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
    
    private z_GetVkProcAddrNV_adr := GetProcAddress('glGetVkProcAddrNV');
    private z_GetVkProcAddrNV_1 := GetProcOrNil&<function(name: IntPtr): GL_VULKAN_PROC_NV>(z_GetVkProcAddrNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVkProcAddrNV(name: string): GL_VULKAN_PROC_NV;
    begin
      var name_str_ptr: IntPtr;
      try
        name_str_ptr := Marshal.StringToHGlobalAnsi(name);
        Result := z_GetVkProcAddrNV_1(name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVkProcAddrNV(name: IntPtr): GL_VULKAN_PROC_NV :=
    z_GetVkProcAddrNV_1(name);
    
    private z_WaitVkSemaphoreNV_adr := GetProcAddress('glWaitVkSemaphoreNV');
    private z_WaitVkSemaphoreNV_1 := GetProcOrNil&<procedure(vkSemaphore: UInt64)>(z_WaitVkSemaphoreNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitVkSemaphoreNV(vkSemaphore: UInt64) :=
    z_WaitVkSemaphoreNV_1(vkSemaphore);
    
    private z_SignalVkSemaphoreNV_adr := GetProcAddress('glSignalVkSemaphoreNV');
    private z_SignalVkSemaphoreNV_1 := GetProcOrNil&<procedure(vkSemaphore: UInt64)>(z_SignalVkSemaphoreNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalVkSemaphoreNV(vkSemaphore: UInt64) :=
    z_SignalVkSemaphoreNV_1(vkSemaphore);
    
    private z_SignalVkFenceNV_adr := GetProcAddress('glSignalVkFenceNV');
    private z_SignalVkFenceNV_1 := GetProcOrNil&<procedure(vkFence: UInt64)>(z_SignalVkFenceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalVkFenceNV(vkFence: UInt64) :=
    z_SignalVkFenceNV_1(vkFence);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glEvaluatorsNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_evaluators';
    
    private z_MapControlPointsNV_adr := GetProcAddress('glMapControlPointsNV');
    private z_MapControlPointsNV_1 := GetProcOrNil&<procedure(target: EvalTarget; index: UInt32; &type: MapType; ustride: Int32; vstride: Int32; uorder: Int32; vorder: Int32; &packed: boolean; points: IntPtr)>(z_MapControlPointsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapControlPointsNV(target: EvalTarget; index: UInt32; &type: MapType; ustride: Int32; vstride: Int32; uorder: Int32; vorder: Int32; &packed: boolean; points: IntPtr) :=
    z_MapControlPointsNV_1(target, index, &type, ustride, vstride, uorder, vorder, &packed, points);
    
    private z_MapParameterivNV_adr := GetProcAddress('glMapParameterivNV');
    private z_MapParameterivNV_1 := GetProcOrNil&<procedure(target: EvalTarget; pname: MapParameter; &params: IntPtr)>(z_MapParameterivNV_adr);
    private z_MapParameterivNV_2 := GetProcOrNil&<procedure(target: EvalTarget; pname: MapParameter; var &params: Int32)>(z_MapParameterivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapParameterivNV(target: EvalTarget; pname: MapParameter; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_MapParameterivNV_2(target, pname, &params[0]) else
        z_MapParameterivNV_2(target, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapParameterivNV(target: EvalTarget; pname: MapParameter; var &params: Int32) :=
    z_MapParameterivNV_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapParameterivNV(target: EvalTarget; pname: MapParameter; &params: IntPtr) :=
    z_MapParameterivNV_1(target, pname, &params);
    
    private z_MapParameterfvNV_adr := GetProcAddress('glMapParameterfvNV');
    private z_MapParameterfvNV_1 := GetProcOrNil&<procedure(target: EvalTarget; pname: MapParameter; &params: IntPtr)>(z_MapParameterfvNV_adr);
    private z_MapParameterfvNV_2 := GetProcOrNil&<procedure(target: EvalTarget; pname: MapParameter; var &params: single)>(z_MapParameterfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapParameterfvNV(target: EvalTarget; pname: MapParameter; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_MapParameterfvNV_2(target, pname, &params[0]) else
        z_MapParameterfvNV_2(target, pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapParameterfvNV(target: EvalTarget; pname: MapParameter; var &params: single) :=
    z_MapParameterfvNV_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapParameterfvNV(target: EvalTarget; pname: MapParameter; &params: IntPtr) :=
    z_MapParameterfvNV_1(target, pname, &params);
    
    private z_GetMapControlPointsNV_adr := GetProcAddress('glGetMapControlPointsNV');
    private z_GetMapControlPointsNV_1 := GetProcOrNil&<procedure(target: EvalTarget; index: UInt32; &type: MapType; ustride: Int32; vstride: Int32; &packed: boolean; points: IntPtr)>(z_GetMapControlPointsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapControlPointsNV(target: EvalTarget; index: UInt32; &type: MapType; ustride: Int32; vstride: Int32; &packed: boolean; points: IntPtr) :=
    z_GetMapControlPointsNV_1(target, index, &type, ustride, vstride, &packed, points);
    
    private z_GetMapParameterivNV_adr := GetProcAddress('glGetMapParameterivNV');
    private z_GetMapParameterivNV_1 := GetProcOrNil&<procedure(target: EvalTarget; pname: MapParameter; &params: IntPtr)>(z_GetMapParameterivNV_adr);
    private z_GetMapParameterivNV_2 := GetProcOrNil&<procedure(target: EvalTarget; pname: MapParameter; var &params: Int32)>(z_GetMapParameterivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapParameterivNV(target: EvalTarget; pname: MapParameter; var &params: Int32) :=
    z_GetMapParameterivNV_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapParameterivNV(target: EvalTarget; pname: MapParameter; &params: IntPtr) :=
    z_GetMapParameterivNV_1(target, pname, &params);
    
    private z_GetMapParameterfvNV_adr := GetProcAddress('glGetMapParameterfvNV');
    private z_GetMapParameterfvNV_1 := GetProcOrNil&<procedure(target: EvalTarget; pname: MapParameter; &params: IntPtr)>(z_GetMapParameterfvNV_adr);
    private z_GetMapParameterfvNV_2 := GetProcOrNil&<procedure(target: EvalTarget; pname: MapParameter; var &params: single)>(z_GetMapParameterfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapParameterfvNV(target: EvalTarget; pname: MapParameter; var &params: single) :=
    z_GetMapParameterfvNV_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapParameterfvNV(target: EvalTarget; pname: MapParameter; &params: IntPtr) :=
    z_GetMapParameterfvNV_1(target, pname, &params);
    
    private z_GetMapAttribParameterivNV_adr := GetProcAddress('glGetMapAttribParameterivNV');
    private z_GetMapAttribParameterivNV_1 := GetProcOrNil&<procedure(target: EvalTarget; index: UInt32; pname: MapAttribParameter; &params: IntPtr)>(z_GetMapAttribParameterivNV_adr);
    private z_GetMapAttribParameterivNV_2 := GetProcOrNil&<procedure(target: EvalTarget; index: UInt32; pname: MapAttribParameter; var &params: Int32)>(z_GetMapAttribParameterivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapAttribParameterivNV(target: EvalTarget; index: UInt32; pname: MapAttribParameter; var &params: Int32) :=
    z_GetMapAttribParameterivNV_2(target, index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapAttribParameterivNV(target: EvalTarget; index: UInt32; pname: MapAttribParameter; &params: IntPtr) :=
    z_GetMapAttribParameterivNV_1(target, index, pname, &params);
    
    private z_GetMapAttribParameterfvNV_adr := GetProcAddress('glGetMapAttribParameterfvNV');
    private z_GetMapAttribParameterfvNV_1 := GetProcOrNil&<procedure(target: EvalTarget; index: UInt32; pname: MapAttribParameter; &params: IntPtr)>(z_GetMapAttribParameterfvNV_adr);
    private z_GetMapAttribParameterfvNV_2 := GetProcOrNil&<procedure(target: EvalTarget; index: UInt32; pname: MapAttribParameter; var &params: single)>(z_GetMapAttribParameterfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapAttribParameterfvNV(target: EvalTarget; index: UInt32; pname: MapAttribParameter; var &params: single) :=
    z_GetMapAttribParameterfvNV_2(target, index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapAttribParameterfvNV(target: EvalTarget; index: UInt32; pname: MapAttribParameter; &params: IntPtr) :=
    z_GetMapAttribParameterfvNV_1(target, index, pname, &params);
    
    private z_EvalMapsNV_adr := GetProcAddress('glEvalMapsNV');
    private z_EvalMapsNV_1 := GetProcOrNil&<procedure(target: EvalTarget; mode: EvalMapsMode)>(z_EvalMapsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalMapsNV(target: EvalTarget; mode: EvalMapsMode) :=
    z_EvalMapsNV_1(target, mode);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glExplicitMultisampleNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_explicit_multisample';
    
    private z_GetMultisamplefvNV_adr := GetProcAddress('glGetMultisamplefvNV');
    private z_GetMultisamplefvNV_1 := GetProcOrNil&<procedure(pname: GetMultisamplePName; index: UInt32; val: IntPtr)>(z_GetMultisamplefvNV_adr);
    private z_GetMultisamplefvNV_2 := GetProcOrNil&<procedure(pname: GetMultisamplePName; index: UInt32; var val: single)>(z_GetMultisamplefvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultisamplefvNV(pname: GetMultisamplePName; index: UInt32; var val: single) :=
    z_GetMultisamplefvNV_2(pname, index, val);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultisamplefvNV(pname: GetMultisamplePName; index: UInt32; val: IntPtr) :=
    z_GetMultisamplefvNV_1(pname, index, val);
    
    private z_SampleMaskIndexedNV_adr := GetProcAddress('glSampleMaskIndexedNV');
    private z_SampleMaskIndexedNV_1 := GetProcOrNil&<procedure(index: UInt32; mask: DummyFlags)>(z_SampleMaskIndexedNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SampleMaskIndexedNV(index: UInt32; mask: DummyFlags) :=
    z_SampleMaskIndexedNV_1(index, mask);
    
    private z_TexRenderbufferNV_adr := GetProcAddress('glTexRenderbufferNV');
    private z_TexRenderbufferNV_1 := GetProcOrNil&<procedure(target: TextureTarget; renderbuffer: gl_renderbuffer)>(z_TexRenderbufferNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexRenderbufferNV(target: TextureTarget; renderbuffer: gl_renderbuffer) :=
    z_TexRenderbufferNV_1(target, renderbuffer);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glFenceNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_fence';
    
    private z_DeleteFencesNV_adr := GetProcAddress('glDeleteFencesNV');
    private z_DeleteFencesNV_1 := GetProcOrNil&<procedure(n: Int32; fences: IntPtr)>(z_DeleteFencesNV_adr);
    private z_DeleteFencesNV_2 := GetProcOrNil&<procedure(n: Int32; var fences: UInt32)>(z_DeleteFencesNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFencesNV(n: Int32; fences: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (fences<>nil) and (fences.Length<>0) then
        z_DeleteFencesNV_2(n, fences[0]) else
        z_DeleteFencesNV_2(n, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFencesNV(n: Int32; var fences: UInt32) :=
    z_DeleteFencesNV_2(n, fences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFencesNV(n: Int32; fences: IntPtr) :=
    z_DeleteFencesNV_1(n, fences);
    
    private z_GenFencesNV_adr := GetProcAddress('glGenFencesNV');
    private z_GenFencesNV_1 := GetProcOrNil&<procedure(n: Int32; fences: IntPtr)>(z_GenFencesNV_adr);
    private z_GenFencesNV_2 := GetProcOrNil&<procedure(n: Int32; var fences: UInt32)>(z_GenFencesNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFencesNV(n: Int32; fences: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (fences<>nil) and (fences.Length<>0) then
        z_GenFencesNV_2(n, fences[0]) else
        z_GenFencesNV_2(n, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFencesNV(n: Int32; var fences: UInt32) :=
    z_GenFencesNV_2(n, fences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFencesNV(n: Int32; fences: IntPtr) :=
    z_GenFencesNV_1(n, fences);
    
    private z_IsFenceNV_adr := GetProcAddress('glIsFenceNV');
    private z_IsFenceNV_1 := GetProcOrNil&<function(fence: UInt32): boolean>(z_IsFenceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsFenceNV(fence: UInt32): boolean :=
    z_IsFenceNV_1(fence);
    
    private z_TestFenceNV_adr := GetProcAddress('glTestFenceNV');
    private z_TestFenceNV_1 := GetProcOrNil&<function(fence: UInt32): boolean>(z_TestFenceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function TestFenceNV(fence: UInt32): boolean :=
    z_TestFenceNV_1(fence);
    
    private z_GetFenceivNV_adr := GetProcAddress('glGetFenceivNV');
    private z_GetFenceivNV_1 := GetProcOrNil&<procedure(fence: UInt32; pname: FenceParameterName; &params: IntPtr)>(z_GetFenceivNV_adr);
    private z_GetFenceivNV_2 := GetProcOrNil&<procedure(fence: UInt32; pname: FenceParameterName; var &params: Int32)>(z_GetFenceivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFenceivNV(fence: UInt32; pname: FenceParameterName; var &params: Int32) :=
    z_GetFenceivNV_2(fence, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFenceivNV(fence: UInt32; pname: FenceParameterName; &params: IntPtr) :=
    z_GetFenceivNV_1(fence, pname, &params);
    
    private z_FinishFenceNV_adr := GetProcAddress('glFinishFenceNV');
    private z_FinishFenceNV_1 := GetProcOrNil&<procedure(fence: UInt32)>(z_FinishFenceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FinishFenceNV(fence: UInt32) :=
    z_FinishFenceNV_1(fence);
    
    private z_SetFenceNV_adr := GetProcAddress('glSetFenceNV');
    private z_SetFenceNV_1 := GetProcOrNil&<procedure(fence: UInt32; condition: FenceCondition)>(z_SetFenceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetFenceNV(fence: UInt32; condition: FenceCondition) :=
    z_SetFenceNV_1(fence, condition);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glFragmentCoverageToColorNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_fragment_coverage_to_color';
    
    private z_FragmentCoverageColorNV_adr := GetProcAddress('glFragmentCoverageColorNV');
    private z_FragmentCoverageColorNV_1 := GetProcOrNil&<procedure(color: UInt32)>(z_FragmentCoverageColorNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentCoverageColorNV(color: UInt32) :=
    z_FragmentCoverageColorNV_1(color);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glFragmentProgramNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_fragment_program';
    
    private z_ProgramNamedParameter4fNV_adr := GetProcAddress('glProgramNamedParameter4fNV');
    private z_ProgramNamedParameter4fNV_1 := GetProcOrNil&<procedure(id: gl_program; len: Int32; name: IntPtr; x: single; y: single; z: single; w: single)>(z_ProgramNamedParameter4fNV_adr);
    private z_ProgramNamedParameter4fNV_2 := GetProcOrNil&<procedure(id: gl_program; len: Int32; var name: Byte; x: single; y: single; z: single; w: single)>(z_ProgramNamedParameter4fNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fNV(id: gl_program; len: Int32; name: array of Byte; x: single; y: single; z: single; w: single);
    type PByte=^Byte;
    begin
      if (name<>nil) and (name.Length<>0) then
        z_ProgramNamedParameter4fNV_2(id, len, name[0], x, y, z, w) else
        z_ProgramNamedParameter4fNV_2(id, len, PByte(nil)^, x, y, z, w);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fNV(id: gl_program; len: Int32; var name: Byte; x: single; y: single; z: single; w: single) :=
    z_ProgramNamedParameter4fNV_2(id, len, name, x, y, z, w);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fNV(id: gl_program; len: Int32; name: IntPtr; x: single; y: single; z: single; w: single) :=
    z_ProgramNamedParameter4fNV_1(id, len, name, x, y, z, w);
    
    private z_ProgramNamedParameter4fvNV_adr := GetProcAddress('glProgramNamedParameter4fvNV');
    private z_ProgramNamedParameter4fvNV_1 := GetProcOrNil&<procedure(id: gl_program; len: Int32; name: IntPtr; v: IntPtr)>(z_ProgramNamedParameter4fvNV_adr);
    private z_ProgramNamedParameter4fvNV_2 := GetProcOrNil&<procedure(id: gl_program; len: Int32; name: IntPtr; var v: single)>(z_ProgramNamedParameter4fvNV_adr);
    private z_ProgramNamedParameter4fvNV_3 := GetProcOrNil&<procedure(id: gl_program; len: Int32; var name: Byte; v: IntPtr)>(z_ProgramNamedParameter4fvNV_adr);
    private z_ProgramNamedParameter4fvNV_4 := GetProcOrNil&<procedure(id: gl_program; len: Int32; var name: Byte; var v: single)>(z_ProgramNamedParameter4fvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fvNV(id: gl_program; len: Int32; name: array of Byte; v: array of single);
    type PByte=^Byte;
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        if (name<>nil) and (name.Length<>0) then
          z_ProgramNamedParameter4fvNV_4(id, len, name[0], v[0]) else
          z_ProgramNamedParameter4fvNV_4(id, len, PByte(nil)^, v[0]) else
        if (name<>nil) and (name.Length<>0) then
          z_ProgramNamedParameter4fvNV_4(id, len, name[0], Psingle(nil)^) else
          z_ProgramNamedParameter4fvNV_4(id, len, PByte(nil)^, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fvNV(id: gl_program; len: Int32; var name: Byte; var v: single) :=
    z_ProgramNamedParameter4fvNV_4(id, len, name, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fvNV(id: gl_program; len: Int32; var name: Byte; v: IntPtr) :=
    z_ProgramNamedParameter4fvNV_3(id, len, name, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fvNV(id: gl_program; len: Int32; name: IntPtr; var v: single) :=
    z_ProgramNamedParameter4fvNV_2(id, len, name, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fvNV(id: gl_program; len: Int32; name: IntPtr; v: IntPtr) :=
    z_ProgramNamedParameter4fvNV_1(id, len, name, v);
    
    private z_ProgramNamedParameter4dNV_adr := GetProcAddress('glProgramNamedParameter4dNV');
    private z_ProgramNamedParameter4dNV_1 := GetProcOrNil&<procedure(id: gl_program; len: Int32; name: IntPtr; x: real; y: real; z: real; w: real)>(z_ProgramNamedParameter4dNV_adr);
    private z_ProgramNamedParameter4dNV_2 := GetProcOrNil&<procedure(id: gl_program; len: Int32; var name: Byte; x: real; y: real; z: real; w: real)>(z_ProgramNamedParameter4dNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dNV(id: gl_program; len: Int32; name: array of Byte; x: real; y: real; z: real; w: real);
    type PByte=^Byte;
    begin
      if (name<>nil) and (name.Length<>0) then
        z_ProgramNamedParameter4dNV_2(id, len, name[0], x, y, z, w) else
        z_ProgramNamedParameter4dNV_2(id, len, PByte(nil)^, x, y, z, w);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dNV(id: gl_program; len: Int32; var name: Byte; x: real; y: real; z: real; w: real) :=
    z_ProgramNamedParameter4dNV_2(id, len, name, x, y, z, w);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dNV(id: gl_program; len: Int32; name: IntPtr; x: real; y: real; z: real; w: real) :=
    z_ProgramNamedParameter4dNV_1(id, len, name, x, y, z, w);
    
    private z_ProgramNamedParameter4dvNV_adr := GetProcAddress('glProgramNamedParameter4dvNV');
    private z_ProgramNamedParameter4dvNV_1 := GetProcOrNil&<procedure(id: gl_program; len: Int32; name: IntPtr; v: IntPtr)>(z_ProgramNamedParameter4dvNV_adr);
    private z_ProgramNamedParameter4dvNV_2 := GetProcOrNil&<procedure(id: gl_program; len: Int32; name: IntPtr; var v: real)>(z_ProgramNamedParameter4dvNV_adr);
    private z_ProgramNamedParameter4dvNV_3 := GetProcOrNil&<procedure(id: gl_program; len: Int32; var name: Byte; v: IntPtr)>(z_ProgramNamedParameter4dvNV_adr);
    private z_ProgramNamedParameter4dvNV_4 := GetProcOrNil&<procedure(id: gl_program; len: Int32; var name: Byte; var v: real)>(z_ProgramNamedParameter4dvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dvNV(id: gl_program; len: Int32; name: array of Byte; v: array of real);
    type PByte=^Byte;
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        if (name<>nil) and (name.Length<>0) then
          z_ProgramNamedParameter4dvNV_4(id, len, name[0], v[0]) else
          z_ProgramNamedParameter4dvNV_4(id, len, PByte(nil)^, v[0]) else
        if (name<>nil) and (name.Length<>0) then
          z_ProgramNamedParameter4dvNV_4(id, len, name[0], Preal(nil)^) else
          z_ProgramNamedParameter4dvNV_4(id, len, PByte(nil)^, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dvNV(id: gl_program; len: Int32; var name: Byte; var v: real) :=
    z_ProgramNamedParameter4dvNV_4(id, len, name, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dvNV(id: gl_program; len: Int32; var name: Byte; v: IntPtr) :=
    z_ProgramNamedParameter4dvNV_3(id, len, name, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dvNV(id: gl_program; len: Int32; name: IntPtr; var v: real) :=
    z_ProgramNamedParameter4dvNV_2(id, len, name, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dvNV(id: gl_program; len: Int32; name: IntPtr; v: IntPtr) :=
    z_ProgramNamedParameter4dvNV_1(id, len, name, v);
    
    private z_GetProgramNamedParameterfvNV_adr := GetProcAddress('glGetProgramNamedParameterfvNV');
    private z_GetProgramNamedParameterfvNV_1 := GetProcOrNil&<procedure(id: gl_program; len: Int32; name: IntPtr; &params: IntPtr)>(z_GetProgramNamedParameterfvNV_adr);
    private z_GetProgramNamedParameterfvNV_2 := GetProcOrNil&<procedure(id: gl_program; len: Int32; name: IntPtr; var &params: single)>(z_GetProgramNamedParameterfvNV_adr);
    private z_GetProgramNamedParameterfvNV_3 := GetProcOrNil&<procedure(id: gl_program; len: Int32; var name: Byte; &params: IntPtr)>(z_GetProgramNamedParameterfvNV_adr);
    private z_GetProgramNamedParameterfvNV_4 := GetProcOrNil&<procedure(id: gl_program; len: Int32; var name: Byte; var &params: single)>(z_GetProgramNamedParameterfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterfvNV(id: gl_program; len: Int32; name: array of Byte; var &params: single);
    type PByte=^Byte;
    begin
      if (name<>nil) and (name.Length<>0) then
        z_GetProgramNamedParameterfvNV_4(id, len, name[0], &params) else
        z_GetProgramNamedParameterfvNV_4(id, len, PByte(nil)^, &params);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterfvNV(id: gl_program; len: Int32; name: array of Byte; &params: IntPtr);
    type PByte=^Byte;
    begin
      if (name<>nil) and (name.Length<>0) then
        z_GetProgramNamedParameterfvNV_3(id, len, name[0], &params) else
        z_GetProgramNamedParameterfvNV_3(id, len, PByte(nil)^, &params);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterfvNV(id: gl_program; len: Int32; var name: Byte; var &params: single) :=
    z_GetProgramNamedParameterfvNV_4(id, len, name, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterfvNV(id: gl_program; len: Int32; var name: Byte; &params: IntPtr) :=
    z_GetProgramNamedParameterfvNV_3(id, len, name, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterfvNV(id: gl_program; len: Int32; name: IntPtr; var &params: single) :=
    z_GetProgramNamedParameterfvNV_2(id, len, name, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterfvNV(id: gl_program; len: Int32; name: IntPtr; &params: IntPtr) :=
    z_GetProgramNamedParameterfvNV_1(id, len, name, &params);
    
    private z_GetProgramNamedParameterdvNV_adr := GetProcAddress('glGetProgramNamedParameterdvNV');
    private z_GetProgramNamedParameterdvNV_1 := GetProcOrNil&<procedure(id: gl_program; len: Int32; name: IntPtr; &params: IntPtr)>(z_GetProgramNamedParameterdvNV_adr);
    private z_GetProgramNamedParameterdvNV_2 := GetProcOrNil&<procedure(id: gl_program; len: Int32; name: IntPtr; var &params: real)>(z_GetProgramNamedParameterdvNV_adr);
    private z_GetProgramNamedParameterdvNV_3 := GetProcOrNil&<procedure(id: gl_program; len: Int32; var name: Byte; &params: IntPtr)>(z_GetProgramNamedParameterdvNV_adr);
    private z_GetProgramNamedParameterdvNV_4 := GetProcOrNil&<procedure(id: gl_program; len: Int32; var name: Byte; var &params: real)>(z_GetProgramNamedParameterdvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterdvNV(id: gl_program; len: Int32; name: array of Byte; var &params: real);
    type PByte=^Byte;
    begin
      if (name<>nil) and (name.Length<>0) then
        z_GetProgramNamedParameterdvNV_4(id, len, name[0], &params) else
        z_GetProgramNamedParameterdvNV_4(id, len, PByte(nil)^, &params);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterdvNV(id: gl_program; len: Int32; name: array of Byte; &params: IntPtr);
    type PByte=^Byte;
    begin
      if (name<>nil) and (name.Length<>0) then
        z_GetProgramNamedParameterdvNV_3(id, len, name[0], &params) else
        z_GetProgramNamedParameterdvNV_3(id, len, PByte(nil)^, &params);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterdvNV(id: gl_program; len: Int32; var name: Byte; var &params: real) :=
    z_GetProgramNamedParameterdvNV_4(id, len, name, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterdvNV(id: gl_program; len: Int32; var name: Byte; &params: IntPtr) :=
    z_GetProgramNamedParameterdvNV_3(id, len, name, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterdvNV(id: gl_program; len: Int32; name: IntPtr; var &params: real) :=
    z_GetProgramNamedParameterdvNV_2(id, len, name, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterdvNV(id: gl_program; len: Int32; name: IntPtr; &params: IntPtr) :=
    z_GetProgramNamedParameterdvNV_1(id, len, name, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glFramebufferMixedSamplesNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_framebuffer_mixed_samples';
    
    private z_RasterSamplesEXT_adr := GetProcAddress('glRasterSamplesEXT');
    private z_RasterSamplesEXT_1 := GetProcOrNil&<procedure(samples: UInt32; fixedsamplelocations: boolean)>(z_RasterSamplesEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterSamplesEXT(samples: UInt32; fixedsamplelocations: boolean) :=
    z_RasterSamplesEXT_1(samples, fixedsamplelocations);
    
    private z_CoverageModulationTableNV_adr := GetProcAddress('glCoverageModulationTableNV');
    private z_CoverageModulationTableNV_1 := GetProcOrNil&<procedure(n: Int32; v: IntPtr)>(z_CoverageModulationTableNV_adr);
    private z_CoverageModulationTableNV_2 := GetProcOrNil&<procedure(n: Int32; var v: single)>(z_CoverageModulationTableNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverageModulationTableNV(n: Int32; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_CoverageModulationTableNV_2(n, v[0]) else
        z_CoverageModulationTableNV_2(n, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverageModulationTableNV(n: Int32; var v: single) :=
    z_CoverageModulationTableNV_2(n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverageModulationTableNV(n: Int32; v: IntPtr) :=
    z_CoverageModulationTableNV_1(n, v);
    
    private z_GetCoverageModulationTableNV_adr := GetProcAddress('glGetCoverageModulationTableNV');
    private z_GetCoverageModulationTableNV_1 := GetProcOrNil&<procedure(bufSize: Int32; v: IntPtr)>(z_GetCoverageModulationTableNV_adr);
    private z_GetCoverageModulationTableNV_2 := GetProcOrNil&<procedure(bufSize: Int32; var v: single)>(z_GetCoverageModulationTableNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCoverageModulationTableNV(bufSize: Int32; var v: single) :=
    z_GetCoverageModulationTableNV_2(bufSize, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCoverageModulationTableNV(bufSize: Int32; v: IntPtr) :=
    z_GetCoverageModulationTableNV_1(bufSize, v);
    
    private z_CoverageModulationNV_adr := GetProcAddress('glCoverageModulationNV');
    private z_CoverageModulationNV_1 := GetProcOrNil&<procedure(components: DummyEnum)>(z_CoverageModulationNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverageModulationNV(components: DummyEnum) :=
    z_CoverageModulationNV_1(components);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glFramebufferMultisampleCoverageNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_framebuffer_multisample_coverage';
    
    private z_RenderbufferStorageMultisampleCoverageNV_adr := GetProcAddress('glRenderbufferStorageMultisampleCoverageNV');
    private z_RenderbufferStorageMultisampleCoverageNV_1 := GetProcOrNil&<procedure(target: RenderbufferTarget; coverageSamples: Int32; colorSamples: Int32; _internalformat: InternalFormat; width: Int32; height: Int32)>(z_RenderbufferStorageMultisampleCoverageNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RenderbufferStorageMultisampleCoverageNV(target: RenderbufferTarget; coverageSamples: Int32; colorSamples: Int32; _internalformat: InternalFormat; width: Int32; height: Int32) :=
    z_RenderbufferStorageMultisampleCoverageNV_1(target, coverageSamples, colorSamples, _internalformat, width, height);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glGeometryProgram4NV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_geometry_program4';
    
    private z_ProgramVertexLimitNV_adr := GetProcAddress('glProgramVertexLimitNV');
    private z_ProgramVertexLimitNV_1 := GetProcOrNil&<procedure(target: ProgramTarget; limit: Int32)>(z_ProgramVertexLimitNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramVertexLimitNV(target: ProgramTarget; limit: Int32) :=
    z_ProgramVertexLimitNV_1(target, limit);
    
    private z_FramebufferTextureEXT_adr := GetProcAddress('glFramebufferTextureEXT');
    private z_FramebufferTextureEXT_1 := GetProcOrNil&<procedure(target: FramebufferTarget; attachment: FramebufferAttachment; texture: gl_texture; level: Int32)>(z_FramebufferTextureEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTextureEXT(target: FramebufferTarget; attachment: FramebufferAttachment; texture: gl_texture; level: Int32) :=
    z_FramebufferTextureEXT_1(target, attachment, texture, level);
    
    private z_FramebufferTextureLayerEXT_adr := GetProcAddress('glFramebufferTextureLayerEXT');
    private z_FramebufferTextureLayerEXT_1 := GetProcOrNil&<procedure(target: FramebufferTarget; attachment: FramebufferAttachment; texture: gl_texture; level: Int32; layer: Int32)>(z_FramebufferTextureLayerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTextureLayerEXT(target: FramebufferTarget; attachment: FramebufferAttachment; texture: gl_texture; level: Int32; layer: Int32) :=
    z_FramebufferTextureLayerEXT_1(target, attachment, texture, level, layer);
    
    private z_FramebufferTextureFaceEXT_adr := GetProcAddress('glFramebufferTextureFaceEXT');
    private z_FramebufferTextureFaceEXT_1 := GetProcOrNil&<procedure(target: FramebufferTarget; attachment: FramebufferAttachment; texture: gl_texture; level: Int32; face: TextureTarget)>(z_FramebufferTextureFaceEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTextureFaceEXT(target: FramebufferTarget; attachment: FramebufferAttachment; texture: gl_texture; level: Int32; face: TextureTarget) :=
    z_FramebufferTextureFaceEXT_1(target, attachment, texture, level, face);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glGpuProgram4NV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_gpu_program4';
    
    private z_ProgramLocalParameterI4iNV_adr := GetProcAddress('glProgramLocalParameterI4iNV');
    private z_ProgramLocalParameterI4iNV_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32)>(z_ProgramLocalParameterI4iNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameterI4iNV(target: ProgramTarget; index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32) :=
    z_ProgramLocalParameterI4iNV_1(target, index, x, y, z, w);
    
    private z_ProgramLocalParameterI4ivNV_adr := GetProcAddress('glProgramLocalParameterI4ivNV');
    private z_ProgramLocalParameterI4ivNV_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; &params: IntPtr)>(z_ProgramLocalParameterI4ivNV_adr);
    private z_ProgramLocalParameterI4ivNV_2 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; var &params: Int32)>(z_ProgramLocalParameterI4ivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameterI4ivNV(target: ProgramTarget; index: UInt32; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_ProgramLocalParameterI4ivNV_2(target, index, &params[0]) else
        z_ProgramLocalParameterI4ivNV_2(target, index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameterI4ivNV(target: ProgramTarget; index: UInt32; var &params: Int32) :=
    z_ProgramLocalParameterI4ivNV_2(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameterI4ivNV(target: ProgramTarget; index: UInt32; &params: IntPtr) :=
    z_ProgramLocalParameterI4ivNV_1(target, index, &params);
    
    private z_ProgramLocalParametersI4ivNV_adr := GetProcAddress('glProgramLocalParametersI4ivNV');
    private z_ProgramLocalParametersI4ivNV_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; count: Int32; &params: IntPtr)>(z_ProgramLocalParametersI4ivNV_adr);
    private z_ProgramLocalParametersI4ivNV_2 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; count: Int32; var &params: Int32)>(z_ProgramLocalParametersI4ivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParametersI4ivNV(target: ProgramTarget; index: UInt32; count: Int32; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_ProgramLocalParametersI4ivNV_2(target, index, count, &params[0]) else
        z_ProgramLocalParametersI4ivNV_2(target, index, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParametersI4ivNV(target: ProgramTarget; index: UInt32; count: Int32; var &params: Int32) :=
    z_ProgramLocalParametersI4ivNV_2(target, index, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParametersI4ivNV(target: ProgramTarget; index: UInt32; count: Int32; &params: IntPtr) :=
    z_ProgramLocalParametersI4ivNV_1(target, index, count, &params);
    
    private z_ProgramLocalParameterI4uiNV_adr := GetProcAddress('glProgramLocalParameterI4uiNV');
    private z_ProgramLocalParameterI4uiNV_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32)>(z_ProgramLocalParameterI4uiNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameterI4uiNV(target: ProgramTarget; index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32) :=
    z_ProgramLocalParameterI4uiNV_1(target, index, x, y, z, w);
    
    private z_ProgramLocalParameterI4uivNV_adr := GetProcAddress('glProgramLocalParameterI4uivNV');
    private z_ProgramLocalParameterI4uivNV_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; &params: IntPtr)>(z_ProgramLocalParameterI4uivNV_adr);
    private z_ProgramLocalParameterI4uivNV_2 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; var &params: UInt32)>(z_ProgramLocalParameterI4uivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameterI4uivNV(target: ProgramTarget; index: UInt32; &params: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_ProgramLocalParameterI4uivNV_2(target, index, &params[0]) else
        z_ProgramLocalParameterI4uivNV_2(target, index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameterI4uivNV(target: ProgramTarget; index: UInt32; var &params: UInt32) :=
    z_ProgramLocalParameterI4uivNV_2(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameterI4uivNV(target: ProgramTarget; index: UInt32; &params: IntPtr) :=
    z_ProgramLocalParameterI4uivNV_1(target, index, &params);
    
    private z_ProgramLocalParametersI4uivNV_adr := GetProcAddress('glProgramLocalParametersI4uivNV');
    private z_ProgramLocalParametersI4uivNV_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; count: Int32; &params: IntPtr)>(z_ProgramLocalParametersI4uivNV_adr);
    private z_ProgramLocalParametersI4uivNV_2 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; count: Int32; var &params: UInt32)>(z_ProgramLocalParametersI4uivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParametersI4uivNV(target: ProgramTarget; index: UInt32; count: Int32; &params: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_ProgramLocalParametersI4uivNV_2(target, index, count, &params[0]) else
        z_ProgramLocalParametersI4uivNV_2(target, index, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParametersI4uivNV(target: ProgramTarget; index: UInt32; count: Int32; var &params: UInt32) :=
    z_ProgramLocalParametersI4uivNV_2(target, index, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParametersI4uivNV(target: ProgramTarget; index: UInt32; count: Int32; &params: IntPtr) :=
    z_ProgramLocalParametersI4uivNV_1(target, index, count, &params);
    
    private z_ProgramEnvParameterI4iNV_adr := GetProcAddress('glProgramEnvParameterI4iNV');
    private z_ProgramEnvParameterI4iNV_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32)>(z_ProgramEnvParameterI4iNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameterI4iNV(target: ProgramTarget; index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32) :=
    z_ProgramEnvParameterI4iNV_1(target, index, x, y, z, w);
    
    private z_ProgramEnvParameterI4ivNV_adr := GetProcAddress('glProgramEnvParameterI4ivNV');
    private z_ProgramEnvParameterI4ivNV_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; &params: IntPtr)>(z_ProgramEnvParameterI4ivNV_adr);
    private z_ProgramEnvParameterI4ivNV_2 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; var &params: Int32)>(z_ProgramEnvParameterI4ivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameterI4ivNV(target: ProgramTarget; index: UInt32; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_ProgramEnvParameterI4ivNV_2(target, index, &params[0]) else
        z_ProgramEnvParameterI4ivNV_2(target, index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameterI4ivNV(target: ProgramTarget; index: UInt32; var &params: Int32) :=
    z_ProgramEnvParameterI4ivNV_2(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameterI4ivNV(target: ProgramTarget; index: UInt32; &params: IntPtr) :=
    z_ProgramEnvParameterI4ivNV_1(target, index, &params);
    
    private z_ProgramEnvParametersI4ivNV_adr := GetProcAddress('glProgramEnvParametersI4ivNV');
    private z_ProgramEnvParametersI4ivNV_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; count: Int32; &params: IntPtr)>(z_ProgramEnvParametersI4ivNV_adr);
    private z_ProgramEnvParametersI4ivNV_2 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; count: Int32; var &params: Int32)>(z_ProgramEnvParametersI4ivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParametersI4ivNV(target: ProgramTarget; index: UInt32; count: Int32; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_ProgramEnvParametersI4ivNV_2(target, index, count, &params[0]) else
        z_ProgramEnvParametersI4ivNV_2(target, index, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParametersI4ivNV(target: ProgramTarget; index: UInt32; count: Int32; var &params: Int32) :=
    z_ProgramEnvParametersI4ivNV_2(target, index, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParametersI4ivNV(target: ProgramTarget; index: UInt32; count: Int32; &params: IntPtr) :=
    z_ProgramEnvParametersI4ivNV_1(target, index, count, &params);
    
    private z_ProgramEnvParameterI4uiNV_adr := GetProcAddress('glProgramEnvParameterI4uiNV');
    private z_ProgramEnvParameterI4uiNV_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32)>(z_ProgramEnvParameterI4uiNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameterI4uiNV(target: ProgramTarget; index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32) :=
    z_ProgramEnvParameterI4uiNV_1(target, index, x, y, z, w);
    
    private z_ProgramEnvParameterI4uivNV_adr := GetProcAddress('glProgramEnvParameterI4uivNV');
    private z_ProgramEnvParameterI4uivNV_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; &params: IntPtr)>(z_ProgramEnvParameterI4uivNV_adr);
    private z_ProgramEnvParameterI4uivNV_2 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; var &params: UInt32)>(z_ProgramEnvParameterI4uivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameterI4uivNV(target: ProgramTarget; index: UInt32; &params: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_ProgramEnvParameterI4uivNV_2(target, index, &params[0]) else
        z_ProgramEnvParameterI4uivNV_2(target, index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameterI4uivNV(target: ProgramTarget; index: UInt32; var &params: UInt32) :=
    z_ProgramEnvParameterI4uivNV_2(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameterI4uivNV(target: ProgramTarget; index: UInt32; &params: IntPtr) :=
    z_ProgramEnvParameterI4uivNV_1(target, index, &params);
    
    private z_ProgramEnvParametersI4uivNV_adr := GetProcAddress('glProgramEnvParametersI4uivNV');
    private z_ProgramEnvParametersI4uivNV_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; count: Int32; &params: IntPtr)>(z_ProgramEnvParametersI4uivNV_adr);
    private z_ProgramEnvParametersI4uivNV_2 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; count: Int32; var &params: UInt32)>(z_ProgramEnvParametersI4uivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParametersI4uivNV(target: ProgramTarget; index: UInt32; count: Int32; &params: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_ProgramEnvParametersI4uivNV_2(target, index, count, &params[0]) else
        z_ProgramEnvParametersI4uivNV_2(target, index, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParametersI4uivNV(target: ProgramTarget; index: UInt32; count: Int32; var &params: UInt32) :=
    z_ProgramEnvParametersI4uivNV_2(target, index, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParametersI4uivNV(target: ProgramTarget; index: UInt32; count: Int32; &params: IntPtr) :=
    z_ProgramEnvParametersI4uivNV_1(target, index, count, &params);
    
    private z_GetProgramLocalParameterIivNV_adr := GetProcAddress('glGetProgramLocalParameterIivNV');
    private z_GetProgramLocalParameterIivNV_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; &params: IntPtr)>(z_GetProgramLocalParameterIivNV_adr);
    private z_GetProgramLocalParameterIivNV_2 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; var &params: Int32)>(z_GetProgramLocalParameterIivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterIivNV(target: ProgramTarget; index: UInt32; var &params: Int32) :=
    z_GetProgramLocalParameterIivNV_2(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterIivNV(target: ProgramTarget; index: UInt32; &params: IntPtr) :=
    z_GetProgramLocalParameterIivNV_1(target, index, &params);
    
    private z_GetProgramLocalParameterIuivNV_adr := GetProcAddress('glGetProgramLocalParameterIuivNV');
    private z_GetProgramLocalParameterIuivNV_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; &params: IntPtr)>(z_GetProgramLocalParameterIuivNV_adr);
    private z_GetProgramLocalParameterIuivNV_2 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; var &params: UInt32)>(z_GetProgramLocalParameterIuivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterIuivNV(target: ProgramTarget; index: UInt32; var &params: UInt32) :=
    z_GetProgramLocalParameterIuivNV_2(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterIuivNV(target: ProgramTarget; index: UInt32; &params: IntPtr) :=
    z_GetProgramLocalParameterIuivNV_1(target, index, &params);
    
    private z_GetProgramEnvParameterIivNV_adr := GetProcAddress('glGetProgramEnvParameterIivNV');
    private z_GetProgramEnvParameterIivNV_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; &params: IntPtr)>(z_GetProgramEnvParameterIivNV_adr);
    private z_GetProgramEnvParameterIivNV_2 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; var &params: Int32)>(z_GetProgramEnvParameterIivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterIivNV(target: ProgramTarget; index: UInt32; var &params: Int32) :=
    z_GetProgramEnvParameterIivNV_2(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterIivNV(target: ProgramTarget; index: UInt32; &params: IntPtr) :=
    z_GetProgramEnvParameterIivNV_1(target, index, &params);
    
    private z_GetProgramEnvParameterIuivNV_adr := GetProcAddress('glGetProgramEnvParameterIuivNV');
    private z_GetProgramEnvParameterIuivNV_1 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; &params: IntPtr)>(z_GetProgramEnvParameterIuivNV_adr);
    private z_GetProgramEnvParameterIuivNV_2 := GetProcOrNil&<procedure(target: ProgramTarget; index: UInt32; var &params: UInt32)>(z_GetProgramEnvParameterIuivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterIuivNV(target: ProgramTarget; index: UInt32; var &params: UInt32) :=
    z_GetProgramEnvParameterIuivNV_2(target, index, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterIuivNV(target: ProgramTarget; index: UInt32; &params: IntPtr) :=
    z_GetProgramEnvParameterIuivNV_1(target, index, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glGpuProgram5NV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_gpu_program5';
    
    private z_ProgramSubroutineParametersuivNV_adr := GetProcAddress('glProgramSubroutineParametersuivNV');
    private z_ProgramSubroutineParametersuivNV_1 := GetProcOrNil&<procedure(target: DummyEnum; count: Int32; &params: IntPtr)>(z_ProgramSubroutineParametersuivNV_adr);
    private z_ProgramSubroutineParametersuivNV_2 := GetProcOrNil&<procedure(target: DummyEnum; count: Int32; var &params: UInt32)>(z_ProgramSubroutineParametersuivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramSubroutineParametersuivNV(target: DummyEnum; count: Int32; &params: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_ProgramSubroutineParametersuivNV_2(target, count, &params[0]) else
        z_ProgramSubroutineParametersuivNV_2(target, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramSubroutineParametersuivNV(target: DummyEnum; count: Int32; var &params: UInt32) :=
    z_ProgramSubroutineParametersuivNV_2(target, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramSubroutineParametersuivNV(target: DummyEnum; count: Int32; &params: IntPtr) :=
    z_ProgramSubroutineParametersuivNV_1(target, count, &params);
    
    private z_GetProgramSubroutineParameteruivNV_adr := GetProcAddress('glGetProgramSubroutineParameteruivNV');
    private z_GetProgramSubroutineParameteruivNV_1 := GetProcOrNil&<procedure(target: DummyEnum; index: UInt32; param: IntPtr)>(z_GetProgramSubroutineParameteruivNV_adr);
    private z_GetProgramSubroutineParameteruivNV_2 := GetProcOrNil&<procedure(target: DummyEnum; index: UInt32; var param: UInt32)>(z_GetProgramSubroutineParameteruivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramSubroutineParameteruivNV(target: DummyEnum; index: UInt32; var param: UInt32) :=
    z_GetProgramSubroutineParameteruivNV_2(target, index, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramSubroutineParameteruivNV(target: DummyEnum; index: UInt32; param: IntPtr) :=
    z_GetProgramSubroutineParameteruivNV_1(target, index, param);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glGpuShader5NV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_gpu_shader5';
    
    private z_Uniform1i64NV_adr := GetProcAddress('glUniform1i64NV');
    private z_Uniform1i64NV_1 := GetProcOrNil&<procedure(location: Int32; x: Int64)>(z_Uniform1i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i64NV(location: Int32; x: Int64) :=
    z_Uniform1i64NV_1(location, x);
    
    private z_Uniform2i64NV_adr := GetProcAddress('glUniform2i64NV');
    private z_Uniform2i64NV_1 := GetProcOrNil&<procedure(location: Int32; x: Int64; y: Int64)>(z_Uniform2i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64NV(location: Int32; x: Int64; y: Int64) :=
    z_Uniform2i64NV_1(location, x, y);
    
    private z_Uniform3i64NV_adr := GetProcAddress('glUniform3i64NV');
    private z_Uniform3i64NV_1 := GetProcOrNil&<procedure(location: Int32; x: Int64; y: Int64; z: Int64)>(z_Uniform3i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64NV(location: Int32; x: Int64; y: Int64; z: Int64) :=
    z_Uniform3i64NV_1(location, x, y, z);
    
    private z_Uniform4i64NV_adr := GetProcAddress('glUniform4i64NV');
    private z_Uniform4i64NV_1 := GetProcOrNil&<procedure(location: Int32; x: Int64; y: Int64; z: Int64; w: Int64)>(z_Uniform4i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64NV(location: Int32; x: Int64; y: Int64; z: Int64; w: Int64) :=
    z_Uniform4i64NV_1(location, x, y, z, w);
    
    private z_Uniform1i64vNV_adr := GetProcAddress('glUniform1i64vNV');
    private z_Uniform1i64vNV_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform1i64vNV_adr);
    private z_Uniform1i64vNV_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int64)>(z_Uniform1i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i64vNV(location: Int32; count: Int32; value: array of Int64);
    type PInt64=^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform1i64vNV_2(location, count, value[0]) else
        z_Uniform1i64vNV_2(location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i64vNV(location: Int32; count: Int32; var value: Int64) :=
    z_Uniform1i64vNV_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i64vNV(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform1i64vNV_1(location, count, value);
    
    private z_Uniform2i64vNV_adr := GetProcAddress('glUniform2i64vNV');
    private z_Uniform2i64vNV_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform2i64vNV_adr);
    private z_Uniform2i64vNV_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int64)>(z_Uniform2i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64vNV(location: Int32; count: Int32; value: array of Int64);
    type PInt64=^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform2i64vNV_2(location, count, value[0]) else
        z_Uniform2i64vNV_2(location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64vNV(location: Int32; count: Int32; var value: Int64) :=
    z_Uniform2i64vNV_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64vNV(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform2i64vNV_1(location, count, value);
    
    private z_Uniform3i64vNV_adr := GetProcAddress('glUniform3i64vNV');
    private z_Uniform3i64vNV_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform3i64vNV_adr);
    private z_Uniform3i64vNV_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int64)>(z_Uniform3i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64vNV(location: Int32; count: Int32; value: array of Int64);
    type PInt64=^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform3i64vNV_2(location, count, value[0]) else
        z_Uniform3i64vNV_2(location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64vNV(location: Int32; count: Int32; var value: Int64) :=
    z_Uniform3i64vNV_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64vNV(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform3i64vNV_1(location, count, value);
    
    private z_Uniform4i64vNV_adr := GetProcAddress('glUniform4i64vNV');
    private z_Uniform4i64vNV_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform4i64vNV_adr);
    private z_Uniform4i64vNV_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: Int64)>(z_Uniform4i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64vNV(location: Int32; count: Int32; value: array of Int64);
    type PInt64=^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform4i64vNV_2(location, count, value[0]) else
        z_Uniform4i64vNV_2(location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64vNV(location: Int32; count: Int32; var value: Int64) :=
    z_Uniform4i64vNV_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64vNV(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform4i64vNV_1(location, count, value);
    
    private z_Uniform1ui64NV_adr := GetProcAddress('glUniform1ui64NV');
    private z_Uniform1ui64NV_1 := GetProcOrNil&<procedure(location: Int32; x: UInt64)>(z_Uniform1ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui64NV(location: Int32; x: UInt64) :=
    z_Uniform1ui64NV_1(location, x);
    
    private z_Uniform2ui64NV_adr := GetProcAddress('glUniform2ui64NV');
    private z_Uniform2ui64NV_1 := GetProcOrNil&<procedure(location: Int32; x: UInt64; y: UInt64)>(z_Uniform2ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64NV(location: Int32; x: UInt64; y: UInt64) :=
    z_Uniform2ui64NV_1(location, x, y);
    
    private z_Uniform3ui64NV_adr := GetProcAddress('glUniform3ui64NV');
    private z_Uniform3ui64NV_1 := GetProcOrNil&<procedure(location: Int32; x: UInt64; y: UInt64; z: UInt64)>(z_Uniform3ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64NV(location: Int32; x: UInt64; y: UInt64; z: UInt64) :=
    z_Uniform3ui64NV_1(location, x, y, z);
    
    private z_Uniform4ui64NV_adr := GetProcAddress('glUniform4ui64NV');
    private z_Uniform4ui64NV_1 := GetProcOrNil&<procedure(location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64)>(z_Uniform4ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64NV(location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64) :=
    z_Uniform4ui64NV_1(location, x, y, z, w);
    
    private z_Uniform1ui64vNV_adr := GetProcAddress('glUniform1ui64vNV');
    private z_Uniform1ui64vNV_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform1ui64vNV_adr);
    private z_Uniform1ui64vNV_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt64)>(z_Uniform1ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui64vNV(location: Int32; count: Int32; value: array of UInt64);
    type PUInt64=^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform1ui64vNV_2(location, count, value[0]) else
        z_Uniform1ui64vNV_2(location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui64vNV(location: Int32; count: Int32; var value: UInt64) :=
    z_Uniform1ui64vNV_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui64vNV(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform1ui64vNV_1(location, count, value);
    
    private z_Uniform2ui64vNV_adr := GetProcAddress('glUniform2ui64vNV');
    private z_Uniform2ui64vNV_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform2ui64vNV_adr);
    private z_Uniform2ui64vNV_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt64)>(z_Uniform2ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64vNV(location: Int32; count: Int32; value: array of UInt64);
    type PUInt64=^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform2ui64vNV_2(location, count, value[0]) else
        z_Uniform2ui64vNV_2(location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64vNV(location: Int32; count: Int32; var value: UInt64) :=
    z_Uniform2ui64vNV_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64vNV(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform2ui64vNV_1(location, count, value);
    
    private z_Uniform3ui64vNV_adr := GetProcAddress('glUniform3ui64vNV');
    private z_Uniform3ui64vNV_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform3ui64vNV_adr);
    private z_Uniform3ui64vNV_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt64)>(z_Uniform3ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64vNV(location: Int32; count: Int32; value: array of UInt64);
    type PUInt64=^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform3ui64vNV_2(location, count, value[0]) else
        z_Uniform3ui64vNV_2(location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64vNV(location: Int32; count: Int32; var value: UInt64) :=
    z_Uniform3ui64vNV_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64vNV(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform3ui64vNV_1(location, count, value);
    
    private z_Uniform4ui64vNV_adr := GetProcAddress('glUniform4ui64vNV');
    private z_Uniform4ui64vNV_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniform4ui64vNV_adr);
    private z_Uniform4ui64vNV_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt64)>(z_Uniform4ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64vNV(location: Int32; count: Int32; value: array of UInt64);
    type PUInt64=^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniform4ui64vNV_2(location, count, value[0]) else
        z_Uniform4ui64vNV_2(location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64vNV(location: Int32; count: Int32; var value: UInt64) :=
    z_Uniform4ui64vNV_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64vNV(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniform4ui64vNV_1(location, count, value);
    
    private z_GetUniformi64vNV_adr := GetProcAddress('glGetUniformi64vNV');
    private z_GetUniformi64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; &params: IntPtr)>(z_GetUniformi64vNV_adr);
    private z_GetUniformi64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; var &params: Int64)>(z_GetUniformi64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformi64vNV(&program: gl_program; location: Int32; var &params: Int64) :=
    z_GetUniformi64vNV_2(&program, location, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformi64vNV(&program: gl_program; location: Int32; &params: IntPtr) :=
    z_GetUniformi64vNV_1(&program, location, &params);
    
    private z_ProgramUniform1i64NV_adr := GetProcAddress('glProgramUniform1i64NV');
    private z_ProgramUniform1i64NV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: Int64)>(z_ProgramUniform1i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i64NV(&program: gl_program; location: Int32; x: Int64) :=
    z_ProgramUniform1i64NV_1(&program, location, x);
    
    private z_ProgramUniform2i64NV_adr := GetProcAddress('glProgramUniform2i64NV');
    private z_ProgramUniform2i64NV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: Int64; y: Int64)>(z_ProgramUniform2i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64NV(&program: gl_program; location: Int32; x: Int64; y: Int64) :=
    z_ProgramUniform2i64NV_1(&program, location, x, y);
    
    private z_ProgramUniform3i64NV_adr := GetProcAddress('glProgramUniform3i64NV');
    private z_ProgramUniform3i64NV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: Int64; y: Int64; z: Int64)>(z_ProgramUniform3i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64NV(&program: gl_program; location: Int32; x: Int64; y: Int64; z: Int64) :=
    z_ProgramUniform3i64NV_1(&program, location, x, y, z);
    
    private z_ProgramUniform4i64NV_adr := GetProcAddress('glProgramUniform4i64NV');
    private z_ProgramUniform4i64NV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: Int64; y: Int64; z: Int64; w: Int64)>(z_ProgramUniform4i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64NV(&program: gl_program; location: Int32; x: Int64; y: Int64; z: Int64; w: Int64) :=
    z_ProgramUniform4i64NV_1(&program, location, x, y, z, w);
    
    private z_ProgramUniform1i64vNV_adr := GetProcAddress('glProgramUniform1i64vNV');
    private z_ProgramUniform1i64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform1i64vNV_adr);
    private z_ProgramUniform1i64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int64)>(z_ProgramUniform1i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i64vNV(&program: gl_program; location: Int32; count: Int32; value: array of Int64);
    type PInt64=^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform1i64vNV_2(&program, location, count, value[0]) else
        z_ProgramUniform1i64vNV_2(&program, location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i64vNV(&program: gl_program; location: Int32; count: Int32; var value: Int64) :=
    z_ProgramUniform1i64vNV_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i64vNV(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform1i64vNV_1(&program, location, count, value);
    
    private z_ProgramUniform2i64vNV_adr := GetProcAddress('glProgramUniform2i64vNV');
    private z_ProgramUniform2i64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform2i64vNV_adr);
    private z_ProgramUniform2i64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int64)>(z_ProgramUniform2i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64vNV(&program: gl_program; location: Int32; count: Int32; value: array of Int64);
    type PInt64=^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform2i64vNV_2(&program, location, count, value[0]) else
        z_ProgramUniform2i64vNV_2(&program, location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64vNV(&program: gl_program; location: Int32; count: Int32; var value: Int64) :=
    z_ProgramUniform2i64vNV_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64vNV(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform2i64vNV_1(&program, location, count, value);
    
    private z_ProgramUniform3i64vNV_adr := GetProcAddress('glProgramUniform3i64vNV');
    private z_ProgramUniform3i64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform3i64vNV_adr);
    private z_ProgramUniform3i64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int64)>(z_ProgramUniform3i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64vNV(&program: gl_program; location: Int32; count: Int32; value: array of Int64);
    type PInt64=^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform3i64vNV_2(&program, location, count, value[0]) else
        z_ProgramUniform3i64vNV_2(&program, location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64vNV(&program: gl_program; location: Int32; count: Int32; var value: Int64) :=
    z_ProgramUniform3i64vNV_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64vNV(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform3i64vNV_1(&program, location, count, value);
    
    private z_ProgramUniform4i64vNV_adr := GetProcAddress('glProgramUniform4i64vNV');
    private z_ProgramUniform4i64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform4i64vNV_adr);
    private z_ProgramUniform4i64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: Int64)>(z_ProgramUniform4i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64vNV(&program: gl_program; location: Int32; count: Int32; value: array of Int64);
    type PInt64=^Int64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform4i64vNV_2(&program, location, count, value[0]) else
        z_ProgramUniform4i64vNV_2(&program, location, count, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64vNV(&program: gl_program; location: Int32; count: Int32; var value: Int64) :=
    z_ProgramUniform4i64vNV_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64vNV(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform4i64vNV_1(&program, location, count, value);
    
    private z_ProgramUniform1ui64NV_adr := GetProcAddress('glProgramUniform1ui64NV');
    private z_ProgramUniform1ui64NV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: UInt64)>(z_ProgramUniform1ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui64NV(&program: gl_program; location: Int32; x: UInt64) :=
    z_ProgramUniform1ui64NV_1(&program, location, x);
    
    private z_ProgramUniform2ui64NV_adr := GetProcAddress('glProgramUniform2ui64NV');
    private z_ProgramUniform2ui64NV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: UInt64; y: UInt64)>(z_ProgramUniform2ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64NV(&program: gl_program; location: Int32; x: UInt64; y: UInt64) :=
    z_ProgramUniform2ui64NV_1(&program, location, x, y);
    
    private z_ProgramUniform3ui64NV_adr := GetProcAddress('glProgramUniform3ui64NV');
    private z_ProgramUniform3ui64NV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: UInt64; y: UInt64; z: UInt64)>(z_ProgramUniform3ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64NV(&program: gl_program; location: Int32; x: UInt64; y: UInt64; z: UInt64) :=
    z_ProgramUniform3ui64NV_1(&program, location, x, y, z);
    
    private z_ProgramUniform4ui64NV_adr := GetProcAddress('glProgramUniform4ui64NV');
    private z_ProgramUniform4ui64NV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64)>(z_ProgramUniform4ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64NV(&program: gl_program; location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64) :=
    z_ProgramUniform4ui64NV_1(&program, location, x, y, z, w);
    
    private z_ProgramUniform1ui64vNV_adr := GetProcAddress('glProgramUniform1ui64vNV');
    private z_ProgramUniform1ui64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform1ui64vNV_adr);
    private z_ProgramUniform1ui64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt64)>(z_ProgramUniform1ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui64vNV(&program: gl_program; location: Int32; count: Int32; value: array of UInt64);
    type PUInt64=^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform1ui64vNV_2(&program, location, count, value[0]) else
        z_ProgramUniform1ui64vNV_2(&program, location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui64vNV(&program: gl_program; location: Int32; count: Int32; var value: UInt64) :=
    z_ProgramUniform1ui64vNV_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui64vNV(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform1ui64vNV_1(&program, location, count, value);
    
    private z_ProgramUniform2ui64vNV_adr := GetProcAddress('glProgramUniform2ui64vNV');
    private z_ProgramUniform2ui64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform2ui64vNV_adr);
    private z_ProgramUniform2ui64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt64)>(z_ProgramUniform2ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64vNV(&program: gl_program; location: Int32; count: Int32; value: array of UInt64);
    type PUInt64=^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform2ui64vNV_2(&program, location, count, value[0]) else
        z_ProgramUniform2ui64vNV_2(&program, location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64vNV(&program: gl_program; location: Int32; count: Int32; var value: UInt64) :=
    z_ProgramUniform2ui64vNV_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64vNV(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform2ui64vNV_1(&program, location, count, value);
    
    private z_ProgramUniform3ui64vNV_adr := GetProcAddress('glProgramUniform3ui64vNV');
    private z_ProgramUniform3ui64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform3ui64vNV_adr);
    private z_ProgramUniform3ui64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt64)>(z_ProgramUniform3ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64vNV(&program: gl_program; location: Int32; count: Int32; value: array of UInt64);
    type PUInt64=^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform3ui64vNV_2(&program, location, count, value[0]) else
        z_ProgramUniform3ui64vNV_2(&program, location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64vNV(&program: gl_program; location: Int32; count: Int32; var value: UInt64) :=
    z_ProgramUniform3ui64vNV_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64vNV(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform3ui64vNV_1(&program, location, count, value);
    
    private z_ProgramUniform4ui64vNV_adr := GetProcAddress('glProgramUniform4ui64vNV');
    private z_ProgramUniform4ui64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniform4ui64vNV_adr);
    private z_ProgramUniform4ui64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt64)>(z_ProgramUniform4ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64vNV(&program: gl_program; location: Int32; count: Int32; value: array of UInt64);
    type PUInt64=^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniform4ui64vNV_2(&program, location, count, value[0]) else
        z_ProgramUniform4ui64vNV_2(&program, location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64vNV(&program: gl_program; location: Int32; count: Int32; var value: UInt64) :=
    z_ProgramUniform4ui64vNV_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64vNV(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniform4ui64vNV_1(&program, location, count, value);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glHalfFloatNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_half_float';
    
    private z_Vertex2hNV_adr := GetProcAddress('glVertex2hNV');
    private z_Vertex2hNV_1 := GetProcOrNil&<procedure(x: Half; y: Half)>(z_Vertex2hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2hNV(x: Half; y: Half) :=
    z_Vertex2hNV_1(x, y);
    
    private z_Vertex2hvNV_adr := GetProcAddress('glVertex2hvNV');
    private z_Vertex2hvNV_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Vertex2hvNV_adr);
    private z_Vertex2hvNV_2 := GetProcOrNil&<procedure(var v: Half)>(z_Vertex2hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2hvNV(v: array of Half);
    type PHalf=^Half;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Vertex2hvNV_2(v[0]) else
        z_Vertex2hvNV_2(PHalf(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2hvNV(var v: Half) :=
    z_Vertex2hvNV_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2hvNV(v: IntPtr) :=
    z_Vertex2hvNV_1(v);
    
    private z_Vertex3hNV_adr := GetProcAddress('glVertex3hNV');
    private z_Vertex3hNV_1 := GetProcOrNil&<procedure(x: Half; y: Half; z: Half)>(z_Vertex3hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3hNV(x: Half; y: Half; z: Half) :=
    z_Vertex3hNV_1(x, y, z);
    
    private z_Vertex3hvNV_adr := GetProcAddress('glVertex3hvNV');
    private z_Vertex3hvNV_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Vertex3hvNV_adr);
    private z_Vertex3hvNV_2 := GetProcOrNil&<procedure(var v: Half)>(z_Vertex3hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3hvNV(v: array of Half);
    type PHalf=^Half;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Vertex3hvNV_2(v[0]) else
        z_Vertex3hvNV_2(PHalf(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3hvNV(var v: Half) :=
    z_Vertex3hvNV_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3hvNV(v: IntPtr) :=
    z_Vertex3hvNV_1(v);
    
    private z_Vertex4hNV_adr := GetProcAddress('glVertex4hNV');
    private z_Vertex4hNV_1 := GetProcOrNil&<procedure(x: Half; y: Half; z: Half; w: Half)>(z_Vertex4hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4hNV(x: Half; y: Half; z: Half; w: Half) :=
    z_Vertex4hNV_1(x, y, z, w);
    
    private z_Vertex4hvNV_adr := GetProcAddress('glVertex4hvNV');
    private z_Vertex4hvNV_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Vertex4hvNV_adr);
    private z_Vertex4hvNV_2 := GetProcOrNil&<procedure(var v: Half)>(z_Vertex4hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4hvNV(v: array of Half);
    type PHalf=^Half;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Vertex4hvNV_2(v[0]) else
        z_Vertex4hvNV_2(PHalf(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4hvNV(var v: Half) :=
    z_Vertex4hvNV_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4hvNV(v: IntPtr) :=
    z_Vertex4hvNV_1(v);
    
    private z_Normal3hNV_adr := GetProcAddress('glNormal3hNV');
    private z_Normal3hNV_1 := GetProcOrNil&<procedure(nx: Half; ny: Half; nz: Half)>(z_Normal3hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3hNV(nx: Half; ny: Half; nz: Half) :=
    z_Normal3hNV_1(nx, ny, nz);
    
    private z_Normal3hvNV_adr := GetProcAddress('glNormal3hvNV');
    private z_Normal3hvNV_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Normal3hvNV_adr);
    private z_Normal3hvNV_2 := GetProcOrNil&<procedure(var v: Half)>(z_Normal3hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3hvNV(v: array of Half);
    type PHalf=^Half;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Normal3hvNV_2(v[0]) else
        z_Normal3hvNV_2(PHalf(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3hvNV(var v: Half) :=
    z_Normal3hvNV_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3hvNV(v: IntPtr) :=
    z_Normal3hvNV_1(v);
    
    private z_Color3hNV_adr := GetProcAddress('glColor3hNV');
    private z_Color3hNV_1 := GetProcOrNil&<procedure(red: Half; green: Half; blue: Half)>(z_Color3hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3hNV(red: Half; green: Half; blue: Half) :=
    z_Color3hNV_1(red, green, blue);
    
    private z_Color3hvNV_adr := GetProcAddress('glColor3hvNV');
    private z_Color3hvNV_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Color3hvNV_adr);
    private z_Color3hvNV_2 := GetProcOrNil&<procedure(var v: Half)>(z_Color3hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3hvNV(v: array of Half);
    type PHalf=^Half;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Color3hvNV_2(v[0]) else
        z_Color3hvNV_2(PHalf(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3hvNV(var v: Half) :=
    z_Color3hvNV_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3hvNV(v: IntPtr) :=
    z_Color3hvNV_1(v);
    
    private z_Color4hNV_adr := GetProcAddress('glColor4hNV');
    private z_Color4hNV_1 := GetProcOrNil&<procedure(red: Half; green: Half; blue: Half; alpha: Half)>(z_Color4hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4hNV(red: Half; green: Half; blue: Half; alpha: Half) :=
    z_Color4hNV_1(red, green, blue, alpha);
    
    private z_Color4hvNV_adr := GetProcAddress('glColor4hvNV');
    private z_Color4hvNV_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_Color4hvNV_adr);
    private z_Color4hvNV_2 := GetProcOrNil&<procedure(var v: Half)>(z_Color4hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4hvNV(v: array of Half);
    type PHalf=^Half;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_Color4hvNV_2(v[0]) else
        z_Color4hvNV_2(PHalf(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4hvNV(var v: Half) :=
    z_Color4hvNV_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4hvNV(v: IntPtr) :=
    z_Color4hvNV_1(v);
    
    private z_TexCoord1hNV_adr := GetProcAddress('glTexCoord1hNV');
    private z_TexCoord1hNV_1 := GetProcOrNil&<procedure(s: Half)>(z_TexCoord1hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1hNV(s: Half) :=
    z_TexCoord1hNV_1(s);
    
    private z_TexCoord1hvNV_adr := GetProcAddress('glTexCoord1hvNV');
    private z_TexCoord1hvNV_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_TexCoord1hvNV_adr);
    private z_TexCoord1hvNV_2 := GetProcOrNil&<procedure(var v: Half)>(z_TexCoord1hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1hvNV(v: array of Half);
    type PHalf=^Half;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_TexCoord1hvNV_2(v[0]) else
        z_TexCoord1hvNV_2(PHalf(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1hvNV(var v: Half) :=
    z_TexCoord1hvNV_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1hvNV(v: IntPtr) :=
    z_TexCoord1hvNV_1(v);
    
    private z_TexCoord2hNV_adr := GetProcAddress('glTexCoord2hNV');
    private z_TexCoord2hNV_1 := GetProcOrNil&<procedure(s: Half; t: Half)>(z_TexCoord2hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2hNV(s: Half; t: Half) :=
    z_TexCoord2hNV_1(s, t);
    
    private z_TexCoord2hvNV_adr := GetProcAddress('glTexCoord2hvNV');
    private z_TexCoord2hvNV_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_TexCoord2hvNV_adr);
    private z_TexCoord2hvNV_2 := GetProcOrNil&<procedure(var v: Half)>(z_TexCoord2hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2hvNV(v: array of Half);
    type PHalf=^Half;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_TexCoord2hvNV_2(v[0]) else
        z_TexCoord2hvNV_2(PHalf(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2hvNV(var v: Half) :=
    z_TexCoord2hvNV_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2hvNV(v: IntPtr) :=
    z_TexCoord2hvNV_1(v);
    
    private z_TexCoord3hNV_adr := GetProcAddress('glTexCoord3hNV');
    private z_TexCoord3hNV_1 := GetProcOrNil&<procedure(s: Half; t: Half; r: Half)>(z_TexCoord3hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3hNV(s: Half; t: Half; r: Half) :=
    z_TexCoord3hNV_1(s, t, r);
    
    private z_TexCoord3hvNV_adr := GetProcAddress('glTexCoord3hvNV');
    private z_TexCoord3hvNV_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_TexCoord3hvNV_adr);
    private z_TexCoord3hvNV_2 := GetProcOrNil&<procedure(var v: Half)>(z_TexCoord3hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3hvNV(v: array of Half);
    type PHalf=^Half;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_TexCoord3hvNV_2(v[0]) else
        z_TexCoord3hvNV_2(PHalf(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3hvNV(var v: Half) :=
    z_TexCoord3hvNV_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3hvNV(v: IntPtr) :=
    z_TexCoord3hvNV_1(v);
    
    private z_TexCoord4hNV_adr := GetProcAddress('glTexCoord4hNV');
    private z_TexCoord4hNV_1 := GetProcOrNil&<procedure(s: Half; t: Half; r: Half; q: Half)>(z_TexCoord4hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4hNV(s: Half; t: Half; r: Half; q: Half) :=
    z_TexCoord4hNV_1(s, t, r, q);
    
    private z_TexCoord4hvNV_adr := GetProcAddress('glTexCoord4hvNV');
    private z_TexCoord4hvNV_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_TexCoord4hvNV_adr);
    private z_TexCoord4hvNV_2 := GetProcOrNil&<procedure(var v: Half)>(z_TexCoord4hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4hvNV(v: array of Half);
    type PHalf=^Half;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_TexCoord4hvNV_2(v[0]) else
        z_TexCoord4hvNV_2(PHalf(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4hvNV(var v: Half) :=
    z_TexCoord4hvNV_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4hvNV(v: IntPtr) :=
    z_TexCoord4hvNV_1(v);
    
    private z_MultiTexCoord1hNV_adr := GetProcAddress('glMultiTexCoord1hNV');
    private z_MultiTexCoord1hNV_1 := GetProcOrNil&<procedure(target: TextureUnit; s: Half)>(z_MultiTexCoord1hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1hNV(target: TextureUnit; s: Half) :=
    z_MultiTexCoord1hNV_1(target, s);
    
    private z_MultiTexCoord1hvNV_adr := GetProcAddress('glMultiTexCoord1hvNV');
    private z_MultiTexCoord1hvNV_1 := GetProcOrNil&<procedure(target: TextureUnit; v: IntPtr)>(z_MultiTexCoord1hvNV_adr);
    private z_MultiTexCoord1hvNV_2 := GetProcOrNil&<procedure(target: TextureUnit; var v: Half)>(z_MultiTexCoord1hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1hvNV(target: TextureUnit; v: array of Half);
    type PHalf=^Half;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MultiTexCoord1hvNV_2(target, v[0]) else
        z_MultiTexCoord1hvNV_2(target, PHalf(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1hvNV(target: TextureUnit; var v: Half) :=
    z_MultiTexCoord1hvNV_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1hvNV(target: TextureUnit; v: IntPtr) :=
    z_MultiTexCoord1hvNV_1(target, v);
    
    private z_MultiTexCoord2hNV_adr := GetProcAddress('glMultiTexCoord2hNV');
    private z_MultiTexCoord2hNV_1 := GetProcOrNil&<procedure(target: TextureUnit; s: Half; t: Half)>(z_MultiTexCoord2hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2hNV(target: TextureUnit; s: Half; t: Half) :=
    z_MultiTexCoord2hNV_1(target, s, t);
    
    private z_MultiTexCoord2hvNV_adr := GetProcAddress('glMultiTexCoord2hvNV');
    private z_MultiTexCoord2hvNV_1 := GetProcOrNil&<procedure(target: TextureUnit; v: IntPtr)>(z_MultiTexCoord2hvNV_adr);
    private z_MultiTexCoord2hvNV_2 := GetProcOrNil&<procedure(target: TextureUnit; var v: Half)>(z_MultiTexCoord2hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2hvNV(target: TextureUnit; v: array of Half);
    type PHalf=^Half;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MultiTexCoord2hvNV_2(target, v[0]) else
        z_MultiTexCoord2hvNV_2(target, PHalf(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2hvNV(target: TextureUnit; var v: Half) :=
    z_MultiTexCoord2hvNV_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2hvNV(target: TextureUnit; v: IntPtr) :=
    z_MultiTexCoord2hvNV_1(target, v);
    
    private z_MultiTexCoord3hNV_adr := GetProcAddress('glMultiTexCoord3hNV');
    private z_MultiTexCoord3hNV_1 := GetProcOrNil&<procedure(target: TextureUnit; s: Half; t: Half; r: Half)>(z_MultiTexCoord3hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3hNV(target: TextureUnit; s: Half; t: Half; r: Half) :=
    z_MultiTexCoord3hNV_1(target, s, t, r);
    
    private z_MultiTexCoord3hvNV_adr := GetProcAddress('glMultiTexCoord3hvNV');
    private z_MultiTexCoord3hvNV_1 := GetProcOrNil&<procedure(target: TextureUnit; v: IntPtr)>(z_MultiTexCoord3hvNV_adr);
    private z_MultiTexCoord3hvNV_2 := GetProcOrNil&<procedure(target: TextureUnit; var v: Half)>(z_MultiTexCoord3hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3hvNV(target: TextureUnit; v: array of Half);
    type PHalf=^Half;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MultiTexCoord3hvNV_2(target, v[0]) else
        z_MultiTexCoord3hvNV_2(target, PHalf(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3hvNV(target: TextureUnit; var v: Half) :=
    z_MultiTexCoord3hvNV_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3hvNV(target: TextureUnit; v: IntPtr) :=
    z_MultiTexCoord3hvNV_1(target, v);
    
    private z_MultiTexCoord4hNV_adr := GetProcAddress('glMultiTexCoord4hNV');
    private z_MultiTexCoord4hNV_1 := GetProcOrNil&<procedure(target: TextureUnit; s: Half; t: Half; r: Half; q: Half)>(z_MultiTexCoord4hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4hNV(target: TextureUnit; s: Half; t: Half; r: Half; q: Half) :=
    z_MultiTexCoord4hNV_1(target, s, t, r, q);
    
    private z_MultiTexCoord4hvNV_adr := GetProcAddress('glMultiTexCoord4hvNV');
    private z_MultiTexCoord4hvNV_1 := GetProcOrNil&<procedure(target: TextureUnit; v: IntPtr)>(z_MultiTexCoord4hvNV_adr);
    private z_MultiTexCoord4hvNV_2 := GetProcOrNil&<procedure(target: TextureUnit; var v: Half)>(z_MultiTexCoord4hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4hvNV(target: TextureUnit; v: array of Half);
    type PHalf=^Half;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MultiTexCoord4hvNV_2(target, v[0]) else
        z_MultiTexCoord4hvNV_2(target, PHalf(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4hvNV(target: TextureUnit; var v: Half) :=
    z_MultiTexCoord4hvNV_2(target, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4hvNV(target: TextureUnit; v: IntPtr) :=
    z_MultiTexCoord4hvNV_1(target, v);
    
    private z_FogCoordhNV_adr := GetProcAddress('glFogCoordhNV');
    private z_FogCoordhNV_1 := GetProcOrNil&<procedure(fog: Half)>(z_FogCoordhNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordhNV(fog: Half) :=
    z_FogCoordhNV_1(fog);
    
    private z_FogCoordhvNV_adr := GetProcAddress('glFogCoordhvNV');
    private z_FogCoordhvNV_1 := GetProcOrNil&<procedure(fog: IntPtr)>(z_FogCoordhvNV_adr);
    private z_FogCoordhvNV_2 := GetProcOrNil&<procedure(var fog: Half)>(z_FogCoordhvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordhvNV(fog: array of Half);
    type PHalf=^Half;
    begin
      if (fog<>nil) and (fog.Length<>0) then
        z_FogCoordhvNV_2(fog[0]) else
        z_FogCoordhvNV_2(PHalf(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordhvNV(var fog: Half) :=
    z_FogCoordhvNV_2(fog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordhvNV(fog: IntPtr) :=
    z_FogCoordhvNV_1(fog);
    
    private z_SecondaryColor3hNV_adr := GetProcAddress('glSecondaryColor3hNV');
    private z_SecondaryColor3hNV_1 := GetProcOrNil&<procedure(red: Half; green: Half; blue: Half)>(z_SecondaryColor3hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3hNV(red: Half; green: Half; blue: Half) :=
    z_SecondaryColor3hNV_1(red, green, blue);
    
    private z_SecondaryColor3hvNV_adr := GetProcAddress('glSecondaryColor3hvNV');
    private z_SecondaryColor3hvNV_1 := GetProcOrNil&<procedure(v: IntPtr)>(z_SecondaryColor3hvNV_adr);
    private z_SecondaryColor3hvNV_2 := GetProcOrNil&<procedure(var v: Half)>(z_SecondaryColor3hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3hvNV(v: array of Half);
    type PHalf=^Half;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_SecondaryColor3hvNV_2(v[0]) else
        z_SecondaryColor3hvNV_2(PHalf(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3hvNV(var v: Half) :=
    z_SecondaryColor3hvNV_2(v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3hvNV(v: IntPtr) :=
    z_SecondaryColor3hvNV_1(v);
    
    private z_VertexWeighthNV_adr := GetProcAddress('glVertexWeighthNV');
    private z_VertexWeighthNV_1 := GetProcOrNil&<procedure(weight: Half)>(z_VertexWeighthNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexWeighthNV(weight: Half) :=
    z_VertexWeighthNV_1(weight);
    
    private z_VertexWeighthvNV_adr := GetProcAddress('glVertexWeighthvNV');
    private z_VertexWeighthvNV_1 := GetProcOrNil&<procedure(weight: IntPtr)>(z_VertexWeighthvNV_adr);
    private z_VertexWeighthvNV_2 := GetProcOrNil&<procedure(var weight: Half)>(z_VertexWeighthvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexWeighthvNV(weight: array of Half);
    type PHalf=^Half;
    begin
      if (weight<>nil) and (weight.Length<>0) then
        z_VertexWeighthvNV_2(weight[0]) else
        z_VertexWeighthvNV_2(PHalf(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexWeighthvNV(var weight: Half) :=
    z_VertexWeighthvNV_2(weight);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexWeighthvNV(weight: IntPtr) :=
    z_VertexWeighthvNV_1(weight);
    
    private z_VertexAttrib1hNV_adr := GetProcAddress('glVertexAttrib1hNV');
    private z_VertexAttrib1hNV_1 := GetProcOrNil&<procedure(index: UInt32; x: Half)>(z_VertexAttrib1hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1hNV(index: UInt32; x: Half) :=
    z_VertexAttrib1hNV_1(index, x);
    
    private z_VertexAttrib1hvNV_adr := GetProcAddress('glVertexAttrib1hvNV');
    private z_VertexAttrib1hvNV_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib1hvNV_adr);
    private z_VertexAttrib1hvNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: Half)>(z_VertexAttrib1hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1hvNV(index: UInt32; v: array of Half);
    type PHalf=^Half;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib1hvNV_2(index, v[0]) else
        z_VertexAttrib1hvNV_2(index, PHalf(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1hvNV(index: UInt32; var v: Half) :=
    z_VertexAttrib1hvNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1hvNV(index: UInt32; v: IntPtr) :=
    z_VertexAttrib1hvNV_1(index, v);
    
    private z_VertexAttrib2hNV_adr := GetProcAddress('glVertexAttrib2hNV');
    private z_VertexAttrib2hNV_1 := GetProcOrNil&<procedure(index: UInt32; x: Half; y: Half)>(z_VertexAttrib2hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2hNV(index: UInt32; x: Half; y: Half) :=
    z_VertexAttrib2hNV_1(index, x, y);
    
    private z_VertexAttrib2hvNV_adr := GetProcAddress('glVertexAttrib2hvNV');
    private z_VertexAttrib2hvNV_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib2hvNV_adr);
    private z_VertexAttrib2hvNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: Half)>(z_VertexAttrib2hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2hvNV(index: UInt32; v: array of Half);
    type PHalf=^Half;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib2hvNV_2(index, v[0]) else
        z_VertexAttrib2hvNV_2(index, PHalf(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2hvNV(index: UInt32; var v: Half) :=
    z_VertexAttrib2hvNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2hvNV(index: UInt32; v: IntPtr) :=
    z_VertexAttrib2hvNV_1(index, v);
    
    private z_VertexAttrib3hNV_adr := GetProcAddress('glVertexAttrib3hNV');
    private z_VertexAttrib3hNV_1 := GetProcOrNil&<procedure(index: UInt32; x: Half; y: Half; z: Half)>(z_VertexAttrib3hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3hNV(index: UInt32; x: Half; y: Half; z: Half) :=
    z_VertexAttrib3hNV_1(index, x, y, z);
    
    private z_VertexAttrib3hvNV_adr := GetProcAddress('glVertexAttrib3hvNV');
    private z_VertexAttrib3hvNV_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib3hvNV_adr);
    private z_VertexAttrib3hvNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: Half)>(z_VertexAttrib3hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3hvNV(index: UInt32; v: array of Half);
    type PHalf=^Half;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib3hvNV_2(index, v[0]) else
        z_VertexAttrib3hvNV_2(index, PHalf(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3hvNV(index: UInt32; var v: Half) :=
    z_VertexAttrib3hvNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3hvNV(index: UInt32; v: IntPtr) :=
    z_VertexAttrib3hvNV_1(index, v);
    
    private z_VertexAttrib4hNV_adr := GetProcAddress('glVertexAttrib4hNV');
    private z_VertexAttrib4hNV_1 := GetProcOrNil&<procedure(index: UInt32; x: Half; y: Half; z: Half; w: Half)>(z_VertexAttrib4hNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4hNV(index: UInt32; x: Half; y: Half; z: Half; w: Half) :=
    z_VertexAttrib4hNV_1(index, x, y, z, w);
    
    private z_VertexAttrib4hvNV_adr := GetProcAddress('glVertexAttrib4hvNV');
    private z_VertexAttrib4hvNV_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4hvNV_adr);
    private z_VertexAttrib4hvNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: Half)>(z_VertexAttrib4hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4hvNV(index: UInt32; v: array of Half);
    type PHalf=^Half;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4hvNV_2(index, v[0]) else
        z_VertexAttrib4hvNV_2(index, PHalf(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4hvNV(index: UInt32; var v: Half) :=
    z_VertexAttrib4hvNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4hvNV(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4hvNV_1(index, v);
    
    private z_VertexAttribs1hvNV_adr := GetProcAddress('glVertexAttribs1hvNV');
    private z_VertexAttribs1hvNV_1 := GetProcOrNil&<procedure(index: UInt32; n: Int32; v: IntPtr)>(z_VertexAttribs1hvNV_adr);
    private z_VertexAttribs1hvNV_2 := GetProcOrNil&<procedure(index: UInt32; n: Int32; var v: Half)>(z_VertexAttribs1hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1hvNV(index: UInt32; n: Int32; v: array of Half);
    type PHalf=^Half;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribs1hvNV_2(index, n, v[0]) else
        z_VertexAttribs1hvNV_2(index, n, PHalf(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1hvNV(index: UInt32; n: Int32; var v: Half) :=
    z_VertexAttribs1hvNV_2(index, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1hvNV(index: UInt32; n: Int32; v: IntPtr) :=
    z_VertexAttribs1hvNV_1(index, n, v);
    
    private z_VertexAttribs2hvNV_adr := GetProcAddress('glVertexAttribs2hvNV');
    private z_VertexAttribs2hvNV_1 := GetProcOrNil&<procedure(index: UInt32; n: Int32; v: IntPtr)>(z_VertexAttribs2hvNV_adr);
    private z_VertexAttribs2hvNV_2 := GetProcOrNil&<procedure(index: UInt32; n: Int32; var v: Half)>(z_VertexAttribs2hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2hvNV(index: UInt32; n: Int32; v: array of Half);
    type PHalf=^Half;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribs2hvNV_2(index, n, v[0]) else
        z_VertexAttribs2hvNV_2(index, n, PHalf(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2hvNV(index: UInt32; n: Int32; var v: Half) :=
    z_VertexAttribs2hvNV_2(index, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2hvNV(index: UInt32; n: Int32; v: IntPtr) :=
    z_VertexAttribs2hvNV_1(index, n, v);
    
    private z_VertexAttribs3hvNV_adr := GetProcAddress('glVertexAttribs3hvNV');
    private z_VertexAttribs3hvNV_1 := GetProcOrNil&<procedure(index: UInt32; n: Int32; v: IntPtr)>(z_VertexAttribs3hvNV_adr);
    private z_VertexAttribs3hvNV_2 := GetProcOrNil&<procedure(index: UInt32; n: Int32; var v: Half)>(z_VertexAttribs3hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3hvNV(index: UInt32; n: Int32; v: array of Half);
    type PHalf=^Half;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribs3hvNV_2(index, n, v[0]) else
        z_VertexAttribs3hvNV_2(index, n, PHalf(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3hvNV(index: UInt32; n: Int32; var v: Half) :=
    z_VertexAttribs3hvNV_2(index, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3hvNV(index: UInt32; n: Int32; v: IntPtr) :=
    z_VertexAttribs3hvNV_1(index, n, v);
    
    private z_VertexAttribs4hvNV_adr := GetProcAddress('glVertexAttribs4hvNV');
    private z_VertexAttribs4hvNV_1 := GetProcOrNil&<procedure(index: UInt32; n: Int32; v: IntPtr)>(z_VertexAttribs4hvNV_adr);
    private z_VertexAttribs4hvNV_2 := GetProcOrNil&<procedure(index: UInt32; n: Int32; var v: Half)>(z_VertexAttribs4hvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4hvNV(index: UInt32; n: Int32; v: array of Half);
    type PHalf=^Half;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribs4hvNV_2(index, n, v[0]) else
        z_VertexAttribs4hvNV_2(index, n, PHalf(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4hvNV(index: UInt32; n: Int32; var v: Half) :=
    z_VertexAttribs4hvNV_2(index, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4hvNV(index: UInt32; n: Int32; v: IntPtr) :=
    z_VertexAttribs4hvNV_1(index, n, v);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glInternalformatSampleQueryNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_internalformat_sample_query';
    
    private z_GetInternalformatSampleivNV_adr := GetProcAddress('glGetInternalformatSampleivNV');
    private z_GetInternalformatSampleivNV_1 := GetProcOrNil&<procedure(target: TextureTarget; _internalformat: InternalFormat; samples: Int32; pname: InternalFormatPName; count: Int32; &params: IntPtr)>(z_GetInternalformatSampleivNV_adr);
    private z_GetInternalformatSampleivNV_2 := GetProcOrNil&<procedure(target: TextureTarget; _internalformat: InternalFormat; samples: Int32; pname: InternalFormatPName; count: Int32; var &params: Int32)>(z_GetInternalformatSampleivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInternalformatSampleivNV(target: TextureTarget; _internalformat: InternalFormat; samples: Int32; pname: InternalFormatPName; count: Int32; var &params: Int32) :=
    z_GetInternalformatSampleivNV_2(target, _internalformat, samples, pname, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInternalformatSampleivNV(target: TextureTarget; _internalformat: InternalFormat; samples: Int32; pname: InternalFormatPName; count: Int32; &params: IntPtr) :=
    z_GetInternalformatSampleivNV_1(target, _internalformat, samples, pname, count, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glGpuMulticastNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_gpu_multicast';
    
    private z_RenderGpuMaskNV_adr := GetProcAddress('glRenderGpuMaskNV');
    private z_RenderGpuMaskNV_1 := GetProcOrNil&<procedure(mask: DummyFlags)>(z_RenderGpuMaskNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RenderGpuMaskNV(mask: DummyFlags) :=
    z_RenderGpuMaskNV_1(mask);
    
    private z_MulticastBufferSubDataNV_adr := GetProcAddress('glMulticastBufferSubDataNV');
    private z_MulticastBufferSubDataNV_1 := GetProcOrNil&<procedure(gpuMask: DummyFlags; buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: IntPtr)>(z_MulticastBufferSubDataNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastBufferSubDataNV(gpuMask: DummyFlags; buffer: gl_buffer; offset: IntPtr; size: UIntPtr; data: IntPtr) :=
    z_MulticastBufferSubDataNV_1(gpuMask, buffer, offset, size, data);
    
    private z_MulticastCopyBufferSubDataNV_adr := GetProcAddress('glMulticastCopyBufferSubDataNV');
    private z_MulticastCopyBufferSubDataNV_1 := GetProcOrNil&<procedure(readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr)>(z_MulticastCopyBufferSubDataNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastCopyBufferSubDataNV(readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr) :=
    z_MulticastCopyBufferSubDataNV_1(readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size);
    
    private z_MulticastCopyImageSubDataNV_adr := GetProcAddress('glMulticastCopyImageSubDataNV');
    private z_MulticastCopyImageSubDataNV_1 := GetProcOrNil&<procedure(srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32)>(z_MulticastCopyImageSubDataNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastCopyImageSubDataNV(srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32) :=
    z_MulticastCopyImageSubDataNV_1(srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
    
    private z_MulticastBlitFramebufferNV_adr := GetProcAddress('glMulticastBlitFramebufferNV');
    private z_MulticastBlitFramebufferNV_1 := GetProcOrNil&<procedure(srcGpu: UInt32; dstGpu: UInt32; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: ClearBufferMask; filter: DummyEnum)>(z_MulticastBlitFramebufferNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastBlitFramebufferNV(srcGpu: UInt32; dstGpu: UInt32; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: ClearBufferMask; filter: DummyEnum) :=
    z_MulticastBlitFramebufferNV_1(srcGpu, dstGpu, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    
    private z_MulticastFramebufferSampleLocationsfvNV_adr := GetProcAddress('glMulticastFramebufferSampleLocationsfvNV');
    private z_MulticastFramebufferSampleLocationsfvNV_1 := GetProcOrNil&<procedure(gpu: UInt32; framebuffer: gl_framebuffer; start: UInt32; count: Int32; v: IntPtr)>(z_MulticastFramebufferSampleLocationsfvNV_adr);
    private z_MulticastFramebufferSampleLocationsfvNV_2 := GetProcOrNil&<procedure(gpu: UInt32; framebuffer: gl_framebuffer; start: UInt32; count: Int32; var v: single)>(z_MulticastFramebufferSampleLocationsfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastFramebufferSampleLocationsfvNV(gpu: UInt32; framebuffer: gl_framebuffer; start: UInt32; count: Int32; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MulticastFramebufferSampleLocationsfvNV_2(gpu, framebuffer, start, count, v[0]) else
        z_MulticastFramebufferSampleLocationsfvNV_2(gpu, framebuffer, start, count, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastFramebufferSampleLocationsfvNV(gpu: UInt32; framebuffer: gl_framebuffer; start: UInt32; count: Int32; var v: single) :=
    z_MulticastFramebufferSampleLocationsfvNV_2(gpu, framebuffer, start, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastFramebufferSampleLocationsfvNV(gpu: UInt32; framebuffer: gl_framebuffer; start: UInt32; count: Int32; v: IntPtr) :=
    z_MulticastFramebufferSampleLocationsfvNV_1(gpu, framebuffer, start, count, v);
    
    private z_MulticastBarrierNV_adr := GetProcAddress('glMulticastBarrierNV');
    private z_MulticastBarrierNV_1 := GetProcOrNil&<procedure>(z_MulticastBarrierNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastBarrierNV :=
    z_MulticastBarrierNV_1();
    
    private z_MulticastWaitSyncNV_adr := GetProcAddress('glMulticastWaitSyncNV');
    private z_MulticastWaitSyncNV_1 := GetProcOrNil&<procedure(signalGpu: UInt32; waitGpuMask: DummyFlags)>(z_MulticastWaitSyncNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastWaitSyncNV(signalGpu: UInt32; waitGpuMask: DummyFlags) :=
    z_MulticastWaitSyncNV_1(signalGpu, waitGpuMask);
    
    private z_MulticastGetQueryObjectivNV_adr := GetProcAddress('glMulticastGetQueryObjectivNV');
    private z_MulticastGetQueryObjectivNV_1 := GetProcOrNil&<procedure(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: IntPtr)>(z_MulticastGetQueryObjectivNV_adr);
    private z_MulticastGetQueryObjectivNV_2 := GetProcOrNil&<procedure(gpu: UInt32; id: UInt32; pname: DummyEnum; var &params: Int32)>(z_MulticastGetQueryObjectivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjectivNV(gpu: UInt32; id: UInt32; pname: DummyEnum; var &params: Int32) :=
    z_MulticastGetQueryObjectivNV_2(gpu, id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjectivNV(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: IntPtr) :=
    z_MulticastGetQueryObjectivNV_1(gpu, id, pname, &params);
    
    private z_MulticastGetQueryObjectuivNV_adr := GetProcAddress('glMulticastGetQueryObjectuivNV');
    private z_MulticastGetQueryObjectuivNV_1 := GetProcOrNil&<procedure(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: IntPtr)>(z_MulticastGetQueryObjectuivNV_adr);
    private z_MulticastGetQueryObjectuivNV_2 := GetProcOrNil&<procedure(gpu: UInt32; id: UInt32; pname: DummyEnum; var &params: UInt32)>(z_MulticastGetQueryObjectuivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjectuivNV(gpu: UInt32; id: UInt32; pname: DummyEnum; var &params: UInt32) :=
    z_MulticastGetQueryObjectuivNV_2(gpu, id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjectuivNV(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: IntPtr) :=
    z_MulticastGetQueryObjectuivNV_1(gpu, id, pname, &params);
    
    private z_MulticastGetQueryObjecti64vNV_adr := GetProcAddress('glMulticastGetQueryObjecti64vNV');
    private z_MulticastGetQueryObjecti64vNV_1 := GetProcOrNil&<procedure(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: IntPtr)>(z_MulticastGetQueryObjecti64vNV_adr);
    private z_MulticastGetQueryObjecti64vNV_2 := GetProcOrNil&<procedure(gpu: UInt32; id: UInt32; pname: DummyEnum; var &params: Int64)>(z_MulticastGetQueryObjecti64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjecti64vNV(gpu: UInt32; id: UInt32; pname: DummyEnum; var &params: Int64) :=
    z_MulticastGetQueryObjecti64vNV_2(gpu, id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjecti64vNV(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: IntPtr) :=
    z_MulticastGetQueryObjecti64vNV_1(gpu, id, pname, &params);
    
    private z_MulticastGetQueryObjectui64vNV_adr := GetProcAddress('glMulticastGetQueryObjectui64vNV');
    private z_MulticastGetQueryObjectui64vNV_1 := GetProcOrNil&<procedure(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: IntPtr)>(z_MulticastGetQueryObjectui64vNV_adr);
    private z_MulticastGetQueryObjectui64vNV_2 := GetProcOrNil&<procedure(gpu: UInt32; id: UInt32; pname: DummyEnum; var &params: UInt64)>(z_MulticastGetQueryObjectui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjectui64vNV(gpu: UInt32; id: UInt32; pname: DummyEnum; var &params: UInt64) :=
    z_MulticastGetQueryObjectui64vNV_2(gpu, id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjectui64vNV(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: IntPtr) :=
    z_MulticastGetQueryObjectui64vNV_1(gpu, id, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glGpuMulticast2NVX = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nvx_gpu_multicast2';
    
    private z_UploadGpuMaskNVX_adr := GetProcAddress('glUploadGpuMaskNVX');
    private z_UploadGpuMaskNVX_1 := GetProcOrNil&<procedure(mask: DummyFlags)>(z_UploadGpuMaskNVX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UploadGpuMaskNVX(mask: DummyFlags) :=
    z_UploadGpuMaskNVX_1(mask);
    
    private z_MulticastViewportArrayvNVX_adr := GetProcAddress('glMulticastViewportArrayvNVX');
    private z_MulticastViewportArrayvNVX_1 := GetProcOrNil&<procedure(gpu: UInt32; first: UInt32; count: Int32; v: IntPtr)>(z_MulticastViewportArrayvNVX_adr);
    private z_MulticastViewportArrayvNVX_2 := GetProcOrNil&<procedure(gpu: UInt32; first: UInt32; count: Int32; var v: single)>(z_MulticastViewportArrayvNVX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastViewportArrayvNVX(gpu: UInt32; first: UInt32; count: Int32; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MulticastViewportArrayvNVX_2(gpu, first, count, v[0]) else
        z_MulticastViewportArrayvNVX_2(gpu, first, count, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastViewportArrayvNVX(gpu: UInt32; first: UInt32; count: Int32; var v: single) :=
    z_MulticastViewportArrayvNVX_2(gpu, first, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastViewportArrayvNVX(gpu: UInt32; first: UInt32; count: Int32; v: IntPtr) :=
    z_MulticastViewportArrayvNVX_1(gpu, first, count, v);
    
    private z_MulticastViewportPositionWScaleNVX_adr := GetProcAddress('glMulticastViewportPositionWScaleNVX');
    private z_MulticastViewportPositionWScaleNVX_1 := GetProcOrNil&<procedure(gpu: UInt32; index: UInt32; xcoeff: single; ycoeff: single)>(z_MulticastViewportPositionWScaleNVX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastViewportPositionWScaleNVX(gpu: UInt32; index: UInt32; xcoeff: single; ycoeff: single) :=
    z_MulticastViewportPositionWScaleNVX_1(gpu, index, xcoeff, ycoeff);
    
    private z_MulticastScissorArrayvNVX_adr := GetProcAddress('glMulticastScissorArrayvNVX');
    private z_MulticastScissorArrayvNVX_1 := GetProcOrNil&<procedure(gpu: UInt32; first: UInt32; count: Int32; v: IntPtr)>(z_MulticastScissorArrayvNVX_adr);
    private z_MulticastScissorArrayvNVX_2 := GetProcOrNil&<procedure(gpu: UInt32; first: UInt32; count: Int32; var v: Int32)>(z_MulticastScissorArrayvNVX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastScissorArrayvNVX(gpu: UInt32; first: UInt32; count: Int32; v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_MulticastScissorArrayvNVX_2(gpu, first, count, v[0]) else
        z_MulticastScissorArrayvNVX_2(gpu, first, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastScissorArrayvNVX(gpu: UInt32; first: UInt32; count: Int32; var v: Int32) :=
    z_MulticastScissorArrayvNVX_2(gpu, first, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastScissorArrayvNVX(gpu: UInt32; first: UInt32; count: Int32; v: IntPtr) :=
    z_MulticastScissorArrayvNVX_1(gpu, first, count, v);
    
    private z_AsyncCopyBufferSubDataNVX_adr := GetProcAddress('glAsyncCopyBufferSubDataNVX');
    private z_AsyncCopyBufferSubDataNVX_1 := GetProcOrNil&<function(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; fenceValueArray: IntPtr; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; signalValueArray: IntPtr): UInt32>(z_AsyncCopyBufferSubDataNVX_adr);
    private z_AsyncCopyBufferSubDataNVX_2 := GetProcOrNil&<function(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; fenceValueArray: IntPtr; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; var signalValueArray: UInt64): UInt32>(z_AsyncCopyBufferSubDataNVX_adr);
    private z_AsyncCopyBufferSubDataNVX_3 := GetProcOrNil&<function(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; fenceValueArray: IntPtr; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: IntPtr): UInt32>(z_AsyncCopyBufferSubDataNVX_adr);
    private z_AsyncCopyBufferSubDataNVX_4 := GetProcOrNil&<function(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; fenceValueArray: IntPtr; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32>(z_AsyncCopyBufferSubDataNVX_adr);
    private z_AsyncCopyBufferSubDataNVX_5 := GetProcOrNil&<function(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; signalValueArray: IntPtr): UInt32>(z_AsyncCopyBufferSubDataNVX_adr);
    private z_AsyncCopyBufferSubDataNVX_6 := GetProcOrNil&<function(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; var signalValueArray: UInt64): UInt32>(z_AsyncCopyBufferSubDataNVX_adr);
    private z_AsyncCopyBufferSubDataNVX_7 := GetProcOrNil&<function(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: IntPtr): UInt32>(z_AsyncCopyBufferSubDataNVX_adr);
    private z_AsyncCopyBufferSubDataNVX_8 := GetProcOrNil&<function(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32>(z_AsyncCopyBufferSubDataNVX_adr);
    private z_AsyncCopyBufferSubDataNVX_9 := GetProcOrNil&<function(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: IntPtr; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; signalValueArray: IntPtr): UInt32>(z_AsyncCopyBufferSubDataNVX_adr);
    private z_AsyncCopyBufferSubDataNVX_10 := GetProcOrNil&<function(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: IntPtr; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; var signalValueArray: UInt64): UInt32>(z_AsyncCopyBufferSubDataNVX_adr);
    private z_AsyncCopyBufferSubDataNVX_11 := GetProcOrNil&<function(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: IntPtr; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: IntPtr): UInt32>(z_AsyncCopyBufferSubDataNVX_adr);
    private z_AsyncCopyBufferSubDataNVX_12 := GetProcOrNil&<function(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: IntPtr; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32>(z_AsyncCopyBufferSubDataNVX_adr);
    private z_AsyncCopyBufferSubDataNVX_13 := GetProcOrNil&<function(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; signalValueArray: IntPtr): UInt32>(z_AsyncCopyBufferSubDataNVX_adr);
    private z_AsyncCopyBufferSubDataNVX_14 := GetProcOrNil&<function(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; var signalValueArray: UInt64): UInt32>(z_AsyncCopyBufferSubDataNVX_adr);
    private z_AsyncCopyBufferSubDataNVX_15 := GetProcOrNil&<function(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: IntPtr): UInt32>(z_AsyncCopyBufferSubDataNVX_adr);
    private z_AsyncCopyBufferSubDataNVX_16 := GetProcOrNil&<function(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32>(z_AsyncCopyBufferSubDataNVX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32;
    type PUInt32=^UInt32;
    type PUInt64=^UInt64;
    begin
      Result := if (signalValueArray<>nil) and (signalValueArray.Length<>0) then
        if (signalSemaphoreArray<>nil) and (signalSemaphoreArray.Length<>0) then
          if (fenceValueArray<>nil) and (fenceValueArray.Length<>0) then
            if (waitSemaphoreArray<>nil) and (waitSemaphoreArray.Length<>0) then
              z_AsyncCopyBufferSubDataNVX_16(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]) else
              z_AsyncCopyBufferSubDataNVX_16(waitSemaphoreCount, PUInt32(nil)^, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]) else
            if (waitSemaphoreArray<>nil) and (waitSemaphoreArray.Length<>0) then
              z_AsyncCopyBufferSubDataNVX_16(waitSemaphoreCount, waitSemaphoreArray[0], PUInt64(nil)^, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]) else
              z_AsyncCopyBufferSubDataNVX_16(waitSemaphoreCount, PUInt32(nil)^, PUInt64(nil)^, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]) else
          if (fenceValueArray<>nil) and (fenceValueArray.Length<>0) then
            if (waitSemaphoreArray<>nil) and (waitSemaphoreArray.Length<>0) then
              z_AsyncCopyBufferSubDataNVX_16(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, PUInt32(nil)^, signalValueArray[0]) else
              z_AsyncCopyBufferSubDataNVX_16(waitSemaphoreCount, PUInt32(nil)^, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, PUInt32(nil)^, signalValueArray[0]) else
            if (waitSemaphoreArray<>nil) and (waitSemaphoreArray.Length<>0) then
              z_AsyncCopyBufferSubDataNVX_16(waitSemaphoreCount, waitSemaphoreArray[0], PUInt64(nil)^, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, PUInt32(nil)^, signalValueArray[0]) else
              z_AsyncCopyBufferSubDataNVX_16(waitSemaphoreCount, PUInt32(nil)^, PUInt64(nil)^, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, PUInt32(nil)^, signalValueArray[0]) else
        if (signalSemaphoreArray<>nil) and (signalSemaphoreArray.Length<>0) then
          if (fenceValueArray<>nil) and (fenceValueArray.Length<>0) then
            if (waitSemaphoreArray<>nil) and (waitSemaphoreArray.Length<>0) then
              z_AsyncCopyBufferSubDataNVX_16(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], PUInt64(nil)^) else
              z_AsyncCopyBufferSubDataNVX_16(waitSemaphoreCount, PUInt32(nil)^, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], PUInt64(nil)^) else
            if (waitSemaphoreArray<>nil) and (waitSemaphoreArray.Length<>0) then
              z_AsyncCopyBufferSubDataNVX_16(waitSemaphoreCount, waitSemaphoreArray[0], PUInt64(nil)^, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], PUInt64(nil)^) else
              z_AsyncCopyBufferSubDataNVX_16(waitSemaphoreCount, PUInt32(nil)^, PUInt64(nil)^, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], PUInt64(nil)^) else
          if (fenceValueArray<>nil) and (fenceValueArray.Length<>0) then
            if (waitSemaphoreArray<>nil) and (waitSemaphoreArray.Length<>0) then
              z_AsyncCopyBufferSubDataNVX_16(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, PUInt32(nil)^, PUInt64(nil)^) else
              z_AsyncCopyBufferSubDataNVX_16(waitSemaphoreCount, PUInt32(nil)^, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, PUInt32(nil)^, PUInt64(nil)^) else
            if (waitSemaphoreArray<>nil) and (waitSemaphoreArray.Length<>0) then
              z_AsyncCopyBufferSubDataNVX_16(waitSemaphoreCount, waitSemaphoreArray[0], PUInt64(nil)^, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, PUInt32(nil)^, PUInt64(nil)^) else
              z_AsyncCopyBufferSubDataNVX_16(waitSemaphoreCount, PUInt32(nil)^, PUInt64(nil)^, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, PUInt32(nil)^, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 :=
    z_AsyncCopyBufferSubDataNVX_16(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: IntPtr): UInt32 :=
    z_AsyncCopyBufferSubDataNVX_15(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; var signalValueArray: UInt64): UInt32 :=
    z_AsyncCopyBufferSubDataNVX_14(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; signalValueArray: IntPtr): UInt32 :=
    z_AsyncCopyBufferSubDataNVX_13(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: IntPtr; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 :=
    z_AsyncCopyBufferSubDataNVX_12(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: IntPtr; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: IntPtr): UInt32 :=
    z_AsyncCopyBufferSubDataNVX_11(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: IntPtr; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; var signalValueArray: UInt64): UInt32 :=
    z_AsyncCopyBufferSubDataNVX_10(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: IntPtr; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; signalValueArray: IntPtr): UInt32 :=
    z_AsyncCopyBufferSubDataNVX_9(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 :=
    z_AsyncCopyBufferSubDataNVX_8(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: IntPtr): UInt32 :=
    z_AsyncCopyBufferSubDataNVX_7(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; var signalValueArray: UInt64): UInt32 :=
    z_AsyncCopyBufferSubDataNVX_6(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; signalValueArray: IntPtr): UInt32 :=
    z_AsyncCopyBufferSubDataNVX_5(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; fenceValueArray: IntPtr; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 :=
    z_AsyncCopyBufferSubDataNVX_4(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; fenceValueArray: IntPtr; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: IntPtr): UInt32 :=
    z_AsyncCopyBufferSubDataNVX_3(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; fenceValueArray: IntPtr; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; var signalValueArray: UInt64): UInt32 :=
    z_AsyncCopyBufferSubDataNVX_2(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; fenceValueArray: IntPtr; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: gl_buffer; writeBuffer: gl_buffer; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; signalValueArray: IntPtr): UInt32 :=
    z_AsyncCopyBufferSubDataNVX_1(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    
    private z_AsyncCopyImageSubDataNVX_adr := GetProcAddress('glAsyncCopyImageSubDataNVX');
    private z_AsyncCopyImageSubDataNVX_1 := GetProcOrNil&<function(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; waitValueArray: IntPtr; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; signalValueArray: IntPtr): UInt32>(z_AsyncCopyImageSubDataNVX_adr);
    private z_AsyncCopyImageSubDataNVX_2 := GetProcOrNil&<function(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; waitValueArray: IntPtr; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; var signalValueArray: UInt64): UInt32>(z_AsyncCopyImageSubDataNVX_adr);
    private z_AsyncCopyImageSubDataNVX_3 := GetProcOrNil&<function(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; waitValueArray: IntPtr; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: IntPtr): UInt32>(z_AsyncCopyImageSubDataNVX_adr);
    private z_AsyncCopyImageSubDataNVX_4 := GetProcOrNil&<function(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; waitValueArray: IntPtr; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32>(z_AsyncCopyImageSubDataNVX_adr);
    private z_AsyncCopyImageSubDataNVX_5 := GetProcOrNil&<function(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; signalValueArray: IntPtr): UInt32>(z_AsyncCopyImageSubDataNVX_adr);
    private z_AsyncCopyImageSubDataNVX_6 := GetProcOrNil&<function(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; var signalValueArray: UInt64): UInt32>(z_AsyncCopyImageSubDataNVX_adr);
    private z_AsyncCopyImageSubDataNVX_7 := GetProcOrNil&<function(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: IntPtr): UInt32>(z_AsyncCopyImageSubDataNVX_adr);
    private z_AsyncCopyImageSubDataNVX_8 := GetProcOrNil&<function(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32>(z_AsyncCopyImageSubDataNVX_adr);
    private z_AsyncCopyImageSubDataNVX_9 := GetProcOrNil&<function(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: IntPtr; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; signalValueArray: IntPtr): UInt32>(z_AsyncCopyImageSubDataNVX_adr);
    private z_AsyncCopyImageSubDataNVX_10 := GetProcOrNil&<function(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: IntPtr; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; var signalValueArray: UInt64): UInt32>(z_AsyncCopyImageSubDataNVX_adr);
    private z_AsyncCopyImageSubDataNVX_11 := GetProcOrNil&<function(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: IntPtr; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: IntPtr): UInt32>(z_AsyncCopyImageSubDataNVX_adr);
    private z_AsyncCopyImageSubDataNVX_12 := GetProcOrNil&<function(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: IntPtr; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32>(z_AsyncCopyImageSubDataNVX_adr);
    private z_AsyncCopyImageSubDataNVX_13 := GetProcOrNil&<function(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; signalValueArray: IntPtr): UInt32>(z_AsyncCopyImageSubDataNVX_adr);
    private z_AsyncCopyImageSubDataNVX_14 := GetProcOrNil&<function(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; var signalValueArray: UInt64): UInt32>(z_AsyncCopyImageSubDataNVX_adr);
    private z_AsyncCopyImageSubDataNVX_15 := GetProcOrNil&<function(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: IntPtr): UInt32>(z_AsyncCopyImageSubDataNVX_adr);
    private z_AsyncCopyImageSubDataNVX_16 := GetProcOrNil&<function(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32>(z_AsyncCopyImageSubDataNVX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32;
    type PUInt32=^UInt32;
    type PUInt64=^UInt64;
    begin
      Result := if (signalValueArray<>nil) and (signalValueArray.Length<>0) then
        if (signalSemaphoreArray<>nil) and (signalSemaphoreArray.Length<>0) then
          if (waitValueArray<>nil) and (waitValueArray.Length<>0) then
            if (waitSemaphoreArray<>nil) and (waitSemaphoreArray.Length<>0) then
              z_AsyncCopyImageSubDataNVX_16(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]) else
              z_AsyncCopyImageSubDataNVX_16(waitSemaphoreCount, PUInt32(nil)^, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]) else
            if (waitSemaphoreArray<>nil) and (waitSemaphoreArray.Length<>0) then
              z_AsyncCopyImageSubDataNVX_16(waitSemaphoreCount, waitSemaphoreArray[0], PUInt64(nil)^, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]) else
              z_AsyncCopyImageSubDataNVX_16(waitSemaphoreCount, PUInt32(nil)^, PUInt64(nil)^, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]) else
          if (waitValueArray<>nil) and (waitValueArray.Length<>0) then
            if (waitSemaphoreArray<>nil) and (waitSemaphoreArray.Length<>0) then
              z_AsyncCopyImageSubDataNVX_16(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, PUInt32(nil)^, signalValueArray[0]) else
              z_AsyncCopyImageSubDataNVX_16(waitSemaphoreCount, PUInt32(nil)^, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, PUInt32(nil)^, signalValueArray[0]) else
            if (waitSemaphoreArray<>nil) and (waitSemaphoreArray.Length<>0) then
              z_AsyncCopyImageSubDataNVX_16(waitSemaphoreCount, waitSemaphoreArray[0], PUInt64(nil)^, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, PUInt32(nil)^, signalValueArray[0]) else
              z_AsyncCopyImageSubDataNVX_16(waitSemaphoreCount, PUInt32(nil)^, PUInt64(nil)^, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, PUInt32(nil)^, signalValueArray[0]) else
        if (signalSemaphoreArray<>nil) and (signalSemaphoreArray.Length<>0) then
          if (waitValueArray<>nil) and (waitValueArray.Length<>0) then
            if (waitSemaphoreArray<>nil) and (waitSemaphoreArray.Length<>0) then
              z_AsyncCopyImageSubDataNVX_16(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], PUInt64(nil)^) else
              z_AsyncCopyImageSubDataNVX_16(waitSemaphoreCount, PUInt32(nil)^, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], PUInt64(nil)^) else
            if (waitSemaphoreArray<>nil) and (waitSemaphoreArray.Length<>0) then
              z_AsyncCopyImageSubDataNVX_16(waitSemaphoreCount, waitSemaphoreArray[0], PUInt64(nil)^, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], PUInt64(nil)^) else
              z_AsyncCopyImageSubDataNVX_16(waitSemaphoreCount, PUInt32(nil)^, PUInt64(nil)^, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], PUInt64(nil)^) else
          if (waitValueArray<>nil) and (waitValueArray.Length<>0) then
            if (waitSemaphoreArray<>nil) and (waitSemaphoreArray.Length<>0) then
              z_AsyncCopyImageSubDataNVX_16(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, PUInt32(nil)^, PUInt64(nil)^) else
              z_AsyncCopyImageSubDataNVX_16(waitSemaphoreCount, PUInt32(nil)^, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, PUInt32(nil)^, PUInt64(nil)^) else
            if (waitSemaphoreArray<>nil) and (waitSemaphoreArray.Length<>0) then
              z_AsyncCopyImageSubDataNVX_16(waitSemaphoreCount, waitSemaphoreArray[0], PUInt64(nil)^, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, PUInt32(nil)^, PUInt64(nil)^) else
              z_AsyncCopyImageSubDataNVX_16(waitSemaphoreCount, PUInt32(nil)^, PUInt64(nil)^, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, PUInt32(nil)^, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 :=
    z_AsyncCopyImageSubDataNVX_16(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: IntPtr): UInt32 :=
    z_AsyncCopyImageSubDataNVX_15(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; var signalValueArray: UInt64): UInt32 :=
    z_AsyncCopyImageSubDataNVX_14(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; signalValueArray: IntPtr): UInt32 :=
    z_AsyncCopyImageSubDataNVX_13(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: IntPtr; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 :=
    z_AsyncCopyImageSubDataNVX_12(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: IntPtr; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: IntPtr): UInt32 :=
    z_AsyncCopyImageSubDataNVX_11(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: IntPtr; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; var signalValueArray: UInt64): UInt32 :=
    z_AsyncCopyImageSubDataNVX_10(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: IntPtr; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; signalValueArray: IntPtr): UInt32 :=
    z_AsyncCopyImageSubDataNVX_9(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 :=
    z_AsyncCopyImageSubDataNVX_8(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: IntPtr): UInt32 :=
    z_AsyncCopyImageSubDataNVX_7(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; var signalValueArray: UInt64): UInt32 :=
    z_AsyncCopyImageSubDataNVX_6(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; signalValueArray: IntPtr): UInt32 :=
    z_AsyncCopyImageSubDataNVX_5(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; waitValueArray: IntPtr; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 :=
    z_AsyncCopyImageSubDataNVX_4(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; waitValueArray: IntPtr; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: IntPtr): UInt32 :=
    z_AsyncCopyImageSubDataNVX_3(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; waitValueArray: IntPtr; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; var signalValueArray: UInt64): UInt32 :=
    z_AsyncCopyImageSubDataNVX_2(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: IntPtr; waitValueArray: IntPtr; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: IntPtr; signalValueArray: IntPtr): UInt32 :=
    z_AsyncCopyImageSubDataNVX_1(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glProgressFenceNVX = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nvx_progress_fence';
    
    private z_CreateProgressFenceNVX_adr := GetProcAddress('glCreateProgressFenceNVX');
    private z_CreateProgressFenceNVX_1 := GetProcOrNil&<function: UInt32>(z_CreateProgressFenceNVX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateProgressFenceNVX: UInt32 :=
    z_CreateProgressFenceNVX_1();
    
    private z_SignalSemaphoreui64NVX_adr := GetProcAddress('glSignalSemaphoreui64NVX');
    private z_SignalSemaphoreui64NVX_1 := GetProcOrNil&<procedure(signalGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: IntPtr; fenceValueArray: IntPtr)>(z_SignalSemaphoreui64NVX_adr);
    private z_SignalSemaphoreui64NVX_2 := GetProcOrNil&<procedure(signalGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: IntPtr; var fenceValueArray: UInt64)>(z_SignalSemaphoreui64NVX_adr);
    private z_SignalSemaphoreui64NVX_3 := GetProcOrNil&<procedure(signalGpu: UInt32; fenceObjectCount: Int32; var semaphoreArray: UInt32; fenceValueArray: IntPtr)>(z_SignalSemaphoreui64NVX_adr);
    private z_SignalSemaphoreui64NVX_4 := GetProcOrNil&<procedure(signalGpu: UInt32; fenceObjectCount: Int32; var semaphoreArray: UInt32; var fenceValueArray: UInt64)>(z_SignalSemaphoreui64NVX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreui64NVX(signalGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: array of UInt32; fenceValueArray: array of UInt64);
    type PUInt32=^UInt32;
    type PUInt64=^UInt64;
    begin
      if (fenceValueArray<>nil) and (fenceValueArray.Length<>0) then
        if (semaphoreArray<>nil) and (semaphoreArray.Length<>0) then
          z_SignalSemaphoreui64NVX_4(signalGpu, fenceObjectCount, semaphoreArray[0], fenceValueArray[0]) else
          z_SignalSemaphoreui64NVX_4(signalGpu, fenceObjectCount, PUInt32(nil)^, fenceValueArray[0]) else
        if (semaphoreArray<>nil) and (semaphoreArray.Length<>0) then
          z_SignalSemaphoreui64NVX_4(signalGpu, fenceObjectCount, semaphoreArray[0], PUInt64(nil)^) else
          z_SignalSemaphoreui64NVX_4(signalGpu, fenceObjectCount, PUInt32(nil)^, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreui64NVX(signalGpu: UInt32; fenceObjectCount: Int32; var semaphoreArray: UInt32; var fenceValueArray: UInt64) :=
    z_SignalSemaphoreui64NVX_4(signalGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreui64NVX(signalGpu: UInt32; fenceObjectCount: Int32; var semaphoreArray: UInt32; fenceValueArray: IntPtr) :=
    z_SignalSemaphoreui64NVX_3(signalGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreui64NVX(signalGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: IntPtr; var fenceValueArray: UInt64) :=
    z_SignalSemaphoreui64NVX_2(signalGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreui64NVX(signalGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: IntPtr; fenceValueArray: IntPtr) :=
    z_SignalSemaphoreui64NVX_1(signalGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
    
    private z_WaitSemaphoreui64NVX_adr := GetProcAddress('glWaitSemaphoreui64NVX');
    private z_WaitSemaphoreui64NVX_1 := GetProcOrNil&<procedure(waitGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: IntPtr; fenceValueArray: IntPtr)>(z_WaitSemaphoreui64NVX_adr);
    private z_WaitSemaphoreui64NVX_2 := GetProcOrNil&<procedure(waitGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: IntPtr; var fenceValueArray: UInt64)>(z_WaitSemaphoreui64NVX_adr);
    private z_WaitSemaphoreui64NVX_3 := GetProcOrNil&<procedure(waitGpu: UInt32; fenceObjectCount: Int32; var semaphoreArray: UInt32; fenceValueArray: IntPtr)>(z_WaitSemaphoreui64NVX_adr);
    private z_WaitSemaphoreui64NVX_4 := GetProcOrNil&<procedure(waitGpu: UInt32; fenceObjectCount: Int32; var semaphoreArray: UInt32; var fenceValueArray: UInt64)>(z_WaitSemaphoreui64NVX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreui64NVX(waitGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: array of UInt32; fenceValueArray: array of UInt64);
    type PUInt32=^UInt32;
    type PUInt64=^UInt64;
    begin
      if (fenceValueArray<>nil) and (fenceValueArray.Length<>0) then
        if (semaphoreArray<>nil) and (semaphoreArray.Length<>0) then
          z_WaitSemaphoreui64NVX_4(waitGpu, fenceObjectCount, semaphoreArray[0], fenceValueArray[0]) else
          z_WaitSemaphoreui64NVX_4(waitGpu, fenceObjectCount, PUInt32(nil)^, fenceValueArray[0]) else
        if (semaphoreArray<>nil) and (semaphoreArray.Length<>0) then
          z_WaitSemaphoreui64NVX_4(waitGpu, fenceObjectCount, semaphoreArray[0], PUInt64(nil)^) else
          z_WaitSemaphoreui64NVX_4(waitGpu, fenceObjectCount, PUInt32(nil)^, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreui64NVX(waitGpu: UInt32; fenceObjectCount: Int32; var semaphoreArray: UInt32; var fenceValueArray: UInt64) :=
    z_WaitSemaphoreui64NVX_4(waitGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreui64NVX(waitGpu: UInt32; fenceObjectCount: Int32; var semaphoreArray: UInt32; fenceValueArray: IntPtr) :=
    z_WaitSemaphoreui64NVX_3(waitGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreui64NVX(waitGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: IntPtr; var fenceValueArray: UInt64) :=
    z_WaitSemaphoreui64NVX_2(waitGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreui64NVX(waitGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: IntPtr; fenceValueArray: IntPtr) :=
    z_WaitSemaphoreui64NVX_1(waitGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
    
    private z_ClientWaitSemaphoreui64NVX_adr := GetProcAddress('glClientWaitSemaphoreui64NVX');
    private z_ClientWaitSemaphoreui64NVX_1 := GetProcOrNil&<procedure(fenceObjectCount: Int32; semaphoreArray: IntPtr; fenceValueArray: IntPtr)>(z_ClientWaitSemaphoreui64NVX_adr);
    private z_ClientWaitSemaphoreui64NVX_2 := GetProcOrNil&<procedure(fenceObjectCount: Int32; semaphoreArray: IntPtr; var fenceValueArray: UInt64)>(z_ClientWaitSemaphoreui64NVX_adr);
    private z_ClientWaitSemaphoreui64NVX_3 := GetProcOrNil&<procedure(fenceObjectCount: Int32; var semaphoreArray: UInt32; fenceValueArray: IntPtr)>(z_ClientWaitSemaphoreui64NVX_adr);
    private z_ClientWaitSemaphoreui64NVX_4 := GetProcOrNil&<procedure(fenceObjectCount: Int32; var semaphoreArray: UInt32; var fenceValueArray: UInt64)>(z_ClientWaitSemaphoreui64NVX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientWaitSemaphoreui64NVX(fenceObjectCount: Int32; semaphoreArray: array of UInt32; fenceValueArray: array of UInt64);
    type PUInt32=^UInt32;
    type PUInt64=^UInt64;
    begin
      if (fenceValueArray<>nil) and (fenceValueArray.Length<>0) then
        if (semaphoreArray<>nil) and (semaphoreArray.Length<>0) then
          z_ClientWaitSemaphoreui64NVX_4(fenceObjectCount, semaphoreArray[0], fenceValueArray[0]) else
          z_ClientWaitSemaphoreui64NVX_4(fenceObjectCount, PUInt32(nil)^, fenceValueArray[0]) else
        if (semaphoreArray<>nil) and (semaphoreArray.Length<>0) then
          z_ClientWaitSemaphoreui64NVX_4(fenceObjectCount, semaphoreArray[0], PUInt64(nil)^) else
          z_ClientWaitSemaphoreui64NVX_4(fenceObjectCount, PUInt32(nil)^, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientWaitSemaphoreui64NVX(fenceObjectCount: Int32; var semaphoreArray: UInt32; var fenceValueArray: UInt64) :=
    z_ClientWaitSemaphoreui64NVX_4(fenceObjectCount, semaphoreArray, fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientWaitSemaphoreui64NVX(fenceObjectCount: Int32; var semaphoreArray: UInt32; fenceValueArray: IntPtr) :=
    z_ClientWaitSemaphoreui64NVX_3(fenceObjectCount, semaphoreArray, fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientWaitSemaphoreui64NVX(fenceObjectCount: Int32; semaphoreArray: IntPtr; var fenceValueArray: UInt64) :=
    z_ClientWaitSemaphoreui64NVX_2(fenceObjectCount, semaphoreArray, fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientWaitSemaphoreui64NVX(fenceObjectCount: Int32; semaphoreArray: IntPtr; fenceValueArray: IntPtr) :=
    z_ClientWaitSemaphoreui64NVX_1(fenceObjectCount, semaphoreArray, fenceValueArray);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glMemoryAttachmentNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_memory_attachment';
    
    private z_GetMemoryObjectDetachedResourcesuivNV_adr := GetProcAddress('glGetMemoryObjectDetachedResourcesuivNV');
    private z_GetMemoryObjectDetachedResourcesuivNV_1 := GetProcOrNil&<procedure(memory: UInt32; pname: DummyEnum; first: Int32; count: Int32; &params: IntPtr)>(z_GetMemoryObjectDetachedResourcesuivNV_adr);
    private z_GetMemoryObjectDetachedResourcesuivNV_2 := GetProcOrNil&<procedure(memory: UInt32; pname: DummyEnum; first: Int32; count: Int32; var &params: UInt32)>(z_GetMemoryObjectDetachedResourcesuivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMemoryObjectDetachedResourcesuivNV(memory: UInt32; pname: DummyEnum; first: Int32; count: Int32; var &params: UInt32) :=
    z_GetMemoryObjectDetachedResourcesuivNV_2(memory, pname, first, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMemoryObjectDetachedResourcesuivNV(memory: UInt32; pname: DummyEnum; first: Int32; count: Int32; &params: IntPtr) :=
    z_GetMemoryObjectDetachedResourcesuivNV_1(memory, pname, first, count, &params);
    
    private z_ResetMemoryObjectParameterNV_adr := GetProcAddress('glResetMemoryObjectParameterNV');
    private z_ResetMemoryObjectParameterNV_1 := GetProcOrNil&<procedure(memory: UInt32; pname: DummyEnum)>(z_ResetMemoryObjectParameterNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ResetMemoryObjectParameterNV(memory: UInt32; pname: DummyEnum) :=
    z_ResetMemoryObjectParameterNV_1(memory, pname);
    
    private z_TexAttachMemoryNV_adr := GetProcAddress('glTexAttachMemoryNV');
    private z_TexAttachMemoryNV_1 := GetProcOrNil&<procedure(target: TextureTarget; memory: UInt32; offset: UInt64)>(z_TexAttachMemoryNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexAttachMemoryNV(target: TextureTarget; memory: UInt32; offset: UInt64) :=
    z_TexAttachMemoryNV_1(target, memory, offset);
    
    private z_BufferAttachMemoryNV_adr := GetProcAddress('glBufferAttachMemoryNV');
    private z_BufferAttachMemoryNV_1 := GetProcOrNil&<procedure(target: BufferTarget; memory: UInt32; offset: UInt64)>(z_BufferAttachMemoryNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferAttachMemoryNV(target: BufferTarget; memory: UInt32; offset: UInt64) :=
    z_BufferAttachMemoryNV_1(target, memory, offset);
    
    private z_TextureAttachMemoryNV_adr := GetProcAddress('glTextureAttachMemoryNV');
    private z_TextureAttachMemoryNV_1 := GetProcOrNil&<procedure(texture: gl_texture; memory: UInt32; offset: UInt64)>(z_TextureAttachMemoryNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureAttachMemoryNV(texture: gl_texture; memory: UInt32; offset: UInt64) :=
    z_TextureAttachMemoryNV_1(texture, memory, offset);
    
    private z_NamedBufferAttachMemoryNV_adr := GetProcAddress('glNamedBufferAttachMemoryNV');
    private z_NamedBufferAttachMemoryNV_1 := GetProcOrNil&<procedure(buffer: gl_buffer; memory: UInt32; offset: UInt64)>(z_NamedBufferAttachMemoryNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferAttachMemoryNV(buffer: gl_buffer; memory: UInt32; offset: UInt64) :=
    z_NamedBufferAttachMemoryNV_1(buffer, memory, offset);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glMemoryObjectSparseNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_memory_object_sparse';
    
    private z_BufferPageCommitmentMemNV_adr := GetProcAddress('glBufferPageCommitmentMemNV');
    private z_BufferPageCommitmentMemNV_1 := GetProcOrNil&<procedure(target: BufferStorageTarget; offset: IntPtr; size: UIntPtr; memory: UInt32; memOffset: UInt64; commit: boolean)>(z_BufferPageCommitmentMemNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferPageCommitmentMemNV(target: BufferStorageTarget; offset: IntPtr; size: UIntPtr; memory: UInt32; memOffset: UInt64; commit: boolean) :=
    z_BufferPageCommitmentMemNV_1(target, offset, size, memory, memOffset, commit);
    
    private z_TexPageCommitmentMemNV_adr := GetProcAddress('glTexPageCommitmentMemNV');
    private z_TexPageCommitmentMemNV_1 := GetProcOrNil&<procedure(target: TextureTarget; layer: Int32; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; memory: UInt32; offset: UInt64; commit: boolean)>(z_TexPageCommitmentMemNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexPageCommitmentMemNV(target: TextureTarget; layer: Int32; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; memory: UInt32; offset: UInt64; commit: boolean) :=
    z_TexPageCommitmentMemNV_1(target, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit);
    
    private z_NamedBufferPageCommitmentMemNV_adr := GetProcAddress('glNamedBufferPageCommitmentMemNV');
    private z_NamedBufferPageCommitmentMemNV_1 := GetProcOrNil&<procedure(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; memory: UInt32; memOffset: UInt64; commit: boolean)>(z_NamedBufferPageCommitmentMemNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferPageCommitmentMemNV(buffer: gl_buffer; offset: IntPtr; size: UIntPtr; memory: UInt32; memOffset: UInt64; commit: boolean) :=
    z_NamedBufferPageCommitmentMemNV_1(buffer, offset, size, memory, memOffset, commit);
    
    private z_TexturePageCommitmentMemNV_adr := GetProcAddress('glTexturePageCommitmentMemNV');
    private z_TexturePageCommitmentMemNV_1 := GetProcOrNil&<procedure(texture: gl_texture; layer: Int32; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; memory: UInt32; offset: UInt64; commit: boolean)>(z_TexturePageCommitmentMemNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexturePageCommitmentMemNV(texture: gl_texture; layer: Int32; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; memory: UInt32; offset: UInt64; commit: boolean) :=
    z_TexturePageCommitmentMemNV_1(texture, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glMeshShaderNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_mesh_shader';
    
    private z_DrawMeshTasksNV_adr := GetProcAddress('glDrawMeshTasksNV');
    private z_DrawMeshTasksNV_1 := GetProcOrNil&<procedure(first: UInt32; count: UInt32)>(z_DrawMeshTasksNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawMeshTasksNV(first: UInt32; count: UInt32) :=
    z_DrawMeshTasksNV_1(first, count);
    
    private z_DrawMeshTasksIndirectNV_adr := GetProcAddress('glDrawMeshTasksIndirectNV');
    private z_DrawMeshTasksIndirectNV_1 := GetProcOrNil&<procedure(indirect: IntPtr)>(z_DrawMeshTasksIndirectNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawMeshTasksIndirectNV(indirect: IntPtr) :=
    z_DrawMeshTasksIndirectNV_1(indirect);
    
    private z_MultiDrawMeshTasksIndirectNV_adr := GetProcAddress('glMultiDrawMeshTasksIndirectNV');
    private z_MultiDrawMeshTasksIndirectNV_1 := GetProcOrNil&<procedure(indirect: IntPtr; drawcount: Int32; stride: Int32)>(z_MultiDrawMeshTasksIndirectNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawMeshTasksIndirectNV(indirect: IntPtr; drawcount: Int32; stride: Int32) :=
    z_MultiDrawMeshTasksIndirectNV_1(indirect, drawcount, stride);
    
    private z_MultiDrawMeshTasksIndirectCountNV_adr := GetProcAddress('glMultiDrawMeshTasksIndirectCountNV');
    private z_MultiDrawMeshTasksIndirectCountNV_1 := GetProcOrNil&<procedure(indirect: IntPtr; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32)>(z_MultiDrawMeshTasksIndirectCountNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawMeshTasksIndirectCountNV(indirect: IntPtr; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32) :=
    z_MultiDrawMeshTasksIndirectCountNV_1(indirect, drawcount, maxdrawcount, stride);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glOcclusionQueryNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_occlusion_query';
    
    private z_GenOcclusionQueriesNV_adr := GetProcAddress('glGenOcclusionQueriesNV');
    private z_GenOcclusionQueriesNV_1 := GetProcOrNil&<procedure(n: Int32; ids: IntPtr)>(z_GenOcclusionQueriesNV_adr);
    private z_GenOcclusionQueriesNV_2 := GetProcOrNil&<procedure(n: Int32; var ids: UInt32)>(z_GenOcclusionQueriesNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenOcclusionQueriesNV(n: Int32; ids: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        z_GenOcclusionQueriesNV_2(n, ids[0]) else
        z_GenOcclusionQueriesNV_2(n, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenOcclusionQueriesNV(n: Int32; var ids: UInt32) :=
    z_GenOcclusionQueriesNV_2(n, ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenOcclusionQueriesNV(n: Int32; ids: IntPtr) :=
    z_GenOcclusionQueriesNV_1(n, ids);
    
    private z_DeleteOcclusionQueriesNV_adr := GetProcAddress('glDeleteOcclusionQueriesNV');
    private z_DeleteOcclusionQueriesNV_1 := GetProcOrNil&<procedure(n: Int32; ids: IntPtr)>(z_DeleteOcclusionQueriesNV_adr);
    private z_DeleteOcclusionQueriesNV_2 := GetProcOrNil&<procedure(n: Int32; var ids: UInt32)>(z_DeleteOcclusionQueriesNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteOcclusionQueriesNV(n: Int32; ids: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        z_DeleteOcclusionQueriesNV_2(n, ids[0]) else
        z_DeleteOcclusionQueriesNV_2(n, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteOcclusionQueriesNV(n: Int32; var ids: UInt32) :=
    z_DeleteOcclusionQueriesNV_2(n, ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteOcclusionQueriesNV(n: Int32; ids: IntPtr) :=
    z_DeleteOcclusionQueriesNV_1(n, ids);
    
    private z_IsOcclusionQueryNV_adr := GetProcAddress('glIsOcclusionQueryNV');
    private z_IsOcclusionQueryNV_1 := GetProcOrNil&<function(id: UInt32): boolean>(z_IsOcclusionQueryNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsOcclusionQueryNV(id: UInt32): boolean :=
    z_IsOcclusionQueryNV_1(id);
    
    private z_BeginOcclusionQueryNV_adr := GetProcAddress('glBeginOcclusionQueryNV');
    private z_BeginOcclusionQueryNV_1 := GetProcOrNil&<procedure(id: UInt32)>(z_BeginOcclusionQueryNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginOcclusionQueryNV(id: UInt32) :=
    z_BeginOcclusionQueryNV_1(id);
    
    private z_EndOcclusionQueryNV_adr := GetProcAddress('glEndOcclusionQueryNV');
    private z_EndOcclusionQueryNV_1 := GetProcOrNil&<procedure>(z_EndOcclusionQueryNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndOcclusionQueryNV :=
    z_EndOcclusionQueryNV_1();
    
    private z_GetOcclusionQueryivNV_adr := GetProcAddress('glGetOcclusionQueryivNV');
    private z_GetOcclusionQueryivNV_1 := GetProcOrNil&<procedure(id: UInt32; pname: OcclusionQueryParameterName; &params: IntPtr)>(z_GetOcclusionQueryivNV_adr);
    private z_GetOcclusionQueryivNV_2 := GetProcOrNil&<procedure(id: UInt32; pname: OcclusionQueryParameterName; var &params: Int32)>(z_GetOcclusionQueryivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetOcclusionQueryivNV(id: UInt32; pname: OcclusionQueryParameterName; var &params: Int32) :=
    z_GetOcclusionQueryivNV_2(id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetOcclusionQueryivNV(id: UInt32; pname: OcclusionQueryParameterName; &params: IntPtr) :=
    z_GetOcclusionQueryivNV_1(id, pname, &params);
    
    private z_GetOcclusionQueryuivNV_adr := GetProcAddress('glGetOcclusionQueryuivNV');
    private z_GetOcclusionQueryuivNV_1 := GetProcOrNil&<procedure(id: UInt32; pname: OcclusionQueryParameterName; &params: IntPtr)>(z_GetOcclusionQueryuivNV_adr);
    private z_GetOcclusionQueryuivNV_2 := GetProcOrNil&<procedure(id: UInt32; pname: OcclusionQueryParameterName; var &params: UInt32)>(z_GetOcclusionQueryuivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetOcclusionQueryuivNV(id: UInt32; pname: OcclusionQueryParameterName; var &params: UInt32) :=
    z_GetOcclusionQueryuivNV_2(id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetOcclusionQueryuivNV(id: UInt32; pname: OcclusionQueryParameterName; &params: IntPtr) :=
    z_GetOcclusionQueryuivNV_1(id, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glParameterBufferObjectNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_parameter_buffer_object';
    
    private z_ProgramBufferParametersfvNV_adr := GetProcAddress('glProgramBufferParametersfvNV');
    private z_ProgramBufferParametersfvNV_1 := GetProcOrNil&<procedure(target: ProgramTarget; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: IntPtr)>(z_ProgramBufferParametersfvNV_adr);
    private z_ProgramBufferParametersfvNV_2 := GetProcOrNil&<procedure(target: ProgramTarget; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; var &params: single)>(z_ProgramBufferParametersfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBufferParametersfvNV(target: ProgramTarget; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_ProgramBufferParametersfvNV_2(target, bindingIndex, wordIndex, count, &params[0]) else
        z_ProgramBufferParametersfvNV_2(target, bindingIndex, wordIndex, count, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBufferParametersfvNV(target: ProgramTarget; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; var &params: single) :=
    z_ProgramBufferParametersfvNV_2(target, bindingIndex, wordIndex, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBufferParametersfvNV(target: ProgramTarget; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: IntPtr) :=
    z_ProgramBufferParametersfvNV_1(target, bindingIndex, wordIndex, count, &params);
    
    private z_ProgramBufferParametersIivNV_adr := GetProcAddress('glProgramBufferParametersIivNV');
    private z_ProgramBufferParametersIivNV_1 := GetProcOrNil&<procedure(target: ProgramTarget; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: IntPtr)>(z_ProgramBufferParametersIivNV_adr);
    private z_ProgramBufferParametersIivNV_2 := GetProcOrNil&<procedure(target: ProgramTarget; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; var &params: Int32)>(z_ProgramBufferParametersIivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBufferParametersIivNV(target: ProgramTarget; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_ProgramBufferParametersIivNV_2(target, bindingIndex, wordIndex, count, &params[0]) else
        z_ProgramBufferParametersIivNV_2(target, bindingIndex, wordIndex, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBufferParametersIivNV(target: ProgramTarget; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; var &params: Int32) :=
    z_ProgramBufferParametersIivNV_2(target, bindingIndex, wordIndex, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBufferParametersIivNV(target: ProgramTarget; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: IntPtr) :=
    z_ProgramBufferParametersIivNV_1(target, bindingIndex, wordIndex, count, &params);
    
    private z_ProgramBufferParametersIuivNV_adr := GetProcAddress('glProgramBufferParametersIuivNV');
    private z_ProgramBufferParametersIuivNV_1 := GetProcOrNil&<procedure(target: ProgramTarget; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: IntPtr)>(z_ProgramBufferParametersIuivNV_adr);
    private z_ProgramBufferParametersIuivNV_2 := GetProcOrNil&<procedure(target: ProgramTarget; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; var &params: UInt32)>(z_ProgramBufferParametersIuivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBufferParametersIuivNV(target: ProgramTarget; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_ProgramBufferParametersIuivNV_2(target, bindingIndex, wordIndex, count, &params[0]) else
        z_ProgramBufferParametersIuivNV_2(target, bindingIndex, wordIndex, count, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBufferParametersIuivNV(target: ProgramTarget; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; var &params: UInt32) :=
    z_ProgramBufferParametersIuivNV_2(target, bindingIndex, wordIndex, count, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBufferParametersIuivNV(target: ProgramTarget; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: IntPtr) :=
    z_ProgramBufferParametersIuivNV_1(target, bindingIndex, wordIndex, count, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glPathRenderingNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_path_rendering';
    
    private z_GenPathsNV_adr := GetProcAddress('glGenPathsNV');
    private z_GenPathsNV_1 := GetProcOrNil&<function(range: Int32): UInt32>(z_GenPathsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenPathsNV(range: Int32): UInt32 :=
    z_GenPathsNV_1(range);
    
    private z_DeletePathsNV_adr := GetProcAddress('glDeletePathsNV');
    private z_DeletePathsNV_1 := GetProcOrNil&<procedure(path: UInt32; range: Int32)>(z_DeletePathsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeletePathsNV(path: UInt32; range: Int32) :=
    z_DeletePathsNV_1(path, range);
    
    private z_IsPathNV_adr := GetProcAddress('glIsPathNV');
    private z_IsPathNV_1 := GetProcOrNil&<function(path: UInt32): boolean>(z_IsPathNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsPathNV(path: UInt32): boolean :=
    z_IsPathNV_1(path);
    
    private z_PathCommandsNV_adr := GetProcAddress('glPathCommandsNV');
    private z_PathCommandsNV_1 := GetProcOrNil&<procedure(path: UInt32; numCommands: Int32; commands: IntPtr; numCoords: Int32; coordType: PathCoordType; coords: IntPtr)>(z_PathCommandsNV_adr);
    private z_PathCommandsNV_2 := GetProcOrNil&<procedure(path: UInt32; numCommands: Int32; var commands: Byte; numCoords: Int32; coordType: PathCoordType; coords: IntPtr)>(z_PathCommandsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathCommandsNV(path: UInt32; numCommands: Int32; commands: array of Byte; numCoords: Int32; coordType: PathCoordType; coords: IntPtr);
    type PByte=^Byte;
    begin
      if (commands<>nil) and (commands.Length<>0) then
        z_PathCommandsNV_2(path, numCommands, commands[0], numCoords, coordType, coords) else
        z_PathCommandsNV_2(path, numCommands, PByte(nil)^, numCoords, coordType, coords);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathCommandsNV(path: UInt32; numCommands: Int32; var commands: Byte; numCoords: Int32; coordType: PathCoordType; coords: IntPtr) :=
    z_PathCommandsNV_2(path, numCommands, commands, numCoords, coordType, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathCommandsNV(path: UInt32; numCommands: Int32; commands: IntPtr; numCoords: Int32; coordType: PathCoordType; coords: IntPtr) :=
    z_PathCommandsNV_1(path, numCommands, commands, numCoords, coordType, coords);
    
    private z_PathCoordsNV_adr := GetProcAddress('glPathCoordsNV');
    private z_PathCoordsNV_1 := GetProcOrNil&<procedure(path: UInt32; numCoords: Int32; coordType: PathCoordType; coords: IntPtr)>(z_PathCoordsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathCoordsNV(path: UInt32; numCoords: Int32; coordType: PathCoordType; coords: IntPtr) :=
    z_PathCoordsNV_1(path, numCoords, coordType, coords);
    
    private z_PathSubCommandsNV_adr := GetProcAddress('glPathSubCommandsNV');
    private z_PathSubCommandsNV_1 := GetProcOrNil&<procedure(path: UInt32; commandStart: Int32; commandsToDelete: Int32; numCommands: Int32; commands: IntPtr; numCoords: Int32; coordType: PathCoordType; coords: IntPtr)>(z_PathSubCommandsNV_adr);
    private z_PathSubCommandsNV_2 := GetProcOrNil&<procedure(path: UInt32; commandStart: Int32; commandsToDelete: Int32; numCommands: Int32; var commands: Byte; numCoords: Int32; coordType: PathCoordType; coords: IntPtr)>(z_PathSubCommandsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathSubCommandsNV(path: UInt32; commandStart: Int32; commandsToDelete: Int32; numCommands: Int32; commands: array of Byte; numCoords: Int32; coordType: PathCoordType; coords: IntPtr);
    type PByte=^Byte;
    begin
      if (commands<>nil) and (commands.Length<>0) then
        z_PathSubCommandsNV_2(path, commandStart, commandsToDelete, numCommands, commands[0], numCoords, coordType, coords) else
        z_PathSubCommandsNV_2(path, commandStart, commandsToDelete, numCommands, PByte(nil)^, numCoords, coordType, coords);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathSubCommandsNV(path: UInt32; commandStart: Int32; commandsToDelete: Int32; numCommands: Int32; var commands: Byte; numCoords: Int32; coordType: PathCoordType; coords: IntPtr) :=
    z_PathSubCommandsNV_2(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathSubCommandsNV(path: UInt32; commandStart: Int32; commandsToDelete: Int32; numCommands: Int32; commands: IntPtr; numCoords: Int32; coordType: PathCoordType; coords: IntPtr) :=
    z_PathSubCommandsNV_1(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);
    
    private z_PathSubCoordsNV_adr := GetProcAddress('glPathSubCoordsNV');
    private z_PathSubCoordsNV_1 := GetProcOrNil&<procedure(path: UInt32; coordStart: Int32; numCoords: Int32; coordType: PathCoordType; coords: IntPtr)>(z_PathSubCoordsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathSubCoordsNV(path: UInt32; coordStart: Int32; numCoords: Int32; coordType: PathCoordType; coords: IntPtr) :=
    z_PathSubCoordsNV_1(path, coordStart, numCoords, coordType, coords);
    
    private z_PathStringNV_adr := GetProcAddress('glPathStringNV');
    private z_PathStringNV_1 := GetProcOrNil&<procedure(path: UInt32; format: PathStringFormat; length: Int32; pathString: IntPtr)>(z_PathStringNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathStringNV(path: UInt32; format: PathStringFormat; length: Int32; pathString: IntPtr) :=
    z_PathStringNV_1(path, format, length, pathString);
    
    private z_PathGlyphsNV_adr := GetProcAddress('glPathGlyphsNV');
    private z_PathGlyphsNV_1 := GetProcOrNil&<procedure(firstPathName: UInt32; fontTarget: PathFontTarget; fontName: IntPtr; fontStyle: PathFontStyle; numGlyphs: Int32; &type: PathElementType; charcodes: IntPtr; handleMissingGlyphs: PathHandleMissingGlyphs; pathParameterTemplate: UInt32; emScale: single)>(z_PathGlyphsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathGlyphsNV(firstPathName: UInt32; fontTarget: PathFontTarget; fontName: IntPtr; fontStyle: PathFontStyle; numGlyphs: Int32; &type: PathElementType; charcodes: IntPtr; handleMissingGlyphs: PathHandleMissingGlyphs; pathParameterTemplate: UInt32; emScale: single) :=
    z_PathGlyphsNV_1(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, &type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
    
    private z_PathGlyphRangeNV_adr := GetProcAddress('glPathGlyphRangeNV');
    private z_PathGlyphRangeNV_1 := GetProcOrNil&<procedure(firstPathName: UInt32; fontTarget: PathFontTarget; fontName: IntPtr; fontStyle: PathFontStyle; firstGlyph: UInt32; numGlyphs: Int32; handleMissingGlyphs: PathHandleMissingGlyphs; pathParameterTemplate: UInt32; emScale: single)>(z_PathGlyphRangeNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathGlyphRangeNV(firstPathName: UInt32; fontTarget: PathFontTarget; fontName: IntPtr; fontStyle: PathFontStyle; firstGlyph: UInt32; numGlyphs: Int32; handleMissingGlyphs: PathHandleMissingGlyphs; pathParameterTemplate: UInt32; emScale: single) :=
    z_PathGlyphRangeNV_1(firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
    
    private z_WeightPathsNV_adr := GetProcAddress('glWeightPathsNV');
    private z_WeightPathsNV_1 := GetProcOrNil&<procedure(resultPath: UInt32; numPaths: Int32; paths: IntPtr; weights: IntPtr)>(z_WeightPathsNV_adr);
    private z_WeightPathsNV_2 := GetProcOrNil&<procedure(resultPath: UInt32; numPaths: Int32; paths: IntPtr; var weights: single)>(z_WeightPathsNV_adr);
    private z_WeightPathsNV_3 := GetProcOrNil&<procedure(resultPath: UInt32; numPaths: Int32; var paths: UInt32; weights: IntPtr)>(z_WeightPathsNV_adr);
    private z_WeightPathsNV_4 := GetProcOrNil&<procedure(resultPath: UInt32; numPaths: Int32; var paths: UInt32; var weights: single)>(z_WeightPathsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightPathsNV(resultPath: UInt32; numPaths: Int32; paths: array of UInt32; weights: array of single);
    type PUInt32=^UInt32;
    type Psingle=^single;
    begin
      if (weights<>nil) and (weights.Length<>0) then
        if (paths<>nil) and (paths.Length<>0) then
          z_WeightPathsNV_4(resultPath, numPaths, paths[0], weights[0]) else
          z_WeightPathsNV_4(resultPath, numPaths, PUInt32(nil)^, weights[0]) else
        if (paths<>nil) and (paths.Length<>0) then
          z_WeightPathsNV_4(resultPath, numPaths, paths[0], Psingle(nil)^) else
          z_WeightPathsNV_4(resultPath, numPaths, PUInt32(nil)^, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightPathsNV(resultPath: UInt32; numPaths: Int32; var paths: UInt32; var weights: single) :=
    z_WeightPathsNV_4(resultPath, numPaths, paths, weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightPathsNV(resultPath: UInt32; numPaths: Int32; var paths: UInt32; weights: IntPtr) :=
    z_WeightPathsNV_3(resultPath, numPaths, paths, weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightPathsNV(resultPath: UInt32; numPaths: Int32; paths: IntPtr; var weights: single) :=
    z_WeightPathsNV_2(resultPath, numPaths, paths, weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightPathsNV(resultPath: UInt32; numPaths: Int32; paths: IntPtr; weights: IntPtr) :=
    z_WeightPathsNV_1(resultPath, numPaths, paths, weights);
    
    private z_CopyPathNV_adr := GetProcAddress('glCopyPathNV');
    private z_CopyPathNV_1 := GetProcOrNil&<procedure(resultPath: UInt32; srcPath: UInt32)>(z_CopyPathNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyPathNV(resultPath: UInt32; srcPath: UInt32) :=
    z_CopyPathNV_1(resultPath, srcPath);
    
    private z_InterpolatePathsNV_adr := GetProcAddress('glInterpolatePathsNV');
    private z_InterpolatePathsNV_1 := GetProcOrNil&<procedure(resultPath: UInt32; pathA: UInt32; pathB: UInt32; weight: single)>(z_InterpolatePathsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InterpolatePathsNV(resultPath: UInt32; pathA: UInt32; pathB: UInt32; weight: single) :=
    z_InterpolatePathsNV_1(resultPath, pathA, pathB, weight);
    
    private z_TransformPathNV_adr := GetProcAddress('glTransformPathNV');
    private z_TransformPathNV_1 := GetProcOrNil&<procedure(resultPath: UInt32; srcPath: UInt32; transformType: PathTransformType; transformValues: IntPtr)>(z_TransformPathNV_adr);
    private z_TransformPathNV_2 := GetProcOrNil&<procedure(resultPath: UInt32; srcPath: UInt32; transformType: PathTransformType; var transformValues: single)>(z_TransformPathNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformPathNV(resultPath: UInt32; srcPath: UInt32; transformType: PathTransformType; transformValues: array of single);
    type Psingle=^single;
    begin
      if (transformValues<>nil) and (transformValues.Length<>0) then
        z_TransformPathNV_2(resultPath, srcPath, transformType, transformValues[0]) else
        z_TransformPathNV_2(resultPath, srcPath, transformType, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformPathNV(resultPath: UInt32; srcPath: UInt32; transformType: PathTransformType; var transformValues: single) :=
    z_TransformPathNV_2(resultPath, srcPath, transformType, transformValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformPathNV(resultPath: UInt32; srcPath: UInt32; transformType: PathTransformType; transformValues: IntPtr) :=
    z_TransformPathNV_1(resultPath, srcPath, transformType, transformValues);
    
    private z_PathParameterivNV_adr := GetProcAddress('glPathParameterivNV');
    private z_PathParameterivNV_1 := GetProcOrNil&<procedure(path: UInt32; pname: PathParameter; value: IntPtr)>(z_PathParameterivNV_adr);
    private z_PathParameterivNV_2 := GetProcOrNil&<procedure(path: UInt32; pname: PathParameter; var value: Int32)>(z_PathParameterivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathParameterivNV(path: UInt32; pname: PathParameter; value: array of Int32);
    type PInt32=^Int32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_PathParameterivNV_2(path, pname, value[0]) else
        z_PathParameterivNV_2(path, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathParameterivNV(path: UInt32; pname: PathParameter; var value: Int32) :=
    z_PathParameterivNV_2(path, pname, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathParameterivNV(path: UInt32; pname: PathParameter; value: IntPtr) :=
    z_PathParameterivNV_1(path, pname, value);
    
    private z_PathParameteriNV_adr := GetProcAddress('glPathParameteriNV');
    private z_PathParameteriNV_1 := GetProcOrNil&<procedure(path: UInt32; pname: PathParameter; value: Int32)>(z_PathParameteriNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathParameteriNV(path: UInt32; pname: PathParameter; value: Int32) :=
    z_PathParameteriNV_1(path, pname, value);
    
    private z_PathParameterfvNV_adr := GetProcAddress('glPathParameterfvNV');
    private z_PathParameterfvNV_1 := GetProcOrNil&<procedure(path: UInt32; pname: PathParameter; value: IntPtr)>(z_PathParameterfvNV_adr);
    private z_PathParameterfvNV_2 := GetProcOrNil&<procedure(path: UInt32; pname: PathParameter; var value: single)>(z_PathParameterfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathParameterfvNV(path: UInt32; pname: PathParameter; value: array of single);
    type Psingle=^single;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_PathParameterfvNV_2(path, pname, value[0]) else
        z_PathParameterfvNV_2(path, pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathParameterfvNV(path: UInt32; pname: PathParameter; var value: single) :=
    z_PathParameterfvNV_2(path, pname, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathParameterfvNV(path: UInt32; pname: PathParameter; value: IntPtr) :=
    z_PathParameterfvNV_1(path, pname, value);
    
    private z_PathParameterfNV_adr := GetProcAddress('glPathParameterfNV');
    private z_PathParameterfNV_1 := GetProcOrNil&<procedure(path: UInt32; pname: PathParameter; value: single)>(z_PathParameterfNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathParameterfNV(path: UInt32; pname: PathParameter; value: single) :=
    z_PathParameterfNV_1(path, pname, value);
    
    private z_PathDashArrayNV_adr := GetProcAddress('glPathDashArrayNV');
    private z_PathDashArrayNV_1 := GetProcOrNil&<procedure(path: UInt32; dashCount: Int32; dashArray: IntPtr)>(z_PathDashArrayNV_adr);
    private z_PathDashArrayNV_2 := GetProcOrNil&<procedure(path: UInt32; dashCount: Int32; var dashArray: single)>(z_PathDashArrayNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathDashArrayNV(path: UInt32; dashCount: Int32; dashArray: array of single);
    type Psingle=^single;
    begin
      if (dashArray<>nil) and (dashArray.Length<>0) then
        z_PathDashArrayNV_2(path, dashCount, dashArray[0]) else
        z_PathDashArrayNV_2(path, dashCount, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathDashArrayNV(path: UInt32; dashCount: Int32; var dashArray: single) :=
    z_PathDashArrayNV_2(path, dashCount, dashArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathDashArrayNV(path: UInt32; dashCount: Int32; dashArray: IntPtr) :=
    z_PathDashArrayNV_1(path, dashCount, dashArray);
    
    private z_PathStencilFuncNV_adr := GetProcAddress('glPathStencilFuncNV');
    private z_PathStencilFuncNV_1 := GetProcOrNil&<procedure(func: StencilFunction; ref: Int32; mask: UInt32)>(z_PathStencilFuncNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathStencilFuncNV(func: StencilFunction; ref: Int32; mask: UInt32) :=
    z_PathStencilFuncNV_1(func, ref, mask);
    
    private z_PathStencilDepthOffsetNV_adr := GetProcAddress('glPathStencilDepthOffsetNV');
    private z_PathStencilDepthOffsetNV_1 := GetProcOrNil&<procedure(factor: single; units: single)>(z_PathStencilDepthOffsetNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathStencilDepthOffsetNV(factor: single; units: single) :=
    z_PathStencilDepthOffsetNV_1(factor, units);
    
    private z_StencilFillPathNV_adr := GetProcAddress('glStencilFillPathNV');
    private z_StencilFillPathNV_1 := GetProcOrNil&<procedure(path: UInt32; fillMode: PathFillMode; mask: UInt32)>(z_StencilFillPathNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilFillPathNV(path: UInt32; fillMode: PathFillMode; mask: UInt32) :=
    z_StencilFillPathNV_1(path, fillMode, mask);
    
    private z_StencilStrokePathNV_adr := GetProcAddress('glStencilStrokePathNV');
    private z_StencilStrokePathNV_1 := GetProcOrNil&<procedure(path: UInt32; reference: Int32; mask: UInt32)>(z_StencilStrokePathNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilStrokePathNV(path: UInt32; reference: Int32; mask: UInt32) :=
    z_StencilStrokePathNV_1(path, reference, mask);
    
    private z_StencilFillPathInstancedNV_adr := GetProcAddress('glStencilFillPathInstancedNV');
    private z_StencilFillPathInstancedNV_1 := GetProcOrNil&<procedure(numPaths: Int32; pathNameType: PathElementType; paths: IntPtr; pathBase: UInt32; fillMode: PathFillMode; mask: UInt32; transformType: PathTransformType; transformValues: IntPtr)>(z_StencilFillPathInstancedNV_adr);
    private z_StencilFillPathInstancedNV_2 := GetProcOrNil&<procedure(numPaths: Int32; pathNameType: PathElementType; paths: IntPtr; pathBase: UInt32; fillMode: PathFillMode; mask: UInt32; transformType: PathTransformType; var transformValues: single)>(z_StencilFillPathInstancedNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilFillPathInstancedNV(numPaths: Int32; pathNameType: PathElementType; paths: IntPtr; pathBase: UInt32; fillMode: PathFillMode; mask: UInt32; transformType: PathTransformType; transformValues: array of single);
    type Psingle=^single;
    begin
      if (transformValues<>nil) and (transformValues.Length<>0) then
        z_StencilFillPathInstancedNV_2(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues[0]) else
        z_StencilFillPathInstancedNV_2(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilFillPathInstancedNV(numPaths: Int32; pathNameType: PathElementType; paths: IntPtr; pathBase: UInt32; fillMode: PathFillMode; mask: UInt32; transformType: PathTransformType; var transformValues: single) :=
    z_StencilFillPathInstancedNV_2(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilFillPathInstancedNV(numPaths: Int32; pathNameType: PathElementType; paths: IntPtr; pathBase: UInt32; fillMode: PathFillMode; mask: UInt32; transformType: PathTransformType; transformValues: IntPtr) :=
    z_StencilFillPathInstancedNV_1(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);
    
    private z_StencilStrokePathInstancedNV_adr := GetProcAddress('glStencilStrokePathInstancedNV');
    private z_StencilStrokePathInstancedNV_1 := GetProcOrNil&<procedure(numPaths: Int32; pathNameType: PathElementType; paths: IntPtr; pathBase: UInt32; reference: Int32; mask: UInt32; transformType: PathTransformType; transformValues: IntPtr)>(z_StencilStrokePathInstancedNV_adr);
    private z_StencilStrokePathInstancedNV_2 := GetProcOrNil&<procedure(numPaths: Int32; pathNameType: PathElementType; paths: IntPtr; pathBase: UInt32; reference: Int32; mask: UInt32; transformType: PathTransformType; var transformValues: single)>(z_StencilStrokePathInstancedNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilStrokePathInstancedNV(numPaths: Int32; pathNameType: PathElementType; paths: IntPtr; pathBase: UInt32; reference: Int32; mask: UInt32; transformType: PathTransformType; transformValues: array of single);
    type Psingle=^single;
    begin
      if (transformValues<>nil) and (transformValues.Length<>0) then
        z_StencilStrokePathInstancedNV_2(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues[0]) else
        z_StencilStrokePathInstancedNV_2(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilStrokePathInstancedNV(numPaths: Int32; pathNameType: PathElementType; paths: IntPtr; pathBase: UInt32; reference: Int32; mask: UInt32; transformType: PathTransformType; var transformValues: single) :=
    z_StencilStrokePathInstancedNV_2(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilStrokePathInstancedNV(numPaths: Int32; pathNameType: PathElementType; paths: IntPtr; pathBase: UInt32; reference: Int32; mask: UInt32; transformType: PathTransformType; transformValues: IntPtr) :=
    z_StencilStrokePathInstancedNV_1(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);
    
    private z_PathCoverDepthFuncNV_adr := GetProcAddress('glPathCoverDepthFuncNV');
    private z_PathCoverDepthFuncNV_1 := GetProcOrNil&<procedure(func: DepthFunction)>(z_PathCoverDepthFuncNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathCoverDepthFuncNV(func: DepthFunction) :=
    z_PathCoverDepthFuncNV_1(func);
    
    private z_CoverFillPathNV_adr := GetProcAddress('glCoverFillPathNV');
    private z_CoverFillPathNV_1 := GetProcOrNil&<procedure(path: UInt32; coverMode: PathCoverMode)>(z_CoverFillPathNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverFillPathNV(path: UInt32; coverMode: PathCoverMode) :=
    z_CoverFillPathNV_1(path, coverMode);
    
    private z_CoverStrokePathNV_adr := GetProcAddress('glCoverStrokePathNV');
    private z_CoverStrokePathNV_1 := GetProcOrNil&<procedure(path: UInt32; coverMode: PathCoverMode)>(z_CoverStrokePathNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverStrokePathNV(path: UInt32; coverMode: PathCoverMode) :=
    z_CoverStrokePathNV_1(path, coverMode);
    
    private z_CoverFillPathInstancedNV_adr := GetProcAddress('glCoverFillPathInstancedNV');
    private z_CoverFillPathInstancedNV_1 := GetProcOrNil&<procedure(numPaths: Int32; pathNameType: PathElementType; paths: IntPtr; pathBase: UInt32; coverMode: PathCoverMode; transformType: PathTransformType; transformValues: IntPtr)>(z_CoverFillPathInstancedNV_adr);
    private z_CoverFillPathInstancedNV_2 := GetProcOrNil&<procedure(numPaths: Int32; pathNameType: PathElementType; paths: IntPtr; pathBase: UInt32; coverMode: PathCoverMode; transformType: PathTransformType; var transformValues: single)>(z_CoverFillPathInstancedNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverFillPathInstancedNV(numPaths: Int32; pathNameType: PathElementType; paths: IntPtr; pathBase: UInt32; coverMode: PathCoverMode; transformType: PathTransformType; transformValues: array of single);
    type Psingle=^single;
    begin
      if (transformValues<>nil) and (transformValues.Length<>0) then
        z_CoverFillPathInstancedNV_2(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues[0]) else
        z_CoverFillPathInstancedNV_2(numPaths, pathNameType, paths, pathBase, coverMode, transformType, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverFillPathInstancedNV(numPaths: Int32; pathNameType: PathElementType; paths: IntPtr; pathBase: UInt32; coverMode: PathCoverMode; transformType: PathTransformType; var transformValues: single) :=
    z_CoverFillPathInstancedNV_2(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverFillPathInstancedNV(numPaths: Int32; pathNameType: PathElementType; paths: IntPtr; pathBase: UInt32; coverMode: PathCoverMode; transformType: PathTransformType; transformValues: IntPtr) :=
    z_CoverFillPathInstancedNV_1(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
    
    private z_CoverStrokePathInstancedNV_adr := GetProcAddress('glCoverStrokePathInstancedNV');
    private z_CoverStrokePathInstancedNV_1 := GetProcOrNil&<procedure(numPaths: Int32; pathNameType: PathElementType; paths: IntPtr; pathBase: UInt32; coverMode: PathCoverMode; transformType: PathTransformType; transformValues: IntPtr)>(z_CoverStrokePathInstancedNV_adr);
    private z_CoverStrokePathInstancedNV_2 := GetProcOrNil&<procedure(numPaths: Int32; pathNameType: PathElementType; paths: IntPtr; pathBase: UInt32; coverMode: PathCoverMode; transformType: PathTransformType; var transformValues: single)>(z_CoverStrokePathInstancedNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverStrokePathInstancedNV(numPaths: Int32; pathNameType: PathElementType; paths: IntPtr; pathBase: UInt32; coverMode: PathCoverMode; transformType: PathTransformType; transformValues: array of single);
    type Psingle=^single;
    begin
      if (transformValues<>nil) and (transformValues.Length<>0) then
        z_CoverStrokePathInstancedNV_2(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues[0]) else
        z_CoverStrokePathInstancedNV_2(numPaths, pathNameType, paths, pathBase, coverMode, transformType, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverStrokePathInstancedNV(numPaths: Int32; pathNameType: PathElementType; paths: IntPtr; pathBase: UInt32; coverMode: PathCoverMode; transformType: PathTransformType; var transformValues: single) :=
    z_CoverStrokePathInstancedNV_2(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverStrokePathInstancedNV(numPaths: Int32; pathNameType: PathElementType; paths: IntPtr; pathBase: UInt32; coverMode: PathCoverMode; transformType: PathTransformType; transformValues: IntPtr) :=
    z_CoverStrokePathInstancedNV_1(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
    
    private z_GetPathParameterivNV_adr := GetProcAddress('glGetPathParameterivNV');
    private z_GetPathParameterivNV_1 := GetProcOrNil&<procedure(path: UInt32; pname: PathParameter; value: IntPtr)>(z_GetPathParameterivNV_adr);
    private z_GetPathParameterivNV_2 := GetProcOrNil&<procedure(path: UInt32; pname: PathParameter; var value: Int32)>(z_GetPathParameterivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathParameterivNV(path: UInt32; pname: PathParameter; var value: Int32) :=
    z_GetPathParameterivNV_2(path, pname, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathParameterivNV(path: UInt32; pname: PathParameter; value: IntPtr) :=
    z_GetPathParameterivNV_1(path, pname, value);
    
    private z_GetPathParameterfvNV_adr := GetProcAddress('glGetPathParameterfvNV');
    private z_GetPathParameterfvNV_1 := GetProcOrNil&<procedure(path: UInt32; pname: PathParameter; value: IntPtr)>(z_GetPathParameterfvNV_adr);
    private z_GetPathParameterfvNV_2 := GetProcOrNil&<procedure(path: UInt32; pname: PathParameter; var value: single)>(z_GetPathParameterfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathParameterfvNV(path: UInt32; pname: PathParameter; var value: single) :=
    z_GetPathParameterfvNV_2(path, pname, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathParameterfvNV(path: UInt32; pname: PathParameter; value: IntPtr) :=
    z_GetPathParameterfvNV_1(path, pname, value);
    
    private z_GetPathCommandsNV_adr := GetProcAddress('glGetPathCommandsNV');
    private z_GetPathCommandsNV_1 := GetProcOrNil&<procedure(path: UInt32; commands: IntPtr)>(z_GetPathCommandsNV_adr);
    private z_GetPathCommandsNV_2 := GetProcOrNil&<procedure(path: UInt32; var commands: Byte)>(z_GetPathCommandsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathCommandsNV(path: UInt32; var commands: Byte) :=
    z_GetPathCommandsNV_2(path, commands);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathCommandsNV(path: UInt32; commands: IntPtr) :=
    z_GetPathCommandsNV_1(path, commands);
    
    private z_GetPathCoordsNV_adr := GetProcAddress('glGetPathCoordsNV');
    private z_GetPathCoordsNV_1 := GetProcOrNil&<procedure(path: UInt32; coords: IntPtr)>(z_GetPathCoordsNV_adr);
    private z_GetPathCoordsNV_2 := GetProcOrNil&<procedure(path: UInt32; var coords: single)>(z_GetPathCoordsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathCoordsNV(path: UInt32; var coords: single) :=
    z_GetPathCoordsNV_2(path, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathCoordsNV(path: UInt32; coords: IntPtr) :=
    z_GetPathCoordsNV_1(path, coords);
    
    private z_GetPathDashArrayNV_adr := GetProcAddress('glGetPathDashArrayNV');
    private z_GetPathDashArrayNV_1 := GetProcOrNil&<procedure(path: UInt32; dashArray: IntPtr)>(z_GetPathDashArrayNV_adr);
    private z_GetPathDashArrayNV_2 := GetProcOrNil&<procedure(path: UInt32; var dashArray: single)>(z_GetPathDashArrayNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathDashArrayNV(path: UInt32; var dashArray: single) :=
    z_GetPathDashArrayNV_2(path, dashArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathDashArrayNV(path: UInt32; dashArray: IntPtr) :=
    z_GetPathDashArrayNV_1(path, dashArray);
    
    private z_GetPathMetricsNV_adr := GetProcAddress('glGetPathMetricsNV');
    private z_GetPathMetricsNV_1 := GetProcOrNil&<procedure(metricQueryMask: PathMetricMask; numPaths: Int32; pathNameType: PathElementType; paths: IntPtr; pathBase: UInt32; stride: Int32; metrics: IntPtr)>(z_GetPathMetricsNV_adr);
    private z_GetPathMetricsNV_2 := GetProcOrNil&<procedure(metricQueryMask: PathMetricMask; numPaths: Int32; pathNameType: PathElementType; paths: IntPtr; pathBase: UInt32; stride: Int32; var metrics: single)>(z_GetPathMetricsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathMetricsNV(metricQueryMask: PathMetricMask; numPaths: Int32; pathNameType: PathElementType; paths: IntPtr; pathBase: UInt32; stride: Int32; var metrics: single) :=
    z_GetPathMetricsNV_2(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathMetricsNV(metricQueryMask: PathMetricMask; numPaths: Int32; pathNameType: PathElementType; paths: IntPtr; pathBase: UInt32; stride: Int32; metrics: IntPtr) :=
    z_GetPathMetricsNV_1(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics);
    
    private z_GetPathMetricRangeNV_adr := GetProcAddress('glGetPathMetricRangeNV');
    private z_GetPathMetricRangeNV_1 := GetProcOrNil&<procedure(metricQueryMask: PathMetricMask; firstPathName: UInt32; numPaths: Int32; stride: Int32; metrics: IntPtr)>(z_GetPathMetricRangeNV_adr);
    private z_GetPathMetricRangeNV_2 := GetProcOrNil&<procedure(metricQueryMask: PathMetricMask; firstPathName: UInt32; numPaths: Int32; stride: Int32; var metrics: single)>(z_GetPathMetricRangeNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathMetricRangeNV(metricQueryMask: PathMetricMask; firstPathName: UInt32; numPaths: Int32; stride: Int32; var metrics: single) :=
    z_GetPathMetricRangeNV_2(metricQueryMask, firstPathName, numPaths, stride, metrics);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathMetricRangeNV(metricQueryMask: PathMetricMask; firstPathName: UInt32; numPaths: Int32; stride: Int32; metrics: IntPtr) :=
    z_GetPathMetricRangeNV_1(metricQueryMask, firstPathName, numPaths, stride, metrics);
    
    private z_GetPathSpacingNV_adr := GetProcAddress('glGetPathSpacingNV');
    private z_GetPathSpacingNV_1 := GetProcOrNil&<procedure(_pathListMode: PathListMode; numPaths: Int32; pathNameType: PathElementType; paths: IntPtr; pathBase: UInt32; advanceScale: single; kerningScale: single; transformType: PathTransformType; returnedSpacing: IntPtr)>(z_GetPathSpacingNV_adr);
    private z_GetPathSpacingNV_2 := GetProcOrNil&<procedure(_pathListMode: PathListMode; numPaths: Int32; pathNameType: PathElementType; paths: IntPtr; pathBase: UInt32; advanceScale: single; kerningScale: single; transformType: PathTransformType; var returnedSpacing: single)>(z_GetPathSpacingNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathSpacingNV(_pathListMode: PathListMode; numPaths: Int32; pathNameType: PathElementType; paths: IntPtr; pathBase: UInt32; advanceScale: single; kerningScale: single; transformType: PathTransformType; var returnedSpacing: single) :=
    z_GetPathSpacingNV_2(_pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathSpacingNV(_pathListMode: PathListMode; numPaths: Int32; pathNameType: PathElementType; paths: IntPtr; pathBase: UInt32; advanceScale: single; kerningScale: single; transformType: PathTransformType; returnedSpacing: IntPtr) :=
    z_GetPathSpacingNV_1(_pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);
    
    private z_IsPointInFillPathNV_adr := GetProcAddress('glIsPointInFillPathNV');
    private z_IsPointInFillPathNV_1 := GetProcOrNil&<function(path: UInt32; mask: UInt32; x: single; y: single): boolean>(z_IsPointInFillPathNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsPointInFillPathNV(path: UInt32; mask: UInt32; x: single; y: single): boolean :=
    z_IsPointInFillPathNV_1(path, mask, x, y);
    
    private z_IsPointInStrokePathNV_adr := GetProcAddress('glIsPointInStrokePathNV');
    private z_IsPointInStrokePathNV_1 := GetProcOrNil&<function(path: UInt32; x: single; y: single): boolean>(z_IsPointInStrokePathNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsPointInStrokePathNV(path: UInt32; x: single; y: single): boolean :=
    z_IsPointInStrokePathNV_1(path, x, y);
    
    private z_GetPathLengthNV_adr := GetProcAddress('glGetPathLengthNV');
    private z_GetPathLengthNV_1 := GetProcOrNil&<function(path: UInt32; startSegment: Int32; numSegments: Int32): single>(z_GetPathLengthNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPathLengthNV(path: UInt32; startSegment: Int32; numSegments: Int32): single :=
    z_GetPathLengthNV_1(path, startSegment, numSegments);
    
    private z_PointAlongPathNV_adr := GetProcAddress('glPointAlongPathNV');
    private z_PointAlongPathNV_1 := GetProcOrNil&<function(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: IntPtr; y: IntPtr; tangentX: IntPtr; tangentY: IntPtr): boolean>(z_PointAlongPathNV_adr);
    private z_PointAlongPathNV_2 := GetProcOrNil&<function(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: IntPtr; y: IntPtr; var tangentX: single; var tangentY: single): boolean>(z_PointAlongPathNV_adr);
    private z_PointAlongPathNV_3 := GetProcOrNil&<function(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; var y: single; tangentX: IntPtr; tangentY: IntPtr): boolean>(z_PointAlongPathNV_adr);
    private z_PointAlongPathNV_4 := GetProcOrNil&<function(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; var y: single; var tangentX: single; var tangentY: single): boolean>(z_PointAlongPathNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; var y: single; var tangentX: single; var tangentY: single): boolean :=
    z_PointAlongPathNV_4(path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; var y: single; tangentX: IntPtr; tangentY: IntPtr): boolean :=
    z_PointAlongPathNV_3(path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: IntPtr; y: IntPtr; var tangentX: single; var tangentY: single): boolean :=
    z_PointAlongPathNV_2(path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: IntPtr; y: IntPtr; tangentX: IntPtr; tangentY: IntPtr): boolean :=
    z_PointAlongPathNV_1(path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
    
    private z_MatrixLoad3x2fNV_adr := GetProcAddress('glMatrixLoad3x2fNV');
    private z_MatrixLoad3x2fNV_1 := GetProcOrNil&<procedure(matrixMode: DummyEnum; m: IntPtr)>(z_MatrixLoad3x2fNV_adr);
    private z_MatrixLoad3x2fNV_2 := GetProcOrNil&<procedure(matrixMode: DummyEnum; var m: single)>(z_MatrixLoad3x2fNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoad3x2fNV(matrixMode: DummyEnum; m: array of single);
    type Psingle=^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_MatrixLoad3x2fNV_2(matrixMode, m[0]) else
        z_MatrixLoad3x2fNV_2(matrixMode, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoad3x2fNV(matrixMode: DummyEnum; var m: single) :=
    z_MatrixLoad3x2fNV_2(matrixMode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoad3x2fNV(matrixMode: DummyEnum; m: IntPtr) :=
    z_MatrixLoad3x2fNV_1(matrixMode, m);
    
    private z_MatrixLoad3x3fNV_adr := GetProcAddress('glMatrixLoad3x3fNV');
    private z_MatrixLoad3x3fNV_1 := GetProcOrNil&<procedure(matrixMode: DummyEnum; m: IntPtr)>(z_MatrixLoad3x3fNV_adr);
    private z_MatrixLoad3x3fNV_2 := GetProcOrNil&<procedure(matrixMode: DummyEnum; var m: single)>(z_MatrixLoad3x3fNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoad3x3fNV(matrixMode: DummyEnum; m: array of single);
    type Psingle=^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_MatrixLoad3x3fNV_2(matrixMode, m[0]) else
        z_MatrixLoad3x3fNV_2(matrixMode, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoad3x3fNV(matrixMode: DummyEnum; var m: single) :=
    z_MatrixLoad3x3fNV_2(matrixMode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoad3x3fNV(matrixMode: DummyEnum; m: IntPtr) :=
    z_MatrixLoad3x3fNV_1(matrixMode, m);
    
    private z_MatrixLoadTranspose3x3fNV_adr := GetProcAddress('glMatrixLoadTranspose3x3fNV');
    private z_MatrixLoadTranspose3x3fNV_1 := GetProcOrNil&<procedure(matrixMode: DummyEnum; m: IntPtr)>(z_MatrixLoadTranspose3x3fNV_adr);
    private z_MatrixLoadTranspose3x3fNV_2 := GetProcOrNil&<procedure(matrixMode: DummyEnum; var m: single)>(z_MatrixLoadTranspose3x3fNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTranspose3x3fNV(matrixMode: DummyEnum; m: array of single);
    type Psingle=^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_MatrixLoadTranspose3x3fNV_2(matrixMode, m[0]) else
        z_MatrixLoadTranspose3x3fNV_2(matrixMode, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTranspose3x3fNV(matrixMode: DummyEnum; var m: single) :=
    z_MatrixLoadTranspose3x3fNV_2(matrixMode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTranspose3x3fNV(matrixMode: DummyEnum; m: IntPtr) :=
    z_MatrixLoadTranspose3x3fNV_1(matrixMode, m);
    
    private z_MatrixMult3x2fNV_adr := GetProcAddress('glMatrixMult3x2fNV');
    private z_MatrixMult3x2fNV_1 := GetProcOrNil&<procedure(matrixMode: DummyEnum; m: IntPtr)>(z_MatrixMult3x2fNV_adr);
    private z_MatrixMult3x2fNV_2 := GetProcOrNil&<procedure(matrixMode: DummyEnum; var m: single)>(z_MatrixMult3x2fNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMult3x2fNV(matrixMode: DummyEnum; m: array of single);
    type Psingle=^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_MatrixMult3x2fNV_2(matrixMode, m[0]) else
        z_MatrixMult3x2fNV_2(matrixMode, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMult3x2fNV(matrixMode: DummyEnum; var m: single) :=
    z_MatrixMult3x2fNV_2(matrixMode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMult3x2fNV(matrixMode: DummyEnum; m: IntPtr) :=
    z_MatrixMult3x2fNV_1(matrixMode, m);
    
    private z_MatrixMult3x3fNV_adr := GetProcAddress('glMatrixMult3x3fNV');
    private z_MatrixMult3x3fNV_1 := GetProcOrNil&<procedure(matrixMode: DummyEnum; m: IntPtr)>(z_MatrixMult3x3fNV_adr);
    private z_MatrixMult3x3fNV_2 := GetProcOrNil&<procedure(matrixMode: DummyEnum; var m: single)>(z_MatrixMult3x3fNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMult3x3fNV(matrixMode: DummyEnum; m: array of single);
    type Psingle=^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_MatrixMult3x3fNV_2(matrixMode, m[0]) else
        z_MatrixMult3x3fNV_2(matrixMode, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMult3x3fNV(matrixMode: DummyEnum; var m: single) :=
    z_MatrixMult3x3fNV_2(matrixMode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMult3x3fNV(matrixMode: DummyEnum; m: IntPtr) :=
    z_MatrixMult3x3fNV_1(matrixMode, m);
    
    private z_MatrixMultTranspose3x3fNV_adr := GetProcAddress('glMatrixMultTranspose3x3fNV');
    private z_MatrixMultTranspose3x3fNV_1 := GetProcOrNil&<procedure(matrixMode: DummyEnum; m: IntPtr)>(z_MatrixMultTranspose3x3fNV_adr);
    private z_MatrixMultTranspose3x3fNV_2 := GetProcOrNil&<procedure(matrixMode: DummyEnum; var m: single)>(z_MatrixMultTranspose3x3fNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTranspose3x3fNV(matrixMode: DummyEnum; m: array of single);
    type Psingle=^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_MatrixMultTranspose3x3fNV_2(matrixMode, m[0]) else
        z_MatrixMultTranspose3x3fNV_2(matrixMode, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTranspose3x3fNV(matrixMode: DummyEnum; var m: single) :=
    z_MatrixMultTranspose3x3fNV_2(matrixMode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTranspose3x3fNV(matrixMode: DummyEnum; m: IntPtr) :=
    z_MatrixMultTranspose3x3fNV_1(matrixMode, m);
    
    private z_StencilThenCoverFillPathNV_adr := GetProcAddress('glStencilThenCoverFillPathNV');
    private z_StencilThenCoverFillPathNV_1 := GetProcOrNil&<procedure(path: UInt32; fillMode: DummyEnum; mask: UInt32; coverMode: DummyEnum)>(z_StencilThenCoverFillPathNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilThenCoverFillPathNV(path: UInt32; fillMode: DummyEnum; mask: UInt32; coverMode: DummyEnum) :=
    z_StencilThenCoverFillPathNV_1(path, fillMode, mask, coverMode);
    
    private z_StencilThenCoverStrokePathNV_adr := GetProcAddress('glStencilThenCoverStrokePathNV');
    private z_StencilThenCoverStrokePathNV_1 := GetProcOrNil&<procedure(path: UInt32; reference: Int32; mask: UInt32; coverMode: DummyEnum)>(z_StencilThenCoverStrokePathNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilThenCoverStrokePathNV(path: UInt32; reference: Int32; mask: UInt32; coverMode: DummyEnum) :=
    z_StencilThenCoverStrokePathNV_1(path, reference, mask, coverMode);
    
    private z_StencilThenCoverFillPathInstancedNV_adr := GetProcAddress('glStencilThenCoverFillPathInstancedNV');
    private z_StencilThenCoverFillPathInstancedNV_1 := GetProcOrNil&<procedure(numPaths: Int32; pathNameType: DummyEnum; paths: IntPtr; pathBase: UInt32; fillMode: DummyEnum; mask: UInt32; coverMode: DummyEnum; transformType: DummyEnum; transformValues: IntPtr)>(z_StencilThenCoverFillPathInstancedNV_adr);
    private z_StencilThenCoverFillPathInstancedNV_2 := GetProcOrNil&<procedure(numPaths: Int32; pathNameType: DummyEnum; paths: IntPtr; pathBase: UInt32; fillMode: DummyEnum; mask: UInt32; coverMode: DummyEnum; transformType: DummyEnum; var transformValues: single)>(z_StencilThenCoverFillPathInstancedNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilThenCoverFillPathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: IntPtr; pathBase: UInt32; fillMode: DummyEnum; mask: UInt32; coverMode: DummyEnum; transformType: DummyEnum; transformValues: array of single);
    type Psingle=^single;
    begin
      if (transformValues<>nil) and (transformValues.Length<>0) then
        z_StencilThenCoverFillPathInstancedNV_2(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues[0]) else
        z_StencilThenCoverFillPathInstancedNV_2(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilThenCoverFillPathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: IntPtr; pathBase: UInt32; fillMode: DummyEnum; mask: UInt32; coverMode: DummyEnum; transformType: DummyEnum; var transformValues: single) :=
    z_StencilThenCoverFillPathInstancedNV_2(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilThenCoverFillPathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: IntPtr; pathBase: UInt32; fillMode: DummyEnum; mask: UInt32; coverMode: DummyEnum; transformType: DummyEnum; transformValues: IntPtr) :=
    z_StencilThenCoverFillPathInstancedNV_1(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues);
    
    private z_StencilThenCoverStrokePathInstancedNV_adr := GetProcAddress('glStencilThenCoverStrokePathInstancedNV');
    private z_StencilThenCoverStrokePathInstancedNV_1 := GetProcOrNil&<procedure(numPaths: Int32; pathNameType: DummyEnum; paths: IntPtr; pathBase: UInt32; reference: Int32; mask: UInt32; coverMode: DummyEnum; transformType: DummyEnum; transformValues: IntPtr)>(z_StencilThenCoverStrokePathInstancedNV_adr);
    private z_StencilThenCoverStrokePathInstancedNV_2 := GetProcOrNil&<procedure(numPaths: Int32; pathNameType: DummyEnum; paths: IntPtr; pathBase: UInt32; reference: Int32; mask: UInt32; coverMode: DummyEnum; transformType: DummyEnum; var transformValues: single)>(z_StencilThenCoverStrokePathInstancedNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilThenCoverStrokePathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: IntPtr; pathBase: UInt32; reference: Int32; mask: UInt32; coverMode: DummyEnum; transformType: DummyEnum; transformValues: array of single);
    type Psingle=^single;
    begin
      if (transformValues<>nil) and (transformValues.Length<>0) then
        z_StencilThenCoverStrokePathInstancedNV_2(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues[0]) else
        z_StencilThenCoverStrokePathInstancedNV_2(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilThenCoverStrokePathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: IntPtr; pathBase: UInt32; reference: Int32; mask: UInt32; coverMode: DummyEnum; transformType: DummyEnum; var transformValues: single) :=
    z_StencilThenCoverStrokePathInstancedNV_2(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilThenCoverStrokePathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: IntPtr; pathBase: UInt32; reference: Int32; mask: UInt32; coverMode: DummyEnum; transformType: DummyEnum; transformValues: IntPtr) :=
    z_StencilThenCoverStrokePathInstancedNV_1(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues);
    
    private z_PathGlyphIndexRangeNV_adr := GetProcAddress('glPathGlyphIndexRangeNV');
    private z_PathGlyphIndexRangeNV_1 := GetProcOrNil&<function(fontTarget: DummyEnum; fontName: IntPtr; fontStyle: PathFontStyle; pathParameterTemplate: UInt32; emScale: single; baseAndCount: IntPtr): DummyEnum>(z_PathGlyphIndexRangeNV_adr);
    private z_PathGlyphIndexRangeNV_2 := GetProcOrNil&<function(fontTarget: DummyEnum; fontName: IntPtr; fontStyle: PathFontStyle; pathParameterTemplate: UInt32; emScale: single; var baseAndCount: UInt32): DummyEnum>(z_PathGlyphIndexRangeNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PathGlyphIndexRangeNV(fontTarget: DummyEnum; fontName: IntPtr; fontStyle: PathFontStyle; pathParameterTemplate: UInt32; emScale: single; baseAndCount: array of UInt32): DummyEnum;
    type PUInt32=^UInt32;
    begin
      Result := if (baseAndCount<>nil) and (baseAndCount.Length<>0) then
        z_PathGlyphIndexRangeNV_2(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount[0]) else
        z_PathGlyphIndexRangeNV_2(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PathGlyphIndexRangeNV(fontTarget: DummyEnum; fontName: IntPtr; fontStyle: PathFontStyle; pathParameterTemplate: UInt32; emScale: single; var baseAndCount: UInt32): DummyEnum :=
    z_PathGlyphIndexRangeNV_2(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PathGlyphIndexRangeNV(fontTarget: DummyEnum; fontName: IntPtr; fontStyle: PathFontStyle; pathParameterTemplate: UInt32; emScale: single; baseAndCount: IntPtr): DummyEnum :=
    z_PathGlyphIndexRangeNV_1(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount);
    
    private z_PathGlyphIndexArrayNV_adr := GetProcAddress('glPathGlyphIndexArrayNV');
    private z_PathGlyphIndexArrayNV_1 := GetProcOrNil&<function(firstPathName: UInt32; fontTarget: DummyEnum; fontName: IntPtr; fontStyle: PathFontStyle; firstGlyphIndex: UInt32; numGlyphs: Int32; pathParameterTemplate: UInt32; emScale: single): DummyEnum>(z_PathGlyphIndexArrayNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PathGlyphIndexArrayNV(firstPathName: UInt32; fontTarget: DummyEnum; fontName: IntPtr; fontStyle: PathFontStyle; firstGlyphIndex: UInt32; numGlyphs: Int32; pathParameterTemplate: UInt32; emScale: single): DummyEnum :=
    z_PathGlyphIndexArrayNV_1(firstPathName, fontTarget, fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
    
    private z_PathMemoryGlyphIndexArrayNV_adr := GetProcAddress('glPathMemoryGlyphIndexArrayNV');
    private z_PathMemoryGlyphIndexArrayNV_1 := GetProcOrNil&<function(firstPathName: UInt32; fontTarget: DummyEnum; fontSize: UIntPtr; fontData: IntPtr; faceIndex: Int32; firstGlyphIndex: UInt32; numGlyphs: Int32; pathParameterTemplate: UInt32; emScale: single): DummyEnum>(z_PathMemoryGlyphIndexArrayNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PathMemoryGlyphIndexArrayNV(firstPathName: UInt32; fontTarget: DummyEnum; fontSize: UIntPtr; fontData: IntPtr; faceIndex: Int32; firstGlyphIndex: UInt32; numGlyphs: Int32; pathParameterTemplate: UInt32; emScale: single): DummyEnum :=
    z_PathMemoryGlyphIndexArrayNV_1(firstPathName, fontTarget, fontSize, fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
    
    private z_ProgramPathFragmentInputGenNV_adr := GetProcAddress('glProgramPathFragmentInputGenNV');
    private z_ProgramPathFragmentInputGenNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; genMode: DummyEnum; components: Int32; coeffs: IntPtr)>(z_ProgramPathFragmentInputGenNV_adr);
    private z_ProgramPathFragmentInputGenNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; genMode: DummyEnum; components: Int32; var coeffs: single)>(z_ProgramPathFragmentInputGenNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramPathFragmentInputGenNV(&program: gl_program; location: Int32; genMode: DummyEnum; components: Int32; coeffs: array of single);
    type Psingle=^single;
    begin
      if (coeffs<>nil) and (coeffs.Length<>0) then
        z_ProgramPathFragmentInputGenNV_2(&program, location, genMode, components, coeffs[0]) else
        z_ProgramPathFragmentInputGenNV_2(&program, location, genMode, components, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramPathFragmentInputGenNV(&program: gl_program; location: Int32; genMode: DummyEnum; components: Int32; var coeffs: single) :=
    z_ProgramPathFragmentInputGenNV_2(&program, location, genMode, components, coeffs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramPathFragmentInputGenNV(&program: gl_program; location: Int32; genMode: DummyEnum; components: Int32; coeffs: IntPtr) :=
    z_ProgramPathFragmentInputGenNV_1(&program, location, genMode, components, coeffs);
    
    private z_GetProgramResourcefvNV_adr := GetProcAddress('glGetProgramResourcefvNV');
    private z_GetProgramResourcefvNV_1 := GetProcOrNil&<procedure(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; length: IntPtr; &params: IntPtr)>(z_GetProgramResourcefvNV_adr);
    private z_GetProgramResourcefvNV_2 := GetProcOrNil&<procedure(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; length: IntPtr; var &params: single)>(z_GetProgramResourcefvNV_adr);
    private z_GetProgramResourcefvNV_3 := GetProcOrNil&<procedure(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; var length: Int32; &params: IntPtr)>(z_GetProgramResourcefvNV_adr);
    private z_GetProgramResourcefvNV_4 := GetProcOrNil&<procedure(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; var length: Int32; var &params: single)>(z_GetProgramResourcefvNV_adr);
    private z_GetProgramResourcefvNV_5 := GetProcOrNil&<procedure(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; var props: DummyEnum; count: Int32; length: IntPtr; &params: IntPtr)>(z_GetProgramResourcefvNV_adr);
    private z_GetProgramResourcefvNV_6 := GetProcOrNil&<procedure(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; var props: DummyEnum; count: Int32; length: IntPtr; var &params: single)>(z_GetProgramResourcefvNV_adr);
    private z_GetProgramResourcefvNV_7 := GetProcOrNil&<procedure(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; var props: DummyEnum; count: Int32; var length: Int32; &params: IntPtr)>(z_GetProgramResourcefvNV_adr);
    private z_GetProgramResourcefvNV_8 := GetProcOrNil&<procedure(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; var props: DummyEnum; count: Int32; var length: Int32; var &params: single)>(z_GetProgramResourcefvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; props: array of DummyEnum; count: Int32; var length: Int32; var &params: single);
    type PDummyEnum=^DummyEnum;
    begin
      if (props<>nil) and (props.Length<>0) then
        z_GetProgramResourcefvNV_8(&program, _programInterface, index, propCount, props[0], count, length, &params) else
        z_GetProgramResourcefvNV_8(&program, _programInterface, index, propCount, PDummyEnum(nil)^, count, length, &params);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; props: array of DummyEnum; count: Int32; var length: Int32; &params: IntPtr);
    type PDummyEnum=^DummyEnum;
    begin
      if (props<>nil) and (props.Length<>0) then
        z_GetProgramResourcefvNV_7(&program, _programInterface, index, propCount, props[0], count, length, &params) else
        z_GetProgramResourcefvNV_7(&program, _programInterface, index, propCount, PDummyEnum(nil)^, count, length, &params);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; props: array of DummyEnum; count: Int32; length: IntPtr; var &params: single);
    type PDummyEnum=^DummyEnum;
    begin
      if (props<>nil) and (props.Length<>0) then
        z_GetProgramResourcefvNV_6(&program, _programInterface, index, propCount, props[0], count, length, &params) else
        z_GetProgramResourcefvNV_6(&program, _programInterface, index, propCount, PDummyEnum(nil)^, count, length, &params);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; props: array of DummyEnum; count: Int32; length: IntPtr; &params: IntPtr);
    type PDummyEnum=^DummyEnum;
    begin
      if (props<>nil) and (props.Length<>0) then
        z_GetProgramResourcefvNV_5(&program, _programInterface, index, propCount, props[0], count, length, &params) else
        z_GetProgramResourcefvNV_5(&program, _programInterface, index, propCount, PDummyEnum(nil)^, count, length, &params);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; var props: DummyEnum; count: Int32; var length: Int32; var &params: single) :=
    z_GetProgramResourcefvNV_8(&program, _programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; var props: DummyEnum; count: Int32; var length: Int32; &params: IntPtr) :=
    z_GetProgramResourcefvNV_7(&program, _programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; var props: DummyEnum; count: Int32; length: IntPtr; var &params: single) :=
    z_GetProgramResourcefvNV_6(&program, _programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; var props: DummyEnum; count: Int32; length: IntPtr; &params: IntPtr) :=
    z_GetProgramResourcefvNV_5(&program, _programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; var length: Int32; var &params: single) :=
    z_GetProgramResourcefvNV_4(&program, _programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; var length: Int32; &params: IntPtr) :=
    z_GetProgramResourcefvNV_3(&program, _programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; length: IntPtr; var &params: single) :=
    z_GetProgramResourcefvNV_2(&program, _programInterface, index, propCount, props, count, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: gl_program; _programInterface: ProgramInterface; index: UInt32; propCount: Int32; props: IntPtr; count: Int32; length: IntPtr; &params: IntPtr) :=
    z_GetProgramResourcefvNV_1(&program, _programInterface, index, propCount, props, count, length, &params);
    
    private z_PathColorGenNV_adr := GetProcAddress('glPathColorGenNV');
    private z_PathColorGenNV_1 := GetProcOrNil&<procedure(color: PathColor; genMode: PathGenMode; colorFormat: PathColorFormat; coeffs: IntPtr)>(z_PathColorGenNV_adr);
    private z_PathColorGenNV_2 := GetProcOrNil&<procedure(color: PathColor; genMode: PathGenMode; colorFormat: PathColorFormat; var coeffs: single)>(z_PathColorGenNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathColorGenNV(color: PathColor; genMode: PathGenMode; colorFormat: PathColorFormat; coeffs: array of single);
    type Psingle=^single;
    begin
      if (coeffs<>nil) and (coeffs.Length<>0) then
        z_PathColorGenNV_2(color, genMode, colorFormat, coeffs[0]) else
        z_PathColorGenNV_2(color, genMode, colorFormat, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathColorGenNV(color: PathColor; genMode: PathGenMode; colorFormat: PathColorFormat; var coeffs: single) :=
    z_PathColorGenNV_2(color, genMode, colorFormat, coeffs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathColorGenNV(color: PathColor; genMode: PathGenMode; colorFormat: PathColorFormat; coeffs: IntPtr) :=
    z_PathColorGenNV_1(color, genMode, colorFormat, coeffs);
    
    private z_PathTexGenNV_adr := GetProcAddress('glPathTexGenNV');
    private z_PathTexGenNV_1 := GetProcOrNil&<procedure(texCoordSet: PathColor; genMode: PathGenMode; components: Int32; coeffs: IntPtr)>(z_PathTexGenNV_adr);
    private z_PathTexGenNV_2 := GetProcOrNil&<procedure(texCoordSet: PathColor; genMode: PathGenMode; components: Int32; var coeffs: single)>(z_PathTexGenNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathTexGenNV(texCoordSet: PathColor; genMode: PathGenMode; components: Int32; coeffs: array of single);
    type Psingle=^single;
    begin
      if (coeffs<>nil) and (coeffs.Length<>0) then
        z_PathTexGenNV_2(texCoordSet, genMode, components, coeffs[0]) else
        z_PathTexGenNV_2(texCoordSet, genMode, components, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathTexGenNV(texCoordSet: PathColor; genMode: PathGenMode; components: Int32; var coeffs: single) :=
    z_PathTexGenNV_2(texCoordSet, genMode, components, coeffs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathTexGenNV(texCoordSet: PathColor; genMode: PathGenMode; components: Int32; coeffs: IntPtr) :=
    z_PathTexGenNV_1(texCoordSet, genMode, components, coeffs);
    
    private z_PathFogGenNV_adr := GetProcAddress('glPathFogGenNV');
    private z_PathFogGenNV_1 := GetProcOrNil&<procedure(genMode: PathGenMode)>(z_PathFogGenNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathFogGenNV(genMode: PathGenMode) :=
    z_PathFogGenNV_1(genMode);
    
    private z_GetPathColorGenivNV_adr := GetProcAddress('glGetPathColorGenivNV');
    private z_GetPathColorGenivNV_1 := GetProcOrNil&<procedure(color: PathColor; pname: PathGenMode; value: IntPtr)>(z_GetPathColorGenivNV_adr);
    private z_GetPathColorGenivNV_2 := GetProcOrNil&<procedure(color: PathColor; pname: PathGenMode; var value: Int32)>(z_GetPathColorGenivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathColorGenivNV(color: PathColor; pname: PathGenMode; var value: Int32) :=
    z_GetPathColorGenivNV_2(color, pname, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathColorGenivNV(color: PathColor; pname: PathGenMode; value: IntPtr) :=
    z_GetPathColorGenivNV_1(color, pname, value);
    
    private z_GetPathColorGenfvNV_adr := GetProcAddress('glGetPathColorGenfvNV');
    private z_GetPathColorGenfvNV_1 := GetProcOrNil&<procedure(color: PathColor; pname: PathGenMode; value: IntPtr)>(z_GetPathColorGenfvNV_adr);
    private z_GetPathColorGenfvNV_2 := GetProcOrNil&<procedure(color: PathColor; pname: PathGenMode; var value: single)>(z_GetPathColorGenfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathColorGenfvNV(color: PathColor; pname: PathGenMode; var value: single) :=
    z_GetPathColorGenfvNV_2(color, pname, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathColorGenfvNV(color: PathColor; pname: PathGenMode; value: IntPtr) :=
    z_GetPathColorGenfvNV_1(color, pname, value);
    
    private z_GetPathTexGenivNV_adr := GetProcAddress('glGetPathTexGenivNV');
    private z_GetPathTexGenivNV_1 := GetProcOrNil&<procedure(texCoordSet: TextureUnit; pname: PathGenMode; value: IntPtr)>(z_GetPathTexGenivNV_adr);
    private z_GetPathTexGenivNV_2 := GetProcOrNil&<procedure(texCoordSet: TextureUnit; pname: PathGenMode; var value: Int32)>(z_GetPathTexGenivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathTexGenivNV(texCoordSet: TextureUnit; pname: PathGenMode; var value: Int32) :=
    z_GetPathTexGenivNV_2(texCoordSet, pname, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathTexGenivNV(texCoordSet: TextureUnit; pname: PathGenMode; value: IntPtr) :=
    z_GetPathTexGenivNV_1(texCoordSet, pname, value);
    
    private z_GetPathTexGenfvNV_adr := GetProcAddress('glGetPathTexGenfvNV');
    private z_GetPathTexGenfvNV_1 := GetProcOrNil&<procedure(texCoordSet: TextureUnit; pname: PathGenMode; value: IntPtr)>(z_GetPathTexGenfvNV_adr);
    private z_GetPathTexGenfvNV_2 := GetProcOrNil&<procedure(texCoordSet: TextureUnit; pname: PathGenMode; var value: single)>(z_GetPathTexGenfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathTexGenfvNV(texCoordSet: TextureUnit; pname: PathGenMode; var value: single) :=
    z_GetPathTexGenfvNV_2(texCoordSet, pname, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathTexGenfvNV(texCoordSet: TextureUnit; pname: PathGenMode; value: IntPtr) :=
    z_GetPathTexGenfvNV_1(texCoordSet, pname, value);
    
    private z_MatrixFrustumEXT_adr := GetProcAddress('glMatrixFrustumEXT');
    private z_MatrixFrustumEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode; left: real; right: real; bottom: real; top: real; zNear: real; zFar: real)>(z_MatrixFrustumEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixFrustumEXT(mode: MatrixMode; left: real; right: real; bottom: real; top: real; zNear: real; zFar: real) :=
    z_MatrixFrustumEXT_1(mode, left, right, bottom, top, zNear, zFar);
    
    private z_MatrixLoadIdentityEXT_adr := GetProcAddress('glMatrixLoadIdentityEXT');
    private z_MatrixLoadIdentityEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode)>(z_MatrixLoadIdentityEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadIdentityEXT(mode: MatrixMode) :=
    z_MatrixLoadIdentityEXT_1(mode);
    
    private z_MatrixLoadTransposefEXT_adr := GetProcAddress('glMatrixLoadTransposefEXT');
    private z_MatrixLoadTransposefEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode; m: IntPtr)>(z_MatrixLoadTransposefEXT_adr);
    private z_MatrixLoadTransposefEXT_2 := GetProcOrNil&<procedure(mode: MatrixMode; var m: single)>(z_MatrixLoadTransposefEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTransposefEXT(mode: MatrixMode; m: array of single);
    type Psingle=^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_MatrixLoadTransposefEXT_2(mode, m[0]) else
        z_MatrixLoadTransposefEXT_2(mode, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTransposefEXT(mode: MatrixMode; var m: single) :=
    z_MatrixLoadTransposefEXT_2(mode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTransposefEXT(mode: MatrixMode; m: IntPtr) :=
    z_MatrixLoadTransposefEXT_1(mode, m);
    
    private z_MatrixLoadTransposedEXT_adr := GetProcAddress('glMatrixLoadTransposedEXT');
    private z_MatrixLoadTransposedEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode; m: IntPtr)>(z_MatrixLoadTransposedEXT_adr);
    private z_MatrixLoadTransposedEXT_2 := GetProcOrNil&<procedure(mode: MatrixMode; var m: real)>(z_MatrixLoadTransposedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTransposedEXT(mode: MatrixMode; m: array of real);
    type Preal=^real;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_MatrixLoadTransposedEXT_2(mode, m[0]) else
        z_MatrixLoadTransposedEXT_2(mode, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTransposedEXT(mode: MatrixMode; var m: real) :=
    z_MatrixLoadTransposedEXT_2(mode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTransposedEXT(mode: MatrixMode; m: IntPtr) :=
    z_MatrixLoadTransposedEXT_1(mode, m);
    
    private z_MatrixLoadfEXT_adr := GetProcAddress('glMatrixLoadfEXT');
    private z_MatrixLoadfEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode; m: IntPtr)>(z_MatrixLoadfEXT_adr);
    private z_MatrixLoadfEXT_2 := GetProcOrNil&<procedure(mode: MatrixMode; var m: single)>(z_MatrixLoadfEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadfEXT(mode: MatrixMode; m: array of single);
    type Psingle=^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_MatrixLoadfEXT_2(mode, m[0]) else
        z_MatrixLoadfEXT_2(mode, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadfEXT(mode: MatrixMode; var m: single) :=
    z_MatrixLoadfEXT_2(mode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadfEXT(mode: MatrixMode; m: IntPtr) :=
    z_MatrixLoadfEXT_1(mode, m);
    
    private z_MatrixLoaddEXT_adr := GetProcAddress('glMatrixLoaddEXT');
    private z_MatrixLoaddEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode; m: IntPtr)>(z_MatrixLoaddEXT_adr);
    private z_MatrixLoaddEXT_2 := GetProcOrNil&<procedure(mode: MatrixMode; var m: real)>(z_MatrixLoaddEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoaddEXT(mode: MatrixMode; m: array of real);
    type Preal=^real;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_MatrixLoaddEXT_2(mode, m[0]) else
        z_MatrixLoaddEXT_2(mode, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoaddEXT(mode: MatrixMode; var m: real) :=
    z_MatrixLoaddEXT_2(mode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoaddEXT(mode: MatrixMode; m: IntPtr) :=
    z_MatrixLoaddEXT_1(mode, m);
    
    private z_MatrixMultTransposefEXT_adr := GetProcAddress('glMatrixMultTransposefEXT');
    private z_MatrixMultTransposefEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode; m: IntPtr)>(z_MatrixMultTransposefEXT_adr);
    private z_MatrixMultTransposefEXT_2 := GetProcOrNil&<procedure(mode: MatrixMode; var m: single)>(z_MatrixMultTransposefEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTransposefEXT(mode: MatrixMode; m: array of single);
    type Psingle=^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_MatrixMultTransposefEXT_2(mode, m[0]) else
        z_MatrixMultTransposefEXT_2(mode, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTransposefEXT(mode: MatrixMode; var m: single) :=
    z_MatrixMultTransposefEXT_2(mode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTransposefEXT(mode: MatrixMode; m: IntPtr) :=
    z_MatrixMultTransposefEXT_1(mode, m);
    
    private z_MatrixMultTransposedEXT_adr := GetProcAddress('glMatrixMultTransposedEXT');
    private z_MatrixMultTransposedEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode; m: IntPtr)>(z_MatrixMultTransposedEXT_adr);
    private z_MatrixMultTransposedEXT_2 := GetProcOrNil&<procedure(mode: MatrixMode; var m: real)>(z_MatrixMultTransposedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTransposedEXT(mode: MatrixMode; m: array of real);
    type Preal=^real;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_MatrixMultTransposedEXT_2(mode, m[0]) else
        z_MatrixMultTransposedEXT_2(mode, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTransposedEXT(mode: MatrixMode; var m: real) :=
    z_MatrixMultTransposedEXT_2(mode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTransposedEXT(mode: MatrixMode; m: IntPtr) :=
    z_MatrixMultTransposedEXT_1(mode, m);
    
    private z_MatrixMultfEXT_adr := GetProcAddress('glMatrixMultfEXT');
    private z_MatrixMultfEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode; m: IntPtr)>(z_MatrixMultfEXT_adr);
    private z_MatrixMultfEXT_2 := GetProcOrNil&<procedure(mode: MatrixMode; var m: single)>(z_MatrixMultfEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultfEXT(mode: MatrixMode; m: array of single);
    type Psingle=^single;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_MatrixMultfEXT_2(mode, m[0]) else
        z_MatrixMultfEXT_2(mode, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultfEXT(mode: MatrixMode; var m: single) :=
    z_MatrixMultfEXT_2(mode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultfEXT(mode: MatrixMode; m: IntPtr) :=
    z_MatrixMultfEXT_1(mode, m);
    
    private z_MatrixMultdEXT_adr := GetProcAddress('glMatrixMultdEXT');
    private z_MatrixMultdEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode; m: IntPtr)>(z_MatrixMultdEXT_adr);
    private z_MatrixMultdEXT_2 := GetProcOrNil&<procedure(mode: MatrixMode; var m: real)>(z_MatrixMultdEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultdEXT(mode: MatrixMode; m: array of real);
    type Preal=^real;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_MatrixMultdEXT_2(mode, m[0]) else
        z_MatrixMultdEXT_2(mode, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultdEXT(mode: MatrixMode; var m: real) :=
    z_MatrixMultdEXT_2(mode, m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultdEXT(mode: MatrixMode; m: IntPtr) :=
    z_MatrixMultdEXT_1(mode, m);
    
    private z_MatrixOrthoEXT_adr := GetProcAddress('glMatrixOrthoEXT');
    private z_MatrixOrthoEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode; left: real; right: real; bottom: real; top: real; zNear: real; zFar: real)>(z_MatrixOrthoEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixOrthoEXT(mode: MatrixMode; left: real; right: real; bottom: real; top: real; zNear: real; zFar: real) :=
    z_MatrixOrthoEXT_1(mode, left, right, bottom, top, zNear, zFar);
    
    private z_MatrixPopEXT_adr := GetProcAddress('glMatrixPopEXT');
    private z_MatrixPopEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode)>(z_MatrixPopEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixPopEXT(mode: MatrixMode) :=
    z_MatrixPopEXT_1(mode);
    
    private z_MatrixPushEXT_adr := GetProcAddress('glMatrixPushEXT');
    private z_MatrixPushEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode)>(z_MatrixPushEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixPushEXT(mode: MatrixMode) :=
    z_MatrixPushEXT_1(mode);
    
    private z_MatrixRotatefEXT_adr := GetProcAddress('glMatrixRotatefEXT');
    private z_MatrixRotatefEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode; angle: single; x: single; y: single; z: single)>(z_MatrixRotatefEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixRotatefEXT(mode: MatrixMode; angle: single; x: single; y: single; z: single) :=
    z_MatrixRotatefEXT_1(mode, angle, x, y, z);
    
    private z_MatrixRotatedEXT_adr := GetProcAddress('glMatrixRotatedEXT');
    private z_MatrixRotatedEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode; angle: real; x: real; y: real; z: real)>(z_MatrixRotatedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixRotatedEXT(mode: MatrixMode; angle: real; x: real; y: real; z: real) :=
    z_MatrixRotatedEXT_1(mode, angle, x, y, z);
    
    private z_MatrixScalefEXT_adr := GetProcAddress('glMatrixScalefEXT');
    private z_MatrixScalefEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode; x: single; y: single; z: single)>(z_MatrixScalefEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixScalefEXT(mode: MatrixMode; x: single; y: single; z: single) :=
    z_MatrixScalefEXT_1(mode, x, y, z);
    
    private z_MatrixScaledEXT_adr := GetProcAddress('glMatrixScaledEXT');
    private z_MatrixScaledEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode; x: real; y: real; z: real)>(z_MatrixScaledEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixScaledEXT(mode: MatrixMode; x: real; y: real; z: real) :=
    z_MatrixScaledEXT_1(mode, x, y, z);
    
    private z_MatrixTranslatefEXT_adr := GetProcAddress('glMatrixTranslatefEXT');
    private z_MatrixTranslatefEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode; x: single; y: single; z: single)>(z_MatrixTranslatefEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixTranslatefEXT(mode: MatrixMode; x: single; y: single; z: single) :=
    z_MatrixTranslatefEXT_1(mode, x, y, z);
    
    private z_MatrixTranslatedEXT_adr := GetProcAddress('glMatrixTranslatedEXT');
    private z_MatrixTranslatedEXT_1 := GetProcOrNil&<procedure(mode: MatrixMode; x: real; y: real; z: real)>(z_MatrixTranslatedEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixTranslatedEXT(mode: MatrixMode; x: real; y: real; z: real) :=
    z_MatrixTranslatedEXT_1(mode, x, y, z);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glPixelDataRangeNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_pixel_data_range';
    
    private z_PixelDataRangeNV_adr := GetProcAddress('glPixelDataRangeNV');
    private z_PixelDataRangeNV_1 := GetProcOrNil&<procedure(target: PixelDataRangeTarget; length: Int32; pointer: IntPtr)>(z_PixelDataRangeNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelDataRangeNV(target: PixelDataRangeTarget; length: Int32; pointer: IntPtr) :=
    z_PixelDataRangeNV_1(target, length, pointer);
    
    private z_FlushPixelDataRangeNV_adr := GetProcAddress('glFlushPixelDataRangeNV');
    private z_FlushPixelDataRangeNV_1 := GetProcOrNil&<procedure(target: PixelDataRangeTarget)>(z_FlushPixelDataRangeNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FlushPixelDataRangeNV(target: PixelDataRangeTarget) :=
    z_FlushPixelDataRangeNV_1(target);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glPointSpriteNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_point_sprite';
    
    private z_PointParameteriNV_adr := GetProcAddress('glPointParameteriNV');
    private z_PointParameteriNV_1 := GetProcOrNil&<procedure(pname: PointParameterName; param: Int32)>(z_PointParameteriNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameteriNV(pname: PointParameterName; param: Int32) :=
    z_PointParameteriNV_1(pname, param);
    
    private z_PointParameterivNV_adr := GetProcAddress('glPointParameterivNV');
    private z_PointParameterivNV_1 := GetProcOrNil&<procedure(pname: PointParameterName; &params: IntPtr)>(z_PointParameterivNV_adr);
    private z_PointParameterivNV_2 := GetProcOrNil&<procedure(pname: PointParameterName; var &params: Int32)>(z_PointParameterivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterivNV(pname: PointParameterName; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_PointParameterivNV_2(pname, &params[0]) else
        z_PointParameterivNV_2(pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterivNV(pname: PointParameterName; var &params: Int32) :=
    z_PointParameterivNV_2(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterivNV(pname: PointParameterName; &params: IntPtr) :=
    z_PointParameterivNV_1(pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glPresentVideoNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_present_video';
    
    private z_PresentFrameKeyedNV_adr := GetProcAddress('glPresentFrameKeyedNV');
    private z_PresentFrameKeyedNV_1 := GetProcOrNil&<procedure(video_slot: UInt32; minPresentTime: UInt64; beginPresentTimeId: UInt32; presentDurationId: UInt32; &type: DummyEnum; target0: DummyEnum; fill0: UInt32; key0: UInt32; target1: DummyEnum; fill1: UInt32; key1: UInt32)>(z_PresentFrameKeyedNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PresentFrameKeyedNV(video_slot: UInt32; minPresentTime: UInt64; beginPresentTimeId: UInt32; presentDurationId: UInt32; &type: DummyEnum; target0: DummyEnum; fill0: UInt32; key0: UInt32; target1: DummyEnum; fill1: UInt32; key1: UInt32) :=
    z_PresentFrameKeyedNV_1(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, &type, target0, fill0, key0, target1, fill1, key1);
    
    private z_PresentFrameDualFillNV_adr := GetProcAddress('glPresentFrameDualFillNV');
    private z_PresentFrameDualFillNV_1 := GetProcOrNil&<procedure(video_slot: UInt32; minPresentTime: UInt64; beginPresentTimeId: UInt32; presentDurationId: UInt32; &type: DummyEnum; target0: DummyEnum; fill0: UInt32; target1: DummyEnum; fill1: UInt32; target2: DummyEnum; fill2: UInt32; target3: DummyEnum; fill3: UInt32)>(z_PresentFrameDualFillNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PresentFrameDualFillNV(video_slot: UInt32; minPresentTime: UInt64; beginPresentTimeId: UInt32; presentDurationId: UInt32; &type: DummyEnum; target0: DummyEnum; fill0: UInt32; target1: DummyEnum; fill1: UInt32; target2: DummyEnum; fill2: UInt32; target3: DummyEnum; fill3: UInt32) :=
    z_PresentFrameDualFillNV_1(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, &type, target0, fill0, target1, fill1, target2, fill2, target3, fill3);
    
    private z_GetVideoivNV_adr := GetProcAddress('glGetVideoivNV');
    private z_GetVideoivNV_1 := GetProcOrNil&<procedure(video_slot: UInt32; pname: DummyEnum; &params: IntPtr)>(z_GetVideoivNV_adr);
    private z_GetVideoivNV_2 := GetProcOrNil&<procedure(video_slot: UInt32; pname: DummyEnum; var &params: Int32)>(z_GetVideoivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoivNV(video_slot: UInt32; pname: DummyEnum; var &params: Int32) :=
    z_GetVideoivNV_2(video_slot, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoivNV(video_slot: UInt32; pname: DummyEnum; &params: IntPtr) :=
    z_GetVideoivNV_1(video_slot, pname, &params);
    
    private z_GetVideouivNV_adr := GetProcAddress('glGetVideouivNV');
    private z_GetVideouivNV_1 := GetProcOrNil&<procedure(video_slot: UInt32; pname: DummyEnum; &params: IntPtr)>(z_GetVideouivNV_adr);
    private z_GetVideouivNV_2 := GetProcOrNil&<procedure(video_slot: UInt32; pname: DummyEnum; var &params: UInt32)>(z_GetVideouivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideouivNV(video_slot: UInt32; pname: DummyEnum; var &params: UInt32) :=
    z_GetVideouivNV_2(video_slot, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideouivNV(video_slot: UInt32; pname: DummyEnum; &params: IntPtr) :=
    z_GetVideouivNV_1(video_slot, pname, &params);
    
    private z_GetVideoi64vNV_adr := GetProcAddress('glGetVideoi64vNV');
    private z_GetVideoi64vNV_1 := GetProcOrNil&<procedure(video_slot: UInt32; pname: DummyEnum; &params: IntPtr)>(z_GetVideoi64vNV_adr);
    private z_GetVideoi64vNV_2 := GetProcOrNil&<procedure(video_slot: UInt32; pname: DummyEnum; var &params: Int64)>(z_GetVideoi64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoi64vNV(video_slot: UInt32; pname: DummyEnum; var &params: Int64) :=
    z_GetVideoi64vNV_2(video_slot, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoi64vNV(video_slot: UInt32; pname: DummyEnum; &params: IntPtr) :=
    z_GetVideoi64vNV_1(video_slot, pname, &params);
    
    private z_GetVideoui64vNV_adr := GetProcAddress('glGetVideoui64vNV');
    private z_GetVideoui64vNV_1 := GetProcOrNil&<procedure(video_slot: UInt32; pname: DummyEnum; &params: IntPtr)>(z_GetVideoui64vNV_adr);
    private z_GetVideoui64vNV_2 := GetProcOrNil&<procedure(video_slot: UInt32; pname: DummyEnum; var &params: UInt64)>(z_GetVideoui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoui64vNV(video_slot: UInt32; pname: DummyEnum; var &params: UInt64) :=
    z_GetVideoui64vNV_2(video_slot, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoui64vNV(video_slot: UInt32; pname: DummyEnum; &params: IntPtr) :=
    z_GetVideoui64vNV_1(video_slot, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glPrimitiveRestartNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_primitive_restart';
    
    private z_PrimitiveRestartNV_adr := GetProcAddress('glPrimitiveRestartNV');
    private z_PrimitiveRestartNV_1 := GetProcOrNil&<procedure>(z_PrimitiveRestartNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrimitiveRestartNV :=
    z_PrimitiveRestartNV_1();
    
    private z_PrimitiveRestartIndexNV_adr := GetProcAddress('glPrimitiveRestartIndexNV');
    private z_PrimitiveRestartIndexNV_1 := GetProcOrNil&<procedure(index: UInt32)>(z_PrimitiveRestartIndexNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrimitiveRestartIndexNV(index: UInt32) :=
    z_PrimitiveRestartIndexNV_1(index);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glQueryResourceNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_query_resource';
    
    private z_QueryResourceNV_adr := GetProcAddress('glQueryResourceNV');
    private z_QueryResourceNV_1 := GetProcOrNil&<function(queryType: DummyEnum; tagId: Int32; count: UInt32; buffer: IntPtr): Int32>(z_QueryResourceNV_adr);
    private z_QueryResourceNV_2 := GetProcOrNil&<function(queryType: DummyEnum; tagId: Int32; count: UInt32; var buffer: Int32): Int32>(z_QueryResourceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryResourceNV(queryType: DummyEnum; tagId: Int32; count: UInt32; buffer: array of Int32): Int32;
    type PInt32=^Int32;
    begin
      Result := if (buffer<>nil) and (buffer.Length<>0) then
        z_QueryResourceNV_2(queryType, tagId, count, buffer[0]) else
        z_QueryResourceNV_2(queryType, tagId, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryResourceNV(queryType: DummyEnum; tagId: Int32; count: UInt32; var buffer: Int32): Int32 :=
    z_QueryResourceNV_2(queryType, tagId, count, buffer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryResourceNV(queryType: DummyEnum; tagId: Int32; count: UInt32; buffer: IntPtr): Int32 :=
    z_QueryResourceNV_1(queryType, tagId, count, buffer);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glQueryResourceTagNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_query_resource_tag';
    
    private z_GenQueryResourceTagNV_adr := GetProcAddress('glGenQueryResourceTagNV');
    private z_GenQueryResourceTagNV_1 := GetProcOrNil&<procedure(n: Int32; tagIds: IntPtr)>(z_GenQueryResourceTagNV_adr);
    private z_GenQueryResourceTagNV_2 := GetProcOrNil&<procedure(n: Int32; var tagIds: Int32)>(z_GenQueryResourceTagNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenQueryResourceTagNV(n: Int32; tagIds: array of Int32);
    type PInt32=^Int32;
    begin
      if (tagIds<>nil) and (tagIds.Length<>0) then
        z_GenQueryResourceTagNV_2(n, tagIds[0]) else
        z_GenQueryResourceTagNV_2(n, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenQueryResourceTagNV(n: Int32; var tagIds: Int32) :=
    z_GenQueryResourceTagNV_2(n, tagIds);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenQueryResourceTagNV(n: Int32; tagIds: IntPtr) :=
    z_GenQueryResourceTagNV_1(n, tagIds);
    
    private z_DeleteQueryResourceTagNV_adr := GetProcAddress('glDeleteQueryResourceTagNV');
    private z_DeleteQueryResourceTagNV_1 := GetProcOrNil&<procedure(n: Int32; tagIds: IntPtr)>(z_DeleteQueryResourceTagNV_adr);
    private z_DeleteQueryResourceTagNV_2 := GetProcOrNil&<procedure(n: Int32; var tagIds: Int32)>(z_DeleteQueryResourceTagNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteQueryResourceTagNV(n: Int32; tagIds: array of Int32);
    type PInt32=^Int32;
    begin
      if (tagIds<>nil) and (tagIds.Length<>0) then
        z_DeleteQueryResourceTagNV_2(n, tagIds[0]) else
        z_DeleteQueryResourceTagNV_2(n, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteQueryResourceTagNV(n: Int32; var tagIds: Int32) :=
    z_DeleteQueryResourceTagNV_2(n, tagIds);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteQueryResourceTagNV(n: Int32; tagIds: IntPtr) :=
    z_DeleteQueryResourceTagNV_1(n, tagIds);
    
    private z_QueryResourceTagNV_adr := GetProcAddress('glQueryResourceTagNV');
    private z_QueryResourceTagNV_1 := GetProcOrNil&<procedure(tagId: Int32; tagString: IntPtr)>(z_QueryResourceTagNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure QueryResourceTagNV(tagId: Int32; tagString: string);
    begin
      var tagString_str_ptr: IntPtr;
      try
        tagString_str_ptr := Marshal.StringToHGlobalAnsi(tagString);
        z_QueryResourceTagNV_1(tagId, tagString_str_ptr);
      finally
        Marshal.FreeHGlobal(tagString_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure QueryResourceTagNV(tagId: Int32; tagString: IntPtr) :=
    z_QueryResourceTagNV_1(tagId, tagString);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glRegisterCombinersNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_register_combiners';
    
    private z_CombinerParameterfvNV_adr := GetProcAddress('glCombinerParameterfvNV');
    private z_CombinerParameterfvNV_1 := GetProcOrNil&<procedure(pname: CombinerParameter; &params: IntPtr)>(z_CombinerParameterfvNV_adr);
    private z_CombinerParameterfvNV_2 := GetProcOrNil&<procedure(pname: CombinerParameter; var &params: single)>(z_CombinerParameterfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerParameterfvNV(pname: CombinerParameter; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_CombinerParameterfvNV_2(pname, &params[0]) else
        z_CombinerParameterfvNV_2(pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerParameterfvNV(pname: CombinerParameter; var &params: single) :=
    z_CombinerParameterfvNV_2(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerParameterfvNV(pname: CombinerParameter; &params: IntPtr) :=
    z_CombinerParameterfvNV_1(pname, &params);
    
    private z_CombinerParameterfNV_adr := GetProcAddress('glCombinerParameterfNV');
    private z_CombinerParameterfNV_1 := GetProcOrNil&<procedure(pname: CombinerParameter; param: single)>(z_CombinerParameterfNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerParameterfNV(pname: CombinerParameter; param: single) :=
    z_CombinerParameterfNV_1(pname, param);
    
    private z_CombinerParameterivNV_adr := GetProcAddress('glCombinerParameterivNV');
    private z_CombinerParameterivNV_1 := GetProcOrNil&<procedure(pname: CombinerParameter; &params: IntPtr)>(z_CombinerParameterivNV_adr);
    private z_CombinerParameterivNV_2 := GetProcOrNil&<procedure(pname: CombinerParameter; var &params: Int32)>(z_CombinerParameterivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerParameterivNV(pname: CombinerParameter; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_CombinerParameterivNV_2(pname, &params[0]) else
        z_CombinerParameterivNV_2(pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerParameterivNV(pname: CombinerParameter; var &params: Int32) :=
    z_CombinerParameterivNV_2(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerParameterivNV(pname: CombinerParameter; &params: IntPtr) :=
    z_CombinerParameterivNV_1(pname, &params);
    
    private z_CombinerParameteriNV_adr := GetProcAddress('glCombinerParameteriNV');
    private z_CombinerParameteriNV_1 := GetProcOrNil&<procedure(pname: CombinerParameter; param: Int32)>(z_CombinerParameteriNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerParameteriNV(pname: CombinerParameter; param: Int32) :=
    z_CombinerParameteriNV_1(pname, param);
    
    private z_CombinerInputNV_adr := GetProcAddress('glCombinerInputNV');
    private z_CombinerInputNV_1 := GetProcOrNil&<procedure(stage: CombinerStage; portion: CombinerPortion; variable: CombinerVariable; input: CombinerRegister; mapping: CombinerMapping; componentUsage: CombinerComponentUsage)>(z_CombinerInputNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerInputNV(stage: CombinerStage; portion: CombinerPortion; variable: CombinerVariable; input: CombinerRegister; mapping: CombinerMapping; componentUsage: CombinerComponentUsage) :=
    z_CombinerInputNV_1(stage, portion, variable, input, mapping, componentUsage);
    
    private z_CombinerOutputNV_adr := GetProcAddress('glCombinerOutputNV');
    private z_CombinerOutputNV_1 := GetProcOrNil&<procedure(stage: CombinerStage; portion: CombinerPortion; abOutput: CombinerRegister; cdOutput: CombinerRegister; sumOutput: CombinerRegister; scale: CombinerScale; bias: CombinerBias; abDotProduct: boolean; cdDotProduct: boolean; muxSum: boolean)>(z_CombinerOutputNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerOutputNV(stage: CombinerStage; portion: CombinerPortion; abOutput: CombinerRegister; cdOutput: CombinerRegister; sumOutput: CombinerRegister; scale: CombinerScale; bias: CombinerBias; abDotProduct: boolean; cdDotProduct: boolean; muxSum: boolean) :=
    z_CombinerOutputNV_1(stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum);
    
    private z_FinalCombinerInputNV_adr := GetProcAddress('glFinalCombinerInputNV');
    private z_FinalCombinerInputNV_1 := GetProcOrNil&<procedure(variable: CombinerVariable; input: CombinerRegister; mapping: CombinerMapping; componentUsage: CombinerComponentUsage)>(z_FinalCombinerInputNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FinalCombinerInputNV(variable: CombinerVariable; input: CombinerRegister; mapping: CombinerMapping; componentUsage: CombinerComponentUsage) :=
    z_FinalCombinerInputNV_1(variable, input, mapping, componentUsage);
    
    private z_GetCombinerInputParameterfvNV_adr := GetProcAddress('glGetCombinerInputParameterfvNV');
    private z_GetCombinerInputParameterfvNV_1 := GetProcOrNil&<procedure(stage: CombinerStage; portion: CombinerPortion; variable: CombinerVariable; pname: CombinerParameter; &params: IntPtr)>(z_GetCombinerInputParameterfvNV_adr);
    private z_GetCombinerInputParameterfvNV_2 := GetProcOrNil&<procedure(stage: CombinerStage; portion: CombinerPortion; variable: CombinerVariable; pname: CombinerParameter; var &params: single)>(z_GetCombinerInputParameterfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerInputParameterfvNV(stage: CombinerStage; portion: CombinerPortion; variable: CombinerVariable; pname: CombinerParameter; var &params: single) :=
    z_GetCombinerInputParameterfvNV_2(stage, portion, variable, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerInputParameterfvNV(stage: CombinerStage; portion: CombinerPortion; variable: CombinerVariable; pname: CombinerParameter; &params: IntPtr) :=
    z_GetCombinerInputParameterfvNV_1(stage, portion, variable, pname, &params);
    
    private z_GetCombinerInputParameterivNV_adr := GetProcAddress('glGetCombinerInputParameterivNV');
    private z_GetCombinerInputParameterivNV_1 := GetProcOrNil&<procedure(stage: CombinerStage; portion: CombinerPortion; variable: CombinerVariable; pname: CombinerParameter; &params: IntPtr)>(z_GetCombinerInputParameterivNV_adr);
    private z_GetCombinerInputParameterivNV_2 := GetProcOrNil&<procedure(stage: CombinerStage; portion: CombinerPortion; variable: CombinerVariable; pname: CombinerParameter; var &params: Int32)>(z_GetCombinerInputParameterivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerInputParameterivNV(stage: CombinerStage; portion: CombinerPortion; variable: CombinerVariable; pname: CombinerParameter; var &params: Int32) :=
    z_GetCombinerInputParameterivNV_2(stage, portion, variable, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerInputParameterivNV(stage: CombinerStage; portion: CombinerPortion; variable: CombinerVariable; pname: CombinerParameter; &params: IntPtr) :=
    z_GetCombinerInputParameterivNV_1(stage, portion, variable, pname, &params);
    
    private z_GetCombinerOutputParameterfvNV_adr := GetProcAddress('glGetCombinerOutputParameterfvNV');
    private z_GetCombinerOutputParameterfvNV_1 := GetProcOrNil&<procedure(stage: CombinerStage; portion: CombinerPortion; pname: CombinerParameter; &params: IntPtr)>(z_GetCombinerOutputParameterfvNV_adr);
    private z_GetCombinerOutputParameterfvNV_2 := GetProcOrNil&<procedure(stage: CombinerStage; portion: CombinerPortion; pname: CombinerParameter; var &params: single)>(z_GetCombinerOutputParameterfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerOutputParameterfvNV(stage: CombinerStage; portion: CombinerPortion; pname: CombinerParameter; var &params: single) :=
    z_GetCombinerOutputParameterfvNV_2(stage, portion, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerOutputParameterfvNV(stage: CombinerStage; portion: CombinerPortion; pname: CombinerParameter; &params: IntPtr) :=
    z_GetCombinerOutputParameterfvNV_1(stage, portion, pname, &params);
    
    private z_GetCombinerOutputParameterivNV_adr := GetProcAddress('glGetCombinerOutputParameterivNV');
    private z_GetCombinerOutputParameterivNV_1 := GetProcOrNil&<procedure(stage: CombinerStage; portion: CombinerPortion; pname: CombinerParameter; &params: IntPtr)>(z_GetCombinerOutputParameterivNV_adr);
    private z_GetCombinerOutputParameterivNV_2 := GetProcOrNil&<procedure(stage: CombinerStage; portion: CombinerPortion; pname: CombinerParameter; var &params: Int32)>(z_GetCombinerOutputParameterivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerOutputParameterivNV(stage: CombinerStage; portion: CombinerPortion; pname: CombinerParameter; var &params: Int32) :=
    z_GetCombinerOutputParameterivNV_2(stage, portion, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerOutputParameterivNV(stage: CombinerStage; portion: CombinerPortion; pname: CombinerParameter; &params: IntPtr) :=
    z_GetCombinerOutputParameterivNV_1(stage, portion, pname, &params);
    
    private z_GetFinalCombinerInputParameterfvNV_adr := GetProcAddress('glGetFinalCombinerInputParameterfvNV');
    private z_GetFinalCombinerInputParameterfvNV_1 := GetProcOrNil&<procedure(variable: CombinerVariable; pname: CombinerParameter; &params: IntPtr)>(z_GetFinalCombinerInputParameterfvNV_adr);
    private z_GetFinalCombinerInputParameterfvNV_2 := GetProcOrNil&<procedure(variable: CombinerVariable; pname: CombinerParameter; var &params: single)>(z_GetFinalCombinerInputParameterfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFinalCombinerInputParameterfvNV(variable: CombinerVariable; pname: CombinerParameter; var &params: single) :=
    z_GetFinalCombinerInputParameterfvNV_2(variable, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFinalCombinerInputParameterfvNV(variable: CombinerVariable; pname: CombinerParameter; &params: IntPtr) :=
    z_GetFinalCombinerInputParameterfvNV_1(variable, pname, &params);
    
    private z_GetFinalCombinerInputParameterivNV_adr := GetProcAddress('glGetFinalCombinerInputParameterivNV');
    private z_GetFinalCombinerInputParameterivNV_1 := GetProcOrNil&<procedure(variable: CombinerVariable; pname: CombinerParameter; &params: IntPtr)>(z_GetFinalCombinerInputParameterivNV_adr);
    private z_GetFinalCombinerInputParameterivNV_2 := GetProcOrNil&<procedure(variable: CombinerVariable; pname: CombinerParameter; var &params: Int32)>(z_GetFinalCombinerInputParameterivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFinalCombinerInputParameterivNV(variable: CombinerVariable; pname: CombinerParameter; var &params: Int32) :=
    z_GetFinalCombinerInputParameterivNV_2(variable, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFinalCombinerInputParameterivNV(variable: CombinerVariable; pname: CombinerParameter; &params: IntPtr) :=
    z_GetFinalCombinerInputParameterivNV_1(variable, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glRegisterCombiners2NV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_register_combiners2';
    
    private z_CombinerStageParameterfvNV_adr := GetProcAddress('glCombinerStageParameterfvNV');
    private z_CombinerStageParameterfvNV_1 := GetProcOrNil&<procedure(stage: CombinerStage; pname: CombinerParameter; &params: IntPtr)>(z_CombinerStageParameterfvNV_adr);
    private z_CombinerStageParameterfvNV_2 := GetProcOrNil&<procedure(stage: CombinerStage; pname: CombinerParameter; var &params: single)>(z_CombinerStageParameterfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerStageParameterfvNV(stage: CombinerStage; pname: CombinerParameter; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_CombinerStageParameterfvNV_2(stage, pname, &params[0]) else
        z_CombinerStageParameterfvNV_2(stage, pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerStageParameterfvNV(stage: CombinerStage; pname: CombinerParameter; var &params: single) :=
    z_CombinerStageParameterfvNV_2(stage, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerStageParameterfvNV(stage: CombinerStage; pname: CombinerParameter; &params: IntPtr) :=
    z_CombinerStageParameterfvNV_1(stage, pname, &params);
    
    private z_GetCombinerStageParameterfvNV_adr := GetProcAddress('glGetCombinerStageParameterfvNV');
    private z_GetCombinerStageParameterfvNV_1 := GetProcOrNil&<procedure(stage: CombinerStage; pname: CombinerParameter; &params: IntPtr)>(z_GetCombinerStageParameterfvNV_adr);
    private z_GetCombinerStageParameterfvNV_2 := GetProcOrNil&<procedure(stage: CombinerStage; pname: CombinerParameter; var &params: single)>(z_GetCombinerStageParameterfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerStageParameterfvNV(stage: CombinerStage; pname: CombinerParameter; var &params: single) :=
    z_GetCombinerStageParameterfvNV_2(stage, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerStageParameterfvNV(stage: CombinerStage; pname: CombinerParameter; &params: IntPtr) :=
    z_GetCombinerStageParameterfvNV_1(stage, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glSampleLocationsNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_sample_locations';
    
    private z_FramebufferSampleLocationsfvNV_adr := GetProcAddress('glFramebufferSampleLocationsfvNV');
    private z_FramebufferSampleLocationsfvNV_1 := GetProcOrNil&<procedure(target: FramebufferTarget; start: UInt32; count: Int32; v: IntPtr)>(z_FramebufferSampleLocationsfvNV_adr);
    private z_FramebufferSampleLocationsfvNV_2 := GetProcOrNil&<procedure(target: FramebufferTarget; start: UInt32; count: Int32; var v: single)>(z_FramebufferSampleLocationsfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferSampleLocationsfvNV(target: FramebufferTarget; start: UInt32; count: Int32; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_FramebufferSampleLocationsfvNV_2(target, start, count, v[0]) else
        z_FramebufferSampleLocationsfvNV_2(target, start, count, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferSampleLocationsfvNV(target: FramebufferTarget; start: UInt32; count: Int32; var v: single) :=
    z_FramebufferSampleLocationsfvNV_2(target, start, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferSampleLocationsfvNV(target: FramebufferTarget; start: UInt32; count: Int32; v: IntPtr) :=
    z_FramebufferSampleLocationsfvNV_1(target, start, count, v);
    
    private z_NamedFramebufferSampleLocationsfvNV_adr := GetProcAddress('glNamedFramebufferSampleLocationsfvNV');
    private z_NamedFramebufferSampleLocationsfvNV_1 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; start: UInt32; count: Int32; v: IntPtr)>(z_NamedFramebufferSampleLocationsfvNV_adr);
    private z_NamedFramebufferSampleLocationsfvNV_2 := GetProcOrNil&<procedure(framebuffer: gl_framebuffer; start: UInt32; count: Int32; var v: single)>(z_NamedFramebufferSampleLocationsfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferSampleLocationsfvNV(framebuffer: gl_framebuffer; start: UInt32; count: Int32; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_NamedFramebufferSampleLocationsfvNV_2(framebuffer, start, count, v[0]) else
        z_NamedFramebufferSampleLocationsfvNV_2(framebuffer, start, count, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferSampleLocationsfvNV(framebuffer: gl_framebuffer; start: UInt32; count: Int32; var v: single) :=
    z_NamedFramebufferSampleLocationsfvNV_2(framebuffer, start, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferSampleLocationsfvNV(framebuffer: gl_framebuffer; start: UInt32; count: Int32; v: IntPtr) :=
    z_NamedFramebufferSampleLocationsfvNV_1(framebuffer, start, count, v);
    
    private z_ResolveDepthValuesNV_adr := GetProcAddress('glResolveDepthValuesNV');
    private z_ResolveDepthValuesNV_1 := GetProcOrNil&<procedure>(z_ResolveDepthValuesNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ResolveDepthValuesNV :=
    z_ResolveDepthValuesNV_1();
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glScissorExclusiveNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_scissor_exclusive';
    
    private z_ScissorExclusiveNV_adr := GetProcAddress('glScissorExclusiveNV');
    private z_ScissorExclusiveNV_1 := GetProcOrNil&<procedure(x: Int32; y: Int32; width: Int32; height: Int32)>(z_ScissorExclusiveNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorExclusiveNV(x: Int32; y: Int32; width: Int32; height: Int32) :=
    z_ScissorExclusiveNV_1(x, y, width, height);
    
    private z_ScissorExclusiveArrayvNV_adr := GetProcAddress('glScissorExclusiveArrayvNV');
    private z_ScissorExclusiveArrayvNV_1 := GetProcOrNil&<procedure(first: UInt32; count: Int32; v: IntPtr)>(z_ScissorExclusiveArrayvNV_adr);
    private z_ScissorExclusiveArrayvNV_2 := GetProcOrNil&<procedure(first: UInt32; count: Int32; var v: Int32)>(z_ScissorExclusiveArrayvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorExclusiveArrayvNV(first: UInt32; count: Int32; v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_ScissorExclusiveArrayvNV_2(first, count, v[0]) else
        z_ScissorExclusiveArrayvNV_2(first, count, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorExclusiveArrayvNV(first: UInt32; count: Int32; var v: Int32) :=
    z_ScissorExclusiveArrayvNV_2(first, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorExclusiveArrayvNV(first: UInt32; count: Int32; v: IntPtr) :=
    z_ScissorExclusiveArrayvNV_1(first, count, v);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glShaderBufferLoadNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_shader_buffer_load';
    
    private z_MakeBufferResidentNV_adr := GetProcAddress('glMakeBufferResidentNV');
    private z_MakeBufferResidentNV_1 := GetProcOrNil&<procedure(target: DummyEnum; access: DummyEnum)>(z_MakeBufferResidentNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeBufferResidentNV(target: DummyEnum; access: DummyEnum) :=
    z_MakeBufferResidentNV_1(target, access);
    
    private z_MakeBufferNonResidentNV_adr := GetProcAddress('glMakeBufferNonResidentNV');
    private z_MakeBufferNonResidentNV_1 := GetProcOrNil&<procedure(target: DummyEnum)>(z_MakeBufferNonResidentNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeBufferNonResidentNV(target: DummyEnum) :=
    z_MakeBufferNonResidentNV_1(target);
    
    private z_IsBufferResidentNV_adr := GetProcAddress('glIsBufferResidentNV');
    private z_IsBufferResidentNV_1 := GetProcOrNil&<function(target: DummyEnum): boolean>(z_IsBufferResidentNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsBufferResidentNV(target: DummyEnum): boolean :=
    z_IsBufferResidentNV_1(target);
    
    private z_MakeNamedBufferResidentNV_adr := GetProcAddress('glMakeNamedBufferResidentNV');
    private z_MakeNamedBufferResidentNV_1 := GetProcOrNil&<procedure(buffer: gl_buffer; access: DummyEnum)>(z_MakeNamedBufferResidentNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeNamedBufferResidentNV(buffer: gl_buffer; access: DummyEnum) :=
    z_MakeNamedBufferResidentNV_1(buffer, access);
    
    private z_MakeNamedBufferNonResidentNV_adr := GetProcAddress('glMakeNamedBufferNonResidentNV');
    private z_MakeNamedBufferNonResidentNV_1 := GetProcOrNil&<procedure(buffer: gl_buffer)>(z_MakeNamedBufferNonResidentNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeNamedBufferNonResidentNV(buffer: gl_buffer) :=
    z_MakeNamedBufferNonResidentNV_1(buffer);
    
    private z_IsNamedBufferResidentNV_adr := GetProcAddress('glIsNamedBufferResidentNV');
    private z_IsNamedBufferResidentNV_1 := GetProcOrNil&<function(buffer: gl_buffer): boolean>(z_IsNamedBufferResidentNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsNamedBufferResidentNV(buffer: gl_buffer): boolean :=
    z_IsNamedBufferResidentNV_1(buffer);
    
    private z_GetBufferParameterui64vNV_adr := GetProcAddress('glGetBufferParameterui64vNV');
    private z_GetBufferParameterui64vNV_1 := GetProcOrNil&<procedure(target: BufferTarget; pname: DummyEnum; &params: IntPtr)>(z_GetBufferParameterui64vNV_adr);
    private z_GetBufferParameterui64vNV_2 := GetProcOrNil&<procedure(target: BufferTarget; pname: DummyEnum; var &params: UInt64)>(z_GetBufferParameterui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferParameterui64vNV(target: BufferTarget; pname: DummyEnum; var &params: UInt64) :=
    z_GetBufferParameterui64vNV_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferParameterui64vNV(target: BufferTarget; pname: DummyEnum; &params: IntPtr) :=
    z_GetBufferParameterui64vNV_1(target, pname, &params);
    
    private z_GetNamedBufferParameterui64vNV_adr := GetProcAddress('glGetNamedBufferParameterui64vNV');
    private z_GetNamedBufferParameterui64vNV_1 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: BufferPName; &params: IntPtr)>(z_GetNamedBufferParameterui64vNV_adr);
    private z_GetNamedBufferParameterui64vNV_2 := GetProcOrNil&<procedure(buffer: gl_buffer; pname: BufferPName; var &params: UInt64)>(z_GetNamedBufferParameterui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameterui64vNV(buffer: gl_buffer; pname: BufferPName; var &params: UInt64) :=
    z_GetNamedBufferParameterui64vNV_2(buffer, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameterui64vNV(buffer: gl_buffer; pname: BufferPName; &params: IntPtr) :=
    z_GetNamedBufferParameterui64vNV_1(buffer, pname, &params);
    
    private z_GetIntegerui64vNV_adr := GetProcAddress('glGetIntegerui64vNV');
    private z_GetIntegerui64vNV_1 := GetProcOrNil&<procedure(value: DummyEnum; result: IntPtr)>(z_GetIntegerui64vNV_adr);
    private z_GetIntegerui64vNV_2 := GetProcOrNil&<procedure(value: DummyEnum; var result: UInt64)>(z_GetIntegerui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerui64vNV(value: DummyEnum; var result: UInt64) :=
    z_GetIntegerui64vNV_2(value, result);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerui64vNV(value: DummyEnum; result: IntPtr) :=
    z_GetIntegerui64vNV_1(value, result);
    
    private z_Uniformui64NV_adr := GetProcAddress('glUniformui64NV');
    private z_Uniformui64NV_1 := GetProcOrNil&<procedure(location: Int32; value: UInt64)>(z_Uniformui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniformui64NV(location: Int32; value: UInt64) :=
    z_Uniformui64NV_1(location, value);
    
    private z_Uniformui64vNV_adr := GetProcAddress('glUniformui64vNV');
    private z_Uniformui64vNV_1 := GetProcOrNil&<procedure(location: Int32; count: Int32; value: IntPtr)>(z_Uniformui64vNV_adr);
    private z_Uniformui64vNV_2 := GetProcOrNil&<procedure(location: Int32; count: Int32; var value: UInt64)>(z_Uniformui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniformui64vNV(location: Int32; count: Int32; value: array of UInt64);
    type PUInt64=^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_Uniformui64vNV_2(location, count, value[0]) else
        z_Uniformui64vNV_2(location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniformui64vNV(location: Int32; count: Int32; var value: UInt64) :=
    z_Uniformui64vNV_2(location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniformui64vNV(location: Int32; count: Int32; value: IntPtr) :=
    z_Uniformui64vNV_1(location, count, value);
    
    private z_GetUniformui64vNV_adr := GetProcAddress('glGetUniformui64vNV');
    private z_GetUniformui64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; &params: IntPtr)>(z_GetUniformui64vNV_adr);
    private z_GetUniformui64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; var &params: UInt64)>(z_GetUniformui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformui64vNV(&program: gl_program; location: Int32; var &params: UInt64) :=
    z_GetUniformui64vNV_2(&program, location, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformui64vNV(&program: gl_program; location: Int32; &params: IntPtr) :=
    z_GetUniformui64vNV_1(&program, location, &params);
    
    private z_ProgramUniformui64NV_adr := GetProcAddress('glProgramUniformui64NV');
    private z_ProgramUniformui64NV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; value: UInt64)>(z_ProgramUniformui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformui64NV(&program: gl_program; location: Int32; value: UInt64) :=
    z_ProgramUniformui64NV_1(&program, location, value);
    
    private z_ProgramUniformui64vNV_adr := GetProcAddress('glProgramUniformui64vNV');
    private z_ProgramUniformui64vNV_1 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; value: IntPtr)>(z_ProgramUniformui64vNV_adr);
    private z_ProgramUniformui64vNV_2 := GetProcOrNil&<procedure(&program: gl_program; location: Int32; count: Int32; var value: UInt64)>(z_ProgramUniformui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformui64vNV(&program: gl_program; location: Int32; count: Int32; value: array of UInt64);
    type PUInt64=^UInt64;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_ProgramUniformui64vNV_2(&program, location, count, value[0]) else
        z_ProgramUniformui64vNV_2(&program, location, count, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformui64vNV(&program: gl_program; location: Int32; count: Int32; var value: UInt64) :=
    z_ProgramUniformui64vNV_2(&program, location, count, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformui64vNV(&program: gl_program; location: Int32; count: Int32; value: IntPtr) :=
    z_ProgramUniformui64vNV_1(&program, location, count, value);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glShadingRateImageNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_shading_rate_image';
    
    private z_BindShadingRateImageNV_adr := GetProcAddress('glBindShadingRateImageNV');
    private z_BindShadingRateImageNV_1 := GetProcOrNil&<procedure(texture: gl_texture)>(z_BindShadingRateImageNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindShadingRateImageNV(texture: gl_texture) :=
    z_BindShadingRateImageNV_1(texture);
    
    private z_GetShadingRateImagePaletteNV_adr := GetProcAddress('glGetShadingRateImagePaletteNV');
    private z_GetShadingRateImagePaletteNV_1 := GetProcOrNil&<procedure(viewport: UInt32; entry: UInt32; rate: IntPtr)>(z_GetShadingRateImagePaletteNV_adr);
    private z_GetShadingRateImagePaletteNV_2 := GetProcOrNil&<procedure(viewport: UInt32; entry: UInt32; var rate: DummyEnum)>(z_GetShadingRateImagePaletteNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShadingRateImagePaletteNV(viewport: UInt32; entry: UInt32; var rate: DummyEnum) :=
    z_GetShadingRateImagePaletteNV_2(viewport, entry, rate);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShadingRateImagePaletteNV(viewport: UInt32; entry: UInt32; rate: IntPtr) :=
    z_GetShadingRateImagePaletteNV_1(viewport, entry, rate);
    
    private z_GetShadingRateSampleLocationivNV_adr := GetProcAddress('glGetShadingRateSampleLocationivNV');
    private z_GetShadingRateSampleLocationivNV_1 := GetProcOrNil&<procedure(rate: DummyEnum; samples: UInt32; index: UInt32; location: IntPtr)>(z_GetShadingRateSampleLocationivNV_adr);
    private z_GetShadingRateSampleLocationivNV_2 := GetProcOrNil&<procedure(rate: DummyEnum; samples: UInt32; index: UInt32; var location: Int32)>(z_GetShadingRateSampleLocationivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShadingRateSampleLocationivNV(rate: DummyEnum; samples: UInt32; index: UInt32; var location: Int32) :=
    z_GetShadingRateSampleLocationivNV_2(rate, samples, index, location);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShadingRateSampleLocationivNV(rate: DummyEnum; samples: UInt32; index: UInt32; location: IntPtr) :=
    z_GetShadingRateSampleLocationivNV_1(rate, samples, index, location);
    
    private z_ShadingRateImageBarrierNV_adr := GetProcAddress('glShadingRateImageBarrierNV');
    private z_ShadingRateImageBarrierNV_1 := GetProcOrNil&<procedure(synchronize: boolean)>(z_ShadingRateImageBarrierNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShadingRateImageBarrierNV(synchronize: boolean) :=
    z_ShadingRateImageBarrierNV_1(synchronize);
    
    private z_ShadingRateImagePaletteNV_adr := GetProcAddress('glShadingRateImagePaletteNV');
    private z_ShadingRateImagePaletteNV_1 := GetProcOrNil&<procedure(viewport: UInt32; first: UInt32; count: Int32; rates: IntPtr)>(z_ShadingRateImagePaletteNV_adr);
    private z_ShadingRateImagePaletteNV_2 := GetProcOrNil&<procedure(viewport: UInt32; first: UInt32; count: Int32; var rates: DummyEnum)>(z_ShadingRateImagePaletteNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShadingRateImagePaletteNV(viewport: UInt32; first: UInt32; count: Int32; rates: array of DummyEnum);
    type PDummyEnum=^DummyEnum;
    begin
      if (rates<>nil) and (rates.Length<>0) then
        z_ShadingRateImagePaletteNV_2(viewport, first, count, rates[0]) else
        z_ShadingRateImagePaletteNV_2(viewport, first, count, PDummyEnum(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShadingRateImagePaletteNV(viewport: UInt32; first: UInt32; count: Int32; var rates: DummyEnum) :=
    z_ShadingRateImagePaletteNV_2(viewport, first, count, rates);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShadingRateImagePaletteNV(viewport: UInt32; first: UInt32; count: Int32; rates: IntPtr) :=
    z_ShadingRateImagePaletteNV_1(viewport, first, count, rates);
    
    private z_ShadingRateSampleOrderNV_adr := GetProcAddress('glShadingRateSampleOrderNV');
    private z_ShadingRateSampleOrderNV_1 := GetProcOrNil&<procedure(order: DummyEnum)>(z_ShadingRateSampleOrderNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShadingRateSampleOrderNV(order: DummyEnum) :=
    z_ShadingRateSampleOrderNV_1(order);
    
    private z_ShadingRateSampleOrderCustomNV_adr := GetProcAddress('glShadingRateSampleOrderCustomNV');
    private z_ShadingRateSampleOrderCustomNV_1 := GetProcOrNil&<procedure(rate: DummyEnum; samples: UInt32; locations: IntPtr)>(z_ShadingRateSampleOrderCustomNV_adr);
    private z_ShadingRateSampleOrderCustomNV_2 := GetProcOrNil&<procedure(rate: DummyEnum; samples: UInt32; var locations: Int32)>(z_ShadingRateSampleOrderCustomNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShadingRateSampleOrderCustomNV(rate: DummyEnum; samples: UInt32; locations: array of Int32);
    type PInt32=^Int32;
    begin
      if (locations<>nil) and (locations.Length<>0) then
        z_ShadingRateSampleOrderCustomNV_2(rate, samples, locations[0]) else
        z_ShadingRateSampleOrderCustomNV_2(rate, samples, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShadingRateSampleOrderCustomNV(rate: DummyEnum; samples: UInt32; var locations: Int32) :=
    z_ShadingRateSampleOrderCustomNV_2(rate, samples, locations);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShadingRateSampleOrderCustomNV(rate: DummyEnum; samples: UInt32; locations: IntPtr) :=
    z_ShadingRateSampleOrderCustomNV_1(rate, samples, locations);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glTextureBarrierNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_texture_barrier';
    
    private z_TextureBarrierNV_adr := GetProcAddress('glTextureBarrierNV');
    private z_TextureBarrierNV_1 := GetProcOrNil&<procedure>(z_TextureBarrierNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureBarrierNV :=
    z_TextureBarrierNV_1();
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glTextureMultisampleNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_texture_multisample';
    
    private z_TexImage2DMultisampleCoverageNV_adr := GetProcAddress('glTexImage2DMultisampleCoverageNV');
    private z_TexImage2DMultisampleCoverageNV_1 := GetProcOrNil&<procedure(target: TextureTarget; coverageSamples: Int32; colorSamples: Int32; _internalFormat: InternalFormat; width: Int32; height: Int32; fixedSampleLocations: boolean)>(z_TexImage2DMultisampleCoverageNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage2DMultisampleCoverageNV(target: TextureTarget; coverageSamples: Int32; colorSamples: Int32; _internalFormat: InternalFormat; width: Int32; height: Int32; fixedSampleLocations: boolean) :=
    z_TexImage2DMultisampleCoverageNV_1(target, coverageSamples, colorSamples, _internalFormat, width, height, fixedSampleLocations);
    
    private z_TexImage3DMultisampleCoverageNV_adr := GetProcAddress('glTexImage3DMultisampleCoverageNV');
    private z_TexImage3DMultisampleCoverageNV_1 := GetProcOrNil&<procedure(target: TextureTarget; coverageSamples: Int32; colorSamples: Int32; _internalFormat: InternalFormat; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: boolean)>(z_TexImage3DMultisampleCoverageNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage3DMultisampleCoverageNV(target: TextureTarget; coverageSamples: Int32; colorSamples: Int32; _internalFormat: InternalFormat; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: boolean) :=
    z_TexImage3DMultisampleCoverageNV_1(target, coverageSamples, colorSamples, _internalFormat, width, height, depth, fixedSampleLocations);
    
    private z_TextureImage2DMultisampleNV_adr := GetProcAddress('glTextureImage2DMultisampleNV');
    private z_TextureImage2DMultisampleNV_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; samples: Int32; _internalFormat: InternalFormat; width: Int32; height: Int32; fixedSampleLocations: boolean)>(z_TextureImage2DMultisampleNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureImage2DMultisampleNV(texture: gl_texture; target: TextureTarget; samples: Int32; _internalFormat: InternalFormat; width: Int32; height: Int32; fixedSampleLocations: boolean) :=
    z_TextureImage2DMultisampleNV_1(texture, target, samples, _internalFormat, width, height, fixedSampleLocations);
    
    private z_TextureImage3DMultisampleNV_adr := GetProcAddress('glTextureImage3DMultisampleNV');
    private z_TextureImage3DMultisampleNV_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; samples: Int32; _internalFormat: InternalFormat; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: boolean)>(z_TextureImage3DMultisampleNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureImage3DMultisampleNV(texture: gl_texture; target: TextureTarget; samples: Int32; _internalFormat: InternalFormat; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: boolean) :=
    z_TextureImage3DMultisampleNV_1(texture, target, samples, _internalFormat, width, height, depth, fixedSampleLocations);
    
    private z_TextureImage2DMultisampleCoverageNV_adr := GetProcAddress('glTextureImage2DMultisampleCoverageNV');
    private z_TextureImage2DMultisampleCoverageNV_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; coverageSamples: Int32; colorSamples: Int32; _internalFormat: InternalFormat; width: Int32; height: Int32; fixedSampleLocations: boolean)>(z_TextureImage2DMultisampleCoverageNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureImage2DMultisampleCoverageNV(texture: gl_texture; target: TextureTarget; coverageSamples: Int32; colorSamples: Int32; _internalFormat: InternalFormat; width: Int32; height: Int32; fixedSampleLocations: boolean) :=
    z_TextureImage2DMultisampleCoverageNV_1(texture, target, coverageSamples, colorSamples, _internalFormat, width, height, fixedSampleLocations);
    
    private z_TextureImage3DMultisampleCoverageNV_adr := GetProcAddress('glTextureImage3DMultisampleCoverageNV');
    private z_TextureImage3DMultisampleCoverageNV_1 := GetProcOrNil&<procedure(texture: gl_texture; target: TextureTarget; coverageSamples: Int32; colorSamples: Int32; _internalFormat: InternalFormat; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: boolean)>(z_TextureImage3DMultisampleCoverageNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureImage3DMultisampleCoverageNV(texture: gl_texture; target: TextureTarget; coverageSamples: Int32; colorSamples: Int32; _internalFormat: InternalFormat; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: boolean) :=
    z_TextureImage3DMultisampleCoverageNV_1(texture, target, coverageSamples, colorSamples, _internalFormat, width, height, depth, fixedSampleLocations);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glTransformFeedbackNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_transform_feedback';
    
    private z_BeginTransformFeedbackNV_adr := GetProcAddress('glBeginTransformFeedbackNV');
    private z_BeginTransformFeedbackNV_1 := GetProcOrNil&<procedure(primitiveMode: PrimitiveType)>(z_BeginTransformFeedbackNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginTransformFeedbackNV(primitiveMode: PrimitiveType) :=
    z_BeginTransformFeedbackNV_1(primitiveMode);
    
    private z_EndTransformFeedbackNV_adr := GetProcAddress('glEndTransformFeedbackNV');
    private z_EndTransformFeedbackNV_1 := GetProcOrNil&<procedure>(z_EndTransformFeedbackNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndTransformFeedbackNV :=
    z_EndTransformFeedbackNV_1();
    
    private z_TransformFeedbackAttribsNV_adr := GetProcAddress('glTransformFeedbackAttribsNV');
    private z_TransformFeedbackAttribsNV_1 := GetProcOrNil&<procedure(count: Int32; attribs: IntPtr; bufferMode: DummyEnum)>(z_TransformFeedbackAttribsNV_adr);
    private z_TransformFeedbackAttribsNV_2 := GetProcOrNil&<procedure(count: Int32; var attribs: Int32; bufferMode: DummyEnum)>(z_TransformFeedbackAttribsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackAttribsNV(count: Int32; attribs: array of Int32; bufferMode: DummyEnum);
    type PInt32=^Int32;
    begin
      if (attribs<>nil) and (attribs.Length<>0) then
        z_TransformFeedbackAttribsNV_2(count, attribs[0], bufferMode) else
        z_TransformFeedbackAttribsNV_2(count, PInt32(nil)^, bufferMode);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackAttribsNV(count: Int32; var attribs: Int32; bufferMode: DummyEnum) :=
    z_TransformFeedbackAttribsNV_2(count, attribs, bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackAttribsNV(count: Int32; attribs: IntPtr; bufferMode: DummyEnum) :=
    z_TransformFeedbackAttribsNV_1(count, attribs, bufferMode);
    
    private z_BindBufferRangeNV_adr := GetProcAddress('glBindBufferRangeNV');
    private z_BindBufferRangeNV_1 := GetProcOrNil&<procedure(target: BufferTarget; index: UInt32; buffer: gl_buffer; offset: IntPtr; size: UIntPtr)>(z_BindBufferRangeNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBufferRangeNV(target: BufferTarget; index: UInt32; buffer: gl_buffer; offset: IntPtr; size: UIntPtr) :=
    z_BindBufferRangeNV_1(target, index, buffer, offset, size);
    
    private z_BindBufferOffsetNV_adr := GetProcAddress('glBindBufferOffsetNV');
    private z_BindBufferOffsetNV_1 := GetProcOrNil&<procedure(target: BufferTarget; index: UInt32; buffer: gl_buffer; offset: IntPtr)>(z_BindBufferOffsetNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBufferOffsetNV(target: BufferTarget; index: UInt32; buffer: gl_buffer; offset: IntPtr) :=
    z_BindBufferOffsetNV_1(target, index, buffer, offset);
    
    private z_BindBufferBaseNV_adr := GetProcAddress('glBindBufferBaseNV');
    private z_BindBufferBaseNV_1 := GetProcOrNil&<procedure(target: BufferTarget; index: UInt32; buffer: gl_buffer)>(z_BindBufferBaseNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBufferBaseNV(target: BufferTarget; index: UInt32; buffer: gl_buffer) :=
    z_BindBufferBaseNV_1(target, index, buffer);
    
    private z_TransformFeedbackVaryingsNV_adr := GetProcAddress('glTransformFeedbackVaryingsNV');
    private z_TransformFeedbackVaryingsNV_1 := GetProcOrNil&<procedure(&program: gl_program; count: Int32; locations: IntPtr; bufferMode: TransformFeedbackBufferMode)>(z_TransformFeedbackVaryingsNV_adr);
    private z_TransformFeedbackVaryingsNV_2 := GetProcOrNil&<procedure(&program: gl_program; count: Int32; var locations: TransformFeedbackToken; bufferMode: TransformFeedbackBufferMode)>(z_TransformFeedbackVaryingsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackVaryingsNV(&program: gl_program; count: Int32; locations: array of TransformFeedbackToken; bufferMode: TransformFeedbackBufferMode);
    type PTransformFeedbackToken=^TransformFeedbackToken;
    begin
      if (locations<>nil) and (locations.Length<>0) then
        z_TransformFeedbackVaryingsNV_2(&program, count, locations[0], bufferMode) else
        z_TransformFeedbackVaryingsNV_2(&program, count, PTransformFeedbackToken(nil)^, bufferMode);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackVaryingsNV(&program: gl_program; count: Int32; var locations: TransformFeedbackToken; bufferMode: TransformFeedbackBufferMode) :=
    z_TransformFeedbackVaryingsNV_2(&program, count, locations, bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackVaryingsNV(&program: gl_program; count: Int32; locations: IntPtr; bufferMode: TransformFeedbackBufferMode) :=
    z_TransformFeedbackVaryingsNV_1(&program, count, locations, bufferMode);
    
    private z_ActiveVaryingNV_adr := GetProcAddress('glActiveVaryingNV');
    private z_ActiveVaryingNV_1 := GetProcOrNil&<procedure(&program: gl_program; name: IntPtr)>(z_ActiveVaryingNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ActiveVaryingNV(&program: gl_program; name: string);
    begin
      var name_str_ptr: IntPtr;
      try
        name_str_ptr := Marshal.StringToHGlobalAnsi(name);
        z_ActiveVaryingNV_1(&program, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ActiveVaryingNV(&program: gl_program; name: IntPtr) :=
    z_ActiveVaryingNV_1(&program, name);
    
    private z_GetVaryingLocationNV_adr := GetProcAddress('glGetVaryingLocationNV');
    private z_GetVaryingLocationNV_1 := GetProcOrNil&<function(&program: gl_program; name: IntPtr): Int32>(z_GetVaryingLocationNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVaryingLocationNV(&program: gl_program; name: string): Int32;
    begin
      var name_str_ptr: IntPtr;
      try
        name_str_ptr := Marshal.StringToHGlobalAnsi(name);
        Result := z_GetVaryingLocationNV_1(&program, name_str_ptr);
      finally
        Marshal.FreeHGlobal(name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVaryingLocationNV(&program: gl_program; name: IntPtr): Int32 :=
    z_GetVaryingLocationNV_1(&program, name);
    
    private z_GetActiveVaryingNV_adr := GetProcAddress('glGetActiveVaryingNV');
    private z_GetActiveVaryingNV_1 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; &type: IntPtr; name: IntPtr)>(z_GetActiveVaryingNV_adr);
    private z_GetActiveVaryingNV_2 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; var &type: DummyEnum; name: IntPtr)>(z_GetActiveVaryingNV_adr);
    private z_GetActiveVaryingNV_3 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; &type: IntPtr; name: IntPtr)>(z_GetActiveVaryingNV_adr);
    private z_GetActiveVaryingNV_4 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; var &type: DummyEnum; name: IntPtr)>(z_GetActiveVaryingNV_adr);
    private z_GetActiveVaryingNV_5 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; &type: IntPtr; name: IntPtr)>(z_GetActiveVaryingNV_adr);
    private z_GetActiveVaryingNV_6 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; var &type: DummyEnum; name: IntPtr)>(z_GetActiveVaryingNV_adr);
    private z_GetActiveVaryingNV_7 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: IntPtr; name: IntPtr)>(z_GetActiveVaryingNV_adr);
    private z_GetActiveVaryingNV_8 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: DummyEnum; name: IntPtr)>(z_GetActiveVaryingNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: DummyEnum; name: IntPtr) :=
    z_GetActiveVaryingNV_8(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: IntPtr; name: IntPtr) :=
    z_GetActiveVaryingNV_7(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; var &type: DummyEnum; name: IntPtr) :=
    z_GetActiveVaryingNV_6(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: gl_program; index: UInt32; bufSize: Int32; var length: Int32; size: IntPtr; &type: IntPtr; name: IntPtr) :=
    z_GetActiveVaryingNV_5(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; var &type: DummyEnum; name: IntPtr) :=
    z_GetActiveVaryingNV_4(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; var size: Int32; &type: IntPtr; name: IntPtr) :=
    z_GetActiveVaryingNV_3(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; var &type: DummyEnum; name: IntPtr) :=
    z_GetActiveVaryingNV_2(&program, index, bufSize, length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: gl_program; index: UInt32; bufSize: Int32; length: IntPtr; size: IntPtr; &type: IntPtr; name: IntPtr) :=
    z_GetActiveVaryingNV_1(&program, index, bufSize, length, size, &type, name);
    
    private z_GetTransformFeedbackVaryingNV_adr := GetProcAddress('glGetTransformFeedbackVaryingNV');
    private z_GetTransformFeedbackVaryingNV_1 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; location: IntPtr)>(z_GetTransformFeedbackVaryingNV_adr);
    private z_GetTransformFeedbackVaryingNV_2 := GetProcOrNil&<procedure(&program: gl_program; index: UInt32; var location: Int32)>(z_GetTransformFeedbackVaryingNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingNV(&program: gl_program; index: UInt32; var location: Int32) :=
    z_GetTransformFeedbackVaryingNV_2(&program, index, location);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingNV(&program: gl_program; index: UInt32; location: IntPtr) :=
    z_GetTransformFeedbackVaryingNV_1(&program, index, location);
    
    private z_TransformFeedbackStreamAttribsNV_adr := GetProcAddress('glTransformFeedbackStreamAttribsNV');
    private z_TransformFeedbackStreamAttribsNV_1 := GetProcOrNil&<procedure(count: Int32; attribs: IntPtr; nbuffers: Int32; bufstreams: IntPtr; bufferMode: DummyEnum)>(z_TransformFeedbackStreamAttribsNV_adr);
    private z_TransformFeedbackStreamAttribsNV_2 := GetProcOrNil&<procedure(count: Int32; attribs: IntPtr; nbuffers: Int32; var bufstreams: Int32; bufferMode: DummyEnum)>(z_TransformFeedbackStreamAttribsNV_adr);
    private z_TransformFeedbackStreamAttribsNV_3 := GetProcOrNil&<procedure(count: Int32; var attribs: Int32; nbuffers: Int32; bufstreams: IntPtr; bufferMode: DummyEnum)>(z_TransformFeedbackStreamAttribsNV_adr);
    private z_TransformFeedbackStreamAttribsNV_4 := GetProcOrNil&<procedure(count: Int32; var attribs: Int32; nbuffers: Int32; var bufstreams: Int32; bufferMode: DummyEnum)>(z_TransformFeedbackStreamAttribsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackStreamAttribsNV(count: Int32; attribs: array of Int32; nbuffers: Int32; bufstreams: array of Int32; bufferMode: DummyEnum);
    type PInt32=^Int32;
    begin
      if (bufstreams<>nil) and (bufstreams.Length<>0) then
        if (attribs<>nil) and (attribs.Length<>0) then
          z_TransformFeedbackStreamAttribsNV_4(count, attribs[0], nbuffers, bufstreams[0], bufferMode) else
          z_TransformFeedbackStreamAttribsNV_4(count, PInt32(nil)^, nbuffers, bufstreams[0], bufferMode) else
        if (attribs<>nil) and (attribs.Length<>0) then
          z_TransformFeedbackStreamAttribsNV_4(count, attribs[0], nbuffers, PInt32(nil)^, bufferMode) else
          z_TransformFeedbackStreamAttribsNV_4(count, PInt32(nil)^, nbuffers, PInt32(nil)^, bufferMode);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackStreamAttribsNV(count: Int32; var attribs: Int32; nbuffers: Int32; var bufstreams: Int32; bufferMode: DummyEnum) :=
    z_TransformFeedbackStreamAttribsNV_4(count, attribs, nbuffers, bufstreams, bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackStreamAttribsNV(count: Int32; var attribs: Int32; nbuffers: Int32; bufstreams: IntPtr; bufferMode: DummyEnum) :=
    z_TransformFeedbackStreamAttribsNV_3(count, attribs, nbuffers, bufstreams, bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackStreamAttribsNV(count: Int32; attribs: IntPtr; nbuffers: Int32; var bufstreams: Int32; bufferMode: DummyEnum) :=
    z_TransformFeedbackStreamAttribsNV_2(count, attribs, nbuffers, bufstreams, bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackStreamAttribsNV(count: Int32; attribs: IntPtr; nbuffers: Int32; bufstreams: IntPtr; bufferMode: DummyEnum) :=
    z_TransformFeedbackStreamAttribsNV_1(count, attribs, nbuffers, bufstreams, bufferMode);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glTransformFeedback2NV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_transform_feedback2';
    
    private z_BindTransformFeedbackNV_adr := GetProcAddress('glBindTransformFeedbackNV');
    private z_BindTransformFeedbackNV_1 := GetProcOrNil&<procedure(target: BufferTarget; id: gl_transform_feedback)>(z_BindTransformFeedbackNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTransformFeedbackNV(target: BufferTarget; id: gl_transform_feedback) :=
    z_BindTransformFeedbackNV_1(target, id);
    
    private z_DeleteTransformFeedbacksNV_adr := GetProcAddress('glDeleteTransformFeedbacksNV');
    private z_DeleteTransformFeedbacksNV_1 := GetProcOrNil&<procedure(n: Int32; ids: IntPtr)>(z_DeleteTransformFeedbacksNV_adr);
    private z_DeleteTransformFeedbacksNV_2 := GetProcOrNil&<procedure(n: Int32; var ids: gl_transform_feedback)>(z_DeleteTransformFeedbacksNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTransformFeedbacksNV(n: Int32; ids: array of gl_transform_feedback);
    type Pgl_transform_feedback=^gl_transform_feedback;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        z_DeleteTransformFeedbacksNV_2(n, ids[0]) else
        z_DeleteTransformFeedbacksNV_2(n, Pgl_transform_feedback(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTransformFeedbacksNV(n: Int32; var ids: gl_transform_feedback) :=
    z_DeleteTransformFeedbacksNV_2(n, ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTransformFeedbacksNV(n: Int32; ids: IntPtr) :=
    z_DeleteTransformFeedbacksNV_1(n, ids);
    
    private z_GenTransformFeedbacksNV_adr := GetProcAddress('glGenTransformFeedbacksNV');
    private z_GenTransformFeedbacksNV_1 := GetProcOrNil&<procedure(n: Int32; ids: IntPtr)>(z_GenTransformFeedbacksNV_adr);
    private z_GenTransformFeedbacksNV_2 := GetProcOrNil&<procedure(n: Int32; var ids: gl_transform_feedback)>(z_GenTransformFeedbacksNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTransformFeedbacksNV(n: Int32; ids: array of gl_transform_feedback);
    type Pgl_transform_feedback=^gl_transform_feedback;
    begin
      if (ids<>nil) and (ids.Length<>0) then
        z_GenTransformFeedbacksNV_2(n, ids[0]) else
        z_GenTransformFeedbacksNV_2(n, Pgl_transform_feedback(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTransformFeedbacksNV(n: Int32; var ids: gl_transform_feedback) :=
    z_GenTransformFeedbacksNV_2(n, ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTransformFeedbacksNV(n: Int32; ids: IntPtr) :=
    z_GenTransformFeedbacksNV_1(n, ids);
    
    private z_IsTransformFeedbackNV_adr := GetProcAddress('glIsTransformFeedbackNV');
    private z_IsTransformFeedbackNV_1 := GetProcOrNil&<function(id: gl_transform_feedback): boolean>(z_IsTransformFeedbackNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsTransformFeedbackNV(id: gl_transform_feedback): boolean :=
    z_IsTransformFeedbackNV_1(id);
    
    private z_PauseTransformFeedbackNV_adr := GetProcAddress('glPauseTransformFeedbackNV');
    private z_PauseTransformFeedbackNV_1 := GetProcOrNil&<procedure>(z_PauseTransformFeedbackNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PauseTransformFeedbackNV :=
    z_PauseTransformFeedbackNV_1();
    
    private z_ResumeTransformFeedbackNV_adr := GetProcAddress('glResumeTransformFeedbackNV');
    private z_ResumeTransformFeedbackNV_1 := GetProcOrNil&<procedure>(z_ResumeTransformFeedbackNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ResumeTransformFeedbackNV :=
    z_ResumeTransformFeedbackNV_1();
    
    private z_DrawTransformFeedbackNV_adr := GetProcAddress('glDrawTransformFeedbackNV');
    private z_DrawTransformFeedbackNV_1 := GetProcOrNil&<procedure(mode: PrimitiveType; id: gl_transform_feedback)>(z_DrawTransformFeedbackNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTransformFeedbackNV(mode: PrimitiveType; id: gl_transform_feedback) :=
    z_DrawTransformFeedbackNV_1(mode, id);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glVdpauInteropNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_vdpau_interop';
    
    private z_VDPAUInitNV_adr := GetProcAddress('glVDPAUInitNV');
    private z_VDPAUInitNV_1 := GetProcOrNil&<procedure(vdpDevice: IntPtr; getProcAddress: IntPtr)>(z_VDPAUInitNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUInitNV(vdpDevice: IntPtr; getProcAddress: IntPtr) :=
    z_VDPAUInitNV_1(vdpDevice, getProcAddress);
    
    private z_VDPAUFiniNV_adr := GetProcAddress('glVDPAUFiniNV');
    private z_VDPAUFiniNV_1 := GetProcOrNil&<procedure>(z_VDPAUFiniNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUFiniNV :=
    z_VDPAUFiniNV_1();
    
    private z_VDPAURegisterVideoSurfaceNV_adr := GetProcAddress('glVDPAURegisterVideoSurfaceNV');
    private z_VDPAURegisterVideoSurfaceNV_1 := GetProcOrNil&<function(vdpSurface: IntPtr; target: DummyEnum; numTextureNames: Int32; textureNames: IntPtr): gl_vdpau_surface_NV>(z_VDPAURegisterVideoSurfaceNV_adr);
    private z_VDPAURegisterVideoSurfaceNV_2 := GetProcOrNil&<function(vdpSurface: IntPtr; target: DummyEnum; numTextureNames: Int32; var textureNames: UInt32): gl_vdpau_surface_NV>(z_VDPAURegisterVideoSurfaceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAURegisterVideoSurfaceNV(vdpSurface: IntPtr; target: DummyEnum; numTextureNames: Int32; textureNames: array of UInt32): gl_vdpau_surface_NV;
    type PUInt32=^UInt32;
    begin
      Result := if (textureNames<>nil) and (textureNames.Length<>0) then
        z_VDPAURegisterVideoSurfaceNV_2(vdpSurface, target, numTextureNames, textureNames[0]) else
        z_VDPAURegisterVideoSurfaceNV_2(vdpSurface, target, numTextureNames, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAURegisterVideoSurfaceNV(vdpSurface: IntPtr; target: DummyEnum; numTextureNames: Int32; var textureNames: UInt32): gl_vdpau_surface_NV :=
    z_VDPAURegisterVideoSurfaceNV_2(vdpSurface, target, numTextureNames, textureNames);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAURegisterVideoSurfaceNV(vdpSurface: IntPtr; target: DummyEnum; numTextureNames: Int32; textureNames: IntPtr): gl_vdpau_surface_NV :=
    z_VDPAURegisterVideoSurfaceNV_1(vdpSurface, target, numTextureNames, textureNames);
    
    private z_VDPAURegisterOutputSurfaceNV_adr := GetProcAddress('glVDPAURegisterOutputSurfaceNV');
    private z_VDPAURegisterOutputSurfaceNV_1 := GetProcOrNil&<function(vdpSurface: IntPtr; target: DummyEnum; numTextureNames: Int32; textureNames: IntPtr): gl_vdpau_surface_NV>(z_VDPAURegisterOutputSurfaceNV_adr);
    private z_VDPAURegisterOutputSurfaceNV_2 := GetProcOrNil&<function(vdpSurface: IntPtr; target: DummyEnum; numTextureNames: Int32; var textureNames: UInt32): gl_vdpau_surface_NV>(z_VDPAURegisterOutputSurfaceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAURegisterOutputSurfaceNV(vdpSurface: IntPtr; target: DummyEnum; numTextureNames: Int32; textureNames: array of UInt32): gl_vdpau_surface_NV;
    type PUInt32=^UInt32;
    begin
      Result := if (textureNames<>nil) and (textureNames.Length<>0) then
        z_VDPAURegisterOutputSurfaceNV_2(vdpSurface, target, numTextureNames, textureNames[0]) else
        z_VDPAURegisterOutputSurfaceNV_2(vdpSurface, target, numTextureNames, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAURegisterOutputSurfaceNV(vdpSurface: IntPtr; target: DummyEnum; numTextureNames: Int32; var textureNames: UInt32): gl_vdpau_surface_NV :=
    z_VDPAURegisterOutputSurfaceNV_2(vdpSurface, target, numTextureNames, textureNames);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAURegisterOutputSurfaceNV(vdpSurface: IntPtr; target: DummyEnum; numTextureNames: Int32; textureNames: IntPtr): gl_vdpau_surface_NV :=
    z_VDPAURegisterOutputSurfaceNV_1(vdpSurface, target, numTextureNames, textureNames);
    
    private z_VDPAUIsSurfaceNV_adr := GetProcAddress('glVDPAUIsSurfaceNV');
    private z_VDPAUIsSurfaceNV_1 := GetProcOrNil&<function(surface: gl_vdpau_surface_NV): boolean>(z_VDPAUIsSurfaceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAUIsSurfaceNV(surface: gl_vdpau_surface_NV): boolean :=
    z_VDPAUIsSurfaceNV_1(surface);
    
    private z_VDPAUUnregisterSurfaceNV_adr := GetProcAddress('glVDPAUUnregisterSurfaceNV');
    private z_VDPAUUnregisterSurfaceNV_1 := GetProcOrNil&<procedure(surface: gl_vdpau_surface_NV)>(z_VDPAUUnregisterSurfaceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUUnregisterSurfaceNV(surface: gl_vdpau_surface_NV) :=
    z_VDPAUUnregisterSurfaceNV_1(surface);
    
    private z_VDPAUGetSurfaceivNV_adr := GetProcAddress('glVDPAUGetSurfaceivNV');
    private z_VDPAUGetSurfaceivNV_1 := GetProcOrNil&<procedure(surface: gl_vdpau_surface_NV; pname: DummyEnum; count: Int32; length: IntPtr; values: IntPtr)>(z_VDPAUGetSurfaceivNV_adr);
    private z_VDPAUGetSurfaceivNV_2 := GetProcOrNil&<procedure(surface: gl_vdpau_surface_NV; pname: DummyEnum; count: Int32; length: IntPtr; var values: Int32)>(z_VDPAUGetSurfaceivNV_adr);
    private z_VDPAUGetSurfaceivNV_3 := GetProcOrNil&<procedure(surface: gl_vdpau_surface_NV; pname: DummyEnum; count: Int32; var length: Int32; values: IntPtr)>(z_VDPAUGetSurfaceivNV_adr);
    private z_VDPAUGetSurfaceivNV_4 := GetProcOrNil&<procedure(surface: gl_vdpau_surface_NV; pname: DummyEnum; count: Int32; var length: Int32; var values: Int32)>(z_VDPAUGetSurfaceivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUGetSurfaceivNV(surface: gl_vdpau_surface_NV; pname: DummyEnum; count: Int32; var length: Int32; var values: Int32) :=
    z_VDPAUGetSurfaceivNV_4(surface, pname, count, length, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUGetSurfaceivNV(surface: gl_vdpau_surface_NV; pname: DummyEnum; count: Int32; var length: Int32; values: IntPtr) :=
    z_VDPAUGetSurfaceivNV_3(surface, pname, count, length, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUGetSurfaceivNV(surface: gl_vdpau_surface_NV; pname: DummyEnum; count: Int32; length: IntPtr; var values: Int32) :=
    z_VDPAUGetSurfaceivNV_2(surface, pname, count, length, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUGetSurfaceivNV(surface: gl_vdpau_surface_NV; pname: DummyEnum; count: Int32; length: IntPtr; values: IntPtr) :=
    z_VDPAUGetSurfaceivNV_1(surface, pname, count, length, values);
    
    private z_VDPAUSurfaceAccessNV_adr := GetProcAddress('glVDPAUSurfaceAccessNV');
    private z_VDPAUSurfaceAccessNV_1 := GetProcOrNil&<procedure(surface: gl_vdpau_surface_NV; access: DummyEnum)>(z_VDPAUSurfaceAccessNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUSurfaceAccessNV(surface: gl_vdpau_surface_NV; access: DummyEnum) :=
    z_VDPAUSurfaceAccessNV_1(surface, access);
    
    private z_VDPAUMapSurfacesNV_adr := GetProcAddress('glVDPAUMapSurfacesNV');
    private z_VDPAUMapSurfacesNV_1 := GetProcOrNil&<procedure(numSurfaces: Int32; surfaces: IntPtr)>(z_VDPAUMapSurfacesNV_adr);
    private z_VDPAUMapSurfacesNV_2 := GetProcOrNil&<procedure(numSurfaces: Int32; var surfaces: gl_vdpau_surface_NV)>(z_VDPAUMapSurfacesNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUMapSurfacesNV(numSurfaces: Int32; surfaces: array of gl_vdpau_surface_NV);
    type Pgl_vdpau_surface_NV=^gl_vdpau_surface_NV;
    begin
      if (surfaces<>nil) and (surfaces.Length<>0) then
        z_VDPAUMapSurfacesNV_2(numSurfaces, surfaces[0]) else
        z_VDPAUMapSurfacesNV_2(numSurfaces, Pgl_vdpau_surface_NV(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUMapSurfacesNV(numSurfaces: Int32; var surfaces: gl_vdpau_surface_NV) :=
    z_VDPAUMapSurfacesNV_2(numSurfaces, surfaces);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUMapSurfacesNV(numSurfaces: Int32; surfaces: IntPtr) :=
    z_VDPAUMapSurfacesNV_1(numSurfaces, surfaces);
    
    private z_VDPAUUnmapSurfacesNV_adr := GetProcAddress('glVDPAUUnmapSurfacesNV');
    private z_VDPAUUnmapSurfacesNV_1 := GetProcOrNil&<procedure(numSurface: Int32; surfaces: IntPtr)>(z_VDPAUUnmapSurfacesNV_adr);
    private z_VDPAUUnmapSurfacesNV_2 := GetProcOrNil&<procedure(numSurface: Int32; var surfaces: gl_vdpau_surface_NV)>(z_VDPAUUnmapSurfacesNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUUnmapSurfacesNV(numSurface: Int32; surfaces: array of gl_vdpau_surface_NV);
    type Pgl_vdpau_surface_NV=^gl_vdpau_surface_NV;
    begin
      if (surfaces<>nil) and (surfaces.Length<>0) then
        z_VDPAUUnmapSurfacesNV_2(numSurface, surfaces[0]) else
        z_VDPAUUnmapSurfacesNV_2(numSurface, Pgl_vdpau_surface_NV(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUUnmapSurfacesNV(numSurface: Int32; var surfaces: gl_vdpau_surface_NV) :=
    z_VDPAUUnmapSurfacesNV_2(numSurface, surfaces);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUUnmapSurfacesNV(numSurface: Int32; surfaces: IntPtr) :=
    z_VDPAUUnmapSurfacesNV_1(numSurface, surfaces);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glVdpauInterop2NV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_vdpau_interop2';
    
    private z_VDPAURegisterVideoSurfaceWithPictureStructureNV_adr := GetProcAddress('glVDPAURegisterVideoSurfaceWithPictureStructureNV');
    private z_VDPAURegisterVideoSurfaceWithPictureStructureNV_1 := GetProcOrNil&<function(vdpSurface: IntPtr; target: DummyEnum; numTextureNames: Int32; textureNames: IntPtr; isFrameStructure: boolean): gl_vdpau_surface_NV>(z_VDPAURegisterVideoSurfaceWithPictureStructureNV_adr);
    private z_VDPAURegisterVideoSurfaceWithPictureStructureNV_2 := GetProcOrNil&<function(vdpSurface: IntPtr; target: DummyEnum; numTextureNames: Int32; var textureNames: UInt32; isFrameStructure: boolean): gl_vdpau_surface_NV>(z_VDPAURegisterVideoSurfaceWithPictureStructureNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAURegisterVideoSurfaceWithPictureStructureNV(vdpSurface: IntPtr; target: DummyEnum; numTextureNames: Int32; textureNames: array of UInt32; isFrameStructure: boolean): gl_vdpau_surface_NV;
    type PUInt32=^UInt32;
    begin
      Result := if (textureNames<>nil) and (textureNames.Length<>0) then
        z_VDPAURegisterVideoSurfaceWithPictureStructureNV_2(vdpSurface, target, numTextureNames, textureNames[0], isFrameStructure) else
        z_VDPAURegisterVideoSurfaceWithPictureStructureNV_2(vdpSurface, target, numTextureNames, PUInt32(nil)^, isFrameStructure);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAURegisterVideoSurfaceWithPictureStructureNV(vdpSurface: IntPtr; target: DummyEnum; numTextureNames: Int32; var textureNames: UInt32; isFrameStructure: boolean): gl_vdpau_surface_NV :=
    z_VDPAURegisterVideoSurfaceWithPictureStructureNV_2(vdpSurface, target, numTextureNames, textureNames, isFrameStructure);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAURegisterVideoSurfaceWithPictureStructureNV(vdpSurface: IntPtr; target: DummyEnum; numTextureNames: Int32; textureNames: IntPtr; isFrameStructure: boolean): gl_vdpau_surface_NV :=
    z_VDPAURegisterVideoSurfaceWithPictureStructureNV_1(vdpSurface, target, numTextureNames, textureNames, isFrameStructure);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glVertexArrayRangeNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_vertex_array_range';
    
    private z_FlushVertexArrayRangeNV_adr := GetProcAddress('glFlushVertexArrayRangeNV');
    private z_FlushVertexArrayRangeNV_1 := GetProcOrNil&<procedure>(z_FlushVertexArrayRangeNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FlushVertexArrayRangeNV :=
    z_FlushVertexArrayRangeNV_1();
    
    private z_VertexArrayRangeNV_adr := GetProcAddress('glVertexArrayRangeNV');
    private z_VertexArrayRangeNV_1 := GetProcOrNil&<procedure(length: Int32; pointer: IntPtr)>(z_VertexArrayRangeNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayRangeNV(length: Int32; pointer: IntPtr) :=
    z_VertexArrayRangeNV_1(length, pointer);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glVertexAttribInteger64bitNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_vertex_attrib_integer_64bit';
    
    private z_VertexAttribL1i64NV_adr := GetProcAddress('glVertexAttribL1i64NV');
    private z_VertexAttribL1i64NV_1 := GetProcOrNil&<procedure(index: UInt32; x: Int64)>(z_VertexAttribL1i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1i64NV(index: UInt32; x: Int64) :=
    z_VertexAttribL1i64NV_1(index, x);
    
    private z_VertexAttribL2i64NV_adr := GetProcAddress('glVertexAttribL2i64NV');
    private z_VertexAttribL2i64NV_1 := GetProcOrNil&<procedure(index: UInt32; x: Int64; y: Int64)>(z_VertexAttribL2i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2i64NV(index: UInt32; x: Int64; y: Int64) :=
    z_VertexAttribL2i64NV_1(index, x, y);
    
    private z_VertexAttribL3i64NV_adr := GetProcAddress('glVertexAttribL3i64NV');
    private z_VertexAttribL3i64NV_1 := GetProcOrNil&<procedure(index: UInt32; x: Int64; y: Int64; z: Int64)>(z_VertexAttribL3i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3i64NV(index: UInt32; x: Int64; y: Int64; z: Int64) :=
    z_VertexAttribL3i64NV_1(index, x, y, z);
    
    private z_VertexAttribL4i64NV_adr := GetProcAddress('glVertexAttribL4i64NV');
    private z_VertexAttribL4i64NV_1 := GetProcOrNil&<procedure(index: UInt32; x: Int64; y: Int64; z: Int64; w: Int64)>(z_VertexAttribL4i64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4i64NV(index: UInt32; x: Int64; y: Int64; z: Int64; w: Int64) :=
    z_VertexAttribL4i64NV_1(index, x, y, z, w);
    
    private z_VertexAttribL1i64vNV_adr := GetProcAddress('glVertexAttribL1i64vNV');
    private z_VertexAttribL1i64vNV_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribL1i64vNV_adr);
    private z_VertexAttribL1i64vNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int64)>(z_VertexAttribL1i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1i64vNV(index: UInt32; v: array of Int64);
    type PInt64=^Int64;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribL1i64vNV_2(index, v[0]) else
        z_VertexAttribL1i64vNV_2(index, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1i64vNV(index: UInt32; var v: Int64) :=
    z_VertexAttribL1i64vNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1i64vNV(index: UInt32; v: IntPtr) :=
    z_VertexAttribL1i64vNV_1(index, v);
    
    private z_VertexAttribL2i64vNV_adr := GetProcAddress('glVertexAttribL2i64vNV');
    private z_VertexAttribL2i64vNV_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribL2i64vNV_adr);
    private z_VertexAttribL2i64vNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int64)>(z_VertexAttribL2i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2i64vNV(index: UInt32; v: array of Int64);
    type PInt64=^Int64;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribL2i64vNV_2(index, v[0]) else
        z_VertexAttribL2i64vNV_2(index, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2i64vNV(index: UInt32; var v: Int64) :=
    z_VertexAttribL2i64vNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2i64vNV(index: UInt32; v: IntPtr) :=
    z_VertexAttribL2i64vNV_1(index, v);
    
    private z_VertexAttribL3i64vNV_adr := GetProcAddress('glVertexAttribL3i64vNV');
    private z_VertexAttribL3i64vNV_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribL3i64vNV_adr);
    private z_VertexAttribL3i64vNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int64)>(z_VertexAttribL3i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3i64vNV(index: UInt32; v: array of Int64);
    type PInt64=^Int64;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribL3i64vNV_2(index, v[0]) else
        z_VertexAttribL3i64vNV_2(index, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3i64vNV(index: UInt32; var v: Int64) :=
    z_VertexAttribL3i64vNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3i64vNV(index: UInt32; v: IntPtr) :=
    z_VertexAttribL3i64vNV_1(index, v);
    
    private z_VertexAttribL4i64vNV_adr := GetProcAddress('glVertexAttribL4i64vNV');
    private z_VertexAttribL4i64vNV_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribL4i64vNV_adr);
    private z_VertexAttribL4i64vNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int64)>(z_VertexAttribL4i64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4i64vNV(index: UInt32; v: array of Int64);
    type PInt64=^Int64;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribL4i64vNV_2(index, v[0]) else
        z_VertexAttribL4i64vNV_2(index, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4i64vNV(index: UInt32; var v: Int64) :=
    z_VertexAttribL4i64vNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4i64vNV(index: UInt32; v: IntPtr) :=
    z_VertexAttribL4i64vNV_1(index, v);
    
    private z_VertexAttribL1ui64NV_adr := GetProcAddress('glVertexAttribL1ui64NV');
    private z_VertexAttribL1ui64NV_1 := GetProcOrNil&<procedure(index: UInt32; x: UInt64)>(z_VertexAttribL1ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1ui64NV(index: UInt32; x: UInt64) :=
    z_VertexAttribL1ui64NV_1(index, x);
    
    private z_VertexAttribL2ui64NV_adr := GetProcAddress('glVertexAttribL2ui64NV');
    private z_VertexAttribL2ui64NV_1 := GetProcOrNil&<procedure(index: UInt32; x: UInt64; y: UInt64)>(z_VertexAttribL2ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2ui64NV(index: UInt32; x: UInt64; y: UInt64) :=
    z_VertexAttribL2ui64NV_1(index, x, y);
    
    private z_VertexAttribL3ui64NV_adr := GetProcAddress('glVertexAttribL3ui64NV');
    private z_VertexAttribL3ui64NV_1 := GetProcOrNil&<procedure(index: UInt32; x: UInt64; y: UInt64; z: UInt64)>(z_VertexAttribL3ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3ui64NV(index: UInt32; x: UInt64; y: UInt64; z: UInt64) :=
    z_VertexAttribL3ui64NV_1(index, x, y, z);
    
    private z_VertexAttribL4ui64NV_adr := GetProcAddress('glVertexAttribL4ui64NV');
    private z_VertexAttribL4ui64NV_1 := GetProcOrNil&<procedure(index: UInt32; x: UInt64; y: UInt64; z: UInt64; w: UInt64)>(z_VertexAttribL4ui64NV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4ui64NV(index: UInt32; x: UInt64; y: UInt64; z: UInt64; w: UInt64) :=
    z_VertexAttribL4ui64NV_1(index, x, y, z, w);
    
    private z_VertexAttribL1ui64vNV_adr := GetProcAddress('glVertexAttribL1ui64vNV');
    private z_VertexAttribL1ui64vNV_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribL1ui64vNV_adr);
    private z_VertexAttribL1ui64vNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: UInt64)>(z_VertexAttribL1ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1ui64vNV(index: UInt32; v: array of UInt64);
    type PUInt64=^UInt64;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribL1ui64vNV_2(index, v[0]) else
        z_VertexAttribL1ui64vNV_2(index, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1ui64vNV(index: UInt32; var v: UInt64) :=
    z_VertexAttribL1ui64vNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1ui64vNV(index: UInt32; v: IntPtr) :=
    z_VertexAttribL1ui64vNV_1(index, v);
    
    private z_VertexAttribL2ui64vNV_adr := GetProcAddress('glVertexAttribL2ui64vNV');
    private z_VertexAttribL2ui64vNV_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribL2ui64vNV_adr);
    private z_VertexAttribL2ui64vNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: UInt64)>(z_VertexAttribL2ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2ui64vNV(index: UInt32; v: array of UInt64);
    type PUInt64=^UInt64;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribL2ui64vNV_2(index, v[0]) else
        z_VertexAttribL2ui64vNV_2(index, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2ui64vNV(index: UInt32; var v: UInt64) :=
    z_VertexAttribL2ui64vNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2ui64vNV(index: UInt32; v: IntPtr) :=
    z_VertexAttribL2ui64vNV_1(index, v);
    
    private z_VertexAttribL3ui64vNV_adr := GetProcAddress('glVertexAttribL3ui64vNV');
    private z_VertexAttribL3ui64vNV_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribL3ui64vNV_adr);
    private z_VertexAttribL3ui64vNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: UInt64)>(z_VertexAttribL3ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3ui64vNV(index: UInt32; v: array of UInt64);
    type PUInt64=^UInt64;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribL3ui64vNV_2(index, v[0]) else
        z_VertexAttribL3ui64vNV_2(index, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3ui64vNV(index: UInt32; var v: UInt64) :=
    z_VertexAttribL3ui64vNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3ui64vNV(index: UInt32; v: IntPtr) :=
    z_VertexAttribL3ui64vNV_1(index, v);
    
    private z_VertexAttribL4ui64vNV_adr := GetProcAddress('glVertexAttribL4ui64vNV');
    private z_VertexAttribL4ui64vNV_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribL4ui64vNV_adr);
    private z_VertexAttribL4ui64vNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: UInt64)>(z_VertexAttribL4ui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4ui64vNV(index: UInt32; v: array of UInt64);
    type PUInt64=^UInt64;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribL4ui64vNV_2(index, v[0]) else
        z_VertexAttribL4ui64vNV_2(index, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4ui64vNV(index: UInt32; var v: UInt64) :=
    z_VertexAttribL4ui64vNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4ui64vNV(index: UInt32; v: IntPtr) :=
    z_VertexAttribL4ui64vNV_1(index, v);
    
    private z_GetVertexAttribLi64vNV_adr := GetProcAddress('glGetVertexAttribLi64vNV');
    private z_GetVertexAttribLi64vNV_1 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribEnum; &params: IntPtr)>(z_GetVertexAttribLi64vNV_adr);
    private z_GetVertexAttribLi64vNV_2 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribEnum; var &params: Int64)>(z_GetVertexAttribLi64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLi64vNV(index: UInt32; pname: VertexAttribEnum; var &params: Int64) :=
    z_GetVertexAttribLi64vNV_2(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLi64vNV(index: UInt32; pname: VertexAttribEnum; &params: IntPtr) :=
    z_GetVertexAttribLi64vNV_1(index, pname, &params);
    
    private z_GetVertexAttribLui64vNV_adr := GetProcAddress('glGetVertexAttribLui64vNV');
    private z_GetVertexAttribLui64vNV_1 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribEnum; &params: IntPtr)>(z_GetVertexAttribLui64vNV_adr);
    private z_GetVertexAttribLui64vNV_2 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribEnum; var &params: UInt64)>(z_GetVertexAttribLui64vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLui64vNV(index: UInt32; pname: VertexAttribEnum; var &params: UInt64) :=
    z_GetVertexAttribLui64vNV_2(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLui64vNV(index: UInt32; pname: VertexAttribEnum; &params: IntPtr) :=
    z_GetVertexAttribLui64vNV_1(index, pname, &params);
    
    private z_VertexAttribLFormatNV_adr := GetProcAddress('glVertexAttribLFormatNV');
    private z_VertexAttribLFormatNV_1 := GetProcOrNil&<procedure(index: UInt32; size: Int32; &type: VertexAttribLType; stride: Int32)>(z_VertexAttribLFormatNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribLFormatNV(index: UInt32; size: Int32; &type: VertexAttribLType; stride: Int32) :=
    z_VertexAttribLFormatNV_1(index, size, &type, stride);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glVertexBufferUnifiedMemoryNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_vertex_buffer_unified_memory';
    
    private z_BufferAddressRangeNV_adr := GetProcAddress('glBufferAddressRangeNV');
    private z_BufferAddressRangeNV_1 := GetProcOrNil&<procedure(pname: DummyEnum; index: UInt32; address: UInt64; length: UIntPtr)>(z_BufferAddressRangeNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferAddressRangeNV(pname: DummyEnum; index: UInt32; address: UInt64; length: UIntPtr) :=
    z_BufferAddressRangeNV_1(pname, index, address, length);
    
    private z_VertexFormatNV_adr := GetProcAddress('glVertexFormatNV');
    private z_VertexFormatNV_1 := GetProcOrNil&<procedure(size: Int32; &type: VertexPointerType; stride: Int32)>(z_VertexFormatNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexFormatNV(size: Int32; &type: VertexPointerType; stride: Int32) :=
    z_VertexFormatNV_1(size, &type, stride);
    
    private z_NormalFormatNV_adr := GetProcAddress('glNormalFormatNV');
    private z_NormalFormatNV_1 := GetProcOrNil&<procedure(&type: DummyEnum; stride: Int32)>(z_NormalFormatNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalFormatNV(&type: DummyEnum; stride: Int32) :=
    z_NormalFormatNV_1(&type, stride);
    
    private z_ColorFormatNV_adr := GetProcAddress('glColorFormatNV');
    private z_ColorFormatNV_1 := GetProcOrNil&<procedure(size: Int32; &type: DummyEnum; stride: Int32)>(z_ColorFormatNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorFormatNV(size: Int32; &type: DummyEnum; stride: Int32) :=
    z_ColorFormatNV_1(size, &type, stride);
    
    private z_IndexFormatNV_adr := GetProcAddress('glIndexFormatNV');
    private z_IndexFormatNV_1 := GetProcOrNil&<procedure(&type: DummyEnum; stride: Int32)>(z_IndexFormatNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexFormatNV(&type: DummyEnum; stride: Int32) :=
    z_IndexFormatNV_1(&type, stride);
    
    private z_TexCoordFormatNV_adr := GetProcAddress('glTexCoordFormatNV');
    private z_TexCoordFormatNV_1 := GetProcOrNil&<procedure(size: Int32; &type: DummyEnum; stride: Int32)>(z_TexCoordFormatNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordFormatNV(size: Int32; &type: DummyEnum; stride: Int32) :=
    z_TexCoordFormatNV_1(size, &type, stride);
    
    private z_EdgeFlagFormatNV_adr := GetProcAddress('glEdgeFlagFormatNV');
    private z_EdgeFlagFormatNV_1 := GetProcOrNil&<procedure(stride: Int32)>(z_EdgeFlagFormatNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlagFormatNV(stride: Int32) :=
    z_EdgeFlagFormatNV_1(stride);
    
    private z_SecondaryColorFormatNV_adr := GetProcAddress('glSecondaryColorFormatNV');
    private z_SecondaryColorFormatNV_1 := GetProcOrNil&<procedure(size: Int32; &type: ColorPointerType; stride: Int32)>(z_SecondaryColorFormatNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorFormatNV(size: Int32; &type: ColorPointerType; stride: Int32) :=
    z_SecondaryColorFormatNV_1(size, &type, stride);
    
    private z_FogCoordFormatNV_adr := GetProcAddress('glFogCoordFormatNV');
    private z_FogCoordFormatNV_1 := GetProcOrNil&<procedure(&type: DummyEnum; stride: Int32)>(z_FogCoordFormatNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordFormatNV(&type: DummyEnum; stride: Int32) :=
    z_FogCoordFormatNV_1(&type, stride);
    
    private z_VertexAttribFormatNV_adr := GetProcAddress('glVertexAttribFormatNV');
    private z_VertexAttribFormatNV_1 := GetProcOrNil&<procedure(index: UInt32; size: Int32; &type: VertexAttribType; normalized: boolean; stride: Int32)>(z_VertexAttribFormatNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribFormatNV(index: UInt32; size: Int32; &type: VertexAttribType; normalized: boolean; stride: Int32) :=
    z_VertexAttribFormatNV_1(index, size, &type, normalized, stride);
    
    private z_VertexAttribIFormatNV_adr := GetProcAddress('glVertexAttribIFormatNV');
    private z_VertexAttribIFormatNV_1 := GetProcOrNil&<procedure(index: UInt32; size: Int32; &type: VertexAttribIType; stride: Int32)>(z_VertexAttribIFormatNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribIFormatNV(index: UInt32; size: Int32; &type: VertexAttribIType; stride: Int32) :=
    z_VertexAttribIFormatNV_1(index, size, &type, stride);
    
    private z_GetIntegerui64i_vNV_adr := GetProcAddress('glGetIntegerui64i_vNV');
    private z_GetIntegerui64i_vNV_1 := GetProcOrNil&<procedure(value: DummyEnum; index: UInt32; result: IntPtr)>(z_GetIntegerui64i_vNV_adr);
    private z_GetIntegerui64i_vNV_2 := GetProcOrNil&<procedure(value: DummyEnum; index: UInt32; var result: UInt64)>(z_GetIntegerui64i_vNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerui64i_vNV(value: DummyEnum; index: UInt32; var result: UInt64) :=
    z_GetIntegerui64i_vNV_2(value, index, result);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerui64i_vNV(value: DummyEnum; index: UInt32; result: IntPtr) :=
    z_GetIntegerui64i_vNV_1(value, index, result);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glVertexProgramNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_vertex_program';
    
    private z_AreProgramsResidentNV_adr := GetProcAddress('glAreProgramsResidentNV');
    private z_AreProgramsResidentNV_1 := GetProcOrNil&<function(n: Int32; programs: IntPtr; residences: IntPtr): boolean>(z_AreProgramsResidentNV_adr);
    private z_AreProgramsResidentNV_2 := GetProcOrNil&<function(n: Int32; programs: IntPtr; var residences: boolean): boolean>(z_AreProgramsResidentNV_adr);
    private z_AreProgramsResidentNV_3 := GetProcOrNil&<function(n: Int32; var programs: gl_program; residences: IntPtr): boolean>(z_AreProgramsResidentNV_adr);
    private z_AreProgramsResidentNV_4 := GetProcOrNil&<function(n: Int32; var programs: gl_program; var residences: boolean): boolean>(z_AreProgramsResidentNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreProgramsResidentNV(n: Int32; programs: array of gl_program; var residences: boolean): boolean;
    type Pgl_program=^gl_program;
    begin
      Result := if (programs<>nil) and (programs.Length<>0) then
        z_AreProgramsResidentNV_4(n, programs[0], residences) else
        z_AreProgramsResidentNV_4(n, Pgl_program(nil)^, residences);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreProgramsResidentNV(n: Int32; programs: array of gl_program; residences: IntPtr): boolean;
    type Pgl_program=^gl_program;
    begin
      Result := if (programs<>nil) and (programs.Length<>0) then
        z_AreProgramsResidentNV_3(n, programs[0], residences) else
        z_AreProgramsResidentNV_3(n, Pgl_program(nil)^, residences);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreProgramsResidentNV(n: Int32; var programs: gl_program; var residences: boolean): boolean :=
    z_AreProgramsResidentNV_4(n, programs, residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreProgramsResidentNV(n: Int32; var programs: gl_program; residences: IntPtr): boolean :=
    z_AreProgramsResidentNV_3(n, programs, residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreProgramsResidentNV(n: Int32; programs: IntPtr; var residences: boolean): boolean :=
    z_AreProgramsResidentNV_2(n, programs, residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreProgramsResidentNV(n: Int32; programs: IntPtr; residences: IntPtr): boolean :=
    z_AreProgramsResidentNV_1(n, programs, residences);
    
    private z_BindProgramNV_adr := GetProcAddress('glBindProgramNV');
    private z_BindProgramNV_1 := GetProcOrNil&<procedure(target: VertexAttribEnumNV; id: gl_program)>(z_BindProgramNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindProgramNV(target: VertexAttribEnumNV; id: gl_program) :=
    z_BindProgramNV_1(target, id);
    
    private z_DeleteProgramsNV_adr := GetProcAddress('glDeleteProgramsNV');
    private z_DeleteProgramsNV_1 := GetProcOrNil&<procedure(n: Int32; programs: IntPtr)>(z_DeleteProgramsNV_adr);
    private z_DeleteProgramsNV_2 := GetProcOrNil&<procedure(n: Int32; var programs: gl_program)>(z_DeleteProgramsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramsNV(n: Int32; programs: array of gl_program);
    type Pgl_program=^gl_program;
    begin
      if (programs<>nil) and (programs.Length<>0) then
        z_DeleteProgramsNV_2(n, programs[0]) else
        z_DeleteProgramsNV_2(n, Pgl_program(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramsNV(n: Int32; var programs: gl_program) :=
    z_DeleteProgramsNV_2(n, programs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramsNV(n: Int32; programs: IntPtr) :=
    z_DeleteProgramsNV_1(n, programs);
    
    private z_ExecuteProgramNV_adr := GetProcAddress('glExecuteProgramNV');
    private z_ExecuteProgramNV_1 := GetProcOrNil&<procedure(target: VertexAttribEnumNV; id: UInt32; &params: IntPtr)>(z_ExecuteProgramNV_adr);
    private z_ExecuteProgramNV_2 := GetProcOrNil&<procedure(target: VertexAttribEnumNV; id: UInt32; var &params: single)>(z_ExecuteProgramNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExecuteProgramNV(target: VertexAttribEnumNV; id: UInt32; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_ExecuteProgramNV_2(target, id, &params[0]) else
        z_ExecuteProgramNV_2(target, id, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExecuteProgramNV(target: VertexAttribEnumNV; id: UInt32; var &params: single) :=
    z_ExecuteProgramNV_2(target, id, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExecuteProgramNV(target: VertexAttribEnumNV; id: UInt32; &params: IntPtr) :=
    z_ExecuteProgramNV_1(target, id, &params);
    
    private z_GenProgramsNV_adr := GetProcAddress('glGenProgramsNV');
    private z_GenProgramsNV_1 := GetProcOrNil&<procedure(n: Int32; programs: IntPtr)>(z_GenProgramsNV_adr);
    private z_GenProgramsNV_2 := GetProcOrNil&<procedure(n: Int32; var programs: gl_program)>(z_GenProgramsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramsNV(n: Int32; programs: array of gl_program);
    type Pgl_program=^gl_program;
    begin
      if (programs<>nil) and (programs.Length<>0) then
        z_GenProgramsNV_2(n, programs[0]) else
        z_GenProgramsNV_2(n, Pgl_program(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramsNV(n: Int32; var programs: gl_program) :=
    z_GenProgramsNV_2(n, programs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramsNV(n: Int32; programs: IntPtr) :=
    z_GenProgramsNV_1(n, programs);
    
    private z_GetProgramParameterdvNV_adr := GetProcAddress('glGetProgramParameterdvNV');
    private z_GetProgramParameterdvNV_1 := GetProcOrNil&<procedure(target: VertexAttribEnumNV; index: UInt32; pname: VertexAttribEnumNV; &params: IntPtr)>(z_GetProgramParameterdvNV_adr);
    private z_GetProgramParameterdvNV_2 := GetProcOrNil&<procedure(target: VertexAttribEnumNV; index: UInt32; pname: VertexAttribEnumNV; var &params: real)>(z_GetProgramParameterdvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramParameterdvNV(target: VertexAttribEnumNV; index: UInt32; pname: VertexAttribEnumNV; var &params: real) :=
    z_GetProgramParameterdvNV_2(target, index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramParameterdvNV(target: VertexAttribEnumNV; index: UInt32; pname: VertexAttribEnumNV; &params: IntPtr) :=
    z_GetProgramParameterdvNV_1(target, index, pname, &params);
    
    private z_GetProgramParameterfvNV_adr := GetProcAddress('glGetProgramParameterfvNV');
    private z_GetProgramParameterfvNV_1 := GetProcOrNil&<procedure(target: VertexAttribEnumNV; index: UInt32; pname: VertexAttribEnumNV; &params: IntPtr)>(z_GetProgramParameterfvNV_adr);
    private z_GetProgramParameterfvNV_2 := GetProcOrNil&<procedure(target: VertexAttribEnumNV; index: UInt32; pname: VertexAttribEnumNV; var &params: single)>(z_GetProgramParameterfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramParameterfvNV(target: VertexAttribEnumNV; index: UInt32; pname: VertexAttribEnumNV; var &params: single) :=
    z_GetProgramParameterfvNV_2(target, index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramParameterfvNV(target: VertexAttribEnumNV; index: UInt32; pname: VertexAttribEnumNV; &params: IntPtr) :=
    z_GetProgramParameterfvNV_1(target, index, pname, &params);
    
    private z_GetProgramivNV_adr := GetProcAddress('glGetProgramivNV');
    private z_GetProgramivNV_1 := GetProcOrNil&<procedure(id: gl_program; pname: VertexAttribEnumNV; &params: IntPtr)>(z_GetProgramivNV_adr);
    private z_GetProgramivNV_2 := GetProcOrNil&<procedure(id: gl_program; pname: VertexAttribEnumNV; var &params: Int32)>(z_GetProgramivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramivNV(id: gl_program; pname: VertexAttribEnumNV; var &params: Int32) :=
    z_GetProgramivNV_2(id, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramivNV(id: gl_program; pname: VertexAttribEnumNV; &params: IntPtr) :=
    z_GetProgramivNV_1(id, pname, &params);
    
    private z_GetProgramStringNV_adr := GetProcAddress('glGetProgramStringNV');
    private z_GetProgramStringNV_1 := GetProcOrNil&<procedure(id: gl_program; pname: VertexAttribEnumNV; &program: IntPtr)>(z_GetProgramStringNV_adr);
    private z_GetProgramStringNV_2 := GetProcOrNil&<procedure(id: gl_program; pname: VertexAttribEnumNV; var &program: Byte)>(z_GetProgramStringNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramStringNV(id: gl_program; pname: VertexAttribEnumNV; var &program: Byte) :=
    z_GetProgramStringNV_2(id, pname, &program);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramStringNV(id: gl_program; pname: VertexAttribEnumNV; &program: IntPtr) :=
    z_GetProgramStringNV_1(id, pname, &program);
    
    private z_GetTrackMatrixivNV_adr := GetProcAddress('glGetTrackMatrixivNV');
    private z_GetTrackMatrixivNV_1 := GetProcOrNil&<procedure(target: VertexAttribEnumNV; address: UInt32; pname: VertexAttribEnumNV; &params: IntPtr)>(z_GetTrackMatrixivNV_adr);
    private z_GetTrackMatrixivNV_2 := GetProcOrNil&<procedure(target: VertexAttribEnumNV; address: UInt32; pname: VertexAttribEnumNV; var &params: Int32)>(z_GetTrackMatrixivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTrackMatrixivNV(target: VertexAttribEnumNV; address: UInt32; pname: VertexAttribEnumNV; var &params: Int32) :=
    z_GetTrackMatrixivNV_2(target, address, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTrackMatrixivNV(target: VertexAttribEnumNV; address: UInt32; pname: VertexAttribEnumNV; &params: IntPtr) :=
    z_GetTrackMatrixivNV_1(target, address, pname, &params);
    
    private z_GetVertexAttribdvNV_adr := GetProcAddress('glGetVertexAttribdvNV');
    private z_GetVertexAttribdvNV_1 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribEnumNV; &params: IntPtr)>(z_GetVertexAttribdvNV_adr);
    private z_GetVertexAttribdvNV_2 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribEnumNV; var &params: real)>(z_GetVertexAttribdvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribdvNV(index: UInt32; pname: VertexAttribEnumNV; var &params: real) :=
    z_GetVertexAttribdvNV_2(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribdvNV(index: UInt32; pname: VertexAttribEnumNV; &params: IntPtr) :=
    z_GetVertexAttribdvNV_1(index, pname, &params);
    
    private z_GetVertexAttribfvNV_adr := GetProcAddress('glGetVertexAttribfvNV');
    private z_GetVertexAttribfvNV_1 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribEnumNV; &params: IntPtr)>(z_GetVertexAttribfvNV_adr);
    private z_GetVertexAttribfvNV_2 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribEnumNV; var &params: single)>(z_GetVertexAttribfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribfvNV(index: UInt32; pname: VertexAttribEnumNV; var &params: single) :=
    z_GetVertexAttribfvNV_2(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribfvNV(index: UInt32; pname: VertexAttribEnumNV; &params: IntPtr) :=
    z_GetVertexAttribfvNV_1(index, pname, &params);
    
    private z_GetVertexAttribivNV_adr := GetProcAddress('glGetVertexAttribivNV');
    private z_GetVertexAttribivNV_1 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribEnumNV; &params: IntPtr)>(z_GetVertexAttribivNV_adr);
    private z_GetVertexAttribivNV_2 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribEnumNV; var &params: Int32)>(z_GetVertexAttribivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribivNV(index: UInt32; pname: VertexAttribEnumNV; var &params: Int32) :=
    z_GetVertexAttribivNV_2(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribivNV(index: UInt32; pname: VertexAttribEnumNV; &params: IntPtr) :=
    z_GetVertexAttribivNV_1(index, pname, &params);
    
    private z_GetVertexAttribPointervNV_adr := GetProcAddress('glGetVertexAttribPointervNV');
    private z_GetVertexAttribPointervNV_1 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribEnumNV; _pointer: pointer)>(z_GetVertexAttribPointervNV_adr);
    private z_GetVertexAttribPointervNV_2 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribEnumNV; var _pointer: IntPtr)>(z_GetVertexAttribPointervNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribPointervNV(index: UInt32; pname: VertexAttribEnumNV; var _pointer: IntPtr) :=
    z_GetVertexAttribPointervNV_2(index, pname, _pointer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribPointervNV(index: UInt32; pname: VertexAttribEnumNV; _pointer: pointer) :=
    z_GetVertexAttribPointervNV_1(index, pname, _pointer);
    
    private z_IsProgramNV_adr := GetProcAddress('glIsProgramNV');
    private z_IsProgramNV_1 := GetProcOrNil&<function(id: gl_program): boolean>(z_IsProgramNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsProgramNV(id: gl_program): boolean :=
    z_IsProgramNV_1(id);
    
    private z_LoadProgramNV_adr := GetProcAddress('glLoadProgramNV');
    private z_LoadProgramNV_1 := GetProcOrNil&<procedure(target: VertexAttribEnumNV; id: UInt32; len: Int32; &program: IntPtr)>(z_LoadProgramNV_adr);
    private z_LoadProgramNV_2 := GetProcOrNil&<procedure(target: VertexAttribEnumNV; id: UInt32; len: Int32; var &program: Byte)>(z_LoadProgramNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadProgramNV(target: VertexAttribEnumNV; id: UInt32; len: Int32; &program: array of Byte);
    type PByte=^Byte;
    begin
      if (&program<>nil) and (&program.Length<>0) then
        z_LoadProgramNV_2(target, id, len, &program[0]) else
        z_LoadProgramNV_2(target, id, len, PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadProgramNV(target: VertexAttribEnumNV; id: UInt32; len: Int32; var &program: Byte) :=
    z_LoadProgramNV_2(target, id, len, &program);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadProgramNV(target: VertexAttribEnumNV; id: UInt32; len: Int32; &program: IntPtr) :=
    z_LoadProgramNV_1(target, id, len, &program);
    
    private z_ProgramParameter4dNV_adr := GetProcAddress('glProgramParameter4dNV');
    private z_ProgramParameter4dNV_1 := GetProcOrNil&<procedure(target: VertexAttribEnumNV; index: UInt32; x: real; y: real; z: real; w: real)>(z_ProgramParameter4dNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameter4dNV(target: VertexAttribEnumNV; index: UInt32; x: real; y: real; z: real; w: real) :=
    z_ProgramParameter4dNV_1(target, index, x, y, z, w);
    
    private z_ProgramParameter4dvNV_adr := GetProcAddress('glProgramParameter4dvNV');
    private z_ProgramParameter4dvNV_1 := GetProcOrNil&<procedure(target: VertexAttribEnumNV; index: UInt32; v: IntPtr)>(z_ProgramParameter4dvNV_adr);
    private z_ProgramParameter4dvNV_2 := GetProcOrNil&<procedure(target: VertexAttribEnumNV; index: UInt32; var v: real)>(z_ProgramParameter4dvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameter4dvNV(target: VertexAttribEnumNV; index: UInt32; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_ProgramParameter4dvNV_2(target, index, v[0]) else
        z_ProgramParameter4dvNV_2(target, index, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameter4dvNV(target: VertexAttribEnumNV; index: UInt32; var v: real) :=
    z_ProgramParameter4dvNV_2(target, index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameter4dvNV(target: VertexAttribEnumNV; index: UInt32; v: IntPtr) :=
    z_ProgramParameter4dvNV_1(target, index, v);
    
    private z_ProgramParameter4fNV_adr := GetProcAddress('glProgramParameter4fNV');
    private z_ProgramParameter4fNV_1 := GetProcOrNil&<procedure(target: VertexAttribEnumNV; index: UInt32; x: single; y: single; z: single; w: single)>(z_ProgramParameter4fNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameter4fNV(target: VertexAttribEnumNV; index: UInt32; x: single; y: single; z: single; w: single) :=
    z_ProgramParameter4fNV_1(target, index, x, y, z, w);
    
    private z_ProgramParameter4fvNV_adr := GetProcAddress('glProgramParameter4fvNV');
    private z_ProgramParameter4fvNV_1 := GetProcOrNil&<procedure(target: VertexAttribEnumNV; index: UInt32; v: IntPtr)>(z_ProgramParameter4fvNV_adr);
    private z_ProgramParameter4fvNV_2 := GetProcOrNil&<procedure(target: VertexAttribEnumNV; index: UInt32; var v: single)>(z_ProgramParameter4fvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameter4fvNV(target: VertexAttribEnumNV; index: UInt32; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_ProgramParameter4fvNV_2(target, index, v[0]) else
        z_ProgramParameter4fvNV_2(target, index, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameter4fvNV(target: VertexAttribEnumNV; index: UInt32; var v: single) :=
    z_ProgramParameter4fvNV_2(target, index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameter4fvNV(target: VertexAttribEnumNV; index: UInt32; v: IntPtr) :=
    z_ProgramParameter4fvNV_1(target, index, v);
    
    private z_ProgramParameters4dvNV_adr := GetProcAddress('glProgramParameters4dvNV');
    private z_ProgramParameters4dvNV_1 := GetProcOrNil&<procedure(target: VertexAttribEnumNV; index: UInt32; count: Int32; v: IntPtr)>(z_ProgramParameters4dvNV_adr);
    private z_ProgramParameters4dvNV_2 := GetProcOrNil&<procedure(target: VertexAttribEnumNV; index: UInt32; count: Int32; var v: real)>(z_ProgramParameters4dvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameters4dvNV(target: VertexAttribEnumNV; index: UInt32; count: Int32; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_ProgramParameters4dvNV_2(target, index, count, v[0]) else
        z_ProgramParameters4dvNV_2(target, index, count, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameters4dvNV(target: VertexAttribEnumNV; index: UInt32; count: Int32; var v: real) :=
    z_ProgramParameters4dvNV_2(target, index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameters4dvNV(target: VertexAttribEnumNV; index: UInt32; count: Int32; v: IntPtr) :=
    z_ProgramParameters4dvNV_1(target, index, count, v);
    
    private z_ProgramParameters4fvNV_adr := GetProcAddress('glProgramParameters4fvNV');
    private z_ProgramParameters4fvNV_1 := GetProcOrNil&<procedure(target: VertexAttribEnumNV; index: UInt32; count: Int32; v: IntPtr)>(z_ProgramParameters4fvNV_adr);
    private z_ProgramParameters4fvNV_2 := GetProcOrNil&<procedure(target: VertexAttribEnumNV; index: UInt32; count: Int32; var v: single)>(z_ProgramParameters4fvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameters4fvNV(target: VertexAttribEnumNV; index: UInt32; count: Int32; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_ProgramParameters4fvNV_2(target, index, count, v[0]) else
        z_ProgramParameters4fvNV_2(target, index, count, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameters4fvNV(target: VertexAttribEnumNV; index: UInt32; count: Int32; var v: single) :=
    z_ProgramParameters4fvNV_2(target, index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameters4fvNV(target: VertexAttribEnumNV; index: UInt32; count: Int32; v: IntPtr) :=
    z_ProgramParameters4fvNV_1(target, index, count, v);
    
    private z_RequestResidentProgramsNV_adr := GetProcAddress('glRequestResidentProgramsNV');
    private z_RequestResidentProgramsNV_1 := GetProcOrNil&<procedure(n: Int32; programs: IntPtr)>(z_RequestResidentProgramsNV_adr);
    private z_RequestResidentProgramsNV_2 := GetProcOrNil&<procedure(n: Int32; var programs: gl_program)>(z_RequestResidentProgramsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RequestResidentProgramsNV(n: Int32; programs: array of gl_program);
    type Pgl_program=^gl_program;
    begin
      if (programs<>nil) and (programs.Length<>0) then
        z_RequestResidentProgramsNV_2(n, programs[0]) else
        z_RequestResidentProgramsNV_2(n, Pgl_program(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RequestResidentProgramsNV(n: Int32; var programs: gl_program) :=
    z_RequestResidentProgramsNV_2(n, programs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RequestResidentProgramsNV(n: Int32; programs: IntPtr) :=
    z_RequestResidentProgramsNV_1(n, programs);
    
    private z_TrackMatrixNV_adr := GetProcAddress('glTrackMatrixNV');
    private z_TrackMatrixNV_1 := GetProcOrNil&<procedure(target: VertexAttribEnumNV; address: UInt32; matrix: VertexAttribEnumNV; transform: VertexAttribEnumNV)>(z_TrackMatrixNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TrackMatrixNV(target: VertexAttribEnumNV; address: UInt32; matrix: VertexAttribEnumNV; transform: VertexAttribEnumNV) :=
    z_TrackMatrixNV_1(target, address, matrix, transform);
    
    private z_VertexAttribPointerNV_adr := GetProcAddress('glVertexAttribPointerNV');
    private z_VertexAttribPointerNV_1 := GetProcOrNil&<procedure(index: UInt32; fsize: Int32; &type: VertexAttribEnumNV; stride: Int32; pointer: IntPtr)>(z_VertexAttribPointerNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribPointerNV(index: UInt32; fsize: Int32; &type: VertexAttribEnumNV; stride: Int32; pointer: IntPtr) :=
    z_VertexAttribPointerNV_1(index, fsize, &type, stride, pointer);
    
    private z_VertexAttrib1dNV_adr := GetProcAddress('glVertexAttrib1dNV');
    private z_VertexAttrib1dNV_1 := GetProcOrNil&<procedure(index: UInt32; x: real)>(z_VertexAttrib1dNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dNV(index: UInt32; x: real) :=
    z_VertexAttrib1dNV_1(index, x);
    
    private z_VertexAttrib1dvNV_adr := GetProcAddress('glVertexAttrib1dvNV');
    private z_VertexAttrib1dvNV_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib1dvNV_adr);
    private z_VertexAttrib1dvNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: real)>(z_VertexAttrib1dvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dvNV(index: UInt32; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib1dvNV_2(index, v[0]) else
        z_VertexAttrib1dvNV_2(index, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dvNV(index: UInt32; var v: real) :=
    z_VertexAttrib1dvNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dvNV(index: UInt32; v: IntPtr) :=
    z_VertexAttrib1dvNV_1(index, v);
    
    private z_VertexAttrib1fNV_adr := GetProcAddress('glVertexAttrib1fNV');
    private z_VertexAttrib1fNV_1 := GetProcOrNil&<procedure(index: UInt32; x: single)>(z_VertexAttrib1fNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fNV(index: UInt32; x: single) :=
    z_VertexAttrib1fNV_1(index, x);
    
    private z_VertexAttrib1fvNV_adr := GetProcAddress('glVertexAttrib1fvNV');
    private z_VertexAttrib1fvNV_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib1fvNV_adr);
    private z_VertexAttrib1fvNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: single)>(z_VertexAttrib1fvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fvNV(index: UInt32; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib1fvNV_2(index, v[0]) else
        z_VertexAttrib1fvNV_2(index, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fvNV(index: UInt32; var v: single) :=
    z_VertexAttrib1fvNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fvNV(index: UInt32; v: IntPtr) :=
    z_VertexAttrib1fvNV_1(index, v);
    
    private z_VertexAttrib1sNV_adr := GetProcAddress('glVertexAttrib1sNV');
    private z_VertexAttrib1sNV_1 := GetProcOrNil&<procedure(index: UInt32; x: Int16)>(z_VertexAttrib1sNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1sNV(index: UInt32; x: Int16) :=
    z_VertexAttrib1sNV_1(index, x);
    
    private z_VertexAttrib1svNV_adr := GetProcAddress('glVertexAttrib1svNV');
    private z_VertexAttrib1svNV_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib1svNV_adr);
    private z_VertexAttrib1svNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(z_VertexAttrib1svNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1svNV(index: UInt32; v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib1svNV_2(index, v[0]) else
        z_VertexAttrib1svNV_2(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1svNV(index: UInt32; var v: Int16) :=
    z_VertexAttrib1svNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1svNV(index: UInt32; v: IntPtr) :=
    z_VertexAttrib1svNV_1(index, v);
    
    private z_VertexAttrib2dNV_adr := GetProcAddress('glVertexAttrib2dNV');
    private z_VertexAttrib2dNV_1 := GetProcOrNil&<procedure(index: UInt32; x: real; y: real)>(z_VertexAttrib2dNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dNV(index: UInt32; x: real; y: real) :=
    z_VertexAttrib2dNV_1(index, x, y);
    
    private z_VertexAttrib2dvNV_adr := GetProcAddress('glVertexAttrib2dvNV');
    private z_VertexAttrib2dvNV_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib2dvNV_adr);
    private z_VertexAttrib2dvNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: real)>(z_VertexAttrib2dvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dvNV(index: UInt32; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib2dvNV_2(index, v[0]) else
        z_VertexAttrib2dvNV_2(index, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dvNV(index: UInt32; var v: real) :=
    z_VertexAttrib2dvNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dvNV(index: UInt32; v: IntPtr) :=
    z_VertexAttrib2dvNV_1(index, v);
    
    private z_VertexAttrib2fNV_adr := GetProcAddress('glVertexAttrib2fNV');
    private z_VertexAttrib2fNV_1 := GetProcOrNil&<procedure(index: UInt32; x: single; y: single)>(z_VertexAttrib2fNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fNV(index: UInt32; x: single; y: single) :=
    z_VertexAttrib2fNV_1(index, x, y);
    
    private z_VertexAttrib2fvNV_adr := GetProcAddress('glVertexAttrib2fvNV');
    private z_VertexAttrib2fvNV_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib2fvNV_adr);
    private z_VertexAttrib2fvNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: single)>(z_VertexAttrib2fvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fvNV(index: UInt32; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib2fvNV_2(index, v[0]) else
        z_VertexAttrib2fvNV_2(index, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fvNV(index: UInt32; var v: single) :=
    z_VertexAttrib2fvNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fvNV(index: UInt32; v: IntPtr) :=
    z_VertexAttrib2fvNV_1(index, v);
    
    private z_VertexAttrib2sNV_adr := GetProcAddress('glVertexAttrib2sNV');
    private z_VertexAttrib2sNV_1 := GetProcOrNil&<procedure(index: UInt32; x: Int16; y: Int16)>(z_VertexAttrib2sNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2sNV(index: UInt32; x: Int16; y: Int16) :=
    z_VertexAttrib2sNV_1(index, x, y);
    
    private z_VertexAttrib2svNV_adr := GetProcAddress('glVertexAttrib2svNV');
    private z_VertexAttrib2svNV_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib2svNV_adr);
    private z_VertexAttrib2svNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(z_VertexAttrib2svNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2svNV(index: UInt32; v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib2svNV_2(index, v[0]) else
        z_VertexAttrib2svNV_2(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2svNV(index: UInt32; var v: Int16) :=
    z_VertexAttrib2svNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2svNV(index: UInt32; v: IntPtr) :=
    z_VertexAttrib2svNV_1(index, v);
    
    private z_VertexAttrib3dNV_adr := GetProcAddress('glVertexAttrib3dNV');
    private z_VertexAttrib3dNV_1 := GetProcOrNil&<procedure(index: UInt32; x: real; y: real; z: real)>(z_VertexAttrib3dNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dNV(index: UInt32; x: real; y: real; z: real) :=
    z_VertexAttrib3dNV_1(index, x, y, z);
    
    private z_VertexAttrib3dvNV_adr := GetProcAddress('glVertexAttrib3dvNV');
    private z_VertexAttrib3dvNV_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib3dvNV_adr);
    private z_VertexAttrib3dvNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: real)>(z_VertexAttrib3dvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dvNV(index: UInt32; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib3dvNV_2(index, v[0]) else
        z_VertexAttrib3dvNV_2(index, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dvNV(index: UInt32; var v: real) :=
    z_VertexAttrib3dvNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dvNV(index: UInt32; v: IntPtr) :=
    z_VertexAttrib3dvNV_1(index, v);
    
    private z_VertexAttrib3fNV_adr := GetProcAddress('glVertexAttrib3fNV');
    private z_VertexAttrib3fNV_1 := GetProcOrNil&<procedure(index: UInt32; x: single; y: single; z: single)>(z_VertexAttrib3fNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fNV(index: UInt32; x: single; y: single; z: single) :=
    z_VertexAttrib3fNV_1(index, x, y, z);
    
    private z_VertexAttrib3fvNV_adr := GetProcAddress('glVertexAttrib3fvNV');
    private z_VertexAttrib3fvNV_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib3fvNV_adr);
    private z_VertexAttrib3fvNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: single)>(z_VertexAttrib3fvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fvNV(index: UInt32; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib3fvNV_2(index, v[0]) else
        z_VertexAttrib3fvNV_2(index, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fvNV(index: UInt32; var v: single) :=
    z_VertexAttrib3fvNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fvNV(index: UInt32; v: IntPtr) :=
    z_VertexAttrib3fvNV_1(index, v);
    
    private z_VertexAttrib3sNV_adr := GetProcAddress('glVertexAttrib3sNV');
    private z_VertexAttrib3sNV_1 := GetProcOrNil&<procedure(index: UInt32; x: Int16; y: Int16; z: Int16)>(z_VertexAttrib3sNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3sNV(index: UInt32; x: Int16; y: Int16; z: Int16) :=
    z_VertexAttrib3sNV_1(index, x, y, z);
    
    private z_VertexAttrib3svNV_adr := GetProcAddress('glVertexAttrib3svNV');
    private z_VertexAttrib3svNV_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib3svNV_adr);
    private z_VertexAttrib3svNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(z_VertexAttrib3svNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3svNV(index: UInt32; v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib3svNV_2(index, v[0]) else
        z_VertexAttrib3svNV_2(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3svNV(index: UInt32; var v: Int16) :=
    z_VertexAttrib3svNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3svNV(index: UInt32; v: IntPtr) :=
    z_VertexAttrib3svNV_1(index, v);
    
    private z_VertexAttrib4dNV_adr := GetProcAddress('glVertexAttrib4dNV');
    private z_VertexAttrib4dNV_1 := GetProcOrNil&<procedure(index: UInt32; x: real; y: real; z: real; w: real)>(z_VertexAttrib4dNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dNV(index: UInt32; x: real; y: real; z: real; w: real) :=
    z_VertexAttrib4dNV_1(index, x, y, z, w);
    
    private z_VertexAttrib4dvNV_adr := GetProcAddress('glVertexAttrib4dvNV');
    private z_VertexAttrib4dvNV_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4dvNV_adr);
    private z_VertexAttrib4dvNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: real)>(z_VertexAttrib4dvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dvNV(index: UInt32; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4dvNV_2(index, v[0]) else
        z_VertexAttrib4dvNV_2(index, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dvNV(index: UInt32; var v: real) :=
    z_VertexAttrib4dvNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dvNV(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4dvNV_1(index, v);
    
    private z_VertexAttrib4fNV_adr := GetProcAddress('glVertexAttrib4fNV');
    private z_VertexAttrib4fNV_1 := GetProcOrNil&<procedure(index: UInt32; x: single; y: single; z: single; w: single)>(z_VertexAttrib4fNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fNV(index: UInt32; x: single; y: single; z: single; w: single) :=
    z_VertexAttrib4fNV_1(index, x, y, z, w);
    
    private z_VertexAttrib4fvNV_adr := GetProcAddress('glVertexAttrib4fvNV');
    private z_VertexAttrib4fvNV_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4fvNV_adr);
    private z_VertexAttrib4fvNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: single)>(z_VertexAttrib4fvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fvNV(index: UInt32; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4fvNV_2(index, v[0]) else
        z_VertexAttrib4fvNV_2(index, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fvNV(index: UInt32; var v: single) :=
    z_VertexAttrib4fvNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fvNV(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4fvNV_1(index, v);
    
    private z_VertexAttrib4sNV_adr := GetProcAddress('glVertexAttrib4sNV');
    private z_VertexAttrib4sNV_1 := GetProcOrNil&<procedure(index: UInt32; x: Int16; y: Int16; z: Int16; w: Int16)>(z_VertexAttrib4sNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4sNV(index: UInt32; x: Int16; y: Int16; z: Int16; w: Int16) :=
    z_VertexAttrib4sNV_1(index, x, y, z, w);
    
    private z_VertexAttrib4svNV_adr := GetProcAddress('glVertexAttrib4svNV');
    private z_VertexAttrib4svNV_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4svNV_adr);
    private z_VertexAttrib4svNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(z_VertexAttrib4svNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4svNV(index: UInt32; v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4svNV_2(index, v[0]) else
        z_VertexAttrib4svNV_2(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4svNV(index: UInt32; var v: Int16) :=
    z_VertexAttrib4svNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4svNV(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4svNV_1(index, v);
    
    private z_VertexAttrib4ubNV_adr := GetProcAddress('glVertexAttrib4ubNV');
    private z_VertexAttrib4ubNV_1 := GetProcOrNil&<procedure(index: UInt32; x: Byte; y: Byte; z: Byte; w: Byte)>(z_VertexAttrib4ubNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubNV(index: UInt32; x: Byte; y: Byte; z: Byte; w: Byte) :=
    z_VertexAttrib4ubNV_1(index, x, y, z, w);
    
    private z_VertexAttrib4ubvNV_adr := GetProcAddress('glVertexAttrib4ubvNV');
    private z_VertexAttrib4ubvNV_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttrib4ubvNV_adr);
    private z_VertexAttrib4ubvNV_2 := GetProcOrNil&<procedure(index: UInt32; var v: Byte)>(z_VertexAttrib4ubvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubvNV(index: UInt32; v: array of Byte);
    type PByte=^Byte;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttrib4ubvNV_2(index, v[0]) else
        z_VertexAttrib4ubvNV_2(index, PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubvNV(index: UInt32; var v: Byte) :=
    z_VertexAttrib4ubvNV_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubvNV(index: UInt32; v: IntPtr) :=
    z_VertexAttrib4ubvNV_1(index, v);
    
    private z_VertexAttribs1dvNV_adr := GetProcAddress('glVertexAttribs1dvNV');
    private z_VertexAttribs1dvNV_1 := GetProcOrNil&<procedure(index: UInt32; count: Int32; v: IntPtr)>(z_VertexAttribs1dvNV_adr);
    private z_VertexAttribs1dvNV_2 := GetProcOrNil&<procedure(index: UInt32; count: Int32; var v: real)>(z_VertexAttribs1dvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1dvNV(index: UInt32; count: Int32; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribs1dvNV_2(index, count, v[0]) else
        z_VertexAttribs1dvNV_2(index, count, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1dvNV(index: UInt32; count: Int32; var v: real) :=
    z_VertexAttribs1dvNV_2(index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1dvNV(index: UInt32; count: Int32; v: IntPtr) :=
    z_VertexAttribs1dvNV_1(index, count, v);
    
    private z_VertexAttribs1fvNV_adr := GetProcAddress('glVertexAttribs1fvNV');
    private z_VertexAttribs1fvNV_1 := GetProcOrNil&<procedure(index: UInt32; count: Int32; v: IntPtr)>(z_VertexAttribs1fvNV_adr);
    private z_VertexAttribs1fvNV_2 := GetProcOrNil&<procedure(index: UInt32; count: Int32; var v: single)>(z_VertexAttribs1fvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1fvNV(index: UInt32; count: Int32; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribs1fvNV_2(index, count, v[0]) else
        z_VertexAttribs1fvNV_2(index, count, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1fvNV(index: UInt32; count: Int32; var v: single) :=
    z_VertexAttribs1fvNV_2(index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1fvNV(index: UInt32; count: Int32; v: IntPtr) :=
    z_VertexAttribs1fvNV_1(index, count, v);
    
    private z_VertexAttribs1svNV_adr := GetProcAddress('glVertexAttribs1svNV');
    private z_VertexAttribs1svNV_1 := GetProcOrNil&<procedure(index: UInt32; count: Int32; v: IntPtr)>(z_VertexAttribs1svNV_adr);
    private z_VertexAttribs1svNV_2 := GetProcOrNil&<procedure(index: UInt32; count: Int32; var v: Int16)>(z_VertexAttribs1svNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1svNV(index: UInt32; count: Int32; v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribs1svNV_2(index, count, v[0]) else
        z_VertexAttribs1svNV_2(index, count, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1svNV(index: UInt32; count: Int32; var v: Int16) :=
    z_VertexAttribs1svNV_2(index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1svNV(index: UInt32; count: Int32; v: IntPtr) :=
    z_VertexAttribs1svNV_1(index, count, v);
    
    private z_VertexAttribs2dvNV_adr := GetProcAddress('glVertexAttribs2dvNV');
    private z_VertexAttribs2dvNV_1 := GetProcOrNil&<procedure(index: UInt32; count: Int32; v: IntPtr)>(z_VertexAttribs2dvNV_adr);
    private z_VertexAttribs2dvNV_2 := GetProcOrNil&<procedure(index: UInt32; count: Int32; var v: real)>(z_VertexAttribs2dvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2dvNV(index: UInt32; count: Int32; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribs2dvNV_2(index, count, v[0]) else
        z_VertexAttribs2dvNV_2(index, count, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2dvNV(index: UInt32; count: Int32; var v: real) :=
    z_VertexAttribs2dvNV_2(index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2dvNV(index: UInt32; count: Int32; v: IntPtr) :=
    z_VertexAttribs2dvNV_1(index, count, v);
    
    private z_VertexAttribs2fvNV_adr := GetProcAddress('glVertexAttribs2fvNV');
    private z_VertexAttribs2fvNV_1 := GetProcOrNil&<procedure(index: UInt32; count: Int32; v: IntPtr)>(z_VertexAttribs2fvNV_adr);
    private z_VertexAttribs2fvNV_2 := GetProcOrNil&<procedure(index: UInt32; count: Int32; var v: single)>(z_VertexAttribs2fvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2fvNV(index: UInt32; count: Int32; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribs2fvNV_2(index, count, v[0]) else
        z_VertexAttribs2fvNV_2(index, count, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2fvNV(index: UInt32; count: Int32; var v: single) :=
    z_VertexAttribs2fvNV_2(index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2fvNV(index: UInt32; count: Int32; v: IntPtr) :=
    z_VertexAttribs2fvNV_1(index, count, v);
    
    private z_VertexAttribs2svNV_adr := GetProcAddress('glVertexAttribs2svNV');
    private z_VertexAttribs2svNV_1 := GetProcOrNil&<procedure(index: UInt32; count: Int32; v: IntPtr)>(z_VertexAttribs2svNV_adr);
    private z_VertexAttribs2svNV_2 := GetProcOrNil&<procedure(index: UInt32; count: Int32; var v: Int16)>(z_VertexAttribs2svNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2svNV(index: UInt32; count: Int32; v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribs2svNV_2(index, count, v[0]) else
        z_VertexAttribs2svNV_2(index, count, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2svNV(index: UInt32; count: Int32; var v: Int16) :=
    z_VertexAttribs2svNV_2(index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2svNV(index: UInt32; count: Int32; v: IntPtr) :=
    z_VertexAttribs2svNV_1(index, count, v);
    
    private z_VertexAttribs3dvNV_adr := GetProcAddress('glVertexAttribs3dvNV');
    private z_VertexAttribs3dvNV_1 := GetProcOrNil&<procedure(index: UInt32; count: Int32; v: IntPtr)>(z_VertexAttribs3dvNV_adr);
    private z_VertexAttribs3dvNV_2 := GetProcOrNil&<procedure(index: UInt32; count: Int32; var v: real)>(z_VertexAttribs3dvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3dvNV(index: UInt32; count: Int32; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribs3dvNV_2(index, count, v[0]) else
        z_VertexAttribs3dvNV_2(index, count, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3dvNV(index: UInt32; count: Int32; var v: real) :=
    z_VertexAttribs3dvNV_2(index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3dvNV(index: UInt32; count: Int32; v: IntPtr) :=
    z_VertexAttribs3dvNV_1(index, count, v);
    
    private z_VertexAttribs3fvNV_adr := GetProcAddress('glVertexAttribs3fvNV');
    private z_VertexAttribs3fvNV_1 := GetProcOrNil&<procedure(index: UInt32; count: Int32; v: IntPtr)>(z_VertexAttribs3fvNV_adr);
    private z_VertexAttribs3fvNV_2 := GetProcOrNil&<procedure(index: UInt32; count: Int32; var v: single)>(z_VertexAttribs3fvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3fvNV(index: UInt32; count: Int32; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribs3fvNV_2(index, count, v[0]) else
        z_VertexAttribs3fvNV_2(index, count, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3fvNV(index: UInt32; count: Int32; var v: single) :=
    z_VertexAttribs3fvNV_2(index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3fvNV(index: UInt32; count: Int32; v: IntPtr) :=
    z_VertexAttribs3fvNV_1(index, count, v);
    
    private z_VertexAttribs3svNV_adr := GetProcAddress('glVertexAttribs3svNV');
    private z_VertexAttribs3svNV_1 := GetProcOrNil&<procedure(index: UInt32; count: Int32; v: IntPtr)>(z_VertexAttribs3svNV_adr);
    private z_VertexAttribs3svNV_2 := GetProcOrNil&<procedure(index: UInt32; count: Int32; var v: Int16)>(z_VertexAttribs3svNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3svNV(index: UInt32; count: Int32; v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribs3svNV_2(index, count, v[0]) else
        z_VertexAttribs3svNV_2(index, count, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3svNV(index: UInt32; count: Int32; var v: Int16) :=
    z_VertexAttribs3svNV_2(index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3svNV(index: UInt32; count: Int32; v: IntPtr) :=
    z_VertexAttribs3svNV_1(index, count, v);
    
    private z_VertexAttribs4dvNV_adr := GetProcAddress('glVertexAttribs4dvNV');
    private z_VertexAttribs4dvNV_1 := GetProcOrNil&<procedure(index: UInt32; count: Int32; v: IntPtr)>(z_VertexAttribs4dvNV_adr);
    private z_VertexAttribs4dvNV_2 := GetProcOrNil&<procedure(index: UInt32; count: Int32; var v: real)>(z_VertexAttribs4dvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4dvNV(index: UInt32; count: Int32; v: array of real);
    type Preal=^real;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribs4dvNV_2(index, count, v[0]) else
        z_VertexAttribs4dvNV_2(index, count, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4dvNV(index: UInt32; count: Int32; var v: real) :=
    z_VertexAttribs4dvNV_2(index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4dvNV(index: UInt32; count: Int32; v: IntPtr) :=
    z_VertexAttribs4dvNV_1(index, count, v);
    
    private z_VertexAttribs4fvNV_adr := GetProcAddress('glVertexAttribs4fvNV');
    private z_VertexAttribs4fvNV_1 := GetProcOrNil&<procedure(index: UInt32; count: Int32; v: IntPtr)>(z_VertexAttribs4fvNV_adr);
    private z_VertexAttribs4fvNV_2 := GetProcOrNil&<procedure(index: UInt32; count: Int32; var v: single)>(z_VertexAttribs4fvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4fvNV(index: UInt32; count: Int32; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribs4fvNV_2(index, count, v[0]) else
        z_VertexAttribs4fvNV_2(index, count, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4fvNV(index: UInt32; count: Int32; var v: single) :=
    z_VertexAttribs4fvNV_2(index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4fvNV(index: UInt32; count: Int32; v: IntPtr) :=
    z_VertexAttribs4fvNV_1(index, count, v);
    
    private z_VertexAttribs4svNV_adr := GetProcAddress('glVertexAttribs4svNV');
    private z_VertexAttribs4svNV_1 := GetProcOrNil&<procedure(index: UInt32; count: Int32; v: IntPtr)>(z_VertexAttribs4svNV_adr);
    private z_VertexAttribs4svNV_2 := GetProcOrNil&<procedure(index: UInt32; count: Int32; var v: Int16)>(z_VertexAttribs4svNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4svNV(index: UInt32; count: Int32; v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribs4svNV_2(index, count, v[0]) else
        z_VertexAttribs4svNV_2(index, count, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4svNV(index: UInt32; count: Int32; var v: Int16) :=
    z_VertexAttribs4svNV_2(index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4svNV(index: UInt32; count: Int32; v: IntPtr) :=
    z_VertexAttribs4svNV_1(index, count, v);
    
    private z_VertexAttribs4ubvNV_adr := GetProcAddress('glVertexAttribs4ubvNV');
    private z_VertexAttribs4ubvNV_1 := GetProcOrNil&<procedure(index: UInt32; count: Int32; v: IntPtr)>(z_VertexAttribs4ubvNV_adr);
    private z_VertexAttribs4ubvNV_2 := GetProcOrNil&<procedure(index: UInt32; count: Int32; var v: Byte)>(z_VertexAttribs4ubvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4ubvNV(index: UInt32; count: Int32; v: array of Byte);
    type PByte=^Byte;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribs4ubvNV_2(index, count, v[0]) else
        z_VertexAttribs4ubvNV_2(index, count, PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4ubvNV(index: UInt32; count: Int32; var v: Byte) :=
    z_VertexAttribs4ubvNV_2(index, count, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4ubvNV(index: UInt32; count: Int32; v: IntPtr) :=
    z_VertexAttribs4ubvNV_1(index, count, v);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glVertexProgram4NV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_vertex_program4';
    
    private z_VertexAttribI1iEXT_adr := GetProcAddress('glVertexAttribI1iEXT');
    private z_VertexAttribI1iEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: Int32)>(z_VertexAttribI1iEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1iEXT(index: UInt32; x: Int32) :=
    z_VertexAttribI1iEXT_1(index, x);
    
    private z_VertexAttribI2iEXT_adr := GetProcAddress('glVertexAttribI2iEXT');
    private z_VertexAttribI2iEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: Int32; y: Int32)>(z_VertexAttribI2iEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2iEXT(index: UInt32; x: Int32; y: Int32) :=
    z_VertexAttribI2iEXT_1(index, x, y);
    
    private z_VertexAttribI3iEXT_adr := GetProcAddress('glVertexAttribI3iEXT');
    private z_VertexAttribI3iEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: Int32; y: Int32; z: Int32)>(z_VertexAttribI3iEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3iEXT(index: UInt32; x: Int32; y: Int32; z: Int32) :=
    z_VertexAttribI3iEXT_1(index, x, y, z);
    
    private z_VertexAttribI4iEXT_adr := GetProcAddress('glVertexAttribI4iEXT');
    private z_VertexAttribI4iEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32)>(z_VertexAttribI4iEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4iEXT(index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32) :=
    z_VertexAttribI4iEXT_1(index, x, y, z, w);
    
    private z_VertexAttribI1uiEXT_adr := GetProcAddress('glVertexAttribI1uiEXT');
    private z_VertexAttribI1uiEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: UInt32)>(z_VertexAttribI1uiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1uiEXT(index: UInt32; x: UInt32) :=
    z_VertexAttribI1uiEXT_1(index, x);
    
    private z_VertexAttribI2uiEXT_adr := GetProcAddress('glVertexAttribI2uiEXT');
    private z_VertexAttribI2uiEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: UInt32; y: UInt32)>(z_VertexAttribI2uiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2uiEXT(index: UInt32; x: UInt32; y: UInt32) :=
    z_VertexAttribI2uiEXT_1(index, x, y);
    
    private z_VertexAttribI3uiEXT_adr := GetProcAddress('glVertexAttribI3uiEXT');
    private z_VertexAttribI3uiEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: UInt32; y: UInt32; z: UInt32)>(z_VertexAttribI3uiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3uiEXT(index: UInt32; x: UInt32; y: UInt32; z: UInt32) :=
    z_VertexAttribI3uiEXT_1(index, x, y, z);
    
    private z_VertexAttribI4uiEXT_adr := GetProcAddress('glVertexAttribI4uiEXT');
    private z_VertexAttribI4uiEXT_1 := GetProcOrNil&<procedure(index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32)>(z_VertexAttribI4uiEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4uiEXT(index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32) :=
    z_VertexAttribI4uiEXT_1(index, x, y, z, w);
    
    private z_VertexAttribI1ivEXT_adr := GetProcAddress('glVertexAttribI1ivEXT');
    private z_VertexAttribI1ivEXT_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribI1ivEXT_adr);
    private z_VertexAttribI1ivEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(z_VertexAttribI1ivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1ivEXT(index: UInt32; v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribI1ivEXT_2(index, v[0]) else
        z_VertexAttribI1ivEXT_2(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1ivEXT(index: UInt32; var v: Int32) :=
    z_VertexAttribI1ivEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1ivEXT(index: UInt32; v: IntPtr) :=
    z_VertexAttribI1ivEXT_1(index, v);
    
    private z_VertexAttribI2ivEXT_adr := GetProcAddress('glVertexAttribI2ivEXT');
    private z_VertexAttribI2ivEXT_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribI2ivEXT_adr);
    private z_VertexAttribI2ivEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(z_VertexAttribI2ivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2ivEXT(index: UInt32; v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribI2ivEXT_2(index, v[0]) else
        z_VertexAttribI2ivEXT_2(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2ivEXT(index: UInt32; var v: Int32) :=
    z_VertexAttribI2ivEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2ivEXT(index: UInt32; v: IntPtr) :=
    z_VertexAttribI2ivEXT_1(index, v);
    
    private z_VertexAttribI3ivEXT_adr := GetProcAddress('glVertexAttribI3ivEXT');
    private z_VertexAttribI3ivEXT_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribI3ivEXT_adr);
    private z_VertexAttribI3ivEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(z_VertexAttribI3ivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3ivEXT(index: UInt32; v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribI3ivEXT_2(index, v[0]) else
        z_VertexAttribI3ivEXT_2(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3ivEXT(index: UInt32; var v: Int32) :=
    z_VertexAttribI3ivEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3ivEXT(index: UInt32; v: IntPtr) :=
    z_VertexAttribI3ivEXT_1(index, v);
    
    private z_VertexAttribI4ivEXT_adr := GetProcAddress('glVertexAttribI4ivEXT');
    private z_VertexAttribI4ivEXT_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribI4ivEXT_adr);
    private z_VertexAttribI4ivEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int32)>(z_VertexAttribI4ivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ivEXT(index: UInt32; v: array of Int32);
    type PInt32=^Int32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribI4ivEXT_2(index, v[0]) else
        z_VertexAttribI4ivEXT_2(index, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ivEXT(index: UInt32; var v: Int32) :=
    z_VertexAttribI4ivEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ivEXT(index: UInt32; v: IntPtr) :=
    z_VertexAttribI4ivEXT_1(index, v);
    
    private z_VertexAttribI1uivEXT_adr := GetProcAddress('glVertexAttribI1uivEXT');
    private z_VertexAttribI1uivEXT_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribI1uivEXT_adr);
    private z_VertexAttribI1uivEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: UInt32)>(z_VertexAttribI1uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1uivEXT(index: UInt32; v: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribI1uivEXT_2(index, v[0]) else
        z_VertexAttribI1uivEXT_2(index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1uivEXT(index: UInt32; var v: UInt32) :=
    z_VertexAttribI1uivEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1uivEXT(index: UInt32; v: IntPtr) :=
    z_VertexAttribI1uivEXT_1(index, v);
    
    private z_VertexAttribI2uivEXT_adr := GetProcAddress('glVertexAttribI2uivEXT');
    private z_VertexAttribI2uivEXT_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribI2uivEXT_adr);
    private z_VertexAttribI2uivEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: UInt32)>(z_VertexAttribI2uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2uivEXT(index: UInt32; v: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribI2uivEXT_2(index, v[0]) else
        z_VertexAttribI2uivEXT_2(index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2uivEXT(index: UInt32; var v: UInt32) :=
    z_VertexAttribI2uivEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2uivEXT(index: UInt32; v: IntPtr) :=
    z_VertexAttribI2uivEXT_1(index, v);
    
    private z_VertexAttribI3uivEXT_adr := GetProcAddress('glVertexAttribI3uivEXT');
    private z_VertexAttribI3uivEXT_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribI3uivEXT_adr);
    private z_VertexAttribI3uivEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: UInt32)>(z_VertexAttribI3uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3uivEXT(index: UInt32; v: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribI3uivEXT_2(index, v[0]) else
        z_VertexAttribI3uivEXT_2(index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3uivEXT(index: UInt32; var v: UInt32) :=
    z_VertexAttribI3uivEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3uivEXT(index: UInt32; v: IntPtr) :=
    z_VertexAttribI3uivEXT_1(index, v);
    
    private z_VertexAttribI4uivEXT_adr := GetProcAddress('glVertexAttribI4uivEXT');
    private z_VertexAttribI4uivEXT_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribI4uivEXT_adr);
    private z_VertexAttribI4uivEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: UInt32)>(z_VertexAttribI4uivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4uivEXT(index: UInt32; v: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribI4uivEXT_2(index, v[0]) else
        z_VertexAttribI4uivEXT_2(index, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4uivEXT(index: UInt32; var v: UInt32) :=
    z_VertexAttribI4uivEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4uivEXT(index: UInt32; v: IntPtr) :=
    z_VertexAttribI4uivEXT_1(index, v);
    
    private z_VertexAttribI4bvEXT_adr := GetProcAddress('glVertexAttribI4bvEXT');
    private z_VertexAttribI4bvEXT_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribI4bvEXT_adr);
    private z_VertexAttribI4bvEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: SByte)>(z_VertexAttribI4bvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4bvEXT(index: UInt32; v: array of SByte);
    type PSByte=^SByte;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribI4bvEXT_2(index, v[0]) else
        z_VertexAttribI4bvEXT_2(index, PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4bvEXT(index: UInt32; var v: SByte) :=
    z_VertexAttribI4bvEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4bvEXT(index: UInt32; v: IntPtr) :=
    z_VertexAttribI4bvEXT_1(index, v);
    
    private z_VertexAttribI4svEXT_adr := GetProcAddress('glVertexAttribI4svEXT');
    private z_VertexAttribI4svEXT_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribI4svEXT_adr);
    private z_VertexAttribI4svEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: Int16)>(z_VertexAttribI4svEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4svEXT(index: UInt32; v: array of Int16);
    type PInt16=^Int16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribI4svEXT_2(index, v[0]) else
        z_VertexAttribI4svEXT_2(index, PInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4svEXT(index: UInt32; var v: Int16) :=
    z_VertexAttribI4svEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4svEXT(index: UInt32; v: IntPtr) :=
    z_VertexAttribI4svEXT_1(index, v);
    
    private z_VertexAttribI4ubvEXT_adr := GetProcAddress('glVertexAttribI4ubvEXT');
    private z_VertexAttribI4ubvEXT_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribI4ubvEXT_adr);
    private z_VertexAttribI4ubvEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: Byte)>(z_VertexAttribI4ubvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ubvEXT(index: UInt32; v: array of Byte);
    type PByte=^Byte;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribI4ubvEXT_2(index, v[0]) else
        z_VertexAttribI4ubvEXT_2(index, PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ubvEXT(index: UInt32; var v: Byte) :=
    z_VertexAttribI4ubvEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ubvEXT(index: UInt32; v: IntPtr) :=
    z_VertexAttribI4ubvEXT_1(index, v);
    
    private z_VertexAttribI4usvEXT_adr := GetProcAddress('glVertexAttribI4usvEXT');
    private z_VertexAttribI4usvEXT_1 := GetProcOrNil&<procedure(index: UInt32; v: IntPtr)>(z_VertexAttribI4usvEXT_adr);
    private z_VertexAttribI4usvEXT_2 := GetProcOrNil&<procedure(index: UInt32; var v: UInt16)>(z_VertexAttribI4usvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4usvEXT(index: UInt32; v: array of UInt16);
    type PUInt16=^UInt16;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_VertexAttribI4usvEXT_2(index, v[0]) else
        z_VertexAttribI4usvEXT_2(index, PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4usvEXT(index: UInt32; var v: UInt16) :=
    z_VertexAttribI4usvEXT_2(index, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4usvEXT(index: UInt32; v: IntPtr) :=
    z_VertexAttribI4usvEXT_1(index, v);
    
    private z_VertexAttribIPointerEXT_adr := GetProcAddress('glVertexAttribIPointerEXT');
    private z_VertexAttribIPointerEXT_1 := GetProcOrNil&<procedure(index: UInt32; size: Int32; &type: VertexAttribIType; stride: Int32; pointer: IntPtr)>(z_VertexAttribIPointerEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribIPointerEXT(index: UInt32; size: Int32; &type: VertexAttribIType; stride: Int32; pointer: IntPtr) :=
    z_VertexAttribIPointerEXT_1(index, size, &type, stride, pointer);
    
    private z_GetVertexAttribIivEXT_adr := GetProcAddress('glGetVertexAttribIivEXT');
    private z_GetVertexAttribIivEXT_1 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribEnum; &params: IntPtr)>(z_GetVertexAttribIivEXT_adr);
    private z_GetVertexAttribIivEXT_2 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribEnum; var &params: Int32)>(z_GetVertexAttribIivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIivEXT(index: UInt32; pname: VertexAttribEnum; var &params: Int32) :=
    z_GetVertexAttribIivEXT_2(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIivEXT(index: UInt32; pname: VertexAttribEnum; &params: IntPtr) :=
    z_GetVertexAttribIivEXT_1(index, pname, &params);
    
    private z_GetVertexAttribIuivEXT_adr := GetProcAddress('glGetVertexAttribIuivEXT');
    private z_GetVertexAttribIuivEXT_1 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribEnum; &params: IntPtr)>(z_GetVertexAttribIuivEXT_adr);
    private z_GetVertexAttribIuivEXT_2 := GetProcOrNil&<procedure(index: UInt32; pname: VertexAttribEnum; var &params: UInt32)>(z_GetVertexAttribIuivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIuivEXT(index: UInt32; pname: VertexAttribEnum; var &params: UInt32) :=
    z_GetVertexAttribIuivEXT_2(index, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIuivEXT(index: UInt32; pname: VertexAttribEnum; &params: IntPtr) :=
    z_GetVertexAttribIuivEXT_1(index, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glVideoCaptureNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_video_capture';
    
    private z_BeginVideoCaptureNV_adr := GetProcAddress('glBeginVideoCaptureNV');
    private z_BeginVideoCaptureNV_1 := GetProcOrNil&<procedure(video_capture_slot: UInt32)>(z_BeginVideoCaptureNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginVideoCaptureNV(video_capture_slot: UInt32) :=
    z_BeginVideoCaptureNV_1(video_capture_slot);
    
    private z_BindVideoCaptureStreamBufferNV_adr := GetProcAddress('glBindVideoCaptureStreamBufferNV');
    private z_BindVideoCaptureStreamBufferNV_1 := GetProcOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; frame_region: DummyEnum; offset: IntPtr)>(z_BindVideoCaptureStreamBufferNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVideoCaptureStreamBufferNV(video_capture_slot: UInt32; stream: UInt32; frame_region: DummyEnum; offset: IntPtr) :=
    z_BindVideoCaptureStreamBufferNV_1(video_capture_slot, stream, frame_region, offset);
    
    private z_BindVideoCaptureStreamTextureNV_adr := GetProcAddress('glBindVideoCaptureStreamTextureNV');
    private z_BindVideoCaptureStreamTextureNV_1 := GetProcOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; frame_region: DummyEnum; target: DummyEnum; texture: gl_texture)>(z_BindVideoCaptureStreamTextureNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVideoCaptureStreamTextureNV(video_capture_slot: UInt32; stream: UInt32; frame_region: DummyEnum; target: DummyEnum; texture: gl_texture) :=
    z_BindVideoCaptureStreamTextureNV_1(video_capture_slot, stream, frame_region, target, texture);
    
    private z_EndVideoCaptureNV_adr := GetProcAddress('glEndVideoCaptureNV');
    private z_EndVideoCaptureNV_1 := GetProcOrNil&<procedure(video_capture_slot: UInt32)>(z_EndVideoCaptureNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndVideoCaptureNV(video_capture_slot: UInt32) :=
    z_EndVideoCaptureNV_1(video_capture_slot);
    
    private z_GetVideoCaptureivNV_adr := GetProcAddress('glGetVideoCaptureivNV');
    private z_GetVideoCaptureivNV_1 := GetProcOrNil&<procedure(video_capture_slot: UInt32; pname: DummyEnum; &params: IntPtr)>(z_GetVideoCaptureivNV_adr);
    private z_GetVideoCaptureivNV_2 := GetProcOrNil&<procedure(video_capture_slot: UInt32; pname: DummyEnum; var &params: Int32)>(z_GetVideoCaptureivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureivNV(video_capture_slot: UInt32; pname: DummyEnum; var &params: Int32) :=
    z_GetVideoCaptureivNV_2(video_capture_slot, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureivNV(video_capture_slot: UInt32; pname: DummyEnum; &params: IntPtr) :=
    z_GetVideoCaptureivNV_1(video_capture_slot, pname, &params);
    
    private z_GetVideoCaptureStreamivNV_adr := GetProcAddress('glGetVideoCaptureStreamivNV');
    private z_GetVideoCaptureStreamivNV_1 := GetProcOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: IntPtr)>(z_GetVideoCaptureStreamivNV_adr);
    private z_GetVideoCaptureStreamivNV_2 := GetProcOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: Int32)>(z_GetVideoCaptureStreamivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureStreamivNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: Int32) :=
    z_GetVideoCaptureStreamivNV_2(video_capture_slot, stream, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureStreamivNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: IntPtr) :=
    z_GetVideoCaptureStreamivNV_1(video_capture_slot, stream, pname, &params);
    
    private z_GetVideoCaptureStreamfvNV_adr := GetProcAddress('glGetVideoCaptureStreamfvNV');
    private z_GetVideoCaptureStreamfvNV_1 := GetProcOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: IntPtr)>(z_GetVideoCaptureStreamfvNV_adr);
    private z_GetVideoCaptureStreamfvNV_2 := GetProcOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: single)>(z_GetVideoCaptureStreamfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureStreamfvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: single) :=
    z_GetVideoCaptureStreamfvNV_2(video_capture_slot, stream, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureStreamfvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: IntPtr) :=
    z_GetVideoCaptureStreamfvNV_1(video_capture_slot, stream, pname, &params);
    
    private z_GetVideoCaptureStreamdvNV_adr := GetProcAddress('glGetVideoCaptureStreamdvNV');
    private z_GetVideoCaptureStreamdvNV_1 := GetProcOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: IntPtr)>(z_GetVideoCaptureStreamdvNV_adr);
    private z_GetVideoCaptureStreamdvNV_2 := GetProcOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: real)>(z_GetVideoCaptureStreamdvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureStreamdvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: real) :=
    z_GetVideoCaptureStreamdvNV_2(video_capture_slot, stream, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureStreamdvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: IntPtr) :=
    z_GetVideoCaptureStreamdvNV_1(video_capture_slot, stream, pname, &params);
    
    private z_VideoCaptureNV_adr := GetProcAddress('glVideoCaptureNV');
    private z_VideoCaptureNV_1 := GetProcOrNil&<function(video_capture_slot: UInt32; sequence_num: IntPtr; capture_time: IntPtr): DummyEnum>(z_VideoCaptureNV_adr);
    private z_VideoCaptureNV_2 := GetProcOrNil&<function(video_capture_slot: UInt32; sequence_num: IntPtr; var capture_time: UInt64): DummyEnum>(z_VideoCaptureNV_adr);
    private z_VideoCaptureNV_3 := GetProcOrNil&<function(video_capture_slot: UInt32; var sequence_num: UInt32; capture_time: IntPtr): DummyEnum>(z_VideoCaptureNV_adr);
    private z_VideoCaptureNV_4 := GetProcOrNil&<function(video_capture_slot: UInt32; var sequence_num: UInt32; var capture_time: UInt64): DummyEnum>(z_VideoCaptureNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VideoCaptureNV(video_capture_slot: UInt32; sequence_num: array of UInt32; capture_time: array of UInt64): DummyEnum;
    type PUInt32=^UInt32;
    type PUInt64=^UInt64;
    begin
      Result := if (capture_time<>nil) and (capture_time.Length<>0) then
        if (sequence_num<>nil) and (sequence_num.Length<>0) then
          z_VideoCaptureNV_4(video_capture_slot, sequence_num[0], capture_time[0]) else
          z_VideoCaptureNV_4(video_capture_slot, PUInt32(nil)^, capture_time[0]) else
        if (sequence_num<>nil) and (sequence_num.Length<>0) then
          z_VideoCaptureNV_4(video_capture_slot, sequence_num[0], PUInt64(nil)^) else
          z_VideoCaptureNV_4(video_capture_slot, PUInt32(nil)^, PUInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VideoCaptureNV(video_capture_slot: UInt32; var sequence_num: UInt32; var capture_time: UInt64): DummyEnum :=
    z_VideoCaptureNV_4(video_capture_slot, sequence_num, capture_time);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VideoCaptureNV(video_capture_slot: UInt32; var sequence_num: UInt32; capture_time: IntPtr): DummyEnum :=
    z_VideoCaptureNV_3(video_capture_slot, sequence_num, capture_time);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VideoCaptureNV(video_capture_slot: UInt32; sequence_num: IntPtr; var capture_time: UInt64): DummyEnum :=
    z_VideoCaptureNV_2(video_capture_slot, sequence_num, capture_time);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VideoCaptureNV(video_capture_slot: UInt32; sequence_num: IntPtr; capture_time: IntPtr): DummyEnum :=
    z_VideoCaptureNV_1(video_capture_slot, sequence_num, capture_time);
    
    private z_VideoCaptureStreamParameterivNV_adr := GetProcAddress('glVideoCaptureStreamParameterivNV');
    private z_VideoCaptureStreamParameterivNV_1 := GetProcOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: IntPtr)>(z_VideoCaptureStreamParameterivNV_adr);
    private z_VideoCaptureStreamParameterivNV_2 := GetProcOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: Int32)>(z_VideoCaptureStreamParameterivNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VideoCaptureStreamParameterivNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_VideoCaptureStreamParameterivNV_2(video_capture_slot, stream, pname, &params[0]) else
        z_VideoCaptureStreamParameterivNV_2(video_capture_slot, stream, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VideoCaptureStreamParameterivNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: Int32) :=
    z_VideoCaptureStreamParameterivNV_2(video_capture_slot, stream, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VideoCaptureStreamParameterivNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: IntPtr) :=
    z_VideoCaptureStreamParameterivNV_1(video_capture_slot, stream, pname, &params);
    
    private z_VideoCaptureStreamParameterfvNV_adr := GetProcAddress('glVideoCaptureStreamParameterfvNV');
    private z_VideoCaptureStreamParameterfvNV_1 := GetProcOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: IntPtr)>(z_VideoCaptureStreamParameterfvNV_adr);
    private z_VideoCaptureStreamParameterfvNV_2 := GetProcOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: single)>(z_VideoCaptureStreamParameterfvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VideoCaptureStreamParameterfvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_VideoCaptureStreamParameterfvNV_2(video_capture_slot, stream, pname, &params[0]) else
        z_VideoCaptureStreamParameterfvNV_2(video_capture_slot, stream, pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VideoCaptureStreamParameterfvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: single) :=
    z_VideoCaptureStreamParameterfvNV_2(video_capture_slot, stream, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VideoCaptureStreamParameterfvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: IntPtr) :=
    z_VideoCaptureStreamParameterfvNV_1(video_capture_slot, stream, pname, &params);
    
    private z_VideoCaptureStreamParameterdvNV_adr := GetProcAddress('glVideoCaptureStreamParameterdvNV');
    private z_VideoCaptureStreamParameterdvNV_1 := GetProcOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: IntPtr)>(z_VideoCaptureStreamParameterdvNV_adr);
    private z_VideoCaptureStreamParameterdvNV_2 := GetProcOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: real)>(z_VideoCaptureStreamParameterdvNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VideoCaptureStreamParameterdvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: array of real);
    type Preal=^real;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_VideoCaptureStreamParameterdvNV_2(video_capture_slot, stream, pname, &params[0]) else
        z_VideoCaptureStreamParameterdvNV_2(video_capture_slot, stream, pname, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VideoCaptureStreamParameterdvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: real) :=
    z_VideoCaptureStreamParameterdvNV_2(video_capture_slot, stream, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VideoCaptureStreamParameterdvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: IntPtr) :=
    z_VideoCaptureStreamParameterdvNV_1(video_capture_slot, stream, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glViewportSwizzleNV = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_nv_viewport_swizzle';
    
    private z_ViewportSwizzleNV_adr := GetProcAddress('glViewportSwizzleNV');
    private z_ViewportSwizzleNV_1 := GetProcOrNil&<procedure(index: UInt32; swizzlex: DummyEnum; swizzley: DummyEnum; swizzlez: DummyEnum; swizzlew: DummyEnum)>(z_ViewportSwizzleNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportSwizzleNV(index: UInt32; swizzlex: DummyEnum; swizzley: DummyEnum; swizzlez: DummyEnum; swizzlew: DummyEnum) :=
    z_ViewportSwizzleNV_1(index, swizzlex, swizzley, swizzlez, swizzlew);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glByteCoordinatesOES = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_oes_byte_coordinates';
    
    private z_MultiTexCoord1bOES_adr := GetProcAddress('glMultiTexCoord1bOES');
    private z_MultiTexCoord1bOES_1 := GetProcOrNil&<procedure(texture: TextureUnit; s: SByte)>(z_MultiTexCoord1bOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1bOES(texture: TextureUnit; s: SByte) :=
    z_MultiTexCoord1bOES_1(texture, s);
    
    private z_MultiTexCoord1bvOES_adr := GetProcAddress('glMultiTexCoord1bvOES');
    private z_MultiTexCoord1bvOES_1 := GetProcOrNil&<procedure(texture: TextureUnit; coords: IntPtr)>(z_MultiTexCoord1bvOES_adr);
    private z_MultiTexCoord1bvOES_2 := GetProcOrNil&<procedure(texture: TextureUnit; var coords: SByte)>(z_MultiTexCoord1bvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1bvOES(texture: TextureUnit; coords: array of SByte);
    type PSByte=^SByte;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_MultiTexCoord1bvOES_2(texture, coords[0]) else
        z_MultiTexCoord1bvOES_2(texture, PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1bvOES(texture: TextureUnit; var coords: SByte) :=
    z_MultiTexCoord1bvOES_2(texture, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1bvOES(texture: TextureUnit; coords: IntPtr) :=
    z_MultiTexCoord1bvOES_1(texture, coords);
    
    private z_MultiTexCoord2bOES_adr := GetProcAddress('glMultiTexCoord2bOES');
    private z_MultiTexCoord2bOES_1 := GetProcOrNil&<procedure(texture: TextureUnit; s: SByte; t: SByte)>(z_MultiTexCoord2bOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2bOES(texture: TextureUnit; s: SByte; t: SByte) :=
    z_MultiTexCoord2bOES_1(texture, s, t);
    
    private z_MultiTexCoord2bvOES_adr := GetProcAddress('glMultiTexCoord2bvOES');
    private z_MultiTexCoord2bvOES_1 := GetProcOrNil&<procedure(texture: TextureUnit; coords: IntPtr)>(z_MultiTexCoord2bvOES_adr);
    private z_MultiTexCoord2bvOES_2 := GetProcOrNil&<procedure(texture: TextureUnit; var coords: SByte)>(z_MultiTexCoord2bvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2bvOES(texture: TextureUnit; coords: array of SByte);
    type PSByte=^SByte;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_MultiTexCoord2bvOES_2(texture, coords[0]) else
        z_MultiTexCoord2bvOES_2(texture, PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2bvOES(texture: TextureUnit; var coords: SByte) :=
    z_MultiTexCoord2bvOES_2(texture, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2bvOES(texture: TextureUnit; coords: IntPtr) :=
    z_MultiTexCoord2bvOES_1(texture, coords);
    
    private z_MultiTexCoord3bOES_adr := GetProcAddress('glMultiTexCoord3bOES');
    private z_MultiTexCoord3bOES_1 := GetProcOrNil&<procedure(texture: TextureUnit; s: SByte; t: SByte; r: SByte)>(z_MultiTexCoord3bOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3bOES(texture: TextureUnit; s: SByte; t: SByte; r: SByte) :=
    z_MultiTexCoord3bOES_1(texture, s, t, r);
    
    private z_MultiTexCoord3bvOES_adr := GetProcAddress('glMultiTexCoord3bvOES');
    private z_MultiTexCoord3bvOES_1 := GetProcOrNil&<procedure(texture: TextureUnit; coords: IntPtr)>(z_MultiTexCoord3bvOES_adr);
    private z_MultiTexCoord3bvOES_2 := GetProcOrNil&<procedure(texture: TextureUnit; var coords: SByte)>(z_MultiTexCoord3bvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3bvOES(texture: TextureUnit; coords: array of SByte);
    type PSByte=^SByte;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_MultiTexCoord3bvOES_2(texture, coords[0]) else
        z_MultiTexCoord3bvOES_2(texture, PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3bvOES(texture: TextureUnit; var coords: SByte) :=
    z_MultiTexCoord3bvOES_2(texture, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3bvOES(texture: TextureUnit; coords: IntPtr) :=
    z_MultiTexCoord3bvOES_1(texture, coords);
    
    private z_MultiTexCoord4bOES_adr := GetProcAddress('glMultiTexCoord4bOES');
    private z_MultiTexCoord4bOES_1 := GetProcOrNil&<procedure(texture: TextureUnit; s: SByte; t: SByte; r: SByte; q: SByte)>(z_MultiTexCoord4bOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4bOES(texture: TextureUnit; s: SByte; t: SByte; r: SByte; q: SByte) :=
    z_MultiTexCoord4bOES_1(texture, s, t, r, q);
    
    private z_MultiTexCoord4bvOES_adr := GetProcAddress('glMultiTexCoord4bvOES');
    private z_MultiTexCoord4bvOES_1 := GetProcOrNil&<procedure(texture: TextureUnit; coords: IntPtr)>(z_MultiTexCoord4bvOES_adr);
    private z_MultiTexCoord4bvOES_2 := GetProcOrNil&<procedure(texture: TextureUnit; var coords: SByte)>(z_MultiTexCoord4bvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4bvOES(texture: TextureUnit; coords: array of SByte);
    type PSByte=^SByte;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_MultiTexCoord4bvOES_2(texture, coords[0]) else
        z_MultiTexCoord4bvOES_2(texture, PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4bvOES(texture: TextureUnit; var coords: SByte) :=
    z_MultiTexCoord4bvOES_2(texture, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4bvOES(texture: TextureUnit; coords: IntPtr) :=
    z_MultiTexCoord4bvOES_1(texture, coords);
    
    private z_TexCoord1bOES_adr := GetProcAddress('glTexCoord1bOES');
    private z_TexCoord1bOES_1 := GetProcOrNil&<procedure(s: SByte)>(z_TexCoord1bOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1bOES(s: SByte) :=
    z_TexCoord1bOES_1(s);
    
    private z_TexCoord1bvOES_adr := GetProcAddress('glTexCoord1bvOES');
    private z_TexCoord1bvOES_1 := GetProcOrNil&<procedure(coords: IntPtr)>(z_TexCoord1bvOES_adr);
    private z_TexCoord1bvOES_2 := GetProcOrNil&<procedure(var coords: SByte)>(z_TexCoord1bvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1bvOES(coords: array of SByte);
    type PSByte=^SByte;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_TexCoord1bvOES_2(coords[0]) else
        z_TexCoord1bvOES_2(PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1bvOES(var coords: SByte) :=
    z_TexCoord1bvOES_2(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1bvOES(coords: IntPtr) :=
    z_TexCoord1bvOES_1(coords);
    
    private z_TexCoord2bOES_adr := GetProcAddress('glTexCoord2bOES');
    private z_TexCoord2bOES_1 := GetProcOrNil&<procedure(s: SByte; t: SByte)>(z_TexCoord2bOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2bOES(s: SByte; t: SByte) :=
    z_TexCoord2bOES_1(s, t);
    
    private z_TexCoord2bvOES_adr := GetProcAddress('glTexCoord2bvOES');
    private z_TexCoord2bvOES_1 := GetProcOrNil&<procedure(coords: IntPtr)>(z_TexCoord2bvOES_adr);
    private z_TexCoord2bvOES_2 := GetProcOrNil&<procedure(var coords: SByte)>(z_TexCoord2bvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2bvOES(coords: array of SByte);
    type PSByte=^SByte;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_TexCoord2bvOES_2(coords[0]) else
        z_TexCoord2bvOES_2(PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2bvOES(var coords: SByte) :=
    z_TexCoord2bvOES_2(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2bvOES(coords: IntPtr) :=
    z_TexCoord2bvOES_1(coords);
    
    private z_TexCoord3bOES_adr := GetProcAddress('glTexCoord3bOES');
    private z_TexCoord3bOES_1 := GetProcOrNil&<procedure(s: SByte; t: SByte; r: SByte)>(z_TexCoord3bOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3bOES(s: SByte; t: SByte; r: SByte) :=
    z_TexCoord3bOES_1(s, t, r);
    
    private z_TexCoord3bvOES_adr := GetProcAddress('glTexCoord3bvOES');
    private z_TexCoord3bvOES_1 := GetProcOrNil&<procedure(coords: IntPtr)>(z_TexCoord3bvOES_adr);
    private z_TexCoord3bvOES_2 := GetProcOrNil&<procedure(var coords: SByte)>(z_TexCoord3bvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3bvOES(coords: array of SByte);
    type PSByte=^SByte;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_TexCoord3bvOES_2(coords[0]) else
        z_TexCoord3bvOES_2(PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3bvOES(var coords: SByte) :=
    z_TexCoord3bvOES_2(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3bvOES(coords: IntPtr) :=
    z_TexCoord3bvOES_1(coords);
    
    private z_TexCoord4bOES_adr := GetProcAddress('glTexCoord4bOES');
    private z_TexCoord4bOES_1 := GetProcOrNil&<procedure(s: SByte; t: SByte; r: SByte; q: SByte)>(z_TexCoord4bOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4bOES(s: SByte; t: SByte; r: SByte; q: SByte) :=
    z_TexCoord4bOES_1(s, t, r, q);
    
    private z_TexCoord4bvOES_adr := GetProcAddress('glTexCoord4bvOES');
    private z_TexCoord4bvOES_1 := GetProcOrNil&<procedure(coords: IntPtr)>(z_TexCoord4bvOES_adr);
    private z_TexCoord4bvOES_2 := GetProcOrNil&<procedure(var coords: SByte)>(z_TexCoord4bvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4bvOES(coords: array of SByte);
    type PSByte=^SByte;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_TexCoord4bvOES_2(coords[0]) else
        z_TexCoord4bvOES_2(PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4bvOES(var coords: SByte) :=
    z_TexCoord4bvOES_2(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4bvOES(coords: IntPtr) :=
    z_TexCoord4bvOES_1(coords);
    
    private z_Vertex2bOES_adr := GetProcAddress('glVertex2bOES');
    private z_Vertex2bOES_1 := GetProcOrNil&<procedure(x: SByte; y: SByte)>(z_Vertex2bOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2bOES(x: SByte; y: SByte) :=
    z_Vertex2bOES_1(x, y);
    
    private z_Vertex2bvOES_adr := GetProcAddress('glVertex2bvOES');
    private z_Vertex2bvOES_1 := GetProcOrNil&<procedure(coords: IntPtr)>(z_Vertex2bvOES_adr);
    private z_Vertex2bvOES_2 := GetProcOrNil&<procedure(var coords: SByte)>(z_Vertex2bvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2bvOES(coords: array of SByte);
    type PSByte=^SByte;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_Vertex2bvOES_2(coords[0]) else
        z_Vertex2bvOES_2(PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2bvOES(var coords: SByte) :=
    z_Vertex2bvOES_2(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2bvOES(coords: IntPtr) :=
    z_Vertex2bvOES_1(coords);
    
    private z_Vertex3bOES_adr := GetProcAddress('glVertex3bOES');
    private z_Vertex3bOES_1 := GetProcOrNil&<procedure(x: SByte; y: SByte; z: SByte)>(z_Vertex3bOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3bOES(x: SByte; y: SByte; z: SByte) :=
    z_Vertex3bOES_1(x, y, z);
    
    private z_Vertex3bvOES_adr := GetProcAddress('glVertex3bvOES');
    private z_Vertex3bvOES_1 := GetProcOrNil&<procedure(coords: IntPtr)>(z_Vertex3bvOES_adr);
    private z_Vertex3bvOES_2 := GetProcOrNil&<procedure(var coords: SByte)>(z_Vertex3bvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3bvOES(coords: array of SByte);
    type PSByte=^SByte;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_Vertex3bvOES_2(coords[0]) else
        z_Vertex3bvOES_2(PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3bvOES(var coords: SByte) :=
    z_Vertex3bvOES_2(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3bvOES(coords: IntPtr) :=
    z_Vertex3bvOES_1(coords);
    
    private z_Vertex4bOES_adr := GetProcAddress('glVertex4bOES');
    private z_Vertex4bOES_1 := GetProcOrNil&<procedure(x: SByte; y: SByte; z: SByte; w: SByte)>(z_Vertex4bOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4bOES(x: SByte; y: SByte; z: SByte; w: SByte) :=
    z_Vertex4bOES_1(x, y, z, w);
    
    private z_Vertex4bvOES_adr := GetProcAddress('glVertex4bvOES');
    private z_Vertex4bvOES_1 := GetProcOrNil&<procedure(coords: IntPtr)>(z_Vertex4bvOES_adr);
    private z_Vertex4bvOES_2 := GetProcOrNil&<procedure(var coords: SByte)>(z_Vertex4bvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4bvOES(coords: array of SByte);
    type PSByte=^SByte;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_Vertex4bvOES_2(coords[0]) else
        z_Vertex4bvOES_2(PSByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4bvOES(var coords: SByte) :=
    z_Vertex4bvOES_2(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4bvOES(coords: IntPtr) :=
    z_Vertex4bvOES_1(coords);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glFixedPointOES = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_oes_fixed_point';
    
    private z_AlphaFuncxOES_adr := GetProcAddress('glAlphaFuncxOES');
    private z_AlphaFuncxOES_1 := GetProcOrNil&<procedure(func: AlphaFunction; ref: Fixed)>(z_AlphaFuncxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AlphaFuncxOES(func: AlphaFunction; ref: Fixed) :=
    z_AlphaFuncxOES_1(func, ref);
    
    private z_ClearColorxOES_adr := GetProcAddress('glClearColorxOES');
    private z_ClearColorxOES_1 := GetProcOrNil&<procedure(red: Fixed; green: Fixed; blue: Fixed; alpha: Fixed)>(z_ClearColorxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearColorxOES(red: Fixed; green: Fixed; blue: Fixed; alpha: Fixed) :=
    z_ClearColorxOES_1(red, green, blue, alpha);
    
    private z_ClearDepthxOES_adr := GetProcAddress('glClearDepthxOES');
    private z_ClearDepthxOES_1 := GetProcOrNil&<procedure(depth: Fixed)>(z_ClearDepthxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearDepthxOES(depth: Fixed) :=
    z_ClearDepthxOES_1(depth);
    
    private z_ClipPlanexOES_adr := GetProcAddress('glClipPlanexOES');
    private z_ClipPlanexOES_1 := GetProcOrNil&<procedure(plane: ClipPlaneName; equation: IntPtr)>(z_ClipPlanexOES_adr);
    private z_ClipPlanexOES_2 := GetProcOrNil&<procedure(plane: ClipPlaneName; var equation: Fixed)>(z_ClipPlanexOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlanexOES(plane: ClipPlaneName; equation: array of Fixed);
    type PFixed=^Fixed;
    begin
      if (equation<>nil) and (equation.Length<>0) then
        z_ClipPlanexOES_2(plane, equation[0]) else
        z_ClipPlanexOES_2(plane, PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlanexOES(plane: ClipPlaneName; var equation: Fixed) :=
    z_ClipPlanexOES_2(plane, equation);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlanexOES(plane: ClipPlaneName; equation: IntPtr) :=
    z_ClipPlanexOES_1(plane, equation);
    
    private z_Color4xOES_adr := GetProcAddress('glColor4xOES');
    private z_Color4xOES_1 := GetProcOrNil&<procedure(red: Fixed; green: Fixed; blue: Fixed; alpha: Fixed)>(z_Color4xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4xOES(red: Fixed; green: Fixed; blue: Fixed; alpha: Fixed) :=
    z_Color4xOES_1(red, green, blue, alpha);
    
    private z_DepthRangexOES_adr := GetProcAddress('glDepthRangexOES');
    private z_DepthRangexOES_1 := GetProcOrNil&<procedure(n: Fixed; f: Fixed)>(z_DepthRangexOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangexOES(n: Fixed; f: Fixed) :=
    z_DepthRangexOES_1(n, f);
    
    private z_FogxOES_adr := GetProcAddress('glFogxOES');
    private z_FogxOES_1 := GetProcOrNil&<procedure(pname: FogPName; param: Fixed)>(z_FogxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogxOES(pname: FogPName; param: Fixed) :=
    z_FogxOES_1(pname, param);
    
    private z_FogxvOES_adr := GetProcAddress('glFogxvOES');
    private z_FogxvOES_1 := GetProcOrNil&<procedure(pname: FogPName; param: IntPtr)>(z_FogxvOES_adr);
    private z_FogxvOES_2 := GetProcOrNil&<procedure(pname: FogPName; var param: Fixed)>(z_FogxvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogxvOES(pname: FogPName; param: array of Fixed);
    type PFixed=^Fixed;
    begin
      if (param<>nil) and (param.Length<>0) then
        z_FogxvOES_2(pname, param[0]) else
        z_FogxvOES_2(pname, PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogxvOES(pname: FogPName; var param: Fixed) :=
    z_FogxvOES_2(pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogxvOES(pname: FogPName; param: IntPtr) :=
    z_FogxvOES_1(pname, param);
    
    private z_FrustumxOES_adr := GetProcAddress('glFrustumxOES');
    private z_FrustumxOES_1 := GetProcOrNil&<procedure(l: Fixed; r: Fixed; b: Fixed; t: Fixed; n: Fixed; f: Fixed)>(z_FrustumxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FrustumxOES(l: Fixed; r: Fixed; b: Fixed; t: Fixed; n: Fixed; f: Fixed) :=
    z_FrustumxOES_1(l, r, b, t, n, f);
    
    private z_GetClipPlanexOES_adr := GetProcAddress('glGetClipPlanexOES');
    private z_GetClipPlanexOES_1 := GetProcOrNil&<procedure(plane: ClipPlaneName; equation: IntPtr)>(z_GetClipPlanexOES_adr);
    private z_GetClipPlanexOES_2 := GetProcOrNil&<procedure(plane: ClipPlaneName; var equation: Fixed)>(z_GetClipPlanexOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetClipPlanexOES(plane: ClipPlaneName; var equation: Fixed) :=
    z_GetClipPlanexOES_2(plane, equation);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetClipPlanexOES(plane: ClipPlaneName; equation: IntPtr) :=
    z_GetClipPlanexOES_1(plane, equation);
    
    private z_GetFixedvOES_adr := GetProcAddress('glGetFixedvOES');
    private z_GetFixedvOES_1 := GetProcOrNil&<procedure(pname: GetPName; &params: IntPtr)>(z_GetFixedvOES_adr);
    private z_GetFixedvOES_2 := GetProcOrNil&<procedure(pname: GetPName; var &params: Fixed)>(z_GetFixedvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFixedvOES(pname: GetPName; var &params: Fixed) :=
    z_GetFixedvOES_2(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFixedvOES(pname: GetPName; &params: IntPtr) :=
    z_GetFixedvOES_1(pname, &params);
    
    private z_GetTexEnvxvOES_adr := GetProcAddress('glGetTexEnvxvOES');
    private z_GetTexEnvxvOES_1 := GetProcOrNil&<procedure(target: TextureEnvTarget; pname: TextureEnvParameter; &params: IntPtr)>(z_GetTexEnvxvOES_adr);
    private z_GetTexEnvxvOES_2 := GetProcOrNil&<procedure(target: TextureEnvTarget; pname: TextureEnvParameter; var &params: Fixed)>(z_GetTexEnvxvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexEnvxvOES(target: TextureEnvTarget; pname: TextureEnvParameter; var &params: Fixed) :=
    z_GetTexEnvxvOES_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexEnvxvOES(target: TextureEnvTarget; pname: TextureEnvParameter; &params: IntPtr) :=
    z_GetTexEnvxvOES_1(target, pname, &params);
    
    private z_GetTexParameterxvOES_adr := GetProcAddress('glGetTexParameterxvOES');
    private z_GetTexParameterxvOES_1 := GetProcOrNil&<procedure(target: TextureTarget; pname: GetTextureParameter; &params: IntPtr)>(z_GetTexParameterxvOES_adr);
    private z_GetTexParameterxvOES_2 := GetProcOrNil&<procedure(target: TextureTarget; pname: GetTextureParameter; var &params: Fixed)>(z_GetTexParameterxvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterxvOES(target: TextureTarget; pname: GetTextureParameter; var &params: Fixed) :=
    z_GetTexParameterxvOES_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterxvOES(target: TextureTarget; pname: GetTextureParameter; &params: IntPtr) :=
    z_GetTexParameterxvOES_1(target, pname, &params);
    
    private z_LightModelxOES_adr := GetProcAddress('glLightModelxOES');
    private z_LightModelxOES_1 := GetProcOrNil&<procedure(pname: LightModelParameter; param: Fixed)>(z_LightModelxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModelxOES(pname: LightModelParameter; param: Fixed) :=
    z_LightModelxOES_1(pname, param);
    
    private z_LightModelxvOES_adr := GetProcAddress('glLightModelxvOES');
    private z_LightModelxvOES_1 := GetProcOrNil&<procedure(pname: LightModelParameter; param: IntPtr)>(z_LightModelxvOES_adr);
    private z_LightModelxvOES_2 := GetProcOrNil&<procedure(pname: LightModelParameter; var param: Fixed)>(z_LightModelxvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModelxvOES(pname: LightModelParameter; param: array of Fixed);
    type PFixed=^Fixed;
    begin
      if (param<>nil) and (param.Length<>0) then
        z_LightModelxvOES_2(pname, param[0]) else
        z_LightModelxvOES_2(pname, PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModelxvOES(pname: LightModelParameter; var param: Fixed) :=
    z_LightModelxvOES_2(pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModelxvOES(pname: LightModelParameter; param: IntPtr) :=
    z_LightModelxvOES_1(pname, param);
    
    private z_LightxOES_adr := GetProcAddress('glLightxOES');
    private z_LightxOES_1 := GetProcOrNil&<procedure(light: LightName; pname: LightParameter; param: Fixed)>(z_LightxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightxOES(light: LightName; pname: LightParameter; param: Fixed) :=
    z_LightxOES_1(light, pname, param);
    
    private z_LightxvOES_adr := GetProcAddress('glLightxvOES');
    private z_LightxvOES_1 := GetProcOrNil&<procedure(light: LightName; pname: LightParameter; &params: IntPtr)>(z_LightxvOES_adr);
    private z_LightxvOES_2 := GetProcOrNil&<procedure(light: LightName; pname: LightParameter; var &params: Fixed)>(z_LightxvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightxvOES(light: LightName; pname: LightParameter; &params: array of Fixed);
    type PFixed=^Fixed;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_LightxvOES_2(light, pname, &params[0]) else
        z_LightxvOES_2(light, pname, PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightxvOES(light: LightName; pname: LightParameter; var &params: Fixed) :=
    z_LightxvOES_2(light, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightxvOES(light: LightName; pname: LightParameter; &params: IntPtr) :=
    z_LightxvOES_1(light, pname, &params);
    
    private z_LineWidthxOES_adr := GetProcAddress('glLineWidthxOES');
    private z_LineWidthxOES_1 := GetProcOrNil&<procedure(width: Fixed)>(z_LineWidthxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LineWidthxOES(width: Fixed) :=
    z_LineWidthxOES_1(width);
    
    private z_LoadMatrixxOES_adr := GetProcAddress('glLoadMatrixxOES');
    private z_LoadMatrixxOES_1 := GetProcOrNil&<procedure(m: IntPtr)>(z_LoadMatrixxOES_adr);
    private z_LoadMatrixxOES_2 := GetProcOrNil&<procedure(var m: Fixed)>(z_LoadMatrixxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadMatrixxOES(m: array of Fixed);
    type PFixed=^Fixed;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_LoadMatrixxOES_2(m[0]) else
        z_LoadMatrixxOES_2(PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadMatrixxOES(var m: Fixed) :=
    z_LoadMatrixxOES_2(m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadMatrixxOES(m: IntPtr) :=
    z_LoadMatrixxOES_1(m);
    
    private z_MaterialxOES_adr := GetProcAddress('glMaterialxOES');
    private z_MaterialxOES_1 := GetProcOrNil&<procedure(face: MaterialFace; pname: MaterialParameter; param: Fixed)>(z_MaterialxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MaterialxOES(face: MaterialFace; pname: MaterialParameter; param: Fixed) :=
    z_MaterialxOES_1(face, pname, param);
    
    private z_MaterialxvOES_adr := GetProcAddress('glMaterialxvOES');
    private z_MaterialxvOES_1 := GetProcOrNil&<procedure(face: MaterialFace; pname: MaterialParameter; param: IntPtr)>(z_MaterialxvOES_adr);
    private z_MaterialxvOES_2 := GetProcOrNil&<procedure(face: MaterialFace; pname: MaterialParameter; var param: Fixed)>(z_MaterialxvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MaterialxvOES(face: MaterialFace; pname: MaterialParameter; param: array of Fixed);
    type PFixed=^Fixed;
    begin
      if (param<>nil) and (param.Length<>0) then
        z_MaterialxvOES_2(face, pname, param[0]) else
        z_MaterialxvOES_2(face, pname, PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MaterialxvOES(face: MaterialFace; pname: MaterialParameter; var param: Fixed) :=
    z_MaterialxvOES_2(face, pname, param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MaterialxvOES(face: MaterialFace; pname: MaterialParameter; param: IntPtr) :=
    z_MaterialxvOES_1(face, pname, param);
    
    private z_MultMatrixxOES_adr := GetProcAddress('glMultMatrixxOES');
    private z_MultMatrixxOES_1 := GetProcOrNil&<procedure(m: IntPtr)>(z_MultMatrixxOES_adr);
    private z_MultMatrixxOES_2 := GetProcOrNil&<procedure(var m: Fixed)>(z_MultMatrixxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultMatrixxOES(m: array of Fixed);
    type PFixed=^Fixed;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_MultMatrixxOES_2(m[0]) else
        z_MultMatrixxOES_2(PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultMatrixxOES(var m: Fixed) :=
    z_MultMatrixxOES_2(m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultMatrixxOES(m: IntPtr) :=
    z_MultMatrixxOES_1(m);
    
    private z_MultiTexCoord4xOES_adr := GetProcAddress('glMultiTexCoord4xOES');
    private z_MultiTexCoord4xOES_1 := GetProcOrNil&<procedure(texture: TextureUnit; s: Fixed; t: Fixed; r: Fixed; q: Fixed)>(z_MultiTexCoord4xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4xOES(texture: TextureUnit; s: Fixed; t: Fixed; r: Fixed; q: Fixed) :=
    z_MultiTexCoord4xOES_1(texture, s, t, r, q);
    
    private z_Normal3xOES_adr := GetProcAddress('glNormal3xOES');
    private z_Normal3xOES_1 := GetProcOrNil&<procedure(nx: Fixed; ny: Fixed; nz: Fixed)>(z_Normal3xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3xOES(nx: Fixed; ny: Fixed; nz: Fixed) :=
    z_Normal3xOES_1(nx, ny, nz);
    
    private z_OrthoxOES_adr := GetProcAddress('glOrthoxOES');
    private z_OrthoxOES_1 := GetProcOrNil&<procedure(l: Fixed; r: Fixed; b: Fixed; t: Fixed; n: Fixed; f: Fixed)>(z_OrthoxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure OrthoxOES(l: Fixed; r: Fixed; b: Fixed; t: Fixed; n: Fixed; f: Fixed) :=
    z_OrthoxOES_1(l, r, b, t, n, f);
    
    private z_PointParameterxvOES_adr := GetProcAddress('glPointParameterxvOES');
    private z_PointParameterxvOES_1 := GetProcOrNil&<procedure(pname: PointParameterName; &params: IntPtr)>(z_PointParameterxvOES_adr);
    private z_PointParameterxvOES_2 := GetProcOrNil&<procedure(pname: PointParameterName; var &params: Fixed)>(z_PointParameterxvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterxvOES(pname: PointParameterName; &params: array of Fixed);
    type PFixed=^Fixed;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_PointParameterxvOES_2(pname, &params[0]) else
        z_PointParameterxvOES_2(pname, PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterxvOES(pname: PointParameterName; var &params: Fixed) :=
    z_PointParameterxvOES_2(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterxvOES(pname: PointParameterName; &params: IntPtr) :=
    z_PointParameterxvOES_1(pname, &params);
    
    private z_PointSizexOES_adr := GetProcAddress('glPointSizexOES');
    private z_PointSizexOES_1 := GetProcOrNil&<procedure(size: Fixed)>(z_PointSizexOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointSizexOES(size: Fixed) :=
    z_PointSizexOES_1(size);
    
    private z_PolygonOffsetxOES_adr := GetProcAddress('glPolygonOffsetxOES');
    private z_PolygonOffsetxOES_1 := GetProcOrNil&<procedure(factor: Fixed; units: Fixed)>(z_PolygonOffsetxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PolygonOffsetxOES(factor: Fixed; units: Fixed) :=
    z_PolygonOffsetxOES_1(factor, units);
    
    private z_RotatexOES_adr := GetProcAddress('glRotatexOES');
    private z_RotatexOES_1 := GetProcOrNil&<procedure(angle: Fixed; x: Fixed; y: Fixed; z: Fixed)>(z_RotatexOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RotatexOES(angle: Fixed; x: Fixed; y: Fixed; z: Fixed) :=
    z_RotatexOES_1(angle, x, y, z);
    
    private z_ScalexOES_adr := GetProcAddress('glScalexOES');
    private z_ScalexOES_1 := GetProcOrNil&<procedure(x: Fixed; y: Fixed; z: Fixed)>(z_ScalexOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScalexOES(x: Fixed; y: Fixed; z: Fixed) :=
    z_ScalexOES_1(x, y, z);
    
    private z_TexEnvxOES_adr := GetProcAddress('glTexEnvxOES');
    private z_TexEnvxOES_1 := GetProcOrNil&<procedure(target: TextureEnvTarget; pname: TextureEnvParameter; param: Fixed)>(z_TexEnvxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvxOES(target: TextureEnvTarget; pname: TextureEnvParameter; param: Fixed) :=
    z_TexEnvxOES_1(target, pname, param);
    
    private z_TexEnvxvOES_adr := GetProcAddress('glTexEnvxvOES');
    private z_TexEnvxvOES_1 := GetProcOrNil&<procedure(target: TextureEnvTarget; pname: TextureEnvParameter; &params: IntPtr)>(z_TexEnvxvOES_adr);
    private z_TexEnvxvOES_2 := GetProcOrNil&<procedure(target: TextureEnvTarget; pname: TextureEnvParameter; var &params: Fixed)>(z_TexEnvxvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvxvOES(target: TextureEnvTarget; pname: TextureEnvParameter; &params: array of Fixed);
    type PFixed=^Fixed;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_TexEnvxvOES_2(target, pname, &params[0]) else
        z_TexEnvxvOES_2(target, pname, PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvxvOES(target: TextureEnvTarget; pname: TextureEnvParameter; var &params: Fixed) :=
    z_TexEnvxvOES_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvxvOES(target: TextureEnvTarget; pname: TextureEnvParameter; &params: IntPtr) :=
    z_TexEnvxvOES_1(target, pname, &params);
    
    private z_TexParameterxOES_adr := GetProcAddress('glTexParameterxOES');
    private z_TexParameterxOES_1 := GetProcOrNil&<procedure(target: TextureTarget; pname: GetTextureParameter; param: Fixed)>(z_TexParameterxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterxOES(target: TextureTarget; pname: GetTextureParameter; param: Fixed) :=
    z_TexParameterxOES_1(target, pname, param);
    
    private z_TexParameterxvOES_adr := GetProcAddress('glTexParameterxvOES');
    private z_TexParameterxvOES_1 := GetProcOrNil&<procedure(target: TextureTarget; pname: GetTextureParameter; &params: IntPtr)>(z_TexParameterxvOES_adr);
    private z_TexParameterxvOES_2 := GetProcOrNil&<procedure(target: TextureTarget; pname: GetTextureParameter; var &params: Fixed)>(z_TexParameterxvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterxvOES(target: TextureTarget; pname: GetTextureParameter; &params: array of Fixed);
    type PFixed=^Fixed;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_TexParameterxvOES_2(target, pname, &params[0]) else
        z_TexParameterxvOES_2(target, pname, PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterxvOES(target: TextureTarget; pname: GetTextureParameter; var &params: Fixed) :=
    z_TexParameterxvOES_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterxvOES(target: TextureTarget; pname: GetTextureParameter; &params: IntPtr) :=
    z_TexParameterxvOES_1(target, pname, &params);
    
    private z_TranslatexOES_adr := GetProcAddress('glTranslatexOES');
    private z_TranslatexOES_1 := GetProcOrNil&<procedure(x: Fixed; y: Fixed; z: Fixed)>(z_TranslatexOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TranslatexOES(x: Fixed; y: Fixed; z: Fixed) :=
    z_TranslatexOES_1(x, y, z);
    
    private z_AccumxOES_adr := GetProcAddress('glAccumxOES');
    private z_AccumxOES_1 := GetProcOrNil&<procedure(op: DummyEnum; value: Fixed)>(z_AccumxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AccumxOES(op: DummyEnum; value: Fixed) :=
    z_AccumxOES_1(op, value);
    
    private z_BitmapxOES_adr := GetProcAddress('glBitmapxOES');
    private z_BitmapxOES_1 := GetProcOrNil&<procedure(width: Int32; height: Int32; xorig: Fixed; yorig: Fixed; xmove: Fixed; ymove: Fixed; bitmap: IntPtr)>(z_BitmapxOES_adr);
    private z_BitmapxOES_2 := GetProcOrNil&<procedure(width: Int32; height: Int32; xorig: Fixed; yorig: Fixed; xmove: Fixed; ymove: Fixed; var bitmap: Byte)>(z_BitmapxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BitmapxOES(width: Int32; height: Int32; xorig: Fixed; yorig: Fixed; xmove: Fixed; ymove: Fixed; bitmap: array of Byte);
    type PByte=^Byte;
    begin
      if (bitmap<>nil) and (bitmap.Length<>0) then
        z_BitmapxOES_2(width, height, xorig, yorig, xmove, ymove, bitmap[0]) else
        z_BitmapxOES_2(width, height, xorig, yorig, xmove, ymove, PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BitmapxOES(width: Int32; height: Int32; xorig: Fixed; yorig: Fixed; xmove: Fixed; ymove: Fixed; var bitmap: Byte) :=
    z_BitmapxOES_2(width, height, xorig, yorig, xmove, ymove, bitmap);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BitmapxOES(width: Int32; height: Int32; xorig: Fixed; yorig: Fixed; xmove: Fixed; ymove: Fixed; bitmap: IntPtr) :=
    z_BitmapxOES_1(width, height, xorig, yorig, xmove, ymove, bitmap);
    
    private z_BlendColorxOES_adr := GetProcAddress('glBlendColorxOES');
    private z_BlendColorxOES_1 := GetProcOrNil&<procedure(red: Fixed; green: Fixed; blue: Fixed; alpha: Fixed)>(z_BlendColorxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendColorxOES(red: Fixed; green: Fixed; blue: Fixed; alpha: Fixed) :=
    z_BlendColorxOES_1(red, green, blue, alpha);
    
    private z_ClearAccumxOES_adr := GetProcAddress('glClearAccumxOES');
    private z_ClearAccumxOES_1 := GetProcOrNil&<procedure(red: Fixed; green: Fixed; blue: Fixed; alpha: Fixed)>(z_ClearAccumxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearAccumxOES(red: Fixed; green: Fixed; blue: Fixed; alpha: Fixed) :=
    z_ClearAccumxOES_1(red, green, blue, alpha);
    
    private z_Color3xOES_adr := GetProcAddress('glColor3xOES');
    private z_Color3xOES_1 := GetProcOrNil&<procedure(red: Fixed; green: Fixed; blue: Fixed)>(z_Color3xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3xOES(red: Fixed; green: Fixed; blue: Fixed) :=
    z_Color3xOES_1(red, green, blue);
    
    private z_Color3xvOES_adr := GetProcAddress('glColor3xvOES');
    private z_Color3xvOES_1 := GetProcOrNil&<procedure(components: IntPtr)>(z_Color3xvOES_adr);
    private z_Color3xvOES_2 := GetProcOrNil&<procedure(var components: Fixed)>(z_Color3xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3xvOES(components: array of Fixed);
    type PFixed=^Fixed;
    begin
      if (components<>nil) and (components.Length<>0) then
        z_Color3xvOES_2(components[0]) else
        z_Color3xvOES_2(PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3xvOES(var components: Fixed) :=
    z_Color3xvOES_2(components);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3xvOES(components: IntPtr) :=
    z_Color3xvOES_1(components);
    
    private z_Color4xvOES_adr := GetProcAddress('glColor4xvOES');
    private z_Color4xvOES_1 := GetProcOrNil&<procedure(components: IntPtr)>(z_Color4xvOES_adr);
    private z_Color4xvOES_2 := GetProcOrNil&<procedure(var components: Fixed)>(z_Color4xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4xvOES(components: array of Fixed);
    type PFixed=^Fixed;
    begin
      if (components<>nil) and (components.Length<>0) then
        z_Color4xvOES_2(components[0]) else
        z_Color4xvOES_2(PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4xvOES(var components: Fixed) :=
    z_Color4xvOES_2(components);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4xvOES(components: IntPtr) :=
    z_Color4xvOES_1(components);
    
    private z_ConvolutionParameterxOES_adr := GetProcAddress('glConvolutionParameterxOES');
    private z_ConvolutionParameterxOES_1 := GetProcOrNil&<procedure(target: ConvolutionTargetEXT; pname: ConvolutionParameter; param: Fixed)>(z_ConvolutionParameterxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterxOES(target: ConvolutionTargetEXT; pname: ConvolutionParameter; param: Fixed) :=
    z_ConvolutionParameterxOES_1(target, pname, param);
    
    private z_ConvolutionParameterxvOES_adr := GetProcAddress('glConvolutionParameterxvOES');
    private z_ConvolutionParameterxvOES_1 := GetProcOrNil&<procedure(target: ConvolutionTargetEXT; pname: ConvolutionParameter; &params: IntPtr)>(z_ConvolutionParameterxvOES_adr);
    private z_ConvolutionParameterxvOES_2 := GetProcOrNil&<procedure(target: ConvolutionTargetEXT; pname: ConvolutionParameter; var &params: Fixed)>(z_ConvolutionParameterxvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterxvOES(target: ConvolutionTargetEXT; pname: ConvolutionParameter; &params: array of Fixed);
    type PFixed=^Fixed;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_ConvolutionParameterxvOES_2(target, pname, &params[0]) else
        z_ConvolutionParameterxvOES_2(target, pname, PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterxvOES(target: ConvolutionTargetEXT; pname: ConvolutionParameter; var &params: Fixed) :=
    z_ConvolutionParameterxvOES_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterxvOES(target: ConvolutionTargetEXT; pname: ConvolutionParameter; &params: IntPtr) :=
    z_ConvolutionParameterxvOES_1(target, pname, &params);
    
    private z_EvalCoord1xOES_adr := GetProcAddress('glEvalCoord1xOES');
    private z_EvalCoord1xOES_1 := GetProcOrNil&<procedure(u: Fixed)>(z_EvalCoord1xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1xOES(u: Fixed) :=
    z_EvalCoord1xOES_1(u);
    
    private z_EvalCoord1xvOES_adr := GetProcAddress('glEvalCoord1xvOES');
    private z_EvalCoord1xvOES_1 := GetProcOrNil&<procedure(coords: IntPtr)>(z_EvalCoord1xvOES_adr);
    private z_EvalCoord1xvOES_2 := GetProcOrNil&<procedure(var coords: Fixed)>(z_EvalCoord1xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1xvOES(coords: array of Fixed);
    type PFixed=^Fixed;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_EvalCoord1xvOES_2(coords[0]) else
        z_EvalCoord1xvOES_2(PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1xvOES(var coords: Fixed) :=
    z_EvalCoord1xvOES_2(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1xvOES(coords: IntPtr) :=
    z_EvalCoord1xvOES_1(coords);
    
    private z_EvalCoord2xOES_adr := GetProcAddress('glEvalCoord2xOES');
    private z_EvalCoord2xOES_1 := GetProcOrNil&<procedure(u: Fixed; v: Fixed)>(z_EvalCoord2xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2xOES(u: Fixed; v: Fixed) :=
    z_EvalCoord2xOES_1(u, v);
    
    private z_EvalCoord2xvOES_adr := GetProcAddress('glEvalCoord2xvOES');
    private z_EvalCoord2xvOES_1 := GetProcOrNil&<procedure(coords: IntPtr)>(z_EvalCoord2xvOES_adr);
    private z_EvalCoord2xvOES_2 := GetProcOrNil&<procedure(var coords: Fixed)>(z_EvalCoord2xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2xvOES(coords: array of Fixed);
    type PFixed=^Fixed;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_EvalCoord2xvOES_2(coords[0]) else
        z_EvalCoord2xvOES_2(PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2xvOES(var coords: Fixed) :=
    z_EvalCoord2xvOES_2(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2xvOES(coords: IntPtr) :=
    z_EvalCoord2xvOES_1(coords);
    
    private z_FeedbackBufferxOES_adr := GetProcAddress('glFeedbackBufferxOES');
    private z_FeedbackBufferxOES_1 := GetProcOrNil&<procedure(n: Int32; &type: DummyEnum; buffer: IntPtr)>(z_FeedbackBufferxOES_adr);
    private z_FeedbackBufferxOES_2 := GetProcOrNil&<procedure(n: Int32; &type: DummyEnum; var buffer: Fixed)>(z_FeedbackBufferxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FeedbackBufferxOES(n: Int32; &type: DummyEnum; buffer: array of Fixed);
    type PFixed=^Fixed;
    begin
      if (buffer<>nil) and (buffer.Length<>0) then
        z_FeedbackBufferxOES_2(n, &type, buffer[0]) else
        z_FeedbackBufferxOES_2(n, &type, PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FeedbackBufferxOES(n: Int32; &type: DummyEnum; var buffer: Fixed) :=
    z_FeedbackBufferxOES_2(n, &type, buffer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FeedbackBufferxOES(n: Int32; &type: DummyEnum; buffer: IntPtr) :=
    z_FeedbackBufferxOES_1(n, &type, buffer);
    
    private z_GetConvolutionParameterxvOES_adr := GetProcAddress('glGetConvolutionParameterxvOES');
    private z_GetConvolutionParameterxvOES_1 := GetProcOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: IntPtr)>(z_GetConvolutionParameterxvOES_adr);
    private z_GetConvolutionParameterxvOES_2 := GetProcOrNil&<procedure(target: DummyEnum; pname: DummyEnum; var &params: Fixed)>(z_GetConvolutionParameterxvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameterxvOES(target: DummyEnum; pname: DummyEnum; var &params: Fixed) :=
    z_GetConvolutionParameterxvOES_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameterxvOES(target: DummyEnum; pname: DummyEnum; &params: IntPtr) :=
    z_GetConvolutionParameterxvOES_1(target, pname, &params);
    
    private z_GetHistogramParameterxvOES_adr := GetProcAddress('glGetHistogramParameterxvOES');
    private z_GetHistogramParameterxvOES_1 := GetProcOrNil&<procedure(target: HistogramTargetEXT; pname: GetHistogramParameterPName; &params: IntPtr)>(z_GetHistogramParameterxvOES_adr);
    private z_GetHistogramParameterxvOES_2 := GetProcOrNil&<procedure(target: HistogramTargetEXT; pname: GetHistogramParameterPName; var &params: Fixed)>(z_GetHistogramParameterxvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameterxvOES(target: HistogramTargetEXT; pname: GetHistogramParameterPName; var &params: Fixed) :=
    z_GetHistogramParameterxvOES_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameterxvOES(target: HistogramTargetEXT; pname: GetHistogramParameterPName; &params: IntPtr) :=
    z_GetHistogramParameterxvOES_1(target, pname, &params);
    
    private z_GetLightxOES_adr := GetProcAddress('glGetLightxOES');
    private z_GetLightxOES_1 := GetProcOrNil&<procedure(light: LightName; pname: LightParameter; &params: IntPtr)>(z_GetLightxOES_adr);
    private z_GetLightxOES_2 := GetProcOrNil&<procedure(light: LightName; pname: LightParameter; var &params: Fixed)>(z_GetLightxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLightxOES(light: LightName; pname: LightParameter; var &params: Fixed) :=
    z_GetLightxOES_2(light, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLightxOES(light: LightName; pname: LightParameter; &params: IntPtr) :=
    z_GetLightxOES_1(light, pname, &params);
    
    private z_GetMapxvOES_adr := GetProcAddress('glGetMapxvOES');
    private z_GetMapxvOES_1 := GetProcOrNil&<procedure(target: MapTarget; query: GetMapQuery; v: IntPtr)>(z_GetMapxvOES_adr);
    private z_GetMapxvOES_2 := GetProcOrNil&<procedure(target: MapTarget; query: GetMapQuery; var v: Fixed)>(z_GetMapxvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapxvOES(target: MapTarget; query: GetMapQuery; var v: Fixed) :=
    z_GetMapxvOES_2(target, query, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapxvOES(target: MapTarget; query: GetMapQuery; v: IntPtr) :=
    z_GetMapxvOES_1(target, query, v);
    
    private z_GetMaterialxOES_adr := GetProcAddress('glGetMaterialxOES');
    private z_GetMaterialxOES_1 := GetProcOrNil&<procedure(face: MaterialFace; pname: MaterialParameter; param: Fixed)>(z_GetMaterialxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMaterialxOES(face: MaterialFace; pname: MaterialParameter; param: Fixed) :=
    z_GetMaterialxOES_1(face, pname, param);
    
    private z_GetPixelMapxv_adr := GetProcAddress('glGetPixelMapxv');
    private z_GetPixelMapxv_1 := GetProcOrNil&<procedure(map: PixelMap; size: Int32; values: IntPtr)>(z_GetPixelMapxv_adr);
    private z_GetPixelMapxv_2 := GetProcOrNil&<procedure(map: PixelMap; size: Int32; var values: Fixed)>(z_GetPixelMapxv_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelMapxv(map: PixelMap; size: Int32; var values: Fixed) :=
    z_GetPixelMapxv_2(map, size, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelMapxv(map: PixelMap; size: Int32; values: IntPtr) :=
    z_GetPixelMapxv_1(map, size, values);
    
    private z_GetTexGenxvOES_adr := GetProcAddress('glGetTexGenxvOES');
    private z_GetTexGenxvOES_1 := GetProcOrNil&<procedure(coord: TextureCoordName; pname: TextureGenParameter; &params: IntPtr)>(z_GetTexGenxvOES_adr);
    private z_GetTexGenxvOES_2 := GetProcOrNil&<procedure(coord: TextureCoordName; pname: TextureGenParameter; var &params: Fixed)>(z_GetTexGenxvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGenxvOES(coord: TextureCoordName; pname: TextureGenParameter; var &params: Fixed) :=
    z_GetTexGenxvOES_2(coord, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGenxvOES(coord: TextureCoordName; pname: TextureGenParameter; &params: IntPtr) :=
    z_GetTexGenxvOES_1(coord, pname, &params);
    
    private z_GetTexLevelParameterxvOES_adr := GetProcAddress('glGetTexLevelParameterxvOES');
    private z_GetTexLevelParameterxvOES_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; pname: GetTextureParameter; &params: IntPtr)>(z_GetTexLevelParameterxvOES_adr);
    private z_GetTexLevelParameterxvOES_2 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; pname: GetTextureParameter; var &params: Fixed)>(z_GetTexLevelParameterxvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexLevelParameterxvOES(target: TextureTarget; level: Int32; pname: GetTextureParameter; var &params: Fixed) :=
    z_GetTexLevelParameterxvOES_2(target, level, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexLevelParameterxvOES(target: TextureTarget; level: Int32; pname: GetTextureParameter; &params: IntPtr) :=
    z_GetTexLevelParameterxvOES_1(target, level, pname, &params);
    
    private z_IndexxOES_adr := GetProcAddress('glIndexxOES');
    private z_IndexxOES_1 := GetProcOrNil&<procedure(component: Fixed)>(z_IndexxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexxOES(component: Fixed) :=
    z_IndexxOES_1(component);
    
    private z_IndexxvOES_adr := GetProcAddress('glIndexxvOES');
    private z_IndexxvOES_1 := GetProcOrNil&<procedure(component: IntPtr)>(z_IndexxvOES_adr);
    private z_IndexxvOES_2 := GetProcOrNil&<procedure(var component: Fixed)>(z_IndexxvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexxvOES(component: array of Fixed);
    type PFixed=^Fixed;
    begin
      if (component<>nil) and (component.Length<>0) then
        z_IndexxvOES_2(component[0]) else
        z_IndexxvOES_2(PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexxvOES(var component: Fixed) :=
    z_IndexxvOES_2(component);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexxvOES(component: IntPtr) :=
    z_IndexxvOES_1(component);
    
    private z_LoadTransposeMatrixxOES_adr := GetProcAddress('glLoadTransposeMatrixxOES');
    private z_LoadTransposeMatrixxOES_1 := GetProcOrNil&<procedure(m: IntPtr)>(z_LoadTransposeMatrixxOES_adr);
    private z_LoadTransposeMatrixxOES_2 := GetProcOrNil&<procedure(var m: Fixed)>(z_LoadTransposeMatrixxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixxOES(m: array of Fixed);
    type PFixed=^Fixed;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_LoadTransposeMatrixxOES_2(m[0]) else
        z_LoadTransposeMatrixxOES_2(PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixxOES(var m: Fixed) :=
    z_LoadTransposeMatrixxOES_2(m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixxOES(m: IntPtr) :=
    z_LoadTransposeMatrixxOES_1(m);
    
    private z_Map1xOES_adr := GetProcAddress('glMap1xOES');
    private z_Map1xOES_1 := GetProcOrNil&<procedure(target: MapTarget; u1: Fixed; u2: Fixed; stride: Int32; order: Int32; points: Fixed)>(z_Map1xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map1xOES(target: MapTarget; u1: Fixed; u2: Fixed; stride: Int32; order: Int32; points: Fixed) :=
    z_Map1xOES_1(target, u1, u2, stride, order, points);
    
    private z_Map2xOES_adr := GetProcAddress('glMap2xOES');
    private z_Map2xOES_1 := GetProcOrNil&<procedure(target: MapTarget; u1: Fixed; u2: Fixed; ustride: Int32; uorder: Int32; v1: Fixed; v2: Fixed; vstride: Int32; vorder: Int32; points: Fixed)>(z_Map2xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map2xOES(target: MapTarget; u1: Fixed; u2: Fixed; ustride: Int32; uorder: Int32; v1: Fixed; v2: Fixed; vstride: Int32; vorder: Int32; points: Fixed) :=
    z_Map2xOES_1(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    
    private z_MapGrid1xOES_adr := GetProcAddress('glMapGrid1xOES');
    private z_MapGrid1xOES_1 := GetProcOrNil&<procedure(n: Int32; u1: Fixed; u2: Fixed)>(z_MapGrid1xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapGrid1xOES(n: Int32; u1: Fixed; u2: Fixed) :=
    z_MapGrid1xOES_1(n, u1, u2);
    
    private z_MapGrid2xOES_adr := GetProcAddress('glMapGrid2xOES');
    private z_MapGrid2xOES_1 := GetProcOrNil&<procedure(n: Int32; u1: Fixed; u2: Fixed; v1: Fixed; v2: Fixed)>(z_MapGrid2xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapGrid2xOES(n: Int32; u1: Fixed; u2: Fixed; v1: Fixed; v2: Fixed) :=
    z_MapGrid2xOES_1(n, u1, u2, v1, v2);
    
    private z_MultTransposeMatrixxOES_adr := GetProcAddress('glMultTransposeMatrixxOES');
    private z_MultTransposeMatrixxOES_1 := GetProcOrNil&<procedure(m: IntPtr)>(z_MultTransposeMatrixxOES_adr);
    private z_MultTransposeMatrixxOES_2 := GetProcOrNil&<procedure(var m: Fixed)>(z_MultTransposeMatrixxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixxOES(m: array of Fixed);
    type PFixed=^Fixed;
    begin
      if (m<>nil) and (m.Length<>0) then
        z_MultTransposeMatrixxOES_2(m[0]) else
        z_MultTransposeMatrixxOES_2(PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixxOES(var m: Fixed) :=
    z_MultTransposeMatrixxOES_2(m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixxOES(m: IntPtr) :=
    z_MultTransposeMatrixxOES_1(m);
    
    private z_MultiTexCoord1xOES_adr := GetProcAddress('glMultiTexCoord1xOES');
    private z_MultiTexCoord1xOES_1 := GetProcOrNil&<procedure(texture: TextureUnit; s: Fixed)>(z_MultiTexCoord1xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1xOES(texture: TextureUnit; s: Fixed) :=
    z_MultiTexCoord1xOES_1(texture, s);
    
    private z_MultiTexCoord1xvOES_adr := GetProcAddress('glMultiTexCoord1xvOES');
    private z_MultiTexCoord1xvOES_1 := GetProcOrNil&<procedure(texture: TextureUnit; coords: IntPtr)>(z_MultiTexCoord1xvOES_adr);
    private z_MultiTexCoord1xvOES_2 := GetProcOrNil&<procedure(texture: TextureUnit; var coords: Fixed)>(z_MultiTexCoord1xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1xvOES(texture: TextureUnit; coords: array of Fixed);
    type PFixed=^Fixed;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_MultiTexCoord1xvOES_2(texture, coords[0]) else
        z_MultiTexCoord1xvOES_2(texture, PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1xvOES(texture: TextureUnit; var coords: Fixed) :=
    z_MultiTexCoord1xvOES_2(texture, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1xvOES(texture: TextureUnit; coords: IntPtr) :=
    z_MultiTexCoord1xvOES_1(texture, coords);
    
    private z_MultiTexCoord2xOES_adr := GetProcAddress('glMultiTexCoord2xOES');
    private z_MultiTexCoord2xOES_1 := GetProcOrNil&<procedure(texture: TextureUnit; s: Fixed; t: Fixed)>(z_MultiTexCoord2xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2xOES(texture: TextureUnit; s: Fixed; t: Fixed) :=
    z_MultiTexCoord2xOES_1(texture, s, t);
    
    private z_MultiTexCoord2xvOES_adr := GetProcAddress('glMultiTexCoord2xvOES');
    private z_MultiTexCoord2xvOES_1 := GetProcOrNil&<procedure(texture: TextureUnit; coords: IntPtr)>(z_MultiTexCoord2xvOES_adr);
    private z_MultiTexCoord2xvOES_2 := GetProcOrNil&<procedure(texture: TextureUnit; var coords: Fixed)>(z_MultiTexCoord2xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2xvOES(texture: TextureUnit; coords: array of Fixed);
    type PFixed=^Fixed;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_MultiTexCoord2xvOES_2(texture, coords[0]) else
        z_MultiTexCoord2xvOES_2(texture, PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2xvOES(texture: TextureUnit; var coords: Fixed) :=
    z_MultiTexCoord2xvOES_2(texture, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2xvOES(texture: TextureUnit; coords: IntPtr) :=
    z_MultiTexCoord2xvOES_1(texture, coords);
    
    private z_MultiTexCoord3xOES_adr := GetProcAddress('glMultiTexCoord3xOES');
    private z_MultiTexCoord3xOES_1 := GetProcOrNil&<procedure(texture: TextureUnit; s: Fixed; t: Fixed; r: Fixed)>(z_MultiTexCoord3xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3xOES(texture: TextureUnit; s: Fixed; t: Fixed; r: Fixed) :=
    z_MultiTexCoord3xOES_1(texture, s, t, r);
    
    private z_MultiTexCoord3xvOES_adr := GetProcAddress('glMultiTexCoord3xvOES');
    private z_MultiTexCoord3xvOES_1 := GetProcOrNil&<procedure(texture: TextureUnit; coords: IntPtr)>(z_MultiTexCoord3xvOES_adr);
    private z_MultiTexCoord3xvOES_2 := GetProcOrNil&<procedure(texture: TextureUnit; var coords: Fixed)>(z_MultiTexCoord3xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3xvOES(texture: TextureUnit; coords: array of Fixed);
    type PFixed=^Fixed;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_MultiTexCoord3xvOES_2(texture, coords[0]) else
        z_MultiTexCoord3xvOES_2(texture, PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3xvOES(texture: TextureUnit; var coords: Fixed) :=
    z_MultiTexCoord3xvOES_2(texture, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3xvOES(texture: TextureUnit; coords: IntPtr) :=
    z_MultiTexCoord3xvOES_1(texture, coords);
    
    private z_MultiTexCoord4xvOES_adr := GetProcAddress('glMultiTexCoord4xvOES');
    private z_MultiTexCoord4xvOES_1 := GetProcOrNil&<procedure(texture: TextureUnit; coords: IntPtr)>(z_MultiTexCoord4xvOES_adr);
    private z_MultiTexCoord4xvOES_2 := GetProcOrNil&<procedure(texture: TextureUnit; var coords: Fixed)>(z_MultiTexCoord4xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4xvOES(texture: TextureUnit; coords: array of Fixed);
    type PFixed=^Fixed;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_MultiTexCoord4xvOES_2(texture, coords[0]) else
        z_MultiTexCoord4xvOES_2(texture, PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4xvOES(texture: TextureUnit; var coords: Fixed) :=
    z_MultiTexCoord4xvOES_2(texture, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4xvOES(texture: TextureUnit; coords: IntPtr) :=
    z_MultiTexCoord4xvOES_1(texture, coords);
    
    private z_Normal3xvOES_adr := GetProcAddress('glNormal3xvOES');
    private z_Normal3xvOES_1 := GetProcOrNil&<procedure(coords: IntPtr)>(z_Normal3xvOES_adr);
    private z_Normal3xvOES_2 := GetProcOrNil&<procedure(var coords: Fixed)>(z_Normal3xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3xvOES(coords: array of Fixed);
    type PFixed=^Fixed;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_Normal3xvOES_2(coords[0]) else
        z_Normal3xvOES_2(PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3xvOES(var coords: Fixed) :=
    z_Normal3xvOES_2(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3xvOES(coords: IntPtr) :=
    z_Normal3xvOES_1(coords);
    
    private z_PassThroughxOES_adr := GetProcAddress('glPassThroughxOES');
    private z_PassThroughxOES_1 := GetProcOrNil&<procedure(token: Fixed)>(z_PassThroughxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PassThroughxOES(token: Fixed) :=
    z_PassThroughxOES_1(token);
    
    private z_PixelMapx_adr := GetProcAddress('glPixelMapx');
    private z_PixelMapx_1 := GetProcOrNil&<procedure(map: PixelMap; size: Int32; values: IntPtr)>(z_PixelMapx_adr);
    private z_PixelMapx_2 := GetProcOrNil&<procedure(map: PixelMap; size: Int32; var values: Fixed)>(z_PixelMapx_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelMapx(map: PixelMap; size: Int32; values: array of Fixed);
    type PFixed=^Fixed;
    begin
      if (values<>nil) and (values.Length<>0) then
        z_PixelMapx_2(map, size, values[0]) else
        z_PixelMapx_2(map, size, PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelMapx(map: PixelMap; size: Int32; var values: Fixed) :=
    z_PixelMapx_2(map, size, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelMapx(map: PixelMap; size: Int32; values: IntPtr) :=
    z_PixelMapx_1(map, size, values);
    
    private z_PixelStorex_adr := GetProcAddress('glPixelStorex');
    private z_PixelStorex_1 := GetProcOrNil&<procedure(pname: PixelStoreParameter; param: Fixed)>(z_PixelStorex_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelStorex(pname: PixelStoreParameter; param: Fixed) :=
    z_PixelStorex_1(pname, param);
    
    private z_PixelTransferxOES_adr := GetProcAddress('glPixelTransferxOES');
    private z_PixelTransferxOES_1 := GetProcOrNil&<procedure(pname: PixelTransferParameter; param: Fixed)>(z_PixelTransferxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransferxOES(pname: PixelTransferParameter; param: Fixed) :=
    z_PixelTransferxOES_1(pname, param);
    
    private z_PixelZoomxOES_adr := GetProcAddress('glPixelZoomxOES');
    private z_PixelZoomxOES_1 := GetProcOrNil&<procedure(xfactor: Fixed; yfactor: Fixed)>(z_PixelZoomxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelZoomxOES(xfactor: Fixed; yfactor: Fixed) :=
    z_PixelZoomxOES_1(xfactor, yfactor);
    
    private z_PrioritizeTexturesxOES_adr := GetProcAddress('glPrioritizeTexturesxOES');
    private z_PrioritizeTexturesxOES_1 := GetProcOrNil&<procedure(n: Int32; textures: IntPtr; priorities: IntPtr)>(z_PrioritizeTexturesxOES_adr);
    private z_PrioritizeTexturesxOES_2 := GetProcOrNil&<procedure(n: Int32; textures: IntPtr; var priorities: Fixed)>(z_PrioritizeTexturesxOES_adr);
    private z_PrioritizeTexturesxOES_3 := GetProcOrNil&<procedure(n: Int32; var textures: gl_texture; priorities: IntPtr)>(z_PrioritizeTexturesxOES_adr);
    private z_PrioritizeTexturesxOES_4 := GetProcOrNil&<procedure(n: Int32; var textures: gl_texture; var priorities: Fixed)>(z_PrioritizeTexturesxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesxOES(n: Int32; textures: array of gl_texture; priorities: array of Fixed);
    type Pgl_texture=^gl_texture;
    type PFixed=^Fixed;
    begin
      if (priorities<>nil) and (priorities.Length<>0) then
        if (textures<>nil) and (textures.Length<>0) then
          z_PrioritizeTexturesxOES_4(n, textures[0], priorities[0]) else
          z_PrioritizeTexturesxOES_4(n, Pgl_texture(nil)^, priorities[0]) else
        if (textures<>nil) and (textures.Length<>0) then
          z_PrioritizeTexturesxOES_4(n, textures[0], PFixed(nil)^) else
          z_PrioritizeTexturesxOES_4(n, Pgl_texture(nil)^, PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesxOES(n: Int32; var textures: gl_texture; var priorities: Fixed) :=
    z_PrioritizeTexturesxOES_4(n, textures, priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesxOES(n: Int32; var textures: gl_texture; priorities: IntPtr) :=
    z_PrioritizeTexturesxOES_3(n, textures, priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesxOES(n: Int32; textures: IntPtr; var priorities: Fixed) :=
    z_PrioritizeTexturesxOES_2(n, textures, priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesxOES(n: Int32; textures: IntPtr; priorities: IntPtr) :=
    z_PrioritizeTexturesxOES_1(n, textures, priorities);
    
    private z_RasterPos2xOES_adr := GetProcAddress('glRasterPos2xOES');
    private z_RasterPos2xOES_1 := GetProcOrNil&<procedure(x: Fixed; y: Fixed)>(z_RasterPos2xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2xOES(x: Fixed; y: Fixed) :=
    z_RasterPos2xOES_1(x, y);
    
    private z_RasterPos2xvOES_adr := GetProcAddress('glRasterPos2xvOES');
    private z_RasterPos2xvOES_1 := GetProcOrNil&<procedure(coords: IntPtr)>(z_RasterPos2xvOES_adr);
    private z_RasterPos2xvOES_2 := GetProcOrNil&<procedure(var coords: Fixed)>(z_RasterPos2xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2xvOES(coords: array of Fixed);
    type PFixed=^Fixed;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_RasterPos2xvOES_2(coords[0]) else
        z_RasterPos2xvOES_2(PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2xvOES(var coords: Fixed) :=
    z_RasterPos2xvOES_2(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2xvOES(coords: IntPtr) :=
    z_RasterPos2xvOES_1(coords);
    
    private z_RasterPos3xOES_adr := GetProcAddress('glRasterPos3xOES');
    private z_RasterPos3xOES_1 := GetProcOrNil&<procedure(x: Fixed; y: Fixed; z: Fixed)>(z_RasterPos3xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3xOES(x: Fixed; y: Fixed; z: Fixed) :=
    z_RasterPos3xOES_1(x, y, z);
    
    private z_RasterPos3xvOES_adr := GetProcAddress('glRasterPos3xvOES');
    private z_RasterPos3xvOES_1 := GetProcOrNil&<procedure(coords: IntPtr)>(z_RasterPos3xvOES_adr);
    private z_RasterPos3xvOES_2 := GetProcOrNil&<procedure(var coords: Fixed)>(z_RasterPos3xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3xvOES(coords: array of Fixed);
    type PFixed=^Fixed;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_RasterPos3xvOES_2(coords[0]) else
        z_RasterPos3xvOES_2(PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3xvOES(var coords: Fixed) :=
    z_RasterPos3xvOES_2(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3xvOES(coords: IntPtr) :=
    z_RasterPos3xvOES_1(coords);
    
    private z_RasterPos4xOES_adr := GetProcAddress('glRasterPos4xOES');
    private z_RasterPos4xOES_1 := GetProcOrNil&<procedure(x: Fixed; y: Fixed; z: Fixed; w: Fixed)>(z_RasterPos4xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4xOES(x: Fixed; y: Fixed; z: Fixed; w: Fixed) :=
    z_RasterPos4xOES_1(x, y, z, w);
    
    private z_RasterPos4xvOES_adr := GetProcAddress('glRasterPos4xvOES');
    private z_RasterPos4xvOES_1 := GetProcOrNil&<procedure(coords: IntPtr)>(z_RasterPos4xvOES_adr);
    private z_RasterPos4xvOES_2 := GetProcOrNil&<procedure(var coords: Fixed)>(z_RasterPos4xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4xvOES(coords: array of Fixed);
    type PFixed=^Fixed;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_RasterPos4xvOES_2(coords[0]) else
        z_RasterPos4xvOES_2(PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4xvOES(var coords: Fixed) :=
    z_RasterPos4xvOES_2(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4xvOES(coords: IntPtr) :=
    z_RasterPos4xvOES_1(coords);
    
    private z_RectxOES_adr := GetProcAddress('glRectxOES');
    private z_RectxOES_1 := GetProcOrNil&<procedure(x1: Fixed; y1: Fixed; x2: Fixed; y2: Fixed)>(z_RectxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RectxOES(x1: Fixed; y1: Fixed; x2: Fixed; y2: Fixed) :=
    z_RectxOES_1(x1, y1, x2, y2);
    
    private z_RectxvOES_adr := GetProcAddress('glRectxvOES');
    private z_RectxvOES_1 := GetProcOrNil&<procedure(v1: IntPtr; v2: IntPtr)>(z_RectxvOES_adr);
    private z_RectxvOES_2 := GetProcOrNil&<procedure(v1: IntPtr; var v2: Fixed)>(z_RectxvOES_adr);
    private z_RectxvOES_3 := GetProcOrNil&<procedure(var v1: Fixed; v2: IntPtr)>(z_RectxvOES_adr);
    private z_RectxvOES_4 := GetProcOrNil&<procedure(var v1: Fixed; var v2: Fixed)>(z_RectxvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RectxvOES(v1: array of Fixed; v2: array of Fixed);
    type PFixed=^Fixed;
    begin
      if (v2<>nil) and (v2.Length<>0) then
        if (v1<>nil) and (v1.Length<>0) then
          z_RectxvOES_4(v1[0], v2[0]) else
          z_RectxvOES_4(PFixed(nil)^, v2[0]) else
        if (v1<>nil) and (v1.Length<>0) then
          z_RectxvOES_4(v1[0], PFixed(nil)^) else
          z_RectxvOES_4(PFixed(nil)^, PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RectxvOES(var v1: Fixed; var v2: Fixed) :=
    z_RectxvOES_4(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RectxvOES(var v1: Fixed; v2: IntPtr) :=
    z_RectxvOES_3(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RectxvOES(v1: IntPtr; var v2: Fixed) :=
    z_RectxvOES_2(v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RectxvOES(v1: IntPtr; v2: IntPtr) :=
    z_RectxvOES_1(v1, v2);
    
    private z_TexCoord1xOES_adr := GetProcAddress('glTexCoord1xOES');
    private z_TexCoord1xOES_1 := GetProcOrNil&<procedure(s: Fixed)>(z_TexCoord1xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1xOES(s: Fixed) :=
    z_TexCoord1xOES_1(s);
    
    private z_TexCoord1xvOES_adr := GetProcAddress('glTexCoord1xvOES');
    private z_TexCoord1xvOES_1 := GetProcOrNil&<procedure(coords: IntPtr)>(z_TexCoord1xvOES_adr);
    private z_TexCoord1xvOES_2 := GetProcOrNil&<procedure(var coords: Fixed)>(z_TexCoord1xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1xvOES(coords: array of Fixed);
    type PFixed=^Fixed;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_TexCoord1xvOES_2(coords[0]) else
        z_TexCoord1xvOES_2(PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1xvOES(var coords: Fixed) :=
    z_TexCoord1xvOES_2(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1xvOES(coords: IntPtr) :=
    z_TexCoord1xvOES_1(coords);
    
    private z_TexCoord2xOES_adr := GetProcAddress('glTexCoord2xOES');
    private z_TexCoord2xOES_1 := GetProcOrNil&<procedure(s: Fixed; t: Fixed)>(z_TexCoord2xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2xOES(s: Fixed; t: Fixed) :=
    z_TexCoord2xOES_1(s, t);
    
    private z_TexCoord2xvOES_adr := GetProcAddress('glTexCoord2xvOES');
    private z_TexCoord2xvOES_1 := GetProcOrNil&<procedure(coords: IntPtr)>(z_TexCoord2xvOES_adr);
    private z_TexCoord2xvOES_2 := GetProcOrNil&<procedure(var coords: Fixed)>(z_TexCoord2xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2xvOES(coords: array of Fixed);
    type PFixed=^Fixed;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_TexCoord2xvOES_2(coords[0]) else
        z_TexCoord2xvOES_2(PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2xvOES(var coords: Fixed) :=
    z_TexCoord2xvOES_2(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2xvOES(coords: IntPtr) :=
    z_TexCoord2xvOES_1(coords);
    
    private z_TexCoord3xOES_adr := GetProcAddress('glTexCoord3xOES');
    private z_TexCoord3xOES_1 := GetProcOrNil&<procedure(s: Fixed; t: Fixed; r: Fixed)>(z_TexCoord3xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3xOES(s: Fixed; t: Fixed; r: Fixed) :=
    z_TexCoord3xOES_1(s, t, r);
    
    private z_TexCoord3xvOES_adr := GetProcAddress('glTexCoord3xvOES');
    private z_TexCoord3xvOES_1 := GetProcOrNil&<procedure(coords: IntPtr)>(z_TexCoord3xvOES_adr);
    private z_TexCoord3xvOES_2 := GetProcOrNil&<procedure(var coords: Fixed)>(z_TexCoord3xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3xvOES(coords: array of Fixed);
    type PFixed=^Fixed;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_TexCoord3xvOES_2(coords[0]) else
        z_TexCoord3xvOES_2(PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3xvOES(var coords: Fixed) :=
    z_TexCoord3xvOES_2(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3xvOES(coords: IntPtr) :=
    z_TexCoord3xvOES_1(coords);
    
    private z_TexCoord4xOES_adr := GetProcAddress('glTexCoord4xOES');
    private z_TexCoord4xOES_1 := GetProcOrNil&<procedure(s: Fixed; t: Fixed; r: Fixed; q: Fixed)>(z_TexCoord4xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4xOES(s: Fixed; t: Fixed; r: Fixed; q: Fixed) :=
    z_TexCoord4xOES_1(s, t, r, q);
    
    private z_TexCoord4xvOES_adr := GetProcAddress('glTexCoord4xvOES');
    private z_TexCoord4xvOES_1 := GetProcOrNil&<procedure(coords: IntPtr)>(z_TexCoord4xvOES_adr);
    private z_TexCoord4xvOES_2 := GetProcOrNil&<procedure(var coords: Fixed)>(z_TexCoord4xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4xvOES(coords: array of Fixed);
    type PFixed=^Fixed;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_TexCoord4xvOES_2(coords[0]) else
        z_TexCoord4xvOES_2(PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4xvOES(var coords: Fixed) :=
    z_TexCoord4xvOES_2(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4xvOES(coords: IntPtr) :=
    z_TexCoord4xvOES_1(coords);
    
    private z_TexGenxOES_adr := GetProcAddress('glTexGenxOES');
    private z_TexGenxOES_1 := GetProcOrNil&<procedure(coord: TextureCoordName; pname: TextureGenParameter; param: Fixed)>(z_TexGenxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenxOES(coord: TextureCoordName; pname: TextureGenParameter; param: Fixed) :=
    z_TexGenxOES_1(coord, pname, param);
    
    private z_TexGenxvOES_adr := GetProcAddress('glTexGenxvOES');
    private z_TexGenxvOES_1 := GetProcOrNil&<procedure(coord: TextureCoordName; pname: TextureGenParameter; &params: IntPtr)>(z_TexGenxvOES_adr);
    private z_TexGenxvOES_2 := GetProcOrNil&<procedure(coord: TextureCoordName; pname: TextureGenParameter; var &params: Fixed)>(z_TexGenxvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenxvOES(coord: TextureCoordName; pname: TextureGenParameter; &params: array of Fixed);
    type PFixed=^Fixed;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_TexGenxvOES_2(coord, pname, &params[0]) else
        z_TexGenxvOES_2(coord, pname, PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenxvOES(coord: TextureCoordName; pname: TextureGenParameter; var &params: Fixed) :=
    z_TexGenxvOES_2(coord, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenxvOES(coord: TextureCoordName; pname: TextureGenParameter; &params: IntPtr) :=
    z_TexGenxvOES_1(coord, pname, &params);
    
    private z_Vertex2xOES_adr := GetProcAddress('glVertex2xOES');
    private z_Vertex2xOES_1 := GetProcOrNil&<procedure(x: Fixed)>(z_Vertex2xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2xOES(x: Fixed) :=
    z_Vertex2xOES_1(x);
    
    private z_Vertex2xvOES_adr := GetProcAddress('glVertex2xvOES');
    private z_Vertex2xvOES_1 := GetProcOrNil&<procedure(coords: IntPtr)>(z_Vertex2xvOES_adr);
    private z_Vertex2xvOES_2 := GetProcOrNil&<procedure(var coords: Fixed)>(z_Vertex2xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2xvOES(coords: array of Fixed);
    type PFixed=^Fixed;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_Vertex2xvOES_2(coords[0]) else
        z_Vertex2xvOES_2(PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2xvOES(var coords: Fixed) :=
    z_Vertex2xvOES_2(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2xvOES(coords: IntPtr) :=
    z_Vertex2xvOES_1(coords);
    
    private z_Vertex3xOES_adr := GetProcAddress('glVertex3xOES');
    private z_Vertex3xOES_1 := GetProcOrNil&<procedure(x: Fixed; y: Fixed)>(z_Vertex3xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3xOES(x: Fixed; y: Fixed) :=
    z_Vertex3xOES_1(x, y);
    
    private z_Vertex3xvOES_adr := GetProcAddress('glVertex3xvOES');
    private z_Vertex3xvOES_1 := GetProcOrNil&<procedure(coords: IntPtr)>(z_Vertex3xvOES_adr);
    private z_Vertex3xvOES_2 := GetProcOrNil&<procedure(var coords: Fixed)>(z_Vertex3xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3xvOES(coords: array of Fixed);
    type PFixed=^Fixed;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_Vertex3xvOES_2(coords[0]) else
        z_Vertex3xvOES_2(PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3xvOES(var coords: Fixed) :=
    z_Vertex3xvOES_2(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3xvOES(coords: IntPtr) :=
    z_Vertex3xvOES_1(coords);
    
    private z_Vertex4xOES_adr := GetProcAddress('glVertex4xOES');
    private z_Vertex4xOES_1 := GetProcOrNil&<procedure(x: Fixed; y: Fixed; z: Fixed)>(z_Vertex4xOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4xOES(x: Fixed; y: Fixed; z: Fixed) :=
    z_Vertex4xOES_1(x, y, z);
    
    private z_Vertex4xvOES_adr := GetProcAddress('glVertex4xvOES');
    private z_Vertex4xvOES_1 := GetProcOrNil&<procedure(coords: IntPtr)>(z_Vertex4xvOES_adr);
    private z_Vertex4xvOES_2 := GetProcOrNil&<procedure(var coords: Fixed)>(z_Vertex4xvOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4xvOES(coords: array of Fixed);
    type PFixed=^Fixed;
    begin
      if (coords<>nil) and (coords.Length<>0) then
        z_Vertex4xvOES_2(coords[0]) else
        z_Vertex4xvOES_2(PFixed(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4xvOES(var coords: Fixed) :=
    z_Vertex4xvOES_2(coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4xvOES(coords: IntPtr) :=
    z_Vertex4xvOES_1(coords);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glQueryMatrixOES = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_oes_query_matrix';
    
    private z_QueryMatrixxOES_adr := GetProcAddress('glQueryMatrixxOES');
    private z_QueryMatrixxOES_1 := GetProcOrNil&<function(mantissa: IntPtr; exponent: IntPtr): DummyFlags>(z_QueryMatrixxOES_adr);
    private z_QueryMatrixxOES_2 := GetProcOrNil&<function(mantissa: IntPtr; var exponent: Int32): DummyFlags>(z_QueryMatrixxOES_adr);
    private z_QueryMatrixxOES_3 := GetProcOrNil&<function(var mantissa: Fixed; exponent: IntPtr): DummyFlags>(z_QueryMatrixxOES_adr);
    private z_QueryMatrixxOES_4 := GetProcOrNil&<function(var mantissa: Fixed; var exponent: Int32): DummyFlags>(z_QueryMatrixxOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMatrixxOES(mantissa: array of Fixed; exponent: array of Int32): DummyFlags;
    type PFixed=^Fixed;
    type PInt32=^Int32;
    begin
      Result := if (exponent<>nil) and (exponent.Length<>0) then
        if (mantissa<>nil) and (mantissa.Length<>0) then
          z_QueryMatrixxOES_4(mantissa[0], exponent[0]) else
          z_QueryMatrixxOES_4(PFixed(nil)^, exponent[0]) else
        if (mantissa<>nil) and (mantissa.Length<>0) then
          z_QueryMatrixxOES_4(mantissa[0], PInt32(nil)^) else
          z_QueryMatrixxOES_4(PFixed(nil)^, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMatrixxOES(var mantissa: Fixed; var exponent: Int32): DummyFlags :=
    z_QueryMatrixxOES_4(mantissa, exponent);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMatrixxOES(var mantissa: Fixed; exponent: IntPtr): DummyFlags :=
    z_QueryMatrixxOES_3(mantissa, exponent);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMatrixxOES(mantissa: IntPtr; var exponent: Int32): DummyFlags :=
    z_QueryMatrixxOES_2(mantissa, exponent);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMatrixxOES(mantissa: IntPtr; exponent: IntPtr): DummyFlags :=
    z_QueryMatrixxOES_1(mantissa, exponent);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glSinglePrecisionOES = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_oes_single_precision';
    
    private z_ClearDepthfOES_adr := GetProcAddress('glClearDepthfOES');
    private z_ClearDepthfOES_1 := GetProcOrNil&<procedure(depth: single)>(z_ClearDepthfOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearDepthfOES(depth: single) :=
    z_ClearDepthfOES_1(depth);
    
    private z_ClipPlanefOES_adr := GetProcAddress('glClipPlanefOES');
    private z_ClipPlanefOES_1 := GetProcOrNil&<procedure(plane: ClipPlaneName; equation: IntPtr)>(z_ClipPlanefOES_adr);
    private z_ClipPlanefOES_2 := GetProcOrNil&<procedure(plane: ClipPlaneName; var equation: single)>(z_ClipPlanefOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlanefOES(plane: ClipPlaneName; equation: array of single);
    type Psingle=^single;
    begin
      if (equation<>nil) and (equation.Length<>0) then
        z_ClipPlanefOES_2(plane, equation[0]) else
        z_ClipPlanefOES_2(plane, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlanefOES(plane: ClipPlaneName; var equation: single) :=
    z_ClipPlanefOES_2(plane, equation);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlanefOES(plane: ClipPlaneName; equation: IntPtr) :=
    z_ClipPlanefOES_1(plane, equation);
    
    private z_DepthRangefOES_adr := GetProcAddress('glDepthRangefOES');
    private z_DepthRangefOES_1 := GetProcOrNil&<procedure(n: single; f: single)>(z_DepthRangefOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangefOES(n: single; f: single) :=
    z_DepthRangefOES_1(n, f);
    
    private z_FrustumfOES_adr := GetProcAddress('glFrustumfOES');
    private z_FrustumfOES_1 := GetProcOrNil&<procedure(l: single; r: single; b: single; t: single; n: single; f: single)>(z_FrustumfOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FrustumfOES(l: single; r: single; b: single; t: single; n: single; f: single) :=
    z_FrustumfOES_1(l, r, b, t, n, f);
    
    private z_GetClipPlanefOES_adr := GetProcAddress('glGetClipPlanefOES');
    private z_GetClipPlanefOES_1 := GetProcOrNil&<procedure(plane: ClipPlaneName; equation: IntPtr)>(z_GetClipPlanefOES_adr);
    private z_GetClipPlanefOES_2 := GetProcOrNil&<procedure(plane: ClipPlaneName; var equation: single)>(z_GetClipPlanefOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetClipPlanefOES(plane: ClipPlaneName; var equation: single) :=
    z_GetClipPlanefOES_2(plane, equation);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetClipPlanefOES(plane: ClipPlaneName; equation: IntPtr) :=
    z_GetClipPlanefOES_1(plane, equation);
    
    private z_OrthofOES_adr := GetProcAddress('glOrthofOES');
    private z_OrthofOES_1 := GetProcOrNil&<procedure(l: single; r: single; b: single; t: single; n: single; f: single)>(z_OrthofOES_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure OrthofOES(l: single; r: single; b: single; t: single; n: single; f: single) :=
    z_OrthofOES_1(l, r, b, t, n, f);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glMultiviewOVR = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_ovr_multiview';
    
    private z_FramebufferTextureMultiviewOVR_adr := GetProcAddress('glFramebufferTextureMultiviewOVR');
    private z_FramebufferTextureMultiviewOVR_1 := GetProcOrNil&<procedure(target: FramebufferTarget; attachment: FramebufferAttachment; texture: gl_texture; level: Int32; baseViewIndex: Int32; numViews: Int32)>(z_FramebufferTextureMultiviewOVR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTextureMultiviewOVR(target: FramebufferTarget; attachment: FramebufferAttachment; texture: gl_texture; level: Int32; baseViewIndex: Int32; numViews: Int32) :=
    z_FramebufferTextureMultiviewOVR_1(target, attachment, texture, level, baseViewIndex, numViews);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glMiscHintsPGI = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_pgi_misc_hints';
    
    private z_HintPGI_adr := GetProcAddress('glHintPGI');
    private z_HintPGI_1 := GetProcOrNil&<procedure(target: HintTargetPGI; mode: VertexHintsMask)>(z_HintPGI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure HintPGI(target: HintTargetPGI; mode: VertexHintsMask) :=
    z_HintPGI_1(target, mode);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glDetailTextureSGIS = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_sgis_detail_texture';
    
    private z_DetailTexFuncSGIS_adr := GetProcAddress('glDetailTexFuncSGIS');
    private z_DetailTexFuncSGIS_1 := GetProcOrNil&<procedure(target: TextureTarget; n: Int32; points: IntPtr)>(z_DetailTexFuncSGIS_adr);
    private z_DetailTexFuncSGIS_2 := GetProcOrNil&<procedure(target: TextureTarget; n: Int32; var points: single)>(z_DetailTexFuncSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DetailTexFuncSGIS(target: TextureTarget; n: Int32; points: array of single);
    type Psingle=^single;
    begin
      if (points<>nil) and (points.Length<>0) then
        z_DetailTexFuncSGIS_2(target, n, points[0]) else
        z_DetailTexFuncSGIS_2(target, n, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DetailTexFuncSGIS(target: TextureTarget; n: Int32; var points: single) :=
    z_DetailTexFuncSGIS_2(target, n, points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DetailTexFuncSGIS(target: TextureTarget; n: Int32; points: IntPtr) :=
    z_DetailTexFuncSGIS_1(target, n, points);
    
    private z_GetDetailTexFuncSGIS_adr := GetProcAddress('glGetDetailTexFuncSGIS');
    private z_GetDetailTexFuncSGIS_1 := GetProcOrNil&<procedure(target: TextureTarget; points: IntPtr)>(z_GetDetailTexFuncSGIS_adr);
    private z_GetDetailTexFuncSGIS_2 := GetProcOrNil&<procedure(target: TextureTarget; var points: single)>(z_GetDetailTexFuncSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDetailTexFuncSGIS(target: TextureTarget; var points: single) :=
    z_GetDetailTexFuncSGIS_2(target, points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDetailTexFuncSGIS(target: TextureTarget; points: IntPtr) :=
    z_GetDetailTexFuncSGIS_1(target, points);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glFogFunctionSGIS = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_sgis_fog_function';
    
    private z_FogFuncSGIS_adr := GetProcAddress('glFogFuncSGIS');
    private z_FogFuncSGIS_1 := GetProcOrNil&<procedure(n: Int32; points: IntPtr)>(z_FogFuncSGIS_adr);
    private z_FogFuncSGIS_2 := GetProcOrNil&<procedure(n: Int32; var points: single)>(z_FogFuncSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogFuncSGIS(n: Int32; points: array of single);
    type Psingle=^single;
    begin
      if (points<>nil) and (points.Length<>0) then
        z_FogFuncSGIS_2(n, points[0]) else
        z_FogFuncSGIS_2(n, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogFuncSGIS(n: Int32; var points: single) :=
    z_FogFuncSGIS_2(n, points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogFuncSGIS(n: Int32; points: IntPtr) :=
    z_FogFuncSGIS_1(n, points);
    
    private z_GetFogFuncSGIS_adr := GetProcAddress('glGetFogFuncSGIS');
    private z_GetFogFuncSGIS_1 := GetProcOrNil&<procedure(points: IntPtr)>(z_GetFogFuncSGIS_adr);
    private z_GetFogFuncSGIS_2 := GetProcOrNil&<procedure(var points: single)>(z_GetFogFuncSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFogFuncSGIS(var points: single) :=
    z_GetFogFuncSGIS_2(points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFogFuncSGIS(points: IntPtr) :=
    z_GetFogFuncSGIS_1(points);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glMultisampleSGIS = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_sgis_multisample';
    
    private z_SampleMaskSGIS_adr := GetProcAddress('glSampleMaskSGIS');
    private z_SampleMaskSGIS_1 := GetProcOrNil&<procedure(value: single; invert: boolean)>(z_SampleMaskSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SampleMaskSGIS(value: single; invert: boolean) :=
    z_SampleMaskSGIS_1(value, invert);
    
    private z_SamplePatternSGIS_adr := GetProcAddress('glSamplePatternSGIS');
    private z_SamplePatternSGIS_1 := GetProcOrNil&<procedure(pattern: SamplePattern)>(z_SamplePatternSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplePatternSGIS(pattern: SamplePattern) :=
    z_SamplePatternSGIS_1(pattern);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glPixelTextureSGIS = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_sgis_pixel_texture';
    
    private z_PixelTexGenParameteriSGIS_adr := GetProcAddress('glPixelTexGenParameteriSGIS');
    private z_PixelTexGenParameteriSGIS_1 := GetProcOrNil&<procedure(pname: PixelTexGenParameterName; param: Int32)>(z_PixelTexGenParameteriSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTexGenParameteriSGIS(pname: PixelTexGenParameterName; param: Int32) :=
    z_PixelTexGenParameteriSGIS_1(pname, param);
    
    private z_PixelTexGenParameterivSGIS_adr := GetProcAddress('glPixelTexGenParameterivSGIS');
    private z_PixelTexGenParameterivSGIS_1 := GetProcOrNil&<procedure(pname: PixelTexGenParameterName; &params: IntPtr)>(z_PixelTexGenParameterivSGIS_adr);
    private z_PixelTexGenParameterivSGIS_2 := GetProcOrNil&<procedure(pname: PixelTexGenParameterName; var &params: Int32)>(z_PixelTexGenParameterivSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTexGenParameterivSGIS(pname: PixelTexGenParameterName; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_PixelTexGenParameterivSGIS_2(pname, &params[0]) else
        z_PixelTexGenParameterivSGIS_2(pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTexGenParameterivSGIS(pname: PixelTexGenParameterName; var &params: Int32) :=
    z_PixelTexGenParameterivSGIS_2(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTexGenParameterivSGIS(pname: PixelTexGenParameterName; &params: IntPtr) :=
    z_PixelTexGenParameterivSGIS_1(pname, &params);
    
    private z_PixelTexGenParameterfSGIS_adr := GetProcAddress('glPixelTexGenParameterfSGIS');
    private z_PixelTexGenParameterfSGIS_1 := GetProcOrNil&<procedure(pname: PixelTexGenParameterName; param: single)>(z_PixelTexGenParameterfSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTexGenParameterfSGIS(pname: PixelTexGenParameterName; param: single) :=
    z_PixelTexGenParameterfSGIS_1(pname, param);
    
    private z_PixelTexGenParameterfvSGIS_adr := GetProcAddress('glPixelTexGenParameterfvSGIS');
    private z_PixelTexGenParameterfvSGIS_1 := GetProcOrNil&<procedure(pname: PixelTexGenParameterName; &params: IntPtr)>(z_PixelTexGenParameterfvSGIS_adr);
    private z_PixelTexGenParameterfvSGIS_2 := GetProcOrNil&<procedure(pname: PixelTexGenParameterName; var &params: single)>(z_PixelTexGenParameterfvSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTexGenParameterfvSGIS(pname: PixelTexGenParameterName; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_PixelTexGenParameterfvSGIS_2(pname, &params[0]) else
        z_PixelTexGenParameterfvSGIS_2(pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTexGenParameterfvSGIS(pname: PixelTexGenParameterName; var &params: single) :=
    z_PixelTexGenParameterfvSGIS_2(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTexGenParameterfvSGIS(pname: PixelTexGenParameterName; &params: IntPtr) :=
    z_PixelTexGenParameterfvSGIS_1(pname, &params);
    
    private z_GetPixelTexGenParameterivSGIS_adr := GetProcAddress('glGetPixelTexGenParameterivSGIS');
    private z_GetPixelTexGenParameterivSGIS_1 := GetProcOrNil&<procedure(pname: PixelTexGenParameterName; &params: IntPtr)>(z_GetPixelTexGenParameterivSGIS_adr);
    private z_GetPixelTexGenParameterivSGIS_2 := GetProcOrNil&<procedure(pname: PixelTexGenParameterName; var &params: Int32)>(z_GetPixelTexGenParameterivSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTexGenParameterivSGIS(pname: PixelTexGenParameterName; var &params: Int32) :=
    z_GetPixelTexGenParameterivSGIS_2(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTexGenParameterivSGIS(pname: PixelTexGenParameterName; &params: IntPtr) :=
    z_GetPixelTexGenParameterivSGIS_1(pname, &params);
    
    private z_GetPixelTexGenParameterfvSGIS_adr := GetProcAddress('glGetPixelTexGenParameterfvSGIS');
    private z_GetPixelTexGenParameterfvSGIS_1 := GetProcOrNil&<procedure(pname: PixelTexGenParameterName; &params: IntPtr)>(z_GetPixelTexGenParameterfvSGIS_adr);
    private z_GetPixelTexGenParameterfvSGIS_2 := GetProcOrNil&<procedure(pname: PixelTexGenParameterName; var &params: single)>(z_GetPixelTexGenParameterfvSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTexGenParameterfvSGIS(pname: PixelTexGenParameterName; var &params: single) :=
    z_GetPixelTexGenParameterfvSGIS_2(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTexGenParameterfvSGIS(pname: PixelTexGenParameterName; &params: IntPtr) :=
    z_GetPixelTexGenParameterfvSGIS_1(pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glPointParametersSGIS = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_sgis_point_parameters';
    
    private z_PointParameterfSGIS_adr := GetProcAddress('glPointParameterfSGIS');
    private z_PointParameterfSGIS_1 := GetProcOrNil&<procedure(pname: PointParameterName; param: single)>(z_PointParameterfSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfSGIS(pname: PointParameterName; param: single) :=
    z_PointParameterfSGIS_1(pname, param);
    
    private z_PointParameterfvSGIS_adr := GetProcAddress('glPointParameterfvSGIS');
    private z_PointParameterfvSGIS_1 := GetProcOrNil&<procedure(pname: PointParameterName; &params: IntPtr)>(z_PointParameterfvSGIS_adr);
    private z_PointParameterfvSGIS_2 := GetProcOrNil&<procedure(pname: PointParameterName; var &params: single)>(z_PointParameterfvSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfvSGIS(pname: PointParameterName; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_PointParameterfvSGIS_2(pname, &params[0]) else
        z_PointParameterfvSGIS_2(pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfvSGIS(pname: PointParameterName; var &params: single) :=
    z_PointParameterfvSGIS_2(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfvSGIS(pname: PointParameterName; &params: IntPtr) :=
    z_PointParameterfvSGIS_1(pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glSharpenTextureSGIS = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_sgis_sharpen_texture';
    
    private z_SharpenTexFuncSGIS_adr := GetProcAddress('glSharpenTexFuncSGIS');
    private z_SharpenTexFuncSGIS_1 := GetProcOrNil&<procedure(target: TextureTarget; n: Int32; points: IntPtr)>(z_SharpenTexFuncSGIS_adr);
    private z_SharpenTexFuncSGIS_2 := GetProcOrNil&<procedure(target: TextureTarget; n: Int32; var points: single)>(z_SharpenTexFuncSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SharpenTexFuncSGIS(target: TextureTarget; n: Int32; points: array of single);
    type Psingle=^single;
    begin
      if (points<>nil) and (points.Length<>0) then
        z_SharpenTexFuncSGIS_2(target, n, points[0]) else
        z_SharpenTexFuncSGIS_2(target, n, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SharpenTexFuncSGIS(target: TextureTarget; n: Int32; var points: single) :=
    z_SharpenTexFuncSGIS_2(target, n, points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SharpenTexFuncSGIS(target: TextureTarget; n: Int32; points: IntPtr) :=
    z_SharpenTexFuncSGIS_1(target, n, points);
    
    private z_GetSharpenTexFuncSGIS_adr := GetProcAddress('glGetSharpenTexFuncSGIS');
    private z_GetSharpenTexFuncSGIS_1 := GetProcOrNil&<procedure(target: TextureTarget; points: IntPtr)>(z_GetSharpenTexFuncSGIS_adr);
    private z_GetSharpenTexFuncSGIS_2 := GetProcOrNil&<procedure(target: TextureTarget; var points: single)>(z_GetSharpenTexFuncSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSharpenTexFuncSGIS(target: TextureTarget; var points: single) :=
    z_GetSharpenTexFuncSGIS_2(target, points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSharpenTexFuncSGIS(target: TextureTarget; points: IntPtr) :=
    z_GetSharpenTexFuncSGIS_1(target, points);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glTexture4DSGIS = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_sgis_texture4d';
    
    private z_TexImage4DSGIS_adr := GetProcAddress('glTexImage4DSGIS');
    private z_TexImage4DSGIS_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; depth: Int32; size4d: Int32; border: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr)>(z_TexImage4DSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage4DSGIS(target: TextureTarget; level: Int32; _internalformat: InternalFormat; width: Int32; height: Int32; depth: Int32; size4d: Int32; border: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr) :=
    z_TexImage4DSGIS_1(target, level, _internalformat, width, height, depth, size4d, border, format, &type, pixels);
    
    private z_TexSubImage4DSGIS_adr := GetProcAddress('glTexSubImage4DSGIS');
    private z_TexSubImage4DSGIS_1 := GetProcOrNil&<procedure(target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; woffset: Int32; width: Int32; height: Int32; depth: Int32; size4d: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr)>(z_TexSubImage4DSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexSubImage4DSGIS(target: TextureTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; woffset: Int32; width: Int32; height: Int32; depth: Int32; size4d: Int32; format: PixelFormat; &type: PixelType; pixels: IntPtr) :=
    z_TexSubImage4DSGIS_1(target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, &type, pixels);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glTextureColorMaskSGIS = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_sgis_texture_color_mask';
    
    private z_TextureColorMaskSGIS_adr := GetProcAddress('glTextureColorMaskSGIS');
    private z_TextureColorMaskSGIS_1 := GetProcOrNil&<procedure(red: boolean; green: boolean; blue: boolean; alpha: boolean)>(z_TextureColorMaskSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureColorMaskSGIS(red: boolean; green: boolean; blue: boolean; alpha: boolean) :=
    z_TextureColorMaskSGIS_1(red, green, blue, alpha);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glTextureFilter4SGIS = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_sgis_texture_filter4';
    
    private z_GetTexFilterFuncSGIS_adr := GetProcAddress('glGetTexFilterFuncSGIS');
    private z_GetTexFilterFuncSGIS_1 := GetProcOrNil&<procedure(target: TextureTarget; filter: TextureFilter; weights: IntPtr)>(z_GetTexFilterFuncSGIS_adr);
    private z_GetTexFilterFuncSGIS_2 := GetProcOrNil&<procedure(target: TextureTarget; filter: TextureFilter; var weights: single)>(z_GetTexFilterFuncSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexFilterFuncSGIS(target: TextureTarget; filter: TextureFilter; var weights: single) :=
    z_GetTexFilterFuncSGIS_2(target, filter, weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexFilterFuncSGIS(target: TextureTarget; filter: TextureFilter; weights: IntPtr) :=
    z_GetTexFilterFuncSGIS_1(target, filter, weights);
    
    private z_TexFilterFuncSGIS_adr := GetProcAddress('glTexFilterFuncSGIS');
    private z_TexFilterFuncSGIS_1 := GetProcOrNil&<procedure(target: TextureTarget; filter: TextureFilter; n: Int32; weights: IntPtr)>(z_TexFilterFuncSGIS_adr);
    private z_TexFilterFuncSGIS_2 := GetProcOrNil&<procedure(target: TextureTarget; filter: TextureFilter; n: Int32; var weights: single)>(z_TexFilterFuncSGIS_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexFilterFuncSGIS(target: TextureTarget; filter: TextureFilter; n: Int32; weights: array of single);
    type Psingle=^single;
    begin
      if (weights<>nil) and (weights.Length<>0) then
        z_TexFilterFuncSGIS_2(target, filter, n, weights[0]) else
        z_TexFilterFuncSGIS_2(target, filter, n, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexFilterFuncSGIS(target: TextureTarget; filter: TextureFilter; n: Int32; var weights: single) :=
    z_TexFilterFuncSGIS_2(target, filter, n, weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexFilterFuncSGIS(target: TextureTarget; filter: TextureFilter; n: Int32; weights: IntPtr) :=
    z_TexFilterFuncSGIS_1(target, filter, n, weights);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glAsyncSGIX = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_sgix_async';
    
    private z_AsyncMarkerSGIX_adr := GetProcAddress('glAsyncMarkerSGIX');
    private z_AsyncMarkerSGIX_1 := GetProcOrNil&<procedure(marker: UInt32)>(z_AsyncMarkerSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AsyncMarkerSGIX(marker: UInt32) :=
    z_AsyncMarkerSGIX_1(marker);
    
    private z_FinishAsyncSGIX_adr := GetProcAddress('glFinishAsyncSGIX');
    private z_FinishAsyncSGIX_1 := GetProcOrNil&<function(markerp: IntPtr): Int32>(z_FinishAsyncSGIX_adr);
    private z_FinishAsyncSGIX_2 := GetProcOrNil&<function(var markerp: UInt32): Int32>(z_FinishAsyncSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function FinishAsyncSGIX(markerp: array of UInt32): Int32;
    type PUInt32=^UInt32;
    begin
      Result := if (markerp<>nil) and (markerp.Length<>0) then
        z_FinishAsyncSGIX_2(markerp[0]) else
        z_FinishAsyncSGIX_2(PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function FinishAsyncSGIX(var markerp: UInt32): Int32 :=
    z_FinishAsyncSGIX_2(markerp);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function FinishAsyncSGIX(markerp: IntPtr): Int32 :=
    z_FinishAsyncSGIX_1(markerp);
    
    private z_PollAsyncSGIX_adr := GetProcAddress('glPollAsyncSGIX');
    private z_PollAsyncSGIX_1 := GetProcOrNil&<function(markerp: IntPtr): Int32>(z_PollAsyncSGIX_adr);
    private z_PollAsyncSGIX_2 := GetProcOrNil&<function(var markerp: UInt32): Int32>(z_PollAsyncSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PollAsyncSGIX(markerp: array of UInt32): Int32;
    type PUInt32=^UInt32;
    begin
      Result := if (markerp<>nil) and (markerp.Length<>0) then
        z_PollAsyncSGIX_2(markerp[0]) else
        z_PollAsyncSGIX_2(PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PollAsyncSGIX(var markerp: UInt32): Int32 :=
    z_PollAsyncSGIX_2(markerp);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PollAsyncSGIX(markerp: IntPtr): Int32 :=
    z_PollAsyncSGIX_1(markerp);
    
    private z_GenAsyncMarkersSGIX_adr := GetProcAddress('glGenAsyncMarkersSGIX');
    private z_GenAsyncMarkersSGIX_1 := GetProcOrNil&<function(range: Int32): UInt32>(z_GenAsyncMarkersSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenAsyncMarkersSGIX(range: Int32): UInt32 :=
    z_GenAsyncMarkersSGIX_1(range);
    
    private z_DeleteAsyncMarkersSGIX_adr := GetProcAddress('glDeleteAsyncMarkersSGIX');
    private z_DeleteAsyncMarkersSGIX_1 := GetProcOrNil&<procedure(marker: UInt32; range: Int32)>(z_DeleteAsyncMarkersSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteAsyncMarkersSGIX(marker: UInt32; range: Int32) :=
    z_DeleteAsyncMarkersSGIX_1(marker, range);
    
    private z_IsAsyncMarkerSGIX_adr := GetProcAddress('glIsAsyncMarkerSGIX');
    private z_IsAsyncMarkerSGIX_1 := GetProcOrNil&<function(marker: UInt32): boolean>(z_IsAsyncMarkerSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsAsyncMarkerSGIX(marker: UInt32): boolean :=
    z_IsAsyncMarkerSGIX_1(marker);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glFlushRasterSGIX = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_sgix_flush_raster';
    
    private z_FlushRasterSGIX_adr := GetProcAddress('glFlushRasterSGIX');
    private z_FlushRasterSGIX_1 := GetProcOrNil&<procedure>(z_FlushRasterSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FlushRasterSGIX :=
    z_FlushRasterSGIX_1();
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glFragmentLightingSGIX = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_sgix_fragment_lighting';
    
    private z_FragmentColorMaterialSGIX_adr := GetProcAddress('glFragmentColorMaterialSGIX');
    private z_FragmentColorMaterialSGIX_1 := GetProcOrNil&<procedure(face: MaterialFace; mode: MaterialParameter)>(z_FragmentColorMaterialSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentColorMaterialSGIX(face: MaterialFace; mode: MaterialParameter) :=
    z_FragmentColorMaterialSGIX_1(face, mode);
    
    private z_FragmentLightfSGIX_adr := GetProcAddress('glFragmentLightfSGIX');
    private z_FragmentLightfSGIX_1 := GetProcOrNil&<procedure(light: FragmentLightName; pname: FragmentLightParameter; param: single)>(z_FragmentLightfSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightfSGIX(light: FragmentLightName; pname: FragmentLightParameter; param: single) :=
    z_FragmentLightfSGIX_1(light, pname, param);
    
    private z_FragmentLightfvSGIX_adr := GetProcAddress('glFragmentLightfvSGIX');
    private z_FragmentLightfvSGIX_1 := GetProcOrNil&<procedure(light: FragmentLightName; pname: FragmentLightParameter; &params: IntPtr)>(z_FragmentLightfvSGIX_adr);
    private z_FragmentLightfvSGIX_2 := GetProcOrNil&<procedure(light: FragmentLightName; pname: FragmentLightParameter; var &params: single)>(z_FragmentLightfvSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightfvSGIX(light: FragmentLightName; pname: FragmentLightParameter; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_FragmentLightfvSGIX_2(light, pname, &params[0]) else
        z_FragmentLightfvSGIX_2(light, pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightfvSGIX(light: FragmentLightName; pname: FragmentLightParameter; var &params: single) :=
    z_FragmentLightfvSGIX_2(light, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightfvSGIX(light: FragmentLightName; pname: FragmentLightParameter; &params: IntPtr) :=
    z_FragmentLightfvSGIX_1(light, pname, &params);
    
    private z_FragmentLightiSGIX_adr := GetProcAddress('glFragmentLightiSGIX');
    private z_FragmentLightiSGIX_1 := GetProcOrNil&<procedure(light: FragmentLightName; pname: FragmentLightParameter; param: Int32)>(z_FragmentLightiSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightiSGIX(light: FragmentLightName; pname: FragmentLightParameter; param: Int32) :=
    z_FragmentLightiSGIX_1(light, pname, param);
    
    private z_FragmentLightivSGIX_adr := GetProcAddress('glFragmentLightivSGIX');
    private z_FragmentLightivSGIX_1 := GetProcOrNil&<procedure(light: FragmentLightName; pname: FragmentLightParameter; &params: IntPtr)>(z_FragmentLightivSGIX_adr);
    private z_FragmentLightivSGIX_2 := GetProcOrNil&<procedure(light: FragmentLightName; pname: FragmentLightParameter; var &params: Int32)>(z_FragmentLightivSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightivSGIX(light: FragmentLightName; pname: FragmentLightParameter; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_FragmentLightivSGIX_2(light, pname, &params[0]) else
        z_FragmentLightivSGIX_2(light, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightivSGIX(light: FragmentLightName; pname: FragmentLightParameter; var &params: Int32) :=
    z_FragmentLightivSGIX_2(light, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightivSGIX(light: FragmentLightName; pname: FragmentLightParameter; &params: IntPtr) :=
    z_FragmentLightivSGIX_1(light, pname, &params);
    
    private z_FragmentLightModelfSGIX_adr := GetProcAddress('glFragmentLightModelfSGIX');
    private z_FragmentLightModelfSGIX_1 := GetProcOrNil&<procedure(pname: FragmentLightModelParameter; param: single)>(z_FragmentLightModelfSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightModelfSGIX(pname: FragmentLightModelParameter; param: single) :=
    z_FragmentLightModelfSGIX_1(pname, param);
    
    private z_FragmentLightModelfvSGIX_adr := GetProcAddress('glFragmentLightModelfvSGIX');
    private z_FragmentLightModelfvSGIX_1 := GetProcOrNil&<procedure(pname: FragmentLightModelParameter; &params: IntPtr)>(z_FragmentLightModelfvSGIX_adr);
    private z_FragmentLightModelfvSGIX_2 := GetProcOrNil&<procedure(pname: FragmentLightModelParameter; var &params: single)>(z_FragmentLightModelfvSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightModelfvSGIX(pname: FragmentLightModelParameter; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_FragmentLightModelfvSGIX_2(pname, &params[0]) else
        z_FragmentLightModelfvSGIX_2(pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightModelfvSGIX(pname: FragmentLightModelParameter; var &params: single) :=
    z_FragmentLightModelfvSGIX_2(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightModelfvSGIX(pname: FragmentLightModelParameter; &params: IntPtr) :=
    z_FragmentLightModelfvSGIX_1(pname, &params);
    
    private z_FragmentLightModeliSGIX_adr := GetProcAddress('glFragmentLightModeliSGIX');
    private z_FragmentLightModeliSGIX_1 := GetProcOrNil&<procedure(pname: FragmentLightModelParameter; param: Int32)>(z_FragmentLightModeliSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightModeliSGIX(pname: FragmentLightModelParameter; param: Int32) :=
    z_FragmentLightModeliSGIX_1(pname, param);
    
    private z_FragmentLightModelivSGIX_adr := GetProcAddress('glFragmentLightModelivSGIX');
    private z_FragmentLightModelivSGIX_1 := GetProcOrNil&<procedure(pname: FragmentLightModelParameter; &params: IntPtr)>(z_FragmentLightModelivSGIX_adr);
    private z_FragmentLightModelivSGIX_2 := GetProcOrNil&<procedure(pname: FragmentLightModelParameter; var &params: Int32)>(z_FragmentLightModelivSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightModelivSGIX(pname: FragmentLightModelParameter; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_FragmentLightModelivSGIX_2(pname, &params[0]) else
        z_FragmentLightModelivSGIX_2(pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightModelivSGIX(pname: FragmentLightModelParameter; var &params: Int32) :=
    z_FragmentLightModelivSGIX_2(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightModelivSGIX(pname: FragmentLightModelParameter; &params: IntPtr) :=
    z_FragmentLightModelivSGIX_1(pname, &params);
    
    private z_FragmentMaterialfSGIX_adr := GetProcAddress('glFragmentMaterialfSGIX');
    private z_FragmentMaterialfSGIX_1 := GetProcOrNil&<procedure(face: MaterialFace; pname: MaterialParameter; param: single)>(z_FragmentMaterialfSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentMaterialfSGIX(face: MaterialFace; pname: MaterialParameter; param: single) :=
    z_FragmentMaterialfSGIX_1(face, pname, param);
    
    private z_FragmentMaterialfvSGIX_adr := GetProcAddress('glFragmentMaterialfvSGIX');
    private z_FragmentMaterialfvSGIX_1 := GetProcOrNil&<procedure(face: MaterialFace; pname: MaterialParameter; &params: IntPtr)>(z_FragmentMaterialfvSGIX_adr);
    private z_FragmentMaterialfvSGIX_2 := GetProcOrNil&<procedure(face: MaterialFace; pname: MaterialParameter; var &params: single)>(z_FragmentMaterialfvSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentMaterialfvSGIX(face: MaterialFace; pname: MaterialParameter; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_FragmentMaterialfvSGIX_2(face, pname, &params[0]) else
        z_FragmentMaterialfvSGIX_2(face, pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentMaterialfvSGIX(face: MaterialFace; pname: MaterialParameter; var &params: single) :=
    z_FragmentMaterialfvSGIX_2(face, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentMaterialfvSGIX(face: MaterialFace; pname: MaterialParameter; &params: IntPtr) :=
    z_FragmentMaterialfvSGIX_1(face, pname, &params);
    
    private z_FragmentMaterialiSGIX_adr := GetProcAddress('glFragmentMaterialiSGIX');
    private z_FragmentMaterialiSGIX_1 := GetProcOrNil&<procedure(face: MaterialFace; pname: MaterialParameter; param: Int32)>(z_FragmentMaterialiSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentMaterialiSGIX(face: MaterialFace; pname: MaterialParameter; param: Int32) :=
    z_FragmentMaterialiSGIX_1(face, pname, param);
    
    private z_FragmentMaterialivSGIX_adr := GetProcAddress('glFragmentMaterialivSGIX');
    private z_FragmentMaterialivSGIX_1 := GetProcOrNil&<procedure(face: MaterialFace; pname: MaterialParameter; &params: IntPtr)>(z_FragmentMaterialivSGIX_adr);
    private z_FragmentMaterialivSGIX_2 := GetProcOrNil&<procedure(face: MaterialFace; pname: MaterialParameter; var &params: Int32)>(z_FragmentMaterialivSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentMaterialivSGIX(face: MaterialFace; pname: MaterialParameter; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_FragmentMaterialivSGIX_2(face, pname, &params[0]) else
        z_FragmentMaterialivSGIX_2(face, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentMaterialivSGIX(face: MaterialFace; pname: MaterialParameter; var &params: Int32) :=
    z_FragmentMaterialivSGIX_2(face, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentMaterialivSGIX(face: MaterialFace; pname: MaterialParameter; &params: IntPtr) :=
    z_FragmentMaterialivSGIX_1(face, pname, &params);
    
    private z_GetFragmentLightfvSGIX_adr := GetProcAddress('glGetFragmentLightfvSGIX');
    private z_GetFragmentLightfvSGIX_1 := GetProcOrNil&<procedure(light: FragmentLightName; pname: FragmentLightParameter; &params: IntPtr)>(z_GetFragmentLightfvSGIX_adr);
    private z_GetFragmentLightfvSGIX_2 := GetProcOrNil&<procedure(light: FragmentLightName; pname: FragmentLightParameter; var &params: single)>(z_GetFragmentLightfvSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFragmentLightfvSGIX(light: FragmentLightName; pname: FragmentLightParameter; var &params: single) :=
    z_GetFragmentLightfvSGIX_2(light, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFragmentLightfvSGIX(light: FragmentLightName; pname: FragmentLightParameter; &params: IntPtr) :=
    z_GetFragmentLightfvSGIX_1(light, pname, &params);
    
    private z_GetFragmentLightivSGIX_adr := GetProcAddress('glGetFragmentLightivSGIX');
    private z_GetFragmentLightivSGIX_1 := GetProcOrNil&<procedure(light: FragmentLightName; pname: FragmentLightParameter; &params: IntPtr)>(z_GetFragmentLightivSGIX_adr);
    private z_GetFragmentLightivSGIX_2 := GetProcOrNil&<procedure(light: FragmentLightName; pname: FragmentLightParameter; var &params: Int32)>(z_GetFragmentLightivSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFragmentLightivSGIX(light: FragmentLightName; pname: FragmentLightParameter; var &params: Int32) :=
    z_GetFragmentLightivSGIX_2(light, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFragmentLightivSGIX(light: FragmentLightName; pname: FragmentLightParameter; &params: IntPtr) :=
    z_GetFragmentLightivSGIX_1(light, pname, &params);
    
    private z_GetFragmentMaterialfvSGIX_adr := GetProcAddress('glGetFragmentMaterialfvSGIX');
    private z_GetFragmentMaterialfvSGIX_1 := GetProcOrNil&<procedure(face: MaterialFace; pname: MaterialParameter; &params: IntPtr)>(z_GetFragmentMaterialfvSGIX_adr);
    private z_GetFragmentMaterialfvSGIX_2 := GetProcOrNil&<procedure(face: MaterialFace; pname: MaterialParameter; var &params: single)>(z_GetFragmentMaterialfvSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFragmentMaterialfvSGIX(face: MaterialFace; pname: MaterialParameter; var &params: single) :=
    z_GetFragmentMaterialfvSGIX_2(face, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFragmentMaterialfvSGIX(face: MaterialFace; pname: MaterialParameter; &params: IntPtr) :=
    z_GetFragmentMaterialfvSGIX_1(face, pname, &params);
    
    private z_GetFragmentMaterialivSGIX_adr := GetProcAddress('glGetFragmentMaterialivSGIX');
    private z_GetFragmentMaterialivSGIX_1 := GetProcOrNil&<procedure(face: MaterialFace; pname: MaterialParameter; &params: IntPtr)>(z_GetFragmentMaterialivSGIX_adr);
    private z_GetFragmentMaterialivSGIX_2 := GetProcOrNil&<procedure(face: MaterialFace; pname: MaterialParameter; var &params: Int32)>(z_GetFragmentMaterialivSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFragmentMaterialivSGIX(face: MaterialFace; pname: MaterialParameter; var &params: Int32) :=
    z_GetFragmentMaterialivSGIX_2(face, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFragmentMaterialivSGIX(face: MaterialFace; pname: MaterialParameter; &params: IntPtr) :=
    z_GetFragmentMaterialivSGIX_1(face, pname, &params);
    
    private z_LightEnviSGIX_adr := GetProcAddress('glLightEnviSGIX');
    private z_LightEnviSGIX_1 := GetProcOrNil&<procedure(pname: LightEnvParameter; param: LightEnvMode)>(z_LightEnviSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightEnviSGIX(pname: LightEnvParameter; param: LightEnvMode) :=
    z_LightEnviSGIX_1(pname, param);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glFramezoomSGIX = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_sgix_framezoom';
    
    private z_FrameZoomSGIX_adr := GetProcAddress('glFrameZoomSGIX');
    private z_FrameZoomSGIX_1 := GetProcOrNil&<procedure(factor: Int32)>(z_FrameZoomSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FrameZoomSGIX(factor: Int32) :=
    z_FrameZoomSGIX_1(factor);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glIglooInterfaceSGIX = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_sgix_igloo_interface';
    
    private z_IglooInterfaceSGIX_adr := GetProcAddress('glIglooInterfaceSGIX');
    private z_IglooInterfaceSGIX_1 := GetProcOrNil&<procedure(pname: DummyEnum; &params: IntPtr)>(z_IglooInterfaceSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IglooInterfaceSGIX(pname: DummyEnum; &params: IntPtr) :=
    z_IglooInterfaceSGIX_1(pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glInstrumentsSGIX = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_sgix_instruments';
    
    private z_GetInstrumentsSGIX_adr := GetProcAddress('glGetInstrumentsSGIX');
    private z_GetInstrumentsSGIX_1 := GetProcOrNil&<function: Int32>(z_GetInstrumentsSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetInstrumentsSGIX: Int32 :=
    z_GetInstrumentsSGIX_1();
    
    private z_InstrumentsBufferSGIX_adr := GetProcAddress('glInstrumentsBufferSGIX');
    private z_InstrumentsBufferSGIX_1 := GetProcOrNil&<procedure(size: Int32; buffer: IntPtr)>(z_InstrumentsBufferSGIX_adr);
    private z_InstrumentsBufferSGIX_2 := GetProcOrNil&<procedure(size: Int32; var buffer: Int32)>(z_InstrumentsBufferSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InstrumentsBufferSGIX(size: Int32; buffer: array of Int32);
    type PInt32=^Int32;
    begin
      if (buffer<>nil) and (buffer.Length<>0) then
        z_InstrumentsBufferSGIX_2(size, buffer[0]) else
        z_InstrumentsBufferSGIX_2(size, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InstrumentsBufferSGIX(size: Int32; var buffer: Int32) :=
    z_InstrumentsBufferSGIX_2(size, buffer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InstrumentsBufferSGIX(size: Int32; buffer: IntPtr) :=
    z_InstrumentsBufferSGIX_1(size, buffer);
    
    private z_PollInstrumentsSGIX_adr := GetProcAddress('glPollInstrumentsSGIX');
    private z_PollInstrumentsSGIX_1 := GetProcOrNil&<function(marker_p: IntPtr): Int32>(z_PollInstrumentsSGIX_adr);
    private z_PollInstrumentsSGIX_2 := GetProcOrNil&<function(var marker_p: Int32): Int32>(z_PollInstrumentsSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PollInstrumentsSGIX(marker_p: array of Int32): Int32;
    type PInt32=^Int32;
    begin
      Result := if (marker_p<>nil) and (marker_p.Length<>0) then
        z_PollInstrumentsSGIX_2(marker_p[0]) else
        z_PollInstrumentsSGIX_2(PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PollInstrumentsSGIX(var marker_p: Int32): Int32 :=
    z_PollInstrumentsSGIX_2(marker_p);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PollInstrumentsSGIX(marker_p: IntPtr): Int32 :=
    z_PollInstrumentsSGIX_1(marker_p);
    
    private z_ReadInstrumentsSGIX_adr := GetProcAddress('glReadInstrumentsSGIX');
    private z_ReadInstrumentsSGIX_1 := GetProcOrNil&<procedure(marker: Int32)>(z_ReadInstrumentsSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReadInstrumentsSGIX(marker: Int32) :=
    z_ReadInstrumentsSGIX_1(marker);
    
    private z_StartInstrumentsSGIX_adr := GetProcAddress('glStartInstrumentsSGIX');
    private z_StartInstrumentsSGIX_1 := GetProcOrNil&<procedure>(z_StartInstrumentsSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StartInstrumentsSGIX :=
    z_StartInstrumentsSGIX_1();
    
    private z_StopInstrumentsSGIX_adr := GetProcAddress('glStopInstrumentsSGIX');
    private z_StopInstrumentsSGIX_1 := GetProcOrNil&<procedure(marker: Int32)>(z_StopInstrumentsSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StopInstrumentsSGIX(marker: Int32) :=
    z_StopInstrumentsSGIX_1(marker);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glListPrioritySGIX = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_sgix_list_priority';
    
    private z_GetListParameterfvSGIX_adr := GetProcAddress('glGetListParameterfvSGIX');
    private z_GetListParameterfvSGIX_1 := GetProcOrNil&<procedure(list: UInt32; pname: ListParameterName; &params: IntPtr)>(z_GetListParameterfvSGIX_adr);
    private z_GetListParameterfvSGIX_2 := GetProcOrNil&<procedure(list: UInt32; pname: ListParameterName; var &params: single)>(z_GetListParameterfvSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetListParameterfvSGIX(list: UInt32; pname: ListParameterName; var &params: single) :=
    z_GetListParameterfvSGIX_2(list, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetListParameterfvSGIX(list: UInt32; pname: ListParameterName; &params: IntPtr) :=
    z_GetListParameterfvSGIX_1(list, pname, &params);
    
    private z_GetListParameterivSGIX_adr := GetProcAddress('glGetListParameterivSGIX');
    private z_GetListParameterivSGIX_1 := GetProcOrNil&<procedure(list: UInt32; pname: ListParameterName; &params: IntPtr)>(z_GetListParameterivSGIX_adr);
    private z_GetListParameterivSGIX_2 := GetProcOrNil&<procedure(list: UInt32; pname: ListParameterName; var &params: Int32)>(z_GetListParameterivSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetListParameterivSGIX(list: UInt32; pname: ListParameterName; var &params: Int32) :=
    z_GetListParameterivSGIX_2(list, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetListParameterivSGIX(list: UInt32; pname: ListParameterName; &params: IntPtr) :=
    z_GetListParameterivSGIX_1(list, pname, &params);
    
    private z_ListParameterfSGIX_adr := GetProcAddress('glListParameterfSGIX');
    private z_ListParameterfSGIX_1 := GetProcOrNil&<procedure(list: UInt32; pname: ListParameterName; param: single)>(z_ListParameterfSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListParameterfSGIX(list: UInt32; pname: ListParameterName; param: single) :=
    z_ListParameterfSGIX_1(list, pname, param);
    
    private z_ListParameterfvSGIX_adr := GetProcAddress('glListParameterfvSGIX');
    private z_ListParameterfvSGIX_1 := GetProcOrNil&<procedure(list: UInt32; pname: ListParameterName; &params: IntPtr)>(z_ListParameterfvSGIX_adr);
    private z_ListParameterfvSGIX_2 := GetProcOrNil&<procedure(list: UInt32; pname: ListParameterName; var &params: single)>(z_ListParameterfvSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListParameterfvSGIX(list: UInt32; pname: ListParameterName; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_ListParameterfvSGIX_2(list, pname, &params[0]) else
        z_ListParameterfvSGIX_2(list, pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListParameterfvSGIX(list: UInt32; pname: ListParameterName; var &params: single) :=
    z_ListParameterfvSGIX_2(list, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListParameterfvSGIX(list: UInt32; pname: ListParameterName; &params: IntPtr) :=
    z_ListParameterfvSGIX_1(list, pname, &params);
    
    private z_ListParameteriSGIX_adr := GetProcAddress('glListParameteriSGIX');
    private z_ListParameteriSGIX_1 := GetProcOrNil&<procedure(list: UInt32; pname: ListParameterName; param: Int32)>(z_ListParameteriSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListParameteriSGIX(list: UInt32; pname: ListParameterName; param: Int32) :=
    z_ListParameteriSGIX_1(list, pname, param);
    
    private z_ListParameterivSGIX_adr := GetProcAddress('glListParameterivSGIX');
    private z_ListParameterivSGIX_1 := GetProcOrNil&<procedure(list: UInt32; pname: ListParameterName; &params: IntPtr)>(z_ListParameterivSGIX_adr);
    private z_ListParameterivSGIX_2 := GetProcOrNil&<procedure(list: UInt32; pname: ListParameterName; var &params: Int32)>(z_ListParameterivSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListParameterivSGIX(list: UInt32; pname: ListParameterName; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_ListParameterivSGIX_2(list, pname, &params[0]) else
        z_ListParameterivSGIX_2(list, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListParameterivSGIX(list: UInt32; pname: ListParameterName; var &params: Int32) :=
    z_ListParameterivSGIX_2(list, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListParameterivSGIX(list: UInt32; pname: ListParameterName; &params: IntPtr) :=
    z_ListParameterivSGIX_1(list, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glPixelTextureSGIX = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_sgix_pixel_texture';
    
    private z_PixelTexGenSGIX_adr := GetProcAddress('glPixelTexGenSGIX');
    private z_PixelTexGenSGIX_1 := GetProcOrNil&<procedure(mode: PixelTexGenMode)>(z_PixelTexGenSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTexGenSGIX(mode: PixelTexGenMode) :=
    z_PixelTexGenSGIX_1(mode);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glPolynomialFfdSGIX = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_sgix_polynomial_ffd';
    
    private z_DeformationMap3dSGIX_adr := GetProcAddress('glDeformationMap3dSGIX');
    private z_DeformationMap3dSGIX_1 := GetProcOrNil&<procedure(target: FfdTarget; u1: real; u2: real; ustride: Int32; uorder: Int32; v1: real; v2: real; vstride: Int32; vorder: Int32; w1: real; w2: real; wstride: Int32; worder: Int32; points: IntPtr)>(z_DeformationMap3dSGIX_adr);
    private z_DeformationMap3dSGIX_2 := GetProcOrNil&<procedure(target: FfdTarget; u1: real; u2: real; ustride: Int32; uorder: Int32; v1: real; v2: real; vstride: Int32; vorder: Int32; w1: real; w2: real; wstride: Int32; worder: Int32; var points: real)>(z_DeformationMap3dSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeformationMap3dSGIX(target: FfdTarget; u1: real; u2: real; ustride: Int32; uorder: Int32; v1: real; v2: real; vstride: Int32; vorder: Int32; w1: real; w2: real; wstride: Int32; worder: Int32; points: array of real);
    type Preal=^real;
    begin
      if (points<>nil) and (points.Length<>0) then
        z_DeformationMap3dSGIX_2(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points[0]) else
        z_DeformationMap3dSGIX_2(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeformationMap3dSGIX(target: FfdTarget; u1: real; u2: real; ustride: Int32; uorder: Int32; v1: real; v2: real; vstride: Int32; vorder: Int32; w1: real; w2: real; wstride: Int32; worder: Int32; var points: real) :=
    z_DeformationMap3dSGIX_2(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeformationMap3dSGIX(target: FfdTarget; u1: real; u2: real; ustride: Int32; uorder: Int32; v1: real; v2: real; vstride: Int32; vorder: Int32; w1: real; w2: real; wstride: Int32; worder: Int32; points: IntPtr) :=
    z_DeformationMap3dSGIX_1(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
    
    private z_DeformationMap3fSGIX_adr := GetProcAddress('glDeformationMap3fSGIX');
    private z_DeformationMap3fSGIX_1 := GetProcOrNil&<procedure(target: FfdTarget; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; w1: single; w2: single; wstride: Int32; worder: Int32; points: IntPtr)>(z_DeformationMap3fSGIX_adr);
    private z_DeformationMap3fSGIX_2 := GetProcOrNil&<procedure(target: FfdTarget; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; w1: single; w2: single; wstride: Int32; worder: Int32; var points: single)>(z_DeformationMap3fSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeformationMap3fSGIX(target: FfdTarget; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; w1: single; w2: single; wstride: Int32; worder: Int32; points: array of single);
    type Psingle=^single;
    begin
      if (points<>nil) and (points.Length<>0) then
        z_DeformationMap3fSGIX_2(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points[0]) else
        z_DeformationMap3fSGIX_2(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeformationMap3fSGIX(target: FfdTarget; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; w1: single; w2: single; wstride: Int32; worder: Int32; var points: single) :=
    z_DeformationMap3fSGIX_2(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeformationMap3fSGIX(target: FfdTarget; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; w1: single; w2: single; wstride: Int32; worder: Int32; points: IntPtr) :=
    z_DeformationMap3fSGIX_1(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
    
    private z_DeformSGIX_adr := GetProcAddress('glDeformSGIX');
    private z_DeformSGIX_1 := GetProcOrNil&<procedure(mask: FfdMask)>(z_DeformSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeformSGIX(mask: FfdMask) :=
    z_DeformSGIX_1(mask);
    
    private z_LoadIdentityDeformationMapSGIX_adr := GetProcAddress('glLoadIdentityDeformationMapSGIX');
    private z_LoadIdentityDeformationMapSGIX_1 := GetProcOrNil&<procedure(mask: FfdMask)>(z_LoadIdentityDeformationMapSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadIdentityDeformationMapSGIX(mask: FfdMask) :=
    z_LoadIdentityDeformationMapSGIX_1(mask);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glReferencePlaneSGIX = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_sgix_reference_plane';
    
    private z_ReferencePlaneSGIX_adr := GetProcAddress('glReferencePlaneSGIX');
    private z_ReferencePlaneSGIX_1 := GetProcOrNil&<procedure(equation: IntPtr)>(z_ReferencePlaneSGIX_adr);
    private z_ReferencePlaneSGIX_2 := GetProcOrNil&<procedure(var equation: real)>(z_ReferencePlaneSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReferencePlaneSGIX(equation: array of real);
    type Preal=^real;
    begin
      if (equation<>nil) and (equation.Length<>0) then
        z_ReferencePlaneSGIX_2(equation[0]) else
        z_ReferencePlaneSGIX_2(Preal(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReferencePlaneSGIX(var equation: real) :=
    z_ReferencePlaneSGIX_2(equation);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReferencePlaneSGIX(equation: IntPtr) :=
    z_ReferencePlaneSGIX_1(equation);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glSpriteSGIX = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_sgix_sprite';
    
    private z_SpriteParameterfSGIX_adr := GetProcAddress('glSpriteParameterfSGIX');
    private z_SpriteParameterfSGIX_1 := GetProcOrNil&<procedure(pname: SpriteParameterName; param: single)>(z_SpriteParameterfSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpriteParameterfSGIX(pname: SpriteParameterName; param: single) :=
    z_SpriteParameterfSGIX_1(pname, param);
    
    private z_SpriteParameterfvSGIX_adr := GetProcAddress('glSpriteParameterfvSGIX');
    private z_SpriteParameterfvSGIX_1 := GetProcOrNil&<procedure(pname: SpriteParameterName; &params: IntPtr)>(z_SpriteParameterfvSGIX_adr);
    private z_SpriteParameterfvSGIX_2 := GetProcOrNil&<procedure(pname: SpriteParameterName; var &params: single)>(z_SpriteParameterfvSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpriteParameterfvSGIX(pname: SpriteParameterName; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_SpriteParameterfvSGIX_2(pname, &params[0]) else
        z_SpriteParameterfvSGIX_2(pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpriteParameterfvSGIX(pname: SpriteParameterName; var &params: single) :=
    z_SpriteParameterfvSGIX_2(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpriteParameterfvSGIX(pname: SpriteParameterName; &params: IntPtr) :=
    z_SpriteParameterfvSGIX_1(pname, &params);
    
    private z_SpriteParameteriSGIX_adr := GetProcAddress('glSpriteParameteriSGIX');
    private z_SpriteParameteriSGIX_1 := GetProcOrNil&<procedure(pname: SpriteParameterName; param: Int32)>(z_SpriteParameteriSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpriteParameteriSGIX(pname: SpriteParameterName; param: Int32) :=
    z_SpriteParameteriSGIX_1(pname, param);
    
    private z_SpriteParameterivSGIX_adr := GetProcAddress('glSpriteParameterivSGIX');
    private z_SpriteParameterivSGIX_1 := GetProcOrNil&<procedure(pname: SpriteParameterName; &params: IntPtr)>(z_SpriteParameterivSGIX_adr);
    private z_SpriteParameterivSGIX_2 := GetProcOrNil&<procedure(pname: SpriteParameterName; var &params: Int32)>(z_SpriteParameterivSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpriteParameterivSGIX(pname: SpriteParameterName; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_SpriteParameterivSGIX_2(pname, &params[0]) else
        z_SpriteParameterivSGIX_2(pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpriteParameterivSGIX(pname: SpriteParameterName; var &params: Int32) :=
    z_SpriteParameterivSGIX_2(pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpriteParameterivSGIX(pname: SpriteParameterName; &params: IntPtr) :=
    z_SpriteParameterivSGIX_1(pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glTagSampleBufferSGIX = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_sgix_tag_sample_buffer';
    
    private z_TagSampleBufferSGIX_adr := GetProcAddress('glTagSampleBufferSGIX');
    private z_TagSampleBufferSGIX_1 := GetProcOrNil&<procedure>(z_TagSampleBufferSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TagSampleBufferSGIX :=
    z_TagSampleBufferSGIX_1();
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glColorTableSGI = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_sgi_color_table';
    
    private z_ColorTableSGI_adr := GetProcAddress('glColorTableSGI');
    private z_ColorTableSGI_1 := GetProcOrNil&<procedure(target: ColorTableTargetSGI; _internalformat: InternalFormat; width: Int32; format: PixelFormat; &type: PixelType; table: IntPtr)>(z_ColorTableSGI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableSGI(target: ColorTableTargetSGI; _internalformat: InternalFormat; width: Int32; format: PixelFormat; &type: PixelType; table: IntPtr) :=
    z_ColorTableSGI_1(target, _internalformat, width, format, &type, table);
    
    private z_ColorTableParameterfvSGI_adr := GetProcAddress('glColorTableParameterfvSGI');
    private z_ColorTableParameterfvSGI_1 := GetProcOrNil&<procedure(target: ColorTableTargetSGI; pname: ColorTableParameterPName; &params: IntPtr)>(z_ColorTableParameterfvSGI_adr);
    private z_ColorTableParameterfvSGI_2 := GetProcOrNil&<procedure(target: ColorTableTargetSGI; pname: ColorTableParameterPName; var &params: single)>(z_ColorTableParameterfvSGI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameterfvSGI(target: ColorTableTargetSGI; pname: ColorTableParameterPName; &params: array of single);
    type Psingle=^single;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_ColorTableParameterfvSGI_2(target, pname, &params[0]) else
        z_ColorTableParameterfvSGI_2(target, pname, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameterfvSGI(target: ColorTableTargetSGI; pname: ColorTableParameterPName; var &params: single) :=
    z_ColorTableParameterfvSGI_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameterfvSGI(target: ColorTableTargetSGI; pname: ColorTableParameterPName; &params: IntPtr) :=
    z_ColorTableParameterfvSGI_1(target, pname, &params);
    
    private z_ColorTableParameterivSGI_adr := GetProcAddress('glColorTableParameterivSGI');
    private z_ColorTableParameterivSGI_1 := GetProcOrNil&<procedure(target: ColorTableTargetSGI; pname: ColorTableParameterPName; &params: IntPtr)>(z_ColorTableParameterivSGI_adr);
    private z_ColorTableParameterivSGI_2 := GetProcOrNil&<procedure(target: ColorTableTargetSGI; pname: ColorTableParameterPName; var &params: Int32)>(z_ColorTableParameterivSGI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameterivSGI(target: ColorTableTargetSGI; pname: ColorTableParameterPName; &params: array of Int32);
    type PInt32=^Int32;
    begin
      if (&params<>nil) and (&params.Length<>0) then
        z_ColorTableParameterivSGI_2(target, pname, &params[0]) else
        z_ColorTableParameterivSGI_2(target, pname, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameterivSGI(target: ColorTableTargetSGI; pname: ColorTableParameterPName; var &params: Int32) :=
    z_ColorTableParameterivSGI_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameterivSGI(target: ColorTableTargetSGI; pname: ColorTableParameterPName; &params: IntPtr) :=
    z_ColorTableParameterivSGI_1(target, pname, &params);
    
    private z_CopyColorTableSGI_adr := GetProcAddress('glCopyColorTableSGI');
    private z_CopyColorTableSGI_1 := GetProcOrNil&<procedure(target: ColorTableTargetSGI; _internalformat: InternalFormat; x: Int32; y: Int32; width: Int32)>(z_CopyColorTableSGI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyColorTableSGI(target: ColorTableTargetSGI; _internalformat: InternalFormat; x: Int32; y: Int32; width: Int32) :=
    z_CopyColorTableSGI_1(target, _internalformat, x, y, width);
    
    private z_GetColorTableSGI_adr := GetProcAddress('glGetColorTableSGI');
    private z_GetColorTableSGI_1 := GetProcOrNil&<procedure(target: ColorTableTargetSGI; format: PixelFormat; &type: PixelType; table: IntPtr)>(z_GetColorTableSGI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableSGI(target: ColorTableTargetSGI; format: PixelFormat; &type: PixelType; table: IntPtr) :=
    z_GetColorTableSGI_1(target, format, &type, table);
    
    private z_GetColorTableParameterfvSGI_adr := GetProcAddress('glGetColorTableParameterfvSGI');
    private z_GetColorTableParameterfvSGI_1 := GetProcOrNil&<procedure(target: ColorTableTargetSGI; pname: ColorTableParameterPName; &params: IntPtr)>(z_GetColorTableParameterfvSGI_adr);
    private z_GetColorTableParameterfvSGI_2 := GetProcOrNil&<procedure(target: ColorTableTargetSGI; pname: ColorTableParameterPName; var &params: single)>(z_GetColorTableParameterfvSGI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterfvSGI(target: ColorTableTargetSGI; pname: ColorTableParameterPName; var &params: single) :=
    z_GetColorTableParameterfvSGI_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterfvSGI(target: ColorTableTargetSGI; pname: ColorTableParameterPName; &params: IntPtr) :=
    z_GetColorTableParameterfvSGI_1(target, pname, &params);
    
    private z_GetColorTableParameterivSGI_adr := GetProcAddress('glGetColorTableParameterivSGI');
    private z_GetColorTableParameterivSGI_1 := GetProcOrNil&<procedure(target: ColorTableTargetSGI; pname: ColorTableParameterPName; &params: IntPtr)>(z_GetColorTableParameterivSGI_adr);
    private z_GetColorTableParameterivSGI_2 := GetProcOrNil&<procedure(target: ColorTableTargetSGI; pname: ColorTableParameterPName; var &params: Int32)>(z_GetColorTableParameterivSGI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterivSGI(target: ColorTableTargetSGI; pname: ColorTableParameterPName; var &params: Int32) :=
    z_GetColorTableParameterivSGI_2(target, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterivSGI(target: ColorTableTargetSGI; pname: ColorTableParameterPName; &params: IntPtr) :=
    z_GetColorTableParameterivSGI_1(target, pname, &params);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glConstantDataSUNX = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_sunx_constant_data';
    
    private z_FinishTextureSUNX_adr := GetProcAddress('glFinishTextureSUNX');
    private z_FinishTextureSUNX_1 := GetProcOrNil&<procedure>(z_FinishTextureSUNX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FinishTextureSUNX :=
    z_FinishTextureSUNX_1();
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glGlobalAlphaSUN = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_sun_global_alpha';
    
    private z_GlobalAlphaFactorbSUN_adr := GetProcAddress('glGlobalAlphaFactorbSUN');
    private z_GlobalAlphaFactorbSUN_1 := GetProcOrNil&<procedure(factor: SByte)>(z_GlobalAlphaFactorbSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GlobalAlphaFactorbSUN(factor: SByte) :=
    z_GlobalAlphaFactorbSUN_1(factor);
    
    private z_GlobalAlphaFactorsSUN_adr := GetProcAddress('glGlobalAlphaFactorsSUN');
    private z_GlobalAlphaFactorsSUN_1 := GetProcOrNil&<procedure(factor: Int16)>(z_GlobalAlphaFactorsSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GlobalAlphaFactorsSUN(factor: Int16) :=
    z_GlobalAlphaFactorsSUN_1(factor);
    
    private z_GlobalAlphaFactoriSUN_adr := GetProcAddress('glGlobalAlphaFactoriSUN');
    private z_GlobalAlphaFactoriSUN_1 := GetProcOrNil&<procedure(factor: Int32)>(z_GlobalAlphaFactoriSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GlobalAlphaFactoriSUN(factor: Int32) :=
    z_GlobalAlphaFactoriSUN_1(factor);
    
    private z_GlobalAlphaFactorfSUN_adr := GetProcAddress('glGlobalAlphaFactorfSUN');
    private z_GlobalAlphaFactorfSUN_1 := GetProcOrNil&<procedure(factor: single)>(z_GlobalAlphaFactorfSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GlobalAlphaFactorfSUN(factor: single) :=
    z_GlobalAlphaFactorfSUN_1(factor);
    
    private z_GlobalAlphaFactordSUN_adr := GetProcAddress('glGlobalAlphaFactordSUN');
    private z_GlobalAlphaFactordSUN_1 := GetProcOrNil&<procedure(factor: real)>(z_GlobalAlphaFactordSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GlobalAlphaFactordSUN(factor: real) :=
    z_GlobalAlphaFactordSUN_1(factor);
    
    private z_GlobalAlphaFactorubSUN_adr := GetProcAddress('glGlobalAlphaFactorubSUN');
    private z_GlobalAlphaFactorubSUN_1 := GetProcOrNil&<procedure(factor: Byte)>(z_GlobalAlphaFactorubSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GlobalAlphaFactorubSUN(factor: Byte) :=
    z_GlobalAlphaFactorubSUN_1(factor);
    
    private z_GlobalAlphaFactorusSUN_adr := GetProcAddress('glGlobalAlphaFactorusSUN');
    private z_GlobalAlphaFactorusSUN_1 := GetProcOrNil&<procedure(factor: UInt16)>(z_GlobalAlphaFactorusSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GlobalAlphaFactorusSUN(factor: UInt16) :=
    z_GlobalAlphaFactorusSUN_1(factor);
    
    private z_GlobalAlphaFactoruiSUN_adr := GetProcAddress('glGlobalAlphaFactoruiSUN');
    private z_GlobalAlphaFactoruiSUN_1 := GetProcOrNil&<procedure(factor: UInt32)>(z_GlobalAlphaFactoruiSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GlobalAlphaFactoruiSUN(factor: UInt32) :=
    z_GlobalAlphaFactoruiSUN_1(factor);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glMeshArraySUN = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_sun_mesh_array';
    
    private z_DrawMeshArraysSUN_adr := GetProcAddress('glDrawMeshArraysSUN');
    private z_DrawMeshArraysSUN_1 := GetProcOrNil&<procedure(mode: PrimitiveType; first: Int32; count: Int32; width: Int32)>(z_DrawMeshArraysSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawMeshArraysSUN(mode: PrimitiveType; first: Int32; count: Int32; width: Int32) :=
    z_DrawMeshArraysSUN_1(mode, first, count, width);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glTriangleListSUN = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_sun_triangle_list';
    
    private z_ReplacementCodeuiSUN_adr := GetProcAddress('glReplacementCodeuiSUN');
    private z_ReplacementCodeuiSUN_1 := GetProcOrNil&<procedure(code: TriangleList)>(z_ReplacementCodeuiSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiSUN(code: TriangleList) :=
    z_ReplacementCodeuiSUN_1(code);
    
    private z_ReplacementCodeusSUN_adr := GetProcAddress('glReplacementCodeusSUN');
    private z_ReplacementCodeusSUN_1 := GetProcOrNil&<procedure(code: UInt16)>(z_ReplacementCodeusSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeusSUN(code: UInt16) :=
    z_ReplacementCodeusSUN_1(code);
    
    private z_ReplacementCodeubSUN_adr := GetProcAddress('glReplacementCodeubSUN');
    private z_ReplacementCodeubSUN_1 := GetProcOrNil&<procedure(code: Byte)>(z_ReplacementCodeubSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeubSUN(code: Byte) :=
    z_ReplacementCodeubSUN_1(code);
    
    private z_ReplacementCodeuivSUN_adr := GetProcAddress('glReplacementCodeuivSUN');
    private z_ReplacementCodeuivSUN_1 := GetProcOrNil&<procedure(code: IntPtr)>(z_ReplacementCodeuivSUN_adr);
    private z_ReplacementCodeuivSUN_2 := GetProcOrNil&<procedure(var code: TriangleList)>(z_ReplacementCodeuivSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuivSUN(code: array of TriangleList);
    type PTriangleList=^TriangleList;
    begin
      if (code<>nil) and (code.Length<>0) then
        z_ReplacementCodeuivSUN_2(code[0]) else
        z_ReplacementCodeuivSUN_2(PTriangleList(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuivSUN(var code: TriangleList) :=
    z_ReplacementCodeuivSUN_2(code);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuivSUN(code: IntPtr) :=
    z_ReplacementCodeuivSUN_1(code);
    
    private z_ReplacementCodeusvSUN_adr := GetProcAddress('glReplacementCodeusvSUN');
    private z_ReplacementCodeusvSUN_1 := GetProcOrNil&<procedure(code: IntPtr)>(z_ReplacementCodeusvSUN_adr);
    private z_ReplacementCodeusvSUN_2 := GetProcOrNil&<procedure(var code: UInt16)>(z_ReplacementCodeusvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeusvSUN(code: array of UInt16);
    type PUInt16=^UInt16;
    begin
      if (code<>nil) and (code.Length<>0) then
        z_ReplacementCodeusvSUN_2(code[0]) else
        z_ReplacementCodeusvSUN_2(PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeusvSUN(var code: UInt16) :=
    z_ReplacementCodeusvSUN_2(code);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeusvSUN(code: IntPtr) :=
    z_ReplacementCodeusvSUN_1(code);
    
    private z_ReplacementCodeubvSUN_adr := GetProcAddress('glReplacementCodeubvSUN');
    private z_ReplacementCodeubvSUN_1 := GetProcOrNil&<procedure(code: IntPtr)>(z_ReplacementCodeubvSUN_adr);
    private z_ReplacementCodeubvSUN_2 := GetProcOrNil&<procedure(var code: Byte)>(z_ReplacementCodeubvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeubvSUN(code: array of Byte);
    type PByte=^Byte;
    begin
      if (code<>nil) and (code.Length<>0) then
        z_ReplacementCodeubvSUN_2(code[0]) else
        z_ReplacementCodeubvSUN_2(PByte(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeubvSUN(var code: Byte) :=
    z_ReplacementCodeubvSUN_2(code);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeubvSUN(code: IntPtr) :=
    z_ReplacementCodeubvSUN_1(code);
    
    private z_ReplacementCodePointerSUN_adr := GetProcAddress('glReplacementCodePointerSUN');
    private z_ReplacementCodePointerSUN_1 := GetProcOrNil&<procedure(&type: ReplacementCodeType; stride: Int32; _pointer: pointer)>(z_ReplacementCodePointerSUN_adr);
    private z_ReplacementCodePointerSUN_2 := GetProcOrNil&<procedure(&type: ReplacementCodeType; stride: Int32; var _pointer: IntPtr)>(z_ReplacementCodePointerSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodePointerSUN(&type: ReplacementCodeType; stride: Int32; _pointer: array of IntPtr);
    type PIntPtr=^IntPtr;
    begin
      if (_pointer<>nil) and (_pointer.Length<>0) then
        z_ReplacementCodePointerSUN_2(&type, stride, _pointer[0]) else
        z_ReplacementCodePointerSUN_2(&type, stride, PIntPtr(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodePointerSUN(&type: ReplacementCodeType; stride: Int32; var _pointer: IntPtr) :=
    z_ReplacementCodePointerSUN_2(&type, stride, _pointer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodePointerSUN(&type: ReplacementCodeType; stride: Int32; _pointer: pointer) :=
    z_ReplacementCodePointerSUN_1(&type, stride, _pointer);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glVertexSUN = sealed partial class
    public constructor(loader: PlatformLoader);
    private constructor := raise new System.NotSupportedException;
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'gl_sun_vertex';
    
    private z_Color4ubVertex2fSUN_adr := GetProcAddress('glColor4ubVertex2fSUN');
    private z_Color4ubVertex2fSUN_1 := GetProcOrNil&<procedure(r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single)>(z_Color4ubVertex2fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex2fSUN(r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single) :=
    z_Color4ubVertex2fSUN_1(r, g, b, a, x, y);
    
    private z_Color4ubVertex2fvSUN_adr := GetProcAddress('glColor4ubVertex2fvSUN');
    private z_Color4ubVertex2fvSUN_1 := GetProcOrNil&<procedure(c: IntPtr; v: IntPtr)>(z_Color4ubVertex2fvSUN_adr);
    private z_Color4ubVertex2fvSUN_2 := GetProcOrNil&<procedure(var c: Byte; var v: single)>(z_Color4ubVertex2fvSUN_adr);
    private z_Color4ubVertex2fvSUN_3 := GetProcOrNil&<procedure(var c: Vec4ub; var v: Vec2f)>(z_Color4ubVertex2fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex2fvSUN(c: array of Byte; v: array of single);
    type PByte=^Byte;
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        if (c<>nil) and (c.Length<>0) then
          z_Color4ubVertex2fvSUN_2(c[0], v[0]) else
          z_Color4ubVertex2fvSUN_2(PByte(nil)^, v[0]) else
        if (c<>nil) and (c.Length<>0) then
          z_Color4ubVertex2fvSUN_2(c[0], Psingle(nil)^) else
          z_Color4ubVertex2fvSUN_2(PByte(nil)^, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex2fvSUN(var c: Vec4ub; var v: Vec2f) :=
    z_Color4ubVertex2fvSUN_3(c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex2fvSUN(var c: Byte; var v: single) :=
    z_Color4ubVertex2fvSUN_2(c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex2fvSUN(c: IntPtr; v: IntPtr) :=
    z_Color4ubVertex2fvSUN_1(c, v);
    
    private z_Color4ubVertex3fSUN_adr := GetProcAddress('glColor4ubVertex3fSUN');
    private z_Color4ubVertex3fSUN_1 := GetProcOrNil&<procedure(r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single; z: single)>(z_Color4ubVertex3fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex3fSUN(r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single; z: single) :=
    z_Color4ubVertex3fSUN_1(r, g, b, a, x, y, z);
    
    private z_Color4ubVertex3fvSUN_adr := GetProcAddress('glColor4ubVertex3fvSUN');
    private z_Color4ubVertex3fvSUN_1 := GetProcOrNil&<procedure(c: IntPtr; v: IntPtr)>(z_Color4ubVertex3fvSUN_adr);
    private z_Color4ubVertex3fvSUN_2 := GetProcOrNil&<procedure(var c: Byte; var v: single)>(z_Color4ubVertex3fvSUN_adr);
    private z_Color4ubVertex3fvSUN_3 := GetProcOrNil&<procedure(var c: Vec4ub; var v: Vec3f)>(z_Color4ubVertex3fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex3fvSUN(c: array of Byte; v: array of single);
    type PByte=^Byte;
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        if (c<>nil) and (c.Length<>0) then
          z_Color4ubVertex3fvSUN_2(c[0], v[0]) else
          z_Color4ubVertex3fvSUN_2(PByte(nil)^, v[0]) else
        if (c<>nil) and (c.Length<>0) then
          z_Color4ubVertex3fvSUN_2(c[0], Psingle(nil)^) else
          z_Color4ubVertex3fvSUN_2(PByte(nil)^, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex3fvSUN(var c: Vec4ub; var v: Vec3f) :=
    z_Color4ubVertex3fvSUN_3(c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex3fvSUN(var c: Byte; var v: single) :=
    z_Color4ubVertex3fvSUN_2(c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex3fvSUN(c: IntPtr; v: IntPtr) :=
    z_Color4ubVertex3fvSUN_1(c, v);
    
    private z_Color3fVertex3fSUN_adr := GetProcAddress('glColor3fVertex3fSUN');
    private z_Color3fVertex3fSUN_1 := GetProcOrNil&<procedure(r: single; g: single; b: single; x: single; y: single; z: single)>(z_Color3fVertex3fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3fVertex3fSUN(r: single; g: single; b: single; x: single; y: single; z: single) :=
    z_Color3fVertex3fSUN_1(r, g, b, x, y, z);
    
    private z_Color3fVertex3fvSUN_adr := GetProcAddress('glColor3fVertex3fvSUN');
    private z_Color3fVertex3fvSUN_1 := GetProcOrNil&<procedure(c: IntPtr; v: IntPtr)>(z_Color3fVertex3fvSUN_adr);
    private z_Color3fVertex3fvSUN_2 := GetProcOrNil&<procedure(var c: single; var v: single)>(z_Color3fVertex3fvSUN_adr);
    private z_Color3fVertex3fvSUN_3 := GetProcOrNil&<procedure(var c: Vec3f; var v: Vec3f)>(z_Color3fVertex3fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3fVertex3fvSUN(c: array of single; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        if (c<>nil) and (c.Length<>0) then
          z_Color3fVertex3fvSUN_2(c[0], v[0]) else
          z_Color3fVertex3fvSUN_2(Psingle(nil)^, v[0]) else
        if (c<>nil) and (c.Length<>0) then
          z_Color3fVertex3fvSUN_2(c[0], Psingle(nil)^) else
          z_Color3fVertex3fvSUN_2(Psingle(nil)^, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3fVertex3fvSUN(var c: Vec3f; var v: Vec3f) :=
    z_Color3fVertex3fvSUN_3(c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3fVertex3fvSUN(var c: single; var v: single) :=
    z_Color3fVertex3fvSUN_2(c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3fVertex3fvSUN(c: IntPtr; v: IntPtr) :=
    z_Color3fVertex3fvSUN_1(c, v);
    
    private z_Normal3fVertex3fSUN_adr := GetProcAddress('glNormal3fVertex3fSUN');
    private z_Normal3fVertex3fSUN_1 := GetProcOrNil&<procedure(nx: single; ny: single; nz: single; x: single; y: single; z: single)>(z_Normal3fVertex3fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fVertex3fSUN(nx: single; ny: single; nz: single; x: single; y: single; z: single) :=
    z_Normal3fVertex3fSUN_1(nx, ny, nz, x, y, z);
    
    private z_Normal3fVertex3fvSUN_adr := GetProcAddress('glNormal3fVertex3fvSUN');
    private z_Normal3fVertex3fvSUN_1 := GetProcOrNil&<procedure(n: IntPtr; v: IntPtr)>(z_Normal3fVertex3fvSUN_adr);
    private z_Normal3fVertex3fvSUN_2 := GetProcOrNil&<procedure(var n: single; var v: single)>(z_Normal3fVertex3fvSUN_adr);
    private z_Normal3fVertex3fvSUN_3 := GetProcOrNil&<procedure(var n: Vec3f; var v: Vec3f)>(z_Normal3fVertex3fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fVertex3fvSUN(n: array of single; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        if (n<>nil) and (n.Length<>0) then
          z_Normal3fVertex3fvSUN_2(n[0], v[0]) else
          z_Normal3fVertex3fvSUN_2(Psingle(nil)^, v[0]) else
        if (n<>nil) and (n.Length<>0) then
          z_Normal3fVertex3fvSUN_2(n[0], Psingle(nil)^) else
          z_Normal3fVertex3fvSUN_2(Psingle(nil)^, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fVertex3fvSUN(var n: Vec3f; var v: Vec3f) :=
    z_Normal3fVertex3fvSUN_3(n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fVertex3fvSUN(var n: single; var v: single) :=
    z_Normal3fVertex3fvSUN_2(n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fVertex3fvSUN(n: IntPtr; v: IntPtr) :=
    z_Normal3fVertex3fvSUN_1(n, v);
    
    private z_Color4fNormal3fVertex3fSUN_adr := GetProcAddress('glColor4fNormal3fVertex3fSUN');
    private z_Color4fNormal3fVertex3fSUN_1 := GetProcOrNil&<procedure(r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single)>(z_Color4fNormal3fVertex3fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fSUN(r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single) :=
    z_Color4fNormal3fVertex3fSUN_1(r, g, b, a, nx, ny, nz, x, y, z);
    
    private z_Color4fNormal3fVertex3fvSUN_adr := GetProcAddress('glColor4fNormal3fVertex3fvSUN');
    private z_Color4fNormal3fVertex3fvSUN_1 := GetProcOrNil&<procedure(c: IntPtr; n: IntPtr; v: IntPtr)>(z_Color4fNormal3fVertex3fvSUN_adr);
    private z_Color4fNormal3fVertex3fvSUN_2 := GetProcOrNil&<procedure(var c: single; var n: single; var v: single)>(z_Color4fNormal3fVertex3fvSUN_adr);
    private z_Color4fNormal3fVertex3fvSUN_3 := GetProcOrNil&<procedure(var c: Vec4f; var n: Vec3f; var v: Vec3f)>(z_Color4fNormal3fVertex3fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(c: array of single; n: array of single; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        if (n<>nil) and (n.Length<>0) then
          if (c<>nil) and (c.Length<>0) then
            z_Color4fNormal3fVertex3fvSUN_2(c[0], n[0], v[0]) else
            z_Color4fNormal3fVertex3fvSUN_2(Psingle(nil)^, n[0], v[0]) else
          if (c<>nil) and (c.Length<>0) then
            z_Color4fNormal3fVertex3fvSUN_2(c[0], Psingle(nil)^, v[0]) else
            z_Color4fNormal3fVertex3fvSUN_2(Psingle(nil)^, Psingle(nil)^, v[0]) else
        if (n<>nil) and (n.Length<>0) then
          if (c<>nil) and (c.Length<>0) then
            z_Color4fNormal3fVertex3fvSUN_2(c[0], n[0], Psingle(nil)^) else
            z_Color4fNormal3fVertex3fvSUN_2(Psingle(nil)^, n[0], Psingle(nil)^) else
          if (c<>nil) and (c.Length<>0) then
            z_Color4fNormal3fVertex3fvSUN_2(c[0], Psingle(nil)^, Psingle(nil)^) else
            z_Color4fNormal3fVertex3fvSUN_2(Psingle(nil)^, Psingle(nil)^, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(var c: Vec4f; var n: Vec3f; var v: Vec3f) :=
    z_Color4fNormal3fVertex3fvSUN_3(c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(var c: single; var n: single; var v: single) :=
    z_Color4fNormal3fVertex3fvSUN_2(c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(c: IntPtr; n: IntPtr; v: IntPtr) :=
    z_Color4fNormal3fVertex3fvSUN_1(c, n, v);
    
    private z_TexCoord2fVertex3fSUN_adr := GetProcAddress('glTexCoord2fVertex3fSUN');
    private z_TexCoord2fVertex3fSUN_1 := GetProcOrNil&<procedure(s: single; t: single; x: single; y: single; z: single)>(z_TexCoord2fVertex3fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fVertex3fSUN(s: single; t: single; x: single; y: single; z: single) :=
    z_TexCoord2fVertex3fSUN_1(s, t, x, y, z);
    
    private z_TexCoord2fVertex3fvSUN_adr := GetProcAddress('glTexCoord2fVertex3fvSUN');
    private z_TexCoord2fVertex3fvSUN_1 := GetProcOrNil&<procedure(tc: IntPtr; v: IntPtr)>(z_TexCoord2fVertex3fvSUN_adr);
    private z_TexCoord2fVertex3fvSUN_2 := GetProcOrNil&<procedure(var tc: single; var v: single)>(z_TexCoord2fVertex3fvSUN_adr);
    private z_TexCoord2fVertex3fvSUN_3 := GetProcOrNil&<procedure(var tc: Vec2f; var v: Vec3f)>(z_TexCoord2fVertex3fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fVertex3fvSUN(tc: array of single; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        if (tc<>nil) and (tc.Length<>0) then
          z_TexCoord2fVertex3fvSUN_2(tc[0], v[0]) else
          z_TexCoord2fVertex3fvSUN_2(Psingle(nil)^, v[0]) else
        if (tc<>nil) and (tc.Length<>0) then
          z_TexCoord2fVertex3fvSUN_2(tc[0], Psingle(nil)^) else
          z_TexCoord2fVertex3fvSUN_2(Psingle(nil)^, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fVertex3fvSUN(var tc: Vec2f; var v: Vec3f) :=
    z_TexCoord2fVertex3fvSUN_3(tc, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fVertex3fvSUN(var tc: single; var v: single) :=
    z_TexCoord2fVertex3fvSUN_2(tc, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fVertex3fvSUN(tc: IntPtr; v: IntPtr) :=
    z_TexCoord2fVertex3fvSUN_1(tc, v);
    
    private z_TexCoord4fVertex4fSUN_adr := GetProcAddress('glTexCoord4fVertex4fSUN');
    private z_TexCoord4fVertex4fSUN_1 := GetProcOrNil&<procedure(s: single; t: single; p: single; q: single; x: single; y: single; z: single; w: single)>(z_TexCoord4fVertex4fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fVertex4fSUN(s: single; t: single; p: single; q: single; x: single; y: single; z: single; w: single) :=
    z_TexCoord4fVertex4fSUN_1(s, t, p, q, x, y, z, w);
    
    private z_TexCoord4fVertex4fvSUN_adr := GetProcAddress('glTexCoord4fVertex4fvSUN');
    private z_TexCoord4fVertex4fvSUN_1 := GetProcOrNil&<procedure(tc: IntPtr; v: IntPtr)>(z_TexCoord4fVertex4fvSUN_adr);
    private z_TexCoord4fVertex4fvSUN_2 := GetProcOrNil&<procedure(var tc: single; var v: single)>(z_TexCoord4fVertex4fvSUN_adr);
    private z_TexCoord4fVertex4fvSUN_3 := GetProcOrNil&<procedure(var tc: Vec4f; var v: Vec4f)>(z_TexCoord4fVertex4fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fVertex4fvSUN(tc: array of single; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        if (tc<>nil) and (tc.Length<>0) then
          z_TexCoord4fVertex4fvSUN_2(tc[0], v[0]) else
          z_TexCoord4fVertex4fvSUN_2(Psingle(nil)^, v[0]) else
        if (tc<>nil) and (tc.Length<>0) then
          z_TexCoord4fVertex4fvSUN_2(tc[0], Psingle(nil)^) else
          z_TexCoord4fVertex4fvSUN_2(Psingle(nil)^, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fVertex4fvSUN(var tc: Vec4f; var v: Vec4f) :=
    z_TexCoord4fVertex4fvSUN_3(tc, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fVertex4fvSUN(var tc: single; var v: single) :=
    z_TexCoord4fVertex4fvSUN_2(tc, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fVertex4fvSUN(tc: IntPtr; v: IntPtr) :=
    z_TexCoord4fVertex4fvSUN_1(tc, v);
    
    private z_TexCoord2fColor4ubVertex3fSUN_adr := GetProcAddress('glTexCoord2fColor4ubVertex3fSUN');
    private z_TexCoord2fColor4ubVertex3fSUN_1 := GetProcOrNil&<procedure(s: single; t: single; r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single; z: single)>(z_TexCoord2fColor4ubVertex3fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fSUN(s: single; t: single; r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single; z: single) :=
    z_TexCoord2fColor4ubVertex3fSUN_1(s, t, r, g, b, a, x, y, z);
    
    private z_TexCoord2fColor4ubVertex3fvSUN_adr := GetProcAddress('glTexCoord2fColor4ubVertex3fvSUN');
    private z_TexCoord2fColor4ubVertex3fvSUN_1 := GetProcOrNil&<procedure(tc: IntPtr; c: IntPtr; v: IntPtr)>(z_TexCoord2fColor4ubVertex3fvSUN_adr);
    private z_TexCoord2fColor4ubVertex3fvSUN_2 := GetProcOrNil&<procedure(var tc: single; var c: Byte; var v: single)>(z_TexCoord2fColor4ubVertex3fvSUN_adr);
    private z_TexCoord2fColor4ubVertex3fvSUN_3 := GetProcOrNil&<procedure(var tc: Vec2f; var c: Vec4ub; var v: Vec3f)>(z_TexCoord2fColor4ubVertex3fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(tc: array of single; c: array of Byte; v: array of single);
    type Psingle=^single;
    type PByte=^Byte;
    begin
      if (v<>nil) and (v.Length<>0) then
        if (c<>nil) and (c.Length<>0) then
          if (tc<>nil) and (tc.Length<>0) then
            z_TexCoord2fColor4ubVertex3fvSUN_2(tc[0], c[0], v[0]) else
            z_TexCoord2fColor4ubVertex3fvSUN_2(Psingle(nil)^, c[0], v[0]) else
          if (tc<>nil) and (tc.Length<>0) then
            z_TexCoord2fColor4ubVertex3fvSUN_2(tc[0], PByte(nil)^, v[0]) else
            z_TexCoord2fColor4ubVertex3fvSUN_2(Psingle(nil)^, PByte(nil)^, v[0]) else
        if (c<>nil) and (c.Length<>0) then
          if (tc<>nil) and (tc.Length<>0) then
            z_TexCoord2fColor4ubVertex3fvSUN_2(tc[0], c[0], Psingle(nil)^) else
            z_TexCoord2fColor4ubVertex3fvSUN_2(Psingle(nil)^, c[0], Psingle(nil)^) else
          if (tc<>nil) and (tc.Length<>0) then
            z_TexCoord2fColor4ubVertex3fvSUN_2(tc[0], PByte(nil)^, Psingle(nil)^) else
            z_TexCoord2fColor4ubVertex3fvSUN_2(Psingle(nil)^, PByte(nil)^, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(var tc: Vec2f; var c: Vec4ub; var v: Vec3f) :=
    z_TexCoord2fColor4ubVertex3fvSUN_3(tc, c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(var tc: single; var c: Byte; var v: single) :=
    z_TexCoord2fColor4ubVertex3fvSUN_2(tc, c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(tc: IntPtr; c: IntPtr; v: IntPtr) :=
    z_TexCoord2fColor4ubVertex3fvSUN_1(tc, c, v);
    
    private z_TexCoord2fColor3fVertex3fSUN_adr := GetProcAddress('glTexCoord2fColor3fVertex3fSUN');
    private z_TexCoord2fColor3fVertex3fSUN_1 := GetProcOrNil&<procedure(s: single; t: single; r: single; g: single; b: single; x: single; y: single; z: single)>(z_TexCoord2fColor3fVertex3fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fSUN(s: single; t: single; r: single; g: single; b: single; x: single; y: single; z: single) :=
    z_TexCoord2fColor3fVertex3fSUN_1(s, t, r, g, b, x, y, z);
    
    private z_TexCoord2fColor3fVertex3fvSUN_adr := GetProcAddress('glTexCoord2fColor3fVertex3fvSUN');
    private z_TexCoord2fColor3fVertex3fvSUN_1 := GetProcOrNil&<procedure(tc: IntPtr; c: IntPtr; v: IntPtr)>(z_TexCoord2fColor3fVertex3fvSUN_adr);
    private z_TexCoord2fColor3fVertex3fvSUN_2 := GetProcOrNil&<procedure(var tc: single; var c: single; var v: single)>(z_TexCoord2fColor3fVertex3fvSUN_adr);
    private z_TexCoord2fColor3fVertex3fvSUN_3 := GetProcOrNil&<procedure(var tc: Vec2f; var c: Vec3f; var v: Vec3f)>(z_TexCoord2fColor3fVertex3fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(tc: array of single; c: array of single; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        if (c<>nil) and (c.Length<>0) then
          if (tc<>nil) and (tc.Length<>0) then
            z_TexCoord2fColor3fVertex3fvSUN_2(tc[0], c[0], v[0]) else
            z_TexCoord2fColor3fVertex3fvSUN_2(Psingle(nil)^, c[0], v[0]) else
          if (tc<>nil) and (tc.Length<>0) then
            z_TexCoord2fColor3fVertex3fvSUN_2(tc[0], Psingle(nil)^, v[0]) else
            z_TexCoord2fColor3fVertex3fvSUN_2(Psingle(nil)^, Psingle(nil)^, v[0]) else
        if (c<>nil) and (c.Length<>0) then
          if (tc<>nil) and (tc.Length<>0) then
            z_TexCoord2fColor3fVertex3fvSUN_2(tc[0], c[0], Psingle(nil)^) else
            z_TexCoord2fColor3fVertex3fvSUN_2(Psingle(nil)^, c[0], Psingle(nil)^) else
          if (tc<>nil) and (tc.Length<>0) then
            z_TexCoord2fColor3fVertex3fvSUN_2(tc[0], Psingle(nil)^, Psingle(nil)^) else
            z_TexCoord2fColor3fVertex3fvSUN_2(Psingle(nil)^, Psingle(nil)^, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(var tc: Vec2f; var c: Vec3f; var v: Vec3f) :=
    z_TexCoord2fColor3fVertex3fvSUN_3(tc, c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(var tc: single; var c: single; var v: single) :=
    z_TexCoord2fColor3fVertex3fvSUN_2(tc, c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(tc: IntPtr; c: IntPtr; v: IntPtr) :=
    z_TexCoord2fColor3fVertex3fvSUN_1(tc, c, v);
    
    private z_TexCoord2fNormal3fVertex3fSUN_adr := GetProcAddress('glTexCoord2fNormal3fVertex3fSUN');
    private z_TexCoord2fNormal3fVertex3fSUN_1 := GetProcOrNil&<procedure(s: single; t: single; nx: single; ny: single; nz: single; x: single; y: single; z: single)>(z_TexCoord2fNormal3fVertex3fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fSUN(s: single; t: single; nx: single; ny: single; nz: single; x: single; y: single; z: single) :=
    z_TexCoord2fNormal3fVertex3fSUN_1(s, t, nx, ny, nz, x, y, z);
    
    private z_TexCoord2fNormal3fVertex3fvSUN_adr := GetProcAddress('glTexCoord2fNormal3fVertex3fvSUN');
    private z_TexCoord2fNormal3fVertex3fvSUN_1 := GetProcOrNil&<procedure(tc: IntPtr; n: IntPtr; v: IntPtr)>(z_TexCoord2fNormal3fVertex3fvSUN_adr);
    private z_TexCoord2fNormal3fVertex3fvSUN_2 := GetProcOrNil&<procedure(var tc: single; var n: single; var v: single)>(z_TexCoord2fNormal3fVertex3fvSUN_adr);
    private z_TexCoord2fNormal3fVertex3fvSUN_3 := GetProcOrNil&<procedure(var tc: Vec2f; var n: Vec3f; var v: Vec3f)>(z_TexCoord2fNormal3fVertex3fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(tc: array of single; n: array of single; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        if (n<>nil) and (n.Length<>0) then
          if (tc<>nil) and (tc.Length<>0) then
            z_TexCoord2fNormal3fVertex3fvSUN_2(tc[0], n[0], v[0]) else
            z_TexCoord2fNormal3fVertex3fvSUN_2(Psingle(nil)^, n[0], v[0]) else
          if (tc<>nil) and (tc.Length<>0) then
            z_TexCoord2fNormal3fVertex3fvSUN_2(tc[0], Psingle(nil)^, v[0]) else
            z_TexCoord2fNormal3fVertex3fvSUN_2(Psingle(nil)^, Psingle(nil)^, v[0]) else
        if (n<>nil) and (n.Length<>0) then
          if (tc<>nil) and (tc.Length<>0) then
            z_TexCoord2fNormal3fVertex3fvSUN_2(tc[0], n[0], Psingle(nil)^) else
            z_TexCoord2fNormal3fVertex3fvSUN_2(Psingle(nil)^, n[0], Psingle(nil)^) else
          if (tc<>nil) and (tc.Length<>0) then
            z_TexCoord2fNormal3fVertex3fvSUN_2(tc[0], Psingle(nil)^, Psingle(nil)^) else
            z_TexCoord2fNormal3fVertex3fvSUN_2(Psingle(nil)^, Psingle(nil)^, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(var tc: Vec2f; var n: Vec3f; var v: Vec3f) :=
    z_TexCoord2fNormal3fVertex3fvSUN_3(tc, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(var tc: single; var n: single; var v: single) :=
    z_TexCoord2fNormal3fVertex3fvSUN_2(tc, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(tc: IntPtr; n: IntPtr; v: IntPtr) :=
    z_TexCoord2fNormal3fVertex3fvSUN_1(tc, n, v);
    
    private z_TexCoord2fColor4fNormal3fVertex3fSUN_adr := GetProcAddress('glTexCoord2fColor4fNormal3fVertex3fSUN');
    private z_TexCoord2fColor4fNormal3fVertex3fSUN_1 := GetProcOrNil&<procedure(s: single; t: single; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single)>(z_TexCoord2fColor4fNormal3fVertex3fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fSUN(s: single; t: single; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single) :=
    z_TexCoord2fColor4fNormal3fVertex3fSUN_1(s, t, r, g, b, a, nx, ny, nz, x, y, z);
    
    private z_TexCoord2fColor4fNormal3fVertex3fvSUN_adr := GetProcAddress('glTexCoord2fColor4fNormal3fVertex3fvSUN');
    private z_TexCoord2fColor4fNormal3fVertex3fvSUN_1 := GetProcOrNil&<procedure(tc: IntPtr; c: IntPtr; n: IntPtr; v: IntPtr)>(z_TexCoord2fColor4fNormal3fVertex3fvSUN_adr);
    private z_TexCoord2fColor4fNormal3fVertex3fvSUN_2 := GetProcOrNil&<procedure(var tc: single; var c: single; var n: single; var v: single)>(z_TexCoord2fColor4fNormal3fVertex3fvSUN_adr);
    private z_TexCoord2fColor4fNormal3fVertex3fvSUN_3 := GetProcOrNil&<procedure(var tc: Vec2f; var c: Vec4f; var n: Vec3f; var v: Vec3f)>(z_TexCoord2fColor4fNormal3fVertex3fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: array of single; c: array of single; n: array of single; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        if (n<>nil) and (n.Length<>0) then
          if (c<>nil) and (c.Length<>0) then
            if (tc<>nil) and (tc.Length<>0) then
              z_TexCoord2fColor4fNormal3fVertex3fvSUN_2(tc[0], c[0], n[0], v[0]) else
              z_TexCoord2fColor4fNormal3fVertex3fvSUN_2(Psingle(nil)^, c[0], n[0], v[0]) else
            if (tc<>nil) and (tc.Length<>0) then
              z_TexCoord2fColor4fNormal3fVertex3fvSUN_2(tc[0], Psingle(nil)^, n[0], v[0]) else
              z_TexCoord2fColor4fNormal3fVertex3fvSUN_2(Psingle(nil)^, Psingle(nil)^, n[0], v[0]) else
          if (c<>nil) and (c.Length<>0) then
            if (tc<>nil) and (tc.Length<>0) then
              z_TexCoord2fColor4fNormal3fVertex3fvSUN_2(tc[0], c[0], Psingle(nil)^, v[0]) else
              z_TexCoord2fColor4fNormal3fVertex3fvSUN_2(Psingle(nil)^, c[0], Psingle(nil)^, v[0]) else
            if (tc<>nil) and (tc.Length<>0) then
              z_TexCoord2fColor4fNormal3fVertex3fvSUN_2(tc[0], Psingle(nil)^, Psingle(nil)^, v[0]) else
              z_TexCoord2fColor4fNormal3fVertex3fvSUN_2(Psingle(nil)^, Psingle(nil)^, Psingle(nil)^, v[0]) else
        if (n<>nil) and (n.Length<>0) then
          if (c<>nil) and (c.Length<>0) then
            if (tc<>nil) and (tc.Length<>0) then
              z_TexCoord2fColor4fNormal3fVertex3fvSUN_2(tc[0], c[0], n[0], Psingle(nil)^) else
              z_TexCoord2fColor4fNormal3fVertex3fvSUN_2(Psingle(nil)^, c[0], n[0], Psingle(nil)^) else
            if (tc<>nil) and (tc.Length<>0) then
              z_TexCoord2fColor4fNormal3fVertex3fvSUN_2(tc[0], Psingle(nil)^, n[0], Psingle(nil)^) else
              z_TexCoord2fColor4fNormal3fVertex3fvSUN_2(Psingle(nil)^, Psingle(nil)^, n[0], Psingle(nil)^) else
          if (c<>nil) and (c.Length<>0) then
            if (tc<>nil) and (tc.Length<>0) then
              z_TexCoord2fColor4fNormal3fVertex3fvSUN_2(tc[0], c[0], Psingle(nil)^, Psingle(nil)^) else
              z_TexCoord2fColor4fNormal3fVertex3fvSUN_2(Psingle(nil)^, c[0], Psingle(nil)^, Psingle(nil)^) else
            if (tc<>nil) and (tc.Length<>0) then
              z_TexCoord2fColor4fNormal3fVertex3fvSUN_2(tc[0], Psingle(nil)^, Psingle(nil)^, Psingle(nil)^) else
              z_TexCoord2fColor4fNormal3fVertex3fvSUN_2(Psingle(nil)^, Psingle(nil)^, Psingle(nil)^, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(var tc: Vec2f; var c: Vec4f; var n: Vec3f; var v: Vec3f) :=
    z_TexCoord2fColor4fNormal3fVertex3fvSUN_3(tc, c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(var tc: single; var c: single; var n: single; var v: single) :=
    z_TexCoord2fColor4fNormal3fVertex3fvSUN_2(tc, c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: IntPtr; c: IntPtr; n: IntPtr; v: IntPtr) :=
    z_TexCoord2fColor4fNormal3fVertex3fvSUN_1(tc, c, n, v);
    
    private z_TexCoord4fColor4fNormal3fVertex4fSUN_adr := GetProcAddress('glTexCoord4fColor4fNormal3fVertex4fSUN');
    private z_TexCoord4fColor4fNormal3fVertex4fSUN_1 := GetProcOrNil&<procedure(s: single; t: single; p: single; q: single; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single; w: single)>(z_TexCoord4fColor4fNormal3fVertex4fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fSUN(s: single; t: single; p: single; q: single; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single; w: single) :=
    z_TexCoord4fColor4fNormal3fVertex4fSUN_1(s, t, p, q, r, g, b, a, nx, ny, nz, x, y, z, w);
    
    private z_TexCoord4fColor4fNormal3fVertex4fvSUN_adr := GetProcAddress('glTexCoord4fColor4fNormal3fVertex4fvSUN');
    private z_TexCoord4fColor4fNormal3fVertex4fvSUN_1 := GetProcOrNil&<procedure(tc: IntPtr; c: IntPtr; n: IntPtr; v: IntPtr)>(z_TexCoord4fColor4fNormal3fVertex4fvSUN_adr);
    private z_TexCoord4fColor4fNormal3fVertex4fvSUN_2 := GetProcOrNil&<procedure(var tc: single; var c: single; var n: single; var v: single)>(z_TexCoord4fColor4fNormal3fVertex4fvSUN_adr);
    private z_TexCoord4fColor4fNormal3fVertex4fvSUN_3 := GetProcOrNil&<procedure(var tc: Vec4f; var c: Vec4f; var n: Vec3f; var v: Vec4f)>(z_TexCoord4fColor4fNormal3fVertex4fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: array of single; c: array of single; n: array of single; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        if (n<>nil) and (n.Length<>0) then
          if (c<>nil) and (c.Length<>0) then
            if (tc<>nil) and (tc.Length<>0) then
              z_TexCoord4fColor4fNormal3fVertex4fvSUN_2(tc[0], c[0], n[0], v[0]) else
              z_TexCoord4fColor4fNormal3fVertex4fvSUN_2(Psingle(nil)^, c[0], n[0], v[0]) else
            if (tc<>nil) and (tc.Length<>0) then
              z_TexCoord4fColor4fNormal3fVertex4fvSUN_2(tc[0], Psingle(nil)^, n[0], v[0]) else
              z_TexCoord4fColor4fNormal3fVertex4fvSUN_2(Psingle(nil)^, Psingle(nil)^, n[0], v[0]) else
          if (c<>nil) and (c.Length<>0) then
            if (tc<>nil) and (tc.Length<>0) then
              z_TexCoord4fColor4fNormal3fVertex4fvSUN_2(tc[0], c[0], Psingle(nil)^, v[0]) else
              z_TexCoord4fColor4fNormal3fVertex4fvSUN_2(Psingle(nil)^, c[0], Psingle(nil)^, v[0]) else
            if (tc<>nil) and (tc.Length<>0) then
              z_TexCoord4fColor4fNormal3fVertex4fvSUN_2(tc[0], Psingle(nil)^, Psingle(nil)^, v[0]) else
              z_TexCoord4fColor4fNormal3fVertex4fvSUN_2(Psingle(nil)^, Psingle(nil)^, Psingle(nil)^, v[0]) else
        if (n<>nil) and (n.Length<>0) then
          if (c<>nil) and (c.Length<>0) then
            if (tc<>nil) and (tc.Length<>0) then
              z_TexCoord4fColor4fNormal3fVertex4fvSUN_2(tc[0], c[0], n[0], Psingle(nil)^) else
              z_TexCoord4fColor4fNormal3fVertex4fvSUN_2(Psingle(nil)^, c[0], n[0], Psingle(nil)^) else
            if (tc<>nil) and (tc.Length<>0) then
              z_TexCoord4fColor4fNormal3fVertex4fvSUN_2(tc[0], Psingle(nil)^, n[0], Psingle(nil)^) else
              z_TexCoord4fColor4fNormal3fVertex4fvSUN_2(Psingle(nil)^, Psingle(nil)^, n[0], Psingle(nil)^) else
          if (c<>nil) and (c.Length<>0) then
            if (tc<>nil) and (tc.Length<>0) then
              z_TexCoord4fColor4fNormal3fVertex4fvSUN_2(tc[0], c[0], Psingle(nil)^, Psingle(nil)^) else
              z_TexCoord4fColor4fNormal3fVertex4fvSUN_2(Psingle(nil)^, c[0], Psingle(nil)^, Psingle(nil)^) else
            if (tc<>nil) and (tc.Length<>0) then
              z_TexCoord4fColor4fNormal3fVertex4fvSUN_2(tc[0], Psingle(nil)^, Psingle(nil)^, Psingle(nil)^) else
              z_TexCoord4fColor4fNormal3fVertex4fvSUN_2(Psingle(nil)^, Psingle(nil)^, Psingle(nil)^, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(var tc: Vec4f; var c: Vec4f; var n: Vec3f; var v: Vec4f) :=
    z_TexCoord4fColor4fNormal3fVertex4fvSUN_3(tc, c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(var tc: single; var c: single; var n: single; var v: single) :=
    z_TexCoord4fColor4fNormal3fVertex4fvSUN_2(tc, c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: IntPtr; c: IntPtr; n: IntPtr; v: IntPtr) :=
    z_TexCoord4fColor4fNormal3fVertex4fvSUN_1(tc, c, n, v);
    
    private z_ReplacementCodeuiVertex3fSUN_adr := GetProcAddress('glReplacementCodeuiVertex3fSUN');
    private z_ReplacementCodeuiVertex3fSUN_1 := GetProcOrNil&<procedure(rc: TriangleList; x: single; y: single; z: single)>(z_ReplacementCodeuiVertex3fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiVertex3fSUN(rc: TriangleList; x: single; y: single; z: single) :=
    z_ReplacementCodeuiVertex3fSUN_1(rc, x, y, z);
    
    private z_ReplacementCodeuiVertex3fvSUN_adr := GetProcAddress('glReplacementCodeuiVertex3fvSUN');
    private z_ReplacementCodeuiVertex3fvSUN_1 := GetProcOrNil&<procedure(rc: IntPtr; v: IntPtr)>(z_ReplacementCodeuiVertex3fvSUN_adr);
    private z_ReplacementCodeuiVertex3fvSUN_2 := GetProcOrNil&<procedure(var rc: TriangleList; var v: single)>(z_ReplacementCodeuiVertex3fvSUN_adr);
    private z_ReplacementCodeuiVertex3fvSUN_3 := GetProcOrNil&<procedure(var rc: TriangleList; var v: Vec3f)>(z_ReplacementCodeuiVertex3fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiVertex3fvSUN(var rc: TriangleList; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        z_ReplacementCodeuiVertex3fvSUN_2(rc, v[0]) else
        z_ReplacementCodeuiVertex3fvSUN_2(rc, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiVertex3fvSUN(var rc: TriangleList; var v: Vec3f) :=
    z_ReplacementCodeuiVertex3fvSUN_3(rc, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiVertex3fvSUN(var rc: TriangleList; var v: single) :=
    z_ReplacementCodeuiVertex3fvSUN_2(rc, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiVertex3fvSUN(rc: IntPtr; v: IntPtr) :=
    z_ReplacementCodeuiVertex3fvSUN_1(rc, v);
    
    private z_ReplacementCodeuiColor4ubVertex3fSUN_adr := GetProcAddress('glReplacementCodeuiColor4ubVertex3fSUN');
    private z_ReplacementCodeuiColor4ubVertex3fSUN_1 := GetProcOrNil&<procedure(rc: TriangleList; r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single; z: single)>(z_ReplacementCodeuiColor4ubVertex3fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fSUN(rc: TriangleList; r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single; z: single) :=
    z_ReplacementCodeuiColor4ubVertex3fSUN_1(rc, r, g, b, a, x, y, z);
    
    private z_ReplacementCodeuiColor4ubVertex3fvSUN_adr := GetProcAddress('glReplacementCodeuiColor4ubVertex3fvSUN');
    private z_ReplacementCodeuiColor4ubVertex3fvSUN_1 := GetProcOrNil&<procedure(rc: IntPtr; c: IntPtr; v: IntPtr)>(z_ReplacementCodeuiColor4ubVertex3fvSUN_adr);
    private z_ReplacementCodeuiColor4ubVertex3fvSUN_2 := GetProcOrNil&<procedure(var rc: TriangleList; var c: Byte; var v: single)>(z_ReplacementCodeuiColor4ubVertex3fvSUN_adr);
    private z_ReplacementCodeuiColor4ubVertex3fvSUN_3 := GetProcOrNil&<procedure(var rc: TriangleList; var c: Vec4ub; var v: Vec3f)>(z_ReplacementCodeuiColor4ubVertex3fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(var rc: TriangleList; c: array of Byte; v: array of single);
    type PByte=^Byte;
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        if (c<>nil) and (c.Length<>0) then
          z_ReplacementCodeuiColor4ubVertex3fvSUN_2(rc, c[0], v[0]) else
          z_ReplacementCodeuiColor4ubVertex3fvSUN_2(rc, PByte(nil)^, v[0]) else
        if (c<>nil) and (c.Length<>0) then
          z_ReplacementCodeuiColor4ubVertex3fvSUN_2(rc, c[0], Psingle(nil)^) else
          z_ReplacementCodeuiColor4ubVertex3fvSUN_2(rc, PByte(nil)^, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(var rc: TriangleList; var c: Vec4ub; var v: Vec3f) :=
    z_ReplacementCodeuiColor4ubVertex3fvSUN_3(rc, c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(var rc: TriangleList; var c: Byte; var v: single) :=
    z_ReplacementCodeuiColor4ubVertex3fvSUN_2(rc, c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(rc: IntPtr; c: IntPtr; v: IntPtr) :=
    z_ReplacementCodeuiColor4ubVertex3fvSUN_1(rc, c, v);
    
    private z_ReplacementCodeuiColor3fVertex3fSUN_adr := GetProcAddress('glReplacementCodeuiColor3fVertex3fSUN');
    private z_ReplacementCodeuiColor3fVertex3fSUN_1 := GetProcOrNil&<procedure(rc: TriangleList; r: single; g: single; b: single; x: single; y: single; z: single)>(z_ReplacementCodeuiColor3fVertex3fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fSUN(rc: TriangleList; r: single; g: single; b: single; x: single; y: single; z: single) :=
    z_ReplacementCodeuiColor3fVertex3fSUN_1(rc, r, g, b, x, y, z);
    
    private z_ReplacementCodeuiColor3fVertex3fvSUN_adr := GetProcAddress('glReplacementCodeuiColor3fVertex3fvSUN');
    private z_ReplacementCodeuiColor3fVertex3fvSUN_1 := GetProcOrNil&<procedure(rc: IntPtr; c: IntPtr; v: IntPtr)>(z_ReplacementCodeuiColor3fVertex3fvSUN_adr);
    private z_ReplacementCodeuiColor3fVertex3fvSUN_2 := GetProcOrNil&<procedure(var rc: TriangleList; var c: single; var v: single)>(z_ReplacementCodeuiColor3fVertex3fvSUN_adr);
    private z_ReplacementCodeuiColor3fVertex3fvSUN_3 := GetProcOrNil&<procedure(var rc: TriangleList; var c: Vec3f; var v: Vec3f)>(z_ReplacementCodeuiColor3fVertex3fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(var rc: TriangleList; c: array of single; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        if (c<>nil) and (c.Length<>0) then
          z_ReplacementCodeuiColor3fVertex3fvSUN_2(rc, c[0], v[0]) else
          z_ReplacementCodeuiColor3fVertex3fvSUN_2(rc, Psingle(nil)^, v[0]) else
        if (c<>nil) and (c.Length<>0) then
          z_ReplacementCodeuiColor3fVertex3fvSUN_2(rc, c[0], Psingle(nil)^) else
          z_ReplacementCodeuiColor3fVertex3fvSUN_2(rc, Psingle(nil)^, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(var rc: TriangleList; var c: Vec3f; var v: Vec3f) :=
    z_ReplacementCodeuiColor3fVertex3fvSUN_3(rc, c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(var rc: TriangleList; var c: single; var v: single) :=
    z_ReplacementCodeuiColor3fVertex3fvSUN_2(rc, c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(rc: IntPtr; c: IntPtr; v: IntPtr) :=
    z_ReplacementCodeuiColor3fVertex3fvSUN_1(rc, c, v);
    
    private z_ReplacementCodeuiNormal3fVertex3fSUN_adr := GetProcAddress('glReplacementCodeuiNormal3fVertex3fSUN');
    private z_ReplacementCodeuiNormal3fVertex3fSUN_1 := GetProcOrNil&<procedure(rc: TriangleList; nx: single; ny: single; nz: single; x: single; y: single; z: single)>(z_ReplacementCodeuiNormal3fVertex3fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fSUN(rc: TriangleList; nx: single; ny: single; nz: single; x: single; y: single; z: single) :=
    z_ReplacementCodeuiNormal3fVertex3fSUN_1(rc, nx, ny, nz, x, y, z);
    
    private z_ReplacementCodeuiNormal3fVertex3fvSUN_adr := GetProcAddress('glReplacementCodeuiNormal3fVertex3fvSUN');
    private z_ReplacementCodeuiNormal3fVertex3fvSUN_1 := GetProcOrNil&<procedure(rc: IntPtr; n: IntPtr; v: IntPtr)>(z_ReplacementCodeuiNormal3fVertex3fvSUN_adr);
    private z_ReplacementCodeuiNormal3fVertex3fvSUN_2 := GetProcOrNil&<procedure(var rc: TriangleList; var n: single; var v: single)>(z_ReplacementCodeuiNormal3fVertex3fvSUN_adr);
    private z_ReplacementCodeuiNormal3fVertex3fvSUN_3 := GetProcOrNil&<procedure(var rc: TriangleList; var n: Vec3f; var v: Vec3f)>(z_ReplacementCodeuiNormal3fVertex3fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(var rc: TriangleList; n: array of single; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        if (n<>nil) and (n.Length<>0) then
          z_ReplacementCodeuiNormal3fVertex3fvSUN_2(rc, n[0], v[0]) else
          z_ReplacementCodeuiNormal3fVertex3fvSUN_2(rc, Psingle(nil)^, v[0]) else
        if (n<>nil) and (n.Length<>0) then
          z_ReplacementCodeuiNormal3fVertex3fvSUN_2(rc, n[0], Psingle(nil)^) else
          z_ReplacementCodeuiNormal3fVertex3fvSUN_2(rc, Psingle(nil)^, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(var rc: TriangleList; var n: Vec3f; var v: Vec3f) :=
    z_ReplacementCodeuiNormal3fVertex3fvSUN_3(rc, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(var rc: TriangleList; var n: single; var v: single) :=
    z_ReplacementCodeuiNormal3fVertex3fvSUN_2(rc, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(rc: IntPtr; n: IntPtr; v: IntPtr) :=
    z_ReplacementCodeuiNormal3fVertex3fvSUN_1(rc, n, v);
    
    private z_ReplacementCodeuiColor4fNormal3fVertex3fSUN_adr := GetProcAddress('glReplacementCodeuiColor4fNormal3fVertex3fSUN');
    private z_ReplacementCodeuiColor4fNormal3fVertex3fSUN_1 := GetProcOrNil&<procedure(rc: TriangleList; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single)>(z_ReplacementCodeuiColor4fNormal3fVertex3fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fSUN(rc: TriangleList; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single) :=
    z_ReplacementCodeuiColor4fNormal3fVertex3fSUN_1(rc, r, g, b, a, nx, ny, nz, x, y, z);
    
    private z_ReplacementCodeuiColor4fNormal3fVertex3fvSUN_adr := GetProcAddress('glReplacementCodeuiColor4fNormal3fVertex3fvSUN');
    private z_ReplacementCodeuiColor4fNormal3fVertex3fvSUN_1 := GetProcOrNil&<procedure(rc: IntPtr; c: IntPtr; n: IntPtr; v: IntPtr)>(z_ReplacementCodeuiColor4fNormal3fVertex3fvSUN_adr);
    private z_ReplacementCodeuiColor4fNormal3fVertex3fvSUN_2 := GetProcOrNil&<procedure(var rc: TriangleList; var c: single; var n: single; var v: single)>(z_ReplacementCodeuiColor4fNormal3fVertex3fvSUN_adr);
    private z_ReplacementCodeuiColor4fNormal3fVertex3fvSUN_3 := GetProcOrNil&<procedure(var rc: TriangleList; var c: Vec4f; var n: Vec3f; var v: Vec3f)>(z_ReplacementCodeuiColor4fNormal3fVertex3fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(var rc: TriangleList; c: array of single; n: array of single; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        if (n<>nil) and (n.Length<>0) then
          if (c<>nil) and (c.Length<>0) then
            z_ReplacementCodeuiColor4fNormal3fVertex3fvSUN_2(rc, c[0], n[0], v[0]) else
            z_ReplacementCodeuiColor4fNormal3fVertex3fvSUN_2(rc, Psingle(nil)^, n[0], v[0]) else
          if (c<>nil) and (c.Length<>0) then
            z_ReplacementCodeuiColor4fNormal3fVertex3fvSUN_2(rc, c[0], Psingle(nil)^, v[0]) else
            z_ReplacementCodeuiColor4fNormal3fVertex3fvSUN_2(rc, Psingle(nil)^, Psingle(nil)^, v[0]) else
        if (n<>nil) and (n.Length<>0) then
          if (c<>nil) and (c.Length<>0) then
            z_ReplacementCodeuiColor4fNormal3fVertex3fvSUN_2(rc, c[0], n[0], Psingle(nil)^) else
            z_ReplacementCodeuiColor4fNormal3fVertex3fvSUN_2(rc, Psingle(nil)^, n[0], Psingle(nil)^) else
          if (c<>nil) and (c.Length<>0) then
            z_ReplacementCodeuiColor4fNormal3fVertex3fvSUN_2(rc, c[0], Psingle(nil)^, Psingle(nil)^) else
            z_ReplacementCodeuiColor4fNormal3fVertex3fvSUN_2(rc, Psingle(nil)^, Psingle(nil)^, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(var rc: TriangleList; var c: Vec4f; var n: Vec3f; var v: Vec3f) :=
    z_ReplacementCodeuiColor4fNormal3fVertex3fvSUN_3(rc, c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(var rc: TriangleList; var c: single; var n: single; var v: single) :=
    z_ReplacementCodeuiColor4fNormal3fVertex3fvSUN_2(rc, c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: IntPtr; c: IntPtr; n: IntPtr; v: IntPtr) :=
    z_ReplacementCodeuiColor4fNormal3fVertex3fvSUN_1(rc, c, n, v);
    
    private z_ReplacementCodeuiTexCoord2fVertex3fSUN_adr := GetProcAddress('glReplacementCodeuiTexCoord2fVertex3fSUN');
    private z_ReplacementCodeuiTexCoord2fVertex3fSUN_1 := GetProcOrNil&<procedure(rc: TriangleList; s: single; t: single; x: single; y: single; z: single)>(z_ReplacementCodeuiTexCoord2fVertex3fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fSUN(rc: TriangleList; s: single; t: single; x: single; y: single; z: single) :=
    z_ReplacementCodeuiTexCoord2fVertex3fSUN_1(rc, s, t, x, y, z);
    
    private z_ReplacementCodeuiTexCoord2fVertex3fvSUN_adr := GetProcAddress('glReplacementCodeuiTexCoord2fVertex3fvSUN');
    private z_ReplacementCodeuiTexCoord2fVertex3fvSUN_1 := GetProcOrNil&<procedure(rc: IntPtr; tc: IntPtr; v: IntPtr)>(z_ReplacementCodeuiTexCoord2fVertex3fvSUN_adr);
    private z_ReplacementCodeuiTexCoord2fVertex3fvSUN_2 := GetProcOrNil&<procedure(var rc: TriangleList; var tc: single; var v: single)>(z_ReplacementCodeuiTexCoord2fVertex3fvSUN_adr);
    private z_ReplacementCodeuiTexCoord2fVertex3fvSUN_3 := GetProcOrNil&<procedure(var rc: TriangleList; var tc: Vec2f; var v: Vec3f)>(z_ReplacementCodeuiTexCoord2fVertex3fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(var rc: TriangleList; tc: array of single; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        if (tc<>nil) and (tc.Length<>0) then
          z_ReplacementCodeuiTexCoord2fVertex3fvSUN_2(rc, tc[0], v[0]) else
          z_ReplacementCodeuiTexCoord2fVertex3fvSUN_2(rc, Psingle(nil)^, v[0]) else
        if (tc<>nil) and (tc.Length<>0) then
          z_ReplacementCodeuiTexCoord2fVertex3fvSUN_2(rc, tc[0], Psingle(nil)^) else
          z_ReplacementCodeuiTexCoord2fVertex3fvSUN_2(rc, Psingle(nil)^, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(var rc: TriangleList; var tc: Vec2f; var v: Vec3f) :=
    z_ReplacementCodeuiTexCoord2fVertex3fvSUN_3(rc, tc, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(var rc: TriangleList; var tc: single; var v: single) :=
    z_ReplacementCodeuiTexCoord2fVertex3fvSUN_2(rc, tc, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(rc: IntPtr; tc: IntPtr; v: IntPtr) :=
    z_ReplacementCodeuiTexCoord2fVertex3fvSUN_1(rc, tc, v);
    
    private z_ReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_adr := GetProcAddress('glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN');
    private z_ReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_1 := GetProcOrNil&<procedure(rc: TriangleList; s: single; t: single; nx: single; ny: single; nz: single; x: single; y: single; z: single)>(z_ReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(rc: TriangleList; s: single; t: single; nx: single; ny: single; nz: single; x: single; y: single; z: single) :=
    z_ReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_1(rc, s, t, nx, ny, nz, x, y, z);
    
    private z_ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_adr := GetProcAddress('glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN');
    private z_ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_1 := GetProcOrNil&<procedure(rc: IntPtr; tc: IntPtr; n: IntPtr; v: IntPtr)>(z_ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_adr);
    private z_ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_2 := GetProcOrNil&<procedure(var rc: TriangleList; var tc: single; var n: single; var v: single)>(z_ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_adr);
    private z_ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_3 := GetProcOrNil&<procedure(var rc: TriangleList; var tc: Vec2f; var n: Vec3f; var v: Vec3f)>(z_ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(var rc: TriangleList; tc: array of single; n: array of single; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        if (n<>nil) and (n.Length<>0) then
          if (tc<>nil) and (tc.Length<>0) then
            z_ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_2(rc, tc[0], n[0], v[0]) else
            z_ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_2(rc, Psingle(nil)^, n[0], v[0]) else
          if (tc<>nil) and (tc.Length<>0) then
            z_ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_2(rc, tc[0], Psingle(nil)^, v[0]) else
            z_ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_2(rc, Psingle(nil)^, Psingle(nil)^, v[0]) else
        if (n<>nil) and (n.Length<>0) then
          if (tc<>nil) and (tc.Length<>0) then
            z_ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_2(rc, tc[0], n[0], Psingle(nil)^) else
            z_ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_2(rc, Psingle(nil)^, n[0], Psingle(nil)^) else
          if (tc<>nil) and (tc.Length<>0) then
            z_ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_2(rc, tc[0], Psingle(nil)^, Psingle(nil)^) else
            z_ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_2(rc, Psingle(nil)^, Psingle(nil)^, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(var rc: TriangleList; var tc: Vec2f; var n: Vec3f; var v: Vec3f) :=
    z_ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_3(rc, tc, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(var rc: TriangleList; var tc: single; var n: single; var v: single) :=
    z_ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_2(rc, tc, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: IntPtr; tc: IntPtr; n: IntPtr; v: IntPtr) :=
    z_ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_1(rc, tc, n, v);
    
    private z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_adr := GetProcAddress('glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN');
    private z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_1 := GetProcOrNil&<procedure(rc: TriangleList; s: single; t: single; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single)>(z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(rc: TriangleList; s: single; t: single; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single) :=
    z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_1(rc, s, t, r, g, b, a, nx, ny, nz, x, y, z);
    
    private z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_adr := GetProcAddress('glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN');
    private z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_1 := GetProcOrNil&<procedure(rc: IntPtr; tc: IntPtr; c: IntPtr; n: IntPtr; v: IntPtr)>(z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_adr);
    private z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_2 := GetProcOrNil&<procedure(var rc: TriangleList; var tc: single; var c: single; var n: single; var v: single)>(z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_adr);
    private z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_3 := GetProcOrNil&<procedure(var rc: TriangleList; var tc: Vec2f; var c: Vec4f; var n: Vec3f; var v: Vec3f)>(z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: TriangleList; tc: array of single; c: array of single; n: array of single; v: array of single);
    type Psingle=^single;
    begin
      if (v<>nil) and (v.Length<>0) then
        if (n<>nil) and (n.Length<>0) then
          if (c<>nil) and (c.Length<>0) then
            if (tc<>nil) and (tc.Length<>0) then
              z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_2(rc, tc[0], c[0], n[0], v[0]) else
              z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_2(rc, Psingle(nil)^, c[0], n[0], v[0]) else
            if (tc<>nil) and (tc.Length<>0) then
              z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_2(rc, tc[0], Psingle(nil)^, n[0], v[0]) else
              z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_2(rc, Psingle(nil)^, Psingle(nil)^, n[0], v[0]) else
          if (c<>nil) and (c.Length<>0) then
            if (tc<>nil) and (tc.Length<>0) then
              z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_2(rc, tc[0], c[0], Psingle(nil)^, v[0]) else
              z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_2(rc, Psingle(nil)^, c[0], Psingle(nil)^, v[0]) else
            if (tc<>nil) and (tc.Length<>0) then
              z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_2(rc, tc[0], Psingle(nil)^, Psingle(nil)^, v[0]) else
              z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_2(rc, Psingle(nil)^, Psingle(nil)^, Psingle(nil)^, v[0]) else
        if (n<>nil) and (n.Length<>0) then
          if (c<>nil) and (c.Length<>0) then
            if (tc<>nil) and (tc.Length<>0) then
              z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_2(rc, tc[0], c[0], n[0], Psingle(nil)^) else
              z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_2(rc, Psingle(nil)^, c[0], n[0], Psingle(nil)^) else
            if (tc<>nil) and (tc.Length<>0) then
              z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_2(rc, tc[0], Psingle(nil)^, n[0], Psingle(nil)^) else
              z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_2(rc, Psingle(nil)^, Psingle(nil)^, n[0], Psingle(nil)^) else
          if (c<>nil) and (c.Length<>0) then
            if (tc<>nil) and (tc.Length<>0) then
              z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_2(rc, tc[0], c[0], Psingle(nil)^, Psingle(nil)^) else
              z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_2(rc, Psingle(nil)^, c[0], Psingle(nil)^, Psingle(nil)^) else
            if (tc<>nil) and (tc.Length<>0) then
              z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_2(rc, tc[0], Psingle(nil)^, Psingle(nil)^, Psingle(nil)^) else
              z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_2(rc, Psingle(nil)^, Psingle(nil)^, Psingle(nil)^, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: TriangleList; var tc: Vec2f; var c: Vec4f; var n: Vec3f; var v: Vec3f) :=
    z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_3(rc, tc, c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: TriangleList; var tc: single; var c: single; var n: single; var v: single) :=
    z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_2(rc, tc, c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: IntPtr; tc: IntPtr; c: IntPtr; n: IntPtr; v: IntPtr) :=
    z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_1(rc, tc, c, n, v);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  wglStereoControl3DL = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'wgl_3dl_stereo_control';
    
    private z_SetStereoEmitterState3DL_adr := GetProcAddress('wglSetStereoEmitterState3DL');
    private z_SetStereoEmitterState3DL_1 := GetProcOrNil&<function(hDC: gdi_device_context; uState: UInt32): Bool>(z_SetStereoEmitterState3DL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetStereoEmitterState3DL(hDC: gdi_device_context; uState: UInt32): Bool :=
    z_SetStereoEmitterState3DL_1(hDC, uState);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  wglGpuAssociationAMD = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'wgl_amd_gpu_association';
    
    private z_GetGPUIDsAMD_adr := GetProcAddress('wglGetGPUIDsAMD');
    private z_GetGPUIDsAMD_1 := GetProcOrNil&<function(maxCount: UInt32; ids: IntPtr): UInt32>(z_GetGPUIDsAMD_adr);
    private z_GetGPUIDsAMD_2 := GetProcOrNil&<function(maxCount: UInt32; var ids: UInt32): UInt32>(z_GetGPUIDsAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGPUIDsAMD(maxCount: UInt32; var ids: UInt32): UInt32 :=
    z_GetGPUIDsAMD_2(maxCount, ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGPUIDsAMD(maxCount: UInt32; ids: IntPtr): UInt32 :=
    z_GetGPUIDsAMD_1(maxCount, ids);
    
    private z_GetGPUInfoAMD_adr := GetProcAddress('wglGetGPUInfoAMD');
    private z_GetGPUInfoAMD_1 := GetProcOrNil&<function(id: UInt32; &property: Int32; dataType: DummyEnum; size: UInt32; data: IntPtr): Int32>(z_GetGPUInfoAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGPUInfoAMD(id: UInt32; &property: Int32; dataType: DummyEnum; size: UInt32; data: IntPtr): Int32 :=
    z_GetGPUInfoAMD_1(id, &property, dataType, size, data);
    
    private z_GetContextGPUIDAMD_adr := GetProcAddress('wglGetContextGPUIDAMD');
    private z_GetContextGPUIDAMD_1 := GetProcOrNil&<function(hglrc: wgl_context): UInt32>(z_GetContextGPUIDAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetContextGPUIDAMD(hglrc: wgl_context): UInt32 :=
    z_GetContextGPUIDAMD_1(hglrc);
    
    private z_CreateAssociatedContextAMD_adr := GetProcAddress('wglCreateAssociatedContextAMD');
    private z_CreateAssociatedContextAMD_1 := GetProcOrNil&<function(id: UInt32): wgl_context>(z_CreateAssociatedContextAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAssociatedContextAMD(id: UInt32): wgl_context :=
    z_CreateAssociatedContextAMD_1(id);
    
    private z_CreateAssociatedContextAttribsAMD_adr := GetProcAddress('wglCreateAssociatedContextAttribsAMD');
    private z_CreateAssociatedContextAttribsAMD_1 := GetProcOrNil&<function(id: UInt32; hShareContext: wgl_context; attribList: IntPtr): wgl_context>(z_CreateAssociatedContextAttribsAMD_adr);
    private z_CreateAssociatedContextAttribsAMD_2 := GetProcOrNil&<function(id: UInt32; hShareContext: wgl_context; var attribList: Int32): wgl_context>(z_CreateAssociatedContextAttribsAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAssociatedContextAttribsAMD(id: UInt32; hShareContext: wgl_context; attribList: array of Int32): wgl_context;
    type PInt32=^Int32;
    begin
      Result := if (attribList<>nil) and (attribList.Length<>0) then
        z_CreateAssociatedContextAttribsAMD_2(id, hShareContext, attribList[0]) else
        z_CreateAssociatedContextAttribsAMD_2(id, hShareContext, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAssociatedContextAttribsAMD(id: UInt32; hShareContext: wgl_context; var attribList: Int32): wgl_context :=
    z_CreateAssociatedContextAttribsAMD_2(id, hShareContext, attribList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAssociatedContextAttribsAMD(id: UInt32; hShareContext: wgl_context; attribList: IntPtr): wgl_context :=
    z_CreateAssociatedContextAttribsAMD_1(id, hShareContext, attribList);
    
    private z_DeleteAssociatedContextAMD_adr := GetProcAddress('wglDeleteAssociatedContextAMD');
    private z_DeleteAssociatedContextAMD_1 := GetProcOrNil&<function(hglrc: wgl_context): Bool>(z_DeleteAssociatedContextAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DeleteAssociatedContextAMD(hglrc: wgl_context): Bool :=
    z_DeleteAssociatedContextAMD_1(hglrc);
    
    private z_MakeAssociatedContextCurrentAMD_adr := GetProcAddress('wglMakeAssociatedContextCurrentAMD');
    private z_MakeAssociatedContextCurrentAMD_1 := GetProcOrNil&<function(hglrc: wgl_context): Bool>(z_MakeAssociatedContextCurrentAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MakeAssociatedContextCurrentAMD(hglrc: wgl_context): Bool :=
    z_MakeAssociatedContextCurrentAMD_1(hglrc);
    
    private z_GetCurrentAssociatedContextAMD_adr := GetProcAddress('wglGetCurrentAssociatedContextAMD');
    private z_GetCurrentAssociatedContextAMD_1 := GetProcOrNil&<function: wgl_context>(z_GetCurrentAssociatedContextAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCurrentAssociatedContextAMD: wgl_context :=
    z_GetCurrentAssociatedContextAMD_1();
    
    private z_BlitContextFramebufferAMD_adr := GetProcAddress('wglBlitContextFramebufferAMD');
    private z_BlitContextFramebufferAMD_1 := GetProcOrNil&<procedure(dstCtx: wgl_context; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: DummyFlags; filter: DummyEnum)>(z_BlitContextFramebufferAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlitContextFramebufferAMD(dstCtx: wgl_context; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: DummyFlags; filter: DummyEnum) :=
    z_BlitContextFramebufferAMD_1(dstCtx, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  wglBufferRegionARB = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'wgl_arb_buffer_region';
    
    private z_CreateBufferRegionARB_adr := GetProcAddress('wglCreateBufferRegionARB');
    private z_CreateBufferRegionARB_1 := GetProcOrNil&<function(hDC: gdi_device_context; iLayerPlane: Int32; uType: UInt32): IntPtr>(z_CreateBufferRegionARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateBufferRegionARB(hDC: gdi_device_context; iLayerPlane: Int32; uType: UInt32): IntPtr :=
    z_CreateBufferRegionARB_1(hDC, iLayerPlane, uType);
    
    private z_DeleteBufferRegionARB_adr := GetProcAddress('wglDeleteBufferRegionARB');
    private z_DeleteBufferRegionARB_1 := GetProcOrNil&<procedure(hRegion: IntPtr)>(z_DeleteBufferRegionARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteBufferRegionARB(hRegion: IntPtr) :=
    z_DeleteBufferRegionARB_1(hRegion);
    
    private z_SaveBufferRegionARB_adr := GetProcAddress('wglSaveBufferRegionARB');
    private z_SaveBufferRegionARB_1 := GetProcOrNil&<function(hRegion: IntPtr; x: Int32; y: Int32; width: Int32; height: Int32): Bool>(z_SaveBufferRegionARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SaveBufferRegionARB(hRegion: IntPtr; x: Int32; y: Int32; width: Int32; height: Int32): Bool :=
    z_SaveBufferRegionARB_1(hRegion, x, y, width, height);
    
    private z_RestoreBufferRegionARB_adr := GetProcAddress('wglRestoreBufferRegionARB');
    private z_RestoreBufferRegionARB_1 := GetProcOrNil&<function(hRegion: IntPtr; x: Int32; y: Int32; width: Int32; height: Int32; xSrc: Int32; ySrc: Int32): Bool>(z_RestoreBufferRegionARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function RestoreBufferRegionARB(hRegion: IntPtr; x: Int32; y: Int32; width: Int32; height: Int32; xSrc: Int32; ySrc: Int32): Bool :=
    z_RestoreBufferRegionARB_1(hRegion, x, y, width, height, xSrc, ySrc);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  wglCreateContextARB = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'wgl_arb_create_context';
    
    private z_CreateContextAttribsARB_adr := GetProcAddress('wglCreateContextAttribsARB');
    private z_CreateContextAttribsARB_1 := GetProcOrNil&<function(hDC: gdi_device_context; hShareContext: wgl_context; attribList: IntPtr): wgl_context>(z_CreateContextAttribsARB_adr);
    private z_CreateContextAttribsARB_2 := GetProcOrNil&<function(hDC: gdi_device_context; hShareContext: wgl_context; var attribList: Int32): wgl_context>(z_CreateContextAttribsARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateContextAttribsARB(hDC: gdi_device_context; hShareContext: wgl_context; attribList: array of Int32): wgl_context;
    type PInt32=^Int32;
    begin
      Result := if (attribList<>nil) and (attribList.Length<>0) then
        z_CreateContextAttribsARB_2(hDC, hShareContext, attribList[0]) else
        z_CreateContextAttribsARB_2(hDC, hShareContext, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateContextAttribsARB(hDC: gdi_device_context; hShareContext: wgl_context; var attribList: Int32): wgl_context :=
    z_CreateContextAttribsARB_2(hDC, hShareContext, attribList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateContextAttribsARB(hDC: gdi_device_context; hShareContext: wgl_context; attribList: IntPtr): wgl_context :=
    z_CreateContextAttribsARB_1(hDC, hShareContext, attribList);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  wglExtensionsStringARB = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'wgl_arb_extensions_string';
    
    private z_GetExtensionsStringARB_adr := GetProcAddress('wglGetExtensionsStringARB');
    private z_GetExtensionsStringARB_1 := GetProcOrNil&<function(hdc: gdi_device_context): IntPtr>(z_GetExtensionsStringARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetExtensionsStringARB(hdc: gdi_device_context): string;
    begin
      var Result_str_ptr: IntPtr;
      Result_str_ptr := z_GetExtensionsStringARB_1(hdc);
      Result := Marshal.PtrToStringAnsi(Result_str_ptr);
    end;
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  wglMakeCurrentReadARB = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'wgl_arb_make_current_read';
    
    private z_MakeContextCurrentARB_adr := GetProcAddress('wglMakeContextCurrentARB');
    private z_MakeContextCurrentARB_1 := GetProcOrNil&<function(hDrawDC: gdi_device_context; hReadDC: gdi_device_context; hglrc: wgl_context): Bool>(z_MakeContextCurrentARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MakeContextCurrentARB(hDrawDC: gdi_device_context; hReadDC: gdi_device_context; hglrc: wgl_context): Bool :=
    z_MakeContextCurrentARB_1(hDrawDC, hReadDC, hglrc);
    
    private z_GetCurrentReadDCARB_adr := GetProcAddress('wglGetCurrentReadDCARB');
    private z_GetCurrentReadDCARB_1 := GetProcOrNil&<function: gdi_device_context>(z_GetCurrentReadDCARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCurrentReadDCARB: gdi_device_context :=
    z_GetCurrentReadDCARB_1();
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  wglPbufferARB = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'wgl_arb_pbuffer';
    
    private z_CreatePbufferARB_adr := GetProcAddress('wglCreatePbufferARB');
    private z_CreatePbufferARB_1 := GetProcOrNil&<function(hDC: gdi_device_context; iPixelFormat: Int32; iWidth: Int32; iHeight: Int32; piAttribList: IntPtr): wgl_pbuffer_ARB>(z_CreatePbufferARB_adr);
    private z_CreatePbufferARB_2 := GetProcOrNil&<function(hDC: gdi_device_context; iPixelFormat: Int32; iWidth: Int32; iHeight: Int32; var piAttribList: Int32): wgl_pbuffer_ARB>(z_CreatePbufferARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreatePbufferARB(hDC: gdi_device_context; iPixelFormat: Int32; iWidth: Int32; iHeight: Int32; piAttribList: array of Int32): wgl_pbuffer_ARB;
    type PInt32=^Int32;
    begin
      Result := if (piAttribList<>nil) and (piAttribList.Length<>0) then
        z_CreatePbufferARB_2(hDC, iPixelFormat, iWidth, iHeight, piAttribList[0]) else
        z_CreatePbufferARB_2(hDC, iPixelFormat, iWidth, iHeight, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreatePbufferARB(hDC: gdi_device_context; iPixelFormat: Int32; iWidth: Int32; iHeight: Int32; var piAttribList: Int32): wgl_pbuffer_ARB :=
    z_CreatePbufferARB_2(hDC, iPixelFormat, iWidth, iHeight, piAttribList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreatePbufferARB(hDC: gdi_device_context; iPixelFormat: Int32; iWidth: Int32; iHeight: Int32; piAttribList: IntPtr): wgl_pbuffer_ARB :=
    z_CreatePbufferARB_1(hDC, iPixelFormat, iWidth, iHeight, piAttribList);
    
    private z_GetPbufferDCARB_adr := GetProcAddress('wglGetPbufferDCARB');
    private z_GetPbufferDCARB_1 := GetProcOrNil&<function(hPbuffer: wgl_pbuffer_ARB): gdi_device_context>(z_GetPbufferDCARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPbufferDCARB(hPbuffer: wgl_pbuffer_ARB): gdi_device_context :=
    z_GetPbufferDCARB_1(hPbuffer);
    
    private z_ReleasePbufferDCARB_adr := GetProcAddress('wglReleasePbufferDCARB');
    private z_ReleasePbufferDCARB_1 := GetProcOrNil&<function(hPbuffer: wgl_pbuffer_ARB; hDC: gdi_device_context): Int32>(z_ReleasePbufferDCARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleasePbufferDCARB(hPbuffer: wgl_pbuffer_ARB; hDC: gdi_device_context): Int32 :=
    z_ReleasePbufferDCARB_1(hPbuffer, hDC);
    
    private z_DestroyPbufferARB_adr := GetProcAddress('wglDestroyPbufferARB');
    private z_DestroyPbufferARB_1 := GetProcOrNil&<function(hPbuffer: wgl_pbuffer_ARB): Bool>(z_DestroyPbufferARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DestroyPbufferARB(hPbuffer: wgl_pbuffer_ARB): Bool :=
    z_DestroyPbufferARB_1(hPbuffer);
    
    private z_QueryPbufferARB_adr := GetProcAddress('wglQueryPbufferARB');
    private z_QueryPbufferARB_1 := GetProcOrNil&<function(hPbuffer: wgl_pbuffer_ARB; iAttribute: Int32; piValue: IntPtr): Bool>(z_QueryPbufferARB_adr);
    private z_QueryPbufferARB_2 := GetProcOrNil&<function(hPbuffer: wgl_pbuffer_ARB; iAttribute: Int32; var piValue: Int32): Bool>(z_QueryPbufferARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryPbufferARB(hPbuffer: wgl_pbuffer_ARB; iAttribute: Int32; piValue: array of Int32): Bool;
    type PInt32=^Int32;
    begin
      Result := if (piValue<>nil) and (piValue.Length<>0) then
        z_QueryPbufferARB_2(hPbuffer, iAttribute, piValue[0]) else
        z_QueryPbufferARB_2(hPbuffer, iAttribute, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryPbufferARB(hPbuffer: wgl_pbuffer_ARB; iAttribute: Int32; var piValue: Int32): Bool :=
    z_QueryPbufferARB_2(hPbuffer, iAttribute, piValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryPbufferARB(hPbuffer: wgl_pbuffer_ARB; iAttribute: Int32; piValue: IntPtr): Bool :=
    z_QueryPbufferARB_1(hPbuffer, iAttribute, piValue);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  wglPixelFormatARB = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'wgl_arb_pixel_format';
    
    private z_GetPixelFormatAttribivARB_adr := GetProcAddress('wglGetPixelFormatAttribivARB');
    private z_GetPixelFormatAttribivARB_1 := GetProcOrNil&<function(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: IntPtr; piValues: IntPtr): Bool>(z_GetPixelFormatAttribivARB_adr);
    private z_GetPixelFormatAttribivARB_2 := GetProcOrNil&<function(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: IntPtr; var piValues: Int32): Bool>(z_GetPixelFormatAttribivARB_adr);
    private z_GetPixelFormatAttribivARB_3 := GetProcOrNil&<function(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: Int32; piValues: IntPtr): Bool>(z_GetPixelFormatAttribivARB_adr);
    private z_GetPixelFormatAttribivARB_4 := GetProcOrNil&<function(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: Int32; var piValues: Int32): Bool>(z_GetPixelFormatAttribivARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivARB(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: array of Int32; var piValues: Int32): Bool;
    type PInt32=^Int32;
    begin
      Result := if (piAttributes<>nil) and (piAttributes.Length<>0) then
        z_GetPixelFormatAttribivARB_4(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes[0], piValues) else
        z_GetPixelFormatAttribivARB_4(hdc, iPixelFormat, iLayerPlane, nAttributes, PInt32(nil)^, piValues);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivARB(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: array of Int32; piValues: IntPtr): Bool;
    type PInt32=^Int32;
    begin
      Result := if (piAttributes<>nil) and (piAttributes.Length<>0) then
        z_GetPixelFormatAttribivARB_3(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes[0], piValues) else
        z_GetPixelFormatAttribivARB_3(hdc, iPixelFormat, iLayerPlane, nAttributes, PInt32(nil)^, piValues);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivARB(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: Int32; var piValues: Int32): Bool :=
    z_GetPixelFormatAttribivARB_4(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivARB(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: Int32; piValues: IntPtr): Bool :=
    z_GetPixelFormatAttribivARB_3(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivARB(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: IntPtr; var piValues: Int32): Bool :=
    z_GetPixelFormatAttribivARB_2(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivARB(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: IntPtr; piValues: IntPtr): Bool :=
    z_GetPixelFormatAttribivARB_1(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues);
    
    private z_GetPixelFormatAttribfvARB_adr := GetProcAddress('wglGetPixelFormatAttribfvARB');
    private z_GetPixelFormatAttribfvARB_1 := GetProcOrNil&<function(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: IntPtr; pfValues: IntPtr): Bool>(z_GetPixelFormatAttribfvARB_adr);
    private z_GetPixelFormatAttribfvARB_2 := GetProcOrNil&<function(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: IntPtr; var pfValues: single): Bool>(z_GetPixelFormatAttribfvARB_adr);
    private z_GetPixelFormatAttribfvARB_3 := GetProcOrNil&<function(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: Int32; pfValues: IntPtr): Bool>(z_GetPixelFormatAttribfvARB_adr);
    private z_GetPixelFormatAttribfvARB_4 := GetProcOrNil&<function(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: Int32; var pfValues: single): Bool>(z_GetPixelFormatAttribfvARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvARB(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: array of Int32; var pfValues: single): Bool;
    type PInt32=^Int32;
    begin
      Result := if (piAttributes<>nil) and (piAttributes.Length<>0) then
        z_GetPixelFormatAttribfvARB_4(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes[0], pfValues) else
        z_GetPixelFormatAttribfvARB_4(hdc, iPixelFormat, iLayerPlane, nAttributes, PInt32(nil)^, pfValues);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvARB(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: array of Int32; pfValues: IntPtr): Bool;
    type PInt32=^Int32;
    begin
      Result := if (piAttributes<>nil) and (piAttributes.Length<>0) then
        z_GetPixelFormatAttribfvARB_3(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes[0], pfValues) else
        z_GetPixelFormatAttribfvARB_3(hdc, iPixelFormat, iLayerPlane, nAttributes, PInt32(nil)^, pfValues);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvARB(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: Int32; var pfValues: single): Bool :=
    z_GetPixelFormatAttribfvARB_4(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvARB(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: Int32; pfValues: IntPtr): Bool :=
    z_GetPixelFormatAttribfvARB_3(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvARB(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: IntPtr; var pfValues: single): Bool :=
    z_GetPixelFormatAttribfvARB_2(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvARB(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: IntPtr; pfValues: IntPtr): Bool :=
    z_GetPixelFormatAttribfvARB_1(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues);
    
    private z_ChoosePixelFormatARB_adr := GetProcAddress('wglChoosePixelFormatARB');
    private z_ChoosePixelFormatARB_1 := GetProcOrNil&<function(hdc: gdi_device_context; piAttribIList: IntPtr; pfAttribFList: IntPtr; nMaxFormats: UInt32; piFormats: IntPtr; nNumFormats: IntPtr): Bool>(z_ChoosePixelFormatARB_adr);
    private z_ChoosePixelFormatARB_2 := GetProcOrNil&<function(hdc: gdi_device_context; piAttribIList: IntPtr; pfAttribFList: IntPtr; nMaxFormats: UInt32; piFormats: IntPtr; var nNumFormats: UInt32): Bool>(z_ChoosePixelFormatARB_adr);
    private z_ChoosePixelFormatARB_3 := GetProcOrNil&<function(hdc: gdi_device_context; piAttribIList: IntPtr; pfAttribFList: IntPtr; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: IntPtr): Bool>(z_ChoosePixelFormatARB_adr);
    private z_ChoosePixelFormatARB_4 := GetProcOrNil&<function(hdc: gdi_device_context; piAttribIList: IntPtr; pfAttribFList: IntPtr; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): Bool>(z_ChoosePixelFormatARB_adr);
    private z_ChoosePixelFormatARB_5 := GetProcOrNil&<function(hdc: gdi_device_context; piAttribIList: IntPtr; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: IntPtr; nNumFormats: IntPtr): Bool>(z_ChoosePixelFormatARB_adr);
    private z_ChoosePixelFormatARB_6 := GetProcOrNil&<function(hdc: gdi_device_context; piAttribIList: IntPtr; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: IntPtr; var nNumFormats: UInt32): Bool>(z_ChoosePixelFormatARB_adr);
    private z_ChoosePixelFormatARB_7 := GetProcOrNil&<function(hdc: gdi_device_context; piAttribIList: IntPtr; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: IntPtr): Bool>(z_ChoosePixelFormatARB_adr);
    private z_ChoosePixelFormatARB_8 := GetProcOrNil&<function(hdc: gdi_device_context; piAttribIList: IntPtr; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): Bool>(z_ChoosePixelFormatARB_adr);
    private z_ChoosePixelFormatARB_9 := GetProcOrNil&<function(hdc: gdi_device_context; var piAttribIList: Int32; pfAttribFList: IntPtr; nMaxFormats: UInt32; piFormats: IntPtr; nNumFormats: IntPtr): Bool>(z_ChoosePixelFormatARB_adr);
    private z_ChoosePixelFormatARB_10 := GetProcOrNil&<function(hdc: gdi_device_context; var piAttribIList: Int32; pfAttribFList: IntPtr; nMaxFormats: UInt32; piFormats: IntPtr; var nNumFormats: UInt32): Bool>(z_ChoosePixelFormatARB_adr);
    private z_ChoosePixelFormatARB_11 := GetProcOrNil&<function(hdc: gdi_device_context; var piAttribIList: Int32; pfAttribFList: IntPtr; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: IntPtr): Bool>(z_ChoosePixelFormatARB_adr);
    private z_ChoosePixelFormatARB_12 := GetProcOrNil&<function(hdc: gdi_device_context; var piAttribIList: Int32; pfAttribFList: IntPtr; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): Bool>(z_ChoosePixelFormatARB_adr);
    private z_ChoosePixelFormatARB_13 := GetProcOrNil&<function(hdc: gdi_device_context; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: IntPtr; nNumFormats: IntPtr): Bool>(z_ChoosePixelFormatARB_adr);
    private z_ChoosePixelFormatARB_14 := GetProcOrNil&<function(hdc: gdi_device_context; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: IntPtr; var nNumFormats: UInt32): Bool>(z_ChoosePixelFormatARB_adr);
    private z_ChoosePixelFormatARB_15 := GetProcOrNil&<function(hdc: gdi_device_context; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: IntPtr): Bool>(z_ChoosePixelFormatARB_adr);
    private z_ChoosePixelFormatARB_16 := GetProcOrNil&<function(hdc: gdi_device_context; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): Bool>(z_ChoosePixelFormatARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: gdi_device_context; piAttribIList: array of Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: array of UInt32): Bool;
    type PInt32=^Int32;
    type Psingle=^single;
    type PUInt32=^UInt32;
    begin
      Result := if (nNumFormats<>nil) and (nNumFormats.Length<>0) then
        if (piFormats<>nil) and (piFormats.Length<>0) then
          if (pfAttribFList<>nil) and (pfAttribFList.Length<>0) then
            if (piAttribIList<>nil) and (piAttribIList.Length<>0) then
              z_ChoosePixelFormatARB_16(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, piFormats[0], nNumFormats[0]) else
              z_ChoosePixelFormatARB_16(hdc, PInt32(nil)^, pfAttribFList[0], nMaxFormats, piFormats[0], nNumFormats[0]) else
            if (piAttribIList<>nil) and (piAttribIList.Length<>0) then
              z_ChoosePixelFormatARB_16(hdc, piAttribIList[0], Psingle(nil)^, nMaxFormats, piFormats[0], nNumFormats[0]) else
              z_ChoosePixelFormatARB_16(hdc, PInt32(nil)^, Psingle(nil)^, nMaxFormats, piFormats[0], nNumFormats[0]) else
          if (pfAttribFList<>nil) and (pfAttribFList.Length<>0) then
            if (piAttribIList<>nil) and (piAttribIList.Length<>0) then
              z_ChoosePixelFormatARB_16(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, PInt32(nil)^, nNumFormats[0]) else
              z_ChoosePixelFormatARB_16(hdc, PInt32(nil)^, pfAttribFList[0], nMaxFormats, PInt32(nil)^, nNumFormats[0]) else
            if (piAttribIList<>nil) and (piAttribIList.Length<>0) then
              z_ChoosePixelFormatARB_16(hdc, piAttribIList[0], Psingle(nil)^, nMaxFormats, PInt32(nil)^, nNumFormats[0]) else
              z_ChoosePixelFormatARB_16(hdc, PInt32(nil)^, Psingle(nil)^, nMaxFormats, PInt32(nil)^, nNumFormats[0]) else
        if (piFormats<>nil) and (piFormats.Length<>0) then
          if (pfAttribFList<>nil) and (pfAttribFList.Length<>0) then
            if (piAttribIList<>nil) and (piAttribIList.Length<>0) then
              z_ChoosePixelFormatARB_16(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, piFormats[0], PUInt32(nil)^) else
              z_ChoosePixelFormatARB_16(hdc, PInt32(nil)^, pfAttribFList[0], nMaxFormats, piFormats[0], PUInt32(nil)^) else
            if (piAttribIList<>nil) and (piAttribIList.Length<>0) then
              z_ChoosePixelFormatARB_16(hdc, piAttribIList[0], Psingle(nil)^, nMaxFormats, piFormats[0], PUInt32(nil)^) else
              z_ChoosePixelFormatARB_16(hdc, PInt32(nil)^, Psingle(nil)^, nMaxFormats, piFormats[0], PUInt32(nil)^) else
          if (pfAttribFList<>nil) and (pfAttribFList.Length<>0) then
            if (piAttribIList<>nil) and (piAttribIList.Length<>0) then
              z_ChoosePixelFormatARB_16(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, PInt32(nil)^, PUInt32(nil)^) else
              z_ChoosePixelFormatARB_16(hdc, PInt32(nil)^, pfAttribFList[0], nMaxFormats, PInt32(nil)^, PUInt32(nil)^) else
            if (piAttribIList<>nil) and (piAttribIList.Length<>0) then
              z_ChoosePixelFormatARB_16(hdc, piAttribIList[0], Psingle(nil)^, nMaxFormats, PInt32(nil)^, PUInt32(nil)^) else
              z_ChoosePixelFormatARB_16(hdc, PInt32(nil)^, Psingle(nil)^, nMaxFormats, PInt32(nil)^, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: gdi_device_context; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): Bool :=
    z_ChoosePixelFormatARB_16(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: gdi_device_context; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: IntPtr): Bool :=
    z_ChoosePixelFormatARB_15(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: gdi_device_context; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: IntPtr; var nNumFormats: UInt32): Bool :=
    z_ChoosePixelFormatARB_14(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: gdi_device_context; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: IntPtr; nNumFormats: IntPtr): Bool :=
    z_ChoosePixelFormatARB_13(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: gdi_device_context; var piAttribIList: Int32; pfAttribFList: IntPtr; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): Bool :=
    z_ChoosePixelFormatARB_12(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: gdi_device_context; var piAttribIList: Int32; pfAttribFList: IntPtr; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: IntPtr): Bool :=
    z_ChoosePixelFormatARB_11(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: gdi_device_context; var piAttribIList: Int32; pfAttribFList: IntPtr; nMaxFormats: UInt32; piFormats: IntPtr; var nNumFormats: UInt32): Bool :=
    z_ChoosePixelFormatARB_10(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: gdi_device_context; var piAttribIList: Int32; pfAttribFList: IntPtr; nMaxFormats: UInt32; piFormats: IntPtr; nNumFormats: IntPtr): Bool :=
    z_ChoosePixelFormatARB_9(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: gdi_device_context; piAttribIList: IntPtr; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): Bool :=
    z_ChoosePixelFormatARB_8(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: gdi_device_context; piAttribIList: IntPtr; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: IntPtr): Bool :=
    z_ChoosePixelFormatARB_7(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: gdi_device_context; piAttribIList: IntPtr; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: IntPtr; var nNumFormats: UInt32): Bool :=
    z_ChoosePixelFormatARB_6(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: gdi_device_context; piAttribIList: IntPtr; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: IntPtr; nNumFormats: IntPtr): Bool :=
    z_ChoosePixelFormatARB_5(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: gdi_device_context; piAttribIList: IntPtr; pfAttribFList: IntPtr; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): Bool :=
    z_ChoosePixelFormatARB_4(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: gdi_device_context; piAttribIList: IntPtr; pfAttribFList: IntPtr; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: IntPtr): Bool :=
    z_ChoosePixelFormatARB_3(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: gdi_device_context; piAttribIList: IntPtr; pfAttribFList: IntPtr; nMaxFormats: UInt32; piFormats: IntPtr; var nNumFormats: UInt32): Bool :=
    z_ChoosePixelFormatARB_2(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: gdi_device_context; piAttribIList: IntPtr; pfAttribFList: IntPtr; nMaxFormats: UInt32; piFormats: IntPtr; nNumFormats: IntPtr): Bool :=
    z_ChoosePixelFormatARB_1(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  wglRenderTextureARB = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'wgl_arb_render_texture';
    
    private z_BindTexImageARB_adr := GetProcAddress('wglBindTexImageARB');
    private z_BindTexImageARB_1 := GetProcOrNil&<function(hPbuffer: wgl_pbuffer_ARB; iBuffer: Int32): Bool>(z_BindTexImageARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindTexImageARB(hPbuffer: wgl_pbuffer_ARB; iBuffer: Int32): Bool :=
    z_BindTexImageARB_1(hPbuffer, iBuffer);
    
    private z_ReleaseTexImageARB_adr := GetProcAddress('wglReleaseTexImageARB');
    private z_ReleaseTexImageARB_1 := GetProcOrNil&<function(hPbuffer: wgl_pbuffer_ARB; iBuffer: Int32): Bool>(z_ReleaseTexImageARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseTexImageARB(hPbuffer: wgl_pbuffer_ARB; iBuffer: Int32): Bool :=
    z_ReleaseTexImageARB_1(hPbuffer, iBuffer);
    
    private z_SetPbufferAttribARB_adr := GetProcAddress('wglSetPbufferAttribARB');
    private z_SetPbufferAttribARB_1 := GetProcOrNil&<function(hPbuffer: wgl_pbuffer_ARB; piAttribList: IntPtr): Bool>(z_SetPbufferAttribARB_adr);
    private z_SetPbufferAttribARB_2 := GetProcOrNil&<function(hPbuffer: wgl_pbuffer_ARB; var piAttribList: Int32): Bool>(z_SetPbufferAttribARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetPbufferAttribARB(hPbuffer: wgl_pbuffer_ARB; piAttribList: array of Int32): Bool;
    type PInt32=^Int32;
    begin
      Result := if (piAttribList<>nil) and (piAttribList.Length<>0) then
        z_SetPbufferAttribARB_2(hPbuffer, piAttribList[0]) else
        z_SetPbufferAttribARB_2(hPbuffer, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetPbufferAttribARB(hPbuffer: wgl_pbuffer_ARB; var piAttribList: Int32): Bool :=
    z_SetPbufferAttribARB_2(hPbuffer, piAttribList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetPbufferAttribARB(hPbuffer: wgl_pbuffer_ARB; piAttribList: IntPtr): Bool :=
    z_SetPbufferAttribARB_1(hPbuffer, piAttribList);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  wglDisplayColorTableEXT = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'wgl_ext_display_color_table';
    
    private z_CreateDisplayColorTableEXT_adr := GetProcAddress('wglCreateDisplayColorTableEXT');
    private z_CreateDisplayColorTableEXT_1 := GetProcOrNil&<function(id: UInt16): boolean>(z_CreateDisplayColorTableEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateDisplayColorTableEXT(id: UInt16): boolean :=
    z_CreateDisplayColorTableEXT_1(id);
    
    private z_LoadDisplayColorTableEXT_adr := GetProcAddress('wglLoadDisplayColorTableEXT');
    private z_LoadDisplayColorTableEXT_1 := GetProcOrNil&<function(table: IntPtr; length: UInt32): boolean>(z_LoadDisplayColorTableEXT_adr);
    private z_LoadDisplayColorTableEXT_2 := GetProcOrNil&<function(var table: UInt16; length: UInt32): boolean>(z_LoadDisplayColorTableEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function LoadDisplayColorTableEXT(table: array of UInt16; length: UInt32): boolean;
    type PUInt16=^UInt16;
    begin
      Result := if (table<>nil) and (table.Length<>0) then
        z_LoadDisplayColorTableEXT_2(table[0], length) else
        z_LoadDisplayColorTableEXT_2(PUInt16(nil)^, length);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function LoadDisplayColorTableEXT(var table: UInt16; length: UInt32): boolean :=
    z_LoadDisplayColorTableEXT_2(table, length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function LoadDisplayColorTableEXT(table: IntPtr; length: UInt32): boolean :=
    z_LoadDisplayColorTableEXT_1(table, length);
    
    private z_BindDisplayColorTableEXT_adr := GetProcAddress('wglBindDisplayColorTableEXT');
    private z_BindDisplayColorTableEXT_1 := GetProcOrNil&<function(id: UInt16): boolean>(z_BindDisplayColorTableEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindDisplayColorTableEXT(id: UInt16): boolean :=
    z_BindDisplayColorTableEXT_1(id);
    
    private z_DestroyDisplayColorTableEXT_adr := GetProcAddress('wglDestroyDisplayColorTableEXT');
    private z_DestroyDisplayColorTableEXT_1 := GetProcOrNil&<procedure(id: UInt16)>(z_DestroyDisplayColorTableEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DestroyDisplayColorTableEXT(id: UInt16) :=
    z_DestroyDisplayColorTableEXT_1(id);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  wglExtensionsStringEXT = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'wgl_ext_extensions_string';
    
    private z_GetExtensionsStringEXT_adr := GetProcAddress('wglGetExtensionsStringEXT');
    private z_GetExtensionsStringEXT_1 := GetProcOrNil&<function: IntPtr>(z_GetExtensionsStringEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetExtensionsStringEXT: string;
    begin
      var Result_str_ptr: IntPtr;
      Result_str_ptr := z_GetExtensionsStringEXT_1();
      Result := Marshal.PtrToStringAnsi(Result_str_ptr);
    end;
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  wglMakeCurrentReadEXT = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'wgl_ext_make_current_read';
    
    private z_MakeContextCurrentEXT_adr := GetProcAddress('wglMakeContextCurrentEXT');
    private z_MakeContextCurrentEXT_1 := GetProcOrNil&<function(hDrawDC: gdi_device_context; hReadDC: gdi_device_context; hglrc: wgl_context): Bool>(z_MakeContextCurrentEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MakeContextCurrentEXT(hDrawDC: gdi_device_context; hReadDC: gdi_device_context; hglrc: wgl_context): Bool :=
    z_MakeContextCurrentEXT_1(hDrawDC, hReadDC, hglrc);
    
    private z_GetCurrentReadDCEXT_adr := GetProcAddress('wglGetCurrentReadDCEXT');
    private z_GetCurrentReadDCEXT_1 := GetProcOrNil&<function: gdi_device_context>(z_GetCurrentReadDCEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCurrentReadDCEXT: gdi_device_context :=
    z_GetCurrentReadDCEXT_1();
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  wglPbufferEXT = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'wgl_ext_pbuffer';
    
    private z_CreatePbufferEXT_adr := GetProcAddress('wglCreatePbufferEXT');
    private z_CreatePbufferEXT_1 := GetProcOrNil&<function(hDC: gdi_device_context; iPixelFormat: Int32; iWidth: Int32; iHeight: Int32; piAttribList: IntPtr): wgl_pbuffer_EXT>(z_CreatePbufferEXT_adr);
    private z_CreatePbufferEXT_2 := GetProcOrNil&<function(hDC: gdi_device_context; iPixelFormat: Int32; iWidth: Int32; iHeight: Int32; var piAttribList: Int32): wgl_pbuffer_EXT>(z_CreatePbufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreatePbufferEXT(hDC: gdi_device_context; iPixelFormat: Int32; iWidth: Int32; iHeight: Int32; piAttribList: array of Int32): wgl_pbuffer_EXT;
    type PInt32=^Int32;
    begin
      Result := if (piAttribList<>nil) and (piAttribList.Length<>0) then
        z_CreatePbufferEXT_2(hDC, iPixelFormat, iWidth, iHeight, piAttribList[0]) else
        z_CreatePbufferEXT_2(hDC, iPixelFormat, iWidth, iHeight, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreatePbufferEXT(hDC: gdi_device_context; iPixelFormat: Int32; iWidth: Int32; iHeight: Int32; var piAttribList: Int32): wgl_pbuffer_EXT :=
    z_CreatePbufferEXT_2(hDC, iPixelFormat, iWidth, iHeight, piAttribList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreatePbufferEXT(hDC: gdi_device_context; iPixelFormat: Int32; iWidth: Int32; iHeight: Int32; piAttribList: IntPtr): wgl_pbuffer_EXT :=
    z_CreatePbufferEXT_1(hDC, iPixelFormat, iWidth, iHeight, piAttribList);
    
    private z_GetPbufferDCEXT_adr := GetProcAddress('wglGetPbufferDCEXT');
    private z_GetPbufferDCEXT_1 := GetProcOrNil&<function(hPbuffer: wgl_pbuffer_EXT): gdi_device_context>(z_GetPbufferDCEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPbufferDCEXT(hPbuffer: wgl_pbuffer_EXT): gdi_device_context :=
    z_GetPbufferDCEXT_1(hPbuffer);
    
    private z_ReleasePbufferDCEXT_adr := GetProcAddress('wglReleasePbufferDCEXT');
    private z_ReleasePbufferDCEXT_1 := GetProcOrNil&<function(hPbuffer: wgl_pbuffer_EXT; hDC: gdi_device_context): Int32>(z_ReleasePbufferDCEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleasePbufferDCEXT(hPbuffer: wgl_pbuffer_EXT; hDC: gdi_device_context): Int32 :=
    z_ReleasePbufferDCEXT_1(hPbuffer, hDC);
    
    private z_DestroyPbufferEXT_adr := GetProcAddress('wglDestroyPbufferEXT');
    private z_DestroyPbufferEXT_1 := GetProcOrNil&<function(hPbuffer: wgl_pbuffer_EXT): Bool>(z_DestroyPbufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DestroyPbufferEXT(hPbuffer: wgl_pbuffer_EXT): Bool :=
    z_DestroyPbufferEXT_1(hPbuffer);
    
    private z_QueryPbufferEXT_adr := GetProcAddress('wglQueryPbufferEXT');
    private z_QueryPbufferEXT_1 := GetProcOrNil&<function(hPbuffer: wgl_pbuffer_EXT; iAttribute: Int32; piValue: IntPtr): Bool>(z_QueryPbufferEXT_adr);
    private z_QueryPbufferEXT_2 := GetProcOrNil&<function(hPbuffer: wgl_pbuffer_EXT; iAttribute: Int32; var piValue: Int32): Bool>(z_QueryPbufferEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryPbufferEXT(hPbuffer: wgl_pbuffer_EXT; iAttribute: Int32; piValue: array of Int32): Bool;
    type PInt32=^Int32;
    begin
      Result := if (piValue<>nil) and (piValue.Length<>0) then
        z_QueryPbufferEXT_2(hPbuffer, iAttribute, piValue[0]) else
        z_QueryPbufferEXT_2(hPbuffer, iAttribute, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryPbufferEXT(hPbuffer: wgl_pbuffer_EXT; iAttribute: Int32; var piValue: Int32): Bool :=
    z_QueryPbufferEXT_2(hPbuffer, iAttribute, piValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryPbufferEXT(hPbuffer: wgl_pbuffer_EXT; iAttribute: Int32; piValue: IntPtr): Bool :=
    z_QueryPbufferEXT_1(hPbuffer, iAttribute, piValue);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  wglPixelFormatEXT = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'wgl_ext_pixel_format';
    
    private z_GetPixelFormatAttribivEXT_adr := GetProcAddress('wglGetPixelFormatAttribivEXT');
    private z_GetPixelFormatAttribivEXT_1 := GetProcOrNil&<function(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: IntPtr; piValues: IntPtr): Bool>(z_GetPixelFormatAttribivEXT_adr);
    private z_GetPixelFormatAttribivEXT_2 := GetProcOrNil&<function(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: IntPtr; var piValues: Int32): Bool>(z_GetPixelFormatAttribivEXT_adr);
    private z_GetPixelFormatAttribivEXT_3 := GetProcOrNil&<function(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: Int32; piValues: IntPtr): Bool>(z_GetPixelFormatAttribivEXT_adr);
    private z_GetPixelFormatAttribivEXT_4 := GetProcOrNil&<function(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: Int32; var piValues: Int32): Bool>(z_GetPixelFormatAttribivEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivEXT(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: Int32; var piValues: Int32): Bool :=
    z_GetPixelFormatAttribivEXT_4(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivEXT(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: Int32; piValues: IntPtr): Bool :=
    z_GetPixelFormatAttribivEXT_3(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivEXT(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: IntPtr; var piValues: Int32): Bool :=
    z_GetPixelFormatAttribivEXT_2(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivEXT(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: IntPtr; piValues: IntPtr): Bool :=
    z_GetPixelFormatAttribivEXT_1(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues);
    
    private z_GetPixelFormatAttribfvEXT_adr := GetProcAddress('wglGetPixelFormatAttribfvEXT');
    private z_GetPixelFormatAttribfvEXT_1 := GetProcOrNil&<function(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: IntPtr; pfValues: IntPtr): Bool>(z_GetPixelFormatAttribfvEXT_adr);
    private z_GetPixelFormatAttribfvEXT_2 := GetProcOrNil&<function(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: IntPtr; var pfValues: single): Bool>(z_GetPixelFormatAttribfvEXT_adr);
    private z_GetPixelFormatAttribfvEXT_3 := GetProcOrNil&<function(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: Int32; pfValues: IntPtr): Bool>(z_GetPixelFormatAttribfvEXT_adr);
    private z_GetPixelFormatAttribfvEXT_4 := GetProcOrNil&<function(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: Int32; var pfValues: single): Bool>(z_GetPixelFormatAttribfvEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvEXT(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: Int32; var pfValues: single): Bool :=
    z_GetPixelFormatAttribfvEXT_4(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvEXT(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: Int32; pfValues: IntPtr): Bool :=
    z_GetPixelFormatAttribfvEXT_3(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvEXT(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: IntPtr; var pfValues: single): Bool :=
    z_GetPixelFormatAttribfvEXT_2(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvEXT(hdc: gdi_device_context; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: IntPtr; pfValues: IntPtr): Bool :=
    z_GetPixelFormatAttribfvEXT_1(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues);
    
    private z_ChoosePixelFormatEXT_adr := GetProcAddress('wglChoosePixelFormatEXT');
    private z_ChoosePixelFormatEXT_1 := GetProcOrNil&<function(hdc: gdi_device_context; piAttribIList: IntPtr; pfAttribFList: IntPtr; nMaxFormats: UInt32; piFormats: IntPtr; nNumFormats: IntPtr): Bool>(z_ChoosePixelFormatEXT_adr);
    private z_ChoosePixelFormatEXT_2 := GetProcOrNil&<function(hdc: gdi_device_context; piAttribIList: IntPtr; pfAttribFList: IntPtr; nMaxFormats: UInt32; piFormats: IntPtr; var nNumFormats: UInt32): Bool>(z_ChoosePixelFormatEXT_adr);
    private z_ChoosePixelFormatEXT_3 := GetProcOrNil&<function(hdc: gdi_device_context; piAttribIList: IntPtr; pfAttribFList: IntPtr; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: IntPtr): Bool>(z_ChoosePixelFormatEXT_adr);
    private z_ChoosePixelFormatEXT_4 := GetProcOrNil&<function(hdc: gdi_device_context; piAttribIList: IntPtr; pfAttribFList: IntPtr; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): Bool>(z_ChoosePixelFormatEXT_adr);
    private z_ChoosePixelFormatEXT_5 := GetProcOrNil&<function(hdc: gdi_device_context; piAttribIList: IntPtr; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: IntPtr; nNumFormats: IntPtr): Bool>(z_ChoosePixelFormatEXT_adr);
    private z_ChoosePixelFormatEXT_6 := GetProcOrNil&<function(hdc: gdi_device_context; piAttribIList: IntPtr; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: IntPtr; var nNumFormats: UInt32): Bool>(z_ChoosePixelFormatEXT_adr);
    private z_ChoosePixelFormatEXT_7 := GetProcOrNil&<function(hdc: gdi_device_context; piAttribIList: IntPtr; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: IntPtr): Bool>(z_ChoosePixelFormatEXT_adr);
    private z_ChoosePixelFormatEXT_8 := GetProcOrNil&<function(hdc: gdi_device_context; piAttribIList: IntPtr; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): Bool>(z_ChoosePixelFormatEXT_adr);
    private z_ChoosePixelFormatEXT_9 := GetProcOrNil&<function(hdc: gdi_device_context; var piAttribIList: Int32; pfAttribFList: IntPtr; nMaxFormats: UInt32; piFormats: IntPtr; nNumFormats: IntPtr): Bool>(z_ChoosePixelFormatEXT_adr);
    private z_ChoosePixelFormatEXT_10 := GetProcOrNil&<function(hdc: gdi_device_context; var piAttribIList: Int32; pfAttribFList: IntPtr; nMaxFormats: UInt32; piFormats: IntPtr; var nNumFormats: UInt32): Bool>(z_ChoosePixelFormatEXT_adr);
    private z_ChoosePixelFormatEXT_11 := GetProcOrNil&<function(hdc: gdi_device_context; var piAttribIList: Int32; pfAttribFList: IntPtr; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: IntPtr): Bool>(z_ChoosePixelFormatEXT_adr);
    private z_ChoosePixelFormatEXT_12 := GetProcOrNil&<function(hdc: gdi_device_context; var piAttribIList: Int32; pfAttribFList: IntPtr; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): Bool>(z_ChoosePixelFormatEXT_adr);
    private z_ChoosePixelFormatEXT_13 := GetProcOrNil&<function(hdc: gdi_device_context; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: IntPtr; nNumFormats: IntPtr): Bool>(z_ChoosePixelFormatEXT_adr);
    private z_ChoosePixelFormatEXT_14 := GetProcOrNil&<function(hdc: gdi_device_context; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: IntPtr; var nNumFormats: UInt32): Bool>(z_ChoosePixelFormatEXT_adr);
    private z_ChoosePixelFormatEXT_15 := GetProcOrNil&<function(hdc: gdi_device_context; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: IntPtr): Bool>(z_ChoosePixelFormatEXT_adr);
    private z_ChoosePixelFormatEXT_16 := GetProcOrNil&<function(hdc: gdi_device_context; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): Bool>(z_ChoosePixelFormatEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: gdi_device_context; piAttribIList: array of Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: array of UInt32): Bool;
    type PInt32=^Int32;
    type Psingle=^single;
    type PUInt32=^UInt32;
    begin
      Result := if (nNumFormats<>nil) and (nNumFormats.Length<>0) then
        if (piFormats<>nil) and (piFormats.Length<>0) then
          if (pfAttribFList<>nil) and (pfAttribFList.Length<>0) then
            if (piAttribIList<>nil) and (piAttribIList.Length<>0) then
              z_ChoosePixelFormatEXT_16(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, piFormats[0], nNumFormats[0]) else
              z_ChoosePixelFormatEXT_16(hdc, PInt32(nil)^, pfAttribFList[0], nMaxFormats, piFormats[0], nNumFormats[0]) else
            if (piAttribIList<>nil) and (piAttribIList.Length<>0) then
              z_ChoosePixelFormatEXT_16(hdc, piAttribIList[0], Psingle(nil)^, nMaxFormats, piFormats[0], nNumFormats[0]) else
              z_ChoosePixelFormatEXT_16(hdc, PInt32(nil)^, Psingle(nil)^, nMaxFormats, piFormats[0], nNumFormats[0]) else
          if (pfAttribFList<>nil) and (pfAttribFList.Length<>0) then
            if (piAttribIList<>nil) and (piAttribIList.Length<>0) then
              z_ChoosePixelFormatEXT_16(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, PInt32(nil)^, nNumFormats[0]) else
              z_ChoosePixelFormatEXT_16(hdc, PInt32(nil)^, pfAttribFList[0], nMaxFormats, PInt32(nil)^, nNumFormats[0]) else
            if (piAttribIList<>nil) and (piAttribIList.Length<>0) then
              z_ChoosePixelFormatEXT_16(hdc, piAttribIList[0], Psingle(nil)^, nMaxFormats, PInt32(nil)^, nNumFormats[0]) else
              z_ChoosePixelFormatEXT_16(hdc, PInt32(nil)^, Psingle(nil)^, nMaxFormats, PInt32(nil)^, nNumFormats[0]) else
        if (piFormats<>nil) and (piFormats.Length<>0) then
          if (pfAttribFList<>nil) and (pfAttribFList.Length<>0) then
            if (piAttribIList<>nil) and (piAttribIList.Length<>0) then
              z_ChoosePixelFormatEXT_16(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, piFormats[0], PUInt32(nil)^) else
              z_ChoosePixelFormatEXT_16(hdc, PInt32(nil)^, pfAttribFList[0], nMaxFormats, piFormats[0], PUInt32(nil)^) else
            if (piAttribIList<>nil) and (piAttribIList.Length<>0) then
              z_ChoosePixelFormatEXT_16(hdc, piAttribIList[0], Psingle(nil)^, nMaxFormats, piFormats[0], PUInt32(nil)^) else
              z_ChoosePixelFormatEXT_16(hdc, PInt32(nil)^, Psingle(nil)^, nMaxFormats, piFormats[0], PUInt32(nil)^) else
          if (pfAttribFList<>nil) and (pfAttribFList.Length<>0) then
            if (piAttribIList<>nil) and (piAttribIList.Length<>0) then
              z_ChoosePixelFormatEXT_16(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, PInt32(nil)^, PUInt32(nil)^) else
              z_ChoosePixelFormatEXT_16(hdc, PInt32(nil)^, pfAttribFList[0], nMaxFormats, PInt32(nil)^, PUInt32(nil)^) else
            if (piAttribIList<>nil) and (piAttribIList.Length<>0) then
              z_ChoosePixelFormatEXT_16(hdc, piAttribIList[0], Psingle(nil)^, nMaxFormats, PInt32(nil)^, PUInt32(nil)^) else
              z_ChoosePixelFormatEXT_16(hdc, PInt32(nil)^, Psingle(nil)^, nMaxFormats, PInt32(nil)^, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: gdi_device_context; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): Bool :=
    z_ChoosePixelFormatEXT_16(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: gdi_device_context; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: IntPtr): Bool :=
    z_ChoosePixelFormatEXT_15(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: gdi_device_context; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: IntPtr; var nNumFormats: UInt32): Bool :=
    z_ChoosePixelFormatEXT_14(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: gdi_device_context; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: IntPtr; nNumFormats: IntPtr): Bool :=
    z_ChoosePixelFormatEXT_13(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: gdi_device_context; var piAttribIList: Int32; pfAttribFList: IntPtr; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): Bool :=
    z_ChoosePixelFormatEXT_12(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: gdi_device_context; var piAttribIList: Int32; pfAttribFList: IntPtr; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: IntPtr): Bool :=
    z_ChoosePixelFormatEXT_11(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: gdi_device_context; var piAttribIList: Int32; pfAttribFList: IntPtr; nMaxFormats: UInt32; piFormats: IntPtr; var nNumFormats: UInt32): Bool :=
    z_ChoosePixelFormatEXT_10(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: gdi_device_context; var piAttribIList: Int32; pfAttribFList: IntPtr; nMaxFormats: UInt32; piFormats: IntPtr; nNumFormats: IntPtr): Bool :=
    z_ChoosePixelFormatEXT_9(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: gdi_device_context; piAttribIList: IntPtr; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): Bool :=
    z_ChoosePixelFormatEXT_8(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: gdi_device_context; piAttribIList: IntPtr; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: IntPtr): Bool :=
    z_ChoosePixelFormatEXT_7(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: gdi_device_context; piAttribIList: IntPtr; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: IntPtr; var nNumFormats: UInt32): Bool :=
    z_ChoosePixelFormatEXT_6(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: gdi_device_context; piAttribIList: IntPtr; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: IntPtr; nNumFormats: IntPtr): Bool :=
    z_ChoosePixelFormatEXT_5(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: gdi_device_context; piAttribIList: IntPtr; pfAttribFList: IntPtr; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): Bool :=
    z_ChoosePixelFormatEXT_4(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: gdi_device_context; piAttribIList: IntPtr; pfAttribFList: IntPtr; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: IntPtr): Bool :=
    z_ChoosePixelFormatEXT_3(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: gdi_device_context; piAttribIList: IntPtr; pfAttribFList: IntPtr; nMaxFormats: UInt32; piFormats: IntPtr; var nNumFormats: UInt32): Bool :=
    z_ChoosePixelFormatEXT_2(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: gdi_device_context; piAttribIList: IntPtr; pfAttribFList: IntPtr; nMaxFormats: UInt32; piFormats: IntPtr; nNumFormats: IntPtr): Bool :=
    z_ChoosePixelFormatEXT_1(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  wglSwapControlEXT = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'wgl_ext_swap_control';
    
    private z_SwapIntervalEXT_adr := GetProcAddress('wglSwapIntervalEXT');
    private z_SwapIntervalEXT_1 := GetProcOrNil&<function(interval: Int32): Bool>(z_SwapIntervalEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SwapIntervalEXT(interval: Int32): Bool :=
    z_SwapIntervalEXT_1(interval);
    
    private z_GetSwapIntervalEXT_adr := GetProcAddress('wglGetSwapIntervalEXT');
    private z_GetSwapIntervalEXT_1 := GetProcOrNil&<function: Int32>(z_GetSwapIntervalEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSwapIntervalEXT: Int32 :=
    z_GetSwapIntervalEXT_1();
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  wglDigitalVideoControlI3D = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'wgl_i3d_digital_video_control';
    
    private z_GetDigitalVideoParametersI3D_adr := GetProcAddress('wglGetDigitalVideoParametersI3D');
    private z_GetDigitalVideoParametersI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; iAttribute: Int32; piValue: IntPtr): Bool>(z_GetDigitalVideoParametersI3D_adr);
    private z_GetDigitalVideoParametersI3D_2 := GetProcOrNil&<function(hDC: gdi_device_context; iAttribute: Int32; var piValue: Int32): Bool>(z_GetDigitalVideoParametersI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDigitalVideoParametersI3D(hDC: gdi_device_context; iAttribute: Int32; var piValue: Int32): Bool :=
    z_GetDigitalVideoParametersI3D_2(hDC, iAttribute, piValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDigitalVideoParametersI3D(hDC: gdi_device_context; iAttribute: Int32; piValue: IntPtr): Bool :=
    z_GetDigitalVideoParametersI3D_1(hDC, iAttribute, piValue);
    
    private z_SetDigitalVideoParametersI3D_adr := GetProcAddress('wglSetDigitalVideoParametersI3D');
    private z_SetDigitalVideoParametersI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; iAttribute: Int32; piValue: IntPtr): Bool>(z_SetDigitalVideoParametersI3D_adr);
    private z_SetDigitalVideoParametersI3D_2 := GetProcOrNil&<function(hDC: gdi_device_context; iAttribute: Int32; var piValue: Int32): Bool>(z_SetDigitalVideoParametersI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetDigitalVideoParametersI3D(hDC: gdi_device_context; iAttribute: Int32; piValue: array of Int32): Bool;
    type PInt32=^Int32;
    begin
      Result := if (piValue<>nil) and (piValue.Length<>0) then
        z_SetDigitalVideoParametersI3D_2(hDC, iAttribute, piValue[0]) else
        z_SetDigitalVideoParametersI3D_2(hDC, iAttribute, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetDigitalVideoParametersI3D(hDC: gdi_device_context; iAttribute: Int32; var piValue: Int32): Bool :=
    z_SetDigitalVideoParametersI3D_2(hDC, iAttribute, piValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetDigitalVideoParametersI3D(hDC: gdi_device_context; iAttribute: Int32; piValue: IntPtr): Bool :=
    z_SetDigitalVideoParametersI3D_1(hDC, iAttribute, piValue);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  wglGammaI3D = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'wgl_i3d_gamma';
    
    private z_GetGammaTableParametersI3D_adr := GetProcAddress('wglGetGammaTableParametersI3D');
    private z_GetGammaTableParametersI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; iAttribute: Int32; piValue: IntPtr): Bool>(z_GetGammaTableParametersI3D_adr);
    private z_GetGammaTableParametersI3D_2 := GetProcOrNil&<function(hDC: gdi_device_context; iAttribute: Int32; var piValue: Int32): Bool>(z_GetGammaTableParametersI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableParametersI3D(hDC: gdi_device_context; iAttribute: Int32; var piValue: Int32): Bool :=
    z_GetGammaTableParametersI3D_2(hDC, iAttribute, piValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableParametersI3D(hDC: gdi_device_context; iAttribute: Int32; piValue: IntPtr): Bool :=
    z_GetGammaTableParametersI3D_1(hDC, iAttribute, piValue);
    
    private z_SetGammaTableParametersI3D_adr := GetProcAddress('wglSetGammaTableParametersI3D');
    private z_SetGammaTableParametersI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; iAttribute: Int32; piValue: IntPtr): Bool>(z_SetGammaTableParametersI3D_adr);
    private z_SetGammaTableParametersI3D_2 := GetProcOrNil&<function(hDC: gdi_device_context; iAttribute: Int32; var piValue: Int32): Bool>(z_SetGammaTableParametersI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableParametersI3D(hDC: gdi_device_context; iAttribute: Int32; piValue: array of Int32): Bool;
    type PInt32=^Int32;
    begin
      Result := if (piValue<>nil) and (piValue.Length<>0) then
        z_SetGammaTableParametersI3D_2(hDC, iAttribute, piValue[0]) else
        z_SetGammaTableParametersI3D_2(hDC, iAttribute, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableParametersI3D(hDC: gdi_device_context; iAttribute: Int32; var piValue: Int32): Bool :=
    z_SetGammaTableParametersI3D_2(hDC, iAttribute, piValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableParametersI3D(hDC: gdi_device_context; iAttribute: Int32; piValue: IntPtr): Bool :=
    z_SetGammaTableParametersI3D_1(hDC, iAttribute, piValue);
    
    private z_GetGammaTableI3D_adr := GetProcAddress('wglGetGammaTableI3D');
    private z_GetGammaTableI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; iEntries: Int32; puRed: IntPtr; puGreen: IntPtr; puBlue: IntPtr): Bool>(z_GetGammaTableI3D_adr);
    private z_GetGammaTableI3D_2 := GetProcOrNil&<function(hDC: gdi_device_context; iEntries: Int32; puRed: IntPtr; puGreen: IntPtr; var puBlue: UInt16): Bool>(z_GetGammaTableI3D_adr);
    private z_GetGammaTableI3D_3 := GetProcOrNil&<function(hDC: gdi_device_context; iEntries: Int32; puRed: IntPtr; var puGreen: UInt16; puBlue: IntPtr): Bool>(z_GetGammaTableI3D_adr);
    private z_GetGammaTableI3D_4 := GetProcOrNil&<function(hDC: gdi_device_context; iEntries: Int32; puRed: IntPtr; var puGreen: UInt16; var puBlue: UInt16): Bool>(z_GetGammaTableI3D_adr);
    private z_GetGammaTableI3D_5 := GetProcOrNil&<function(hDC: gdi_device_context; iEntries: Int32; var puRed: UInt16; puGreen: IntPtr; puBlue: IntPtr): Bool>(z_GetGammaTableI3D_adr);
    private z_GetGammaTableI3D_6 := GetProcOrNil&<function(hDC: gdi_device_context; iEntries: Int32; var puRed: UInt16; puGreen: IntPtr; var puBlue: UInt16): Bool>(z_GetGammaTableI3D_adr);
    private z_GetGammaTableI3D_7 := GetProcOrNil&<function(hDC: gdi_device_context; iEntries: Int32; var puRed: UInt16; var puGreen: UInt16; puBlue: IntPtr): Bool>(z_GetGammaTableI3D_adr);
    private z_GetGammaTableI3D_8 := GetProcOrNil&<function(hDC: gdi_device_context; iEntries: Int32; var puRed: UInt16; var puGreen: UInt16; var puBlue: UInt16): Bool>(z_GetGammaTableI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: gdi_device_context; iEntries: Int32; var puRed: UInt16; var puGreen: UInt16; var puBlue: UInt16): Bool :=
    z_GetGammaTableI3D_8(hDC, iEntries, puRed, puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: gdi_device_context; iEntries: Int32; var puRed: UInt16; var puGreen: UInt16; puBlue: IntPtr): Bool :=
    z_GetGammaTableI3D_7(hDC, iEntries, puRed, puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: gdi_device_context; iEntries: Int32; var puRed: UInt16; puGreen: IntPtr; var puBlue: UInt16): Bool :=
    z_GetGammaTableI3D_6(hDC, iEntries, puRed, puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: gdi_device_context; iEntries: Int32; var puRed: UInt16; puGreen: IntPtr; puBlue: IntPtr): Bool :=
    z_GetGammaTableI3D_5(hDC, iEntries, puRed, puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: gdi_device_context; iEntries: Int32; puRed: IntPtr; var puGreen: UInt16; var puBlue: UInt16): Bool :=
    z_GetGammaTableI3D_4(hDC, iEntries, puRed, puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: gdi_device_context; iEntries: Int32; puRed: IntPtr; var puGreen: UInt16; puBlue: IntPtr): Bool :=
    z_GetGammaTableI3D_3(hDC, iEntries, puRed, puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: gdi_device_context; iEntries: Int32; puRed: IntPtr; puGreen: IntPtr; var puBlue: UInt16): Bool :=
    z_GetGammaTableI3D_2(hDC, iEntries, puRed, puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: gdi_device_context; iEntries: Int32; puRed: IntPtr; puGreen: IntPtr; puBlue: IntPtr): Bool :=
    z_GetGammaTableI3D_1(hDC, iEntries, puRed, puGreen, puBlue);
    
    private z_SetGammaTableI3D_adr := GetProcAddress('wglSetGammaTableI3D');
    private z_SetGammaTableI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; iEntries: Int32; puRed: IntPtr; puGreen: IntPtr; puBlue: IntPtr): Bool>(z_SetGammaTableI3D_adr);
    private z_SetGammaTableI3D_2 := GetProcOrNil&<function(hDC: gdi_device_context; iEntries: Int32; puRed: IntPtr; puGreen: IntPtr; var puBlue: UInt16): Bool>(z_SetGammaTableI3D_adr);
    private z_SetGammaTableI3D_3 := GetProcOrNil&<function(hDC: gdi_device_context; iEntries: Int32; puRed: IntPtr; var puGreen: UInt16; puBlue: IntPtr): Bool>(z_SetGammaTableI3D_adr);
    private z_SetGammaTableI3D_4 := GetProcOrNil&<function(hDC: gdi_device_context; iEntries: Int32; puRed: IntPtr; var puGreen: UInt16; var puBlue: UInt16): Bool>(z_SetGammaTableI3D_adr);
    private z_SetGammaTableI3D_5 := GetProcOrNil&<function(hDC: gdi_device_context; iEntries: Int32; var puRed: UInt16; puGreen: IntPtr; puBlue: IntPtr): Bool>(z_SetGammaTableI3D_adr);
    private z_SetGammaTableI3D_6 := GetProcOrNil&<function(hDC: gdi_device_context; iEntries: Int32; var puRed: UInt16; puGreen: IntPtr; var puBlue: UInt16): Bool>(z_SetGammaTableI3D_adr);
    private z_SetGammaTableI3D_7 := GetProcOrNil&<function(hDC: gdi_device_context; iEntries: Int32; var puRed: UInt16; var puGreen: UInt16; puBlue: IntPtr): Bool>(z_SetGammaTableI3D_adr);
    private z_SetGammaTableI3D_8 := GetProcOrNil&<function(hDC: gdi_device_context; iEntries: Int32; var puRed: UInt16; var puGreen: UInt16; var puBlue: UInt16): Bool>(z_SetGammaTableI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: gdi_device_context; iEntries: Int32; puRed: array of UInt16; puGreen: array of UInt16; puBlue: array of UInt16): Bool;
    type PUInt16=^UInt16;
    begin
      Result := if (puBlue<>nil) and (puBlue.Length<>0) then
        if (puGreen<>nil) and (puGreen.Length<>0) then
          if (puRed<>nil) and (puRed.Length<>0) then
            z_SetGammaTableI3D_8(hDC, iEntries, puRed[0], puGreen[0], puBlue[0]) else
            z_SetGammaTableI3D_8(hDC, iEntries, PUInt16(nil)^, puGreen[0], puBlue[0]) else
          if (puRed<>nil) and (puRed.Length<>0) then
            z_SetGammaTableI3D_8(hDC, iEntries, puRed[0], PUInt16(nil)^, puBlue[0]) else
            z_SetGammaTableI3D_8(hDC, iEntries, PUInt16(nil)^, PUInt16(nil)^, puBlue[0]) else
        if (puGreen<>nil) and (puGreen.Length<>0) then
          if (puRed<>nil) and (puRed.Length<>0) then
            z_SetGammaTableI3D_8(hDC, iEntries, puRed[0], puGreen[0], PUInt16(nil)^) else
            z_SetGammaTableI3D_8(hDC, iEntries, PUInt16(nil)^, puGreen[0], PUInt16(nil)^) else
          if (puRed<>nil) and (puRed.Length<>0) then
            z_SetGammaTableI3D_8(hDC, iEntries, puRed[0], PUInt16(nil)^, PUInt16(nil)^) else
            z_SetGammaTableI3D_8(hDC, iEntries, PUInt16(nil)^, PUInt16(nil)^, PUInt16(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: gdi_device_context; iEntries: Int32; var puRed: UInt16; var puGreen: UInt16; var puBlue: UInt16): Bool :=
    z_SetGammaTableI3D_8(hDC, iEntries, puRed, puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: gdi_device_context; iEntries: Int32; var puRed: UInt16; var puGreen: UInt16; puBlue: IntPtr): Bool :=
    z_SetGammaTableI3D_7(hDC, iEntries, puRed, puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: gdi_device_context; iEntries: Int32; var puRed: UInt16; puGreen: IntPtr; var puBlue: UInt16): Bool :=
    z_SetGammaTableI3D_6(hDC, iEntries, puRed, puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: gdi_device_context; iEntries: Int32; var puRed: UInt16; puGreen: IntPtr; puBlue: IntPtr): Bool :=
    z_SetGammaTableI3D_5(hDC, iEntries, puRed, puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: gdi_device_context; iEntries: Int32; puRed: IntPtr; var puGreen: UInt16; var puBlue: UInt16): Bool :=
    z_SetGammaTableI3D_4(hDC, iEntries, puRed, puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: gdi_device_context; iEntries: Int32; puRed: IntPtr; var puGreen: UInt16; puBlue: IntPtr): Bool :=
    z_SetGammaTableI3D_3(hDC, iEntries, puRed, puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: gdi_device_context; iEntries: Int32; puRed: IntPtr; puGreen: IntPtr; var puBlue: UInt16): Bool :=
    z_SetGammaTableI3D_2(hDC, iEntries, puRed, puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: gdi_device_context; iEntries: Int32; puRed: IntPtr; puGreen: IntPtr; puBlue: IntPtr): Bool :=
    z_SetGammaTableI3D_1(hDC, iEntries, puRed, puGreen, puBlue);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  wglGenlockI3D = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'wgl_i3d_genlock';
    
    private z_EnableGenlockI3D_adr := GetProcAddress('wglEnableGenlockI3D');
    private z_EnableGenlockI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context): Bool>(z_EnableGenlockI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnableGenlockI3D(hDC: gdi_device_context): Bool :=
    z_EnableGenlockI3D_1(hDC);
    
    private z_DisableGenlockI3D_adr := GetProcAddress('wglDisableGenlockI3D');
    private z_DisableGenlockI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context): Bool>(z_DisableGenlockI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DisableGenlockI3D(hDC: gdi_device_context): Bool :=
    z_DisableGenlockI3D_1(hDC);
    
    private z_IsEnabledGenlockI3D_adr := GetProcAddress('wglIsEnabledGenlockI3D');
    private z_IsEnabledGenlockI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; pFlag: IntPtr): Bool>(z_IsEnabledGenlockI3D_adr);
    private z_IsEnabledGenlockI3D_2 := GetProcOrNil&<function(hDC: gdi_device_context; var pFlag: Bool): Bool>(z_IsEnabledGenlockI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnabledGenlockI3D(hDC: gdi_device_context; pFlag: array of Bool): Bool;
    type PBool=^Bool;
    begin
      Result := if (pFlag<>nil) and (pFlag.Length<>0) then
        z_IsEnabledGenlockI3D_2(hDC, pFlag[0]) else
        z_IsEnabledGenlockI3D_2(hDC, PBool(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnabledGenlockI3D(hDC: gdi_device_context; var pFlag: Bool): Bool :=
    z_IsEnabledGenlockI3D_2(hDC, pFlag);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnabledGenlockI3D(hDC: gdi_device_context; pFlag: IntPtr): Bool :=
    z_IsEnabledGenlockI3D_1(hDC, pFlag);
    
    private z_GenlockSourceI3D_adr := GetProcAddress('wglGenlockSourceI3D');
    private z_GenlockSourceI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; uSource: UInt32): Bool>(z_GenlockSourceI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenlockSourceI3D(hDC: gdi_device_context; uSource: UInt32): Bool :=
    z_GenlockSourceI3D_1(hDC, uSource);
    
    private z_GetGenlockSourceI3D_adr := GetProcAddress('wglGetGenlockSourceI3D');
    private z_GetGenlockSourceI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; uSource: IntPtr): Bool>(z_GetGenlockSourceI3D_adr);
    private z_GetGenlockSourceI3D_2 := GetProcOrNil&<function(hDC: gdi_device_context; var uSource: UInt32): Bool>(z_GetGenlockSourceI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSourceI3D(hDC: gdi_device_context; var uSource: UInt32): Bool :=
    z_GetGenlockSourceI3D_2(hDC, uSource);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSourceI3D(hDC: gdi_device_context; uSource: IntPtr): Bool :=
    z_GetGenlockSourceI3D_1(hDC, uSource);
    
    private z_GenlockSourceEdgeI3D_adr := GetProcAddress('wglGenlockSourceEdgeI3D');
    private z_GenlockSourceEdgeI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; uEdge: UInt32): Bool>(z_GenlockSourceEdgeI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenlockSourceEdgeI3D(hDC: gdi_device_context; uEdge: UInt32): Bool :=
    z_GenlockSourceEdgeI3D_1(hDC, uEdge);
    
    private z_GetGenlockSourceEdgeI3D_adr := GetProcAddress('wglGetGenlockSourceEdgeI3D');
    private z_GetGenlockSourceEdgeI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; uEdge: IntPtr): Bool>(z_GetGenlockSourceEdgeI3D_adr);
    private z_GetGenlockSourceEdgeI3D_2 := GetProcOrNil&<function(hDC: gdi_device_context; var uEdge: UInt32): Bool>(z_GetGenlockSourceEdgeI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSourceEdgeI3D(hDC: gdi_device_context; var uEdge: UInt32): Bool :=
    z_GetGenlockSourceEdgeI3D_2(hDC, uEdge);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSourceEdgeI3D(hDC: gdi_device_context; uEdge: IntPtr): Bool :=
    z_GetGenlockSourceEdgeI3D_1(hDC, uEdge);
    
    private z_GenlockSampleRateI3D_adr := GetProcAddress('wglGenlockSampleRateI3D');
    private z_GenlockSampleRateI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; uRate: UInt32): Bool>(z_GenlockSampleRateI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenlockSampleRateI3D(hDC: gdi_device_context; uRate: UInt32): Bool :=
    z_GenlockSampleRateI3D_1(hDC, uRate);
    
    private z_GetGenlockSampleRateI3D_adr := GetProcAddress('wglGetGenlockSampleRateI3D');
    private z_GetGenlockSampleRateI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; uRate: IntPtr): Bool>(z_GetGenlockSampleRateI3D_adr);
    private z_GetGenlockSampleRateI3D_2 := GetProcOrNil&<function(hDC: gdi_device_context; var uRate: UInt32): Bool>(z_GetGenlockSampleRateI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSampleRateI3D(hDC: gdi_device_context; var uRate: UInt32): Bool :=
    z_GetGenlockSampleRateI3D_2(hDC, uRate);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSampleRateI3D(hDC: gdi_device_context; uRate: IntPtr): Bool :=
    z_GetGenlockSampleRateI3D_1(hDC, uRate);
    
    private z_GenlockSourceDelayI3D_adr := GetProcAddress('wglGenlockSourceDelayI3D');
    private z_GenlockSourceDelayI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; uDelay: UInt32): Bool>(z_GenlockSourceDelayI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenlockSourceDelayI3D(hDC: gdi_device_context; uDelay: UInt32): Bool :=
    z_GenlockSourceDelayI3D_1(hDC, uDelay);
    
    private z_GetGenlockSourceDelayI3D_adr := GetProcAddress('wglGetGenlockSourceDelayI3D');
    private z_GetGenlockSourceDelayI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; uDelay: IntPtr): Bool>(z_GetGenlockSourceDelayI3D_adr);
    private z_GetGenlockSourceDelayI3D_2 := GetProcOrNil&<function(hDC: gdi_device_context; var uDelay: UInt32): Bool>(z_GetGenlockSourceDelayI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSourceDelayI3D(hDC: gdi_device_context; var uDelay: UInt32): Bool :=
    z_GetGenlockSourceDelayI3D_2(hDC, uDelay);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSourceDelayI3D(hDC: gdi_device_context; uDelay: IntPtr): Bool :=
    z_GetGenlockSourceDelayI3D_1(hDC, uDelay);
    
    private z_QueryGenlockMaxSourceDelayI3D_adr := GetProcAddress('wglQueryGenlockMaxSourceDelayI3D');
    private z_QueryGenlockMaxSourceDelayI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; uMaxLineDelay: IntPtr; uMaxPixelDelay: IntPtr): Bool>(z_QueryGenlockMaxSourceDelayI3D_adr);
    private z_QueryGenlockMaxSourceDelayI3D_2 := GetProcOrNil&<function(hDC: gdi_device_context; uMaxLineDelay: IntPtr; var uMaxPixelDelay: UInt32): Bool>(z_QueryGenlockMaxSourceDelayI3D_adr);
    private z_QueryGenlockMaxSourceDelayI3D_3 := GetProcOrNil&<function(hDC: gdi_device_context; var uMaxLineDelay: UInt32; uMaxPixelDelay: IntPtr): Bool>(z_QueryGenlockMaxSourceDelayI3D_adr);
    private z_QueryGenlockMaxSourceDelayI3D_4 := GetProcOrNil&<function(hDC: gdi_device_context; var uMaxLineDelay: UInt32; var uMaxPixelDelay: UInt32): Bool>(z_QueryGenlockMaxSourceDelayI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryGenlockMaxSourceDelayI3D(hDC: gdi_device_context; uMaxLineDelay: array of UInt32; uMaxPixelDelay: array of UInt32): Bool;
    type PUInt32=^UInt32;
    begin
      Result := if (uMaxPixelDelay<>nil) and (uMaxPixelDelay.Length<>0) then
        if (uMaxLineDelay<>nil) and (uMaxLineDelay.Length<>0) then
          z_QueryGenlockMaxSourceDelayI3D_4(hDC, uMaxLineDelay[0], uMaxPixelDelay[0]) else
          z_QueryGenlockMaxSourceDelayI3D_4(hDC, PUInt32(nil)^, uMaxPixelDelay[0]) else
        if (uMaxLineDelay<>nil) and (uMaxLineDelay.Length<>0) then
          z_QueryGenlockMaxSourceDelayI3D_4(hDC, uMaxLineDelay[0], PUInt32(nil)^) else
          z_QueryGenlockMaxSourceDelayI3D_4(hDC, PUInt32(nil)^, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryGenlockMaxSourceDelayI3D(hDC: gdi_device_context; var uMaxLineDelay: UInt32; var uMaxPixelDelay: UInt32): Bool :=
    z_QueryGenlockMaxSourceDelayI3D_4(hDC, uMaxLineDelay, uMaxPixelDelay);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryGenlockMaxSourceDelayI3D(hDC: gdi_device_context; var uMaxLineDelay: UInt32; uMaxPixelDelay: IntPtr): Bool :=
    z_QueryGenlockMaxSourceDelayI3D_3(hDC, uMaxLineDelay, uMaxPixelDelay);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryGenlockMaxSourceDelayI3D(hDC: gdi_device_context; uMaxLineDelay: IntPtr; var uMaxPixelDelay: UInt32): Bool :=
    z_QueryGenlockMaxSourceDelayI3D_2(hDC, uMaxLineDelay, uMaxPixelDelay);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryGenlockMaxSourceDelayI3D(hDC: gdi_device_context; uMaxLineDelay: IntPtr; uMaxPixelDelay: IntPtr): Bool :=
    z_QueryGenlockMaxSourceDelayI3D_1(hDC, uMaxLineDelay, uMaxPixelDelay);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  wglImageBufferI3D = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'wgl_i3d_image_buffer';
    
    private z_CreateImageBufferI3D_adr := GetProcAddress('wglCreateImageBufferI3D');
    private z_CreateImageBufferI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; dwSize: UInt32; uFlags: UInt32): IntPtr>(z_CreateImageBufferI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateImageBufferI3D(hDC: gdi_device_context; dwSize: UInt32; uFlags: UInt32): IntPtr :=
    z_CreateImageBufferI3D_1(hDC, dwSize, uFlags);
    
    private z_DestroyImageBufferI3D_adr := GetProcAddress('wglDestroyImageBufferI3D');
    private z_DestroyImageBufferI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; pAddress: IntPtr): Bool>(z_DestroyImageBufferI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DestroyImageBufferI3D(hDC: gdi_device_context; pAddress: IntPtr): Bool :=
    z_DestroyImageBufferI3D_1(hDC, pAddress);
    
    private z_AssociateImageBufferEventsI3D_adr := GetProcAddress('wglAssociateImageBufferEventsI3D');
    private z_AssociateImageBufferEventsI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; pEvent: pointer; pAddress: pointer; pSize: IntPtr; count: UInt32): Bool>(z_AssociateImageBufferEventsI3D_adr);
    private z_AssociateImageBufferEventsI3D_2 := GetProcOrNil&<function(hDC: gdi_device_context; pEvent: pointer; pAddress: pointer; var pSize: UInt32; count: UInt32): Bool>(z_AssociateImageBufferEventsI3D_adr);
    private z_AssociateImageBufferEventsI3D_3 := GetProcOrNil&<function(hDC: gdi_device_context; pEvent: pointer; var pAddress: IntPtr; pSize: IntPtr; count: UInt32): Bool>(z_AssociateImageBufferEventsI3D_adr);
    private z_AssociateImageBufferEventsI3D_4 := GetProcOrNil&<function(hDC: gdi_device_context; pEvent: pointer; var pAddress: IntPtr; var pSize: UInt32; count: UInt32): Bool>(z_AssociateImageBufferEventsI3D_adr);
    private z_AssociateImageBufferEventsI3D_5 := GetProcOrNil&<function(hDC: gdi_device_context; var pEvent: IntPtr; pAddress: pointer; pSize: IntPtr; count: UInt32): Bool>(z_AssociateImageBufferEventsI3D_adr);
    private z_AssociateImageBufferEventsI3D_6 := GetProcOrNil&<function(hDC: gdi_device_context; var pEvent: IntPtr; pAddress: pointer; var pSize: UInt32; count: UInt32): Bool>(z_AssociateImageBufferEventsI3D_adr);
    private z_AssociateImageBufferEventsI3D_7 := GetProcOrNil&<function(hDC: gdi_device_context; var pEvent: IntPtr; var pAddress: IntPtr; pSize: IntPtr; count: UInt32): Bool>(z_AssociateImageBufferEventsI3D_adr);
    private z_AssociateImageBufferEventsI3D_8 := GetProcOrNil&<function(hDC: gdi_device_context; var pEvent: IntPtr; var pAddress: IntPtr; var pSize: UInt32; count: UInt32): Bool>(z_AssociateImageBufferEventsI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: gdi_device_context; pEvent: array of IntPtr; pAddress: array of IntPtr; pSize: array of UInt32; count: UInt32): Bool;
    type PIntPtr=^IntPtr;
    type PUInt32=^UInt32;
    begin
      Result := if (pSize<>nil) and (pSize.Length<>0) then
        if (pAddress<>nil) and (pAddress.Length<>0) then
          if (pEvent<>nil) and (pEvent.Length<>0) then
            z_AssociateImageBufferEventsI3D_8(hDC, pEvent[0], pAddress[0], pSize[0], count) else
            z_AssociateImageBufferEventsI3D_8(hDC, PIntPtr(nil)^, pAddress[0], pSize[0], count) else
          if (pEvent<>nil) and (pEvent.Length<>0) then
            z_AssociateImageBufferEventsI3D_8(hDC, pEvent[0], PIntPtr(nil)^, pSize[0], count) else
            z_AssociateImageBufferEventsI3D_8(hDC, PIntPtr(nil)^, PIntPtr(nil)^, pSize[0], count) else
        if (pAddress<>nil) and (pAddress.Length<>0) then
          if (pEvent<>nil) and (pEvent.Length<>0) then
            z_AssociateImageBufferEventsI3D_8(hDC, pEvent[0], pAddress[0], PUInt32(nil)^, count) else
            z_AssociateImageBufferEventsI3D_8(hDC, PIntPtr(nil)^, pAddress[0], PUInt32(nil)^, count) else
          if (pEvent<>nil) and (pEvent.Length<>0) then
            z_AssociateImageBufferEventsI3D_8(hDC, pEvent[0], PIntPtr(nil)^, PUInt32(nil)^, count) else
            z_AssociateImageBufferEventsI3D_8(hDC, PIntPtr(nil)^, PIntPtr(nil)^, PUInt32(nil)^, count);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: gdi_device_context; var pEvent: IntPtr; var pAddress: IntPtr; var pSize: UInt32; count: UInt32): Bool :=
    z_AssociateImageBufferEventsI3D_8(hDC, pEvent, pAddress, pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: gdi_device_context; var pEvent: IntPtr; var pAddress: IntPtr; pSize: IntPtr; count: UInt32): Bool :=
    z_AssociateImageBufferEventsI3D_7(hDC, pEvent, pAddress, pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: gdi_device_context; var pEvent: IntPtr; pAddress: pointer; var pSize: UInt32; count: UInt32): Bool :=
    z_AssociateImageBufferEventsI3D_6(hDC, pEvent, pAddress, pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: gdi_device_context; var pEvent: IntPtr; pAddress: pointer; pSize: IntPtr; count: UInt32): Bool :=
    z_AssociateImageBufferEventsI3D_5(hDC, pEvent, pAddress, pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: gdi_device_context; pEvent: pointer; var pAddress: IntPtr; var pSize: UInt32; count: UInt32): Bool :=
    z_AssociateImageBufferEventsI3D_4(hDC, pEvent, pAddress, pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: gdi_device_context; pEvent: pointer; var pAddress: IntPtr; pSize: IntPtr; count: UInt32): Bool :=
    z_AssociateImageBufferEventsI3D_3(hDC, pEvent, pAddress, pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: gdi_device_context; pEvent: pointer; pAddress: pointer; var pSize: UInt32; count: UInt32): Bool :=
    z_AssociateImageBufferEventsI3D_2(hDC, pEvent, pAddress, pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: gdi_device_context; pEvent: pointer; pAddress: pointer; pSize: IntPtr; count: UInt32): Bool :=
    z_AssociateImageBufferEventsI3D_1(hDC, pEvent, pAddress, pSize, count);
    
    private z_ReleaseImageBufferEventsI3D_adr := GetProcAddress('wglReleaseImageBufferEventsI3D');
    private z_ReleaseImageBufferEventsI3D_1 := GetProcOrNil&<function(hDC: gdi_device_context; pAddress: pointer; count: UInt32): Bool>(z_ReleaseImageBufferEventsI3D_adr);
    private z_ReleaseImageBufferEventsI3D_2 := GetProcOrNil&<function(hDC: gdi_device_context; var pAddress: IntPtr; count: UInt32): Bool>(z_ReleaseImageBufferEventsI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseImageBufferEventsI3D(hDC: gdi_device_context; pAddress: array of IntPtr; count: UInt32): Bool;
    type PIntPtr=^IntPtr;
    begin
      Result := if (pAddress<>nil) and (pAddress.Length<>0) then
        z_ReleaseImageBufferEventsI3D_2(hDC, pAddress[0], count) else
        z_ReleaseImageBufferEventsI3D_2(hDC, PIntPtr(nil)^, count);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseImageBufferEventsI3D(hDC: gdi_device_context; var pAddress: IntPtr; count: UInt32): Bool :=
    z_ReleaseImageBufferEventsI3D_2(hDC, pAddress, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseImageBufferEventsI3D(hDC: gdi_device_context; pAddress: pointer; count: UInt32): Bool :=
    z_ReleaseImageBufferEventsI3D_1(hDC, pAddress, count);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  wglSwapFrameLockI3D = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'wgl_i3d_swap_frame_lock';
    
    private z_EnableFrameLockI3D_adr := GetProcAddress('wglEnableFrameLockI3D');
    private z_EnableFrameLockI3D_1 := GetProcOrNil&<function: Bool>(z_EnableFrameLockI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnableFrameLockI3D: Bool :=
    z_EnableFrameLockI3D_1();
    
    private z_DisableFrameLockI3D_adr := GetProcAddress('wglDisableFrameLockI3D');
    private z_DisableFrameLockI3D_1 := GetProcOrNil&<function: Bool>(z_DisableFrameLockI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DisableFrameLockI3D: Bool :=
    z_DisableFrameLockI3D_1();
    
    private z_IsEnabledFrameLockI3D_adr := GetProcAddress('wglIsEnabledFrameLockI3D');
    private z_IsEnabledFrameLockI3D_1 := GetProcOrNil&<function(pFlag: IntPtr): Bool>(z_IsEnabledFrameLockI3D_adr);
    private z_IsEnabledFrameLockI3D_2 := GetProcOrNil&<function(var pFlag: Bool): Bool>(z_IsEnabledFrameLockI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnabledFrameLockI3D(pFlag: array of Bool): Bool;
    type PBool=^Bool;
    begin
      Result := if (pFlag<>nil) and (pFlag.Length<>0) then
        z_IsEnabledFrameLockI3D_2(pFlag[0]) else
        z_IsEnabledFrameLockI3D_2(PBool(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnabledFrameLockI3D(var pFlag: Bool): Bool :=
    z_IsEnabledFrameLockI3D_2(pFlag);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnabledFrameLockI3D(pFlag: IntPtr): Bool :=
    z_IsEnabledFrameLockI3D_1(pFlag);
    
    private z_QueryFrameLockMasterI3D_adr := GetProcAddress('wglQueryFrameLockMasterI3D');
    private z_QueryFrameLockMasterI3D_1 := GetProcOrNil&<function(pFlag: IntPtr): Bool>(z_QueryFrameLockMasterI3D_adr);
    private z_QueryFrameLockMasterI3D_2 := GetProcOrNil&<function(var pFlag: Bool): Bool>(z_QueryFrameLockMasterI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameLockMasterI3D(pFlag: array of Bool): Bool;
    type PBool=^Bool;
    begin
      Result := if (pFlag<>nil) and (pFlag.Length<>0) then
        z_QueryFrameLockMasterI3D_2(pFlag[0]) else
        z_QueryFrameLockMasterI3D_2(PBool(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameLockMasterI3D(var pFlag: Bool): Bool :=
    z_QueryFrameLockMasterI3D_2(pFlag);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameLockMasterI3D(pFlag: IntPtr): Bool :=
    z_QueryFrameLockMasterI3D_1(pFlag);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  wglSwapFrameUsageI3D = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'wgl_i3d_swap_frame_usage';
    
    private z_GetFrameUsageI3D_adr := GetProcAddress('wglGetFrameUsageI3D');
    private z_GetFrameUsageI3D_1 := GetProcOrNil&<function(pUsage: IntPtr): Bool>(z_GetFrameUsageI3D_adr);
    private z_GetFrameUsageI3D_2 := GetProcOrNil&<function(var pUsage: single): Bool>(z_GetFrameUsageI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFrameUsageI3D(var pUsage: single): Bool :=
    z_GetFrameUsageI3D_2(pUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFrameUsageI3D(pUsage: IntPtr): Bool :=
    z_GetFrameUsageI3D_1(pUsage);
    
    private z_BeginFrameTrackingI3D_adr := GetProcAddress('wglBeginFrameTrackingI3D');
    private z_BeginFrameTrackingI3D_1 := GetProcOrNil&<function: Bool>(z_BeginFrameTrackingI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BeginFrameTrackingI3D: Bool :=
    z_BeginFrameTrackingI3D_1();
    
    private z_EndFrameTrackingI3D_adr := GetProcAddress('wglEndFrameTrackingI3D');
    private z_EndFrameTrackingI3D_1 := GetProcOrNil&<function: Bool>(z_EndFrameTrackingI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EndFrameTrackingI3D: Bool :=
    z_EndFrameTrackingI3D_1();
    
    private z_QueryFrameTrackingI3D_adr := GetProcAddress('wglQueryFrameTrackingI3D');
    private z_QueryFrameTrackingI3D_1 := GetProcOrNil&<function(pFrameCount: IntPtr; pMissedFrames: IntPtr; pLastMissedUsage: IntPtr): Bool>(z_QueryFrameTrackingI3D_adr);
    private z_QueryFrameTrackingI3D_2 := GetProcOrNil&<function(pFrameCount: IntPtr; pMissedFrames: IntPtr; var pLastMissedUsage: single): Bool>(z_QueryFrameTrackingI3D_adr);
    private z_QueryFrameTrackingI3D_3 := GetProcOrNil&<function(pFrameCount: IntPtr; var pMissedFrames: UInt32; pLastMissedUsage: IntPtr): Bool>(z_QueryFrameTrackingI3D_adr);
    private z_QueryFrameTrackingI3D_4 := GetProcOrNil&<function(pFrameCount: IntPtr; var pMissedFrames: UInt32; var pLastMissedUsage: single): Bool>(z_QueryFrameTrackingI3D_adr);
    private z_QueryFrameTrackingI3D_5 := GetProcOrNil&<function(var pFrameCount: UInt32; pMissedFrames: IntPtr; pLastMissedUsage: IntPtr): Bool>(z_QueryFrameTrackingI3D_adr);
    private z_QueryFrameTrackingI3D_6 := GetProcOrNil&<function(var pFrameCount: UInt32; pMissedFrames: IntPtr; var pLastMissedUsage: single): Bool>(z_QueryFrameTrackingI3D_adr);
    private z_QueryFrameTrackingI3D_7 := GetProcOrNil&<function(var pFrameCount: UInt32; var pMissedFrames: UInt32; pLastMissedUsage: IntPtr): Bool>(z_QueryFrameTrackingI3D_adr);
    private z_QueryFrameTrackingI3D_8 := GetProcOrNil&<function(var pFrameCount: UInt32; var pMissedFrames: UInt32; var pLastMissedUsage: single): Bool>(z_QueryFrameTrackingI3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: array of UInt32; pMissedFrames: array of UInt32; pLastMissedUsage: array of single): Bool;
    type PUInt32=^UInt32;
    type Psingle=^single;
    begin
      Result := if (pLastMissedUsage<>nil) and (pLastMissedUsage.Length<>0) then
        if (pMissedFrames<>nil) and (pMissedFrames.Length<>0) then
          if (pFrameCount<>nil) and (pFrameCount.Length<>0) then
            z_QueryFrameTrackingI3D_8(pFrameCount[0], pMissedFrames[0], pLastMissedUsage[0]) else
            z_QueryFrameTrackingI3D_8(PUInt32(nil)^, pMissedFrames[0], pLastMissedUsage[0]) else
          if (pFrameCount<>nil) and (pFrameCount.Length<>0) then
            z_QueryFrameTrackingI3D_8(pFrameCount[0], PUInt32(nil)^, pLastMissedUsage[0]) else
            z_QueryFrameTrackingI3D_8(PUInt32(nil)^, PUInt32(nil)^, pLastMissedUsage[0]) else
        if (pMissedFrames<>nil) and (pMissedFrames.Length<>0) then
          if (pFrameCount<>nil) and (pFrameCount.Length<>0) then
            z_QueryFrameTrackingI3D_8(pFrameCount[0], pMissedFrames[0], Psingle(nil)^) else
            z_QueryFrameTrackingI3D_8(PUInt32(nil)^, pMissedFrames[0], Psingle(nil)^) else
          if (pFrameCount<>nil) and (pFrameCount.Length<>0) then
            z_QueryFrameTrackingI3D_8(pFrameCount[0], PUInt32(nil)^, Psingle(nil)^) else
            z_QueryFrameTrackingI3D_8(PUInt32(nil)^, PUInt32(nil)^, Psingle(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(var pFrameCount: UInt32; var pMissedFrames: UInt32; var pLastMissedUsage: single): Bool :=
    z_QueryFrameTrackingI3D_8(pFrameCount, pMissedFrames, pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(var pFrameCount: UInt32; var pMissedFrames: UInt32; pLastMissedUsage: IntPtr): Bool :=
    z_QueryFrameTrackingI3D_7(pFrameCount, pMissedFrames, pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(var pFrameCount: UInt32; pMissedFrames: IntPtr; var pLastMissedUsage: single): Bool :=
    z_QueryFrameTrackingI3D_6(pFrameCount, pMissedFrames, pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(var pFrameCount: UInt32; pMissedFrames: IntPtr; pLastMissedUsage: IntPtr): Bool :=
    z_QueryFrameTrackingI3D_5(pFrameCount, pMissedFrames, pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: IntPtr; var pMissedFrames: UInt32; var pLastMissedUsage: single): Bool :=
    z_QueryFrameTrackingI3D_4(pFrameCount, pMissedFrames, pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: IntPtr; var pMissedFrames: UInt32; pLastMissedUsage: IntPtr): Bool :=
    z_QueryFrameTrackingI3D_3(pFrameCount, pMissedFrames, pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: IntPtr; pMissedFrames: IntPtr; var pLastMissedUsage: single): Bool :=
    z_QueryFrameTrackingI3D_2(pFrameCount, pMissedFrames, pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: IntPtr; pMissedFrames: IntPtr; pLastMissedUsage: IntPtr): Bool :=
    z_QueryFrameTrackingI3D_1(pFrameCount, pMissedFrames, pLastMissedUsage);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  wglCopyImageNV = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'wgl_nv_copy_image';
    
    private z_CopyImageSubDataNV_adr := GetProcAddress('wglCopyImageSubDataNV');
    private z_CopyImageSubDataNV_1 := GetProcOrNil&<function(hSrcRC: wgl_context; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; hDstRC: wgl_context; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; width: Int32; height: Int32; depth: Int32): Bool>(z_CopyImageSubDataNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CopyImageSubDataNV(hSrcRC: wgl_context; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; hDstRC: wgl_context; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; width: Int32; height: Int32; depth: Int32): Bool :=
    z_CopyImageSubDataNV_1(hSrcRC, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, hDstRC, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  wglDelayBeforeSwapNV = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'wgl_nv_delay_before_swap';
    
    private z_DelayBeforeSwapNV_adr := GetProcAddress('wglDelayBeforeSwapNV');
    private z_DelayBeforeSwapNV_1 := GetProcOrNil&<function(hDC: gdi_device_context; seconds: single): Bool>(z_DelayBeforeSwapNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DelayBeforeSwapNV(hDC: gdi_device_context; seconds: single): Bool :=
    z_DelayBeforeSwapNV_1(hDC, seconds);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  wglDXInteropNV = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'wgl_nv_dx_interop';
    
    private z_DXSetResourceShareHandleNV_adr := GetProcAddress('wglDXSetResourceShareHandleNV');
    private z_DXSetResourceShareHandleNV_1 := GetProcOrNil&<function(dxObject: IntPtr; shareHandle: IntPtr): Bool>(z_DXSetResourceShareHandleNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXSetResourceShareHandleNV(dxObject: IntPtr; shareHandle: IntPtr): Bool :=
    z_DXSetResourceShareHandleNV_1(dxObject, shareHandle);
    
    private z_DXOpenDeviceNV_adr := GetProcAddress('wglDXOpenDeviceNV');
    private z_DXOpenDeviceNV_1 := GetProcOrNil&<function(dxDevice: IntPtr): IntPtr>(z_DXOpenDeviceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXOpenDeviceNV(dxDevice: IntPtr): IntPtr :=
    z_DXOpenDeviceNV_1(dxDevice);
    
    private z_DXCloseDeviceNV_adr := GetProcAddress('wglDXCloseDeviceNV');
    private z_DXCloseDeviceNV_1 := GetProcOrNil&<function(hDevice: IntPtr): Bool>(z_DXCloseDeviceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXCloseDeviceNV(hDevice: IntPtr): Bool :=
    z_DXCloseDeviceNV_1(hDevice);
    
    private z_DXRegisterObjectNV_adr := GetProcAddress('wglDXRegisterObjectNV');
    private z_DXRegisterObjectNV_1 := GetProcOrNil&<function(hDevice: IntPtr; dxObject: IntPtr; name: UInt32; &type: DummyEnum; access: DummyEnum): IntPtr>(z_DXRegisterObjectNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXRegisterObjectNV(hDevice: IntPtr; dxObject: IntPtr; name: UInt32; &type: DummyEnum; access: DummyEnum): IntPtr :=
    z_DXRegisterObjectNV_1(hDevice, dxObject, name, &type, access);
    
    private z_DXUnregisterObjectNV_adr := GetProcAddress('wglDXUnregisterObjectNV');
    private z_DXUnregisterObjectNV_1 := GetProcOrNil&<function(hDevice: IntPtr; hObject: IntPtr): Bool>(z_DXUnregisterObjectNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXUnregisterObjectNV(hDevice: IntPtr; hObject: IntPtr): Bool :=
    z_DXUnregisterObjectNV_1(hDevice, hObject);
    
    private z_DXObjectAccessNV_adr := GetProcAddress('wglDXObjectAccessNV');
    private z_DXObjectAccessNV_1 := GetProcOrNil&<function(hObject: IntPtr; access: DummyEnum): Bool>(z_DXObjectAccessNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXObjectAccessNV(hObject: IntPtr; access: DummyEnum): Bool :=
    z_DXObjectAccessNV_1(hObject, access);
    
    private z_DXLockObjectsNV_adr := GetProcAddress('wglDXLockObjectsNV');
    private z_DXLockObjectsNV_1 := GetProcOrNil&<function(hDevice: IntPtr; count: Int32; hObjects: pointer): Bool>(z_DXLockObjectsNV_adr);
    private z_DXLockObjectsNV_2 := GetProcOrNil&<function(hDevice: IntPtr; count: Int32; var hObjects: IntPtr): Bool>(z_DXLockObjectsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXLockObjectsNV(hDevice: IntPtr; count: Int32; hObjects: array of IntPtr): Bool;
    type PIntPtr=^IntPtr;
    begin
      Result := if (hObjects<>nil) and (hObjects.Length<>0) then
        z_DXLockObjectsNV_2(hDevice, count, hObjects[0]) else
        z_DXLockObjectsNV_2(hDevice, count, PIntPtr(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXLockObjectsNV(hDevice: IntPtr; count: Int32; var hObjects: IntPtr): Bool :=
    z_DXLockObjectsNV_2(hDevice, count, hObjects);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXLockObjectsNV(hDevice: IntPtr; count: Int32; hObjects: pointer): Bool :=
    z_DXLockObjectsNV_1(hDevice, count, hObjects);
    
    private z_DXUnlockObjectsNV_adr := GetProcAddress('wglDXUnlockObjectsNV');
    private z_DXUnlockObjectsNV_1 := GetProcOrNil&<function(hDevice: IntPtr; count: Int32; hObjects: pointer): Bool>(z_DXUnlockObjectsNV_adr);
    private z_DXUnlockObjectsNV_2 := GetProcOrNil&<function(hDevice: IntPtr; count: Int32; var hObjects: IntPtr): Bool>(z_DXUnlockObjectsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXUnlockObjectsNV(hDevice: IntPtr; count: Int32; hObjects: array of IntPtr): Bool;
    type PIntPtr=^IntPtr;
    begin
      Result := if (hObjects<>nil) and (hObjects.Length<>0) then
        z_DXUnlockObjectsNV_2(hDevice, count, hObjects[0]) else
        z_DXUnlockObjectsNV_2(hDevice, count, PIntPtr(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXUnlockObjectsNV(hDevice: IntPtr; count: Int32; var hObjects: IntPtr): Bool :=
    z_DXUnlockObjectsNV_2(hDevice, count, hObjects);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXUnlockObjectsNV(hDevice: IntPtr; count: Int32; hObjects: pointer): Bool :=
    z_DXUnlockObjectsNV_1(hDevice, count, hObjects);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  wglGpuAffinityNV = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'wgl_nv_gpu_affinity';
    
    private z_EnumGpusNV_adr := GetProcAddress('wglEnumGpusNV');
    private z_EnumGpusNV_1 := GetProcOrNil&<function(iGpuIndex: UInt32; phGpu: IntPtr): Bool>(z_EnumGpusNV_adr);
    private z_EnumGpusNV_2 := GetProcOrNil&<function(iGpuIndex: UInt32; var phGpu: wgl_GPU_NV): Bool>(z_EnumGpusNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumGpusNV(iGpuIndex: UInt32; phGpu: array of wgl_GPU_NV): Bool;
    type Pwgl_GPU_NV=^wgl_GPU_NV;
    begin
      Result := if (phGpu<>nil) and (phGpu.Length<>0) then
        z_EnumGpusNV_2(iGpuIndex, phGpu[0]) else
        z_EnumGpusNV_2(iGpuIndex, Pwgl_GPU_NV(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumGpusNV(iGpuIndex: UInt32; var phGpu: wgl_GPU_NV): Bool :=
    z_EnumGpusNV_2(iGpuIndex, phGpu);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumGpusNV(iGpuIndex: UInt32; phGpu: IntPtr): Bool :=
    z_EnumGpusNV_1(iGpuIndex, phGpu);
    
    private z_EnumGpuDevicesNV_adr := GetProcAddress('wglEnumGpuDevicesNV');
    private z_EnumGpuDevicesNV_1 := GetProcOrNil&<function(hGpu: wgl_GPU_NV; iDeviceIndex: UInt32; lpGpuDevice: IntPtr): Bool>(z_EnumGpuDevicesNV_adr);
    private z_EnumGpuDevicesNV_2 := GetProcOrNil&<function(hGpu: wgl_GPU_NV; iDeviceIndex: UInt32; var lpGpuDevice: wgl_GPU_device_NV): Bool>(z_EnumGpuDevicesNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumGpuDevicesNV(hGpu: wgl_GPU_NV; iDeviceIndex: UInt32; lpGpuDevice: array of wgl_GPU_device_NV): Bool;
    type Pwgl_GPU_device_NV=^wgl_GPU_device_NV;
    begin
      Result := if (lpGpuDevice<>nil) and (lpGpuDevice.Length<>0) then
        z_EnumGpuDevicesNV_2(hGpu, iDeviceIndex, lpGpuDevice[0]) else
        z_EnumGpuDevicesNV_2(hGpu, iDeviceIndex, Pwgl_GPU_device_NV(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumGpuDevicesNV(hGpu: wgl_GPU_NV; iDeviceIndex: UInt32; var lpGpuDevice: wgl_GPU_device_NV): Bool :=
    z_EnumGpuDevicesNV_2(hGpu, iDeviceIndex, lpGpuDevice);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumGpuDevicesNV(hGpu: wgl_GPU_NV; iDeviceIndex: UInt32; lpGpuDevice: IntPtr): Bool :=
    z_EnumGpuDevicesNV_1(hGpu, iDeviceIndex, lpGpuDevice);
    
    private z_CreateAffinityDCNV_adr := GetProcAddress('wglCreateAffinityDCNV');
    private z_CreateAffinityDCNV_1 := GetProcOrNil&<function(phGpuList: IntPtr): gdi_device_context>(z_CreateAffinityDCNV_adr);
    private z_CreateAffinityDCNV_2 := GetProcOrNil&<function(var phGpuList: wgl_GPU_NV): gdi_device_context>(z_CreateAffinityDCNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAffinityDCNV(phGpuList: array of wgl_GPU_NV): gdi_device_context;
    type Pwgl_GPU_NV=^wgl_GPU_NV;
    begin
      Result := if (phGpuList<>nil) and (phGpuList.Length<>0) then
        z_CreateAffinityDCNV_2(phGpuList[0]) else
        z_CreateAffinityDCNV_2(Pwgl_GPU_NV(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAffinityDCNV(var phGpuList: wgl_GPU_NV): gdi_device_context :=
    z_CreateAffinityDCNV_2(phGpuList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAffinityDCNV(phGpuList: IntPtr): gdi_device_context :=
    z_CreateAffinityDCNV_1(phGpuList);
    
    private z_EnumGpusFromAffinityDCNV_adr := GetProcAddress('wglEnumGpusFromAffinityDCNV');
    private z_EnumGpusFromAffinityDCNV_1 := GetProcOrNil&<function(hAffinityDC: gdi_device_context; iGpuIndex: UInt32; hGpu: IntPtr): Bool>(z_EnumGpusFromAffinityDCNV_adr);
    private z_EnumGpusFromAffinityDCNV_2 := GetProcOrNil&<function(hAffinityDC: gdi_device_context; iGpuIndex: UInt32; var hGpu: wgl_GPU_NV): Bool>(z_EnumGpusFromAffinityDCNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumGpusFromAffinityDCNV(hAffinityDC: gdi_device_context; iGpuIndex: UInt32; hGpu: array of wgl_GPU_NV): Bool;
    type Pwgl_GPU_NV=^wgl_GPU_NV;
    begin
      Result := if (hGpu<>nil) and (hGpu.Length<>0) then
        z_EnumGpusFromAffinityDCNV_2(hAffinityDC, iGpuIndex, hGpu[0]) else
        z_EnumGpusFromAffinityDCNV_2(hAffinityDC, iGpuIndex, Pwgl_GPU_NV(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumGpusFromAffinityDCNV(hAffinityDC: gdi_device_context; iGpuIndex: UInt32; var hGpu: wgl_GPU_NV): Bool :=
    z_EnumGpusFromAffinityDCNV_2(hAffinityDC, iGpuIndex, hGpu);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumGpusFromAffinityDCNV(hAffinityDC: gdi_device_context; iGpuIndex: UInt32; hGpu: IntPtr): Bool :=
    z_EnumGpusFromAffinityDCNV_1(hAffinityDC, iGpuIndex, hGpu);
    
    private z_DeleteDCNV_adr := GetProcAddress('wglDeleteDCNV');
    private z_DeleteDCNV_1 := GetProcOrNil&<function(hdc: gdi_device_context): Bool>(z_DeleteDCNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DeleteDCNV(hdc: gdi_device_context): Bool :=
    z_DeleteDCNV_1(hdc);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  wglPresentVideoNV = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'wgl_nv_present_video';
    
    private z_EnumerateVideoDevicesNV_adr := GetProcAddress('wglEnumerateVideoDevicesNV');
    private z_EnumerateVideoDevicesNV_1 := GetProcOrNil&<function(hDc: gdi_device_context; phDeviceList: IntPtr): Int32>(z_EnumerateVideoDevicesNV_adr);
    private z_EnumerateVideoDevicesNV_2 := GetProcOrNil&<function(hDc: gdi_device_context; var phDeviceList: wgl_h_video_output_device_NV): Int32>(z_EnumerateVideoDevicesNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumerateVideoDevicesNV(hDc: gdi_device_context; phDeviceList: array of wgl_h_video_output_device_NV): Int32;
    type Pwgl_h_video_output_device_NV=^wgl_h_video_output_device_NV;
    begin
      Result := if (phDeviceList<>nil) and (phDeviceList.Length<>0) then
        z_EnumerateVideoDevicesNV_2(hDc, phDeviceList[0]) else
        z_EnumerateVideoDevicesNV_2(hDc, Pwgl_h_video_output_device_NV(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumerateVideoDevicesNV(hDc: gdi_device_context; var phDeviceList: wgl_h_video_output_device_NV): Int32 :=
    z_EnumerateVideoDevicesNV_2(hDc, phDeviceList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumerateVideoDevicesNV(hDc: gdi_device_context; phDeviceList: IntPtr): Int32 :=
    z_EnumerateVideoDevicesNV_1(hDc, phDeviceList);
    
    private z_BindVideoDeviceNV_adr := GetProcAddress('wglBindVideoDeviceNV');
    private z_BindVideoDeviceNV_1 := GetProcOrNil&<function(hDc: gdi_device_context; uVideoSlot: UInt32; hVideoDevice: wgl_h_video_output_device_NV; piAttribList: IntPtr): Bool>(z_BindVideoDeviceNV_adr);
    private z_BindVideoDeviceNV_2 := GetProcOrNil&<function(hDc: gdi_device_context; uVideoSlot: UInt32; hVideoDevice: wgl_h_video_output_device_NV; var piAttribList: Int32): Bool>(z_BindVideoDeviceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindVideoDeviceNV(hDc: gdi_device_context; uVideoSlot: UInt32; hVideoDevice: wgl_h_video_output_device_NV; piAttribList: array of Int32): Bool;
    type PInt32=^Int32;
    begin
      Result := if (piAttribList<>nil) and (piAttribList.Length<>0) then
        z_BindVideoDeviceNV_2(hDc, uVideoSlot, hVideoDevice, piAttribList[0]) else
        z_BindVideoDeviceNV_2(hDc, uVideoSlot, hVideoDevice, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindVideoDeviceNV(hDc: gdi_device_context; uVideoSlot: UInt32; hVideoDevice: wgl_h_video_output_device_NV; var piAttribList: Int32): Bool :=
    z_BindVideoDeviceNV_2(hDc, uVideoSlot, hVideoDevice, piAttribList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindVideoDeviceNV(hDc: gdi_device_context; uVideoSlot: UInt32; hVideoDevice: wgl_h_video_output_device_NV; piAttribList: IntPtr): Bool :=
    z_BindVideoDeviceNV_1(hDc, uVideoSlot, hVideoDevice, piAttribList);
    
    private z_QueryCurrentContextNV_adr := GetProcAddress('wglQueryCurrentContextNV');
    private z_QueryCurrentContextNV_1 := GetProcOrNil&<function(iAttribute: Int32; piValue: IntPtr): Bool>(z_QueryCurrentContextNV_adr);
    private z_QueryCurrentContextNV_2 := GetProcOrNil&<function(iAttribute: Int32; var piValue: Int32): Bool>(z_QueryCurrentContextNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryCurrentContextNV(iAttribute: Int32; piValue: array of Int32): Bool;
    type PInt32=^Int32;
    begin
      Result := if (piValue<>nil) and (piValue.Length<>0) then
        z_QueryCurrentContextNV_2(iAttribute, piValue[0]) else
        z_QueryCurrentContextNV_2(iAttribute, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryCurrentContextNV(iAttribute: Int32; var piValue: Int32): Bool :=
    z_QueryCurrentContextNV_2(iAttribute, piValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryCurrentContextNV(iAttribute: Int32; piValue: IntPtr): Bool :=
    z_QueryCurrentContextNV_1(iAttribute, piValue);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  wglSwapGroupNV = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'wgl_nv_swap_group';
    
    private z_JoinSwapGroupNV_adr := GetProcAddress('wglJoinSwapGroupNV');
    private z_JoinSwapGroupNV_1 := GetProcOrNil&<function(hDC: gdi_device_context; group: UInt32): Bool>(z_JoinSwapGroupNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function JoinSwapGroupNV(hDC: gdi_device_context; group: UInt32): Bool :=
    z_JoinSwapGroupNV_1(hDC, group);
    
    private z_BindSwapBarrierNV_adr := GetProcAddress('wglBindSwapBarrierNV');
    private z_BindSwapBarrierNV_1 := GetProcOrNil&<function(group: UInt32; barrier: UInt32): Bool>(z_BindSwapBarrierNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindSwapBarrierNV(group: UInt32; barrier: UInt32): Bool :=
    z_BindSwapBarrierNV_1(group, barrier);
    
    private z_QuerySwapGroupNV_adr := GetProcAddress('wglQuerySwapGroupNV');
    private z_QuerySwapGroupNV_1 := GetProcOrNil&<function(hDC: gdi_device_context; group: IntPtr; barrier: IntPtr): Bool>(z_QuerySwapGroupNV_adr);
    private z_QuerySwapGroupNV_2 := GetProcOrNil&<function(hDC: gdi_device_context; group: IntPtr; var barrier: UInt32): Bool>(z_QuerySwapGroupNV_adr);
    private z_QuerySwapGroupNV_3 := GetProcOrNil&<function(hDC: gdi_device_context; var group: UInt32; barrier: IntPtr): Bool>(z_QuerySwapGroupNV_adr);
    private z_QuerySwapGroupNV_4 := GetProcOrNil&<function(hDC: gdi_device_context; var group: UInt32; var barrier: UInt32): Bool>(z_QuerySwapGroupNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(hDC: gdi_device_context; group: array of UInt32; barrier: array of UInt32): Bool;
    type PUInt32=^UInt32;
    begin
      Result := if (barrier<>nil) and (barrier.Length<>0) then
        if (group<>nil) and (group.Length<>0) then
          z_QuerySwapGroupNV_4(hDC, group[0], barrier[0]) else
          z_QuerySwapGroupNV_4(hDC, PUInt32(nil)^, barrier[0]) else
        if (group<>nil) and (group.Length<>0) then
          z_QuerySwapGroupNV_4(hDC, group[0], PUInt32(nil)^) else
          z_QuerySwapGroupNV_4(hDC, PUInt32(nil)^, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(hDC: gdi_device_context; var group: UInt32; var barrier: UInt32): Bool :=
    z_QuerySwapGroupNV_4(hDC, group, barrier);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(hDC: gdi_device_context; var group: UInt32; barrier: IntPtr): Bool :=
    z_QuerySwapGroupNV_3(hDC, group, barrier);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(hDC: gdi_device_context; group: IntPtr; var barrier: UInt32): Bool :=
    z_QuerySwapGroupNV_2(hDC, group, barrier);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(hDC: gdi_device_context; group: IntPtr; barrier: IntPtr): Bool :=
    z_QuerySwapGroupNV_1(hDC, group, barrier);
    
    private z_QueryMaxSwapGroupsNV_adr := GetProcAddress('wglQueryMaxSwapGroupsNV');
    private z_QueryMaxSwapGroupsNV_1 := GetProcOrNil&<function(hDC: gdi_device_context; maxGroups: IntPtr; maxBarriers: IntPtr): Bool>(z_QueryMaxSwapGroupsNV_adr);
    private z_QueryMaxSwapGroupsNV_2 := GetProcOrNil&<function(hDC: gdi_device_context; maxGroups: IntPtr; var maxBarriers: UInt32): Bool>(z_QueryMaxSwapGroupsNV_adr);
    private z_QueryMaxSwapGroupsNV_3 := GetProcOrNil&<function(hDC: gdi_device_context; var maxGroups: UInt32; maxBarriers: IntPtr): Bool>(z_QueryMaxSwapGroupsNV_adr);
    private z_QueryMaxSwapGroupsNV_4 := GetProcOrNil&<function(hDC: gdi_device_context; var maxGroups: UInt32; var maxBarriers: UInt32): Bool>(z_QueryMaxSwapGroupsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(hDC: gdi_device_context; maxGroups: array of UInt32; maxBarriers: array of UInt32): Bool;
    type PUInt32=^UInt32;
    begin
      Result := if (maxBarriers<>nil) and (maxBarriers.Length<>0) then
        if (maxGroups<>nil) and (maxGroups.Length<>0) then
          z_QueryMaxSwapGroupsNV_4(hDC, maxGroups[0], maxBarriers[0]) else
          z_QueryMaxSwapGroupsNV_4(hDC, PUInt32(nil)^, maxBarriers[0]) else
        if (maxGroups<>nil) and (maxGroups.Length<>0) then
          z_QueryMaxSwapGroupsNV_4(hDC, maxGroups[0], PUInt32(nil)^) else
          z_QueryMaxSwapGroupsNV_4(hDC, PUInt32(nil)^, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(hDC: gdi_device_context; var maxGroups: UInt32; var maxBarriers: UInt32): Bool :=
    z_QueryMaxSwapGroupsNV_4(hDC, maxGroups, maxBarriers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(hDC: gdi_device_context; var maxGroups: UInt32; maxBarriers: IntPtr): Bool :=
    z_QueryMaxSwapGroupsNV_3(hDC, maxGroups, maxBarriers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(hDC: gdi_device_context; maxGroups: IntPtr; var maxBarriers: UInt32): Bool :=
    z_QueryMaxSwapGroupsNV_2(hDC, maxGroups, maxBarriers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(hDC: gdi_device_context; maxGroups: IntPtr; maxBarriers: IntPtr): Bool :=
    z_QueryMaxSwapGroupsNV_1(hDC, maxGroups, maxBarriers);
    
    private z_QueryFrameCountNV_adr := GetProcAddress('wglQueryFrameCountNV');
    private z_QueryFrameCountNV_1 := GetProcOrNil&<function(hDC: gdi_device_context; count: IntPtr): Bool>(z_QueryFrameCountNV_adr);
    private z_QueryFrameCountNV_2 := GetProcOrNil&<function(hDC: gdi_device_context; var count: UInt32): Bool>(z_QueryFrameCountNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameCountNV(hDC: gdi_device_context; count: array of UInt32): Bool;
    type PUInt32=^UInt32;
    begin
      Result := if (count<>nil) and (count.Length<>0) then
        z_QueryFrameCountNV_2(hDC, count[0]) else
        z_QueryFrameCountNV_2(hDC, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameCountNV(hDC: gdi_device_context; var count: UInt32): Bool :=
    z_QueryFrameCountNV_2(hDC, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameCountNV(hDC: gdi_device_context; count: IntPtr): Bool :=
    z_QueryFrameCountNV_1(hDC, count);
    
    private z_ResetFrameCountNV_adr := GetProcAddress('wglResetFrameCountNV');
    private z_ResetFrameCountNV_1 := GetProcOrNil&<function(hDC: gdi_device_context): Bool>(z_ResetFrameCountNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ResetFrameCountNV(hDC: gdi_device_context): Bool :=
    z_ResetFrameCountNV_1(hDC);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  wglVideoCaptureNV = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'wgl_nv_video_capture';
    
    private z_BindVideoCaptureDeviceNV_adr := GetProcAddress('wglBindVideoCaptureDeviceNV');
    private z_BindVideoCaptureDeviceNV_1 := GetProcOrNil&<function(uVideoSlot: UInt32; hDevice: wgl_h_video_input_device_NV): Bool>(z_BindVideoCaptureDeviceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindVideoCaptureDeviceNV(uVideoSlot: UInt32; hDevice: wgl_h_video_input_device_NV): Bool :=
    z_BindVideoCaptureDeviceNV_1(uVideoSlot, hDevice);
    
    private z_EnumerateVideoCaptureDevicesNV_adr := GetProcAddress('wglEnumerateVideoCaptureDevicesNV');
    private z_EnumerateVideoCaptureDevicesNV_1 := GetProcOrNil&<function(hDc: gdi_device_context; phDeviceList: IntPtr): UInt32>(z_EnumerateVideoCaptureDevicesNV_adr);
    private z_EnumerateVideoCaptureDevicesNV_2 := GetProcOrNil&<function(hDc: gdi_device_context; var phDeviceList: wgl_h_video_input_device_NV): UInt32>(z_EnumerateVideoCaptureDevicesNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumerateVideoCaptureDevicesNV(hDc: gdi_device_context; phDeviceList: array of wgl_h_video_input_device_NV): UInt32;
    type Pwgl_h_video_input_device_NV=^wgl_h_video_input_device_NV;
    begin
      Result := if (phDeviceList<>nil) and (phDeviceList.Length<>0) then
        z_EnumerateVideoCaptureDevicesNV_2(hDc, phDeviceList[0]) else
        z_EnumerateVideoCaptureDevicesNV_2(hDc, Pwgl_h_video_input_device_NV(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumerateVideoCaptureDevicesNV(hDc: gdi_device_context; var phDeviceList: wgl_h_video_input_device_NV): UInt32 :=
    z_EnumerateVideoCaptureDevicesNV_2(hDc, phDeviceList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumerateVideoCaptureDevicesNV(hDc: gdi_device_context; phDeviceList: IntPtr): UInt32 :=
    z_EnumerateVideoCaptureDevicesNV_1(hDc, phDeviceList);
    
    private z_LockVideoCaptureDeviceNV_adr := GetProcAddress('wglLockVideoCaptureDeviceNV');
    private z_LockVideoCaptureDeviceNV_1 := GetProcOrNil&<function(hDc: gdi_device_context; hDevice: wgl_h_video_input_device_NV): Bool>(z_LockVideoCaptureDeviceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function LockVideoCaptureDeviceNV(hDc: gdi_device_context; hDevice: wgl_h_video_input_device_NV): Bool :=
    z_LockVideoCaptureDeviceNV_1(hDc, hDevice);
    
    private z_QueryVideoCaptureDeviceNV_adr := GetProcAddress('wglQueryVideoCaptureDeviceNV');
    private z_QueryVideoCaptureDeviceNV_1 := GetProcOrNil&<function(hDc: gdi_device_context; hDevice: wgl_h_video_input_device_NV; iAttribute: Int32; piValue: IntPtr): Bool>(z_QueryVideoCaptureDeviceNV_adr);
    private z_QueryVideoCaptureDeviceNV_2 := GetProcOrNil&<function(hDc: gdi_device_context; hDevice: wgl_h_video_input_device_NV; iAttribute: Int32; var piValue: Int32): Bool>(z_QueryVideoCaptureDeviceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryVideoCaptureDeviceNV(hDc: gdi_device_context; hDevice: wgl_h_video_input_device_NV; iAttribute: Int32; piValue: array of Int32): Bool;
    type PInt32=^Int32;
    begin
      Result := if (piValue<>nil) and (piValue.Length<>0) then
        z_QueryVideoCaptureDeviceNV_2(hDc, hDevice, iAttribute, piValue[0]) else
        z_QueryVideoCaptureDeviceNV_2(hDc, hDevice, iAttribute, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryVideoCaptureDeviceNV(hDc: gdi_device_context; hDevice: wgl_h_video_input_device_NV; iAttribute: Int32; var piValue: Int32): Bool :=
    z_QueryVideoCaptureDeviceNV_2(hDc, hDevice, iAttribute, piValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryVideoCaptureDeviceNV(hDc: gdi_device_context; hDevice: wgl_h_video_input_device_NV; iAttribute: Int32; piValue: IntPtr): Bool :=
    z_QueryVideoCaptureDeviceNV_1(hDc, hDevice, iAttribute, piValue);
    
    private z_ReleaseVideoCaptureDeviceNV_adr := GetProcAddress('wglReleaseVideoCaptureDeviceNV');
    private z_ReleaseVideoCaptureDeviceNV_1 := GetProcOrNil&<function(hDc: gdi_device_context; hDevice: wgl_h_video_input_device_NV): Bool>(z_ReleaseVideoCaptureDeviceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseVideoCaptureDeviceNV(hDc: gdi_device_context; hDevice: wgl_h_video_input_device_NV): Bool :=
    z_ReleaseVideoCaptureDeviceNV_1(hDc, hDevice);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  wglVideoOutputNV = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'wgl_nv_video_output';
    
    private z_GetVideoDeviceNV_adr := GetProcAddress('wglGetVideoDeviceNV');
    private z_GetVideoDeviceNV_1 := GetProcOrNil&<function(hDC: gdi_device_context; numDevices: Int32; hVideoDevice: IntPtr): Bool>(z_GetVideoDeviceNV_adr);
    private z_GetVideoDeviceNV_2 := GetProcOrNil&<function(hDC: gdi_device_context; numDevices: Int32; var hVideoDevice: wgl_h_video_device_NV): Bool>(z_GetVideoDeviceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoDeviceNV(hDC: gdi_device_context; numDevices: Int32; var hVideoDevice: wgl_h_video_device_NV): Bool :=
    z_GetVideoDeviceNV_2(hDC, numDevices, hVideoDevice);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoDeviceNV(hDC: gdi_device_context; numDevices: Int32; hVideoDevice: IntPtr): Bool :=
    z_GetVideoDeviceNV_1(hDC, numDevices, hVideoDevice);
    
    private z_ReleaseVideoDeviceNV_adr := GetProcAddress('wglReleaseVideoDeviceNV');
    private z_ReleaseVideoDeviceNV_1 := GetProcOrNil&<function(hVideoDevice: wgl_h_video_device_NV): Bool>(z_ReleaseVideoDeviceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseVideoDeviceNV(hVideoDevice: wgl_h_video_device_NV): Bool :=
    z_ReleaseVideoDeviceNV_1(hVideoDevice);
    
    private z_BindVideoImageNV_adr := GetProcAddress('wglBindVideoImageNV');
    private z_BindVideoImageNV_1 := GetProcOrNil&<function(hVideoDevice: wgl_h_video_device_NV; hPbuffer: wgl_pbuffer_ARB; iVideoBuffer: Int32): Bool>(z_BindVideoImageNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindVideoImageNV(hVideoDevice: wgl_h_video_device_NV; hPbuffer: wgl_pbuffer_ARB; iVideoBuffer: Int32): Bool :=
    z_BindVideoImageNV_1(hVideoDevice, hPbuffer, iVideoBuffer);
    
    private z_ReleaseVideoImageNV_adr := GetProcAddress('wglReleaseVideoImageNV');
    private z_ReleaseVideoImageNV_1 := GetProcOrNil&<function(hPbuffer: wgl_pbuffer_ARB; iVideoBuffer: Int32): Bool>(z_ReleaseVideoImageNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseVideoImageNV(hPbuffer: wgl_pbuffer_ARB; iVideoBuffer: Int32): Bool :=
    z_ReleaseVideoImageNV_1(hPbuffer, iVideoBuffer);
    
    private z_SendPbufferToVideoNV_adr := GetProcAddress('wglSendPbufferToVideoNV');
    private z_SendPbufferToVideoNV_1 := GetProcOrNil&<function(hPbuffer: wgl_pbuffer_ARB; iBufferType: Int32; pulCounterPbuffer: IntPtr; bBlock: Bool): Bool>(z_SendPbufferToVideoNV_adr);
    private z_SendPbufferToVideoNV_2 := GetProcOrNil&<function(hPbuffer: wgl_pbuffer_ARB; iBufferType: Int32; var pulCounterPbuffer: UInt64; bBlock: Bool): Bool>(z_SendPbufferToVideoNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SendPbufferToVideoNV(hPbuffer: wgl_pbuffer_ARB; iBufferType: Int32; pulCounterPbuffer: array of UInt64; bBlock: Bool): Bool;
    type PUInt64=^UInt64;
    begin
      Result := if (pulCounterPbuffer<>nil) and (pulCounterPbuffer.Length<>0) then
        z_SendPbufferToVideoNV_2(hPbuffer, iBufferType, pulCounterPbuffer[0], bBlock) else
        z_SendPbufferToVideoNV_2(hPbuffer, iBufferType, PUInt64(nil)^, bBlock);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SendPbufferToVideoNV(hPbuffer: wgl_pbuffer_ARB; iBufferType: Int32; var pulCounterPbuffer: UInt64; bBlock: Bool): Bool :=
    z_SendPbufferToVideoNV_2(hPbuffer, iBufferType, pulCounterPbuffer, bBlock);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SendPbufferToVideoNV(hPbuffer: wgl_pbuffer_ARB; iBufferType: Int32; pulCounterPbuffer: IntPtr; bBlock: Bool): Bool :=
    z_SendPbufferToVideoNV_1(hPbuffer, iBufferType, pulCounterPbuffer, bBlock);
    
    private z_GetVideoInfoNV_adr := GetProcAddress('wglGetVideoInfoNV');
    private z_GetVideoInfoNV_1 := GetProcOrNil&<function(hpVideoDevice: wgl_h_video_device_NV; pulCounterOutputPbuffer: IntPtr; pulCounterOutputVideo: IntPtr): Bool>(z_GetVideoInfoNV_adr);
    private z_GetVideoInfoNV_2 := GetProcOrNil&<function(hpVideoDevice: wgl_h_video_device_NV; pulCounterOutputPbuffer: IntPtr; var pulCounterOutputVideo: UInt64): Bool>(z_GetVideoInfoNV_adr);
    private z_GetVideoInfoNV_3 := GetProcOrNil&<function(hpVideoDevice: wgl_h_video_device_NV; var pulCounterOutputPbuffer: UInt64; pulCounterOutputVideo: IntPtr): Bool>(z_GetVideoInfoNV_adr);
    private z_GetVideoInfoNV_4 := GetProcOrNil&<function(hpVideoDevice: wgl_h_video_device_NV; var pulCounterOutputPbuffer: UInt64; var pulCounterOutputVideo: UInt64): Bool>(z_GetVideoInfoNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoInfoNV(hpVideoDevice: wgl_h_video_device_NV; var pulCounterOutputPbuffer: UInt64; var pulCounterOutputVideo: UInt64): Bool :=
    z_GetVideoInfoNV_4(hpVideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoInfoNV(hpVideoDevice: wgl_h_video_device_NV; var pulCounterOutputPbuffer: UInt64; pulCounterOutputVideo: IntPtr): Bool :=
    z_GetVideoInfoNV_3(hpVideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoInfoNV(hpVideoDevice: wgl_h_video_device_NV; pulCounterOutputPbuffer: IntPtr; var pulCounterOutputVideo: UInt64): Bool :=
    z_GetVideoInfoNV_2(hpVideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoInfoNV(hpVideoDevice: wgl_h_video_device_NV; pulCounterOutputPbuffer: IntPtr; pulCounterOutputVideo: IntPtr): Bool :=
    z_GetVideoInfoNV_1(hpVideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  wglVertexArrayRangeNV = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'wgl_nv_vertex_array_range';
    
    private z_AllocateMemoryNV_adr := GetProcAddress('wglAllocateMemoryNV');
    private z_AllocateMemoryNV_1 := GetProcOrNil&<function(size: Int32; readfreq: single; writefreq: single; priority: single): IntPtr>(z_AllocateMemoryNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AllocateMemoryNV(size: Int32; readfreq: single; writefreq: single; priority: single): IntPtr :=
    z_AllocateMemoryNV_1(size, readfreq, writefreq, priority);
    
    private z_FreeMemoryNV_adr := GetProcAddress('wglFreeMemoryNV');
    private z_FreeMemoryNV_1 := GetProcOrNil&<procedure(pointer: IntPtr)>(z_FreeMemoryNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FreeMemoryNV(pointer: IntPtr) :=
    z_FreeMemoryNV_1(pointer);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  wglSyncControlOML = sealed partial class
    private function GetProcAddress(name: string) := wgl.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'wgl_oml_sync_control';
    
    private z_GetSyncValuesOML_adr := GetProcAddress('wglGetSyncValuesOML');
    private z_GetSyncValuesOML_1 := GetProcOrNil&<function(hdc: gdi_device_context; ust: IntPtr; msc: IntPtr; sbc: IntPtr): Bool>(z_GetSyncValuesOML_adr);
    private z_GetSyncValuesOML_2 := GetProcOrNil&<function(hdc: gdi_device_context; ust: IntPtr; msc: IntPtr; var sbc: Int64): Bool>(z_GetSyncValuesOML_adr);
    private z_GetSyncValuesOML_3 := GetProcOrNil&<function(hdc: gdi_device_context; ust: IntPtr; var msc: Int64; sbc: IntPtr): Bool>(z_GetSyncValuesOML_adr);
    private z_GetSyncValuesOML_4 := GetProcOrNil&<function(hdc: gdi_device_context; ust: IntPtr; var msc: Int64; var sbc: Int64): Bool>(z_GetSyncValuesOML_adr);
    private z_GetSyncValuesOML_5 := GetProcOrNil&<function(hdc: gdi_device_context; var ust: Int64; msc: IntPtr; sbc: IntPtr): Bool>(z_GetSyncValuesOML_adr);
    private z_GetSyncValuesOML_6 := GetProcOrNil&<function(hdc: gdi_device_context; var ust: Int64; msc: IntPtr; var sbc: Int64): Bool>(z_GetSyncValuesOML_adr);
    private z_GetSyncValuesOML_7 := GetProcOrNil&<function(hdc: gdi_device_context; var ust: Int64; var msc: Int64; sbc: IntPtr): Bool>(z_GetSyncValuesOML_adr);
    private z_GetSyncValuesOML_8 := GetProcOrNil&<function(hdc: gdi_device_context; var ust: Int64; var msc: Int64; var sbc: Int64): Bool>(z_GetSyncValuesOML_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: gdi_device_context; var ust: Int64; var msc: Int64; var sbc: Int64): Bool :=
    z_GetSyncValuesOML_8(hdc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: gdi_device_context; var ust: Int64; var msc: Int64; sbc: IntPtr): Bool :=
    z_GetSyncValuesOML_7(hdc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: gdi_device_context; var ust: Int64; msc: IntPtr; var sbc: Int64): Bool :=
    z_GetSyncValuesOML_6(hdc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: gdi_device_context; var ust: Int64; msc: IntPtr; sbc: IntPtr): Bool :=
    z_GetSyncValuesOML_5(hdc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: gdi_device_context; ust: IntPtr; var msc: Int64; var sbc: Int64): Bool :=
    z_GetSyncValuesOML_4(hdc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: gdi_device_context; ust: IntPtr; var msc: Int64; sbc: IntPtr): Bool :=
    z_GetSyncValuesOML_3(hdc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: gdi_device_context; ust: IntPtr; msc: IntPtr; var sbc: Int64): Bool :=
    z_GetSyncValuesOML_2(hdc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: gdi_device_context; ust: IntPtr; msc: IntPtr; sbc: IntPtr): Bool :=
    z_GetSyncValuesOML_1(hdc, ust, msc, sbc);
    
    private z_GetMscRateOML_adr := GetProcAddress('wglGetMscRateOML');
    private z_GetMscRateOML_1 := GetProcOrNil&<function(hdc: gdi_device_context; numerator: IntPtr; denominator: IntPtr): Bool>(z_GetMscRateOML_adr);
    private z_GetMscRateOML_2 := GetProcOrNil&<function(hdc: gdi_device_context; numerator: IntPtr; var denominator: Int32): Bool>(z_GetMscRateOML_adr);
    private z_GetMscRateOML_3 := GetProcOrNil&<function(hdc: gdi_device_context; var numerator: Int32; denominator: IntPtr): Bool>(z_GetMscRateOML_adr);
    private z_GetMscRateOML_4 := GetProcOrNil&<function(hdc: gdi_device_context; var numerator: Int32; var denominator: Int32): Bool>(z_GetMscRateOML_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMscRateOML(hdc: gdi_device_context; var numerator: Int32; var denominator: Int32): Bool :=
    z_GetMscRateOML_4(hdc, numerator, denominator);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMscRateOML(hdc: gdi_device_context; var numerator: Int32; denominator: IntPtr): Bool :=
    z_GetMscRateOML_3(hdc, numerator, denominator);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMscRateOML(hdc: gdi_device_context; numerator: IntPtr; var denominator: Int32): Bool :=
    z_GetMscRateOML_2(hdc, numerator, denominator);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMscRateOML(hdc: gdi_device_context; numerator: IntPtr; denominator: IntPtr): Bool :=
    z_GetMscRateOML_1(hdc, numerator, denominator);
    
    private z_SwapBuffersMscOML_adr := GetProcAddress('wglSwapBuffersMscOML');
    private z_SwapBuffersMscOML_1 := GetProcOrNil&<function(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64): Int64>(z_SwapBuffersMscOML_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SwapBuffersMscOML(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64): Int64 :=
    z_SwapBuffersMscOML_1(hdc, target_msc, divisor, remainder);
    
    private z_SwapLayerBuffersMscOML_adr := GetProcAddress('wglSwapLayerBuffersMscOML');
    private z_SwapLayerBuffersMscOML_1 := GetProcOrNil&<function(hdc: gdi_device_context; fuPlanes: Int32; target_msc: Int64; divisor: Int64; remainder: Int64): Int64>(z_SwapLayerBuffersMscOML_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SwapLayerBuffersMscOML(hdc: gdi_device_context; fuPlanes: Int32; target_msc: Int64; divisor: Int64; remainder: Int64): Int64 :=
    z_SwapLayerBuffersMscOML_1(hdc, fuPlanes, target_msc, divisor, remainder);
    
    private z_WaitForMscOML_adr := GetProcAddress('wglWaitForMscOML');
    private z_WaitForMscOML_1 := GetProcOrNil&<function(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64; ust: IntPtr; msc: IntPtr; sbc: IntPtr): Bool>(z_WaitForMscOML_adr);
    private z_WaitForMscOML_2 := GetProcOrNil&<function(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64; ust: IntPtr; msc: IntPtr; var sbc: Int64): Bool>(z_WaitForMscOML_adr);
    private z_WaitForMscOML_3 := GetProcOrNil&<function(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64; ust: IntPtr; var msc: Int64; sbc: IntPtr): Bool>(z_WaitForMscOML_adr);
    private z_WaitForMscOML_4 := GetProcOrNil&<function(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64; ust: IntPtr; var msc: Int64; var sbc: Int64): Bool>(z_WaitForMscOML_adr);
    private z_WaitForMscOML_5 := GetProcOrNil&<function(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: IntPtr; sbc: IntPtr): Bool>(z_WaitForMscOML_adr);
    private z_WaitForMscOML_6 := GetProcOrNil&<function(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: IntPtr; var sbc: Int64): Bool>(z_WaitForMscOML_adr);
    private z_WaitForMscOML_7 := GetProcOrNil&<function(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; var msc: Int64; sbc: IntPtr): Bool>(z_WaitForMscOML_adr);
    private z_WaitForMscOML_8 := GetProcOrNil&<function(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; var msc: Int64; var sbc: Int64): Bool>(z_WaitForMscOML_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; msc: array of Int64; sbc: array of Int64): Bool;
    type PInt64=^Int64;
    begin
      Result := if (sbc<>nil) and (sbc.Length<>0) then
        if (msc<>nil) and (msc.Length<>0) then
          if (ust<>nil) and (ust.Length<>0) then
            z_WaitForMscOML_8(hdc, target_msc, divisor, remainder, ust[0], msc[0], sbc[0]) else
            z_WaitForMscOML_8(hdc, target_msc, divisor, remainder, PInt64(nil)^, msc[0], sbc[0]) else
          if (ust<>nil) and (ust.Length<>0) then
            z_WaitForMscOML_8(hdc, target_msc, divisor, remainder, ust[0], PInt64(nil)^, sbc[0]) else
            z_WaitForMscOML_8(hdc, target_msc, divisor, remainder, PInt64(nil)^, PInt64(nil)^, sbc[0]) else
        if (msc<>nil) and (msc.Length<>0) then
          if (ust<>nil) and (ust.Length<>0) then
            z_WaitForMscOML_8(hdc, target_msc, divisor, remainder, ust[0], msc[0], PInt64(nil)^) else
            z_WaitForMscOML_8(hdc, target_msc, divisor, remainder, PInt64(nil)^, msc[0], PInt64(nil)^) else
          if (ust<>nil) and (ust.Length<>0) then
            z_WaitForMscOML_8(hdc, target_msc, divisor, remainder, ust[0], PInt64(nil)^, PInt64(nil)^) else
            z_WaitForMscOML_8(hdc, target_msc, divisor, remainder, PInt64(nil)^, PInt64(nil)^, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; var msc: Int64; var sbc: Int64): Bool :=
    z_WaitForMscOML_8(hdc, target_msc, divisor, remainder, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; var msc: Int64; sbc: IntPtr): Bool :=
    z_WaitForMscOML_7(hdc, target_msc, divisor, remainder, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: IntPtr; var sbc: Int64): Bool :=
    z_WaitForMscOML_6(hdc, target_msc, divisor, remainder, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: IntPtr; sbc: IntPtr): Bool :=
    z_WaitForMscOML_5(hdc, target_msc, divisor, remainder, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64; ust: IntPtr; var msc: Int64; var sbc: Int64): Bool :=
    z_WaitForMscOML_4(hdc, target_msc, divisor, remainder, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64; ust: IntPtr; var msc: Int64; sbc: IntPtr): Bool :=
    z_WaitForMscOML_3(hdc, target_msc, divisor, remainder, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64; ust: IntPtr; msc: IntPtr; var sbc: Int64): Bool :=
    z_WaitForMscOML_2(hdc, target_msc, divisor, remainder, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: gdi_device_context; target_msc: Int64; divisor: Int64; remainder: Int64; ust: IntPtr; msc: IntPtr; sbc: IntPtr): Bool :=
    z_WaitForMscOML_1(hdc, target_msc, divisor, remainder, ust, msc, sbc);
    
    private z_WaitForSbcOML_adr := GetProcAddress('wglWaitForSbcOML');
    private z_WaitForSbcOML_1 := GetProcOrNil&<function(hdc: gdi_device_context; target_sbc: Int64; ust: IntPtr; msc: IntPtr; sbc: IntPtr): Bool>(z_WaitForSbcOML_adr);
    private z_WaitForSbcOML_2 := GetProcOrNil&<function(hdc: gdi_device_context; target_sbc: Int64; ust: IntPtr; msc: IntPtr; var sbc: Int64): Bool>(z_WaitForSbcOML_adr);
    private z_WaitForSbcOML_3 := GetProcOrNil&<function(hdc: gdi_device_context; target_sbc: Int64; ust: IntPtr; var msc: Int64; sbc: IntPtr): Bool>(z_WaitForSbcOML_adr);
    private z_WaitForSbcOML_4 := GetProcOrNil&<function(hdc: gdi_device_context; target_sbc: Int64; ust: IntPtr; var msc: Int64; var sbc: Int64): Bool>(z_WaitForSbcOML_adr);
    private z_WaitForSbcOML_5 := GetProcOrNil&<function(hdc: gdi_device_context; target_sbc: Int64; var ust: Int64; msc: IntPtr; sbc: IntPtr): Bool>(z_WaitForSbcOML_adr);
    private z_WaitForSbcOML_6 := GetProcOrNil&<function(hdc: gdi_device_context; target_sbc: Int64; var ust: Int64; msc: IntPtr; var sbc: Int64): Bool>(z_WaitForSbcOML_adr);
    private z_WaitForSbcOML_7 := GetProcOrNil&<function(hdc: gdi_device_context; target_sbc: Int64; var ust: Int64; var msc: Int64; sbc: IntPtr): Bool>(z_WaitForSbcOML_adr);
    private z_WaitForSbcOML_8 := GetProcOrNil&<function(hdc: gdi_device_context; target_sbc: Int64; var ust: Int64; var msc: Int64; var sbc: Int64): Bool>(z_WaitForSbcOML_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: gdi_device_context; target_sbc: Int64; ust: array of Int64; msc: array of Int64; sbc: array of Int64): Bool;
    type PInt64=^Int64;
    begin
      Result := if (sbc<>nil) and (sbc.Length<>0) then
        if (msc<>nil) and (msc.Length<>0) then
          if (ust<>nil) and (ust.Length<>0) then
            z_WaitForSbcOML_8(hdc, target_sbc, ust[0], msc[0], sbc[0]) else
            z_WaitForSbcOML_8(hdc, target_sbc, PInt64(nil)^, msc[0], sbc[0]) else
          if (ust<>nil) and (ust.Length<>0) then
            z_WaitForSbcOML_8(hdc, target_sbc, ust[0], PInt64(nil)^, sbc[0]) else
            z_WaitForSbcOML_8(hdc, target_sbc, PInt64(nil)^, PInt64(nil)^, sbc[0]) else
        if (msc<>nil) and (msc.Length<>0) then
          if (ust<>nil) and (ust.Length<>0) then
            z_WaitForSbcOML_8(hdc, target_sbc, ust[0], msc[0], PInt64(nil)^) else
            z_WaitForSbcOML_8(hdc, target_sbc, PInt64(nil)^, msc[0], PInt64(nil)^) else
          if (ust<>nil) and (ust.Length<>0) then
            z_WaitForSbcOML_8(hdc, target_sbc, ust[0], PInt64(nil)^, PInt64(nil)^) else
            z_WaitForSbcOML_8(hdc, target_sbc, PInt64(nil)^, PInt64(nil)^, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: gdi_device_context; target_sbc: Int64; var ust: Int64; var msc: Int64; var sbc: Int64): Bool :=
    z_WaitForSbcOML_8(hdc, target_sbc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: gdi_device_context; target_sbc: Int64; var ust: Int64; var msc: Int64; sbc: IntPtr): Bool :=
    z_WaitForSbcOML_7(hdc, target_sbc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: gdi_device_context; target_sbc: Int64; var ust: Int64; msc: IntPtr; var sbc: Int64): Bool :=
    z_WaitForSbcOML_6(hdc, target_sbc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: gdi_device_context; target_sbc: Int64; var ust: Int64; msc: IntPtr; sbc: IntPtr): Bool :=
    z_WaitForSbcOML_5(hdc, target_sbc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: gdi_device_context; target_sbc: Int64; ust: IntPtr; var msc: Int64; var sbc: Int64): Bool :=
    z_WaitForSbcOML_4(hdc, target_sbc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: gdi_device_context; target_sbc: Int64; ust: IntPtr; var msc: Int64; sbc: IntPtr): Bool :=
    z_WaitForSbcOML_3(hdc, target_sbc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: gdi_device_context; target_sbc: Int64; ust: IntPtr; msc: IntPtr; var sbc: Int64): Bool :=
    z_WaitForSbcOML_2(hdc, target_sbc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: gdi_device_context; target_sbc: Int64; ust: IntPtr; msc: IntPtr; sbc: IntPtr): Bool :=
    z_WaitForSbcOML_1(hdc, target_sbc, ust, msc, sbc);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glxGpuAssociationAMD = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'glx_amd_gpu_association';
    
    private z_GetGPUIDsAMD_adr := GetProcAddress('glXGetGPUIDsAMD');
    private z_GetGPUIDsAMD_1 := GetProcOrNil&<function(maxCount: UInt32; ids: IntPtr): UInt32>(z_GetGPUIDsAMD_adr);
    private z_GetGPUIDsAMD_2 := GetProcOrNil&<function(maxCount: UInt32; var ids: UInt32): UInt32>(z_GetGPUIDsAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGPUIDsAMD(maxCount: UInt32; var ids: UInt32): UInt32 :=
    z_GetGPUIDsAMD_2(maxCount, ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGPUIDsAMD(maxCount: UInt32; ids: IntPtr): UInt32 :=
    z_GetGPUIDsAMD_1(maxCount, ids);
    
    private z_GetGPUInfoAMD_adr := GetProcAddress('glXGetGPUInfoAMD');
    private z_GetGPUInfoAMD_1 := GetProcOrNil&<function(id: UInt32; &property: Int32; dataType: DummyEnum; size: UInt32; data: IntPtr): Int32>(z_GetGPUInfoAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGPUInfoAMD(id: UInt32; &property: Int32; dataType: DummyEnum; size: UInt32; data: IntPtr): Int32 :=
    z_GetGPUInfoAMD_1(id, &property, dataType, size, data);
    
    private z_GetContextGPUIDAMD_adr := GetProcAddress('glXGetContextGPUIDAMD');
    private z_GetContextGPUIDAMD_1 := GetProcOrNil&<function(ctx: glx_context): UInt32>(z_GetContextGPUIDAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetContextGPUIDAMD(ctx: glx_context): UInt32 :=
    z_GetContextGPUIDAMD_1(ctx);
    
    private z_CreateAssociatedContextAMD_adr := GetProcAddress('glXCreateAssociatedContextAMD');
    private z_CreateAssociatedContextAMD_1 := GetProcOrNil&<function(id: UInt32; share_list: glx_context): glx_context>(z_CreateAssociatedContextAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAssociatedContextAMD(id: UInt32; share_list: glx_context): glx_context :=
    z_CreateAssociatedContextAMD_1(id, share_list);
    
    private z_CreateAssociatedContextAttribsAMD_adr := GetProcAddress('glXCreateAssociatedContextAttribsAMD');
    private z_CreateAssociatedContextAttribsAMD_1 := GetProcOrNil&<function(id: UInt32; share_context: glx_context; attribList: IntPtr): glx_context>(z_CreateAssociatedContextAttribsAMD_adr);
    private z_CreateAssociatedContextAttribsAMD_2 := GetProcOrNil&<function(id: UInt32; share_context: glx_context; var attribList: Int32): glx_context>(z_CreateAssociatedContextAttribsAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAssociatedContextAttribsAMD(id: UInt32; share_context: glx_context; attribList: array of Int32): glx_context;
    type PInt32=^Int32;
    begin
      Result := if (attribList<>nil) and (attribList.Length<>0) then
        z_CreateAssociatedContextAttribsAMD_2(id, share_context, attribList[0]) else
        z_CreateAssociatedContextAttribsAMD_2(id, share_context, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAssociatedContextAttribsAMD(id: UInt32; share_context: glx_context; var attribList: Int32): glx_context :=
    z_CreateAssociatedContextAttribsAMD_2(id, share_context, attribList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAssociatedContextAttribsAMD(id: UInt32; share_context: glx_context; attribList: IntPtr): glx_context :=
    z_CreateAssociatedContextAttribsAMD_1(id, share_context, attribList);
    
    private z_DeleteAssociatedContextAMD_adr := GetProcAddress('glXDeleteAssociatedContextAMD');
    private z_DeleteAssociatedContextAMD_1 := GetProcOrNil&<function(ctx: glx_context): Bool>(z_DeleteAssociatedContextAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DeleteAssociatedContextAMD(ctx: glx_context): Bool :=
    z_DeleteAssociatedContextAMD_1(ctx);
    
    private z_MakeAssociatedContextCurrentAMD_adr := GetProcAddress('glXMakeAssociatedContextCurrentAMD');
    private z_MakeAssociatedContextCurrentAMD_1 := GetProcOrNil&<function(ctx: glx_context): Bool>(z_MakeAssociatedContextCurrentAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MakeAssociatedContextCurrentAMD(ctx: glx_context): Bool :=
    z_MakeAssociatedContextCurrentAMD_1(ctx);
    
    private z_GetCurrentAssociatedContextAMD_adr := GetProcAddress('glXGetCurrentAssociatedContextAMD');
    private z_GetCurrentAssociatedContextAMD_1 := GetProcOrNil&<function: glx_context>(z_GetCurrentAssociatedContextAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCurrentAssociatedContextAMD: glx_context :=
    z_GetCurrentAssociatedContextAMD_1();
    
    private z_BlitContextFramebufferAMD_adr := GetProcAddress('glXBlitContextFramebufferAMD');
    private z_BlitContextFramebufferAMD_1 := GetProcOrNil&<procedure(dstCtx: glx_context; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: DummyFlags; filter: DummyEnum)>(z_BlitContextFramebufferAMD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlitContextFramebufferAMD(dstCtx: glx_context; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: DummyFlags; filter: DummyEnum) :=
    z_BlitContextFramebufferAMD_1(dstCtx, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glxCreateContextARB = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'glx_arb_create_context';
    
    private z_CreateContextAttribsARB_adr := GetProcAddress('glXCreateContextAttribsARB');
    private z_CreateContextAttribsARB_1 := GetProcOrNil&<function(dpy: x_p_display; config: glx_fb_config; share_context: glx_context; direct: Bool; attrib_list: IntPtr): glx_context>(z_CreateContextAttribsARB_adr);
    private z_CreateContextAttribsARB_2 := GetProcOrNil&<function(dpy: x_p_display; config: glx_fb_config; share_context: glx_context; direct: Bool; var attrib_list: Int32): glx_context>(z_CreateContextAttribsARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateContextAttribsARB(dpy: x_p_display; config: glx_fb_config; share_context: glx_context; direct: Bool; attrib_list: array of Int32): glx_context;
    type PInt32=^Int32;
    begin
      Result := if (attrib_list<>nil) and (attrib_list.Length<>0) then
        z_CreateContextAttribsARB_2(dpy, config, share_context, direct, attrib_list[0]) else
        z_CreateContextAttribsARB_2(dpy, config, share_context, direct, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateContextAttribsARB(dpy: x_p_display; config: glx_fb_config; share_context: glx_context; direct: Bool; var attrib_list: Int32): glx_context :=
    z_CreateContextAttribsARB_2(dpy, config, share_context, direct, attrib_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateContextAttribsARB(dpy: x_p_display; config: glx_fb_config; share_context: glx_context; direct: Bool; attrib_list: IntPtr): glx_context :=
    z_CreateContextAttribsARB_1(dpy, config, share_context, direct, attrib_list);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glxGetProcAddressARB = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'glx_arb_get_proc_address';
    
    private z_GetProcAddressARB_adr := GetProcAddress('glXGetProcAddressARB');
    private z_GetProcAddressARB_1 := GetProcOrNil&<function(procName: IntPtr): IntPtr>(z_GetProcAddressARB_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProcAddressARB(procName: string): IntPtr;
    begin
      var procName_str_ptr: IntPtr;
      try
        procName_str_ptr := Marshal.StringToHGlobalAnsi(procName);
        Result := z_GetProcAddressARB_1(procName_str_ptr);
      finally
        Marshal.FreeHGlobal(procName_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProcAddressARB(procName: IntPtr): IntPtr :=
    z_GetProcAddressARB_1(procName);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glxImportContextEXT = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'glx_ext_import_context';
    
    private z_GetCurrentDisplayEXT_adr := GetProcAddress('glXGetCurrentDisplayEXT');
    private z_GetCurrentDisplayEXT_1 := GetProcOrNil&<function: x_p_display>(z_GetCurrentDisplayEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCurrentDisplayEXT: x_p_display :=
    z_GetCurrentDisplayEXT_1();
    
    private z_QueryContextInfoEXT_adr := GetProcAddress('glXQueryContextInfoEXT');
    private z_QueryContextInfoEXT_1 := GetProcOrNil&<function(dpy: x_p_display; context: glx_context; attribute: Int32; value: IntPtr): Int32>(z_QueryContextInfoEXT_adr);
    private z_QueryContextInfoEXT_2 := GetProcOrNil&<function(dpy: x_p_display; context: glx_context; attribute: Int32; var value: Int32): Int32>(z_QueryContextInfoEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryContextInfoEXT(dpy: x_p_display; context: glx_context; attribute: Int32; value: array of Int32): Int32;
    type PInt32=^Int32;
    begin
      Result := if (value<>nil) and (value.Length<>0) then
        z_QueryContextInfoEXT_2(dpy, context, attribute, value[0]) else
        z_QueryContextInfoEXT_2(dpy, context, attribute, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryContextInfoEXT(dpy: x_p_display; context: glx_context; attribute: Int32; var value: Int32): Int32 :=
    z_QueryContextInfoEXT_2(dpy, context, attribute, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryContextInfoEXT(dpy: x_p_display; context: glx_context; attribute: Int32; value: IntPtr): Int32 :=
    z_QueryContextInfoEXT_1(dpy, context, attribute, value);
    
    private z_GetContextIDEXT_adr := GetProcAddress('glXGetContextIDEXT');
    private z_GetContextIDEXT_1 := GetProcOrNil&<function(context: glx_context): glx_context_id>(z_GetContextIDEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetContextIDEXT(context: glx_context): glx_context_id :=
    z_GetContextIDEXT_1(context);
    
    private z_ImportContextEXT_adr := GetProcAddress('glXImportContextEXT');
    private z_ImportContextEXT_1 := GetProcOrNil&<function(dpy: x_p_display; contextID: glx_context_id): glx_context>(z_ImportContextEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ImportContextEXT(dpy: x_p_display; contextID: glx_context_id): glx_context :=
    z_ImportContextEXT_1(dpy, contextID);
    
    private z_FreeContextEXT_adr := GetProcAddress('glXFreeContextEXT');
    private z_FreeContextEXT_1 := GetProcOrNil&<procedure(dpy: x_p_display; context: glx_context)>(z_FreeContextEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FreeContextEXT(dpy: x_p_display; context: glx_context) :=
    z_FreeContextEXT_1(dpy, context);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glxSwapControlEXT = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'glx_ext_swap_control';
    
    private z_SwapIntervalEXT_adr := GetProcAddress('glXSwapIntervalEXT');
    private z_SwapIntervalEXT_1 := GetProcOrNil&<procedure(dpy: x_p_display; drawable: glx_drawable; interval: Int32)>(z_SwapIntervalEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SwapIntervalEXT(dpy: x_p_display; drawable: glx_drawable; interval: Int32) :=
    z_SwapIntervalEXT_1(dpy, drawable, interval);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glxTextureFromPixmapEXT = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'glx_ext_texture_from_pixmap';
    
    private z_BindTexImageEXT_adr := GetProcAddress('glXBindTexImageEXT');
    private z_BindTexImageEXT_1 := GetProcOrNil&<procedure(dpy: x_p_display; drawable: glx_drawable; buffer: Int32; attrib_list: IntPtr)>(z_BindTexImageEXT_adr);
    private z_BindTexImageEXT_2 := GetProcOrNil&<procedure(dpy: x_p_display; drawable: glx_drawable; buffer: Int32; var attrib_list: Int32)>(z_BindTexImageEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTexImageEXT(dpy: x_p_display; drawable: glx_drawable; buffer: Int32; attrib_list: array of Int32);
    type PInt32=^Int32;
    begin
      if (attrib_list<>nil) and (attrib_list.Length<>0) then
        z_BindTexImageEXT_2(dpy, drawable, buffer, attrib_list[0]) else
        z_BindTexImageEXT_2(dpy, drawable, buffer, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTexImageEXT(dpy: x_p_display; drawable: glx_drawable; buffer: Int32; var attrib_list: Int32) :=
    z_BindTexImageEXT_2(dpy, drawable, buffer, attrib_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTexImageEXT(dpy: x_p_display; drawable: glx_drawable; buffer: Int32; attrib_list: IntPtr) :=
    z_BindTexImageEXT_1(dpy, drawable, buffer, attrib_list);
    
    private z_ReleaseTexImageEXT_adr := GetProcAddress('glXReleaseTexImageEXT');
    private z_ReleaseTexImageEXT_1 := GetProcOrNil&<procedure(dpy: x_p_display; drawable: glx_drawable; buffer: Int32)>(z_ReleaseTexImageEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReleaseTexImageEXT(dpy: x_p_display; drawable: glx_drawable; buffer: Int32) :=
    z_ReleaseTexImageEXT_1(dpy, drawable, buffer);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glxAgpOffsetMESA = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'glx_mesa_agp_offset';
    
    private z_GetAGPOffsetMESA_adr := GetProcAddress('glXGetAGPOffsetMESA');
    private z_GetAGPOffsetMESA_1 := GetProcOrNil&<function(pointer: IntPtr): UInt32>(z_GetAGPOffsetMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetAGPOffsetMESA(pointer: IntPtr): UInt32 :=
    z_GetAGPOffsetMESA_1(pointer);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glxCopySubBufferMESA = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'glx_mesa_copy_sub_buffer';
    
    private z_CopySubBufferMESA_adr := GetProcAddress('glXCopySubBufferMESA');
    private z_CopySubBufferMESA_1 := GetProcOrNil&<procedure(dpy: x_p_display; drawable: glx_drawable; x: Int32; y: Int32; width: Int32; height: Int32)>(z_CopySubBufferMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopySubBufferMESA(dpy: x_p_display; drawable: glx_drawable; x: Int32; y: Int32; width: Int32; height: Int32) :=
    z_CopySubBufferMESA_1(dpy, drawable, x, y, width, height);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glxPixmapColormapMESA = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'glx_mesa_pixmap_colormap';
    
    private z_CreateGLXPixmapMESA_adr := GetProcAddress('glXCreateGLXPixmapMESA');
    private z_CreateGLXPixmapMESA_1 := GetProcOrNil&<function(dpy: x_p_display; visual: x_p_visual_info; pixmap: x_pixmap; cmap: x_colormap): glx_pixmap>(z_CreateGLXPixmapMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateGLXPixmapMESA(dpy: x_p_display; visual: x_p_visual_info; pixmap: x_pixmap; cmap: x_colormap): glx_pixmap :=
    z_CreateGLXPixmapMESA_1(dpy, visual, pixmap, cmap);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glxQueryRendererMESA = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'glx_mesa_query_renderer';
    
    private z_QueryCurrentRendererIntegerMESA_adr := GetProcAddress('glXQueryCurrentRendererIntegerMESA');
    private z_QueryCurrentRendererIntegerMESA_1 := GetProcOrNil&<function(attribute: Int32; value: IntPtr): Bool>(z_QueryCurrentRendererIntegerMESA_adr);
    private z_QueryCurrentRendererIntegerMESA_2 := GetProcOrNil&<function(attribute: Int32; var value: UInt32): Bool>(z_QueryCurrentRendererIntegerMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryCurrentRendererIntegerMESA(attribute: Int32; value: array of UInt32): Bool;
    type PUInt32=^UInt32;
    begin
      Result := if (value<>nil) and (value.Length<>0) then
        z_QueryCurrentRendererIntegerMESA_2(attribute, value[0]) else
        z_QueryCurrentRendererIntegerMESA_2(attribute, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryCurrentRendererIntegerMESA(attribute: Int32; var value: UInt32): Bool :=
    z_QueryCurrentRendererIntegerMESA_2(attribute, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryCurrentRendererIntegerMESA(attribute: Int32; value: IntPtr): Bool :=
    z_QueryCurrentRendererIntegerMESA_1(attribute, value);
    
    private z_QueryCurrentRendererStringMESA_adr := GetProcAddress('glXQueryCurrentRendererStringMESA');
    private z_QueryCurrentRendererStringMESA_1 := GetProcOrNil&<function(attribute: Int32): IntPtr>(z_QueryCurrentRendererStringMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryCurrentRendererStringMESA(attribute: Int32): string;
    begin
      var Result_str_ptr: IntPtr;
      Result_str_ptr := z_QueryCurrentRendererStringMESA_1(attribute);
      Result := Marshal.PtrToStringAnsi(Result_str_ptr);
    end;
    
    private z_QueryRendererIntegerMESA_adr := GetProcAddress('glXQueryRendererIntegerMESA');
    private z_QueryRendererIntegerMESA_1 := GetProcOrNil&<function(dpy: x_p_display; screen: Int32; renderer: Int32; attribute: Int32; value: IntPtr): Bool>(z_QueryRendererIntegerMESA_adr);
    private z_QueryRendererIntegerMESA_2 := GetProcOrNil&<function(dpy: x_p_display; screen: Int32; renderer: Int32; attribute: Int32; var value: UInt32): Bool>(z_QueryRendererIntegerMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryRendererIntegerMESA(dpy: x_p_display; screen: Int32; renderer: Int32; attribute: Int32; value: array of UInt32): Bool;
    type PUInt32=^UInt32;
    begin
      Result := if (value<>nil) and (value.Length<>0) then
        z_QueryRendererIntegerMESA_2(dpy, screen, renderer, attribute, value[0]) else
        z_QueryRendererIntegerMESA_2(dpy, screen, renderer, attribute, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryRendererIntegerMESA(dpy: x_p_display; screen: Int32; renderer: Int32; attribute: Int32; var value: UInt32): Bool :=
    z_QueryRendererIntegerMESA_2(dpy, screen, renderer, attribute, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryRendererIntegerMESA(dpy: x_p_display; screen: Int32; renderer: Int32; attribute: Int32; value: IntPtr): Bool :=
    z_QueryRendererIntegerMESA_1(dpy, screen, renderer, attribute, value);
    
    private z_QueryRendererStringMESA_adr := GetProcAddress('glXQueryRendererStringMESA');
    private z_QueryRendererStringMESA_1 := GetProcOrNil&<function(dpy: x_p_display; screen: Int32; renderer: Int32; attribute: Int32): IntPtr>(z_QueryRendererStringMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryRendererStringMESA(dpy: x_p_display; screen: Int32; renderer: Int32; attribute: Int32): string;
    begin
      var Result_str_ptr: IntPtr;
      Result_str_ptr := z_QueryRendererStringMESA_1(dpy, screen, renderer, attribute);
      Result := Marshal.PtrToStringAnsi(Result_str_ptr);
    end;
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glxReleaseBuffersMESA = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'glx_mesa_release_buffers';
    
    private z_ReleaseBuffersMESA_adr := GetProcAddress('glXReleaseBuffersMESA');
    private z_ReleaseBuffersMESA_1 := GetProcOrNil&<function(dpy: x_p_display; drawable: glx_drawable): Bool>(z_ReleaseBuffersMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseBuffersMESA(dpy: x_p_display; drawable: glx_drawable): Bool :=
    z_ReleaseBuffersMESA_1(dpy, drawable);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glxSet3dfxModeMESA = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'glx_mesa_set_3dfx_mode';
    
    private z_Set3DfxModeMESA_adr := GetProcAddress('glXSet3DfxModeMESA');
    private z_Set3DfxModeMESA_1 := GetProcOrNil&<function(mode: Int32): boolean>(z_Set3DfxModeMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function Set3DfxModeMESA(mode: Int32): boolean :=
    z_Set3DfxModeMESA_1(mode);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glxSwapControlMESA = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'glx_mesa_swap_control';
    
    private z_GetSwapIntervalMESA_adr := GetProcAddress('glXGetSwapIntervalMESA');
    private z_GetSwapIntervalMESA_1 := GetProcOrNil&<function: Int32>(z_GetSwapIntervalMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSwapIntervalMESA: Int32 :=
    z_GetSwapIntervalMESA_1();
    
    private z_SwapIntervalMESA_adr := GetProcAddress('glXSwapIntervalMESA');
    private z_SwapIntervalMESA_1 := GetProcOrNil&<function(interval: UInt32): Int32>(z_SwapIntervalMESA_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SwapIntervalMESA(interval: UInt32): Int32 :=
    z_SwapIntervalMESA_1(interval);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glxCopyBufferNV = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'glx_nv_copy_buffer';
    
    private z_CopyBufferSubDataNV_adr := GetProcAddress('glXCopyBufferSubDataNV');
    private z_CopyBufferSubDataNV_1 := GetProcOrNil&<procedure(dpy: x_p_display; readCtx: glx_context; writeCtx: glx_context; readTarget: DummyEnum; writeTarget: DummyEnum; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr)>(z_CopyBufferSubDataNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyBufferSubDataNV(dpy: x_p_display; readCtx: glx_context; writeCtx: glx_context; readTarget: DummyEnum; writeTarget: DummyEnum; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr) :=
    z_CopyBufferSubDataNV_1(dpy, readCtx, writeCtx, readTarget, writeTarget, readOffset, writeOffset, size);
    
    private z_NamedCopyBufferSubDataNV_adr := GetProcAddress('glXNamedCopyBufferSubDataNV');
    private z_NamedCopyBufferSubDataNV_1 := GetProcOrNil&<procedure(dpy: x_p_display; readCtx: glx_context; writeCtx: glx_context; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr)>(z_NamedCopyBufferSubDataNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedCopyBufferSubDataNV(dpy: x_p_display; readCtx: glx_context; writeCtx: glx_context; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr) :=
    z_NamedCopyBufferSubDataNV_1(dpy, readCtx, writeCtx, readBuffer, writeBuffer, readOffset, writeOffset, size);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glxCopyImageNV = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'glx_nv_copy_image';
    
    private z_CopyImageSubDataNV_adr := GetProcAddress('glXCopyImageSubDataNV');
    private z_CopyImageSubDataNV_1 := GetProcOrNil&<procedure(dpy: x_p_display; srcCtx: glx_context; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstCtx: glx_context; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; width: Int32; height: Int32; depth: Int32)>(z_CopyImageSubDataNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyImageSubDataNV(dpy: x_p_display; srcCtx: glx_context; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstCtx: glx_context; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; width: Int32; height: Int32; depth: Int32) :=
    z_CopyImageSubDataNV_1(dpy, srcCtx, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstCtx, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glxDelayBeforeSwapNV = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'glx_nv_delay_before_swap';
    
    private z_DelayBeforeSwapNV_adr := GetProcAddress('glXDelayBeforeSwapNV');
    private z_DelayBeforeSwapNV_1 := GetProcOrNil&<function(dpy: x_p_display; drawable: glx_drawable; seconds: single): Bool>(z_DelayBeforeSwapNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DelayBeforeSwapNV(dpy: x_p_display; drawable: glx_drawable; seconds: single): Bool :=
    z_DelayBeforeSwapNV_1(dpy, drawable, seconds);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glxPresentVideoNV = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'glx_nv_present_video';
    
    private z_EnumerateVideoDevicesNV_adr := GetProcAddress('glXEnumerateVideoDevicesNV');
    private z_EnumerateVideoDevicesNV_1 := GetProcOrNil&<function(dpy: x_p_display; screen: Int32; nelements: IntPtr): ^UInt32>(z_EnumerateVideoDevicesNV_adr);
    private z_EnumerateVideoDevicesNV_2 := GetProcOrNil&<function(dpy: x_p_display; screen: Int32; var nelements: Int32): ^UInt32>(z_EnumerateVideoDevicesNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumerateVideoDevicesNV(dpy: x_p_display; screen: Int32; nelements: array of Int32): ^UInt32;
    type PInt32=^Int32;
    begin
      Result := if (nelements<>nil) and (nelements.Length<>0) then
        z_EnumerateVideoDevicesNV_2(dpy, screen, nelements[0]) else
        z_EnumerateVideoDevicesNV_2(dpy, screen, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumerateVideoDevicesNV(dpy: x_p_display; screen: Int32; var nelements: Int32): ^UInt32 :=
    z_EnumerateVideoDevicesNV_2(dpy, screen, nelements);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumerateVideoDevicesNV(dpy: x_p_display; screen: Int32; nelements: IntPtr): ^UInt32 :=
    z_EnumerateVideoDevicesNV_1(dpy, screen, nelements);
    
    private z_BindVideoDeviceNV_adr := GetProcAddress('glXBindVideoDeviceNV');
    private z_BindVideoDeviceNV_1 := GetProcOrNil&<function(dpy: x_p_display; video_slot: UInt32; video_device: UInt32; attrib_list: IntPtr): Int32>(z_BindVideoDeviceNV_adr);
    private z_BindVideoDeviceNV_2 := GetProcOrNil&<function(dpy: x_p_display; video_slot: UInt32; video_device: UInt32; var attrib_list: Int32): Int32>(z_BindVideoDeviceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindVideoDeviceNV(dpy: x_p_display; video_slot: UInt32; video_device: UInt32; attrib_list: array of Int32): Int32;
    type PInt32=^Int32;
    begin
      Result := if (attrib_list<>nil) and (attrib_list.Length<>0) then
        z_BindVideoDeviceNV_2(dpy, video_slot, video_device, attrib_list[0]) else
        z_BindVideoDeviceNV_2(dpy, video_slot, video_device, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindVideoDeviceNV(dpy: x_p_display; video_slot: UInt32; video_device: UInt32; var attrib_list: Int32): Int32 :=
    z_BindVideoDeviceNV_2(dpy, video_slot, video_device, attrib_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindVideoDeviceNV(dpy: x_p_display; video_slot: UInt32; video_device: UInt32; attrib_list: IntPtr): Int32 :=
    z_BindVideoDeviceNV_1(dpy, video_slot, video_device, attrib_list);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glxSwapGroupNV = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'glx_nv_swap_group';
    
    private z_JoinSwapGroupNV_adr := GetProcAddress('glXJoinSwapGroupNV');
    private z_JoinSwapGroupNV_1 := GetProcOrNil&<function(dpy: x_p_display; drawable: glx_drawable; group: UInt32): Bool>(z_JoinSwapGroupNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function JoinSwapGroupNV(dpy: x_p_display; drawable: glx_drawable; group: UInt32): Bool :=
    z_JoinSwapGroupNV_1(dpy, drawable, group);
    
    private z_BindSwapBarrierNV_adr := GetProcAddress('glXBindSwapBarrierNV');
    private z_BindSwapBarrierNV_1 := GetProcOrNil&<function(dpy: x_p_display; group: UInt32; barrier: UInt32): Bool>(z_BindSwapBarrierNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindSwapBarrierNV(dpy: x_p_display; group: UInt32; barrier: UInt32): Bool :=
    z_BindSwapBarrierNV_1(dpy, group, barrier);
    
    private z_QuerySwapGroupNV_adr := GetProcAddress('glXQuerySwapGroupNV');
    private z_QuerySwapGroupNV_1 := GetProcOrNil&<function(dpy: x_p_display; drawable: glx_drawable; group: IntPtr; barrier: IntPtr): Bool>(z_QuerySwapGroupNV_adr);
    private z_QuerySwapGroupNV_2 := GetProcOrNil&<function(dpy: x_p_display; drawable: glx_drawable; group: IntPtr; var barrier: UInt32): Bool>(z_QuerySwapGroupNV_adr);
    private z_QuerySwapGroupNV_3 := GetProcOrNil&<function(dpy: x_p_display; drawable: glx_drawable; var group: UInt32; barrier: IntPtr): Bool>(z_QuerySwapGroupNV_adr);
    private z_QuerySwapGroupNV_4 := GetProcOrNil&<function(dpy: x_p_display; drawable: glx_drawable; var group: UInt32; var barrier: UInt32): Bool>(z_QuerySwapGroupNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(dpy: x_p_display; drawable: glx_drawable; group: array of UInt32; barrier: array of UInt32): Bool;
    type PUInt32=^UInt32;
    begin
      Result := if (barrier<>nil) and (barrier.Length<>0) then
        if (group<>nil) and (group.Length<>0) then
          z_QuerySwapGroupNV_4(dpy, drawable, group[0], barrier[0]) else
          z_QuerySwapGroupNV_4(dpy, drawable, PUInt32(nil)^, barrier[0]) else
        if (group<>nil) and (group.Length<>0) then
          z_QuerySwapGroupNV_4(dpy, drawable, group[0], PUInt32(nil)^) else
          z_QuerySwapGroupNV_4(dpy, drawable, PUInt32(nil)^, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(dpy: x_p_display; drawable: glx_drawable; var group: UInt32; var barrier: UInt32): Bool :=
    z_QuerySwapGroupNV_4(dpy, drawable, group, barrier);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(dpy: x_p_display; drawable: glx_drawable; var group: UInt32; barrier: IntPtr): Bool :=
    z_QuerySwapGroupNV_3(dpy, drawable, group, barrier);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(dpy: x_p_display; drawable: glx_drawable; group: IntPtr; var barrier: UInt32): Bool :=
    z_QuerySwapGroupNV_2(dpy, drawable, group, barrier);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(dpy: x_p_display; drawable: glx_drawable; group: IntPtr; barrier: IntPtr): Bool :=
    z_QuerySwapGroupNV_1(dpy, drawable, group, barrier);
    
    private z_QueryMaxSwapGroupsNV_adr := GetProcAddress('glXQueryMaxSwapGroupsNV');
    private z_QueryMaxSwapGroupsNV_1 := GetProcOrNil&<function(dpy: x_p_display; screen: Int32; maxGroups: IntPtr; maxBarriers: IntPtr): Bool>(z_QueryMaxSwapGroupsNV_adr);
    private z_QueryMaxSwapGroupsNV_2 := GetProcOrNil&<function(dpy: x_p_display; screen: Int32; maxGroups: IntPtr; var maxBarriers: UInt32): Bool>(z_QueryMaxSwapGroupsNV_adr);
    private z_QueryMaxSwapGroupsNV_3 := GetProcOrNil&<function(dpy: x_p_display; screen: Int32; var maxGroups: UInt32; maxBarriers: IntPtr): Bool>(z_QueryMaxSwapGroupsNV_adr);
    private z_QueryMaxSwapGroupsNV_4 := GetProcOrNil&<function(dpy: x_p_display; screen: Int32; var maxGroups: UInt32; var maxBarriers: UInt32): Bool>(z_QueryMaxSwapGroupsNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(dpy: x_p_display; screen: Int32; maxGroups: array of UInt32; maxBarriers: array of UInt32): Bool;
    type PUInt32=^UInt32;
    begin
      Result := if (maxBarriers<>nil) and (maxBarriers.Length<>0) then
        if (maxGroups<>nil) and (maxGroups.Length<>0) then
          z_QueryMaxSwapGroupsNV_4(dpy, screen, maxGroups[0], maxBarriers[0]) else
          z_QueryMaxSwapGroupsNV_4(dpy, screen, PUInt32(nil)^, maxBarriers[0]) else
        if (maxGroups<>nil) and (maxGroups.Length<>0) then
          z_QueryMaxSwapGroupsNV_4(dpy, screen, maxGroups[0], PUInt32(nil)^) else
          z_QueryMaxSwapGroupsNV_4(dpy, screen, PUInt32(nil)^, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(dpy: x_p_display; screen: Int32; var maxGroups: UInt32; var maxBarriers: UInt32): Bool :=
    z_QueryMaxSwapGroupsNV_4(dpy, screen, maxGroups, maxBarriers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(dpy: x_p_display; screen: Int32; var maxGroups: UInt32; maxBarriers: IntPtr): Bool :=
    z_QueryMaxSwapGroupsNV_3(dpy, screen, maxGroups, maxBarriers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(dpy: x_p_display; screen: Int32; maxGroups: IntPtr; var maxBarriers: UInt32): Bool :=
    z_QueryMaxSwapGroupsNV_2(dpy, screen, maxGroups, maxBarriers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(dpy: x_p_display; screen: Int32; maxGroups: IntPtr; maxBarriers: IntPtr): Bool :=
    z_QueryMaxSwapGroupsNV_1(dpy, screen, maxGroups, maxBarriers);
    
    private z_QueryFrameCountNV_adr := GetProcAddress('glXQueryFrameCountNV');
    private z_QueryFrameCountNV_1 := GetProcOrNil&<function(dpy: x_p_display; screen: Int32; count: IntPtr): Bool>(z_QueryFrameCountNV_adr);
    private z_QueryFrameCountNV_2 := GetProcOrNil&<function(dpy: x_p_display; screen: Int32; var count: UInt32): Bool>(z_QueryFrameCountNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameCountNV(dpy: x_p_display; screen: Int32; count: array of UInt32): Bool;
    type PUInt32=^UInt32;
    begin
      Result := if (count<>nil) and (count.Length<>0) then
        z_QueryFrameCountNV_2(dpy, screen, count[0]) else
        z_QueryFrameCountNV_2(dpy, screen, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameCountNV(dpy: x_p_display; screen: Int32; var count: UInt32): Bool :=
    z_QueryFrameCountNV_2(dpy, screen, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameCountNV(dpy: x_p_display; screen: Int32; count: IntPtr): Bool :=
    z_QueryFrameCountNV_1(dpy, screen, count);
    
    private z_ResetFrameCountNV_adr := GetProcAddress('glXResetFrameCountNV');
    private z_ResetFrameCountNV_1 := GetProcOrNil&<function(dpy: x_p_display; screen: Int32): Bool>(z_ResetFrameCountNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ResetFrameCountNV(dpy: x_p_display; screen: Int32): Bool :=
    z_ResetFrameCountNV_1(dpy, screen);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glxVideoCaptureNV = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'glx_nv_video_capture';
    
    private z_BindVideoCaptureDeviceNV_adr := GetProcAddress('glXBindVideoCaptureDeviceNV');
    private z_BindVideoCaptureDeviceNV_1 := GetProcOrNil&<function(dpy: x_p_display; video_capture_slot: UInt32; device: glx_video_capture_device_NV): Int32>(z_BindVideoCaptureDeviceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindVideoCaptureDeviceNV(dpy: x_p_display; video_capture_slot: UInt32; device: glx_video_capture_device_NV): Int32 :=
    z_BindVideoCaptureDeviceNV_1(dpy, video_capture_slot, device);
    
    private z_EnumerateVideoCaptureDevicesNV_adr := GetProcAddress('glXEnumerateVideoCaptureDevicesNV');
    private z_EnumerateVideoCaptureDevicesNV_1 := GetProcOrNil&<function(dpy: x_p_display; screen: Int32; nelements: IntPtr): ^glx_video_capture_device_NV>(z_EnumerateVideoCaptureDevicesNV_adr);
    private z_EnumerateVideoCaptureDevicesNV_2 := GetProcOrNil&<function(dpy: x_p_display; screen: Int32; var nelements: Int32): ^glx_video_capture_device_NV>(z_EnumerateVideoCaptureDevicesNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumerateVideoCaptureDevicesNV(dpy: x_p_display; screen: Int32; nelements: array of Int32): ^glx_video_capture_device_NV;
    type PInt32=^Int32;
    begin
      Result := if (nelements<>nil) and (nelements.Length<>0) then
        z_EnumerateVideoCaptureDevicesNV_2(dpy, screen, nelements[0]) else
        z_EnumerateVideoCaptureDevicesNV_2(dpy, screen, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumerateVideoCaptureDevicesNV(dpy: x_p_display; screen: Int32; var nelements: Int32): ^glx_video_capture_device_NV :=
    z_EnumerateVideoCaptureDevicesNV_2(dpy, screen, nelements);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumerateVideoCaptureDevicesNV(dpy: x_p_display; screen: Int32; nelements: IntPtr): ^glx_video_capture_device_NV :=
    z_EnumerateVideoCaptureDevicesNV_1(dpy, screen, nelements);
    
    private z_LockVideoCaptureDeviceNV_adr := GetProcAddress('glXLockVideoCaptureDeviceNV');
    private z_LockVideoCaptureDeviceNV_1 := GetProcOrNil&<procedure(dpy: x_p_display; device: glx_video_capture_device_NV)>(z_LockVideoCaptureDeviceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LockVideoCaptureDeviceNV(dpy: x_p_display; device: glx_video_capture_device_NV) :=
    z_LockVideoCaptureDeviceNV_1(dpy, device);
    
    private z_QueryVideoCaptureDeviceNV_adr := GetProcAddress('glXQueryVideoCaptureDeviceNV');
    private z_QueryVideoCaptureDeviceNV_1 := GetProcOrNil&<function(dpy: x_p_display; device: glx_video_capture_device_NV; attribute: Int32; value: IntPtr): Int32>(z_QueryVideoCaptureDeviceNV_adr);
    private z_QueryVideoCaptureDeviceNV_2 := GetProcOrNil&<function(dpy: x_p_display; device: glx_video_capture_device_NV; attribute: Int32; var value: Int32): Int32>(z_QueryVideoCaptureDeviceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryVideoCaptureDeviceNV(dpy: x_p_display; device: glx_video_capture_device_NV; attribute: Int32; value: array of Int32): Int32;
    type PInt32=^Int32;
    begin
      Result := if (value<>nil) and (value.Length<>0) then
        z_QueryVideoCaptureDeviceNV_2(dpy, device, attribute, value[0]) else
        z_QueryVideoCaptureDeviceNV_2(dpy, device, attribute, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryVideoCaptureDeviceNV(dpy: x_p_display; device: glx_video_capture_device_NV; attribute: Int32; var value: Int32): Int32 :=
    z_QueryVideoCaptureDeviceNV_2(dpy, device, attribute, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryVideoCaptureDeviceNV(dpy: x_p_display; device: glx_video_capture_device_NV; attribute: Int32; value: IntPtr): Int32 :=
    z_QueryVideoCaptureDeviceNV_1(dpy, device, attribute, value);
    
    private z_ReleaseVideoCaptureDeviceNV_adr := GetProcAddress('glXReleaseVideoCaptureDeviceNV');
    private z_ReleaseVideoCaptureDeviceNV_1 := GetProcOrNil&<procedure(dpy: x_p_display; device: glx_video_capture_device_NV)>(z_ReleaseVideoCaptureDeviceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReleaseVideoCaptureDeviceNV(dpy: x_p_display; device: glx_video_capture_device_NV) :=
    z_ReleaseVideoCaptureDeviceNV_1(dpy, device);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glxVideoOutNV = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'glx_nv_video_out';
    
    private z_GetVideoDeviceNV_adr := GetProcAddress('glXGetVideoDeviceNV');
    private z_GetVideoDeviceNV_1 := GetProcOrNil&<function(dpy: x_p_display; screen: Int32; numVideoDevices: Int32; pVideoDevice: IntPtr): Int32>(z_GetVideoDeviceNV_adr);
    private z_GetVideoDeviceNV_2 := GetProcOrNil&<function(dpy: x_p_display; screen: Int32; numVideoDevices: Int32; var pVideoDevice: glx_video_device_NV): Int32>(z_GetVideoDeviceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoDeviceNV(dpy: x_p_display; screen: Int32; numVideoDevices: Int32; var pVideoDevice: glx_video_device_NV): Int32 :=
    z_GetVideoDeviceNV_2(dpy, screen, numVideoDevices, pVideoDevice);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoDeviceNV(dpy: x_p_display; screen: Int32; numVideoDevices: Int32; pVideoDevice: IntPtr): Int32 :=
    z_GetVideoDeviceNV_1(dpy, screen, numVideoDevices, pVideoDevice);
    
    private z_ReleaseVideoDeviceNV_adr := GetProcAddress('glXReleaseVideoDeviceNV');
    private z_ReleaseVideoDeviceNV_1 := GetProcOrNil&<function(dpy: x_p_display; screen: Int32; VideoDevice: glx_video_device_NV): Int32>(z_ReleaseVideoDeviceNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseVideoDeviceNV(dpy: x_p_display; screen: Int32; VideoDevice: glx_video_device_NV): Int32 :=
    z_ReleaseVideoDeviceNV_1(dpy, screen, VideoDevice);
    
    private z_BindVideoImageNV_adr := GetProcAddress('glXBindVideoImageNV');
    private z_BindVideoImageNV_1 := GetProcOrNil&<function(dpy: x_p_display; VideoDevice: glx_video_device_NV; pbuf: glx_pbuffer; iVideoBuffer: Int32): Int32>(z_BindVideoImageNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindVideoImageNV(dpy: x_p_display; VideoDevice: glx_video_device_NV; pbuf: glx_pbuffer; iVideoBuffer: Int32): Int32 :=
    z_BindVideoImageNV_1(dpy, VideoDevice, pbuf, iVideoBuffer);
    
    private z_ReleaseVideoImageNV_adr := GetProcAddress('glXReleaseVideoImageNV');
    private z_ReleaseVideoImageNV_1 := GetProcOrNil&<function(dpy: x_p_display; pbuf: glx_pbuffer): Int32>(z_ReleaseVideoImageNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseVideoImageNV(dpy: x_p_display; pbuf: glx_pbuffer): Int32 :=
    z_ReleaseVideoImageNV_1(dpy, pbuf);
    
    private z_SendPbufferToVideoNV_adr := GetProcAddress('glXSendPbufferToVideoNV');
    private z_SendPbufferToVideoNV_1 := GetProcOrNil&<function(dpy: x_p_display; pbuf: glx_pbuffer; iBufferType: Int32; pulCounterPbuffer: IntPtr; bBlock: boolean): Int32>(z_SendPbufferToVideoNV_adr);
    private z_SendPbufferToVideoNV_2 := GetProcOrNil&<function(dpy: x_p_display; pbuf: glx_pbuffer; iBufferType: Int32; var pulCounterPbuffer: UInt64; bBlock: boolean): Int32>(z_SendPbufferToVideoNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SendPbufferToVideoNV(dpy: x_p_display; pbuf: glx_pbuffer; iBufferType: Int32; pulCounterPbuffer: array of UInt64; bBlock: boolean): Int32;
    type PUInt64=^UInt64;
    begin
      Result := if (pulCounterPbuffer<>nil) and (pulCounterPbuffer.Length<>0) then
        z_SendPbufferToVideoNV_2(dpy, pbuf, iBufferType, pulCounterPbuffer[0], bBlock) else
        z_SendPbufferToVideoNV_2(dpy, pbuf, iBufferType, PUInt64(nil)^, bBlock);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SendPbufferToVideoNV(dpy: x_p_display; pbuf: glx_pbuffer; iBufferType: Int32; var pulCounterPbuffer: UInt64; bBlock: boolean): Int32 :=
    z_SendPbufferToVideoNV_2(dpy, pbuf, iBufferType, pulCounterPbuffer, bBlock);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SendPbufferToVideoNV(dpy: x_p_display; pbuf: glx_pbuffer; iBufferType: Int32; pulCounterPbuffer: IntPtr; bBlock: boolean): Int32 :=
    z_SendPbufferToVideoNV_1(dpy, pbuf, iBufferType, pulCounterPbuffer, bBlock);
    
    private z_GetVideoInfoNV_adr := GetProcAddress('glXGetVideoInfoNV');
    private z_GetVideoInfoNV_1 := GetProcOrNil&<function(dpy: x_p_display; screen: Int32; VideoDevice: glx_video_device_NV; pulCounterOutputPbuffer: IntPtr; pulCounterOutputVideo: IntPtr): Int32>(z_GetVideoInfoNV_adr);
    private z_GetVideoInfoNV_2 := GetProcOrNil&<function(dpy: x_p_display; screen: Int32; VideoDevice: glx_video_device_NV; pulCounterOutputPbuffer: IntPtr; var pulCounterOutputVideo: UInt64): Int32>(z_GetVideoInfoNV_adr);
    private z_GetVideoInfoNV_3 := GetProcOrNil&<function(dpy: x_p_display; screen: Int32; VideoDevice: glx_video_device_NV; var pulCounterOutputPbuffer: UInt64; pulCounterOutputVideo: IntPtr): Int32>(z_GetVideoInfoNV_adr);
    private z_GetVideoInfoNV_4 := GetProcOrNil&<function(dpy: x_p_display; screen: Int32; VideoDevice: glx_video_device_NV; var pulCounterOutputPbuffer: UInt64; var pulCounterOutputVideo: UInt64): Int32>(z_GetVideoInfoNV_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoInfoNV(dpy: x_p_display; screen: Int32; VideoDevice: glx_video_device_NV; var pulCounterOutputPbuffer: UInt64; var pulCounterOutputVideo: UInt64): Int32 :=
    z_GetVideoInfoNV_4(dpy, screen, VideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoInfoNV(dpy: x_p_display; screen: Int32; VideoDevice: glx_video_device_NV; var pulCounterOutputPbuffer: UInt64; pulCounterOutputVideo: IntPtr): Int32 :=
    z_GetVideoInfoNV_3(dpy, screen, VideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoInfoNV(dpy: x_p_display; screen: Int32; VideoDevice: glx_video_device_NV; pulCounterOutputPbuffer: IntPtr; var pulCounterOutputVideo: UInt64): Int32 :=
    z_GetVideoInfoNV_2(dpy, screen, VideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoInfoNV(dpy: x_p_display; screen: Int32; VideoDevice: glx_video_device_NV; pulCounterOutputPbuffer: IntPtr; pulCounterOutputVideo: IntPtr): Int32 :=
    z_GetVideoInfoNV_1(dpy, screen, VideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glxSyncControlOML = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'glx_oml_sync_control';
    
    private z_GetSyncValuesOML_adr := GetProcAddress('glXGetSyncValuesOML');
    private z_GetSyncValuesOML_1 := GetProcOrNil&<function(dpy: x_p_display; drawable: glx_drawable; ust: IntPtr; msc: IntPtr; sbc: IntPtr): Bool>(z_GetSyncValuesOML_adr);
    private z_GetSyncValuesOML_2 := GetProcOrNil&<function(dpy: x_p_display; drawable: glx_drawable; ust: IntPtr; msc: IntPtr; var sbc: Int64): Bool>(z_GetSyncValuesOML_adr);
    private z_GetSyncValuesOML_3 := GetProcOrNil&<function(dpy: x_p_display; drawable: glx_drawable; ust: IntPtr; var msc: Int64; sbc: IntPtr): Bool>(z_GetSyncValuesOML_adr);
    private z_GetSyncValuesOML_4 := GetProcOrNil&<function(dpy: x_p_display; drawable: glx_drawable; ust: IntPtr; var msc: Int64; var sbc: Int64): Bool>(z_GetSyncValuesOML_adr);
    private z_GetSyncValuesOML_5 := GetProcOrNil&<function(dpy: x_p_display; drawable: glx_drawable; var ust: Int64; msc: IntPtr; sbc: IntPtr): Bool>(z_GetSyncValuesOML_adr);
    private z_GetSyncValuesOML_6 := GetProcOrNil&<function(dpy: x_p_display; drawable: glx_drawable; var ust: Int64; msc: IntPtr; var sbc: Int64): Bool>(z_GetSyncValuesOML_adr);
    private z_GetSyncValuesOML_7 := GetProcOrNil&<function(dpy: x_p_display; drawable: glx_drawable; var ust: Int64; var msc: Int64; sbc: IntPtr): Bool>(z_GetSyncValuesOML_adr);
    private z_GetSyncValuesOML_8 := GetProcOrNil&<function(dpy: x_p_display; drawable: glx_drawable; var ust: Int64; var msc: Int64; var sbc: Int64): Bool>(z_GetSyncValuesOML_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: x_p_display; drawable: glx_drawable; var ust: Int64; var msc: Int64; var sbc: Int64): Bool :=
    z_GetSyncValuesOML_8(dpy, drawable, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: x_p_display; drawable: glx_drawable; var ust: Int64; var msc: Int64; sbc: IntPtr): Bool :=
    z_GetSyncValuesOML_7(dpy, drawable, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: x_p_display; drawable: glx_drawable; var ust: Int64; msc: IntPtr; var sbc: Int64): Bool :=
    z_GetSyncValuesOML_6(dpy, drawable, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: x_p_display; drawable: glx_drawable; var ust: Int64; msc: IntPtr; sbc: IntPtr): Bool :=
    z_GetSyncValuesOML_5(dpy, drawable, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: x_p_display; drawable: glx_drawable; ust: IntPtr; var msc: Int64; var sbc: Int64): Bool :=
    z_GetSyncValuesOML_4(dpy, drawable, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: x_p_display; drawable: glx_drawable; ust: IntPtr; var msc: Int64; sbc: IntPtr): Bool :=
    z_GetSyncValuesOML_3(dpy, drawable, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: x_p_display; drawable: glx_drawable; ust: IntPtr; msc: IntPtr; var sbc: Int64): Bool :=
    z_GetSyncValuesOML_2(dpy, drawable, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: x_p_display; drawable: glx_drawable; ust: IntPtr; msc: IntPtr; sbc: IntPtr): Bool :=
    z_GetSyncValuesOML_1(dpy, drawable, ust, msc, sbc);
    
    private z_GetMscRateOML_adr := GetProcAddress('glXGetMscRateOML');
    private z_GetMscRateOML_1 := GetProcOrNil&<function(dpy: x_p_display; drawable: glx_drawable; numerator: IntPtr; denominator: IntPtr): Bool>(z_GetMscRateOML_adr);
    private z_GetMscRateOML_2 := GetProcOrNil&<function(dpy: x_p_display; drawable: glx_drawable; numerator: IntPtr; var denominator: Int32): Bool>(z_GetMscRateOML_adr);
    private z_GetMscRateOML_3 := GetProcOrNil&<function(dpy: x_p_display; drawable: glx_drawable; var numerator: Int32; denominator: IntPtr): Bool>(z_GetMscRateOML_adr);
    private z_GetMscRateOML_4 := GetProcOrNil&<function(dpy: x_p_display; drawable: glx_drawable; var numerator: Int32; var denominator: Int32): Bool>(z_GetMscRateOML_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMscRateOML(dpy: x_p_display; drawable: glx_drawable; var numerator: Int32; var denominator: Int32): Bool :=
    z_GetMscRateOML_4(dpy, drawable, numerator, denominator);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMscRateOML(dpy: x_p_display; drawable: glx_drawable; var numerator: Int32; denominator: IntPtr): Bool :=
    z_GetMscRateOML_3(dpy, drawable, numerator, denominator);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMscRateOML(dpy: x_p_display; drawable: glx_drawable; numerator: IntPtr; var denominator: Int32): Bool :=
    z_GetMscRateOML_2(dpy, drawable, numerator, denominator);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMscRateOML(dpy: x_p_display; drawable: glx_drawable; numerator: IntPtr; denominator: IntPtr): Bool :=
    z_GetMscRateOML_1(dpy, drawable, numerator, denominator);
    
    private z_SwapBuffersMscOML_adr := GetProcAddress('glXSwapBuffersMscOML');
    private z_SwapBuffersMscOML_1 := GetProcOrNil&<function(dpy: x_p_display; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64): Int64>(z_SwapBuffersMscOML_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SwapBuffersMscOML(dpy: x_p_display; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64): Int64 :=
    z_SwapBuffersMscOML_1(dpy, drawable, target_msc, divisor, remainder);
    
    private z_WaitForMscOML_adr := GetProcAddress('glXWaitForMscOML');
    private z_WaitForMscOML_1 := GetProcOrNil&<function(dpy: x_p_display; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: IntPtr; msc: IntPtr; sbc: IntPtr): Bool>(z_WaitForMscOML_adr);
    private z_WaitForMscOML_2 := GetProcOrNil&<function(dpy: x_p_display; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: IntPtr; msc: IntPtr; var sbc: Int64): Bool>(z_WaitForMscOML_adr);
    private z_WaitForMscOML_3 := GetProcOrNil&<function(dpy: x_p_display; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: IntPtr; var msc: Int64; sbc: IntPtr): Bool>(z_WaitForMscOML_adr);
    private z_WaitForMscOML_4 := GetProcOrNil&<function(dpy: x_p_display; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: IntPtr; var msc: Int64; var sbc: Int64): Bool>(z_WaitForMscOML_adr);
    private z_WaitForMscOML_5 := GetProcOrNil&<function(dpy: x_p_display; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: IntPtr; sbc: IntPtr): Bool>(z_WaitForMscOML_adr);
    private z_WaitForMscOML_6 := GetProcOrNil&<function(dpy: x_p_display; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: IntPtr; var sbc: Int64): Bool>(z_WaitForMscOML_adr);
    private z_WaitForMscOML_7 := GetProcOrNil&<function(dpy: x_p_display; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; var msc: Int64; sbc: IntPtr): Bool>(z_WaitForMscOML_adr);
    private z_WaitForMscOML_8 := GetProcOrNil&<function(dpy: x_p_display; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; var msc: Int64; var sbc: Int64): Bool>(z_WaitForMscOML_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: x_p_display; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; msc: array of Int64; sbc: array of Int64): Bool;
    type PInt64=^Int64;
    begin
      Result := if (sbc<>nil) and (sbc.Length<>0) then
        if (msc<>nil) and (msc.Length<>0) then
          if (ust<>nil) and (ust.Length<>0) then
            z_WaitForMscOML_8(dpy, drawable, target_msc, divisor, remainder, ust[0], msc[0], sbc[0]) else
            z_WaitForMscOML_8(dpy, drawable, target_msc, divisor, remainder, PInt64(nil)^, msc[0], sbc[0]) else
          if (ust<>nil) and (ust.Length<>0) then
            z_WaitForMscOML_8(dpy, drawable, target_msc, divisor, remainder, ust[0], PInt64(nil)^, sbc[0]) else
            z_WaitForMscOML_8(dpy, drawable, target_msc, divisor, remainder, PInt64(nil)^, PInt64(nil)^, sbc[0]) else
        if (msc<>nil) and (msc.Length<>0) then
          if (ust<>nil) and (ust.Length<>0) then
            z_WaitForMscOML_8(dpy, drawable, target_msc, divisor, remainder, ust[0], msc[0], PInt64(nil)^) else
            z_WaitForMscOML_8(dpy, drawable, target_msc, divisor, remainder, PInt64(nil)^, msc[0], PInt64(nil)^) else
          if (ust<>nil) and (ust.Length<>0) then
            z_WaitForMscOML_8(dpy, drawable, target_msc, divisor, remainder, ust[0], PInt64(nil)^, PInt64(nil)^) else
            z_WaitForMscOML_8(dpy, drawable, target_msc, divisor, remainder, PInt64(nil)^, PInt64(nil)^, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: x_p_display; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; var msc: Int64; var sbc: Int64): Bool :=
    z_WaitForMscOML_8(dpy, drawable, target_msc, divisor, remainder, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: x_p_display; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; var msc: Int64; sbc: IntPtr): Bool :=
    z_WaitForMscOML_7(dpy, drawable, target_msc, divisor, remainder, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: x_p_display; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: IntPtr; var sbc: Int64): Bool :=
    z_WaitForMscOML_6(dpy, drawable, target_msc, divisor, remainder, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: x_p_display; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: IntPtr; sbc: IntPtr): Bool :=
    z_WaitForMscOML_5(dpy, drawable, target_msc, divisor, remainder, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: x_p_display; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: IntPtr; var msc: Int64; var sbc: Int64): Bool :=
    z_WaitForMscOML_4(dpy, drawable, target_msc, divisor, remainder, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: x_p_display; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: IntPtr; var msc: Int64; sbc: IntPtr): Bool :=
    z_WaitForMscOML_3(dpy, drawable, target_msc, divisor, remainder, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: x_p_display; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: IntPtr; msc: IntPtr; var sbc: Int64): Bool :=
    z_WaitForMscOML_2(dpy, drawable, target_msc, divisor, remainder, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: x_p_display; drawable: glx_drawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: IntPtr; msc: IntPtr; sbc: IntPtr): Bool :=
    z_WaitForMscOML_1(dpy, drawable, target_msc, divisor, remainder, ust, msc, sbc);
    
    private z_WaitForSbcOML_adr := GetProcAddress('glXWaitForSbcOML');
    private z_WaitForSbcOML_1 := GetProcOrNil&<function(dpy: x_p_display; drawable: glx_drawable; target_sbc: Int64; ust: IntPtr; msc: IntPtr; sbc: IntPtr): Bool>(z_WaitForSbcOML_adr);
    private z_WaitForSbcOML_2 := GetProcOrNil&<function(dpy: x_p_display; drawable: glx_drawable; target_sbc: Int64; ust: IntPtr; msc: IntPtr; var sbc: Int64): Bool>(z_WaitForSbcOML_adr);
    private z_WaitForSbcOML_3 := GetProcOrNil&<function(dpy: x_p_display; drawable: glx_drawable; target_sbc: Int64; ust: IntPtr; var msc: Int64; sbc: IntPtr): Bool>(z_WaitForSbcOML_adr);
    private z_WaitForSbcOML_4 := GetProcOrNil&<function(dpy: x_p_display; drawable: glx_drawable; target_sbc: Int64; ust: IntPtr; var msc: Int64; var sbc: Int64): Bool>(z_WaitForSbcOML_adr);
    private z_WaitForSbcOML_5 := GetProcOrNil&<function(dpy: x_p_display; drawable: glx_drawable; target_sbc: Int64; var ust: Int64; msc: IntPtr; sbc: IntPtr): Bool>(z_WaitForSbcOML_adr);
    private z_WaitForSbcOML_6 := GetProcOrNil&<function(dpy: x_p_display; drawable: glx_drawable; target_sbc: Int64; var ust: Int64; msc: IntPtr; var sbc: Int64): Bool>(z_WaitForSbcOML_adr);
    private z_WaitForSbcOML_7 := GetProcOrNil&<function(dpy: x_p_display; drawable: glx_drawable; target_sbc: Int64; var ust: Int64; var msc: Int64; sbc: IntPtr): Bool>(z_WaitForSbcOML_adr);
    private z_WaitForSbcOML_8 := GetProcOrNil&<function(dpy: x_p_display; drawable: glx_drawable; target_sbc: Int64; var ust: Int64; var msc: Int64; var sbc: Int64): Bool>(z_WaitForSbcOML_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: x_p_display; drawable: glx_drawable; target_sbc: Int64; ust: array of Int64; msc: array of Int64; sbc: array of Int64): Bool;
    type PInt64=^Int64;
    begin
      Result := if (sbc<>nil) and (sbc.Length<>0) then
        if (msc<>nil) and (msc.Length<>0) then
          if (ust<>nil) and (ust.Length<>0) then
            z_WaitForSbcOML_8(dpy, drawable, target_sbc, ust[0], msc[0], sbc[0]) else
            z_WaitForSbcOML_8(dpy, drawable, target_sbc, PInt64(nil)^, msc[0], sbc[0]) else
          if (ust<>nil) and (ust.Length<>0) then
            z_WaitForSbcOML_8(dpy, drawable, target_sbc, ust[0], PInt64(nil)^, sbc[0]) else
            z_WaitForSbcOML_8(dpy, drawable, target_sbc, PInt64(nil)^, PInt64(nil)^, sbc[0]) else
        if (msc<>nil) and (msc.Length<>0) then
          if (ust<>nil) and (ust.Length<>0) then
            z_WaitForSbcOML_8(dpy, drawable, target_sbc, ust[0], msc[0], PInt64(nil)^) else
            z_WaitForSbcOML_8(dpy, drawable, target_sbc, PInt64(nil)^, msc[0], PInt64(nil)^) else
          if (ust<>nil) and (ust.Length<>0) then
            z_WaitForSbcOML_8(dpy, drawable, target_sbc, ust[0], PInt64(nil)^, PInt64(nil)^) else
            z_WaitForSbcOML_8(dpy, drawable, target_sbc, PInt64(nil)^, PInt64(nil)^, PInt64(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: x_p_display; drawable: glx_drawable; target_sbc: Int64; var ust: Int64; var msc: Int64; var sbc: Int64): Bool :=
    z_WaitForSbcOML_8(dpy, drawable, target_sbc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: x_p_display; drawable: glx_drawable; target_sbc: Int64; var ust: Int64; var msc: Int64; sbc: IntPtr): Bool :=
    z_WaitForSbcOML_7(dpy, drawable, target_sbc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: x_p_display; drawable: glx_drawable; target_sbc: Int64; var ust: Int64; msc: IntPtr; var sbc: Int64): Bool :=
    z_WaitForSbcOML_6(dpy, drawable, target_sbc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: x_p_display; drawable: glx_drawable; target_sbc: Int64; var ust: Int64; msc: IntPtr; sbc: IntPtr): Bool :=
    z_WaitForSbcOML_5(dpy, drawable, target_sbc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: x_p_display; drawable: glx_drawable; target_sbc: Int64; ust: IntPtr; var msc: Int64; var sbc: Int64): Bool :=
    z_WaitForSbcOML_4(dpy, drawable, target_sbc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: x_p_display; drawable: glx_drawable; target_sbc: Int64; ust: IntPtr; var msc: Int64; sbc: IntPtr): Bool :=
    z_WaitForSbcOML_3(dpy, drawable, target_sbc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: x_p_display; drawable: glx_drawable; target_sbc: Int64; ust: IntPtr; msc: IntPtr; var sbc: Int64): Bool :=
    z_WaitForSbcOML_2(dpy, drawable, target_sbc, ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: x_p_display; drawable: glx_drawable; target_sbc: Int64; ust: IntPtr; msc: IntPtr; sbc: IntPtr): Bool :=
    z_WaitForSbcOML_1(dpy, drawable, target_sbc, ust, msc, sbc);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glxCushionSGI = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'glx_sgi_cushion';
    
    private z_CushionSGI_adr := GetProcAddress('glXCushionSGI');
    private z_CushionSGI_1 := GetProcOrNil&<procedure(dpy: x_p_display; window: x_window; cushion: single)>(z_CushionSGI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CushionSGI(dpy: x_p_display; window: x_window; cushion: single) :=
    z_CushionSGI_1(dpy, window, cushion);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glxMakeCurrentReadSGI = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'glx_sgi_make_current_read';
    
    private z_MakeCurrentReadSGI_adr := GetProcAddress('glXMakeCurrentReadSGI');
    private z_MakeCurrentReadSGI_1 := GetProcOrNil&<function(dpy: x_p_display; draw: glx_drawable; read: glx_drawable; ctx: glx_context): Bool>(z_MakeCurrentReadSGI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MakeCurrentReadSGI(dpy: x_p_display; draw: glx_drawable; read: glx_drawable; ctx: glx_context): Bool :=
    z_MakeCurrentReadSGI_1(dpy, draw, read, ctx);
    
    private z_GetCurrentReadDrawableSGI_adr := GetProcAddress('glXGetCurrentReadDrawableSGI');
    private z_GetCurrentReadDrawableSGI_1 := GetProcOrNil&<function: glx_drawable>(z_GetCurrentReadDrawableSGI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCurrentReadDrawableSGI: glx_drawable :=
    z_GetCurrentReadDrawableSGI_1();
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glxSwapControlSGI = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'glx_sgi_swap_control';
    
    private z_SwapIntervalSGI_adr := GetProcAddress('glXSwapIntervalSGI');
    private z_SwapIntervalSGI_1 := GetProcOrNil&<function(interval: Int32): Int32>(z_SwapIntervalSGI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SwapIntervalSGI(interval: Int32): Int32 :=
    z_SwapIntervalSGI_1(interval);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glxVideoSyncSGI = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'glx_sgi_video_sync';
    
    private z_GetVideoSyncSGI_adr := GetProcAddress('glXGetVideoSyncSGI');
    private z_GetVideoSyncSGI_1 := GetProcOrNil&<function(count: IntPtr): Int32>(z_GetVideoSyncSGI_adr);
    private z_GetVideoSyncSGI_2 := GetProcOrNil&<function(var count: UInt32): Int32>(z_GetVideoSyncSGI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoSyncSGI(var count: UInt32): Int32 :=
    z_GetVideoSyncSGI_2(count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoSyncSGI(count: IntPtr): Int32 :=
    z_GetVideoSyncSGI_1(count);
    
    private z_WaitVideoSyncSGI_adr := GetProcAddress('glXWaitVideoSyncSGI');
    private z_WaitVideoSyncSGI_1 := GetProcOrNil&<function(divisor: Int32; remainder: Int32; count: IntPtr): Int32>(z_WaitVideoSyncSGI_adr);
    private z_WaitVideoSyncSGI_2 := GetProcOrNil&<function(divisor: Int32; remainder: Int32; var count: UInt32): Int32>(z_WaitVideoSyncSGI_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitVideoSyncSGI(divisor: Int32; remainder: Int32; count: array of UInt32): Int32;
    type PUInt32=^UInt32;
    begin
      Result := if (count<>nil) and (count.Length<>0) then
        z_WaitVideoSyncSGI_2(divisor, remainder, count[0]) else
        z_WaitVideoSyncSGI_2(divisor, remainder, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitVideoSyncSGI(divisor: Int32; remainder: Int32; var count: UInt32): Int32 :=
    z_WaitVideoSyncSGI_2(divisor, remainder, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitVideoSyncSGI(divisor: Int32; remainder: Int32; count: IntPtr): Int32 :=
    z_WaitVideoSyncSGI_1(divisor, remainder, count);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glxDmbufferSGIX = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'glx_sgix_dmbuffer';
    
    private z_AssociateDMPbufferSGIX_adr := GetProcAddress('glXAssociateDMPbufferSGIX');
    private z_AssociateDMPbufferSGIX_1 := GetProcOrNil&<function(dpy: x_p_display; pbuffer: glx_pbuffer; &params: IntPtr; dmbuffer: x_dm_buffer): Bool>(z_AssociateDMPbufferSGIX_adr);
    private z_AssociateDMPbufferSGIX_2 := GetProcOrNil&<function(dpy: x_p_display; pbuffer: glx_pbuffer; var &params: x_dm_params; dmbuffer: x_dm_buffer): Bool>(z_AssociateDMPbufferSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateDMPbufferSGIX(dpy: x_p_display; pbuffer: glx_pbuffer; &params: array of x_dm_params; dmbuffer: x_dm_buffer): Bool;
    type Px_dm_params=^x_dm_params;
    begin
      Result := if (&params<>nil) and (&params.Length<>0) then
        z_AssociateDMPbufferSGIX_2(dpy, pbuffer, &params[0], dmbuffer) else
        z_AssociateDMPbufferSGIX_2(dpy, pbuffer, Px_dm_params(nil)^, dmbuffer);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateDMPbufferSGIX(dpy: x_p_display; pbuffer: glx_pbuffer; var &params: x_dm_params; dmbuffer: x_dm_buffer): Bool :=
    z_AssociateDMPbufferSGIX_2(dpy, pbuffer, &params, dmbuffer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateDMPbufferSGIX(dpy: x_p_display; pbuffer: glx_pbuffer; &params: IntPtr; dmbuffer: x_dm_buffer): Bool :=
    z_AssociateDMPbufferSGIX_1(dpy, pbuffer, &params, dmbuffer);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glxFbconfigSGIX = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'glx_sgix_fbconfig';
    
    private z_GetFBConfigAttribSGIX_adr := GetProcAddress('glXGetFBConfigAttribSGIX');
    private z_GetFBConfigAttribSGIX_1 := GetProcOrNil&<function(dpy: x_p_display; config: glx_fb_config; attribute: Int32; value: IntPtr): Int32>(z_GetFBConfigAttribSGIX_adr);
    private z_GetFBConfigAttribSGIX_2 := GetProcOrNil&<function(dpy: x_p_display; config: glx_fb_config; attribute: Int32; var value: Int32): Int32>(z_GetFBConfigAttribSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFBConfigAttribSGIX(dpy: x_p_display; config: glx_fb_config; attribute: Int32; var value: Int32): Int32 :=
    z_GetFBConfigAttribSGIX_2(dpy, config, attribute, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFBConfigAttribSGIX(dpy: x_p_display; config: glx_fb_config; attribute: Int32; value: IntPtr): Int32 :=
    z_GetFBConfigAttribSGIX_1(dpy, config, attribute, value);
    
    private z_ChooseFBConfigSGIX_adr := GetProcAddress('glXChooseFBConfigSGIX');
    private z_ChooseFBConfigSGIX_1 := GetProcOrNil&<function(dpy: x_p_display; screen: Int32; attrib_list: IntPtr; nelements: IntPtr): ^glx_fb_config>(z_ChooseFBConfigSGIX_adr);
    private z_ChooseFBConfigSGIX_2 := GetProcOrNil&<function(dpy: x_p_display; screen: Int32; attrib_list: IntPtr; var nelements: Int32): ^glx_fb_config>(z_ChooseFBConfigSGIX_adr);
    private z_ChooseFBConfigSGIX_3 := GetProcOrNil&<function(dpy: x_p_display; screen: Int32; var attrib_list: Int32; nelements: IntPtr): ^glx_fb_config>(z_ChooseFBConfigSGIX_adr);
    private z_ChooseFBConfigSGIX_4 := GetProcOrNil&<function(dpy: x_p_display; screen: Int32; var attrib_list: Int32; var nelements: Int32): ^glx_fb_config>(z_ChooseFBConfigSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChooseFBConfigSGIX(dpy: x_p_display; screen: Int32; attrib_list: array of Int32; nelements: array of Int32): ^glx_fb_config;
    type PInt32=^Int32;
    begin
      Result := if (nelements<>nil) and (nelements.Length<>0) then
        if (attrib_list<>nil) and (attrib_list.Length<>0) then
          z_ChooseFBConfigSGIX_4(dpy, screen, attrib_list[0], nelements[0]) else
          z_ChooseFBConfigSGIX_4(dpy, screen, PInt32(nil)^, nelements[0]) else
        if (attrib_list<>nil) and (attrib_list.Length<>0) then
          z_ChooseFBConfigSGIX_4(dpy, screen, attrib_list[0], PInt32(nil)^) else
          z_ChooseFBConfigSGIX_4(dpy, screen, PInt32(nil)^, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChooseFBConfigSGIX(dpy: x_p_display; screen: Int32; var attrib_list: Int32; var nelements: Int32): ^glx_fb_config :=
    z_ChooseFBConfigSGIX_4(dpy, screen, attrib_list, nelements);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChooseFBConfigSGIX(dpy: x_p_display; screen: Int32; var attrib_list: Int32; nelements: IntPtr): ^glx_fb_config :=
    z_ChooseFBConfigSGIX_3(dpy, screen, attrib_list, nelements);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChooseFBConfigSGIX(dpy: x_p_display; screen: Int32; attrib_list: IntPtr; var nelements: Int32): ^glx_fb_config :=
    z_ChooseFBConfigSGIX_2(dpy, screen, attrib_list, nelements);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChooseFBConfigSGIX(dpy: x_p_display; screen: Int32; attrib_list: IntPtr; nelements: IntPtr): ^glx_fb_config :=
    z_ChooseFBConfigSGIX_1(dpy, screen, attrib_list, nelements);
    
    private z_CreateGLXPixmapWithConfigSGIX_adr := GetProcAddress('glXCreateGLXPixmapWithConfigSGIX');
    private z_CreateGLXPixmapWithConfigSGIX_1 := GetProcOrNil&<function(dpy: x_p_display; config: glx_fb_config; pixmap: x_pixmap): glx_pixmap>(z_CreateGLXPixmapWithConfigSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateGLXPixmapWithConfigSGIX(dpy: x_p_display; config: glx_fb_config; pixmap: x_pixmap): glx_pixmap :=
    z_CreateGLXPixmapWithConfigSGIX_1(dpy, config, pixmap);
    
    private z_CreateContextWithConfigSGIX_adr := GetProcAddress('glXCreateContextWithConfigSGIX');
    private z_CreateContextWithConfigSGIX_1 := GetProcOrNil&<function(dpy: x_p_display; config: glx_fb_config; render_type: Int32; share_list: glx_context; direct: Bool): glx_context>(z_CreateContextWithConfigSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateContextWithConfigSGIX(dpy: x_p_display; config: glx_fb_config; render_type: Int32; share_list: glx_context; direct: Bool): glx_context :=
    z_CreateContextWithConfigSGIX_1(dpy, config, render_type, share_list, direct);
    
    private z_GetVisualFromFBConfigSGIX_adr := GetProcAddress('glXGetVisualFromFBConfigSGIX');
    private z_GetVisualFromFBConfigSGIX_1 := GetProcOrNil&<function(dpy: x_p_display; config: glx_fb_config): x_p_visual_info>(z_GetVisualFromFBConfigSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVisualFromFBConfigSGIX(dpy: x_p_display; config: glx_fb_config): x_p_visual_info :=
    z_GetVisualFromFBConfigSGIX_1(dpy, config);
    
    private z_GetFBConfigFromVisualSGIX_adr := GetProcAddress('glXGetFBConfigFromVisualSGIX');
    private z_GetFBConfigFromVisualSGIX_1 := GetProcOrNil&<function(dpy: x_p_display; vis: x_p_visual_info): glx_fb_config>(z_GetFBConfigFromVisualSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFBConfigFromVisualSGIX(dpy: x_p_display; vis: x_p_visual_info): glx_fb_config :=
    z_GetFBConfigFromVisualSGIX_1(dpy, vis);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glxHyperpipeSGIX = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'glx_sgix_hyperpipe';
    
    private z_QueryHyperpipeNetworkSGIX_adr := GetProcAddress('glXQueryHyperpipeNetworkSGIX');
    private z_QueryHyperpipeNetworkSGIX_1 := GetProcOrNil&<function(dpy: x_p_display; npipes: IntPtr): ^glx_hyperpipe_network_SGIX>(z_QueryHyperpipeNetworkSGIX_adr);
    private z_QueryHyperpipeNetworkSGIX_2 := GetProcOrNil&<function(dpy: x_p_display; var npipes: Int32): ^glx_hyperpipe_network_SGIX>(z_QueryHyperpipeNetworkSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryHyperpipeNetworkSGIX(dpy: x_p_display; var npipes: Int32): ^glx_hyperpipe_network_SGIX :=
    z_QueryHyperpipeNetworkSGIX_2(dpy, npipes);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryHyperpipeNetworkSGIX(dpy: x_p_display; npipes: IntPtr): ^glx_hyperpipe_network_SGIX :=
    z_QueryHyperpipeNetworkSGIX_1(dpy, npipes);
    
    private z_HyperpipeConfigSGIX_adr := GetProcAddress('glXHyperpipeConfigSGIX');
    private z_HyperpipeConfigSGIX_1 := GetProcOrNil&<function(dpy: x_p_display; networkId: Int32; npipes: Int32; cfg: IntPtr; hpId: IntPtr): Int32>(z_HyperpipeConfigSGIX_adr);
    private z_HyperpipeConfigSGIX_2 := GetProcOrNil&<function(dpy: x_p_display; networkId: Int32; npipes: Int32; cfg: IntPtr; var hpId: Int32): Int32>(z_HyperpipeConfigSGIX_adr);
    private z_HyperpipeConfigSGIX_3 := GetProcOrNil&<function(dpy: x_p_display; networkId: Int32; npipes: Int32; var cfg: glx_hyperpipe_config_SGIX; hpId: IntPtr): Int32>(z_HyperpipeConfigSGIX_adr);
    private z_HyperpipeConfigSGIX_4 := GetProcOrNil&<function(dpy: x_p_display; networkId: Int32; npipes: Int32; var cfg: glx_hyperpipe_config_SGIX; var hpId: Int32): Int32>(z_HyperpipeConfigSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function HyperpipeConfigSGIX(dpy: x_p_display; networkId: Int32; npipes: Int32; cfg: array of glx_hyperpipe_config_SGIX; var hpId: Int32): Int32;
    type Pglx_hyperpipe_config_SGIX=^glx_hyperpipe_config_SGIX;
    begin
      Result := if (cfg<>nil) and (cfg.Length<>0) then
        z_HyperpipeConfigSGIX_4(dpy, networkId, npipes, cfg[0], hpId) else
        z_HyperpipeConfigSGIX_4(dpy, networkId, npipes, Pglx_hyperpipe_config_SGIX(nil)^, hpId);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function HyperpipeConfigSGIX(dpy: x_p_display; networkId: Int32; npipes: Int32; cfg: array of glx_hyperpipe_config_SGIX; hpId: IntPtr): Int32;
    type Pglx_hyperpipe_config_SGIX=^glx_hyperpipe_config_SGIX;
    begin
      Result := if (cfg<>nil) and (cfg.Length<>0) then
        z_HyperpipeConfigSGIX_3(dpy, networkId, npipes, cfg[0], hpId) else
        z_HyperpipeConfigSGIX_3(dpy, networkId, npipes, Pglx_hyperpipe_config_SGIX(nil)^, hpId);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function HyperpipeConfigSGIX(dpy: x_p_display; networkId: Int32; npipes: Int32; var cfg: glx_hyperpipe_config_SGIX; var hpId: Int32): Int32 :=
    z_HyperpipeConfigSGIX_4(dpy, networkId, npipes, cfg, hpId);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function HyperpipeConfigSGIX(dpy: x_p_display; networkId: Int32; npipes: Int32; var cfg: glx_hyperpipe_config_SGIX; hpId: IntPtr): Int32 :=
    z_HyperpipeConfigSGIX_3(dpy, networkId, npipes, cfg, hpId);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function HyperpipeConfigSGIX(dpy: x_p_display; networkId: Int32; npipes: Int32; cfg: IntPtr; var hpId: Int32): Int32 :=
    z_HyperpipeConfigSGIX_2(dpy, networkId, npipes, cfg, hpId);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function HyperpipeConfigSGIX(dpy: x_p_display; networkId: Int32; npipes: Int32; cfg: IntPtr; hpId: IntPtr): Int32 :=
    z_HyperpipeConfigSGIX_1(dpy, networkId, npipes, cfg, hpId);
    
    private z_QueryHyperpipeConfigSGIX_adr := GetProcAddress('glXQueryHyperpipeConfigSGIX');
    private z_QueryHyperpipeConfigSGIX_1 := GetProcOrNil&<function(dpy: x_p_display; hpId: Int32; npipes: IntPtr): ^glx_hyperpipe_config_SGIX>(z_QueryHyperpipeConfigSGIX_adr);
    private z_QueryHyperpipeConfigSGIX_2 := GetProcOrNil&<function(dpy: x_p_display; hpId: Int32; var npipes: Int32): ^glx_hyperpipe_config_SGIX>(z_QueryHyperpipeConfigSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryHyperpipeConfigSGIX(dpy: x_p_display; hpId: Int32; var npipes: Int32): ^glx_hyperpipe_config_SGIX :=
    z_QueryHyperpipeConfigSGIX_2(dpy, hpId, npipes);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryHyperpipeConfigSGIX(dpy: x_p_display; hpId: Int32; npipes: IntPtr): ^glx_hyperpipe_config_SGIX :=
    z_QueryHyperpipeConfigSGIX_1(dpy, hpId, npipes);
    
    private z_DestroyHyperpipeConfigSGIX_adr := GetProcAddress('glXDestroyHyperpipeConfigSGIX');
    private z_DestroyHyperpipeConfigSGIX_1 := GetProcOrNil&<function(dpy: x_p_display; hpId: Int32): Int32>(z_DestroyHyperpipeConfigSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DestroyHyperpipeConfigSGIX(dpy: x_p_display; hpId: Int32): Int32 :=
    z_DestroyHyperpipeConfigSGIX_1(dpy, hpId);
    
    private z_BindHyperpipeSGIX_adr := GetProcAddress('glXBindHyperpipeSGIX');
    private z_BindHyperpipeSGIX_1 := GetProcOrNil&<function(dpy: x_p_display; hpId: Int32): Int32>(z_BindHyperpipeSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindHyperpipeSGIX(dpy: x_p_display; hpId: Int32): Int32 :=
    z_BindHyperpipeSGIX_1(dpy, hpId);
    
    private z_QueryHyperpipeBestAttribSGIX_adr := GetProcAddress('glXQueryHyperpipeBestAttribSGIX');
    private z_QueryHyperpipeBestAttribSGIX_1 := GetProcOrNil&<function(dpy: x_p_display; timeSlice: Int32; attrib: Int32; size: Int32; attribList: IntPtr; returnAttribList: IntPtr): Int32>(z_QueryHyperpipeBestAttribSGIX_adr);
    private z_QueryHyperpipeBestAttribSGIX_2 := GetProcOrNil&<function(dpy: x_p_display; timeSlice: Int32; attrib: Int32; size: Int32; var attribList: glx_pipe_rect_SGIX; var returnAttribList: glx_pipe_rect_SGIX): Int32>(z_QueryHyperpipeBestAttribSGIX_adr);
    private z_QueryHyperpipeBestAttribSGIX_3 := GetProcOrNil&<function(dpy: x_p_display; timeSlice: Int32; attrib: Int32; size: Int32; var attribList: glx_pipe_rect_limits_SGIX; var returnAttribList: glx_pipe_rect_limits_SGIX): Int32>(z_QueryHyperpipeBestAttribSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryHyperpipeBestAttribSGIX(dpy: x_p_display; timeSlice: Int32; attrib: Int32; size: Int32; attribList: array of glx_pipe_rect_limits_SGIX; returnAttribList: array of glx_pipe_rect_limits_SGIX): Int32;
    type Pglx_pipe_rect_limits_SGIX=^glx_pipe_rect_limits_SGIX;
    begin
      Result := if (returnAttribList<>nil) and (returnAttribList.Length<>0) then
        if (attribList<>nil) and (attribList.Length<>0) then
          z_QueryHyperpipeBestAttribSGIX_3(dpy, timeSlice, attrib, size, attribList[0], returnAttribList[0]) else
          z_QueryHyperpipeBestAttribSGIX_3(dpy, timeSlice, attrib, size, Pglx_pipe_rect_limits_SGIX(nil)^, returnAttribList[0]) else
        if (attribList<>nil) and (attribList.Length<>0) then
          z_QueryHyperpipeBestAttribSGIX_3(dpy, timeSlice, attrib, size, attribList[0], Pglx_pipe_rect_limits_SGIX(nil)^) else
          z_QueryHyperpipeBestAttribSGIX_3(dpy, timeSlice, attrib, size, Pglx_pipe_rect_limits_SGIX(nil)^, Pglx_pipe_rect_limits_SGIX(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryHyperpipeBestAttribSGIX(dpy: x_p_display; timeSlice: Int32; attrib: Int32; size: Int32; attribList: array of glx_pipe_rect_SGIX; returnAttribList: array of glx_pipe_rect_SGIX): Int32;
    type Pglx_pipe_rect_SGIX=^glx_pipe_rect_SGIX;
    begin
      Result := if (returnAttribList<>nil) and (returnAttribList.Length<>0) then
        if (attribList<>nil) and (attribList.Length<>0) then
          z_QueryHyperpipeBestAttribSGIX_2(dpy, timeSlice, attrib, size, attribList[0], returnAttribList[0]) else
          z_QueryHyperpipeBestAttribSGIX_2(dpy, timeSlice, attrib, size, Pglx_pipe_rect_SGIX(nil)^, returnAttribList[0]) else
        if (attribList<>nil) and (attribList.Length<>0) then
          z_QueryHyperpipeBestAttribSGIX_2(dpy, timeSlice, attrib, size, attribList[0], Pglx_pipe_rect_SGIX(nil)^) else
          z_QueryHyperpipeBestAttribSGIX_2(dpy, timeSlice, attrib, size, Pglx_pipe_rect_SGIX(nil)^, Pglx_pipe_rect_SGIX(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryHyperpipeBestAttribSGIX(dpy: x_p_display; timeSlice: Int32; attrib: Int32; size: Int32; var attribList: glx_pipe_rect_limits_SGIX; var returnAttribList: glx_pipe_rect_limits_SGIX): Int32 :=
    z_QueryHyperpipeBestAttribSGIX_3(dpy, timeSlice, attrib, size, attribList, returnAttribList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryHyperpipeBestAttribSGIX(dpy: x_p_display; timeSlice: Int32; attrib: Int32; size: Int32; var attribList: glx_pipe_rect_SGIX; var returnAttribList: glx_pipe_rect_SGIX): Int32 :=
    z_QueryHyperpipeBestAttribSGIX_2(dpy, timeSlice, attrib, size, attribList, returnAttribList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryHyperpipeBestAttribSGIX(dpy: x_p_display; timeSlice: Int32; attrib: Int32; size: Int32; attribList: IntPtr; returnAttribList: IntPtr): Int32 :=
    z_QueryHyperpipeBestAttribSGIX_1(dpy, timeSlice, attrib, size, attribList, returnAttribList);
    
    private z_HyperpipeAttribSGIX_adr := GetProcAddress('glXHyperpipeAttribSGIX');
    private z_HyperpipeAttribSGIX_1 := GetProcOrNil&<function(dpy: x_p_display; timeSlice: Int32; attrib: Int32; size: Int32; attribList: IntPtr): Int32>(z_HyperpipeAttribSGIX_adr);
    private z_HyperpipeAttribSGIX_2 := GetProcOrNil&<function(dpy: x_p_display; timeSlice: Int32; attrib: Int32; size: Int32; var attribList: Int32): Int32>(z_HyperpipeAttribSGIX_adr);
    private z_HyperpipeAttribSGIX_3 := GetProcOrNil&<function(dpy: x_p_display; timeSlice: Int32; attrib: Int32; size: Int32; var attribList: glx_pipe_rect_SGIX): Int32>(z_HyperpipeAttribSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function HyperpipeAttribSGIX(dpy: x_p_display; timeSlice: Int32; attrib: Int32; size: Int32; attribList: array of glx_pipe_rect_SGIX): Int32;
    type Pglx_pipe_rect_SGIX=^glx_pipe_rect_SGIX;
    begin
      Result := if (attribList<>nil) and (attribList.Length<>0) then
        z_HyperpipeAttribSGIX_3(dpy, timeSlice, attrib, size, attribList[0]) else
        z_HyperpipeAttribSGIX_3(dpy, timeSlice, attrib, size, Pglx_pipe_rect_SGIX(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function HyperpipeAttribSGIX(dpy: x_p_display; timeSlice: Int32; attrib: Int32; size: Int32; var attribList: glx_pipe_rect_SGIX): Int32 :=
    z_HyperpipeAttribSGIX_3(dpy, timeSlice, attrib, size, attribList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function HyperpipeAttribSGIX(dpy: x_p_display; timeSlice: Int32; attrib: Int32; size: Int32; var attribList: Int32): Int32 :=
    z_HyperpipeAttribSGIX_2(dpy, timeSlice, attrib, size, attribList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function HyperpipeAttribSGIX(dpy: x_p_display; timeSlice: Int32; attrib: Int32; size: Int32; attribList: IntPtr): Int32 :=
    z_HyperpipeAttribSGIX_1(dpy, timeSlice, attrib, size, attribList);
    
    private z_QueryHyperpipeAttribSGIX_adr := GetProcAddress('glXQueryHyperpipeAttribSGIX');
    private z_QueryHyperpipeAttribSGIX_1 := GetProcOrNil&<function(dpy: x_p_display; timeSlice: Int32; attrib: Int32; size: Int32; returnAttribList: IntPtr): Int32>(z_QueryHyperpipeAttribSGIX_adr);
    private z_QueryHyperpipeAttribSGIX_2 := GetProcOrNil&<function(dpy: x_p_display; timeSlice: Int32; attrib: Int32; size: Int32; var returnAttribList: glx_pipe_rect_SGIX): Int32>(z_QueryHyperpipeAttribSGIX_adr);
    private z_QueryHyperpipeAttribSGIX_3 := GetProcOrNil&<function(dpy: x_p_display; timeSlice: Int32; attrib: Int32; size: Int32; var returnAttribList: glx_pipe_rect_limits_SGIX): Int32>(z_QueryHyperpipeAttribSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryHyperpipeAttribSGIX(dpy: x_p_display; timeSlice: Int32; attrib: Int32; size: Int32; returnAttribList: array of glx_pipe_rect_limits_SGIX): Int32;
    type Pglx_pipe_rect_limits_SGIX=^glx_pipe_rect_limits_SGIX;
    begin
      Result := if (returnAttribList<>nil) and (returnAttribList.Length<>0) then
        z_QueryHyperpipeAttribSGIX_3(dpy, timeSlice, attrib, size, returnAttribList[0]) else
        z_QueryHyperpipeAttribSGIX_3(dpy, timeSlice, attrib, size, Pglx_pipe_rect_limits_SGIX(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryHyperpipeAttribSGIX(dpy: x_p_display; timeSlice: Int32; attrib: Int32; size: Int32; returnAttribList: array of glx_pipe_rect_SGIX): Int32;
    type Pglx_pipe_rect_SGIX=^glx_pipe_rect_SGIX;
    begin
      Result := if (returnAttribList<>nil) and (returnAttribList.Length<>0) then
        z_QueryHyperpipeAttribSGIX_2(dpy, timeSlice, attrib, size, returnAttribList[0]) else
        z_QueryHyperpipeAttribSGIX_2(dpy, timeSlice, attrib, size, Pglx_pipe_rect_SGIX(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryHyperpipeAttribSGIX(dpy: x_p_display; timeSlice: Int32; attrib: Int32; size: Int32; var returnAttribList: glx_pipe_rect_limits_SGIX): Int32 :=
    z_QueryHyperpipeAttribSGIX_3(dpy, timeSlice, attrib, size, returnAttribList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryHyperpipeAttribSGIX(dpy: x_p_display; timeSlice: Int32; attrib: Int32; size: Int32; var returnAttribList: glx_pipe_rect_SGIX): Int32 :=
    z_QueryHyperpipeAttribSGIX_2(dpy, timeSlice, attrib, size, returnAttribList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryHyperpipeAttribSGIX(dpy: x_p_display; timeSlice: Int32; attrib: Int32; size: Int32; returnAttribList: IntPtr): Int32 :=
    z_QueryHyperpipeAttribSGIX_1(dpy, timeSlice, attrib, size, returnAttribList);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glxPbufferSGIX = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'glx_sgix_pbuffer';
    
    private z_CreateGLXPbufferSGIX_adr := GetProcAddress('glXCreateGLXPbufferSGIX');
    private z_CreateGLXPbufferSGIX_1 := GetProcOrNil&<function(dpy: x_p_display; config: glx_fb_config; width: UInt32; height: UInt32; attrib_list: IntPtr): glx_pbuffer>(z_CreateGLXPbufferSGIX_adr);
    private z_CreateGLXPbufferSGIX_2 := GetProcOrNil&<function(dpy: x_p_display; config: glx_fb_config; width: UInt32; height: UInt32; var attrib_list: Int32): glx_pbuffer>(z_CreateGLXPbufferSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateGLXPbufferSGIX(dpy: x_p_display; config: glx_fb_config; width: UInt32; height: UInt32; attrib_list: array of Int32): glx_pbuffer;
    type PInt32=^Int32;
    begin
      Result := if (attrib_list<>nil) and (attrib_list.Length<>0) then
        z_CreateGLXPbufferSGIX_2(dpy, config, width, height, attrib_list[0]) else
        z_CreateGLXPbufferSGIX_2(dpy, config, width, height, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateGLXPbufferSGIX(dpy: x_p_display; config: glx_fb_config; width: UInt32; height: UInt32; var attrib_list: Int32): glx_pbuffer :=
    z_CreateGLXPbufferSGIX_2(dpy, config, width, height, attrib_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateGLXPbufferSGIX(dpy: x_p_display; config: glx_fb_config; width: UInt32; height: UInt32; attrib_list: IntPtr): glx_pbuffer :=
    z_CreateGLXPbufferSGIX_1(dpy, config, width, height, attrib_list);
    
    private z_DestroyGLXPbufferSGIX_adr := GetProcAddress('glXDestroyGLXPbufferSGIX');
    private z_DestroyGLXPbufferSGIX_1 := GetProcOrNil&<procedure(dpy: x_p_display; pbuf: glx_pbuffer)>(z_DestroyGLXPbufferSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DestroyGLXPbufferSGIX(dpy: x_p_display; pbuf: glx_pbuffer) :=
    z_DestroyGLXPbufferSGIX_1(dpy, pbuf);
    
    private z_QueryGLXPbufferSGIX_adr := GetProcAddress('glXQueryGLXPbufferSGIX');
    private z_QueryGLXPbufferSGIX_1 := GetProcOrNil&<procedure(dpy: x_p_display; pbuf: glx_pbuffer; attribute: Int32; value: IntPtr)>(z_QueryGLXPbufferSGIX_adr);
    private z_QueryGLXPbufferSGIX_2 := GetProcOrNil&<procedure(dpy: x_p_display; pbuf: glx_pbuffer; attribute: Int32; var value: UInt32)>(z_QueryGLXPbufferSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure QueryGLXPbufferSGIX(dpy: x_p_display; pbuf: glx_pbuffer; attribute: Int32; value: array of UInt32);
    type PUInt32=^UInt32;
    begin
      if (value<>nil) and (value.Length<>0) then
        z_QueryGLXPbufferSGIX_2(dpy, pbuf, attribute, value[0]) else
        z_QueryGLXPbufferSGIX_2(dpy, pbuf, attribute, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure QueryGLXPbufferSGIX(dpy: x_p_display; pbuf: glx_pbuffer; attribute: Int32; var value: UInt32) :=
    z_QueryGLXPbufferSGIX_2(dpy, pbuf, attribute, value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure QueryGLXPbufferSGIX(dpy: x_p_display; pbuf: glx_pbuffer; attribute: Int32; value: IntPtr) :=
    z_QueryGLXPbufferSGIX_1(dpy, pbuf, attribute, value);
    
    private z_SelectEventSGIX_adr := GetProcAddress('glXSelectEventSGIX');
    private z_SelectEventSGIX_1 := GetProcOrNil&<procedure(dpy: x_p_display; drawable: glx_drawable; mask: UInt64)>(z_SelectEventSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SelectEventSGIX(dpy: x_p_display; drawable: glx_drawable; mask: UInt64) :=
    z_SelectEventSGIX_1(dpy, drawable, mask);
    
    private z_GetSelectedEventSGIX_adr := GetProcAddress('glXGetSelectedEventSGIX');
    private z_GetSelectedEventSGIX_1 := GetProcOrNil&<procedure(dpy: x_p_display; drawable: glx_drawable; mask: IntPtr)>(z_GetSelectedEventSGIX_adr);
    private z_GetSelectedEventSGIX_2 := GetProcOrNil&<procedure(dpy: x_p_display; drawable: glx_drawable; var mask: UInt64)>(z_GetSelectedEventSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSelectedEventSGIX(dpy: x_p_display; drawable: glx_drawable; var mask: UInt64) :=
    z_GetSelectedEventSGIX_2(dpy, drawable, mask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSelectedEventSGIX(dpy: x_p_display; drawable: glx_drawable; mask: IntPtr) :=
    z_GetSelectedEventSGIX_1(dpy, drawable, mask);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glxSwapBarrierSGIX = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'glx_sgix_swap_barrier';
    
    private z_BindSwapBarrierSGIX_adr := GetProcAddress('glXBindSwapBarrierSGIX');
    private z_BindSwapBarrierSGIX_1 := GetProcOrNil&<procedure(dpy: x_p_display; drawable: glx_drawable; barrier: Int32)>(z_BindSwapBarrierSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindSwapBarrierSGIX(dpy: x_p_display; drawable: glx_drawable; barrier: Int32) :=
    z_BindSwapBarrierSGIX_1(dpy, drawable, barrier);
    
    private z_QueryMaxSwapBarriersSGIX_adr := GetProcAddress('glXQueryMaxSwapBarriersSGIX');
    private z_QueryMaxSwapBarriersSGIX_1 := GetProcOrNil&<function(dpy: x_p_display; screen: Int32; max: IntPtr): Bool>(z_QueryMaxSwapBarriersSGIX_adr);
    private z_QueryMaxSwapBarriersSGIX_2 := GetProcOrNil&<function(dpy: x_p_display; screen: Int32; var max: Int32): Bool>(z_QueryMaxSwapBarriersSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapBarriersSGIX(dpy: x_p_display; screen: Int32; max: array of Int32): Bool;
    type PInt32=^Int32;
    begin
      Result := if (max<>nil) and (max.Length<>0) then
        z_QueryMaxSwapBarriersSGIX_2(dpy, screen, max[0]) else
        z_QueryMaxSwapBarriersSGIX_2(dpy, screen, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapBarriersSGIX(dpy: x_p_display; screen: Int32; var max: Int32): Bool :=
    z_QueryMaxSwapBarriersSGIX_2(dpy, screen, max);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapBarriersSGIX(dpy: x_p_display; screen: Int32; max: IntPtr): Bool :=
    z_QueryMaxSwapBarriersSGIX_1(dpy, screen, max);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glxSwapGroupSGIX = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'glx_sgix_swap_group';
    
    private z_JoinSwapGroupSGIX_adr := GetProcAddress('glXJoinSwapGroupSGIX');
    private z_JoinSwapGroupSGIX_1 := GetProcOrNil&<procedure(dpy: x_p_display; drawable: glx_drawable; member: glx_drawable)>(z_JoinSwapGroupSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure JoinSwapGroupSGIX(dpy: x_p_display; drawable: glx_drawable; member: glx_drawable) :=
    z_JoinSwapGroupSGIX_1(dpy, drawable, member);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glxVideoResizeSGIX = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'glx_sgix_video_resize';
    
    private z_BindChannelToWindowSGIX_adr := GetProcAddress('glXBindChannelToWindowSGIX');
    private z_BindChannelToWindowSGIX_1 := GetProcOrNil&<function(display: x_p_display; screen: Int32; channel: Int32; window: x_window): Int32>(z_BindChannelToWindowSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindChannelToWindowSGIX(display: x_p_display; screen: Int32; channel: Int32; window: x_window): Int32 :=
    z_BindChannelToWindowSGIX_1(display, screen, channel, window);
    
    private z_ChannelRectSGIX_adr := GetProcAddress('glXChannelRectSGIX');
    private z_ChannelRectSGIX_1 := GetProcOrNil&<function(display: x_p_display; screen: Int32; channel: Int32; x: Int32; y: Int32; w: Int32; h: Int32): Int32>(z_ChannelRectSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChannelRectSGIX(display: x_p_display; screen: Int32; channel: Int32; x: Int32; y: Int32; w: Int32; h: Int32): Int32 :=
    z_ChannelRectSGIX_1(display, screen, channel, x, y, w, h);
    
    private z_QueryChannelRectSGIX_adr := GetProcAddress('glXQueryChannelRectSGIX');
    private z_QueryChannelRectSGIX_1 := GetProcOrNil&<function(display: x_p_display; screen: Int32; channel: Int32; dx: IntPtr; dy: IntPtr; dw: IntPtr; dh: IntPtr): Int32>(z_QueryChannelRectSGIX_adr);
    private z_QueryChannelRectSGIX_2 := GetProcOrNil&<function(display: x_p_display; screen: Int32; channel: Int32; dx: IntPtr; dy: IntPtr; dw: IntPtr; var dh: Int32): Int32>(z_QueryChannelRectSGIX_adr);
    private z_QueryChannelRectSGIX_3 := GetProcOrNil&<function(display: x_p_display; screen: Int32; channel: Int32; dx: IntPtr; dy: IntPtr; var dw: Int32; dh: IntPtr): Int32>(z_QueryChannelRectSGIX_adr);
    private z_QueryChannelRectSGIX_4 := GetProcOrNil&<function(display: x_p_display; screen: Int32; channel: Int32; dx: IntPtr; dy: IntPtr; var dw: Int32; var dh: Int32): Int32>(z_QueryChannelRectSGIX_adr);
    private z_QueryChannelRectSGIX_5 := GetProcOrNil&<function(display: x_p_display; screen: Int32; channel: Int32; dx: IntPtr; var dy: Int32; dw: IntPtr; dh: IntPtr): Int32>(z_QueryChannelRectSGIX_adr);
    private z_QueryChannelRectSGIX_6 := GetProcOrNil&<function(display: x_p_display; screen: Int32; channel: Int32; dx: IntPtr; var dy: Int32; dw: IntPtr; var dh: Int32): Int32>(z_QueryChannelRectSGIX_adr);
    private z_QueryChannelRectSGIX_7 := GetProcOrNil&<function(display: x_p_display; screen: Int32; channel: Int32; dx: IntPtr; var dy: Int32; var dw: Int32; dh: IntPtr): Int32>(z_QueryChannelRectSGIX_adr);
    private z_QueryChannelRectSGIX_8 := GetProcOrNil&<function(display: x_p_display; screen: Int32; channel: Int32; dx: IntPtr; var dy: Int32; var dw: Int32; var dh: Int32): Int32>(z_QueryChannelRectSGIX_adr);
    private z_QueryChannelRectSGIX_9 := GetProcOrNil&<function(display: x_p_display; screen: Int32; channel: Int32; var dx: Int32; dy: IntPtr; dw: IntPtr; dh: IntPtr): Int32>(z_QueryChannelRectSGIX_adr);
    private z_QueryChannelRectSGIX_10 := GetProcOrNil&<function(display: x_p_display; screen: Int32; channel: Int32; var dx: Int32; dy: IntPtr; dw: IntPtr; var dh: Int32): Int32>(z_QueryChannelRectSGIX_adr);
    private z_QueryChannelRectSGIX_11 := GetProcOrNil&<function(display: x_p_display; screen: Int32; channel: Int32; var dx: Int32; dy: IntPtr; var dw: Int32; dh: IntPtr): Int32>(z_QueryChannelRectSGIX_adr);
    private z_QueryChannelRectSGIX_12 := GetProcOrNil&<function(display: x_p_display; screen: Int32; channel: Int32; var dx: Int32; dy: IntPtr; var dw: Int32; var dh: Int32): Int32>(z_QueryChannelRectSGIX_adr);
    private z_QueryChannelRectSGIX_13 := GetProcOrNil&<function(display: x_p_display; screen: Int32; channel: Int32; var dx: Int32; var dy: Int32; dw: IntPtr; dh: IntPtr): Int32>(z_QueryChannelRectSGIX_adr);
    private z_QueryChannelRectSGIX_14 := GetProcOrNil&<function(display: x_p_display; screen: Int32; channel: Int32; var dx: Int32; var dy: Int32; dw: IntPtr; var dh: Int32): Int32>(z_QueryChannelRectSGIX_adr);
    private z_QueryChannelRectSGIX_15 := GetProcOrNil&<function(display: x_p_display; screen: Int32; channel: Int32; var dx: Int32; var dy: Int32; var dw: Int32; dh: IntPtr): Int32>(z_QueryChannelRectSGIX_adr);
    private z_QueryChannelRectSGIX_16 := GetProcOrNil&<function(display: x_p_display; screen: Int32; channel: Int32; var dx: Int32; var dy: Int32; var dw: Int32; var dh: Int32): Int32>(z_QueryChannelRectSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: x_p_display; screen: Int32; channel: Int32; dx: array of Int32; dy: array of Int32; dw: array of Int32; dh: array of Int32): Int32;
    type PInt32=^Int32;
    begin
      Result := if (dh<>nil) and (dh.Length<>0) then
        if (dw<>nil) and (dw.Length<>0) then
          if (dy<>nil) and (dy.Length<>0) then
            if (dx<>nil) and (dx.Length<>0) then
              z_QueryChannelRectSGIX_16(display, screen, channel, dx[0], dy[0], dw[0], dh[0]) else
              z_QueryChannelRectSGIX_16(display, screen, channel, PInt32(nil)^, dy[0], dw[0], dh[0]) else
            if (dx<>nil) and (dx.Length<>0) then
              z_QueryChannelRectSGIX_16(display, screen, channel, dx[0], PInt32(nil)^, dw[0], dh[0]) else
              z_QueryChannelRectSGIX_16(display, screen, channel, PInt32(nil)^, PInt32(nil)^, dw[0], dh[0]) else
          if (dy<>nil) and (dy.Length<>0) then
            if (dx<>nil) and (dx.Length<>0) then
              z_QueryChannelRectSGIX_16(display, screen, channel, dx[0], dy[0], PInt32(nil)^, dh[0]) else
              z_QueryChannelRectSGIX_16(display, screen, channel, PInt32(nil)^, dy[0], PInt32(nil)^, dh[0]) else
            if (dx<>nil) and (dx.Length<>0) then
              z_QueryChannelRectSGIX_16(display, screen, channel, dx[0], PInt32(nil)^, PInt32(nil)^, dh[0]) else
              z_QueryChannelRectSGIX_16(display, screen, channel, PInt32(nil)^, PInt32(nil)^, PInt32(nil)^, dh[0]) else
        if (dw<>nil) and (dw.Length<>0) then
          if (dy<>nil) and (dy.Length<>0) then
            if (dx<>nil) and (dx.Length<>0) then
              z_QueryChannelRectSGIX_16(display, screen, channel, dx[0], dy[0], dw[0], PInt32(nil)^) else
              z_QueryChannelRectSGIX_16(display, screen, channel, PInt32(nil)^, dy[0], dw[0], PInt32(nil)^) else
            if (dx<>nil) and (dx.Length<>0) then
              z_QueryChannelRectSGIX_16(display, screen, channel, dx[0], PInt32(nil)^, dw[0], PInt32(nil)^) else
              z_QueryChannelRectSGIX_16(display, screen, channel, PInt32(nil)^, PInt32(nil)^, dw[0], PInt32(nil)^) else
          if (dy<>nil) and (dy.Length<>0) then
            if (dx<>nil) and (dx.Length<>0) then
              z_QueryChannelRectSGIX_16(display, screen, channel, dx[0], dy[0], PInt32(nil)^, PInt32(nil)^) else
              z_QueryChannelRectSGIX_16(display, screen, channel, PInt32(nil)^, dy[0], PInt32(nil)^, PInt32(nil)^) else
            if (dx<>nil) and (dx.Length<>0) then
              z_QueryChannelRectSGIX_16(display, screen, channel, dx[0], PInt32(nil)^, PInt32(nil)^, PInt32(nil)^) else
              z_QueryChannelRectSGIX_16(display, screen, channel, PInt32(nil)^, PInt32(nil)^, PInt32(nil)^, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: x_p_display; screen: Int32; channel: Int32; var dx: Int32; var dy: Int32; var dw: Int32; var dh: Int32): Int32 :=
    z_QueryChannelRectSGIX_16(display, screen, channel, dx, dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: x_p_display; screen: Int32; channel: Int32; var dx: Int32; var dy: Int32; var dw: Int32; dh: IntPtr): Int32 :=
    z_QueryChannelRectSGIX_15(display, screen, channel, dx, dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: x_p_display; screen: Int32; channel: Int32; var dx: Int32; var dy: Int32; dw: IntPtr; var dh: Int32): Int32 :=
    z_QueryChannelRectSGIX_14(display, screen, channel, dx, dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: x_p_display; screen: Int32; channel: Int32; var dx: Int32; var dy: Int32; dw: IntPtr; dh: IntPtr): Int32 :=
    z_QueryChannelRectSGIX_13(display, screen, channel, dx, dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: x_p_display; screen: Int32; channel: Int32; var dx: Int32; dy: IntPtr; var dw: Int32; var dh: Int32): Int32 :=
    z_QueryChannelRectSGIX_12(display, screen, channel, dx, dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: x_p_display; screen: Int32; channel: Int32; var dx: Int32; dy: IntPtr; var dw: Int32; dh: IntPtr): Int32 :=
    z_QueryChannelRectSGIX_11(display, screen, channel, dx, dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: x_p_display; screen: Int32; channel: Int32; var dx: Int32; dy: IntPtr; dw: IntPtr; var dh: Int32): Int32 :=
    z_QueryChannelRectSGIX_10(display, screen, channel, dx, dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: x_p_display; screen: Int32; channel: Int32; var dx: Int32; dy: IntPtr; dw: IntPtr; dh: IntPtr): Int32 :=
    z_QueryChannelRectSGIX_9(display, screen, channel, dx, dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: x_p_display; screen: Int32; channel: Int32; dx: IntPtr; var dy: Int32; var dw: Int32; var dh: Int32): Int32 :=
    z_QueryChannelRectSGIX_8(display, screen, channel, dx, dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: x_p_display; screen: Int32; channel: Int32; dx: IntPtr; var dy: Int32; var dw: Int32; dh: IntPtr): Int32 :=
    z_QueryChannelRectSGIX_7(display, screen, channel, dx, dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: x_p_display; screen: Int32; channel: Int32; dx: IntPtr; var dy: Int32; dw: IntPtr; var dh: Int32): Int32 :=
    z_QueryChannelRectSGIX_6(display, screen, channel, dx, dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: x_p_display; screen: Int32; channel: Int32; dx: IntPtr; var dy: Int32; dw: IntPtr; dh: IntPtr): Int32 :=
    z_QueryChannelRectSGIX_5(display, screen, channel, dx, dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: x_p_display; screen: Int32; channel: Int32; dx: IntPtr; dy: IntPtr; var dw: Int32; var dh: Int32): Int32 :=
    z_QueryChannelRectSGIX_4(display, screen, channel, dx, dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: x_p_display; screen: Int32; channel: Int32; dx: IntPtr; dy: IntPtr; var dw: Int32; dh: IntPtr): Int32 :=
    z_QueryChannelRectSGIX_3(display, screen, channel, dx, dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: x_p_display; screen: Int32; channel: Int32; dx: IntPtr; dy: IntPtr; dw: IntPtr; var dh: Int32): Int32 :=
    z_QueryChannelRectSGIX_2(display, screen, channel, dx, dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: x_p_display; screen: Int32; channel: Int32; dx: IntPtr; dy: IntPtr; dw: IntPtr; dh: IntPtr): Int32 :=
    z_QueryChannelRectSGIX_1(display, screen, channel, dx, dy, dw, dh);
    
    private z_QueryChannelDeltasSGIX_adr := GetProcAddress('glXQueryChannelDeltasSGIX');
    private z_QueryChannelDeltasSGIX_1 := GetProcOrNil&<function(display: x_p_display; screen: Int32; channel: Int32; x: IntPtr; y: IntPtr; w: IntPtr; h: IntPtr): Int32>(z_QueryChannelDeltasSGIX_adr);
    private z_QueryChannelDeltasSGIX_2 := GetProcOrNil&<function(display: x_p_display; screen: Int32; channel: Int32; x: IntPtr; y: IntPtr; w: IntPtr; var h: Int32): Int32>(z_QueryChannelDeltasSGIX_adr);
    private z_QueryChannelDeltasSGIX_3 := GetProcOrNil&<function(display: x_p_display; screen: Int32; channel: Int32; x: IntPtr; y: IntPtr; var w: Int32; h: IntPtr): Int32>(z_QueryChannelDeltasSGIX_adr);
    private z_QueryChannelDeltasSGIX_4 := GetProcOrNil&<function(display: x_p_display; screen: Int32; channel: Int32; x: IntPtr; y: IntPtr; var w: Int32; var h: Int32): Int32>(z_QueryChannelDeltasSGIX_adr);
    private z_QueryChannelDeltasSGIX_5 := GetProcOrNil&<function(display: x_p_display; screen: Int32; channel: Int32; x: IntPtr; var y: Int32; w: IntPtr; h: IntPtr): Int32>(z_QueryChannelDeltasSGIX_adr);
    private z_QueryChannelDeltasSGIX_6 := GetProcOrNil&<function(display: x_p_display; screen: Int32; channel: Int32; x: IntPtr; var y: Int32; w: IntPtr; var h: Int32): Int32>(z_QueryChannelDeltasSGIX_adr);
    private z_QueryChannelDeltasSGIX_7 := GetProcOrNil&<function(display: x_p_display; screen: Int32; channel: Int32; x: IntPtr; var y: Int32; var w: Int32; h: IntPtr): Int32>(z_QueryChannelDeltasSGIX_adr);
    private z_QueryChannelDeltasSGIX_8 := GetProcOrNil&<function(display: x_p_display; screen: Int32; channel: Int32; x: IntPtr; var y: Int32; var w: Int32; var h: Int32): Int32>(z_QueryChannelDeltasSGIX_adr);
    private z_QueryChannelDeltasSGIX_9 := GetProcOrNil&<function(display: x_p_display; screen: Int32; channel: Int32; var x: Int32; y: IntPtr; w: IntPtr; h: IntPtr): Int32>(z_QueryChannelDeltasSGIX_adr);
    private z_QueryChannelDeltasSGIX_10 := GetProcOrNil&<function(display: x_p_display; screen: Int32; channel: Int32; var x: Int32; y: IntPtr; w: IntPtr; var h: Int32): Int32>(z_QueryChannelDeltasSGIX_adr);
    private z_QueryChannelDeltasSGIX_11 := GetProcOrNil&<function(display: x_p_display; screen: Int32; channel: Int32; var x: Int32; y: IntPtr; var w: Int32; h: IntPtr): Int32>(z_QueryChannelDeltasSGIX_adr);
    private z_QueryChannelDeltasSGIX_12 := GetProcOrNil&<function(display: x_p_display; screen: Int32; channel: Int32; var x: Int32; y: IntPtr; var w: Int32; var h: Int32): Int32>(z_QueryChannelDeltasSGIX_adr);
    private z_QueryChannelDeltasSGIX_13 := GetProcOrNil&<function(display: x_p_display; screen: Int32; channel: Int32; var x: Int32; var y: Int32; w: IntPtr; h: IntPtr): Int32>(z_QueryChannelDeltasSGIX_adr);
    private z_QueryChannelDeltasSGIX_14 := GetProcOrNil&<function(display: x_p_display; screen: Int32; channel: Int32; var x: Int32; var y: Int32; w: IntPtr; var h: Int32): Int32>(z_QueryChannelDeltasSGIX_adr);
    private z_QueryChannelDeltasSGIX_15 := GetProcOrNil&<function(display: x_p_display; screen: Int32; channel: Int32; var x: Int32; var y: Int32; var w: Int32; h: IntPtr): Int32>(z_QueryChannelDeltasSGIX_adr);
    private z_QueryChannelDeltasSGIX_16 := GetProcOrNil&<function(display: x_p_display; screen: Int32; channel: Int32; var x: Int32; var y: Int32; var w: Int32; var h: Int32): Int32>(z_QueryChannelDeltasSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: x_p_display; screen: Int32; channel: Int32; x: array of Int32; y: array of Int32; w: array of Int32; h: array of Int32): Int32;
    type PInt32=^Int32;
    begin
      Result := if (h<>nil) and (h.Length<>0) then
        if (w<>nil) and (w.Length<>0) then
          if (y<>nil) and (y.Length<>0) then
            if (x<>nil) and (x.Length<>0) then
              z_QueryChannelDeltasSGIX_16(display, screen, channel, x[0], y[0], w[0], h[0]) else
              z_QueryChannelDeltasSGIX_16(display, screen, channel, PInt32(nil)^, y[0], w[0], h[0]) else
            if (x<>nil) and (x.Length<>0) then
              z_QueryChannelDeltasSGIX_16(display, screen, channel, x[0], PInt32(nil)^, w[0], h[0]) else
              z_QueryChannelDeltasSGIX_16(display, screen, channel, PInt32(nil)^, PInt32(nil)^, w[0], h[0]) else
          if (y<>nil) and (y.Length<>0) then
            if (x<>nil) and (x.Length<>0) then
              z_QueryChannelDeltasSGIX_16(display, screen, channel, x[0], y[0], PInt32(nil)^, h[0]) else
              z_QueryChannelDeltasSGIX_16(display, screen, channel, PInt32(nil)^, y[0], PInt32(nil)^, h[0]) else
            if (x<>nil) and (x.Length<>0) then
              z_QueryChannelDeltasSGIX_16(display, screen, channel, x[0], PInt32(nil)^, PInt32(nil)^, h[0]) else
              z_QueryChannelDeltasSGIX_16(display, screen, channel, PInt32(nil)^, PInt32(nil)^, PInt32(nil)^, h[0]) else
        if (w<>nil) and (w.Length<>0) then
          if (y<>nil) and (y.Length<>0) then
            if (x<>nil) and (x.Length<>0) then
              z_QueryChannelDeltasSGIX_16(display, screen, channel, x[0], y[0], w[0], PInt32(nil)^) else
              z_QueryChannelDeltasSGIX_16(display, screen, channel, PInt32(nil)^, y[0], w[0], PInt32(nil)^) else
            if (x<>nil) and (x.Length<>0) then
              z_QueryChannelDeltasSGIX_16(display, screen, channel, x[0], PInt32(nil)^, w[0], PInt32(nil)^) else
              z_QueryChannelDeltasSGIX_16(display, screen, channel, PInt32(nil)^, PInt32(nil)^, w[0], PInt32(nil)^) else
          if (y<>nil) and (y.Length<>0) then
            if (x<>nil) and (x.Length<>0) then
              z_QueryChannelDeltasSGIX_16(display, screen, channel, x[0], y[0], PInt32(nil)^, PInt32(nil)^) else
              z_QueryChannelDeltasSGIX_16(display, screen, channel, PInt32(nil)^, y[0], PInt32(nil)^, PInt32(nil)^) else
            if (x<>nil) and (x.Length<>0) then
              z_QueryChannelDeltasSGIX_16(display, screen, channel, x[0], PInt32(nil)^, PInt32(nil)^, PInt32(nil)^) else
              z_QueryChannelDeltasSGIX_16(display, screen, channel, PInt32(nil)^, PInt32(nil)^, PInt32(nil)^, PInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: x_p_display; screen: Int32; channel: Int32; var x: Int32; var y: Int32; var w: Int32; var h: Int32): Int32 :=
    z_QueryChannelDeltasSGIX_16(display, screen, channel, x, y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: x_p_display; screen: Int32; channel: Int32; var x: Int32; var y: Int32; var w: Int32; h: IntPtr): Int32 :=
    z_QueryChannelDeltasSGIX_15(display, screen, channel, x, y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: x_p_display; screen: Int32; channel: Int32; var x: Int32; var y: Int32; w: IntPtr; var h: Int32): Int32 :=
    z_QueryChannelDeltasSGIX_14(display, screen, channel, x, y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: x_p_display; screen: Int32; channel: Int32; var x: Int32; var y: Int32; w: IntPtr; h: IntPtr): Int32 :=
    z_QueryChannelDeltasSGIX_13(display, screen, channel, x, y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: x_p_display; screen: Int32; channel: Int32; var x: Int32; y: IntPtr; var w: Int32; var h: Int32): Int32 :=
    z_QueryChannelDeltasSGIX_12(display, screen, channel, x, y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: x_p_display; screen: Int32; channel: Int32; var x: Int32; y: IntPtr; var w: Int32; h: IntPtr): Int32 :=
    z_QueryChannelDeltasSGIX_11(display, screen, channel, x, y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: x_p_display; screen: Int32; channel: Int32; var x: Int32; y: IntPtr; w: IntPtr; var h: Int32): Int32 :=
    z_QueryChannelDeltasSGIX_10(display, screen, channel, x, y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: x_p_display; screen: Int32; channel: Int32; var x: Int32; y: IntPtr; w: IntPtr; h: IntPtr): Int32 :=
    z_QueryChannelDeltasSGIX_9(display, screen, channel, x, y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: x_p_display; screen: Int32; channel: Int32; x: IntPtr; var y: Int32; var w: Int32; var h: Int32): Int32 :=
    z_QueryChannelDeltasSGIX_8(display, screen, channel, x, y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: x_p_display; screen: Int32; channel: Int32; x: IntPtr; var y: Int32; var w: Int32; h: IntPtr): Int32 :=
    z_QueryChannelDeltasSGIX_7(display, screen, channel, x, y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: x_p_display; screen: Int32; channel: Int32; x: IntPtr; var y: Int32; w: IntPtr; var h: Int32): Int32 :=
    z_QueryChannelDeltasSGIX_6(display, screen, channel, x, y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: x_p_display; screen: Int32; channel: Int32; x: IntPtr; var y: Int32; w: IntPtr; h: IntPtr): Int32 :=
    z_QueryChannelDeltasSGIX_5(display, screen, channel, x, y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: x_p_display; screen: Int32; channel: Int32; x: IntPtr; y: IntPtr; var w: Int32; var h: Int32): Int32 :=
    z_QueryChannelDeltasSGIX_4(display, screen, channel, x, y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: x_p_display; screen: Int32; channel: Int32; x: IntPtr; y: IntPtr; var w: Int32; h: IntPtr): Int32 :=
    z_QueryChannelDeltasSGIX_3(display, screen, channel, x, y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: x_p_display; screen: Int32; channel: Int32; x: IntPtr; y: IntPtr; w: IntPtr; var h: Int32): Int32 :=
    z_QueryChannelDeltasSGIX_2(display, screen, channel, x, y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: x_p_display; screen: Int32; channel: Int32; x: IntPtr; y: IntPtr; w: IntPtr; h: IntPtr): Int32 :=
    z_QueryChannelDeltasSGIX_1(display, screen, channel, x, y, w, h);
    
    private z_ChannelRectSyncSGIX_adr := GetProcAddress('glXChannelRectSyncSGIX');
    private z_ChannelRectSyncSGIX_1 := GetProcOrNil&<function(display: x_p_display; screen: Int32; channel: Int32; synctype: DummyEnum): Int32>(z_ChannelRectSyncSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChannelRectSyncSGIX(display: x_p_display; screen: Int32; channel: Int32; synctype: DummyEnum): Int32 :=
    z_ChannelRectSyncSGIX_1(display, screen, channel, synctype);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glxVideoSourceSGIX = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'glx_sgix_video_source';
    
    private z_CreateGLXVideoSourceSGIX_adr := GetProcAddress('glXCreateGLXVideoSourceSGIX');
    private z_CreateGLXVideoSourceSGIX_1 := GetProcOrNil&<function(display: x_p_display; screen: Int32; server: x_vl_server; path: x_vl_path; nodeClass: Int32; drainNode: x_vl_node): glx_video_source_SGIX>(z_CreateGLXVideoSourceSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateGLXVideoSourceSGIX(display: x_p_display; screen: Int32; server: x_vl_server; path: x_vl_path; nodeClass: Int32; drainNode: x_vl_node): glx_video_source_SGIX :=
    z_CreateGLXVideoSourceSGIX_1(display, screen, server, path, nodeClass, drainNode);
    
    private z_DestroyGLXVideoSourceSGIX_adr := GetProcAddress('glXDestroyGLXVideoSourceSGIX');
    private z_DestroyGLXVideoSourceSGIX_1 := GetProcOrNil&<procedure(dpy: x_p_display; glxvideosource: glx_video_source_SGIX)>(z_DestroyGLXVideoSourceSGIX_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DestroyGLXVideoSourceSGIX(dpy: x_p_display; glxvideosource: glx_video_source_SGIX) :=
    z_DestroyGLXVideoSourceSGIX_1(dpy, glxvideosource);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  glxGetTransparentIndexSUN = sealed partial class
    private function GetProcAddress(name: string) := glx.GetProcAddress(name);
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
    fadr=IntPtr.Zero ? default(T) :
    Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const _ExtStr = 'glx_sun_get_transparent_index';
    
    private z_GetTransparentIndexSUN_adr := GetProcAddress('glXGetTransparentIndexSUN');
    private z_GetTransparentIndexSUN_1 := GetProcOrNil&<function(dpy: x_p_display; overlay: x_window; underlay: x_window; pTransparentIndex: IntPtr): Bool>(z_GetTransparentIndexSUN_adr);
    private z_GetTransparentIndexSUN_2 := GetProcOrNil&<function(dpy: x_p_display; overlay: x_window; underlay: x_window; var pTransparentIndex: UInt64): Bool>(z_GetTransparentIndexSUN_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetTransparentIndexSUN(dpy: x_p_display; overlay: x_window; underlay: x_window; var pTransparentIndex: UInt64): Bool :=
    z_GetTransparentIndexSUN_2(dpy, overlay, underlay, pTransparentIndex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetTransparentIndexSUN(dpy: x_p_display; overlay: x_window; underlay: x_window; pTransparentIndex: IntPtr): Bool :=
    z_GetTransparentIndexSUN_1(dpy, overlay, underlay, pTransparentIndex);
    
  end;
  
  {$endregion Extensions}
  
  
  