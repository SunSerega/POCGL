  
  
  
  Fixed = record
    public val: UInt32;
    
    public constructor(val: UInt32);
    begin
      self.val := val;
    end;
    
  end;
  
  gdi_colorref = record
    private a: byte := 0;
    public r: byte;
    public g: byte;
    public b: byte;
    
    public constructor(r: byte; g: byte; b: byte);
    begin
      self.r := r;
      self.g := g;
      self.b := b;
    end;
    
  end;
  
  gdi_glyphmetrics_float = record
    public gmfBlackBoxX: single;
    public gmfBlackBoxY: single;
    public gmfptGlyphOriginX: single;
    public gmfptGlyphOriginY: single;
    public gmfCellIncX: single;
    public gmfCellIncY: single;
    
    public constructor(gmfBlackBoxX: single; gmfBlackBoxY: single; gmfptGlyphOriginX: single; gmfptGlyphOriginY: single; gmfCellIncX: single; gmfCellIncY: single);
    begin
      self.gmfBlackBoxX := gmfBlackBoxX;
      self.gmfBlackBoxY := gmfBlackBoxY;
      self.gmfptGlyphOriginX := gmfptGlyphOriginX;
      self.gmfptGlyphOriginY := gmfptGlyphOriginY;
      self.gmfCellIncX := gmfCellIncX;
      self.gmfCellIncY := gmfCellIncY;
    end;
    
  end;
  
  gdi_layer_plane_descriptor = record
    public nSize: UInt16 := sizeof(gdi_layer_plane_descriptor);
    public nVersion: UInt16 := 1;
    
    public dwFlags: GDI_LayerPlaneFlags;
    public iPixelType: GDI_PixelDataType;
    
    public cColorBits: Byte; // Кол-во бит для R+G+B
    public cRedBits: Byte; // Если оставить эти 6 нулями - их заполнит автоматически
    public cRedShift: Byte;
    public cGreenBits: Byte;
    public cGreenShift: Byte;
    public cBlueBits: Byte;
    public cBlueShift: Byte;
    public cAlphaBits: Byte; // Последние 2 не работают на Windows
    public cAlphaShift: Byte;
    
    public cAccumBits: Byte;
    public cAccumRedBits: Byte;
    public cAccumGreenBits: Byte;
    public cAccumBlueBits: Byte;
    public cAccumAlphaBits: Byte;
    public cDepthBits: Byte;
    public cStencilBits: Byte;
    
    public cAuxBuffers: Byte; // Устарело
    public iLayerPlane: Byte;
    public bReserved: Byte;
    
    public crTransparent: gdi_colorref; // Прозрачный цвет работает только если в dwFlags добавить LayerPlaneFlagsGDI.TRANSPARENT
    
    public constructor(dwFlags: GDI_LayerPlaneFlags; iPixelType: GDI_PixelDataType; cColorBits: Byte; cRedBits: Byte; cRedShift: Byte; cGreenBits: Byte; cGreenShift: Byte; cBlueBits: Byte; cBlueShift: Byte; cAlphaBits: Byte; cAlphaShift: Byte; cAccumBits: Byte; cAccumRedBits: Byte; cAccumGreenBits: Byte; cAccumBlueBits: Byte; cAccumAlphaBits: Byte; cDepthBits: Byte; cStencilBits: Byte; cAuxBuffers: Byte; iLayerPlane: Byte; bReserved: Byte; crTransparent: gdi_colorref);
    begin
      self.dwFlags := dwFlags;
      self.iPixelType := iPixelType;
      self.cColorBits := cColorBits;
      self.cRedBits := cRedBits;
      self.cRedShift := cRedShift;
      self.cGreenBits := cGreenBits;
      self.cGreenShift := cGreenShift;
      self.cBlueBits := cBlueBits;
      self.cBlueShift := cBlueShift;
      self.cAlphaBits := cAlphaBits;
      self.cAlphaShift := cAlphaShift;
      self.cAccumBits := cAccumBits;
      self.cAccumRedBits := cAccumRedBits;
      self.cAccumGreenBits := cAccumGreenBits;
      self.cAccumBlueBits := cAccumBlueBits;
      self.cAccumAlphaBits := cAccumAlphaBits;
      self.cDepthBits := cDepthBits;
      self.cStencilBits := cStencilBits;
      self.cAuxBuffers := cAuxBuffers;
      self.iLayerPlane := iLayerPlane;
      self.bReserved := bReserved;
      self.crTransparent := crTransparent;
    end;
    
  end;
  
  gdi_pixel_format_descriptor = record
    public nSize: UInt16 := sizeof(gdi_pixel_format_descriptor);
    public nVersion: UInt16 := 1;
    
    public dwFlags: GDI_PixelFormatFlags;
    public iPixelType: GDI_PixelDataType;
    
    public cColorBits: Byte; // Кол-во бит для R+G+B
    public cRedBits: Byte; // Если оставить эти 6 нулями - их заполнит автоматически
    public cRedShift: Byte;
    public cGreenBits: Byte;
    public cGreenShift: Byte;
    public cBlueBits: Byte;
    public cBlueShift: Byte;
    public cAlphaBits: Byte; // Последние 2 не работают на Windows
    public cAlphaShift: Byte;
    
    public cAccumBits: Byte;
    public cAccumRedBits: Byte;
    public cAccumGreenBits: Byte;
    public cAccumBlueBits: Byte;
    public cAccumAlphaBits: Byte;
    
    public cDepthBits: Byte;
    public cStencilBits: Byte;
    public cAuxBuffers: Byte; // Устарело
    
    public iLayerType: Byte; // Устарело
    public bLayersSize: Byte; // Устарело
    
    public dwLayerMask: UInt32; // Не могу найти нормальное описание последних 3, но все оставляют их нулями
    public dwVisibleMask: UInt32;
    public dwDamageMask: UInt32;
    
    public constructor(dwFlags: GDI_PixelFormatFlags; iPixelType: GDI_PixelDataType; cColorBits: Byte; cRedBits: Byte; cRedShift: Byte; cGreenBits: Byte; cGreenShift: Byte; cBlueBits: Byte; cBlueShift: Byte; cAlphaBits: Byte; cAlphaShift: Byte; cAccumBits: Byte; cAccumRedBits: Byte; cAccumGreenBits: Byte; cAccumBlueBits: Byte; cAccumAlphaBits: Byte; cDepthBits: Byte; cStencilBits: Byte; cAuxBuffers: Byte; iLayerType: Byte; bLayersSize: Byte; dwLayerMask: UInt32; dwVisibleMask: UInt32; dwDamageMask: UInt32);
    begin
      self.dwFlags := dwFlags;
      self.iPixelType := iPixelType;
      self.cColorBits := cColorBits;
      self.cRedBits := cRedBits;
      self.cRedShift := cRedShift;
      self.cGreenBits := cGreenBits;
      self.cGreenShift := cGreenShift;
      self.cBlueBits := cBlueBits;
      self.cBlueShift := cBlueShift;
      self.cAlphaBits := cAlphaBits;
      self.cAlphaShift := cAlphaShift;
      self.cAccumBits := cAccumBits;
      self.cAccumRedBits := cAccumRedBits;
      self.cAccumGreenBits := cAccumGreenBits;
      self.cAccumBlueBits := cAccumBlueBits;
      self.cAccumAlphaBits := cAccumAlphaBits;
      self.cDepthBits := cDepthBits;
      self.cStencilBits := cStencilBits;
      self.cAuxBuffers := cAuxBuffers;
      self.iLayerType := iLayerType;
      self.bLayersSize := bLayersSize;
      self.dwLayerMask := dwLayerMask;
      self.dwVisibleMask := dwVisibleMask;
      self.dwDamageMask := dwDamageMask;
    end;
    
  end;
  
  [StructLayout(LayoutKind.Explicit, Size = 80)]
  ValueAnsiString_80 = record
    
    public property AnsiChars[i: integer]: Byte
    read Marshal.ReadByte(new IntPtr(@self), i)
    write Marshal.WriteByte(new IntPtr(@self), i, value);
    public property Chars[i: integer]: char read ChrAnsi(AnsiChars[i]) write AnsiChars[i] := OrdAnsi(value); default;
    
    public constructor(s: string; can_trim: boolean := false);
    begin
      var len := s.Length;
      if len>79 then
        if can_trim then
          len := 79 else
          raise new System.OverflowException;
      
      self.AnsiChars[len] := 0;
      for var i := 0 to len-1 do
        self[i] := s[i+1];
      
    end;
    
    public function ToString: string; override :=
    Marshal.PtrToStringAnsi(new IntPtr(@self));
    
    public static function operator implicit(s: string): ValueAnsiString_80 := new ValueAnsiString_80(s);
    public static function operator explicit(s: string): ValueAnsiString_80 := new ValueAnsiString_80(s, true);
    
    public static function operator implicit(s: ValueAnsiString_80): string := s.ToString;
    
  end;
  
  glx_hyperpipe_config_SGIX = record
    public pipeName: ValueAnsiString_80;
    public channel: Int32;
    public participationType: PipeParticipationTypeFlags;
    public timeSlice: Int32;
    
    public constructor(pipeName: ValueAnsiString_80; channel: Int32; participationType: PipeParticipationTypeFlags; timeSlice: Int32);
    begin
      self.pipeName := pipeName;
      self.channel := channel;
      self.participationType := participationType;
      self.timeSlice := timeSlice;
    end;
    
  end;
  
  glx_hyperpipe_network_SGIX = record
    public pipeName: ValueAnsiString_80;
    public networkId: Int32;
    
    public constructor(pipeName: ValueAnsiString_80; networkId: Int32);
    begin
      self.pipeName := pipeName;
      self.networkId := networkId;
    end;
    
  end;
  
  glx_pipe_rect_limits_SGIX = record
    public pipeName: ValueAnsiString_80;
    public XOrigin: Int32;
    public YOrigin: Int32;
    public maxHeight: Int32;
    public maxWidth: Int32;
    
    public constructor(pipeName: ValueAnsiString_80; XOrigin: Int32; YOrigin: Int32; maxHeight: Int32; maxWidth: Int32);
    begin
      self.pipeName := pipeName;
      self.XOrigin := XOrigin;
      self.YOrigin := YOrigin;
      self.maxHeight := maxHeight;
      self.maxWidth := maxWidth;
    end;
    
  end;
  
  glx_pipe_rect_SGIX = record
    public pipeName: ValueAnsiString_80;
    public srcXOrigin: Int32;
    public srcYOrigin: Int32;
    public srcWidth: Int32;
    public srcHeight: Int32;
    public destXOrigin: Int32;
    public destYOrigin: Int32;
    public destWidth: Int32;
    public destHeight: Int32;
    
    public constructor(pipeName: ValueAnsiString_80; srcXOrigin: Int32; srcYOrigin: Int32; srcWidth: Int32; srcHeight: Int32; destXOrigin: Int32; destYOrigin: Int32; destWidth: Int32; destHeight: Int32);
    begin
      self.pipeName := pipeName;
      self.srcXOrigin := srcXOrigin;
      self.srcYOrigin := srcYOrigin;
      self.srcWidth := srcWidth;
      self.srcHeight := srcHeight;
      self.destXOrigin := destXOrigin;
      self.destYOrigin := destYOrigin;
      self.destWidth := destWidth;
      self.destHeight := destHeight;
    end;
    
  end;
  
  Half = record
    public val: UInt16;
    
    public constructor(val: UInt16);
    begin
      self.val := val;
    end;
    
  end;
  
  [StructLayout(LayoutKind.Explicit, Size = 32)]
  ValueAnsiString_32 = record
    
    public property AnsiChars[i: integer]: Byte
    read Marshal.ReadByte(new IntPtr(@self), i)
    write Marshal.WriteByte(new IntPtr(@self), i, value);
    public property Chars[i: integer]: char read ChrAnsi(AnsiChars[i]) write AnsiChars[i] := OrdAnsi(value); default;
    
    public constructor(s: string; can_trim: boolean := false);
    begin
      var len := s.Length;
      if len>31 then
        if can_trim then
          len := 31 else
          raise new System.OverflowException;
      
      self.AnsiChars[len] := 0;
      for var i := 0 to len-1 do
        self[i] := s[i+1];
      
    end;
    
    public function ToString: string; override :=
    Marshal.PtrToStringAnsi(new IntPtr(@self));
    
    public static function operator implicit(s: string): ValueAnsiString_32 := new ValueAnsiString_32(s);
    public static function operator explicit(s: string): ValueAnsiString_32 := new ValueAnsiString_32(s, true);
    
    public static function operator implicit(s: ValueAnsiString_32): string := s.ToString;
    
  end;
  
  [StructLayout(LayoutKind.Explicit, Size = 128)]
  ValueAnsiString_128 = record
    
    public property AnsiChars[i: integer]: Byte
    read Marshal.ReadByte(new IntPtr(@self), i)
    write Marshal.WriteByte(new IntPtr(@self), i, value);
    public property Chars[i: integer]: char read ChrAnsi(AnsiChars[i]) write AnsiChars[i] := OrdAnsi(value); default;
    
    public constructor(s: string; can_trim: boolean := false);
    begin
      var len := s.Length;
      if len>127 then
        if can_trim then
          len := 127 else
          raise new System.OverflowException;
      
      self.AnsiChars[len] := 0;
      for var i := 0 to len-1 do
        self[i] := s[i+1];
      
    end;
    
    public function ToString: string; override :=
    Marshal.PtrToStringAnsi(new IntPtr(@self));
    
    public static function operator implicit(s: string): ValueAnsiString_128 := new ValueAnsiString_128(s);
    public static function operator explicit(s: string): ValueAnsiString_128 := new ValueAnsiString_128(s, true);
    
    public static function operator implicit(s: ValueAnsiString_128): string := s.ToString;
    
  end;
  
  wgl_GPU_device_NV = record
    public cb: UInt32 := sizeof(wgl_GPU_device_NV);
    public DeviceName: ValueAnsiString_32;
    public DeviceString: ValueAnsiString_128;
    public Flags: GPUDisplayDeviceFlags;
    public rcVirtualScreen: record left, top, right, bottom: Int64; end := (left: 0; top: 0; right: 0; bottom: 0);
    
    public constructor(DeviceName: ValueAnsiString_32; DeviceString: ValueAnsiString_128; Flags: GPUDisplayDeviceFlags);
    begin
      self.DeviceName := DeviceName;
      self.DeviceString := DeviceString;
      self.Flags := Flags;
    end;
    
  end;
  
  
  