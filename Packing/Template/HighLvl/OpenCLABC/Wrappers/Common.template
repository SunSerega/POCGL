  
  
  
  CLPlatform = partial class
    
    public property Native: cl_platform_id read ntv;
    
    private prop: CLPlatformProperties;
    private function GetProperties: CLPlatformProperties;
    begin
      if prop=nil then prop := new CLPlatformProperties(ntv);
      Result := prop;
    end;
    public property Properties: CLPlatformProperties read GetProperties;
    
    public static function operator=(wr1, wr2: CLPlatform): boolean :=
    ReferenceEquals(wr1,wr2) or not ReferenceEquals(wr1,nil) and not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    public static function operator<>(wr1, wr2: CLPlatform): boolean := false=
    ReferenceEquals(wr1,wr2) or not ReferenceEquals(wr1,nil) and not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    
    public function Equals(obj: object): boolean; override :=
    (obj is CLPlatform(var wr)) and (self = wr);
    
    public function GetHashCode: integer; override :=
    ntv.val.GetHashCode;
    
    public function ToString: string; override :=
    $'{TypeName(self)}[{ntv.val}]';
    
  end;
  
  CLDevice = partial class
    
    public property Native: cl_device_id read ntv;
    
    private prop: CLDeviceProperties;
    private function GetProperties: CLDeviceProperties;
    begin
      if prop=nil then prop := new CLDeviceProperties(ntv);
      Result := prop;
    end;
    public property Properties: CLDeviceProperties read GetProperties;
    
    public static function operator=(wr1, wr2: CLDevice): boolean :=
    ReferenceEquals(wr1,wr2) or not ReferenceEquals(wr1,nil) and not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    public static function operator<>(wr1, wr2: CLDevice): boolean := false=
    ReferenceEquals(wr1,wr2) or not ReferenceEquals(wr1,nil) and not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    
    public function Equals(obj: object): boolean; override :=
    (obj is CLDevice(var wr)) and (self = wr);
    
    public function GetHashCode: integer; override :=
    ntv.val.GetHashCode;
    
    public function ToString: string; override :=
    $'{TypeName(self)}[{ntv.val}]';
    
  end;
  
  CLSubDevice = partial class(CLDevice)
    
    private prop: CLSubDeviceProperties;
    private function GetProperties: CLSubDeviceProperties;
    begin
      if prop=nil then prop := new CLSubDeviceProperties(ntv);
      Result := prop;
    end;
    public property Properties: CLSubDeviceProperties read GetProperties;
    
    public function ToString: string; override :=
    $'{inherited ToString} of {Parent}';
    
  end;
  
  CLContext = partial class
    
    public property Native: cl_context read ntv;
    
    private prop: CLContextProperties;
    private function GetProperties: CLContextProperties;
    begin
      if prop=nil then prop := new CLContextProperties(ntv);
      Result := prop;
    end;
    public property Properties: CLContextProperties read GetProperties;
    
    public static function operator=(wr1, wr2: CLContext): boolean :=
    ReferenceEquals(wr1,wr2) or not ReferenceEquals(wr1,nil) and not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    public static function operator<>(wr1, wr2: CLContext): boolean := false=
    ReferenceEquals(wr1,wr2) or not ReferenceEquals(wr1,nil) and not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    
    public function Equals(obj: object): boolean; override :=
    (obj is CLContext(var wr)) and (self = wr);
    
    public function GetHashCode: integer; override :=
    ntv.val.GetHashCode;
    
    public function ToString: string; override :=
    $'{TypeName(self)}[{ntv.val}] on devices: {AllDevices.JoinToString('', '')}; Main device: {MainDevice}';
    
  end;
  
  CLCode = abstract partial class
    
    public property Native: cl_program read ntv;
    
    public static function operator=(wr1, wr2: CLCode): boolean :=
    ReferenceEquals(wr1,wr2) or not ReferenceEquals(wr1,nil) and not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    public static function operator<>(wr1, wr2: CLCode): boolean := false=
    ReferenceEquals(wr1,wr2) or not ReferenceEquals(wr1,nil) and not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    
    public function Equals(obj: object): boolean; override :=
    (obj is CLCode(var wr)) and (self = wr);
    
    public function GetHashCode: integer; override :=
    ntv.val.GetHashCode;
    
    public function ToString: string; override :=
    $'{TypeName(self)}[{ntv.val}]';
    
  end;
  
  CLKernel = partial class
    
    public static function operator=(wr1, wr2: CLKernel): boolean :=
    ReferenceEquals(wr1,wr2) or not ReferenceEquals(wr1,nil) and not ReferenceEquals(wr2,nil) and (wr1.Name=wr2.Name) and (wr1.CodeContainer=wr2.CodeContainer);
    public static function operator<>(wr1, wr2: CLKernel): boolean := false=
    ReferenceEquals(wr1,wr2) or not ReferenceEquals(wr1,nil) and not ReferenceEquals(wr2,nil) and (wr1.Name=wr2.Name) and (wr1.CodeContainer=wr2.CodeContainer);
    
    public function Equals(obj: object): boolean; override :=
    (obj is CLKernel(var wr)) and (self = wr);
    
    public function GetHashCode: integer; override :=
    Name.GetHashCode xor CodeContainer.GetHashCode;
    
    public function ToString: string; override :=
    $'{TypeName(self)}[{Name}] from {CodeContainer}';
    
  end;
  
  CLMemory = partial class(ICLMemory)
    
    public property Native: cl_mem read ntv;
    
    private prop: CLMemoryProperties;
    private function GetProperties: CLMemoryProperties;
    begin
      if prop=nil then prop := new CLMemoryProperties(ntv);
      Result := prop;
    end;
    public property Properties: CLMemoryProperties read GetProperties;
    
    public static function operator=(wr1, wr2: CLMemory): boolean :=
    ReferenceEquals(wr1,wr2) or not ReferenceEquals(wr1,nil) and not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    public static function operator<>(wr1, wr2: CLMemory): boolean := false=
    ReferenceEquals(wr1,wr2) or not ReferenceEquals(wr1,nil) and not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    
    public function Equals(obj: object): boolean; override :=
    (obj is CLMemory(var wr)) and (self = wr);
    
    public function GetHashCode: integer; override :=
    ntv.val.GetHashCode;
    
    public function ToString: string; override :=
    $'{TypeName(self)}[{ntv.val}] of size {Size}';
    
  end;
  
  CLMemorySubSegment = partial class(CLMemory)
    
    private prop: CLMemorySubSegmentProperties;
    private function GetProperties: CLMemorySubSegmentProperties;
    begin
      if prop=nil then prop := new CLMemorySubSegmentProperties(ntv);
      Result := prop;
    end;
    public property Properties: CLMemorySubSegmentProperties read GetProperties;
    
    public function ToString: string; override :=
    $'{inherited ToString} inside {Parent}';
    
  end;
  
  CLValue<T> = partial class(ICLMemory)
    
    public property Native: cl_mem read ntv;
    
    private prop: CLValueProperties;
    private function GetProperties: CLValueProperties;
    begin
      if prop=nil then prop := new CLValueProperties(ntv);
      Result := prop;
    end;
    public property Properties: CLValueProperties read GetProperties;
    
    public static function operator=(wr1, wr2: CLValue<T>): boolean :=
    ReferenceEquals(wr1,wr2) or not ReferenceEquals(wr1,nil) and not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    public static function operator<>(wr1, wr2: CLValue<T>): boolean := false=
    ReferenceEquals(wr1,wr2) or not ReferenceEquals(wr1,nil) and not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    
    public function Equals(obj: object): boolean; override :=
    (obj is CLValue<T>(var wr)) and (self = wr);
    
    public function GetHashCode: integer; override :=
    ntv.val.GetHashCode;
    
    public function ToString: string; override :=
    $'{TypeName(self)}[{ntv.val}]';
    
  end;
  
  CLArray<T> = partial class(ICLMemory)
    
    public property Native: cl_mem read ntv;
    
    private prop: CLArrayProperties;
    private function GetProperties: CLArrayProperties;
    begin
      if prop=nil then prop := new CLArrayProperties(ntv);
      Result := prop;
    end;
    public property Properties: CLArrayProperties read GetProperties;
    
    public static function operator=(wr1, wr2: CLArray<T>): boolean :=
    ReferenceEquals(wr1,wr2) or not ReferenceEquals(wr1,nil) and not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    public static function operator<>(wr1, wr2: CLArray<T>): boolean := false=
    ReferenceEquals(wr1,wr2) or not ReferenceEquals(wr1,nil) and not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    
    public function Equals(obj: object): boolean; override :=
    (obj is CLArray<T>(var wr)) and (self = wr);
    
    public function GetHashCode: integer; override :=
    ntv.val.GetHashCode;
    
    public function ToString: string; override :=
    $'{TypeName(self)}[{ntv.val}] of length {Length}';
    
  end;
  
  
  