


{$region CL}

{$region CLMemory}

type
  CLKernelArgConstantCLMemory = sealed class(CLKernelArgConstant)
    private data: CLKernelArgConstantCommon<CLMemory>;
    
    public constructor(cl_mem: CommandQueue<CLMemory>) :=
    data := new CLKernelArgConstantCommon<CLMemory>(cl_mem);
    
    private static function WrapToNative(o: CLMemory) := o.Native;
    
    protected function TryGetConstSetter: CLKernelArgSetter; override :=
    data.TryGetConstSetter(WrapToNative);
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueue>); override :=
    data.q.InitBeforeInvoke(g, inited_hubs);
    
    protected function Invoke(inv: CLTaskBranchInvoker; par_err_handlers: DoubleList<ErrHandler>): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke(inv, WrapToNative, par_err_handlers);
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgConstant.FromCLMemory(cl_mem: CommandQueue<CLMemory>): CLKernelArgConstant;
begin Result := new CLKernelArgConstantCLMemory(cl_mem) end;
static function CLKernelArgConstant.operator implicit(cl_mem: CLMemoryCCQ): CLKernelArgConstant;
begin Result := FromCLMemory(cl_mem) end;

{$endregion CLMemory}

{$region CLValue}

type
  CLKernelArgConstantCLValue<T> = sealed class(CLKernelArgConstant)
  where T: record;
    private data: CLKernelArgConstantCommon<CLValue<T>>;
    
    public constructor(cl_val: CommandQueue<CLValue<T>>) :=
    data := new CLKernelArgConstantCommon<CLValue<T>>(cl_val);
    
    private static function WrapToNative(o: CLValue<T>) := o.Native;
    
    protected function TryGetConstSetter: CLKernelArgSetter; override :=
    data.TryGetConstSetter(WrapToNative);
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueue>); override :=
    data.q.InitBeforeInvoke(g, inited_hubs);
    
    protected function Invoke(inv: CLTaskBranchInvoker; par_err_handlers: DoubleList<ErrHandler>): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke(inv, WrapToNative, par_err_handlers);
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgConstant.FromCLValue<T>(cl_val: CommandQueue<CLValue<T>>): CLKernelArgConstant; where T: record;
begin Result := new CLKernelArgConstantCLValue<T>(cl_val) end;
static function CLKernelArgConstant.operator implicit<T>(cl_val: CLValueCCQ<T>): CLKernelArgConstant; where T: record;
begin Result := FromCLValue(cl_val) end;

{$endregion CLValue}

{$region CLArray}

type
  CLKernelArgConstantCLArray<T> = sealed class(CLKernelArgConstant)
  where T: record;
    private data: CLKernelArgConstantCommon<CLArray<T>>;
    
    public constructor(cl_arr: CommandQueue<CLArray<T>>) :=
    data := new CLKernelArgConstantCommon<CLArray<T>>(cl_arr);
    
    private static function WrapToNative(o: CLArray<T>) := o.Native;
    
    protected function TryGetConstSetter: CLKernelArgSetter; override :=
    data.TryGetConstSetter(WrapToNative);
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueue>); override :=
    data.q.InitBeforeInvoke(g, inited_hubs);
    
    protected function Invoke(inv: CLTaskBranchInvoker; par_err_handlers: DoubleList<ErrHandler>): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke(inv, WrapToNative, par_err_handlers);
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgConstant.FromCLArray<T>(cl_arr: CommandQueue<CLArray<T>>): CLKernelArgConstant; where T: record;
begin Result := new CLKernelArgConstantCLArray<T>(cl_arr) end;
static function CLKernelArgConstant.operator implicit<T>(cl_arr: CLArrayCCQ<T>): CLKernelArgConstant; where T: record;
begin Result := FromCLArray(cl_arr) end;

{$endregion CLArray}

{$endregion CL}


