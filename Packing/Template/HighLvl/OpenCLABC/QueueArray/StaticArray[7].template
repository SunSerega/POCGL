  
  
  
  {$region Invokers}
  
  QueueArray7InvokerData<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7> = record
    public all_qrs_const := true;
    public next_l: CLTaskLocalData;
    public qr1: QueueRes<TInp1>;
    public qr2: QueueRes<TInp2>;
    public qr3: QueueRes<TInp3>;
    public qr4: QueueRes<TInp4>;
    public qr5: QueueRes<TInp5>;
    public qr6: QueueRes<TInp6>;
    public qr7: QueueRes<TInp7>;
  end;
  
  IQueueArray7Invoker = interface
    
    function InvokeToNil<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; g: CLTaskGlobalData; l: CLTaskLocalData): CLTaskLocalData;
    function InvokeToAny<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; g: CLTaskGlobalData; l: CLTaskLocalData): QueueArray7InvokerData<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>;
    
  end;
  
  QueueArray7SyncInvoker = record(IQueueArray7Invoker)
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function InvokeToNil<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; g: CLTaskGlobalData; l: CLTaskLocalData): CLTaskLocalData;
    begin
      l := q1.InvokeToNil(g, l).base;
      l := q2.InvokeToNil(g, l).base;
      l := q3.InvokeToNil(g, l).base;
      l := q4.InvokeToNil(g, l).base;
      l := q5.InvokeToNil(g, l).base;
      l := q6.InvokeToNil(g, l).base;
      l := q7.InvokeToNil(g, l).base;
      Result := l;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function InvokeToAny<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; g: CLTaskGlobalData; l: CLTaskLocalData): QueueArray7InvokerData<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>;
    begin
      
      Result.qr1 := q1.InvokeToAny(g, l);
      if not Result.qr1.IsConst then Result.all_qrs_const := false;
      l := Result.qr1.TakeBaseOut;
      
      Result.qr2 := q2.InvokeToAny(g, l);
      if not Result.qr2.IsConst then Result.all_qrs_const := false;
      l := Result.qr2.TakeBaseOut;
      
      Result.qr3 := q3.InvokeToAny(g, l);
      if not Result.qr3.IsConst then Result.all_qrs_const := false;
      l := Result.qr3.TakeBaseOut;
      
      Result.qr4 := q4.InvokeToAny(g, l);
      if not Result.qr4.IsConst then Result.all_qrs_const := false;
      l := Result.qr4.TakeBaseOut;
      
      Result.qr5 := q5.InvokeToAny(g, l);
      if not Result.qr5.IsConst then Result.all_qrs_const := false;
      l := Result.qr5.TakeBaseOut;
      
      Result.qr6 := q6.InvokeToAny(g, l);
      if not Result.qr6.IsConst then Result.all_qrs_const := false;
      l := Result.qr6.TakeBaseOut;
      
      Result.qr7 := q7.InvokeToAny(g, l);
      if not Result.qr7.IsConst then Result.all_qrs_const := false;
      l := Result.qr7.TakeBaseOut;
      
      Result.next_l := l;
    end;
    
  end;
  
  QueueArray7AsyncInvoker = record(IQueueArray7Invoker)
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function InvokeToNil<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; g: CLTaskGlobalData; l: CLTaskLocalData): CLTaskLocalData;
    begin
      var res_ev: EventList;
      g.ParallelInvoke(l, 7, invoker->(res_ev := EventList.Combine(|
        invoker.InvokeBranch(q1.InvokeToNil).AttachInvokeActions(invoker.g),
        invoker.InvokeBranch(q2.InvokeToNil).AttachInvokeActions(invoker.g),
        invoker.InvokeBranch(q3.InvokeToNil).AttachInvokeActions(invoker.g),
        invoker.InvokeBranch(q4.InvokeToNil).AttachInvokeActions(invoker.g),
        invoker.InvokeBranch(q5.InvokeToNil).AttachInvokeActions(invoker.g),
        invoker.InvokeBranch(q6.InvokeToNil).AttachInvokeActions(invoker.g),
        invoker.InvokeBranch(q7.InvokeToNil).AttachInvokeActions(invoker.g)
      |)));
      Result := new CLTaskLocalData(res_ev);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function InvokeToAny<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; g: CLTaskGlobalData; l: CLTaskLocalData): QueueArray7InvokerData<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>;
    begin
      
      var res: QueueArray7InvokerData<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>;
      g.ParallelInvoke(l, 7, invoker->
      begin
        res.qr1 := invoker.InvokeBranch(q1.InvokeToAny);
        res.qr2 := invoker.InvokeBranch(q2.InvokeToAny);
        res.qr3 := invoker.InvokeBranch(q3.InvokeToAny);
        res.qr4 := invoker.InvokeBranch(q4.InvokeToAny);
        res.qr5 := invoker.InvokeBranch(q5.InvokeToAny);
        res.qr6 := invoker.InvokeBranch(q6.InvokeToAny);
        res.qr7 := invoker.InvokeBranch(q7.InvokeToAny);
      end);
      Result := res;
      
      Result.all_qrs_const := Result.qr1.IsConst and Result.qr2.IsConst and Result.qr3.IsConst and Result.qr4.IsConst and Result.qr5.IsConst and Result.qr6.IsConst and Result.qr7.IsConst;
      Result.next_l := new CLTaskLocalData(EventList.Combine(|
        Result.qr1.AttachInvokeActions(g),
        Result.qr2.AttachInvokeActions(g),
        Result.qr3.AttachInvokeActions(g),
        Result.qr4.AttachInvokeActions(g),
        Result.qr5.AttachInvokeActions(g),
        Result.qr6.AttachInvokeActions(g),
        Result.qr7.AttachInvokeActions(g)
      |));
    end;
    
  end;
  
  {$endregion Invokers}
  
  {$region Work}
  
  IQueueArray7Work<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes, TDelegate> = interface
  where TDelegate: ISimpleDelegateContainer;
    
    function PreInvoke(d: TDelegate; inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; inp6: TInp6; inp7: TInp7): TRes;
    
    function Invoke(d: TDelegate; err_handler: ErrHandler{$ifdef DEBUG}; err_test_reason: string{$endif}; inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; inp6: TInp6; inp7: TInp7; c: CLContext): TRes;
    
  end;
  
  {$region Func}
  
  ISimpleFunc7Container<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes> = interface(ISimpleDelegateContainer)
    
    function Invoke(inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; inp6: TInp6; inp7: TInp7; c: CLContext): TRes;
    
  end;
  
  SimpleFunc7Container<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes> = record(ISimpleFunc7Container<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes>)
    private d: (TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7)->TRes;
    
    public static function operator implicit(d: (TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7)->TRes): SimpleFunc7Container<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes>;
    begin
      Result.d := d;
    end;
    
    public function Invoke(inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; inp6: TInp6; inp7: TInp7; c: CLContext) := d(inp1,inp2,inp3,inp4,inp5,inp6,inp7);
    
    public procedure ToStringB(sb: StringBuilder) :=
      CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  SimpleFunc7ContainerC<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes> = record(ISimpleFunc7Container<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes>)
    private d: (TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, CLContext)->TRes;
    
    public static function operator implicit(d: (TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, CLContext)->TRes): SimpleFunc7ContainerC<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes>;
    begin
      Result.d := d;
    end;
    
    public function Invoke(inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; inp6: TInp6; inp7: TInp7; c: CLContext) := d(inp1,inp2,inp3,inp4,inp5,inp6,inp7,c);
    
    public procedure ToStringB(sb: StringBuilder) :=
      CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  
  QueueArray7WorkConvert<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes, TFunc> = record(IQueueArray7Work<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes, TFunc>)
  where TFunc: ISimpleFunc7Container<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes>;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function PreInvoke(f: TFunc; inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; inp6: TInp6; inp7: TInp7) :=
    f.Invoke(inp1,inp2,inp3,inp4,inp5,inp6,inp7, nil);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke(f: TFunc; err_handler: ErrHandler{$ifdef DEBUG}; err_test_reason: string{$endif}; inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; inp6: TInp6; inp7: TInp7; c: CLContext): TRes;
    begin
      if not err_handler.HadError then
      try
        Result := f.Invoke(inp1,inp2,inp3,inp4,inp5,inp6,inp7, c);
      except
        on e: Exception do err_handler.AddErr(e{$ifdef DEBUG}, err_test_reason{$endif})
      end;
      {$ifdef DEBUG}
      err_handler.EndMaybeError(err_test_reason);
      {$endif DEBUG}
    end;
    
  end;
  
  {$endregion Func}
  
  {$region Proc}
  
  ISimpleProc7Container<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7> = interface(ISimpleDelegateContainer)
    
    procedure Invoke(inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; inp6: TInp6; inp7: TInp7; c: CLContext);
    
  end;
  
  SimpleProc7Container<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7> = record(ISimpleProc7Container<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>)
    private d: (TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7)->();
    
    public static function operator implicit(d: (TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7)->()): SimpleProc7Container<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>;
    begin
      Result.d := d;
    end;
    
    public procedure Invoke(inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; inp6: TInp6; inp7: TInp7; c: CLContext) := d(inp1,inp2,inp3,inp4,inp5,inp6,inp7);
    
    public procedure ToStringB(sb: StringBuilder) :=
      CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  SimpleProc7ContainerC<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7> = record(ISimpleProc7Container<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>)
    private d: (TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, CLContext)->();
    
    public static function operator implicit(d: (TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, CLContext)->()): SimpleProc7ContainerC<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>;
    begin
      Result.d := d;
    end;
    
    public procedure Invoke(inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; inp6: TInp6; inp7: TInp7; c: CLContext) := d(inp1,inp2,inp3,inp4,inp5,inp6,inp7,c);
    
    public procedure ToStringB(sb: StringBuilder) :=
      CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  
  QueueArray7WorkUse<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TProc> = record(IQueueArray7Work<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>, TProc>)
  where TProc: ISimpleProc7Container<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function PreInvoke(p: TProc; inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; inp6: TInp6; inp7: TInp7): ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>;
    begin
      p.Invoke(inp1,inp2,inp3,inp4,inp5,inp6,inp7, nil);
      Result := ValueTuple.Create(inp1,inp2,inp3,inp4,inp5,inp6,inp7);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke(p: TProc; err_handler: ErrHandler{$ifdef DEBUG}; err_test_reason: string{$endif}; inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; inp6: TInp6; inp7: TInp7; c: CLContext): ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>;
    begin
      if not err_handler.HadError then
      try
        p.Invoke(inp1,inp2,inp3,inp4,inp5,inp6,inp7, c);
        Result := ValueTuple.Create(inp1,inp2,inp3,inp4,inp5,inp6,inp7);
      except
        on e: Exception do err_handler.AddErr(e{$ifdef DEBUG}, err_test_reason{$endif})
      end;
      {$ifdef DEBUG}
      err_handler.EndMaybeError(err_test_reason);
      {$endif DEBUG}
    end;
    
  end;
  
  {$endregion Proc}
  
  {$endregion Work}
  
  {$region Common}
  
  CommandQueueArray7WithWork<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes, TInv,TDelegate,TWork> = abstract class(CommandQueue<TRes>)
  where TInv: IQueueArray7Invoker, constructor;
  where TDelegate: ISimpleDelegateContainer;
  where TWork: IQueueArray7Work<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes, TDelegate>, constructor;
    protected q1: CommandQueue<TInp1>;
    protected q2: CommandQueue<TInp2>;
    protected q3: CommandQueue<TInp3>;
    protected q4: CommandQueue<TInp4>;
    protected q5: CommandQueue<TInp5>;
    protected q6: CommandQueue<TInp6>;
    protected q7: CommandQueue<TInp7>;
    protected d: TDelegate;
    protected can_pre_call: boolean;
    
    public constructor(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; d: TDelegate; can_pre_call: boolean);
    begin
      self.q1 := q1;
      self.q2 := q2;
      self.q3 := q3;
      self.q4 := q4;
      self.q5 := q5;
      self.q6 := q6;
      self.q7 := q7;
      self.d := d;
      self.can_pre_call := can_pre_call;
      if can_pre_call and (q1.const_res_dep<>nil) and (q2.const_res_dep<>nil) and (q3.const_res_dep<>nil) and (q4.const_res_dep<>nil) and (q5.const_res_dep<>nil) and (q6.const_res_dep<>nil) and (q7.const_res_dep<>nil) then
      begin
        self.expected_const_res := TWork.Create.PreInvoke(d,
          q1.expected_const_res,
          q2.expected_const_res,
          q3.expected_const_res,
          q4.expected_const_res,
          q5.expected_const_res,
          q6.expected_const_res,
          q7.expected_const_res
        );
        
        var c := q1.const_res_dep.Length + q2.const_res_dep.Length + q3.const_res_dep.Length + q4.const_res_dep.Length + q5.const_res_dep.Length + q6.const_res_dep.Length + q7.const_res_dep.Length;
        {$ifdef DEBUG}
        if c=0 then raise new OpenCLABCInternalException($'0dep version is CQ/HFQ/HPQ');
        {$endif DEBUG}
        
        self.const_res_dep := new CommandQueueBase[c];
        var dep: array of CommandQueueBase;
        dep := q7.const_res_dep; c -= dep.Length; dep.CopyTo(self.const_res_dep, c);
        dep := q6.const_res_dep; c -= dep.Length; dep.CopyTo(self.const_res_dep, c);
        dep := q5.const_res_dep; c -= dep.Length; dep.CopyTo(self.const_res_dep, c);
        dep := q4.const_res_dep; c -= dep.Length; dep.CopyTo(self.const_res_dep, c);
        dep := q3.const_res_dep; c -= dep.Length; dep.CopyTo(self.const_res_dep, c);
        dep := q2.const_res_dep; c -= dep.Length; dep.CopyTo(self.const_res_dep, c);
        dep := q1.const_res_dep; c -= dep.Length; dep.CopyTo(self.const_res_dep, c);
      end;
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueue>); override :=
    begin
      q1.InitBeforeInvoke(g, inited_hubs);
      q2.InitBeforeInvoke(g, inited_hubs);
      q3.InitBeforeInvoke(g, inited_hubs);
      q4.InitBeforeInvoke(g, inited_hubs);
      q5.InitBeforeInvoke(g, inited_hubs);
      q6.InitBeforeInvoke(g, inited_hubs);
      q7.InitBeforeInvoke(g, inited_hubs);
    end;
    
    protected function TrySkipInvoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; qr_factory: IQueueResFactory<TRes,TR>; var res: TR): boolean; where TR: IQueueRes;
    begin
      Result := qr_factory.TrySkipInvoke(
        g, l,
        self,(g,l)->new QueueResNil(TInv.Create.InvokeToNil(q1,q2,q3,q4,q5,q6,q7, g,l)),
        res
      );
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      q1.ToString(sb, tabs, index, delayed);
      q2.ToString(sb, tabs, index, delayed);
      q3.ToString(sb, tabs, index, delayed);
      q4.ToString(sb, tabs, index, delayed);
      q5.ToString(sb, tabs, index, delayed);
      q6.ToString(sb, tabs, index, delayed);
      q7.ToString(sb, tabs, index, delayed);
      sb.Append(#9, tabs);
      d.ToStringB(sb);
      sb += #10;
    end;
    
  end;
  
  {$endregion Common}
  
  {$region Quick}
  
  CommandQueueQuickArray7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes, TInv, TDelegate, TWork> = sealed class(CommandQueueArray7WithWork<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes, TInv, TDelegate, TWork>)
  where TInv: IQueueArray7Invoker, constructor;
  where TDelegate: ISimpleDelegateContainer;
  where TWork: IQueueArray7Work<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes, TDelegate>, constructor;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; qr_factory: IQueueResFactory<TRes,TR>): TR; where TR: IQueueRes;
    begin
      if TrySkipInvoke(g,l, qr_factory, Result) then exit;
      var inv_data := TInv.Create.InvokeToAny(q1,q2,q3,q4,q5,q6,q7, g, l);
      l := inv_data.next_l;
      
      var qr1 := inv_data.qr1;
      var qr2 := inv_data.qr2;
      var qr3 := inv_data.qr3;
      var qr4 := inv_data.qr4;
      var qr5 := inv_data.qr5;
      var qr6 := inv_data.qr6;
      var qr7 := inv_data.qr7;
      var err_handler := g.curr_err_handler.Extract({$ifdef DEBUG}false{$endif});
      
      {$ifdef DEBUG}
      var err_test_reason := $'[{self.GetHashCode}]:{TypeName(self)}.d.Invoke';
      err_handler.AddMaybeError(err_test_reason);
      {$endif DEBUG}
      
      var should_make_const := if can_pre_call then
        inv_data.all_qrs_const else
        l.ShouldInstaCallAction;
      
      if should_make_const then
        Result := qr_factory.MakeConst(l, TWork.Create.Invoke(d,
          err_handler{$ifdef DEBUG}, err_test_reason{$endif},
          qr1.GetResDirect, qr2.GetResDirect, qr3.GetResDirect, qr4.GetResDirect, qr5.GetResDirect, qr6.GetResDirect, qr7.GetResDirect, g.c
        )) else
        Result := qr_factory.MakeDelayed(l, qr->c->qr.SetRes(TWork.Create.Invoke(d,
          err_handler{$ifdef DEBUG}, err_test_reason{$endif},
          qr1.GetResDirect, qr2.GetResDirect, qr3.GetResDirect, qr4.GetResDirect, qr5.GetResDirect, qr6.GetResDirect, qr7.GetResDirect, c
        )));
      
    end;
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil;       override := Invoke(g, l, qr_nil_factory);
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes   <TRes>; override := Invoke(g, l, qr_val_factory);
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<TRes>; override := Invoke(g, l, qr_ptr_factory);
    
  end;
  
  CommandQueueConvertQuickArray7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes, TInv, TFunc> = CommandQueueQuickArray7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes, TInv, TFunc, QueueArray7WorkConvert<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes, TFunc>>;
  CommandQueueUseQuickArray7    <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,      TInv, TProc> = CommandQueueQuickArray7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>, TInv, TProc, QueueArray7WorkUse<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TProc>>;
  
  {$endregion Quick}
  
  {$region Threaded}
  
  DCommandQueueThreadedArray7MakeBody<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TR> = function(acts: QueueResComplDelegateData; qr1: QueueRes<TInp1>; qr2: QueueRes<TInp2>; qr3: QueueRes<TInp3>; qr4: QueueRes<TInp4>; qr5: QueueRes<TInp5>; qr6: QueueRes<TInp6>; qr7: QueueRes<TInp7>; err_handler: ErrHandler; c: CLContext; own_qr: TR{$ifdef DEBUG}; err_test_reason: string{$endif}): Action;
  CommandQueueThreadedArray7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes, TInv, TDelegate, TWork> = sealed class(CommandQueueArray7WithWork<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes, TInv, TDelegate, TWork>)
  where TInv: IQueueArray7Invoker, constructor;
  where TDelegate: ISimpleDelegateContainer;
  where TWork: IQueueArray7Work<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes, TDelegate>, constructor;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function MakeNilBody    (acts: QueueResComplDelegateData; qr1: QueueRes<TInp1>; qr2: QueueRes<TInp2>; qr3: QueueRes<TInp3>; qr4: QueueRes<TInp4>; qr5: QueueRes<TInp5>; qr6: QueueRes<TInp6>; qr7: QueueRes<TInp7>; err_handler: ErrHandler; c: CLContext; own_qr: QueueResNil{$ifdef DEBUG}; err_test_reason: string{$endif}): Action;
    begin
      Result := ()->
      begin
        acts.Invoke(c);
        TWork.Create.Invoke(d, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, qr1.GetResDirect, qr2.GetResDirect, qr3.GetResDirect, qr4.GetResDirect, qr5.GetResDirect, qr6.GetResDirect, qr7.GetResDirect, c);
      end;
    end;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function MakeResBody<TR>(acts: QueueResComplDelegateData; qr1: QueueRes<TInp1>; qr2: QueueRes<TInp2>; qr3: QueueRes<TInp3>; qr4: QueueRes<TInp4>; qr5: QueueRes<TInp5>; qr6: QueueRes<TInp6>; qr7: QueueRes<TInp7>; err_handler: ErrHandler; c: CLContext; own_qr: TR{$ifdef DEBUG}; err_test_reason: string{$endif}): Action; where TR: QueueRes<TRes>;
    begin
      Result := ()->
      begin
        acts.Invoke(c);
        own_qr.SetRes(TWork.Create.Invoke(d, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, qr1.GetResDirect, qr2.GetResDirect, qr3.GetResDirect, qr4.GetResDirect, qr5.GetResDirect, qr6.GetResDirect, qr7.GetResDirect, c));
      end;
    end;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; qr_factory: IQueueResFactory<TRes,TR>; make_body: DCommandQueueThreadedArray7MakeBody<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TR>): TR; where TR: IQueueRes;
    begin
      if TrySkipInvoke(g,l, qr_factory, Result) then exit;
      var inv_data := TInv.Create.InvokeToAny(q1,q2,q3,q4,q5,q6,q7, g, l);
      l := inv_data.next_l;
      
      var qr1 := inv_data.qr1;
      var qr2 := inv_data.qr2;
      var qr3 := inv_data.qr3;
      var qr4 := inv_data.qr4;
      var qr5 := inv_data.qr5;
      var qr6 := inv_data.qr6;
      var qr7 := inv_data.qr7;
      var err_handler := g.curr_err_handler.Extract({$ifdef DEBUG}false{$endif});
      
      {$ifdef DEBUG}
      var err_test_reason := $'[{self.GetHashCode}]:{TypeName(self)}.d.Invoke';
      err_handler.AddMaybeError(err_test_reason);
      {$endif DEBUG}
      
      var should_make_const := if can_pre_call then
        inv_data.all_qrs_const else
        false;
      
      if should_make_const then
        Result := qr_factory.MakeConst(l, TWork.Create.Invoke(d,
          err_handler{$ifdef DEBUG}, err_test_reason{$endif},
          qr1.GetResDirect, qr2.GetResDirect, qr3.GetResDirect, qr4.GetResDirect, qr5.GetResDirect, qr6.GetResDirect, qr7.GetResDirect, g.c
        )) else
      begin
        var prev_ev := l.prev_ev;
        var acts := l.prev_delegate;
        Result := qr_factory.MakeDelayed(qr->new CLTaskLocalData(UserEvent.StartWorkThread(
          prev_ev, make_body(acts, qr1,qr2,qr3,qr4,qr5,qr6,qr7, err_handler, g.c, qr{$ifdef DEBUG}, err_test_reason{$endif}), g
          {$ifdef EventDebug}, $'body of {TypeName(self)}'{$endif}
        )));
      end;
      
    end;
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil;       override := Invoke(g, l, qr_nil_factory, MakeNilBody);
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes   <TRes>; override := Invoke(g, l, qr_val_factory, MakeResBody&<QueueResVal<TRes>>);
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<TRes>; override := Invoke(g, l, qr_ptr_factory, MakeResBody&<QueueResPtr<TRes>>);
    
  end;
  
  CommandQueueConvertThreadedArray7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes, TInv, TFunc> = CommandQueueThreadedArray7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes, TInv, TFunc, QueueArray7WorkConvert<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes, TFunc>>;
  CommandQueueUseThreadedArray7    <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,      TInv, TProc> = CommandQueueThreadedArray7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>, TInv, TProc, QueueArray7WorkUse<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TProc>>;
  
  {$endregion Threaded}
  
  
  