


constructor CLValueCCQ<T>.Create(q: CommandQueue<CLValue<T>>) := inherited;
constructor CLValueCCQ<T>.Create := inherited;

/// %CommandQueue<CLValue<T>>.MakeCCQ%
function MakeCCQ<T>(self: CommandQueue<CLValue<T>>): CLValueCCQ<T>; extensionmethod; where T: record;
begin
  Result := new CLValueCCQ<T>(self);
end;

{$region Special .Add's}

function CLValueCCQ<T>.ThenQueue(q: CommandQueueBase): CLValueCCQ<T>;
begin
  var comm := QueueCommandConstructor&<CLValue<T>>.Make(q);
  Result := if comm=nil then self else AddCommand(self, comm);
end;

function CLValueCCQ<T>.ThenProc(p: CLValue<T>->(); need_own_thread, can_pre_calc: boolean) := AddCommand(self, ProcCommandConstructor&<CLValue<T>>.Make&<SimpleProcContainer<CLValue<T>>>(p, need_own_thread, can_pre_calc));
function CLValueCCQ<T>.ThenProc(p: (CLValue<T>, CLContext)->(); need_own_thread, can_pre_calc: boolean) := AddCommand(self, ProcCommandConstructor&<CLValue<T>>.Make&<SimpleProcContainerC<CLValue<T>>>(p, need_own_thread, can_pre_calc));

function CLValueCCQ<T>.ThenWait(marker: WaitMarker) := AddCommand(self, WaitCommandConstructor&<CLValue<T>>.Make(marker));

{$endregion Special .Add's}


