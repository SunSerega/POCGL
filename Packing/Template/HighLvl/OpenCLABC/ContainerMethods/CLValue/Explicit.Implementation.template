


{$region 1#Write&Read}

{$region WriteValue}

type
  CLValueCommandWriteValue<T> = sealed class(EnqueueableGPUCommand<CLValue<T>>)
  where T: record;
    private val := new NativeValueArea<&T>(true);
    
    protected procedure Finalize; override;
    begin
      val.Release;
    end;
    
    protected function ExpectedEnqCount: integer; override := 0;
    
    public constructor(val: &T);
    begin
      self.val.Value := val;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleEventListList): ParamInvRes<CLValue<T>>; override;
    begin
      Result.Item1 := new CLTaskErrHandlerEmpty;
      
      Result.Item2 := (o, cq, evs)->
      begin
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(Marshal.SizeOf(default(T))),
          val.Pointer,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      sb.Append(val.Value);
      
    end;
    
  end;
  
function CLValueCCQ<T>.ThenWriteValue(val: &T): CLValueCCQ<T>;
begin
  Result := AddCommand(self, new CLValueCommandWriteValue<T>(val));
end;

{$endregion WriteValue}

{$region WriteValue!Q}

type
  CLValueCommandWriteValueQ<T> = sealed class(EnqueueableGPUCommand<CLValue<T>>)
  where T: record;
    private val: CommandQueue<&T>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(val: CommandQueue<&T>);
    begin
      self.val := val;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      val.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleEventListList): ParamInvRes<CLValue<T>>; override;
    begin
      Result.Item1 := new CLTaskErrHandlerEmpty;
      var val_qr: QueueResPtr<&T>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        val_qr := invoker.InvokeBranch(val.InvokeToPtr).AddToEvLst(g, enq_evs, False);
      end);
      
      Result.Item2 := (o, cq, evs)->
      begin
        var val := val_qr.GetResPtrForRead;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(Marshal.SizeOf(default(T))),
          val,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          GC.KeepAlive(val_qr);
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      val.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLValueCCQ<T>.ThenWriteValue(val: CommandQueue<&T>): CLValueCCQ<T>;
begin
  Result := AddCommand(self, new CLValueCommandWriteValueQ<T>(val));
end;

{$endregion WriteValue!Q}

{$region WriteNativeValueArea}

type
  CLValueCommandWriteNativeValueArea<T> = sealed class(EnqueueableGPUCommand<CLValue<T>>)
  where T: record;
    private native_data: CommandQueue<NativeValueArea<&T>>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(native_data: CommandQueue<NativeValueArea<&T>>);
    begin
      self.native_data := native_data;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleEventListList): ParamInvRes<CLValue<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeValueArea<&T>>;
      
      var l1_err_handler: CLTaskErrHandler;
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny).AddToEvLst(g, enq_evs, True);
        l1_err_handler := invoker.GroupHandlers;
      end);
      Result.Item1 := l1_err_handler;
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          UIntPtr.Zero, native_data.ByteSize,
          native_data.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLValueCCQ<T>.ThenWriteNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>): CLValueCCQ<T>;
begin
  Result := AddCommand(self, new CLValueCommandWriteNativeValueArea<T>(native_data));
end;

{$endregion WriteNativeValueArea}

{$region WriteNativeValue}

type
  CLValueCommandWriteNativeValue<T> = sealed class(EnqueueableGPUCommand<CLValue<T>>)
  where T: record;
    private native_data: CommandQueue<NativeValue<&T>>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(native_data: CommandQueue<NativeValue<&T>>);
    begin
      self.native_data := native_data;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleEventListList): ParamInvRes<CLValue<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeValue<&T>>;
      
      var l1_err_handler: CLTaskErrHandler;
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny).AddToEvLst(g, enq_evs, True);
        l1_err_handler := invoker.GroupHandlers;
      end);
      Result.Item1 := l1_err_handler;
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          UIntPtr.Zero, native_data.Area.ByteSize,
          native_data.Area.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLValueCCQ<T>.ThenWriteNativeValue(native_data: CommandQueue<NativeValue<&T>>): CLValueCCQ<T>;
begin
  Result := AddCommand(self, new CLValueCommandWriteNativeValue<T>(native_data));
end;

{$endregion WriteNativeValue}

{$region ReadNativeValueArea}

type
  CLValueCommandReadNativeValueArea<T> = sealed class(EnqueueableGPUCommand<CLValue<T>>)
  where T: record;
    private native_data: CommandQueue<NativeValueArea<&T>>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(native_data: CommandQueue<NativeValueArea<&T>>);
    begin
      self.native_data := native_data;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleEventListList): ParamInvRes<CLValue<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeValueArea<&T>>;
      
      var l1_err_handler: CLTaskErrHandler;
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny).AddToEvLst(g, enq_evs, True);
        l1_err_handler := invoker.GroupHandlers;
      end);
      Result.Item1 := l1_err_handler;
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          UIntPtr.Zero, native_data.ByteSize,
          native_data.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLValueCCQ<T>.ThenReadNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>): CLValueCCQ<T>;
begin
  Result := AddCommand(self, new CLValueCommandReadNativeValueArea<T>(native_data));
end;

{$endregion ReadNativeValueArea}

{$region ReadNativeValue}

type
  CLValueCommandReadNativeValue<T> = sealed class(EnqueueableGPUCommand<CLValue<T>>)
  where T: record;
    private native_data: CommandQueue<NativeValue<&T>>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(native_data: CommandQueue<NativeValue<&T>>);
    begin
      self.native_data := native_data;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleEventListList): ParamInvRes<CLValue<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeValue<&T>>;
      
      var l1_err_handler: CLTaskErrHandler;
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny).AddToEvLst(g, enq_evs, True);
        l1_err_handler := invoker.GroupHandlers;
      end);
      Result.Item1 := l1_err_handler;
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          UIntPtr.Zero, native_data.Area.ByteSize,
          native_data.Area.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLValueCCQ<T>.ThenReadNativeValue(native_data: CommandQueue<NativeValue<&T>>): CLValueCCQ<T>;
begin
  Result := AddCommand(self, new CLValueCommandReadNativeValue<T>(native_data));
end;

{$endregion ReadNativeValue}

{$endregion 1#Write&Read}

{$region 3#Copy}

{$region CopyTo!CLMemory}

function CLValueCCQ<T>.ThenCopyTo(mem: CommandQueue<CLMemory>): CLValueCCQ<T>;
begin
  Result := ThenCopyTo(mem, 0);
end;

{$endregion CopyTo!CLMemory}

{$region CopyFrom!CLMemory}

function CLValueCCQ<T>.ThenCopyFrom(mem: CommandQueue<CLMemory>): CLValueCCQ<T>;
begin
  Result := ThenCopyFrom(mem, 0);
end;

{$endregion CopyFrom!CLMemory}

{$region CopyTo}

type
  CLValueCommandCopyTo<T> = sealed class(EnqueueableGPUCommand<CLValue<T>>)
  where T: record;
    private        mem: CommandQueue<CLMemory>;
    private mem_offset: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    public constructor(mem: CommandQueue<CLMemory>; mem_offset: CommandQueue<integer>);
    begin
      self.       mem :=        mem;
      self.mem_offset := mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
             mem.InitBeforeInvoke(g, prev_hubs);
      mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleEventListList): ParamInvRes<CLValue<T>>; override;
    begin
      var        mem_qr: QueueRes<CLMemory>;
      var mem_offset_qr: QueueRes<integer>;
      
      var l1_err_handler: CLTaskErrHandler;
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
               mem_qr := invoker.InvokeBranch(       mem.InvokeToAny).AddToEvLst(g, enq_evs, True);
        mem_offset_qr := invoker.InvokeBranch(mem_offset.InvokeToAny).AddToEvLst(g, enq_evs, True);
        l1_err_handler := invoker.GroupHandlers;
      end);
      Result.Item1 := l1_err_handler;
      
      Result.Item2 := (o, cq, evs)->
      begin
        var        mem :=        mem_qr.GetResDirect;
        var mem_offset := mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueCopyBuffer(
          cq, o.Native,mem.Native,
          UIntPtr.Zero,new UIntPtr(mem_offset),
          new UIntPtr(Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'mem:';
      sb += ' ';
      mem.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLValueCCQ<T>.ThenCopyTo(mem: CommandQueue<CLMemory>; mem_offset: CommandQueue<integer>): CLValueCCQ<T>;
begin
  Result := AddCommand(self, new CLValueCommandCopyTo<T>(mem, mem_offset));
end;

{$endregion CopyTo}

{$region CopyFrom}

type
  CLValueCommandCopyFrom<T> = sealed class(EnqueueableGPUCommand<CLValue<T>>)
  where T: record;
    private        mem: CommandQueue<CLMemory>;
    private mem_offset: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    public constructor(mem: CommandQueue<CLMemory>; mem_offset: CommandQueue<integer>);
    begin
      self.       mem :=        mem;
      self.mem_offset := mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
             mem.InitBeforeInvoke(g, prev_hubs);
      mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleEventListList): ParamInvRes<CLValue<T>>; override;
    begin
      var        mem_qr: QueueRes<CLMemory>;
      var mem_offset_qr: QueueRes<integer>;
      
      var l1_err_handler: CLTaskErrHandler;
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
               mem_qr := invoker.InvokeBranch(       mem.InvokeToAny).AddToEvLst(g, enq_evs, True);
        mem_offset_qr := invoker.InvokeBranch(mem_offset.InvokeToAny).AddToEvLst(g, enq_evs, True);
        l1_err_handler := invoker.GroupHandlers;
      end);
      Result.Item1 := l1_err_handler;
      
      Result.Item2 := (o, cq, evs)->
      begin
        var        mem :=        mem_qr.GetResDirect;
        var mem_offset := mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueCopyBuffer(
          cq, mem.Native,o.Native,
          new UIntPtr(mem_offset),UIntPtr.Zero,
          new UIntPtr(Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'mem:';
      sb += ' ';
      mem.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLValueCCQ<T>.ThenCopyFrom(mem: CommandQueue<CLMemory>; mem_offset: CommandQueue<integer>): CLValueCCQ<T>;
begin
  Result := AddCommand(self, new CLValueCommandCopyFrom<T>(mem, mem_offset));
end;

{$endregion CopyFrom}

{$region CopyTo!CLValue}

type
  CLValueCommandCopyToCLValue<T> = sealed class(EnqueueableGPUCommand<CLValue<T>>)
  where T: record;
    private val: CommandQueue<CLValue<&T>>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(val: CommandQueue<CLValue<&T>>);
    begin
      self.val := val;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      val.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleEventListList): ParamInvRes<CLValue<T>>; override;
    begin
      var val_qr: QueueRes<CLValue<&T>>;
      
      var l1_err_handler: CLTaskErrHandler;
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        val_qr := invoker.InvokeBranch(val.InvokeToAny).AddToEvLst(g, enq_evs, True);
        l1_err_handler := invoker.GroupHandlers;
      end);
      Result.Item1 := l1_err_handler;
      
      Result.Item2 := (o, cq, evs)->
      begin
        var val := val_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueCopyBuffer(
          cq, o.Native,val.Native,
          UIntPtr.Zero, UIntPtr.Zero,
          new UIntPtr(Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      val.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLValueCCQ<T>.ThenCopyTo(val: CommandQueue<CLValue<&T>>): CLValueCCQ<T>;
begin
  Result := AddCommand(self, new CLValueCommandCopyToCLValue<T>(val));
end;

{$endregion CopyTo!CLValue}

{$region CopyFrom!CLValue}

type
  CLValueCommandCopyFromCLValue<T> = sealed class(EnqueueableGPUCommand<CLValue<T>>)
  where T: record;
    private val: CommandQueue<CLValue<&T>>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(val: CommandQueue<CLValue<&T>>);
    begin
      self.val := val;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      val.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleEventListList): ParamInvRes<CLValue<T>>; override;
    begin
      var val_qr: QueueRes<CLValue<&T>>;
      
      var l1_err_handler: CLTaskErrHandler;
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        val_qr := invoker.InvokeBranch(val.InvokeToAny).AddToEvLst(g, enq_evs, True);
        l1_err_handler := invoker.GroupHandlers;
      end);
      Result.Item1 := l1_err_handler;
      
      Result.Item2 := (o, cq, evs)->
      begin
        var val := val_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueCopyBuffer(
          cq, val.Native,o.Native,
          UIntPtr.Zero, UIntPtr.Zero,
          new UIntPtr(Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      val.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLValueCCQ<T>.ThenCopyFrom(val: CommandQueue<CLValue<&T>>): CLValueCCQ<T>;
begin
  Result := AddCommand(self, new CLValueCommandCopyFromCLValue<T>(val));
end;

{$endregion CopyFrom!CLValue}

{$endregion 3#Copy}


