


{$region Get}

{$region GetValue}

type
  CLValueCommandGetValue<T> = sealed class(EnqueueableGetPtrCommand<CLValue<T>, &T>)
  where T: record;
    
    protected function ExpectedEnqCount: integer; override := 0;
    
    public constructor(ccq: CLValueCCQ<T>);
    begin
      inherited Create(ccq);
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override := prev_commands.InitBeforeInvoke(g, prev_hubs);
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleEventListList; own_qr: QueueRes<&T>): ParamInvRes<CLValue<T>>; override;
    begin
      Result.Item1 := new CLTaskErrHandlerEmpty;
      
      Result.Item2 := (o, cq, evs)->
      begin
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(Marshal.SizeOf(default(T))),
          (own_qr as QueueResPtr<&T>).GetResPtrForWrite,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          GC.KeepAlive(own_qr);
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override := sb += #10;
    
  end;
  
function CLValueCCQ<T>.ThenGetValue: CommandQueue<&T>;
begin
  Result := new CLValueCommandGetValue<T>(self) as CommandQueue<&T>;
end;

{$endregion GetValue}

{$endregion Get}


