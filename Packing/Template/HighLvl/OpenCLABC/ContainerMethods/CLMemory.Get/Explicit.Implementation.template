


{$region Get}

{$region GetValue}

function CLMemoryCCQ.ThenGetValue<TRecord>: CommandQueue<TRecord>; where TRecord: record;
begin
  Result := ThenGetValue&<TRecord>(0);
end;

{$endregion GetValue}

{$region GetValue}

type
  CLMemoryCommandGetValue<TRecord> = sealed class(EnqueueableGetPtrCommand<CLMemory, TRecord>)
  where TRecord: record;
    private mem_offset: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemory:GetValue%');
    end;
    public constructor(ccq: CLMemoryCCQ; mem_offset: CommandQueue<integer>);
    begin
      inherited Create(ccq);
      self.mem_offset := mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      prev_commands.InitBeforeInvoke(g, prev_hubs);
      mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>; own_qr: QueueRes<TRecord>): ParamInvRes<CLMemory>; override;
    begin
      var mem_offset_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        mem_offset_qr := invoker.InvokeBranch(mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        mem_offset_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var mem_offset := mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(mem_offset), new UIntPtr(Marshal.SizeOf(default(TRecord))),
          (own_qr as QueueResPtr<TRecord>).GetResPtrForWrite,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          GC.KeepAlive(own_qr);
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenGetValue<TRecord>(mem_offset: CommandQueue<integer>): CommandQueue<TRecord>; where TRecord: record;
begin
  Result := new CLMemoryCommandGetValue<TRecord>(self, mem_offset) as CommandQueue<TRecord>;
end;

{$endregion GetValue}

{$region GetArray!AutoSize}

type
  CLMemoryCommandGetArrayAutoSize<TRecord> = sealed class(EnqueueableGetCommand<CLMemory, array of TRecord>)
  where TRecord: record;
    
    protected function ExpectedEnqCount: integer; override := 0;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemory:GetArrayAutoSize%');
    end;
    public constructor(ccq: CLMemoryCCQ);
    begin
      inherited Create(ccq);
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override := prev_commands.InitBeforeInvoke(g, prev_hubs);
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>; own_qr: QueueRes<array of TRecord>): ParamInvRes<CLMemory>; override;
    begin
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var res := new TRecord[o.Size64 div Marshal.SizeOf(default(TRecord))];;
        own_qr.SetRes(res);
        var res_hnd := GCHandle.Alloc(res, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(0), new UIntPtr(res.Length * Marshal.SizeOf(default(TRecord))),
          res_hnd.AddrOfPinnedObject.ToPointer,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          res_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override := sb += #10;
    
  end;
  
function CLMemoryCCQ.ThenGetArray<TRecord>: CommandQueue<array of TRecord>; where TRecord: record;
begin
  Result := new CLMemoryCommandGetArrayAutoSize<TRecord>(self) as CommandQueue<array of TRecord>;
end;

{$endregion GetArray!AutoSize}

{$region GetArray}

type
  CLMemoryCommandGetArray<TRecord> = sealed class(EnqueueableGetCommand<CLMemory, array of TRecord>)
  where TRecord: record;
    private len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemory:GetArray%');
    end;
    public constructor(ccq: CLMemoryCCQ; len: CommandQueue<integer>);
    begin
      inherited Create(ccq);
      self.len := len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      prev_commands.InitBeforeInvoke(g, prev_hubs);
      len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>; own_qr: QueueRes<array of TRecord>): ParamInvRes<CLMemory>; override;
    begin
      var len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        len_qr := invoker.InvokeBranch(len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var len := len_qr.GetResDirect;
        var res := new TRecord[len];
        own_qr.SetRes(res);
        var res_hnd := GCHandle.Alloc(res, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(0), new UIntPtr(int64(len) * Marshal.SizeOf(default(TRecord))),
          res[0],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          res_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenGetArray<TRecord>(len: CommandQueue<integer>): CommandQueue<array of TRecord>; where TRecord: record;
begin
  Result := new CLMemoryCommandGetArray<TRecord>(self, len) as CommandQueue<array of TRecord>;
end;

{$endregion GetArray}

{$region GetArray2}

type
  CLMemoryCommandGetArray2<TRecord> = sealed class(EnqueueableGetCommand<CLMemory, array[,] of TRecord>)
  where TRecord: record;
    private len1: CommandQueue<integer>;
    private len2: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemory:GetArray2%');
    end;
    public constructor(ccq: CLMemoryCCQ; len1,len2: CommandQueue<integer>);
    begin
      inherited Create(ccq);
      self.len1 := len1;
      self.len2 := len2;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      prev_commands.InitBeforeInvoke(g, prev_hubs);
      len1.InitBeforeInvoke(g, prev_hubs);
      len2.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>; own_qr: QueueRes<array[,] of TRecord>): ParamInvRes<CLMemory>; override;
    begin
      var len1_qr: QueueRes<integer>;
      var len2_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        len1_qr := invoker.InvokeBranch(len1.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        len2_qr := invoker.InvokeBranch(len2.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        len1_qr.CancelStatusCheck('enq cancel');
        len2_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var len1 := len1_qr.GetResDirect;
        var len2 := len2_qr.GetResDirect;
        var res := new TRecord[len1,len2];
        own_qr.SetRes(res);
        var res_hnd := GCHandle.Alloc(res, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(0), new UIntPtr(int64(len1)*len2 * Marshal.SizeOf(default(TRecord))),
          res[0,0],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          res_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'len1:';
      sb += ' ';
      len1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len2:';
      sb += ' ';
      len2.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenGetArray2<TRecord>(len1,len2: CommandQueue<integer>): CommandQueue<array[,] of TRecord>; where TRecord: record;
begin
  Result := new CLMemoryCommandGetArray2<TRecord>(self, len1, len2) as CommandQueue<array[,] of TRecord>;
end;

{$endregion GetArray2}

{$region GetArray3}

type
  CLMemoryCommandGetArray3<TRecord> = sealed class(EnqueueableGetCommand<CLMemory, array[,,] of TRecord>)
  where TRecord: record;
    private len1: CommandQueue<integer>;
    private len2: CommandQueue<integer>;
    private len3: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 3;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemory:GetArray3%');
    end;
    public constructor(ccq: CLMemoryCCQ; len1,len2,len3: CommandQueue<integer>);
    begin
      inherited Create(ccq);
      self.len1 := len1;
      self.len2 := len2;
      self.len3 := len3;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      prev_commands.InitBeforeInvoke(g, prev_hubs);
      len1.InitBeforeInvoke(g, prev_hubs);
      len2.InitBeforeInvoke(g, prev_hubs);
      len3.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>; own_qr: QueueRes<array[,,] of TRecord>): ParamInvRes<CLMemory>; override;
    begin
      var len1_qr: QueueRes<integer>;
      var len2_qr: QueueRes<integer>;
      var len3_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        len1_qr := invoker.InvokeBranch(len1.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        len2_qr := invoker.InvokeBranch(len2.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        len3_qr := invoker.InvokeBranch(len3.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        len1_qr.CancelStatusCheck('enq cancel');
        len2_qr.CancelStatusCheck('enq cancel');
        len3_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var len1 := len1_qr.GetResDirect;
        var len2 := len2_qr.GetResDirect;
        var len3 := len3_qr.GetResDirect;
        var res := new TRecord[len1,len2,len3];
        own_qr.SetRes(res);
        var res_hnd := GCHandle.Alloc(res, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(0), new UIntPtr(int64(len1)*len2*len3 * Marshal.SizeOf(default(TRecord))),
          res[0,0,0],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          res_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'len1:';
      sb += ' ';
      len1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len2:';
      sb += ' ';
      len2.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len3:';
      sb += ' ';
      len3.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenGetArray3<TRecord>(len1,len2,len3: CommandQueue<integer>): CommandQueue<array[,,] of TRecord>; where TRecord: record;
begin
  Result := new CLMemoryCommandGetArray3<TRecord>(self, len1, len2, len3) as CommandQueue<array[,,] of TRecord>;
end;

{$endregion GetArray3}

{$endregion Get}


