


{$region Exec}

{$region Exec1}

type
  CLKernelCommandExec1 = sealed class(EnqueueableExecCommand)
    private  sz1: CommandQueue<integer>;
    private args: array of CLKernelArg;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(sz1: CommandQueue<integer>; params args: array of CLKernelArg);
    begin
      inherited Create(args);
      self. sz1 :=  sz1;
      self.args := args;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      foreach var arg in args do arg.InitBeforeInvoke(g, prev_hubs);
       sz1.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>; get_arg_cache: ()->CLKernelArgCache): ParamInvRes<cl_kernel>; override;
    begin
      var  sz1_qr: QueueRes<integer>;
      var arg_setters: array of CLKernelArgSetter;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
         sz1_qr := invoker.InvokeBranch( sz1.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        arg_setters := self.InvokeArgs(invoker, enq_evs, par_err_handlers);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
         sz1_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var  sz1 :=  sz1_qr.GetResDirect;
        ApplySetters(get_arg_cache(), arg_setters);
        var res_ev: cl_event;
        
        var ec := cl.EnqueueNDRangeKernel(
          cq, o, 1,
          IntPtr.Zero,
          | new UIntPtr(sz1) |[0],
          IntPtr.Zero,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          self.KeepArgsGCAlive;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'sz1:';
      sb += ' ';
      sz1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'args:';
      sb += #10;
      foreach var arg in args do arg.ToString(sb, tabs+1, index, delayed);
      
    end;
    
  end;
  
function CLKernelCCQ.ThenExec1(sz1: CommandQueue<integer>; params args: array of CLKernelArg): CLKernelCCQ;
begin
  Result := AddCommand(self, new CLKernelCommandExec1(sz1, args));
end;

{$endregion Exec1}

{$region Exec2}

type
  CLKernelCommandExec2 = sealed class(EnqueueableExecCommand)
    private  sz1: CommandQueue<integer>;
    private  sz2: CommandQueue<integer>;
    private args: array of CLKernelArg;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    public constructor(sz1,sz2: CommandQueue<integer>; params args: array of CLKernelArg);
    begin
      inherited Create(args);
      self. sz1 :=  sz1;
      self. sz2 :=  sz2;
      self.args := args;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      foreach var arg in args do arg.InitBeforeInvoke(g, prev_hubs);
       sz1.InitBeforeInvoke(g, prev_hubs);
       sz2.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>; get_arg_cache: ()->CLKernelArgCache): ParamInvRes<cl_kernel>; override;
    begin
      var  sz1_qr: QueueRes<integer>;
      var  sz2_qr: QueueRes<integer>;
      var arg_setters: array of CLKernelArgSetter;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
         sz1_qr := invoker.InvokeBranch( sz1.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
         sz2_qr := invoker.InvokeBranch( sz2.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        arg_setters := self.InvokeArgs(invoker, enq_evs, par_err_handlers);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
         sz1_qr.CancelStatusCheck('enq cancel');
         sz2_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var  sz1 :=  sz1_qr.GetResDirect;
        var  sz2 :=  sz2_qr.GetResDirect;
        ApplySetters(get_arg_cache(), arg_setters);
        var res_ev: cl_event;
        
        var ec := cl.EnqueueNDRangeKernel(
          cq, o, 2,
          IntPtr.Zero,
          | new UIntPtr(sz1),new UIntPtr(sz2) |[0],
          IntPtr.Zero,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          self.KeepArgsGCAlive;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'sz1:';
      sb += ' ';
      sz1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'sz2:';
      sb += ' ';
      sz2.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'args:';
      sb += #10;
      foreach var arg in args do arg.ToString(sb, tabs+1, index, delayed);
      
    end;
    
  end;
  
function CLKernelCCQ.ThenExec2(sz1,sz2: CommandQueue<integer>; params args: array of CLKernelArg): CLKernelCCQ;
begin
  Result := AddCommand(self, new CLKernelCommandExec2(sz1, sz2, args));
end;

{$endregion Exec2}

{$region Exec3}

type
  CLKernelCommandExec3 = sealed class(EnqueueableExecCommand)
    private  sz1: CommandQueue<integer>;
    private  sz2: CommandQueue<integer>;
    private  sz3: CommandQueue<integer>;
    private args: array of CLKernelArg;
    
    protected function ExpectedEnqCount: integer; override := 3;
    
    public constructor(sz1,sz2,sz3: CommandQueue<integer>; params args: array of CLKernelArg);
    begin
      inherited Create(args);
      self. sz1 :=  sz1;
      self. sz2 :=  sz2;
      self. sz3 :=  sz3;
      self.args := args;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      foreach var arg in args do arg.InitBeforeInvoke(g, prev_hubs);
       sz1.InitBeforeInvoke(g, prev_hubs);
       sz2.InitBeforeInvoke(g, prev_hubs);
       sz3.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>; get_arg_cache: ()->CLKernelArgCache): ParamInvRes<cl_kernel>; override;
    begin
      var  sz1_qr: QueueRes<integer>;
      var  sz2_qr: QueueRes<integer>;
      var  sz3_qr: QueueRes<integer>;
      var arg_setters: array of CLKernelArgSetter;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
         sz1_qr := invoker.InvokeBranch( sz1.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
         sz2_qr := invoker.InvokeBranch( sz2.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
         sz3_qr := invoker.InvokeBranch( sz3.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        arg_setters := self.InvokeArgs(invoker, enq_evs, par_err_handlers);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
         sz1_qr.CancelStatusCheck('enq cancel');
         sz2_qr.CancelStatusCheck('enq cancel');
         sz3_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var  sz1 :=  sz1_qr.GetResDirect;
        var  sz2 :=  sz2_qr.GetResDirect;
        var  sz3 :=  sz3_qr.GetResDirect;
        ApplySetters(get_arg_cache(), arg_setters);
        var res_ev: cl_event;
        
        var ec := cl.EnqueueNDRangeKernel(
          cq, o, 3,
          IntPtr.Zero,
          | new UIntPtr(sz1),new UIntPtr(sz2),new UIntPtr(sz3) |[0],
          IntPtr.Zero,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          self.KeepArgsGCAlive;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'sz1:';
      sb += ' ';
      sz1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'sz2:';
      sb += ' ';
      sz2.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'sz3:';
      sb += ' ';
      sz3.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'args:';
      sb += #10;
      foreach var arg in args do arg.ToString(sb, tabs+1, index, delayed);
      
    end;
    
  end;
  
function CLKernelCCQ.ThenExec3(sz1,sz2,sz3: CommandQueue<integer>; params args: array of CLKernelArg): CLKernelCCQ;
begin
  Result := AddCommand(self, new CLKernelCommandExec3(sz1, sz2, sz3, args));
end;

{$endregion Exec3}

{$region Exec}

type
  CLKernelCommandExec = sealed class(EnqueueableExecCommand)
    private global_work_offset: CommandQueue<array of UIntPtr>;
    private   global_work_size: CommandQueue<array of UIntPtr>;
    private    local_work_size: CommandQueue<array of UIntPtr>;
    private               args: array of CLKernelArg;
    
    protected function ExpectedEnqCount: integer; override := 3;
    
    public constructor(global_work_offset, global_work_size, local_work_size: CommandQueue<array of UIntPtr>; params args: array of CLKernelArg);
    begin
      inherited Create(args);
      self.global_work_offset := global_work_offset;
      self.  global_work_size :=   global_work_size;
      self.   local_work_size :=    local_work_size;
      self.              args :=               args;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      foreach var arg in args do arg.InitBeforeInvoke(g, prev_hubs);
      global_work_offset.InitBeforeInvoke(g, prev_hubs);
        global_work_size.InitBeforeInvoke(g, prev_hubs);
         local_work_size.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>; get_arg_cache: ()->CLKernelArgCache): ParamInvRes<cl_kernel>; override;
    begin
      var global_work_offset_qr: QueueRes<array of UIntPtr>;
      var   global_work_size_qr: QueueRes<array of UIntPtr>;
      var    local_work_size_qr: QueueRes<array of UIntPtr>;
      var arg_setters: array of CLKernelArgSetter;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        global_work_offset_qr := invoker.InvokeBranch(global_work_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
          global_work_size_qr := invoker.InvokeBranch(  global_work_size.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
           local_work_size_qr := invoker.InvokeBranch(   local_work_size.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        arg_setters := self.InvokeArgs(invoker, enq_evs, par_err_handlers);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        global_work_offset_qr.CancelStatusCheck('enq cancel');
          global_work_size_qr.CancelStatusCheck('enq cancel');
           local_work_size_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var global_work_offset := global_work_offset_qr.GetResDirect;
        var   global_work_size :=   global_work_size_qr.GetResDirect;
        var    local_work_size :=    local_work_size_qr.GetResDirect;
        ApplySetters(get_arg_cache(), arg_setters);
        var res_ev: cl_event;
        
        var ec := cl.EnqueueNDRangeKernel(
          cq, o, global_work_size.Length,
          global_work_offset[0],
          global_work_size[0],
          local_work_size[0],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          self.KeepArgsGCAlive;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'global_work_offset:';
      sb += ' ';
      global_work_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'global_work_size:';
      sb += ' ';
      global_work_size.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'local_work_size:';
      sb += ' ';
      local_work_size.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'args:';
      sb += #10;
      foreach var arg in args do arg.ToString(sb, tabs+1, index, delayed);
      
    end;
    
  end;
  
function CLKernelCCQ.ThenExec(global_work_offset, global_work_size, local_work_size: CommandQueue<array of UIntPtr>; params args: array of CLKernelArg): CLKernelCCQ;
begin
  Result := AddCommand(self, new CLKernelCommandExec(global_work_offset, global_work_size, local_work_size, args));
end;

{$endregion Exec}

{$endregion Exec}


