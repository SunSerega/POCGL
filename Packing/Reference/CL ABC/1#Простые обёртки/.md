


Сам модуль `OpenCLABC` - обёртка модуля `OpenCL`. Это значит, что внутри он использует
содержимое `OpenCL`, но при подключении - показывает только свой личный функционал.

Так же множество типов из `OpenCLABC` являются обёртками типов из `OpenCL`.

Тип `CommandQueue` использует тип `cl_command_queue`, но предоставляет очень много не связанного с `cl_command_queue` функционала.

"Простые" типы-обёртки модуля `OpenCLABC` предоставляют только функционал соответствующего
типа из модуля `OpenCL`... в более презентабельном виде. Из общего - у таких типов есть:

- Свойство `.Native`, возвращающее внутренний неуправляемый объект из модуля `OpenCL`.\
Если вам не пришлось, по какой-либо причине, использовать `OpenCLABC` и `OpenCL` вместе - это свойство может понадобится только для дебага.

- Свойство `.Properties`, возвращающее объект свойств внутреннего объекта.\
Свойства неуправляемого объекта никак не обрабатываются и не имеют описаний.
Но типы этих свойств всё равно преобразуются в управляемые (особо заметно на строках и массивах).

---

# Страницы:

- <a path="Platform">		Platform	</a> - Платформа, объединяющая несколько совместимых устройств;
- <a path="Device">			Device		</a> - Устройство, поддерживающее OpenCL;
- <a path="Context">		Context		</a> - Контекст выполнения;
- <a path="Kernel">			Kernel		</a> - Подпрограмма, выполняемая на GPU;
- <a path="ProgramCode">	ProgramCode	</a> - Контейнер kernel'ов;
- <a path="Память">			Память		</a> - Обёртки памяти GPU.


