


Большинство деревьев выполнения очередей можно реализовать используя только сложение и умножение очередей. Но есть несколько проблем:

-  Большинство но не все. Пример дерева которое нельзя реализовать через сложение и умножение можно найти [тут](https://github.com/SunSerega/POCGL/blob/master/Samples/OpenCLABC/Wait%20очереди/1.pas) или в файле:\
   C:\\PABCWork.NET\\Samples\\OpenGL и OpenCL\\OpenCLABC\\Wait очереди\\1.pas
   
-  Даже если дерево реализуется сложением+умножением - такая реализация может выглядеть запутано и не похоже на график дерева выполнения, [к примеру](https://github.com/SunSerega/POCGL/blob/master/Samples/OpenCLABC/Wait%20очереди/2.pas):\
   C:\\PABCWork.NET\\Samples\\OpenGL и OpenCL\\OpenCLABC\\Wait очереди\\2.pas
   
-  Очереди, выполняемые на разных контекстах не могут эффективно взаимодействовать.

Эти проблемы решают `Wait`-очереди:
```
## uses OpenCLABC;

var M := WaitMarker.Create;

var t := Context.Default.BeginInvoke(
  HPQ(()->Writeln('Начало .BeginInvoke')) +
  WaitFor(M) +
  HPQ(()->Writeln('Конец .BeginInvoke'))
);

Sleep(2000);
Writeln('Посылаем сигнал маркера M');
M.SendSignal;

t.Wait;
```
`WaitFor(M)` создаёт очень простую `Wait`-очередь.\
Внутри вызова `.BeginInvoke` (до того как он вернёт `CLTask`)
эта очередь входит в режим ожидания сигналов от маркера `M`.\
В этом режиме она **не** тратит время процессора, но готова возобновить выполнение в любой момент.

Далее, вызов `M.SendSignal` посылает по 1 сигналу всем `.BeginInvoke`, имеющим `Wait`-очереди в ожидании этого сигнала.

---

`WaitMarker` не является очередью, но может быть преобразован к типу `CommandQueueBase`, в своеобразную выполняемую форму.

Преобразование к выполняемой форме обычно происходит автоматически, если складывать/умножать его с другими очередями,
либо передавать в подпрограмму принимающую `CommandQueueBase`, как `.BeginInvoke`.\
Так же его можно вызвать явно, написав `CommandQueueBase(M)`, где `M` - маркер.

Выполняемая форма маркера вызывает метод `.SendSignal` своего макера.\
То есть `CommandQueueBase(M)` обычно равноценна, но немного эффективнее чем `HPQQ(M.SendSignal)`.\
Но не всегда - потому что `HPQ` возвращает `nil`, а выполняемая форма маркера может возвращать другие результаты (об этом ниже).

И стоит так же сказать, прямой вызов `M.SendSignal` всё равно всегда эффективнее чем `Context.Default.SyncInvoke(M)`.\
Используйте выполнение маркеров внутри `.BeginInvoke` только если вам надо активировать его сразу после других очередей:
```
var M := WaitMarker.Create;

Context.Default.SyncInvoke(
  HFQ(()->5) + M
);
```

---

Но в этом же коде видно ещё одну проблему - сложение очередей возвращает последний результат,
то есть результат маркера (который для простого макера из `WaitMarker.Create` - `nil`).

Если нужно иметь сразу и маркер и возвращаемое значение предыдущей очереди,
можно создать оторванный сигнал маркера методом `.ThenMarkerSignal`:
```
## uses OpenCLABC;
var Q := HFQ(()->5).ThenMarkerSignal;

var t := Context.Default.BeginInvoke(
  WaitFor(Q) + HPQ(()->Writeln('Получен сигнал от Q'))
);
var res := Context.Default.SyncInvoke( Q );

t.Wait;
res.Println;
```
Тут выполнение `Q` сначала выполнит `HFQ`, затем пошлёт сигнал в
`Wait`-очередь `WaitFor(Q)` и в конце вернёт то, что вернула `HFQ`.

В общем случае, оторванный сигнал макера является очередью, и имеет то же возвращаемое значение, что очередь из которой он был создан.\
Но в то же время его можно преобразовать типу `WaitMarker`, так же как `WaitMarker` преобразовывается в `CommandQueueBase`.\
Более того, выполняемая форма полученного маркера - это оторванный сигнал, из которого создали этот маркер.
Другими словами даже после преобразования в `WaitMarker` - оторванный сигнал можно выполнить и получить его результат:
```
## uses OpenCLABC;
var Q := HFQ(()->5).ThenMarkerSignal;
var M: WaitMarker := Q;

Context.Default.SyncInvoke(
  CommandQueueBase(M)
  // CommandQueueBase надо всё равно как то преобразовать,
  // чтобы SyncInvoke вернуло результат Q
  .Cast&<integer>
).Println;
```

---

Того же эффекта можно добится используя `.Multiusable`:
```
## uses OpenCLABC;

var Qs := HFQ(()->5).Multiusable;
var M := WaitMarker.Create;

var t := Context.Default.BeginInvoke(
  WaitFor(M) + HPQ(()->Writeln('Получен сигнал от M'))
);
var res := Context.Default.SyncInvoke( Qs()+M+Qs() );

t.Wait;
res.Println;
```
То есть `.ThenMarkerSignal` не имеет незаменимых применений, но делает код читабельнее.

---

Есть всего три подпрограммы, создающие `Wait`-очереди:

1. Глобальная, `WaitFor`:\
   Ничего не делает сама, но блокирует выполнение, ожидая сигнала указанного маркера.
   
2. Ещё один общий метод CCQ объектов: `.ThenWait`:\
   Как и `.ThenQueue` и `.ThenProc`, `.ThenWait(...)` это всего лишь аналог
   `.ThenQueue(WaitFor(...))`, существующий только ради читабельности кода.
   
3. Метод очереди с результатом, `.ThenWaitFor`:\
   Как и `.ThenMarkerSignal`, сначала выполняет исходную очередь, потом ожидает и в конце возвращает результат исходной очереди.

---

Маркеры можно комбинировать:
```
## uses OpenCLABC;

var M1 := WaitMarker.Create;
var M2 := WaitMarker.Create;

var Q1 := WaitFor(M1 and M2); // Ожидание обоих маркеров
var Q2 := WaitFor(M1 or M2); // Ожидание любого из маркеров
```
При этом если надо применить `and` или `or` >2 маркерам - лучше использовать `WaitAll`/`WaitAny` соответственно:
```
## uses OpenCLABC;

var M1 := WaitMarker.Create;
var M2 := WaitMarker.Create;
var M3 := WaitMarker.Create;

var Q1 := WaitFor(WaitAll(M1,M2,M3)); // Ожидание всех маркеров
var Q2 := WaitFor(WaitAny(M1,M2,M3)); // Ожидание любого из маркеров
```

---

`Wait`-очереди работают даже между вызовами `Context.BeginInvoke`, в отличии от всего остального в `OpenCLABC`.

Это не всегда безопасно:
```
Context.Default.BeginInvoke(M);
Context.Default.BeginInvoke(WaitFor(M) + Q);
```
Проблема этого кода в том, что `M` может послать сигнал ещё до того как `WaitFor(M)` начнёт ждать.

Чтобы такое не происходило - надо всегда запускать `Wait`-очередь раньше маркера:
```
Context.Default.BeginInvoke(WaitFor(M) + Q);
Context.Default.BeginInvoke(M);
```
Но, как всегда, лучше объединять вызовы `Context.BeginInvoke`:
```
Context.Default.BeginInvoke(
  ( M ) *
  ( WaitFor(M) + Q )
);
```
Все `Wait`-очереди начинают ждать в самом начале вызова `Context.BeginInvoke`, перед началом выполнения очереди.
Поэтому если `Wait`-очередь и вызов её маркера находятся в общем `Context.BeginInvoke` - использовать их можно в любом порядке.

---

Все `Wait`-очереди в одном `Context.BeginInvoke`, ожидающие один и тот же маркер, образуют общую `Wait`-группу.\
Когда ожидаемый этой группой маркер активируется - он удаляет из `Wait`-группы одну из `Wait`-очередей, посылая ей сигнал.
```
## uses OpenCLABC;

var Q1 := HPQ(()->
begin
  Sleep(10);
  lock output do Writeln('Выполнилась Q1');
end).ThenMarkerSignal;

var Q2 := HPQ(()->lock output do Writeln('Выполнилась Q2'));
var Q3 := HPQ(()->lock output do Writeln('Выполнилась Q3'));

var t1 := Context.Default.BeginInvoke(
  (WaitFor(Q1)+Q2) *
  (WaitFor(Q1)+Q3)
);
Context.Default.SyncInvoke(Q1+Q1);

// Все оставшиеся CLTask лучше ожидать, чтобы
// вывести ошибки, если возникнут при выполнении очереди
t1.Wait;
```
Тут `Q1` посылает 2 сигнала, сначала в первый `WaitFor(Q1)`, затем во второй.\
В данный момент не рекомендуется расчитывать на порядок `Wait`-очередей в `Wait`-группе.

Ну и, конечно, лучше совместить вызовы `Context.BeginInvoke`, раз контекст общий:
```
## uses OpenCLABC;

var Q1 := HPQ(()->
begin
  Sleep(10);
  lock output do Writeln('Выполнилась Q1');
end).ThenMarkerSignal;

var Q2 := HPQ(()->lock output do Writeln('Выполнилась Q2'));
var Q3 := HPQ(()->lock output do Writeln('Выполнилась Q3'));

Context.Default.SyncInvoke(
  (Q1+Q1) *
  (WaitFor(Q1)+Q2) *
  (WaitFor(Q1)+Q3)
);
```
Будьте осторожны, лишняя `Wait`-очередь вызовет зависание:
```
## uses OpenCLABC;

var Q1 := HFQ(()->0).ThenMarkerSignal;

var t1 := Context.Default.BeginInvoke(
  WaitFor(Q1) +
  // Второй запуск Q1 никогда не произойдёт,
  // поэтому эта Wait очередь зависнет
  WaitFor(Q1)
);
Context.Default.SyncInvoke(Q1);

t1.Wait;
```

---

`Wait`-очереди ожидающие один и тот же маркер в разных `Context.BeginInvoke` - образуют отдельные `Wait`-группы.\
И при активации маркера - он посылает по 1 сигналу **каждой** (ожидающей его) `Wait`-группе:
```
## uses OpenCLABC;

var Q1 := HPQ(()->
begin
  Sleep(1000);
  lock output do Writeln('Выполнилась Q1');
end).ThenMarkerSignal;

var Q2 := HPQ(()->lock output do Writeln('Выполнилась Q2'));
var Q3 := HPQ(()->lock output do Writeln('Выполнилась Q3'));

var Q4 := HPQ(()->lock output do Writeln('Выполнилась Q4'));
var Q5 := HPQ(()->lock output do Writeln('Выполнилась Q5'));

var t1 := Context.Default.BeginInvoke(
  ( WaitFor(Q1)+Q2 ) *
  ( WaitFor(Q1)+Q3 )
);
var t2 := Context.Default.BeginInvoke(
  ( WaitFor(Q1)+Q4 ) *
  ( WaitFor(Q1)+Q5 )
);
// Каждый вызов Q1 тут - активирует по одному WaitFor(Q1) в каждом .BeginInvoke
Context.Default.SyncInvoke(Q1+Q1);

t1.Wait;
t2.Wait;
```


