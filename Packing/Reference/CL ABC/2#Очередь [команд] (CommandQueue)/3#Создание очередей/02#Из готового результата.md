


Константы в любом контексте позволяют проводить особые оптимизации.\
В случае `OpenCLABC` - константные очереди являются константами только на время выполнения очереди.
```
## uses OpenCLABC;

var cq := new ConstQueue<integer>(1);
Context.Default.SyncInvoke(cq).Println;

cq.Value := 2;
Context.Default.SyncInvoke(cq).Println;
```
Обратите внимание, `.Value` нельзя изменять пока `.BeginInvoke` не досоздаст `CLTask`. Иначе поведение неопределено.

---

Так же, константную очередь можно создать присвоив значение результата туда, где ожидается очередь:
```
var q: CommandQueue<integer> := 1;
```
Для этого тип значения (`1`) и результата очереди `<integer>` должны полностью совпадать. К примеру так сделать не позволит:
```
//Ошибка: Нельзя преобразовать тип integer к CommandQueue<object>
var q: CommandQueue<object> := 1;
```
Чтобы можно было присвоить - значение надо явно преобразовать к `object`:
```
var q: CommandQueue<object> := object(1);
```
Этот способ создания константной очереди обычно используется подпрограммами, принимающими очереди:
```
## uses OpenCLABC;

procedure p1(q: CommandQueue<integer>) :=
Context.Default.SyncInvoke(q).Println;

p1(1);
p1(HFQQ(()->2));
```
В `OpenCLABC` есть множество подпрограмм, принимающий очередь вместо значения.
<a path="../Вложенные очереди/">Подробнее</a>.
 
---

Если нужно сохранить константную очередь в переменную, можно написать:
```
var q1 := new ConstQueue<integer>(1);
var q2: CommandQueue<integer> := 3;
```
Но оба способа объёмны и, что важнее, требуют указать тип значения явно.

Поэтому в `OpenCLABC` есть вспомогательная подпрограмма:
```
var q3 := CQ(3);
```

---

У очередей есть возвращаемое значение, но чтобы передавать в них данные при запуске - можно
или создавать новую очередь на каждое выполнение (что очень не эффективно), или выкручиваться так:
```
uses OpenCLABC;

type
  MyQueueContainer = sealed class
    private Q: CommandQueue<integer>;
    private par1 := new ConstQueue<integer>(-1);
    private par2 := new ConstQueue<string>(nil);
    
    // Эта очередь ничего полезного не делает, но это только пример
    public constructor := self.Q :=
    MemorySegment.Create(sizeof(integer)).NewQueue
    .ThenWriteValue( self.par1 )
    .ThenQueue( self.par2.ThenQuickUse(x->Writeln(x)) )
    .ThenGetValue&<integer>;
    
    public function Invoke(par1: integer; par2: string): integer;
    begin
      var tsk: CLTask<integer>;
      // Нужна блокировка, чтобы если метод Invoke будет выполнен
      // в нескольких потоках одновременно, .Value параметров
      // не могло поменяться пока Context.BeginInvoke создаёт CLTask
      lock self do
      begin
        self.par1.Value := par1;
        self.par2.Value := par2;
        tsk := Context.Default.BeginInvoke(Q);
      end;
      
      Result := tsk.WaitRes;
    end;
    
  end;
  
begin
  var cont := new MyQueueContainer;
  
  cont.Invoke(1, 'abc').Println;
  cont.Invoke(2, 'def').Println;
  
end.
```
Но это не очень красиво. Можно сделать красивее, используя специальную очередь-параметр.\
`ParameterQueue<T>` тоже является константной во время выполнения очереди, но используется по-другому:
```
uses OpenCLABC;

type
  MyQueueContainer = sealed class
    private Q: CommandQueue<integer>;
    private par1 := new ParameterQueue<integer>('par1');
    private par2 := new ParameterQueue<string>('par2');
    
    // Эта очередь ничего полезного не делает, но это только пример
    public constructor := self.Q :=
    MemorySegment.Create(sizeof(integer)).NewQueue
    .ThenWriteValue( self.par1 )
    .ThenQueue( self.par2.ThenQuickUse(x->Writeln(x)) )
    .ThenGetValue&<integer>;
    
    public function Invoke(par1: integer; par2: string) :=
    Context.Default.SyncInvoke(self.Q,
      self.par1.NewSetter(par1),
      self.par2.NewSetter(par2)
    );
    
  end;
  
begin
  var cont := new MyQueueContainer;
  
  cont.Invoke(1, 'abc').Println;
  cont.Invoke(2, 'def').Println;
  
end.
```
Таким образом код получается значительно чище.\
Кроме того, при запуске очереди проводятся проверки, чтобы очереди-параметры
не оказывались не_определены или установлены дважды.


