


Если сложить две очереди A и B (`var C := A+B`) — получится очередь C, в которой сначала выполнится A, а затем B.\
Очередь C будет считаться выполненной тогда, когда выполнится очередь B.

Если умножить две очереди A и B (`var C := A*B`) — получится очередь C, в которой одновременно начнут выполняться A и B.\
Очередь C будет считаться выполненной тогда, когда обе очереди (A и B) выполнятся.

Как и в математике, умножение имеет бОльший приоритет чем сложение.

В обоих случаях очередь C будет возвращать то, что вернула очередь B. То есть если складывать и умножать много очередей - результат будет всегда возвращать то, что вернула самая последняя очередь.

Простейший пример:
```
## uses OpenCLABC;

var q1 := HPQ(()->
begin
  // lock необходим чтобы при параллельном выполнении два потока
  // не пытались использовать вывод одновременно. Иначе выведет кашу
  lock output do Writeln('Очередь 1 начала выполняться');
  Sleep(500);
  lock output do Writeln('Очередь 1 закончила выполняться');
end);
var q2 := HPQ(()->
begin
  lock output do Writeln('Очередь 2 начала выполняться');
  Sleep(500);
  lock output do Writeln('Очередь 2 закончила выполняться');
end);

Writeln('Последовательное выполнение:');
Context.Default.SyncInvoke( q1 + q2 );

Writeln;
Writeln('Параллельное выполнение:');
Context.Default.SyncInvoke( q1 * q2 );
```

Операторы += и \*= также применимы к очередям.\
И как и для чисел - `A += B` работает как `A := A+B` (и аналогично с \*=).\
А значит, возвращаемые типы очередей A и B должны быть одинаковыми, чтобы к ним можно было применить +=/*=.

---

Если надо сложить/умножить много очередей - лучше применять `CombineSyncQueue`/`CombineAsyncQueue` соответственно.\
Точнее `A+B+C` это то же самое что `CombineSyncQueue(CombineSyncQueue(A, B), C)`.\
Поэтому `CombineSyncQueue(A, B, C)` создаст очередь немного быстрее чем `A+B+C`.\
Но скорость выполнения очереди будет абсолютно одинаковой в этих двух случаях.

Чтобы складывать/умножать много `CommandQueueBase` и `CommandQueueNil` очередей
используются `Combine*QueueBase` и `Combine*QueueNil` соответственно.

---

Используя `CombineConv*Queue` можно указать функцию преобразования, принимающую результаты всех скомбинированных очередей:
```
## uses OpenCLABC;

var q1 := HFQ( ()->1 );
var q2 := HFQ( ()->2 );

// Выводит 2, то есть только результат последней очереди
// Так сделано из за вопросов производительности
Context.Default.SyncInvoke( q1+q2 ).Println;
// Но бывает так, что нужны результаты всех сложенных/умноженных очередей

// В таком случае надо использовать CombineConv*Queue
Context.Default.SyncInvoke(
  CombineConvSyncQueue(
    results->results.JoinToString, // Функция преобразования
    q1, q2
  )
).Println;
// Выводит строку "1 2". Это то же самое, что вернёт "Arr(1,2).JoinToString"
```
И так же как с другими очередями с кодом на CPU - есть `Quick` версия:
```
## uses OpenCLABC;

var q1 := HFQQ( ()->1 );
var q2 := HFQQ( ()->2 );

Context.Default.SyncInvoke( q1+q2 ).Println;

Context.Default.SyncInvoke(
  CombineQuickConvSyncQueue(
    results->results.JoinToString,
    q1, q2
  )
).Println;
```

---

Если надо скомбинировать несколько очередей с разными типами результатов, но при этом использовать все результаты, можно использовать `CombineConv*QueueN*`:
```
## uses OpenCLABC;

var q1 := HFQQ( ()->1 );
var q2 := HFQQ( ()->'abc' );

Context.Default.SyncInvoke( q1+q2 ).Println;

Context.Default.SyncInvoke(
  CombineConvSyncQueueN2(
    (r1,r2)->$'integer[{r1}]+string[{r2}]',
    q1, q2
  )
).Println;
```
У каждой из `CombineConv*QueueN*` так же есть `CombineQuickConv*QueueN*` версия.


