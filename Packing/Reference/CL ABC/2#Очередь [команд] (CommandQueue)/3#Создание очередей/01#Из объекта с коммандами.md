


OpenCL используется для передачи комманд в GPU.
Поэтому в первую очередь стоит поговорить об очередях `OpenCLABC`, содержащих комманды для GPU.

Такие очереди создаются из некоторых типов-простых_обёрток методом `.NewQueue` и имеют тип с припиской `CCQ`.\
("Command Container Queue", то есть очередь-контейнер для коман GPU)\
К примеру, метод `CLArray<byte>.NewQueue` вернёт очередь типа `CLArrayCCQ<byte>`, наследующего от `CommandQueue< CLArray<byte> >`.

Чтобы создать саму комманду - надо вызвать соответствующий ей метод `CCQ` объекта. К примеру:
```
## uses OpenCLABC;

// Массив на 3 элемента типа integer
var a := new CLArray<integer>(3);

// Создаём очередь
var q: CLArrayCCQ<integer> := a.NewQueue;

Context.Default.SyncInvoke(q
  .ThenWriteValue(1, 0)
  // Записывать по 1 элементу не эффективно
  // Лучше сначала создать массив в RAM
  // А затем послать его целиком
  .ThenWriteArray(|5,7|, 1, 2,0)
  // .ThenGet методы особенные, потому что не возвращают CCQ объект
  // В данном случае эта комманда читает весь CLArray как обычный массив в RAM
  .ThenGetArray
).Println;
```

Также, `CCQ` очереди можно создавать из очередей, возвращающих объект с командами. Для этого используется конструктор:
```
var q0: CommandQueue<MemorySegment>;
...
var q := new MemorySegmentCCQ(q0);
```

---

Команды объектов, представляющих память на GPU, можно разделить на группы.

По направлению передачи:
1. `Write` и `Fill`: Из RAM в память GPU;
2. `Read` и `Get`: Из памяти GPU в RAM;
3. `Copy`: Между двумя областями памяти GPU.

И по типу данных на стороне RAM:
1. `Data`: Используются данные, находящиеся в RAM по указанному адресу;
2. `Value`: Используется размерное значение;
3. `Array`: Используется содержимое указанного массива размерных значений.

Но при этом отсутствуют некоторые комбинации.

В первую очередь, в случае `Copy` нет понятия типа данных на стороне RAM, потому что RAM в принципе не задействуется.

И нет `GetData`, потому что в случае ошибок будут утечки памяти.
Вместо него выделяйте память явно и передавайте её в `ReadData`.

Так же, `WriteValue` может принимать размерное значение и `NativeValue`, но `ReadValue` принимает только `NativeValue`.\
Это потому, что принимать размерное значение в `ReadValue` `var`-параметром не безопасно,
как и в случае передачи адреса в качестве <a path="../../Простые обёртки/Kernel/KernelArg"> `KernelArg` </a>.\
Если вы понимаете что делаете - используйте `ReadData`, явно передавая в него адрес вашего значения (то есть указатель).\
Но обычно лучше использовать `GetValue`, создающее и возвращающее новое размерное значение, либо `ReadValue` принимающее `NativeValue`.

---

Кроме таких объектов, методы-команды для GPU есть только у `Kernel`. И все они представляют запуск kernel'а.

---

Комманда `.ThenGet` не выполняется, если её результат выкидывается.
Подробнее <a path="../Возвращаемое значение очередей/">тут</a>.

Это оптимизация, которую вы можете заметить только в одном случае:
Если параметры этой команды были неправильные - ошибка не возникнет.


