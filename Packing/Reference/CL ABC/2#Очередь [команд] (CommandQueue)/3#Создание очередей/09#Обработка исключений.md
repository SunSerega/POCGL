


Для начала немного о распространении ошибок в очередях:

Исключения в очереди Q отменяет выполнение всех очередей, ожидающих Q,
но никак не влияет на параллельные к Q очереди:
```
## uses OpenCLABC;

function make_q(i: integer) :=
HPQ(()->lock output do Writeln(i));

try
  Context.Default.SyncInvoke(
    make_q(1) +
    (make_q(2) * HPQ(()->raise new Exception('3')))
    + make_q(4)
  );
except
  on e: System.AggregateException do
    Writeln(e.InnerExceptions.Single);
end;
```
Очередь 1 выполняется в любом случае, потому что очередь с ошибкой (3) находится позже;\
Очередь 2 выполняется, потому что она стоит параллельно к очереди 3;\
Очередь 3 выполняется и в процессе кидает исключение;\
Очередь 4 пропускается, потому что ожидает успешного выполнения очередей 2 и 3.

Может звучать тривиально - но это базовое правило, распространяющееся на более сложные случаи. К примеру:
```
## uses OpenCLABC;

var M := WaitMarker.Create;

try
  Context.Default.SyncInvoke(
    (HPQ(()->raise new Exception('Special error')) + WaitFor(M))
  *
    (HPQ(()->Sleep(100)) + WaitFor(M))
  *
    M
  );
except
  on e: System.AggregateException do
    Writeln(e.InnerExceptions.Single);
end;
```
Из за исключения первое `WaitFor(M)` пропускается. Оно начинает ожидать
ещё до выхода из `.BeginInvoke`, но затем отменяется, а значит не имеет
шанса поглотить сигнал от `M`, оставляя его для второго `WaitFor(M)`.

---

Так же надо сказать что `.Multiusable` даёт множественный доступ
к любому результату выполнения очереди, будь то возвращаемое значение или ошибка:
```
## uses OpenCLABC;

var Qs := HPQ(()->raise new Exception('Special error')).Multiusable;

try
  Context.Default.SyncInvoke( Qs()*Qs() );
except
  on e: System.AggregateException do
    e.InnerExceptions.PrintLines;
end;
```
Этот код выводит ошибку дважды, потому что она пришла из 2 параллельных веток, которые обе взяли её из общего источника.

---

Самый простой обработчик ошибок это `.HandleWithoutRes`:\
Он применим ко всем очередям, в том числе `CommandQueueBase`, потому что игнорирует любое предыдущее
возвращаемое значение и создаёт `CommandQueueNil`.

Есть два варианта вызова `.HandleWithoutRes`:

1. Ловля всех исключений - аналог `on e: Exception do`:
   ```
   ## uses OpenCLABC;

   var Q1 := HPQ(()->raise new Exception('Expected error'));
   var Q2 := HPQ(()->raise new Exception('Unexpected error'));

   try
     Context.Default.SyncInvoke( (Q1*Q2)
       // Ловим все исключения с указанным сообщением
       // Для реального случая это плохо, но для демонстрации нормально
       .HandleWithoutRes(e->(e.Message.Print='Expected error').Println)
     );
   except
     on e: System.AggregateException do
       e.InnerExceptions.PrintLines;
   end;
   ```
2. Ловля исключений конкретного типа - аналог `on e: ... do`:
   ```
   ## uses OpenCLABC;

   var Q1 := HPQ(()->raise new System.InvalidOperationException);
   var Q2 := HPQ(()->raise new System.InvalidTimeZoneException);

   try
     Context.Default.SyncInvoke( (Q1*Q2)
       // Ловим все исключения типа InvalidOperationException
	   // Опять же, вообще плохо съедать исключения без полной диагностики
       .HandleWithoutRes&<System.InvalidOperationException>(e->true)
     );
   except
     on e: System.AggregateException do
       e.InnerExceptions.PrintLines;
   end;
   ```

---

Далее, обработчик `.HandleDefaultRes`:

Если в очереди было кинуто исключение - возвращаемое значение не существует (не `nil`, а именно отсутствует).\
Поэтому чтобы вернуть очередь с определённым типом возвращаемого значения,
необходимо заменить результат после успешной обработки исключения:
```
## uses OpenCLABC;

// Исключение, кидаемое при не_первых выполнениях этой очереди
var need_error := false;
var QErr := HPQ(()->
begin
  if need_error then
    raise new Exception else
    need_error := true;
end);

loop 3 do Context.Default.SyncInvoke( (QErr+HFQ(()->5))
  // Ловим все исключения типа Exception
  // И заменяем результат на 0, если он отсутствует
  .HandleDefaultRes&<Exception>(e->true, 0)
).Println;
```

---

И последний - обработчик `.HandleReplaceRes`:

Не всегда значение, которым надо заменять возвращаемое значение очереди, можно посчитать до выполнения этой очереди.\
В более сложном случае это значение может вычисляться во время выполнения, скорее всего используя пойманные исключения.

В таком случае нет смысла обрабатывать исключения по одному, потому что так
можно получить несколько конфликтующих замен для возвращаемого значения:
```
## uses OpenCLABC;
var QErr := HPQ(()->raise new Exception);

Context.Default.SyncInvoke(
  (QErr*QErr + HFQ(()->-1))
  .HandleReplaceRes(lst->
  begin
    Result := lst.Count; // Возвращаемое значение
    lst.Clear; // Считаем что обработали всё
  end)
).Println;
```

`.HandleReplaceRes` нельзя вызывать на `Base` и `Nil` очередях, потому что непонятно что возвращать если ошибка **не** возникла.
Но всегда можно прибавить константную очередь к обрабатываемой, таким образом указав результат по-умолчанию, на случай без ошибок:
```
## uses OpenCLABC;

var Q1 := HPQQ(()->begin end);
var Q2 := HPQQ(()->raise new Exception);

Context.Default.SyncInvoke((Q1*Q2 + CQ(0)).HandleReplaceRes(err_lst->
begin
  err_lst.PrintLines;
  err_lst.Clear;
  Result := -1;
end)).Println;
```
Результат очереди из этого примера можно передавать напрямую в `Halt`, если вы, к примеру, делаете инструмент для коммандной строки.

---

Обратите внимание, обработчики исключений всегда действую по принципу `Quick` очередей.\
То есть код выполняемый на CPU, который обрабатывает исключения, не должен содержать блокирующих вызовов модуля `OpenCL`.

Но использовать затратные алгоритмы, или блокирующие вызовы как ввод с клавиатуры (`'Ошибка, всё равно продолжить? [Y/n]'`) вполне нормально:\
Обработчики вызываются только если было кинуто исключение. А исключения должны кидаться только в исключительных ситуациях, когда что-то пошло не так.

---

В паскале есть два типа блоков для обработки исключений, `try-except` - собственно обработчик,
а так же `try-finally` - позволяющий выполнять код не зависимо от того, было ли кинуто исключение.

В очередях `OpenCLABC` аналог последнего выглядит так:
```
## uses OpenCLABC;
function QErr(i: integer) := HPQ(()->raise new Exception(i.ToString));

Context.Default.SyncInvoke(
  ( QErr(1)+QErr(2) >= QErr(3)+QErr(4) >= QErr(5)+QErr(6) )
  .HandleWithoutRes(e->e.Message.Println<>nil)
);
```
В этом коде:
- Выполняется очередь 1, кидая исключение.
- Очередь 2 пропускается, из за ошибки в очереди 1.
- Затем стоит `>=`, работающий как `+`, но игнорирующий предыдущие исключения, поэтому очередь 3 выполняется.
- Очередь 4 пропускается, из за ошибки в очереди 3.
- Затем стоит ещё один `>=`, игнорирующий исключения всех предыдущих очередей, то есть 1 и 3, а значит очередь 5 тоже выполняется.
- Очередь 6 пропускается, из за ошибки в очереди 5.

Затем стоит обработчик, который съедает все исключения, но перед этим выводит их текст, показывая что выполнились очереди 1, 3 и 5.

---

Обычные `.ThenMarkerSignal` и `.ThenWaitFor` посылают/съедают сигнал маркера только если перед ними небыло ошибок.\
Это не всегда хорошо, потому что в случае ошибок будет сложно судить о количестве сигналов.

Как общее правило - `Wait`-очереди и маркеры лучше ставить после `>=`.
Но `HFQ(()->5) >= WaitFor(M)` вернёт результат последней очереди, то есть `nil`.

Поэтому существуют методы `.ThenFinallyMarkerSignal` и `.ThenFinallyWaitFor`.\
Эти методы так же как их варианты без `Finally` - возвращают то что вернула исходная очередь.\
Но в отличии от них - посылают/поглащают сигнал не зависимо от ошибок в очереди, из которой их создали.


