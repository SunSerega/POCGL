


Кроме самого выполнения очередей - им так же необходима инициализация и финализация.

---
### Инициализация

Для начала, перед тем как любая из под-очередей в `BeginInvoke` начнёт выполняться - необходимо инициалировать `Wait` очереди.
Иначе у ожидаемого маркера всегда будет шанс выполнится до того как ожидающая его очередь начнёт ожидать.

Инициализация `Wait` очередей заключается в обходе всего дерева под-очередей.
Для каждой `Wait`-группы (очередей, ожидающих общий маркер в общем `.BeginInvoke`),
создаётся счётчик выполнений ожидаемого маркера.

---
### Запуск очередей

Тоже заключается в обходе дерева под-очередей.

Но в этот раз очереди по которым прошлись - уже начали выполнятся, не ожидая окончания обхода всего дерева.

Как только этот обход закончен - метод `BeginInvoke` возвращает свой `CLTask` коду, вызвавшему его.

---
### Финализация

Заключается в чистке после выполнения - к примеру удалении всех созданных `cl_command_queue`.\
Так же тут собирается информация о всех исключениях, пойманных во время выполнения.

---

Основное преимущество объединения вызовов `BeginInvoke` состоит в различии следующих 2 случаев:
```
Context.Default.SyncInvoke(A+B);
```
```
Context.Default.SyncInvoke(A);
Context.Default.SyncInvoke(B);
```
В первом случае пока выполнится `A` - `B` уже, скорее всего, окажется полностью запущено.
А значит как только `A` закончит выполнятся - ход выполнения перейдёт на `B`.

А во втором случае - между окончанием выполнения `A` и запуском `B` - будет произведено множество проверок,
а так же выходов/входов в объёмные (что значит JIT их не инлайнит) подпрограммы, как конструктор `CLTask`.

Так же, в первом случае многие ресурсы, как объекты `OpenCL.cl_command_queue`,
выделенные при выполнении `A`, будут ещё раз использованы для выполнения `B`.

Да, всё это мелочи. Но нулевая задержка всегда лучше ненулевой.

---

Ну а когда всё же приходится вызывать 2 отдельных `BeginInvoke`, к примеру на 2 разных
контекстах - можно использовать `Wait` очереди, чтобы добится того же эффекта:
```
c2.BeginInvoke(WaitFor(A)+B);
c1.BeginInvoke(A);
```
Внутренние оптимизации `OpenCLABC` делают этот код практически не отличимым по скорости, от `BeginInvoke(A+B)`.

Единственное различие - время инициализации. Потому что `A` не запустится, пока не закончится вызов `c2.BeginInvoke`.


