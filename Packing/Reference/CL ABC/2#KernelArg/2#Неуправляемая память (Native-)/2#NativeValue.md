


OpenCL это неуправляемая библиотека. Обычно можно заставить управляеммые типы данных работать с ней.\
Но часто это приводит к дополнительным затратам производительности.\
И обычно не значит всегда - `MemorySegment.ReadValue`, принимающее запись `var`-параметром не может быть безопасным из за сборщика мусора
(и поэтому отсутствует).

Более прямым будет передача неуправляемых типов - указателей - без преобразований в подпрограммы модуля `OpenCL`.\
И эта возможность тоже существует, к примеру в виде `MemorySegment.WriteData`. Но такие указатели ещё более не_безопасны:\
Как минимум они требуют освобождения в `try-finally` чтобы избежать утечек памяти.
И защиты от дурака, не возволяющей записать значение типа `real` туда, где хранится `int64` - не существует.

Как что-то среднее между этими двумя вариантами - существует `NativeValue<T>`:\
Этот класс является обёрткой указателя на область памяти RAM.
```
## uses OpenCLABC;

// В конструктор необходимо передавать значение,
// потому что иначе неуправляемая память будет содержать мусор
// Но можно передать default, чтобы заполнить выделяемую память нулями
var nv := new NativeValue<integer>(default(integer));

nv.Value := 5; // Перезаписываем значение,
nv.Value.Println; // И читаем назад

// Напрямую получать доступ к области памяти,
// через свойство Pointer, не рекомендуется
Writeln(nv.Pointer);
// Кроме как передавать nv.Pointer^ var-параметром

nv.Dispose; // Освобождение памяти - вызывается и само при сборке мусора
```


