


Некоторые данные, передаваемые в программы на GPU, могут быть общими (для всех ядер) или просто не однотипными.\
Такие данные можно хранить в типе `MemorySegment`, представляющем область памяти GPU, для которой не определено ничего кроме размера.

Область памяти `MemorySegment` создаётся конструктором (`new MemorySegment(...)`).\
Основные конструкторы принимают размер области памяти и, опционально, контекст. Если контекст не указывается - память выделяется на `Context.Default`.

Далее, в неё можно записывать и читать данные практически любого типа записи, в любой точке:
```
## uses OpenCLABC;

var s := new MemorySegment(sizeof(int64));
// $ Это запись числа в 16-ичной СС
s.WriteValue&<int64>($FEDCBA9876543210);
// .ToString('X') преобразовывает число в строку в 16-ичной СС
s.GetValue&<int64>.ToString('X').Println;
// Можно читать кусок данных одного типа, как данные другого типа
s.GetValue&<integer>.ToString('X').Println;
// Читаем начиная с четвёртого байта
// Я сделал 16-ичный вывод чтобы было видно, изначальное число разрезало пополам
s.GetValue&<integer>(4).ToString('X').Println;
// Ну и никто не запретит прочитать как совершенно не совместимый тип данных
// Но в ответ вы получите мусорные данные
s.GetValue&<real>.Println;
```
То есть, вам самим придётся заботится о типе внутренних данных, работая с `MemorySegment`, но взамен вы полностью контролируете содержимое области памяти.

---

Память на GPU можно моментально освободить, вызвав метод `MemorySegment.Dispose`.\
Но вызывать его не обязательно, потому что этот метод вызывается автоматически во время сборки мусора.


