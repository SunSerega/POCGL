


Всё преимущество GPU над CPU состоит в выполнении одинаковой программы на рое из процессорных ядер.\
Каждое из этих ядер значительно медленнее ядер CPU, но используя весь рой вместе можно выполнять вычисления значительно быстрее.\
Но раз все ядра GPU выполняют одну и ту же программу - им обычно приходится передавать массив из однотипных данных.

Объект типа `CLArray<T>` (где `T` - почти любая запись) является массивом, содержимое которого хранится в памяти GPU, для более быстрого доступа из кода на GPU.

---

`CLArray<T>` создаётся конструктором:

```
## uses OpenCLABC;

// Массив для 10 элементов типа integer
var a1 := new CLArray<integer>(Context.Default, 10);
// Заполняем нулями, потому что при создании CLArray может содержать мусорные данные
a1.FillValue(0);
a1.GetArray.Println;

// Массив, в который при создании копируются данные из переданного массива
var a2 := new CLArray<byte>(Context.Default, new byte[](1,2,3,4,5,6,7));
a2.GetArray.Println;

// Массив, в который при создании копируется часть данных из переданного массива
// Точнее, копируется 2 элемента, начиная с элемента с индексом 3
var cpu_array := |0,1,2,3,4,5,6,7|;
var a3 := new CLArray<integer>(Context.Default, 3, 2, cpu_array);
a3.GetArray.Println;
```
Кроме того, объект контекста можно не передавать, тогда для выделения памяти будет автоматически выбран `Context.Default`.

---

Элементы этого массива, так же как у обычных массивов, можно читать через индексное свойство:
```
## uses OpenCLABC;
var a := new CLArray<integer>(Context.Default, |0,1,4,9,16|);
a[3].Println;
a[4] := 5;
a[4].Println;
```
Но имейте в виду - каждое обращение к индексному свойству - это новое выполнение неявной очереди, поэтому заполнять или читать такой массив по 1 элементу не эффективно.

Лучше всего использовать полноценные очереди. Но если вы выполняете какое-то одноразовое заполнение - можно, хотя бы, использовать свойство `.Section`:
```
## uses OpenCLABC;
var a := new CLArray<integer>(Context.Default, |0,1,4,9,16|);
// Заполняем элементы с индексами от 2 до 3 массивом |-1,-2|
a.Section[2..3] := |-1,-2|;
// Читаем и выводим элементы с 0 по 2 индексы как массив
a.Section[0..2].Println;
```

