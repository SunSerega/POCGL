


В исходных библиотеках обращение ко всем объектам идёт по "именам" (их так же можно назвать дескрипторами или id этих объектов).

Имена объектов - это числа (в OpenGL обычно на 32 бита, в OpenCL - зависит от битности системы).

Чтобы в подпрограмму, принимающую имена объектов определённого типа нельзя было передать имя
объекта неправильного типа - в н.у. модулях для каждого типа объектов описана подобная запись:
```
  gl_buffer = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    public static property Zero: gl_buffer read default(gl_buffer);
    public static property Size: integer read Marshal.SizeOf&<UInt32>;
    public function ToString: string; override := $'gl_buffer[{val}]';
  end;
```
Такой подход не замедляет готовую программу, но позволяет отловить некоторые ошибки на этапе компиляции.

Поле `.val` и конструктор публичны только на случай ошибки в перегрузках,
то есть если подпрограмма принемает неправильный тип имени.

В обычной ситуации - вы будете взаимодействовать с именами только 3 способами:

1. Объявление:
   ```
   var name: gl_buffer;
   var names: array of gl_buffer := new gl_buffer[5];
   ```

2. Передача исходным библиотекам:
   ```
   gl.CreateBuffers(1, name);
   gl.CreateBuffers(names.Length, names);
   ```

3. Использование статического свойства `.Zero`:
   ```
   procedure MyProc(buff: gl_buffer);
   begin
     ...
   end;
   ...
   MyProc(gl_buffer.Zero);
   // То же самое, но с лишними скобками:
   MyProc(default(gl_buffer));
   ```
   У настоящих объектов имя никогда не будет нулевым.
   
   Но бывает не мало случаев когда исходные библиотеки могут принимать нулевое имя.\
   К примеру, привязка шейдера с нулевым именем в OpenGL отменяет предыдущую привязку шейдера.


