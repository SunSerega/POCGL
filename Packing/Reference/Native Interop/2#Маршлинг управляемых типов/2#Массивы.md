


В .Net массивы хранят не только содержимое, но и данные о своём размере.

А в C++ вместо обычных массивов используется безформенная область памяти.\
При её выделении - в переменную записывается указатель `[0]` элемента.
А о том чтобы сохранить данные о размере этой области - должен позаботится программист.\
(на самом деле обычно в C++ используют обёртки, хранящие длину так же как .Net массивы. Но OpenGL.dll и OpenCL.dll это не касается)

---

Если вы видели старые коды с использованием OpenGL из какого то-из паскалей - наверняка видели что то такое:
```
glИмяПодпрограммы(@a[0]);
```
Но в PascalABC.Net так делать нельзя! Получение указателя на элемент массива моментально создаёт утечку памяти,
потому что компилятор, на всякий случай, вставляет полную блокировку массива в памяти, используя `GCHandle` с `GCHandleType.Pinned`.

Такая блокировка нужна, потому что иначе полученный указатель может в любой момент стать устаревшим.

Обычно `GCHandle` освобождают методом `.Free`. Но если позволить компилятору использовать
`GCHandle` - освобождение никогда не произойдёт, потому что компилятор не знает когда указатель станет не нужен.

---

Из очевидных вариантов - использовать `GCHandle` самостоятельно:
```
## uses System.Runtime.InteropServices;
var a := |1,2,3|;

var gc_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
try
  var ptr: ^integer := gc_hnd.AddrOfPinnedObject.ToPointer;
  Writeln(ptr);
  Writeln(ptr^);
finally
  // Освобождение в finally, чтобы оно произошло не зависимо ошибок при выполнении
  gc_hnd.Free;
end;
```
Но на него наложенны некоторые ограничения, связанные с тем как среда .Net работает с памятью:
```
uses System;

type
  r1 = record
    b1: byte;
    i: integer;
    b2: byte;
//    s: string[5];
  end;
  
function Offset(p1,p2: pointer) := int64(p2)-int64(p1);

begin
  var a: r1;
  Offset(@a,@a.b1).Println;
  Offset(@a,@a.i ).Println;
  Offset(@a,@a.b2).Println;
//  Offset(@a,@a.s).Println;
end.
```
Пока запись содержит только размерные поля - их хранит в памяти в том порядке, которые описали вы.\
Ну и в данном случае если бы `i` хранилось сразу за `b1` - его адрес не делился бы поровну на `sizeof(integer)=4`,
а значит процессору было бы неудобно читать и записывать `i`, поэтому его отодвигает на 3 байта от `b1`.

Но если раскомментировать объявление поля `s`, являющегося строкой (то есть имеющего ссылочный тип),
среда .Net решает что эта запись не может быть передана в неуправляемый код как есть,
(потому что каждая реализация .Net может по-своему решать как хранить содержимое классов)
а значит можно спокойно перетасовать поля так, чтобы плотнее их упаковать.

Эта запись всё ещё может быть передана параметром в неуправляемый код, даже `var`-параметром.
Но в таком случае данные из неё копирует в отдельную область памяти, так чтобы в этой области
поля были в том порядке, в котором их описали в записи. Это копирование можно симулировать вручную:
```
uses System;
uses System.Runtime.InteropServices;

type
  // Чтобы класс был форматированным, то есть совместимым
  // с неуправляемым кодом, надо или
  // LayoutKind.Sequential или LayoutKind.Explicit
  [StructLayout(LayoutKind.Sequential)]
  MyFormattedClass = class
    b1: byte := $BA;
    i: integer := $87654321;
    b2: byte := $DC;
  end;
  
  // LayoutKind.Sequential влияет на StructureToPtr,
  // но не на то как хранятся данные в переменной "a"
  // CharSet.Unicode указывает как должен работать UnmanagedType.ByValTStr
  [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
  r1 = record
    b1: byte := $AB;
    i: integer := $12345678;
    b2: byte := $CD;
    o := new MyFormattedClass;
    
    // Явно указываем как неуправляемый код
    // должен видеть массив и строку:
    
    // Из массива берём первые 2 значения и сохраняем в саму запись
    // В массиве должно быть хотя бы 2 элемента при вызове StructureToPtr
    [MarshalAs(UnmanagedType.ByValArray, SizeConst=2)]
    arr := new byte[]($EF,$FE);
    // А из строки берём максимум 2 первых символа
    // То есть не больше двух, в строке может быть и меньше
    // В конце всегда добавляется нулевой символ, чтобы
    // указать неуправляемому коду где строка заканчивается
    [MarshalAs(UnmanagedType.ByValTStr, SizeConst=2+1)]
    s := char($CC11)+char($CC22);
    
  end;
  
function Offset(p1,p2: pointer) := int64(p2)-int64(p1);

begin
  var a: r1;
  
  'Содержимое r1:'.Println;
  Writeln('Начало: ',@a);
  Offset(@a,@a.b1).Println;
  Offset(@a,@a.i ).Println;
  Offset(@a,@a.b2).Println;
  Offset(@a,@a.o).Println;
  
  'Содержимое класса:'.Println;
  // Будем надеятся что содержимое класса не переместит пока выводим
  // Конечно, в реальной ситуации такая надежда не годится
  var po := PPointer(pointer(@a.o))^;
  Writeln('Начало: ',po);
  Offset(po,@a.o.b1).Println;
  Offset(po,@a.o.i ).Println;
  Offset(po,@a.o.b2).Println;
  
  var sz := Marshal.SizeOf&<r1>;
  var ptr := Marshal.AllocHGlobal(sz);
  // Делаем неуправляемую версию этой записи
  Marshal.StructureToPtr(a, ptr, false);
  
  'Содержимое неуправляемой копии:'.Println;
  for var i := 1 to sz do
  begin
    // X2 указывает 16-ричный вывод, по 2 символа на каждое значение
    PByte((ptr+(i-1)).ToPointer)^.ToString('X2').Print;
    if i.Divs(8) then Println;
  end;
  
end.
```
Поля записи `r1` опять перемешиваются, даже с явным указанием `LayoutKind.Sequential`,
потому что эта запись всё равно не может использоваться неуправляемым кодом как-есть.

В то же время поля класса оказались в том порядке, как мы указали. Потому что, на самом деле,
этот класс можно передавать в неуправляемый код отдельно от `r1`. Такое объявление:
```
procedure p1(o: MyFormattedClass); external 'some_lib.dll';
```
Будет эквивалентно:
```
procedure p1(var o: SomeRecord); external 'some_lib.dll';
```
Где `SomeRecord` - запись с таким же полями. Но есть одно но: первое объявление `p1` будет блокировать
содержимое `MyFormattedClass` с помощью `GCHandle`, тратя на это немного времени процессора.

Но если бы в `MyFormattedClass` были ссылочные поля - все его поля перемешались бы так же, как и поля `r1`.

Далее, вызывается `StructureToPtr`, копирующее содержимое записи в область неуправляемой памяти.\
И в данном случае, то что сохраняется в неуправляемую память это не копия содержимого переменной `a`,
а совершенно новое значение, в которое влили копии содержимого `MyFormattedClass`, массива и строки,
не смотря на то что оригиналы этих значений хранились в разных частях оперативной памяти.

Кроме того, в данном примере не показано, но есть некоторые типы записей, как `boolean`, `char` и `DateTime`,
которые можно по-разному интерпретировать при передаче в неуправляемый код.
Их тоже преобразовывает при копировании в неуправляемую память.

Возвращаясь к `GCHandle`: Он принципиально используется не для копирования, а для закрепления в памяти существующего содержимого.\
Поэтому когда он встречает запись, которую надо преобразовывать при передаче в неуправляемый код,
`GCHandle` наотрез отказывается загреплять её с `GCHandleType.Pinned`.\
(но в качестве исключения разрешает закреплять некоторые особые случаи, как массив символов)

И это хорошо - это защита от дурака, потому что случаи когда запись,
поля которой среда .Net могла перетасовать, передают в неуправляемый код как есть - заведомо неправильны.

---

Но с другой стороны - эта проверка типов происходит во время выполнения программы.
А если надо делать много быстрых неуправляемых вызовов - это плохо.\
Поэтому н.у модули используют другой способ:

Как видно в тестах на странице выше - массив можно заблокировать в памяти без `GCHandle`,
если передавать его параметром-массивом или `var`-параметром.

И, в отличии от `GCHandle`, такой способ будет работать с массивами с любым размерным типом элементов.\
Это значит что следить за адекватностью содержимого записи должны вы сами.\
Но в то же время это значит что вы сами решаете, какие проверки делать.

К примеру, если имеем процедуру `p1` из неуправляемой .dll, принимающую массив из двух чисел типа `integer`:
```
var a := new integer[5](...);
p1(a); // Передача массива целиком
p1(a[3]); // Передача [3] элемента var-параметром
```
Из первого вызова `p1` возьмёт только элементы `a[0]` и `a[1]`,
потому что `p1` по условию требует только два элемента.

Из второго вызова `p1` возьмёт `a[3]` и `a[4]`, потому что в неуправляемом коде
нет разницы между указателем на один из элементов и указателем на начало массива.

Но, обратите внимание, на случай, когда тип требует особого преобразования.\
Для примера возьмём параметр, который объявили как `var b: boolean` и передали в него элемент массива:

`boolean` занимает 1 байт в .Net, но по-умолчанию преобразовывается в `BOOL` из C++, занимающий 4 байта.\
Поэтому, в данном случае, среда .Net выделит новую неуправляемую область памяти в 4 байта
и передаст её неуправляемому коду. А остальные элементы массива неуправляемому коду не достанутся.

---

Обычнно эти два способа передать массив в неуправляемый код - всё что вам понадобится.

Но, допустим, вы хотите написать подпрограмму для создания OpenGL буфера из массива векторов.
Можно сделать перегрузку для каждого типа вектора, но тогда получится очень много дублей кода.
Этого довольно просто избежать, используя шаблоны:
```
// Это не настоящая подпрограмма, а только пример
procedure FillBuffer(var data: byte);
external 'some.dll';

// external подпрограммы не могут быть шаблонными, поэтому нужна ещё одна промежуточная перегрузка
// "where T: record;" делает так, что FillBuffer будет можно вызвать только для размерных типов T
procedure FillBuffer<T>(var data: T); where T: record;
begin
  // Компилятор развернёт это в "FillBuffer(data)"
  // То есть никакие преобразования в .exe не попадут
  // Но указатели всё равно нужны, чтобы компилятор не ругался на несовместимость типов
  FillBuffer(PByte(pointer(@data))^);
end;

procedure FillBuffer<T>(data: array of T); where T: record;
begin
  // В неуправляемом коде нет разницы между массивом и адресом начала его содержимого
  // Поэтому можно передавать массив в виде [0] элемента-var-параметра.
  FillBuffer(data[0]);
end;
```
Но это для одномерных массивов. А что насчёт многомерных?

Сделать перегрузку для заданного кол-ва измерений не сложно:
```
procedure FillBuffer<T>(data: array[,] of T); where T: record;
begin
  // Многомерные массивы расположены в памяти как одномерные,
  // Но обращение к элементам идёт по нескольким индексам
  // Элемент [0,0,...] в любом случае будет в самом начале,
  // Поэтому код одинаковый для любого кол-ва измерений
  FillBuffer(data[0,0]);
end;
```
Но, опять же, получается так, что для каждой размерности - приходится добавлять перегрузку.

И, к сожалению, в данном случае я не знаю красивого способа обхода.\
Лучшее что я могу придумать - создать `Dictionary<integer, Action<System.Array>>`,
где ключи - размерности массивов, а значения - делегаты, работающие с соответствующей размерностью.\
Когда происходит вызов с массивом определённой размерности - создавать новый делегат
в виде динамичного метода, с помощью `System.Reflection.Emit`, если его ещё нет в словаре.


