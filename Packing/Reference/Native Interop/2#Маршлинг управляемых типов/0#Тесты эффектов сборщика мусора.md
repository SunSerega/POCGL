


Кроме удаления неиспользуемых экземпляров классов, сборщик мусора так же может произвольно
перемещать используемые объекты, более плотно упаковая их в памяти.

И он прекрасно справляется с тем, чтобы сделать эти перемещения незаметными, в обычных ситуациях.
Но как только речь находит об указателях и неуправляемом коде - начинаются проблемы.
Чтобы избежать их, надо очень хорошо понимать как работает сборщик мусора.

:::spoiler { summary="Страницы в данной папке опираются на результаты следующего теста:" hidden=true }

```
uses System;
uses System.Runtime.InteropServices;
// Отдельный разбор:
// http://forum.mmcs.sfedu.ru/t/testy-raboty-sborshhika-musora

function get_addr(a: array of integer) := '$'+Marshal.UnsafeAddrOfPinnedArrayElement(a,0).ToString('X');

// Заполняем память кучей разных мусорных объектов,
// которые никогда не удалятся, чтобы
// сборщик мусора засуетился когда его тыкнут
// Не знаю почему надо именно массив массивов + массив их адресов
var ___a := ArrGen(10000, i->|0|);
var ___p := ___a.ConvertAll(get_addr);

type
  punch_gc_callback = procedure(ptr: pointer);
  
function ptr_adr<T>(var a: T) := new IntPtr(@a);

{$region Safe}

function copy_arr(var a: integer; punch_gc: punch_gc_callback): IntPtr;
external 'Native\x64\Release\Native.dll';
function copy_arr(var a: byte; punch_gc: punch_gc_callback): IntPtr;
external 'Native\x64\Release\Native.dll';

function copy_arr([MarshalAs(UnmanagedType.LPArray)] a: array of integer; punch_gc: punch_gc_callback): IntPtr;
external 'Native\x64\Release\Native.dll';

function copy_arr_recall2(a: array of integer; punch_gc: punch_gc_callback): IntPtr :=
copy_arr(a, punch_gc);

function copy_arr_recall3(var a: integer; punch_gc: punch_gc_callback): IntPtr :=
copy_arr(a, punch_gc);

function copy_arr_recall5(var a: integer; punch_gc: punch_gc_callback): IntPtr :=
copy_arr(PByte(pointer(@a))^, punch_gc);

{$endregion Safe}

{$region Unsafe}

function copy_arr(a: IntPtr; punch_gc: punch_gc_callback): IntPtr;
external 'Native\x64\Release\Native.dll';
function copy_arr(a: ^integer; punch_gc: punch_gc_callback): IntPtr;
external 'Native\x64\Release\Native.dll';

function copy_arr_recall1(var a: integer; punch_gc: punch_gc_callback): IntPtr :=
copy_arr(@a, punch_gc);

function copy_arr_recall4_helper(a: ^integer; punch_gc: punch_gc_callback): IntPtr;
begin
  punch_gc(a);
  Result := copy_arr(a^, ptr->begin end); // Второй раз вызывать punch_gc и вывод - ни к чему, всё ломается уже на предыдущей строчке
end;
function copy_arr_recall4(var a: integer; punch_gc: punch_gc_callback): IntPtr :=
copy_arr_recall4_helper(@a, punch_gc);

function get_int(punch_gc: punch_gc_callback; var a: integer): integer;
begin
  punch_gc(@a);
  Result := 4;
end;
function copy_arr_recall6(var a: integer; punch_gc: punch_gc_callback): IntPtr :=
copy_arr(PByte(pointer(IntPtr(pointer(@a))+get_int(punch_gc, a)))^, ptr->begin end);

{$endregion Unsafe}

procedure punch_gc := GC.Collect;

begin
  var a := Arr(1,2,3,4,5,6);
  var b := Arr(1,2,3,4,5);
  Console.WriteLine('begin');
  Console.WriteLine(get_addr(a));
  Console.WriteLine(get_addr(b));
  
  // punch_gc работает только 1 раз, эти строчки только чтобы протестировать, работает ли он у вас вообще
//  punch_gc;
//  Console.WriteLine('after first gc');
//  Console.WriteLine(get_addr(a));
//  Console.WriteLine(get_addr(b));
  
  {$region заголовки вызова copy_arr}
  
  // Безопасно
//  var ptr := copy_arr(a,              // Передавать как массив безопасно
//  var ptr := copy_arr(a[0],           // Передавать элемент массива var-параметром безопасно
//  var ptr := copy_arr(a[1],           // И это касается не только элемента [0]
//  var ptr := copy_arr_recall2(a,      // Безопасно, потому что с точки зрения copy_arr_recall2 ситуация та же что "copy_arr(a,"
//  var ptr := copy_arr_recall3(a[0],   // И var-параметры тоже безопасны через промежуточные подпрограммы
//  var ptr := copy_arr_recall5(a[0],   // Тут указатели не попадают в готовый .exe, они только чтобы успокоить компилятор, поэтому безопасно
  
  // НЕ безопасно
//  var ptr := copy_arr(Marshal.UnsafeAddrOfPinnedArrayElement(a,0), // GC не следит за содержимым IntPtr
//  var ptr := copy_arr(ptr_adr(a[0]),  // И за другими формами указателей тоже
//  var ptr := copy_arr_recall1(a[0],   // Проблема не в передаче адреса возвращаемым значением из ptr_adr в copy_arr
//  var ptr := copy_arr_recall4(a[0],   // Кроме того, проблема вообще не в неуправляемом коде, в управляемом тоже воспроизводится
//  var ptr := copy_arr_recall6(a[0],   // В отличии от recall5 - тут указатели попадают в готовый .exe, поэтому небезопасно
  
  {$endregion заголовки вызова copy_arr}
  
  ptr->
  begin
    Console.WriteLine('before gc');
    Console.WriteLine(get_addr(a));
    Console.WriteLine('$'+IntPtr(ptr).ToString('X'));
    Console.WriteLine(get_addr(b));
    
    // "b" используется только чтобы видеть когда punch_gc успешно сработал
    // (хотя всегда может переместить только "a", или только "b", поэтому не 100% показатель)
    // Но главное тут - "ptr" это то, что хранит неуправляемый код, а "get_addr(a)" показывает текущий адрес "a"
    // Если "get_addr(a)" изменился после вызова "punch_gc", а "ptr" остался тем же - значит "a" не заблокирован
    punch_gc;
    Console.WriteLine('after gc');
    Console.WriteLine(get_addr(a));
    Console.WriteLine('$'+IntPtr(ptr).ToString('X'));
    Console.WriteLine(get_addr(b));
  end);
  
  Console.WriteLine('end');
  Console.WriteLine(get_addr(a));
  Console.WriteLine(get_addr(b));
  
//  punch_gc;
//  Console.WriteLine('after last gc');
//  Console.WriteLine(get_addr(a));
//  Console.WriteLine(get_addr(b));
  
  // Показывает эффекты НЕ безопасного вызова
  // Точнее если неуправляемый код потеряет адрес массива, то тут
  // может быть мусор или ошибка доступа, правда я их ни разу не получил
  var res := new byte[20];
  Marshal.Copy(ptr,res,0,20);
  res.Println;
end.
```
`Dll1.dll` должна быть неуправляемой библиотекой, содержащей следующую функцию (это C++):
```
extern "C" __declspec(dllexport) BYTE* copy_arr(int* a, void (*punch_gc)(void*))
{
    BYTE* res = new BYTE[20]; // Выделяем 20 байт неуправляемой памяти
    punch_gc(a); // Вызываем ту подпрограмму, чей адрес сюда передали
    memcpy(res, a, 20); // Копируем 20 байт из "a" в "res"
    return res; // Плохо что неуправляемая память не освобождается, но в этом тесте не важно
}
```
Подробнее о параметрах:

1. `a` принимает указатель на `integer`, что в C++ так же может являеться массивом с элементами типа `integer`;

1. `punch_gc` принемает адрес подпрограммы, принемающей `void*` (безтиповый указатель)
и возвращающей `void` (ничего не возвращающей, то есть это процедура);

1. Ну и возвращаемое значение - `BYTE*`. Так же как `a`, вообще указатель, но в данном случае массив.

Почитать более подробный разбор и скачать архив с упакованной библиотекой можно [тут](http://forum.mmcs.sfedu.ru/t/testy-raboty-sborshhika-musora).

Пожалуйста, попробуйте поэксперементировать с этим кодом сами. И если найдёте
что-то интересное - обязательно напишите в issue. В этом деле много тестов не бывает.

:::

### В кратце

Вся безопасность зависит только от объявления параметра `external`-подпрограммы,
через который передаётся управляемый объект. Если параметр принимает:

- Любой размерный тип (то есть запись):\
При передаче в подпрограмму размерное значение копируется.
Сборщик мусора тут не при чём. Поэтому передача записи всегда безопасна.

- Массив или `var`-параметр:\
Пока вызов неуправляемой подпрограммы не завершится - сборщик мусора НЕ будет передвигать объект в памяти.\
Но обратите внимание, есть неуправляемые подпрограммы, использующие переданные вами данные после завершения вызова `external`-подпрограммы.\
К примеру `gl.Uniform1iv` скопирует данные из вашего массива в память GPU, поэтому он безопасен.\
Но `cl.CreateBuffer` в который передали `MemFlags.MEM_USE_HOST_PTR` создаст буфер, который
будет ссылаться на ваш массив. В таком случае надо использовать `GCHandle` с `GCHandleType.Pinned`, чтобы массив не двигался в памяти.\
Поэтому очень внимательно читайте документацию того, что вызываете.

- Указатель в любом виде (типизированный, безтиповый или даже обёрнутый в запись вроде `IntPtr`):\
Передавать адрес содержимого класса НЕ безопасно.\
Можно передавать только адрес локальной переменной, которая **не** была захвачена лямбдой.\
Ну или адрес заведомо неуправляемого куска памяти, к примеру выделенного с помощью `Marshal.AllocHGlobal`.

---

### Другие ОС

Так же протестировал `mono` (версия .Net для линукса) на arch-linux и Windows10.\
Среда выполнения `mono` блокирует управляемые объекта не зависимо от типа параметра,
даже если `external` подпрограмма принимает указатель или `IntPtr`.

То есть при запуске из под `mono` волноваться о блокировке объектов надо только в случае,
если неуправляемый код будет использовать данные этого объекта после выхода из вызова `external`-подпрограммы.

Ну и нельзя забывать о случае, когда данные объекта имеют сложный тип, требующий маршлинга
перед передачей в неуправляемый код. Подробнее <a path="Массивы">на странице ниже</a>.


