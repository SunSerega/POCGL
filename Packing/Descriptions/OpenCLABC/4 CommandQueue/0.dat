


# CommandQueue:Common
# CommandQueueBase
Представляет очередь команд, в основном выполняемых на GPU

# CommandQueueNil
%CommandQueue:Common%
Такая очередь всегда возвращает nil

# CommandQueue<T>
%CommandQueue:Common%
Такая очередь всегда возвращает значение типа T



# ITypedCQUser
# ITypedCQConverter<TRes>
Представляет интерфейс типа, содержащего отдельные алгоритмы обработки, очереди без- и с возвращаемым значением

# ITypedCQUser.Use<T>(CommandQueue<T>)
# ITypedCQConverter<TRes>.Convert<T>(CommandQueue<T>)
Вызывается если у очереди есть возвращаемое значение
# ITypedCQUser.UseNil(CommandQueueNil)
# ITypedCQConverter<TRes>.ConvertNil(CommandQueueNil)
Вызывается если у очереди нет возвращаемого значения

# CommandQueueBase.UseTyped(ITypedCQUser)
# CommandQueueBase.ConvertTyped<TRes>(ITypedCQConverter<TRes>)
Проверяет, какой тип результата у данной очереди
Передаёт результат указанному объекту

# CommandQueue<T>.UseTyped(ITypedCQUser)
# CommandQueue<T>.ConvertTyped<TRes>(ITypedCQConverter<TRes>)
# CommandQueueNil.UseTyped(ITypedCQUser)
# CommandQueueNil.ConvertTyped<TRes>(ITypedCQConverter<TRes>)
--



# CommandQueueBase.Cast<T>
Если данная очередь проходит по условию "... is CommandQueue<T>" - возвращает себя же
Иначе возвращает очередь-обёртку, выполняющую "res := T(res)", где res - результат данной очереди
# CommandQueueNil.Cast<T>
Создаёт константную очередь, выполняющую данную и возвращающую T(nil)
Для этого T должен быть ссылочным



# CommandQueueNil.DiscardResult
# CQ:DiscardResult
Возвращает данную очередь
# CommandQueueBase.DiscardResult
# CommandQueue<T>.DiscardResult
%CQ:DiscardResult% но без результата



# CQ:ThenUseConvert:When:[%when:,Quick%]
%DelegateExec:{%when?Background:Quick%}% {%when?начинающуюся на ".ThenQuick...":%}

# CQ:Then[%when:,Quick%]ConvertDef
Создаёт очередь, которая выполнит данную
А затем выполнит на CPU функцию f, используя результат данной очереди

# CommandQueue<T>.Then[%when:,Quick%]Convert<TOtp>(T->TOtp)
%CQ:Then{%when%}ConvertDef%
%CQ:ThenUseConvert:When:{%when%}%
# CommandQueue<T>.Then[%when:,Quick%]Convert<TOtp>((T, Context)->TOtp)
%CQ:Then{%when%}ConvertDef% и контекст выполнения
%CQ:ThenUseConvert:When:{%when%}%

# CQ:Then[%when:,Quick%]UseDef
Создаёт очередь, которая выполнит данную и вернёт её результат
Но перед этим выполнит на CPU процедуру p, используя полученный результат

# CommandQueue<T>.Then[%when:,Quick%]Use(T->())
%CQ:Then{%when%}UseDef%
%CQ:ThenUseConvert:When:{%when%}%
# CommandQueue<T>.Then[%when:,Quick%]Use((T, Context)->())
%CQ:Then{%when%}UseDef% и контекст выполнения
%CQ:ThenUseConvert:When:{%when%}%



# CommandQueue[%Base,Nil,<T>%].Multiusable
Создаёт функцию, вызывая которую можно создать любое кол-во очередей-удлинителей для данной очереди
Подробнее в справке: "Очередь>>Создание очередей>>Множественное использование очереди"



# CQ:ThenSaveRes
В конце выполнения созданная очередь возвращает то, что вернула данная

# CQ:FinallyMode:

# CQ:FinallyMode:Finally
не зависимо от исключений при выполнении данной очереди



# CommandQueueNil.Then[%finally:,Finally%]MarkerSignal
# CommandQueue<T>.Then[%finally:,Finally%]MarkerSignal
Создаёт очередь, сначала выполняющую данную, а затем вызывающую свой .SendSignal %CQ:FinallyMode:{%finally%}%
При передаче в Wait-очереди, полученная очередь превращается в маркер
%CQ:ThenSaveRes%

# CommandQueue<T>.Then[%finally:,Finally%]WaitFor(WaitMarker)
Создаёт очередь, сначала выполняющую данную, а затем ожидающую сигнала от указанного маркера %CQ:FinallyMode:{%finally%}%
%CQ:ThenSaveRes%



# CQ:Handle
Создаёт очередь, сначала выполняющую данную, а затем обрабатывающую кинутые в ней исключения

# CommandQueueBase.HandleWithoutRes<TException>(TException->boolean)
# CommandQueueBase.HandleWithoutRes(Exception->boolean)
%CQ:Handle%
Созданная очередь возвращает nil %CQ:FinallyMode:Finally%

# CommandQueue<T>.HandleDefaultRes<TException>(TException->boolean, T)
# CommandQueue<T>.HandleDefaultRes(Exception->boolean, T)
%CQ:Handle%
%CQ:ThenSaveRes%, если исключений небыло и указанное значение если обработчик был успешно выполнен

# CommandQueue<T>.HandleReplaceRes(List<Exception> -> T)
%CQ:Handle%
Для того чтоб пометить исключение обработанным - его надо удалить из полученного списка
Возвращаемое значение обработчика указывает на что надо заменить возвращаемое значение данной очереди, если обработчик был успешно выполнен



# CommandQueueBase.ToString
%CQ:ToString%

# CommandQueue[%Base,Nil,<T>%].Print[%ln:,ln%]
%CQ:Print{%ln%}%


