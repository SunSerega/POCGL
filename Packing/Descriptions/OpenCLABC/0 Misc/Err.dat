


# OpenCLException
Класс исключений из OpenCL



# Err:NoParamCtor
Был вызван не_применимый конструктор без параметров... Обратитесь к разработчику OpenCLABC



# Err:CLMemory:WrongNtvType
Неправильный тип неуправляемого объекта памяти. Ожидалось [MEM_OBJECT_BUFFER], а не [{t}]



# Err:Device:SplitCUCount
Количество ядер должно быть положительным числом, а не {CUCount}

# Err:Device:SplitNotSupported
Данный режим .Split не поддерживается выбранным устройством



# Err:Context:WrongMainDvc
main_dvc должен быть в списке устройств контекста



# Err:ProgramCode:BuildFail
Ошибка компиляции OpenCL программы:



#Err:NativeArray:SliceCopy:WriteSize
Массив присваиваемый свойству NativeArray<>.SliceCopy должен иметь размер ({value.Length}), равный размеру среза ({expected_len})



# Err:Blittable:Main
Значения типа {TypeToTypeName(t)} нельзя {source_name}

# Err:Blittable:Blame
%Err:Blittable:Main%, потому что он содержит тип {TypeToTypeName(blame)}

# Err:Blittable:Source:NativeValue
использовать как тип значения NativeValue<>

# Err:Blittable:Source:NativeArray
использовать как элементы NativeArray<>

# Err:Blittable:Source:CLValue
использовать как тип значения CLValue<>

# Err:Blittable:Source:CLArray
использовать как элементы CLArray<>

# Err:Blittable:Source:KernelArg
передавать в качестве параметров kernel''а

# Err:Blittable:Source:CLMemory:WriteValue
# Err:Blittable:Source:CLMemory:WriteValueQ
# Err:Blittable:Source:CLMemory:WriteArray1AutoSize
# Err:Blittable:Source:CLMemory:WriteArray2AutoSize
# Err:Blittable:Source:CLMemory:WriteArray3AutoSize
# Err:Blittable:Source:CLMemory:WriteArray1
# Err:Blittable:Source:CLMemory:WriteArray2
# Err:Blittable:Source:CLMemory:WriteArray3
# Err:Blittable:Source:CLMemory:WriteNativeValue
# Err:Blittable:Source:CLMemory:WriteNativeArrayAutoSize
# Err:Blittable:Source:CLMemory:WriteNativeArray
# Err:Blittable:Source:CLMemory:FillValueAutoSize
# Err:Blittable:Source:CLMemory:FillValue
# Err:Blittable:Source:CLMemory:FillValueAutoSizeQ
# Err:Blittable:Source:CLMemory:FillValueQ
# Err:Blittable:Source:CLMemory:FillArray1AutoSize
# Err:Blittable:Source:CLMemory:FillArray2AutoSize
# Err:Blittable:Source:CLMemory:FillArray3AutoSize
# Err:Blittable:Source:CLMemory:FillArray1
# Err:Blittable:Source:CLMemory:FillArray2
# Err:Blittable:Source:CLMemory:FillArray3
# Err:Blittable:Source:CLMemory:FillArraySegmentAutoSize
# Err:Blittable:Source:CLMemory:FillArraySegment
# Err:Blittable:Source:CLMemory:FillNativeValueAutoSize
# Err:Blittable:Source:CLMemory:FillNativeValue
# Err:Blittable:Source:CLMemory:FillNativeArrayAutoSize
# Err:Blittable:Source:CLMemory:FillNativeArray
записывать в область памяти OpenCL

# Err:Blittable:Source:CLMemory:ReadArray1AutoSize
# Err:Blittable:Source:CLMemory:ReadArray2AutoSize
# Err:Blittable:Source:CLMemory:ReadArray3AutoSize
# Err:Blittable:Source:CLMemory:ReadArray1
# Err:Blittable:Source:CLMemory:ReadArray2
# Err:Blittable:Source:CLMemory:ReadArray3
# Err:Blittable:Source:CLMemory:ReadNativeValue
# Err:Blittable:Source:CLMemory:ReadNativeArrayAutoSize
# Err:Blittable:Source:CLMemory:ReadNativeArray
# Err:Blittable:Source:CLMemory:GetValue
# Err:Blittable:Source:CLMemory:GetArrayAutoSize
# Err:Blittable:Source:CLMemory:GetArray
# Err:Blittable:Source:CLMemory:GetArray2
# Err:Blittable:Source:CLMemory:GetArray3
читать из области памяти OpenCL



# Err:Blittable:Source:QueueResPtr
использовать в некоторой внутренней ситуации (напишите об этом в issue)



# Err:CLTask:
При выполнении очереди было вызвано {err_lst.Count} исключений. Используйте try чтоб получить больше информации



# Err:Cast:nil->T
.Cast не может преобразовывать nil в {TypeToTypeName(typeof(T))}

# Err:Cast:TInp->TRes
.Cast не может преобразовывать {TypeToTypeName(typeof(TInp))} в {TypeToTypeName(typeof(TRes))}



# Err:FlattenQueueArray:InpEmpty
Функции CombineSyncQueue/CombineAsyncQueue не могут принимать 0 очередей

# Err:WaitCombine:InpEmpty
Количество комбинируемых маркеров должно быть положительным

# Err:WaitMarkerCombination.ConvertToQBase
Преобразовывать комбинацию маркеров в очередь нельзя. Возможно вы забыли написать WaitFor?


