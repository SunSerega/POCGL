# CLArray<T>
Представляет массив записей, содержимое которого хранится на устройстве OpenCL (обычно GPU)

# CLArray<T>.ByteSize
Возвращает размер области памяти, занимаемой массивом, в байтах

# CLArray<T>.CopyFrom(CommandQueue<CLArray<&T>>)
# CLArrayCCQ<T>.ThenCopyFrom(CommandQueue<CLArray<&T>>)
Копирует элементы из a в данный массив
Если у массивов разный размер - копируется кол-во элементов меньшего массива

# CLArray<T>.CopyFrom(CommandQueue<CLArray<&T>>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenCopyFrom(CommandQueue<CLArray<&T>>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Копирует элементы из a в данный массив
from_ind указывает индекс в массиве, из которого копируют
to_ind указывает индекс в массиве, в который копируют
len указывает кол-во копируемых элементов

# CLArray<T>.CopyFrom(CommandQueue<CLMemory>)
# CLArrayCCQ<T>.ThenCopyFrom(CommandQueue<CLMemory>)
Копирует элементы из mem в данный массив
Копируется максимальное кол-во байт, не выходящее за границы данного массива и mem

# CLArray<T>.CopyFrom(CommandQueue<CLMemory>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenCopyFrom(CommandQueue<CLMemory>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Копирует элементы из mem в данный массив
mem_offset указывает отступ от начала области памяти, в байтах
ind указывает индекс первого элемента данного массива
len указывает кол-во копируемых элементов

# CLArray<T>.CopyFrom(CommandQueue<CLValue<&T>>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenCopyFrom(CommandQueue<CLValue<&T>>, CommandQueue<integer>)
Копирует val в элемент данного массива с индексом ind

# CLArray<T>.CopyTo(CommandQueue<CLArray<&T>>)
# CLArrayCCQ<T>.ThenCopyTo(CommandQueue<CLArray<&T>>)
Копирует элементы из данного массива в a
Если у массивов разный размер - копируется кол-во элементов меньшего массива

# CLArray<T>.CopyTo(CommandQueue<CLArray<&T>>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenCopyTo(CommandQueue<CLArray<&T>>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Копирует элементы из данного массива в a
from_ind указывает индекс в массиве, из которого копируют
to_ind указывает индекс в массиве, в который копируют
len указывает кол-во копируемых элементов

# CLArray<T>.CopyTo(CommandQueue<CLMemory>)
# CLArrayCCQ<T>.ThenCopyTo(CommandQueue<CLMemory>)
Копирует элементы из данного массива в mem
Копируется максимальное кол-во байт, не выходящее за границы данного массива и mem

# CLArray<T>.CopyTo(CommandQueue<CLMemory>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenCopyTo(CommandQueue<CLMemory>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Копирует элементы из данного массива в mem
mem_offset указывает отступ от начала области памяти, в байтах
ind указывает индекс первого элемента данного массива
len указывает кол-во копируемых элементов

# CLArray<T>.CopyTo(CommandQueue<CLValue<&T>>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenCopyTo(CommandQueue<CLValue<&T>>, CommandQueue<integer>)
Копирует элемент с индексом ind из данного массива в val

# CLArray<T>.Dispose
# CLMemory.Dispose
# CLValue<T>.Dispose
Позволяет OpenCL удалить неуправляемый объект
Данный метод вызывается автоматически во время сборки мусора, если объект ещё не удалён

# CLArray<T>.Equals(object)
# CLMemory.Equals(object)
# CLValue<T>.Equals(object)
# CommandQueue<T>.ConvertTyped<TRes>(ITypedCQConverter<TRes>)
# CommandQueue<T>.UseTyped(ITypedCQUser)
# CommandQueueNil.ConvertTyped<TRes>(ITypedCQConverter<TRes>)
# CommandQueueNil.UseTyped(ITypedCQUser)
--

# CLArray<T>.FillArray(CommandQueue<array of &T>)
# CLArray<T>.FillArray2(CommandQueue<array[,] of &T>)
# CLArray<T>.FillArray3(CommandQueue<array[,,] of &T>)
# CLArray<T>.FillNativeArray(CommandQueue<NativeArray<&T>>)
# CLArrayCCQ<T>.ThenFillArray(CommandQueue<array of &T>)
# CLArrayCCQ<T>.ThenFillArray2(CommandQueue<array[,] of &T>)
# CLArrayCCQ<T>.ThenFillArray3(CommandQueue<array[,,] of &T>)
# CLArrayCCQ<T>.ThenFillNativeArray(CommandQueue<NativeArray<&T>>)
Заполняет данный массив OpenCL копиями указанного массива RAM

# CLArray<T>.FillArray(CommandQueue<array of &T>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenFillArray(CommandQueue<array of &T>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Заполняет fill_len элементов данного массива OpenCL копиями участков из pattern_len элементов указанного массива
ind указывает индекс первого элемента данного массива OpenCL
a_ind(-ы) указывают индекс первого элемента в массиве RAM

# CLArray<T>.FillArray2(CommandQueue<array[,] of &T>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArray<T>.FillArray3(CommandQueue<array[,,] of &T>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenFillArray2(CommandQueue<array[,] of &T>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenFillArray3(CommandQueue<array[,,] of &T>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Заполняет fill_len элементов данного массива OpenCL копиями участков из pattern_len элементов указанного массива
ind указывает индекс первого элемента данного массива OpenCL
a_ind(-ы) указывают индекс первого элемента в массиве RAM
==================================================
ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку

# CLArray<T>.FillArraySegment(CommandQueue<ArraySegment<&T>>)
# CLArrayCCQ<T>.ThenFillArraySegment(CommandQueue<ArraySegment<&T>>)
Заполняет данный массив OpenCL копиями указанного участка массива RAM

# CLArray<T>.FillArraySegment(CommandQueue<ArraySegment<&T>>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenFillArraySegment(CommandQueue<ArraySegment<&T>>, CommandQueue<integer>, CommandQueue<integer>)
Заполняет fill_len элементов данного массива OpenCL начиная с индекса ind копиями указанного участка массива RAM

# CLArray<T>.FillData(CommandQueue<IntPtr>, CommandQueue<integer>)
# CLArray<T>.FillData(pointer, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenFillData(CommandQueue<IntPtr>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenFillData(pointer, CommandQueue<integer>)
Берёт pattern_len элементов из RAM по указанному адресу и заполняет их копиями весь данный массив

# CLArray<T>.FillData(CommandQueue<IntPtr>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArray<T>.FillData(pointer, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenFillData(CommandQueue<IntPtr>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenFillData(pointer, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Берёт pattern_len элементов из RAM по указанному адресу и заполняет их копиями len элементов начиная с индекса ind данного массива

# CLArray<T>.FillNativeValue(CommandQueue<NativeValue<&T>>)
# CLArray<T>.FillValue(&T)
# CLArray<T>.FillValue(CommandQueue<&T>)
# CLArrayCCQ<T>.ThenFillNativeValue(CommandQueue<NativeValue<&T>>)
# CLArrayCCQ<T>.ThenFillValue(&T)
# CLArrayCCQ<T>.ThenFillValue(CommandQueue<&T>)
Заполняет весь массив копиями указанного значения

# CLArray<T>.FillNativeValue(CommandQueue<NativeValue<&T>>, CommandQueue<integer>, CommandQueue<integer>)
# CLArray<T>.FillValue(&T, CommandQueue<integer>, CommandQueue<integer>)
# CLArray<T>.FillValue(CommandQueue<&T>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenFillNativeValue(CommandQueue<NativeValue<&T>>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenFillValue(&T, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenFillValue(CommandQueue<&T>, CommandQueue<integer>, CommandQueue<integer>)
Заполняет len элементов начиная с индекса ind копиями указанного значения

# CLArray<T>.Finalize
# CLMemory.Finalize
# CLValue<T>.Finalize
# NativeArray<T>.Finalize
# NativeValue<T>.Finalize
Вызывает Dispose. Данный метод вызывается автоматически во время сборки мусора
Данный метод не должен вызываться из пользовательского кода. Он виден только на случай если вы хотите переопределить его в своём классе-наследнике

# CLArray<T>.GetArray
# CLArrayCCQ<T>.ThenGetArray
Читает весь данный массив OpenCL как массив RAM

# CLArray<T>.GetArray(CommandQueue<integer>)
# CLArray<T>.GetArray2(CommandQueue<integer>, CommandQueue<integer>)
# CLArray<T>.GetArray3(CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenGetArray(CommandQueue<integer>)
# CLArrayCCQ<T>.ThenGetArray2(CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenGetArray3(CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Создаёт массив RAM с указанным кол-вом элементов и копирует в него данные из начала данного массива OpenCL

# CLArray<T>.GetValue(CommandQueue<integer>)
# CLArrayCCQ<T>.ThenGetValue(CommandQueue<integer>)
Читает элемент по указанному индексу

# CLArray<T>.Item[integer]
Возвращает или задаёт один элемент массива
Внимание! Данные свойство использует неявные очереди при каждом обращение, поэтому может быть очень не эффективным

# CLArray<T>.ItemSize
# NativeArray<T>.ItemSize
Возвращает размер одного элемента массива, в байтах

# CLArray<T>.Length
Возвращает длину массива

# CLArray<T>.Native
# CLMemory.Native
# CLValue<T>.Native
Возвращает имя (дескриптор) неуправляемого объекта

# CLArray<T>.Properties
# CLMemory.Properties
# CLMemorySubSegment.Properties
# CLValue<T>.Properties
Возвращает контейнер свойств неуправляемого объекта

# CLArray<T>.ReadArray(CommandQueue<array of &T>)
# CLArray<T>.ReadArray2(CommandQueue<array[,] of &T>)
# CLArray<T>.ReadArray3(CommandQueue<array[,,] of &T>)
# CLArray<T>.ReadNativeArray(CommandQueue<NativeArray<&T>>)
# CLArrayCCQ<T>.ThenReadArray(CommandQueue<array of &T>)
# CLArrayCCQ<T>.ThenReadArray2(CommandQueue<array[,] of &T>)
# CLArrayCCQ<T>.ThenReadArray3(CommandQueue<array[,,] of &T>)
# CLArrayCCQ<T>.ThenReadNativeArray(CommandQueue<NativeArray<&T>>)
Читает начало данного массива OpenCL в указанный массив RAM

# CLArray<T>.ReadArray(CommandQueue<array of &T>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenReadArray(CommandQueue<array of &T>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Читает len элементов данного массива OpenCL в указанный массив RAM
ind указывает индекс первого элемента данного массива OpenCL
a_ind(-ы) указывают индекс первого элемента в массиве RAM

# CLArray<T>.ReadArray2(CommandQueue<array[,] of &T>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArray<T>.ReadArray3(CommandQueue<array[,,] of &T>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenReadArray2(CommandQueue<array[,] of &T>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenReadArray3(CommandQueue<array[,,] of &T>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Читает len элементов данного массива OpenCL в указанный массив RAM
ind указывает индекс первого элемента данного массива OpenCL
a_ind(-ы) указывают индекс первого элемента в массиве RAM
==================================================
ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку

# CLArray<T>.ReadArraySegment(CommandQueue<ArraySegment<&T>>)
# CLArrayCCQ<T>.ThenReadArraySegment(CommandQueue<ArraySegment<&T>>)
Читает начало данного массива OpenCL в указанный участок массива RAM

# CLArray<T>.ReadArraySegment(CommandQueue<ArraySegment<&T>>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenReadArraySegment(CommandQueue<ArraySegment<&T>>, CommandQueue<integer>)
Читает данные данного массива OpenCL в указанный участок массива RAM
ind указывает индекс первого элемента данного массива OpenCL

# CLArray<T>.ReadData(CommandQueue<IntPtr>)
# CLArray<T>.ReadData(pointer)
# CLArrayCCQ<T>.ThenReadData(CommandQueue<IntPtr>)
# CLArrayCCQ<T>.ThenReadData(pointer)
Читает всё содержимое из данного массива в RAM, по указанному адресу

# CLArray<T>.ReadData(CommandQueue<IntPtr>, CommandQueue<integer>, CommandQueue<integer>)
# CLArray<T>.ReadData(pointer, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenReadData(CommandQueue<IntPtr>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenReadData(pointer, CommandQueue<integer>, CommandQueue<integer>)
Читает len элементов начиная с индекса ind из данного массива в RAM, по указанному адресу

# CLArray<T>.ReadNativeValue(CommandQueue<NativeValue<&T>>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenReadNativeValue(CommandQueue<NativeValue<&T>>, CommandQueue<integer>)
Читает элемент данного массива с индексом ind в указанное значение

# CLArray<T>.Slice[IntRange]
Возвращает или задаёт элементы массива в заданном диапазоне
Внимание! Данные свойство использует неявные очереди при каждом обращение, поэтому может быть очень не эффективным

# CLArray<T>.ToString
# CLMemory.ToString
# CLMemorySubSegment.ToString
# CLValue<T>.ToString
# NativeArray<T>.ToString
# NativeMemoryArea.ToString
# NativeValue<T>.ToString
Возвращает строку с основными данными о данном объекте

# CLArray<T>.WriteArray(CommandQueue<array of &T>)
# CLArray<T>.WriteArray2(CommandQueue<array[,] of &T>)
# CLArray<T>.WriteArray3(CommandQueue<array[,,] of &T>)
# CLArray<T>.WriteNativeArray(CommandQueue<NativeArray<&T>>)
# CLArrayCCQ<T>.ThenWriteArray(CommandQueue<array of &T>)
# CLArrayCCQ<T>.ThenWriteArray2(CommandQueue<array[,] of &T>)
# CLArrayCCQ<T>.ThenWriteArray3(CommandQueue<array[,,] of &T>)
# CLArrayCCQ<T>.ThenWriteNativeArray(CommandQueue<NativeArray<&T>>)
Записывает указанный массив RAM в начало данного массива OpenCL

# CLArray<T>.WriteArray(CommandQueue<array of &T>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenWriteArray(CommandQueue<array of &T>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Записывает len элементов из указанного массива RAM в данный массив OpenCL
ind указывает индекс первого элемента данного массива OpenCL
a_ind(-ы) указывают индекс первого элемента в массиве RAM

# CLArray<T>.WriteArray2(CommandQueue<array[,] of &T>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArray<T>.WriteArray3(CommandQueue<array[,,] of &T>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenWriteArray2(CommandQueue<array[,] of &T>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenWriteArray3(CommandQueue<array[,,] of &T>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Записывает len элементов из указанного массива RAM в данный массив OpenCL
ind указывает индекс первого элемента данного массива OpenCL
a_ind(-ы) указывают индекс первого элемента в массиве RAM
==================================================
ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку

# CLArray<T>.WriteArraySegment(CommandQueue<ArraySegment<&T>>)
# CLArrayCCQ<T>.ThenWriteArraySegment(CommandQueue<ArraySegment<&T>>)
Записывает указанный участок массива RAM в начало данного массива OpenCL

# CLArray<T>.WriteArraySegment(CommandQueue<ArraySegment<&T>>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenWriteArraySegment(CommandQueue<ArraySegment<&T>>, CommandQueue<integer>)
Записывает указанный участок массива RAM в данный массив OpenCL
ind указывает индекс первого элемента данного массива OpenCL

# CLArray<T>.WriteData(CommandQueue<IntPtr>)
# CLArray<T>.WriteData(pointer)
# CLArrayCCQ<T>.ThenWriteData(CommandQueue<IntPtr>)
# CLArrayCCQ<T>.ThenWriteData(pointer)
Заполняет весь данный массив данными, находящимися по указанному адресу в RAM

# CLArray<T>.WriteData(CommandQueue<IntPtr>, CommandQueue<integer>, CommandQueue<integer>)
# CLArray<T>.WriteData(pointer, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenWriteData(CommandQueue<IntPtr>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenWriteData(pointer, CommandQueue<integer>, CommandQueue<integer>)
Заполняет len элементов начиная с индекса ind данного массива данными, находящимися по указанному адресу в RAM

# CLArray<T>.WriteNativeValue(CommandQueue<NativeValue<&T>>, CommandQueue<integer>)
# CLArray<T>.WriteValue(&T, CommandQueue<integer>)
# CLArray<T>.WriteValue(CommandQueue<&T>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenWriteNativeValue(CommandQueue<NativeValue<&T>>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenWriteValue(&T, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenWriteValue(CommandQueue<&T>, CommandQueue<integer>)
Записывает указанное значение в элемент данного массива с индексом ind

# CLArrayCCQ<T>
Представляет очередь-контейнер для команд GPU, применяемых к объекту типа CLArray

# CLArrayCCQ<T>.(CommandQueue<CLArray<T>>)
# CLMemoryCCQ.(CommandQueue<CLMemory>)
# CLValueCCQ<T>.(CommandQueue<CLValue<T>>)
Создаёт контейнер команд, который будет применять команды к объекту, который вернёт указанная очередь
За каждое одно выполнение контейнера - q выполнится ровно один раз

# CLArrayCCQ<T>.ThenQueue(CommandQueueBase)
# CLMemoryCCQ.ThenQueue(CommandQueueBase)
# CLValueCCQ<T>.ThenQueue(CommandQueueBase)
Добавляет выполнение очереди в список обычных команд для GPU

# CLArrayCCQ<T>.ThenWait(WaitMarker)
# CLMemoryCCQ.ThenWait(WaitMarker)
# CLValueCCQ<T>.ThenWait(WaitMarker)
Добавляет ожидание сигнала выполненности от заданного маркера

# CLMemory
Представляет область памяти устройства OpenCL (обычно GPU)

# CLMemory.CopyFrom(CommandQueue<CLMemory>)
# CLMemoryCCQ.ThenCopyFrom(CommandQueue<CLMemory>)
Копирует данные из mem в данную область памяти
Если области памяти имеют разный размер - в качестве объёма данных берётся размер меньшей области

# CLMemory.CopyFrom(CommandQueue<CLMemory>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemoryCCQ.ThenCopyFrom(CommandQueue<CLMemory>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Копирует данные из mem в данную область памяти
from_offset указывает отступ в байтах от начала области памяти, из которой копируют
to_offset указывает отступ в байтах от начала области памяти, в которую копируют
len указывает кол-во копируемых байт

# CLMemory.CopyTo(CommandQueue<CLMemory>)
# CLMemoryCCQ.ThenCopyTo(CommandQueue<CLMemory>)
Копирует данные из данной области памяти в mem
Если области памяти имеют разный размер - в качестве объёма данных берётся размер меньшей области

# CLMemory.CopyTo(CommandQueue<CLMemory>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemoryCCQ.ThenCopyTo(CommandQueue<CLMemory>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Копирует данные из данной области памяти в mem
from_offset указывает отступ в байтах от начала области памяти, из которой копируют
to_offset указывает отступ в байтах от начала области памяти, в которую копируют
len указывает кол-во копируемых байт

# CLMemory.FillArray1<TRecord>(array of TRecord)
# CLMemory.FillArray1<TRecord>(CommandQueue<array of TRecord>)
# CLMemory.FillArray2<TRecord>(array[,] of TRecord)
# CLMemory.FillArray2<TRecord>(CommandQueue<array[,] of TRecord>)
# CLMemory.FillArray3<TRecord>(array[,,] of TRecord)
# CLMemory.FillArray3<TRecord>(CommandQueue<array[,,] of TRecord>)
# CLMemory.FillNativeArray<TRecord>(CommandQueue<NativeArray<TRecord>>)
# CLMemory.FillNativeArray<TRecord>(NativeArray<TRecord>)
# CLMemoryCCQ.ThenFillArray1<TRecord>(array of TRecord)
# CLMemoryCCQ.ThenFillArray1<TRecord>(CommandQueue<array of TRecord>)
# CLMemoryCCQ.ThenFillArray2<TRecord>(array[,] of TRecord)
# CLMemoryCCQ.ThenFillArray2<TRecord>(CommandQueue<array[,] of TRecord>)
# CLMemoryCCQ.ThenFillArray3<TRecord>(array[,,] of TRecord)
# CLMemoryCCQ.ThenFillArray3<TRecord>(CommandQueue<array[,,] of TRecord>)
# CLMemoryCCQ.ThenFillNativeArray<TRecord>(CommandQueue<NativeArray<TRecord>>)
# CLMemoryCCQ.ThenFillNativeArray<TRecord>(NativeArray<TRecord>)
Заполняет область памяти копиями указанного массива

# CLMemory.FillArray1<TRecord>(array of TRecord, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemory.FillArray1<TRecord>(CommandQueue<array of TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemoryCCQ.ThenFillArray1<TRecord>(array of TRecord, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemoryCCQ.ThenFillArray1<TRecord>(CommandQueue<array of TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Заполняет область памяти копиями указанного участка массива
a_ind(-ы) указывают индекс первого задействованного элемента массива
el_count указывает кол-во задействованных элементов массива
mem_offset указывает отступ от начала области памяти, в байтах
fill_byte_len указывает кол-во заливаемых байт

# CLMemory.FillArray2<TRecord>(array[,] of TRecord, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemory.FillArray2<TRecord>(CommandQueue<array[,] of TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemory.FillArray3<TRecord>(array[,,] of TRecord, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemory.FillArray3<TRecord>(CommandQueue<array[,,] of TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemoryCCQ.ThenFillArray2<TRecord>(array[,] of TRecord, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemoryCCQ.ThenFillArray2<TRecord>(CommandQueue<array[,] of TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemoryCCQ.ThenFillArray3<TRecord>(array[,,] of TRecord, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemoryCCQ.ThenFillArray3<TRecord>(CommandQueue<array[,,] of TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Заполняет область памяти копиями указанного участка массива
a_ind(-ы) указывают индекс первого задействованного элемента массива
el_count указывает кол-во задействованных элементов массива
mem_offset указывает отступ от начала области памяти, в байтах
fill_byte_len указывает кол-во заливаемых байт
==================================================
ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку

# CLMemory.FillArraySegment<TRecord>(ArraySegment<TRecord>)
# CLMemoryCCQ.ThenFillArraySegment<TRecord>(ArraySegment<TRecord>)
Заполняет область памяти копиями указанного участка массива

# CLMemory.FillArraySegment<TRecord>(ArraySegment<TRecord>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemoryCCQ.ThenFillArraySegment<TRecord>(ArraySegment<TRecord>, CommandQueue<integer>, CommandQueue<integer>)
Заполняет область памяти копиями указанного участка массива
mem_offset указывает отступ от начала области памяти, в байтах
fill_byte_len указывает кол-во заливаемых байт

# CLMemory.FillData(CommandQueue<IntPtr>, CommandQueue<integer>)
# CLMemory.FillData(pointer, CommandQueue<integer>)
# CLMemoryCCQ.ThenFillData(CommandQueue<IntPtr>, CommandQueue<integer>)
# CLMemoryCCQ.ThenFillData(pointer, CommandQueue<integer>)
Берёт последовательность из pattern_len байт из RAM по указанному адресу и заполняет её копиями всю область памяти

# CLMemory.FillData(CommandQueue<IntPtr>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemory.FillData(pointer, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemoryCCQ.ThenFillData(CommandQueue<IntPtr>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemoryCCQ.ThenFillData(pointer, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Берёт последовательность из pattern_len байт из RAM по указанному адресу и заполняет её копиями часть области памяти
mem_offset указывает отступ от начала области памяти, в байтах
fill_byte_len указывает кол-во заливаемых байт

# CLMemory.FillNativeValue<TRecord>(CommandQueue<NativeValue<TRecord>>)
# CLMemory.FillNativeValue<TRecord>(NativeValue<TRecord>)
# CLMemory.FillValue<TRecord>(CommandQueue<TRecord>)
# CLMemory.FillValue<TRecord>(TRecord)
# CLMemoryCCQ.ThenFillNativeValue<TRecord>(CommandQueue<NativeValue<TRecord>>)
# CLMemoryCCQ.ThenFillNativeValue<TRecord>(NativeValue<TRecord>)
# CLMemoryCCQ.ThenFillValue<TRecord>(CommandQueue<TRecord>)
# CLMemoryCCQ.ThenFillValue<TRecord>(TRecord)
Заполняет всю область памяти копиями указанного значения размерного типа

# CLMemory.FillNativeValue<TRecord>(CommandQueue<NativeValue<TRecord>>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemory.FillNativeValue<TRecord>(NativeValue<TRecord>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemory.FillValue<TRecord>(CommandQueue<TRecord>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemory.FillValue<TRecord>(TRecord, CommandQueue<integer>, CommandQueue<integer>)
# CLMemoryCCQ.ThenFillNativeValue<TRecord>(CommandQueue<NativeValue<TRecord>>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemoryCCQ.ThenFillNativeValue<TRecord>(NativeValue<TRecord>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemoryCCQ.ThenFillValue<TRecord>(CommandQueue<TRecord>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemoryCCQ.ThenFillValue<TRecord>(TRecord, CommandQueue<integer>, CommandQueue<integer>)
Заполняет часть области памяти копиями указанного значения размерного типа
mem_offset указывает отступ от начала области памяти, в байтах
fill_byte_len указывает кол-во заливаемых байт

# CLMemory.GetArray<TRecord>
# CLMemoryCCQ.ThenGetArray<TRecord>
Создаёт массив с максимальным возможным кол-вом элементов и заполняет его содержимым области памяти

# CLMemory.GetArray<TRecord>(CommandQueue<integer>)
# CLMemory.GetArray2<TRecord>(CommandQueue<integer>, CommandQueue<integer>)
# CLMemory.GetArray3<TRecord>(CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemoryCCQ.ThenGetArray<TRecord>(CommandQueue<integer>)
# CLMemoryCCQ.ThenGetArray2<TRecord>(CommandQueue<integer>, CommandQueue<integer>)
# CLMemoryCCQ.ThenGetArray3<TRecord>(CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Создаёт массив с указанным кол-вом элементов и копирует в него содержимое из начала области памяти

# CLMemory.GetValue<TRecord>
# CLMemoryCCQ.ThenGetValue<TRecord>
Читает значение указанного размерного типа из начала области памяти

# CLMemory.GetValue<TRecord>(CommandQueue<integer>)
# CLMemoryCCQ.ThenGetValue<TRecord>(CommandQueue<integer>)
Читает значение указанного размерного типа из области памяти
mem_offset указывает отступ от начала области памяти, в байтах

# CLMemory.ReadArray1<TRecord>(array of TRecord)
# CLMemory.ReadArray1<TRecord>(CommandQueue<array of TRecord>)
# CLMemory.ReadArray2<TRecord>(array[,] of TRecord)
# CLMemory.ReadArray2<TRecord>(CommandQueue<array[,] of TRecord>)
# CLMemory.ReadArray3<TRecord>(array[,,] of TRecord)
# CLMemory.ReadArray3<TRecord>(CommandQueue<array[,,] of TRecord>)
# CLMemory.ReadNativeArray<TRecord>(CommandQueue<NativeArray<TRecord>>)
# CLMemory.ReadNativeArray<TRecord>(NativeArray<TRecord>)
# CLMemoryCCQ.ThenReadArray1<TRecord>(array of TRecord)
# CLMemoryCCQ.ThenReadArray1<TRecord>(CommandQueue<array of TRecord>)
# CLMemoryCCQ.ThenReadArray2<TRecord>(array[,] of TRecord)
# CLMemoryCCQ.ThenReadArray2<TRecord>(CommandQueue<array[,] of TRecord>)
# CLMemoryCCQ.ThenReadArray3<TRecord>(array[,,] of TRecord)
# CLMemoryCCQ.ThenReadArray3<TRecord>(CommandQueue<array[,,] of TRecord>)
# CLMemoryCCQ.ThenReadNativeArray<TRecord>(CommandQueue<NativeArray<TRecord>>)
# CLMemoryCCQ.ThenReadNativeArray<TRecord>(NativeArray<TRecord>)
Заполняет весь массив байбами из начала области памяти

# CLMemory.ReadArray1<TRecord>(array of TRecord, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemory.ReadArray1<TRecord>(CommandQueue<array of TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemoryCCQ.ThenReadArray1<TRecord>(array of TRecord, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemoryCCQ.ThenReadArray1<TRecord>(CommandQueue<array of TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Читает данные из области памяти в указанный участок массива
mem_offset указывает отступ от начала области памяти, в байтах
a_ind(-ы) указывают индекс первого задействованного элемента массива
el_count указывает кол-во задействованных элементов массива

# CLMemory.ReadArray2<TRecord>(array[,] of TRecord, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemory.ReadArray2<TRecord>(CommandQueue<array[,] of TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemory.ReadArray3<TRecord>(array[,,] of TRecord, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemory.ReadArray3<TRecord>(CommandQueue<array[,,] of TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemoryCCQ.ThenReadArray2<TRecord>(array[,] of TRecord, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemoryCCQ.ThenReadArray2<TRecord>(CommandQueue<array[,] of TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemoryCCQ.ThenReadArray3<TRecord>(array[,,] of TRecord, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemoryCCQ.ThenReadArray3<TRecord>(CommandQueue<array[,,] of TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Читает данные из области памяти в указанный участок массива
mem_offset указывает отступ от начала области памяти, в байтах
a_ind(-ы) указывают индекс первого задействованного элемента массива
el_count указывает кол-во задействованных элементов массива
==================================================
ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку

# CLMemory.ReadArraySegment<TRecord>(ArraySegment<TRecord>, CommandQueue<integer>)
# CLMemoryCCQ.ThenReadArraySegment<TRecord>(ArraySegment<TRecord>, CommandQueue<integer>)
Читает данные из области памяти в указанный участок массива
mem_offset указывает отступ от начала области памяти, в байтах

# CLMemory.ReadData(CommandQueue<IntPtr>)
# CLMemory.ReadData(pointer)
# CLMemoryCCQ.ThenReadData(CommandQueue<IntPtr>)
# CLMemoryCCQ.ThenReadData(pointer)
Читает всё содержимое области памяти в RAM, по указанному адресу

# CLMemory.ReadData(CommandQueue<IntPtr>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemory.ReadData(pointer, CommandQueue<integer>, CommandQueue<integer>)
# CLMemoryCCQ.ThenReadData(CommandQueue<IntPtr>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemoryCCQ.ThenReadData(pointer, CommandQueue<integer>, CommandQueue<integer>)
Читает часть содержимого области памяти в RAM, по указанному адресу
mem_offset указывает отступ от начала области памяти, в байтах
len указывает кол-во задействованных в операции байт

# CLMemory.ReadNativeValue<TRecord>(CommandQueue<NativeValue<TRecord>>)
# CLMemory.ReadNativeValue<TRecord>(NativeValue<TRecord>)
# CLMemoryCCQ.ThenReadNativeValue<TRecord>(CommandQueue<NativeValue<TRecord>>)
# CLMemoryCCQ.ThenReadNativeValue<TRecord>(NativeValue<TRecord>)
Читает значение размерного типа из начала области памяти в указанное значение

# CLMemory.ReadNativeValue<TRecord>(CommandQueue<NativeValue<TRecord>>, CommandQueue<integer>)
# CLMemory.ReadNativeValue<TRecord>(NativeValue<TRecord>, CommandQueue<integer>)
# CLMemoryCCQ.ThenReadNativeValue<TRecord>(CommandQueue<NativeValue<TRecord>>, CommandQueue<integer>)
# CLMemoryCCQ.ThenReadNativeValue<TRecord>(NativeValue<TRecord>, CommandQueue<integer>)
Читает значение размерного типа из области памяти в указанное значение
mem_offset указывает отступ от начала области памяти, в байтах

# CLMemory.Size
# CLMemory.Size32
# CLMemory.Size64
Возвращает размер области памяти в байтах

# CLMemory.WriteArray1<TRecord>(array of TRecord)
# CLMemory.WriteArray1<TRecord>(CommandQueue<array of TRecord>)
# CLMemory.WriteArray2<TRecord>(array[,] of TRecord)
# CLMemory.WriteArray2<TRecord>(CommandQueue<array[,] of TRecord>)
# CLMemory.WriteArray3<TRecord>(array[,,] of TRecord)
# CLMemory.WriteArray3<TRecord>(CommandQueue<array[,,] of TRecord>)
# CLMemory.WriteNativeArray<TRecord>(CommandQueue<NativeArray<TRecord>>)
# CLMemory.WriteNativeArray<TRecord>(NativeArray<TRecord>)
# CLMemoryCCQ.ThenWriteArray1<TRecord>(array of TRecord)
# CLMemoryCCQ.ThenWriteArray1<TRecord>(CommandQueue<array of TRecord>)
# CLMemoryCCQ.ThenWriteArray2<TRecord>(array[,] of TRecord)
# CLMemoryCCQ.ThenWriteArray2<TRecord>(CommandQueue<array[,] of TRecord>)
# CLMemoryCCQ.ThenWriteArray3<TRecord>(array[,,] of TRecord)
# CLMemoryCCQ.ThenWriteArray3<TRecord>(CommandQueue<array[,,] of TRecord>)
# CLMemoryCCQ.ThenWriteNativeArray<TRecord>(CommandQueue<NativeArray<TRecord>>)
# CLMemoryCCQ.ThenWriteNativeArray<TRecord>(NativeArray<TRecord>)
Записывает весь массив в начало области памяти

# CLMemory.WriteArray1<TRecord>(array of TRecord, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemory.WriteArray1<TRecord>(CommandQueue<array of TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemoryCCQ.ThenWriteArray1<TRecord>(array of TRecord, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemoryCCQ.ThenWriteArray1<TRecord>(CommandQueue<array of TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Записывает указанный участок массива в область памяти
mem_offset указывает отступ от начала области памяти, в байтах
a_ind(-ы) указывают индекс первого задействованного элемента массива
el_count указывает кол-во задействованных элементов массива

# CLMemory.WriteArray2<TRecord>(array[,] of TRecord, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemory.WriteArray2<TRecord>(CommandQueue<array[,] of TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemory.WriteArray3<TRecord>(array[,,] of TRecord, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemory.WriteArray3<TRecord>(CommandQueue<array[,,] of TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemoryCCQ.ThenWriteArray2<TRecord>(array[,] of TRecord, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemoryCCQ.ThenWriteArray2<TRecord>(CommandQueue<array[,] of TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemoryCCQ.ThenWriteArray3<TRecord>(array[,,] of TRecord, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemoryCCQ.ThenWriteArray3<TRecord>(CommandQueue<array[,,] of TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Записывает указанный участок массива в область памяти
mem_offset указывает отступ от начала области памяти, в байтах
a_ind(-ы) указывают индекс первого задействованного элемента массива
el_count указывает кол-во задействованных элементов массива
==================================================
ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку

# CLMemory.WriteArraySegment<TRecord>(ArraySegment<TRecord>, CommandQueue<integer>)
# CLMemoryCCQ.ThenWriteArraySegment<TRecord>(ArraySegment<TRecord>, CommandQueue<integer>)
Записывает указанный участок массива в область памяти
mem_offset указывает отступ от начала области памяти, в байтах

# CLMemory.WriteData(CommandQueue<IntPtr>)
# CLMemory.WriteData(pointer)
# CLMemoryCCQ.ThenWriteData(CommandQueue<IntPtr>)
# CLMemoryCCQ.ThenWriteData(pointer)
Заполняет всю область памяти данными, находящимися по указанному адресу в RAM

# CLMemory.WriteData(CommandQueue<IntPtr>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemory.WriteData(pointer, CommandQueue<integer>, CommandQueue<integer>)
# CLMemoryCCQ.ThenWriteData(CommandQueue<IntPtr>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemoryCCQ.ThenWriteData(pointer, CommandQueue<integer>, CommandQueue<integer>)
Заполняет часть области памяти данными, находящимися по указанному адресу в RAM
mem_offset указывает отступ от начала области памяти, в байтах
len указывает кол-во задействованных в операции байт

# CLMemory.WriteNativeValue<TRecord>(CommandQueue<NativeValue<TRecord>>)
# CLMemory.WriteNativeValue<TRecord>(NativeValue<TRecord>)
# CLMemory.WriteValue<TRecord>(CommandQueue<TRecord>)
# CLMemory.WriteValue<TRecord>(TRecord)
# CLMemoryCCQ.ThenWriteNativeValue<TRecord>(CommandQueue<NativeValue<TRecord>>)
# CLMemoryCCQ.ThenWriteNativeValue<TRecord>(NativeValue<TRecord>)
# CLMemoryCCQ.ThenWriteValue<TRecord>(CommandQueue<TRecord>)
# CLMemoryCCQ.ThenWriteValue<TRecord>(TRecord)
Записывает указанное значение размерного типа в начало области памяти

# CLMemory.WriteNativeValue<TRecord>(CommandQueue<NativeValue<TRecord>>, CommandQueue<integer>)
# CLMemory.WriteNativeValue<TRecord>(NativeValue<TRecord>, CommandQueue<integer>)
# CLMemory.WriteValue<TRecord>(CommandQueue<TRecord>, CommandQueue<integer>)
# CLMemory.WriteValue<TRecord>(TRecord, CommandQueue<integer>)
# CLMemoryCCQ.ThenWriteNativeValue<TRecord>(CommandQueue<NativeValue<TRecord>>, CommandQueue<integer>)
# CLMemoryCCQ.ThenWriteNativeValue<TRecord>(NativeValue<TRecord>, CommandQueue<integer>)
# CLMemoryCCQ.ThenWriteValue<TRecord>(CommandQueue<TRecord>, CommandQueue<integer>)
# CLMemoryCCQ.ThenWriteValue<TRecord>(TRecord, CommandQueue<integer>)
Записывает указанное значение размерного типа в область памяти
mem_offset указывает отступ от начала области памяти, в байтах

# CLMemoryCCQ
Представляет очередь-контейнер для команд GPU, применяемых к объекту типа CLMemory

# CLMemorySubSegment
Представляет виртуальную область памяти, выделенную внутри CLMemory

# CLMemorySubSegment.Parent
Возвращает родительскую область памяти

# CLTask<T>
# CLTaskBase
# CLTaskNil
Представляет задачу выполнения очереди, создаваемую методом Context.BeginInvoke

# CLTask<T>.OrgQueue
# CLTaskBase.OrgQueue
# CLTaskNil.OrgQueue
Возвращает очередь, которую выполняет данный CLTask

# CLTask<T>.WaitRes
Ожидает окончания выполнения очереди (если оно ещё не завершилось)
Кидает System.AggregateException, содержащие ошибки при выполнении очереди, если такие имеются
А затем возвращает результат выполнения

# CLTaskBase.Wait
Ожидает окончания выполнения очереди (если оно ещё не завершилось)
Кидает System.AggregateException, содержащие ошибки при выполнении очереди, если такие имеются

# CLValue<T>
Представляет запись, значение которой хранится на устройстве OpenCL (обычно GPU)

# CLValue<T>.CopyFrom(CommandQueue<CLMemory>)
# CLValueCCQ<T>.ThenCopyFrom(CommandQueue<CLMemory>)
Копирует данные из mem в данное значение

# CLValue<T>.CopyFrom(CommandQueue<CLMemory>, CommandQueue<integer>)
# CLValueCCQ<T>.ThenCopyFrom(CommandQueue<CLMemory>, CommandQueue<integer>)
Копирует данные из mem в данное значение
mem_offset указывает отступ от начала области памяти, в байтах

# CLValue<T>.CopyFrom(CommandQueue<CLValue<&T>>)
# CLValueCCQ<T>.ThenCopyFrom(CommandQueue<CLValue<&T>>)
Копирует данные из val в данное значение

# CLValue<T>.CopyTo(CommandQueue<CLMemory>)
# CLValueCCQ<T>.ThenCopyTo(CommandQueue<CLMemory>)
Копирует данные из данного значения в mem

# CLValue<T>.CopyTo(CommandQueue<CLMemory>, CommandQueue<integer>)
# CLValueCCQ<T>.ThenCopyTo(CommandQueue<CLMemory>, CommandQueue<integer>)
Копирует данные из данного значения в mem
mem_offset указывает отступ от начала области памяти, в байтах

# CLValue<T>.CopyTo(CommandQueue<CLValue<&T>>)
# CLValueCCQ<T>.ThenCopyTo(CommandQueue<CLValue<&T>>)
Копирует данные из данного значения в val

# CLValue<T>.GetValue
# CLValueCCQ<T>.ThenGetValue
Читает данное значение

# CLValue<T>.ReadNativeValue(CommandQueue<NativeValue<&T>>)
# CLValueCCQ<T>.ThenReadNativeValue(CommandQueue<NativeValue<&T>>)
Читает данное значение в указанное

# CLValue<T>.ValueSize
# NativeValue<T>.ValueSize
Возвращает размер значения, в байтах

# CLValue<T>.WriteNativeValue(CommandQueue<NativeValue<&T>>)
# CLValue<T>.WriteValue(&T)
# CLValue<T>.WriteValue(CommandQueue<&T>)
# CLValueCCQ<T>.ThenWriteNativeValue(CommandQueue<NativeValue<&T>>)
# CLValueCCQ<T>.ThenWriteValue(&T)
# CLValueCCQ<T>.ThenWriteValue(CommandQueue<&T>)
Записывает указанное значение в данное

# CLValueCCQ<T>
Представляет очередь-контейнер для команд GPU, применяемых к объекту типа CLValue

# CombineAsyncQueue<T>(array of CommandQueue<T>)
Создаёт очередь, выполняющую указанные очереди одновременно
И возвращающую результат последней очереди

# CombineSyncQueue<T>(array of CommandQueue<T>)
Создаёт очередь, выполняющую указанные очереди одну за другой
И возвращающую результат последней очереди

# CommandQueue<T>
Представляет очередь команд, в основном выполняемых на GPU
Такая очередь всегда возвращает значение типа T

# CommandQueue<T>.DiscardResult
# CommandQueueBase.DiscardResult
Возвращает данную очередь но без результата

# CommandQueue<T>.HandleDefaultRes(Exception->boolean, T)
# CommandQueue<T>.HandleDefaultRes<TException>(TException->boolean, T)
Создаёт очередь, сначала выполняющую данную, а затем обрабатывающую кинутые в ней исключения
В конце выполнения созданная очередь возвращает то, что вернула данная, если исключений небыло и указанное значение если обработчик был успешно выполнен

# CommandQueue<T>.HandleReplaceRes(List<Exception> -> T)
Создаёт очередь, сначала выполняющую данную, а затем обрабатывающую кинутые в ней исключения
Для того чтоб пометить исключение обработанным - его надо удалить из полученного списка
Возвращаемое значение обработчика указывает на что надо заменить возвращаемое значение данной очереди, если обработчик был успешно выполнен

# CommandQueue<T>.Multiusable
# CommandQueueBase.Multiusable
# CommandQueueNil.Multiusable
Создаёт функцию, вызывая которую можно создать любое кол-во очередей-удлинителей для данной очереди
Подробнее в справке: "Очередь>>Создание очередей>>Множественное использование очереди"

# CommandQueue<T>.Print
# CommandQueueBase.Print
# CommandQueueNil.Print
# WaitMarker.Print
Вызывает Write(ToString) для данного объекта и возвращает его же

# CommandQueue<T>.Println
# CommandQueueBase.Println
# CommandQueueNil.Println
# WaitMarker.Println
Вызывает Writeln(ToString) для данного объекта и возвращает его же

# CommandQueue<T>.ThenFinallyMarkerSignal
# CommandQueueNil.ThenFinallyMarkerSignal
Создаёт очередь, сначала выполняющую данную, а затем вызывающую свой .SendSignal не зависимо от исключений при выполнении данной очереди
При передаче в Wait-очереди, полученная очередь превращается в маркер
В конце выполнения созданная очередь возвращает то, что вернула данная

# CommandQueue<T>.ThenFinallyWaitFor(WaitMarker)
Создаёт очередь, сначала выполняющую данную, а затем ожидающую сигнала от указанного маркера не зависимо от исключений при выполнении данной очереди
В конце выполнения созданная очередь возвращает то, что вернула данная

# CommandQueue<T>.ThenMarkerSignal
# CommandQueueNil.ThenMarkerSignal
Создаёт очередь, сначала выполняющую данную, а затем вызывающую свой .SendSignal 
При передаче в Wait-очереди, полученная очередь превращается в маркер
В конце выполнения созданная очередь возвращает то, что вернула данная

# CommandQueue<T>.ThenWaitFor(WaitMarker)
Создаёт очередь, сначала выполняющую данную, а затем ожидающую сигнала от указанного маркера 
В конце выполнения созданная очередь возвращает то, что вернула данная

# CommandQueueBase
Представляет очередь команд, в основном выполняемых на GPU

# CommandQueueBase.Cast<T>
Если данная очередь проходит по условию "... is CommandQueue<T>" - возвращает себя же
Иначе возвращает очередь-обёртку, выполняющую "res := T(res)", где res - результат данной очереди

# CommandQueueBase.ConvertTyped<TRes>(ITypedCQConverter<TRes>)
# CommandQueueBase.UseTyped(ITypedCQUser)
Проверяет, какой тип результата у данной очереди
Передаёт результат указанному объекту

# CommandQueueBase.HandleWithoutRes(Exception->boolean)
# CommandQueueBase.HandleWithoutRes<TException>(TException->boolean)
Создаёт очередь, сначала выполняющую данную, а затем обрабатывающую кинутые в ней исключения
Созданная очередь возвращает nil не зависимо от исключений при выполнении данной очереди

# CommandQueueBase.ToString
# WaitMarker.ToString
Возвращает строковое представление данного объекта
Используйте это значение только для отладки, потому что данный метод не оптимизирован

# CommandQueueNil
Представляет очередь команд, в основном выполняемых на GPU
Такая очередь всегда возвращает nil

# CommandQueueNil.Cast<T>
Создаёт константную очередь, выполняющую данную и возвращающую T(nil)
Для этого T должен быть ссылочным

# CommandQueueNil.DiscardResult
Возвращает данную очередь

# ConstQueue<T>
Представляет константную очередь
Константные очереди ничего не выполняют и возвращают заданное при создании значение

# ConstQueue<T>.(T)
Создаёт новую константную очередь, возвращающую указанное значения

# ConstQueue<T>.Value
Значение, которого возвращает данная константная очередь

# CQ<T>(T)
Создаёт константную очередь с указанным результатом

# Err:Blittable:Blame
Значения типа {TypeToTypeName(t)} нельзя {source_name}, потому что он содержит тип {TypeToTypeName(blame)}

# Err:Blittable:Main
Значения типа {TypeToTypeName(t)} нельзя {source_name}

# Err:Blittable:Source:CLArray
использовать как элементы CLArray<>

# Err:Blittable:Source:CLMemory:FillArray1
# Err:Blittable:Source:CLMemory:FillArray1AutoSize
# Err:Blittable:Source:CLMemory:FillArray2
# Err:Blittable:Source:CLMemory:FillArray2AutoSize
# Err:Blittable:Source:CLMemory:FillArray3
# Err:Blittable:Source:CLMemory:FillArray3AutoSize
# Err:Blittable:Source:CLMemory:FillArraySegment
# Err:Blittable:Source:CLMemory:FillArraySegmentAutoSize
# Err:Blittable:Source:CLMemory:FillNativeArray
# Err:Blittable:Source:CLMemory:FillNativeArrayAutoSize
# Err:Blittable:Source:CLMemory:FillNativeValue
# Err:Blittable:Source:CLMemory:FillNativeValueAutoSize
# Err:Blittable:Source:CLMemory:FillValue
# Err:Blittable:Source:CLMemory:FillValueAutoSize
# Err:Blittable:Source:CLMemory:FillValueAutoSizeQ
# Err:Blittable:Source:CLMemory:FillValueQ
# Err:Blittable:Source:CLMemory:WriteArray1
# Err:Blittable:Source:CLMemory:WriteArray1AutoSize
# Err:Blittable:Source:CLMemory:WriteArray2
# Err:Blittable:Source:CLMemory:WriteArray2AutoSize
# Err:Blittable:Source:CLMemory:WriteArray3
# Err:Blittable:Source:CLMemory:WriteArray3AutoSize
# Err:Blittable:Source:CLMemory:WriteNativeArray
# Err:Blittable:Source:CLMemory:WriteNativeValue
# Err:Blittable:Source:CLMemory:WriteValue
# Err:Blittable:Source:CLMemory:WriteValueQ
записывать в область памяти OpenCL

# Err:Blittable:Source:CLMemory:GetArray
# Err:Blittable:Source:CLMemory:GetArray2
# Err:Blittable:Source:CLMemory:GetArray3
# Err:Blittable:Source:CLMemory:GetArrayAutoSize
# Err:Blittable:Source:CLMemory:GetValue
# Err:Blittable:Source:CLMemory:ReadArray1
# Err:Blittable:Source:CLMemory:ReadArray1AutoSize
# Err:Blittable:Source:CLMemory:ReadArray2
# Err:Blittable:Source:CLMemory:ReadArray2AutoSize
# Err:Blittable:Source:CLMemory:ReadArray3
# Err:Blittable:Source:CLMemory:ReadArray3AutoSize
# Err:Blittable:Source:CLMemory:ReadNativeArray
# Err:Blittable:Source:CLMemory:ReadNativeValue
читать из области памяти OpenCL

# Err:Blittable:Source:CLValue
использовать как тип значения CLValue<>

# Err:Blittable:Source:QueueResPtr
использовать в некоторой внутренней ситуации (напишите об этом в issue)

# Err:Cast:nil->T
.Cast не может преобразовывать nil в {TypeToTypeName(typeof(T))}

# Err:Cast:TInp->TRes
.Cast не может преобразовывать {TypeToTypeName(typeof(TInp))} в {TypeToTypeName(typeof(TRes))}

# Err:CLMemory:WrongNtvType
Неправильный тип неуправляемого объекта памяти. Ожидалось [MEM_OBJECT_BUFFER], а не [{t}]

# Err:CLTask:
При выполнении очереди было вызвано {err_lst.Count} исключений. Используйте try чтоб получить больше информации

# Err:NoParamCtor
Был вызван не_применимый конструктор без параметров... Обратитесь к разработчику OpenCLABC

# Err:Parameter:NotFound
Параметр {par.Name} не используется

# Err:Parameter:SetAgain
Значение параметра {name} установлено больше одного раза

# Err:Parameter:UnSet
Значение параметра {name} небыло установлено

# Err:WaitCombine:InpEmpty
Количество комбинируемых маркеров должно быть положительным

# Err:WaitMarkerCombination.ConvertToQBase
Преобразовывать комбинацию маркеров в очередь нельзя. Возможно вы забыли написать WaitFor?

# ITypedCQConverter<TRes>
# ITypedCQUser
Представляет интерфейс типа, содержащего отдельные алгоритмы обработки, очереди без- и с возвращаемым значением

# ITypedCQConverter<TRes>.Convert<T>(CommandQueue<T>)
# ITypedCQUser.Use<T>(CommandQueue<T>)
Вызывается если у очереди есть возвращаемое значение

# ITypedCQConverter<TRes>.ConvertNil(CommandQueueNil)
# ITypedCQUser.UseNil(CommandQueueNil)
Вызывается если у очереди нет возвращаемого значения

# NativeArray<T>
Представляет массив, содержимое которого хранится в неуправляемой области памяти

# NativeArray<T>.(array of T)
Выделяет неуправляемую память и сохраняет в неё копию указанных данных

# NativeArray<T>.Contains(T)
Определяет содержится ли элемент в массиве

# NativeArray<T>.CopyTo(array of T, integer)
Копирует всё содержимое данного массива в указанный
Данное свойство проверяет правильность переданных индексов

# NativeArray<T>.Dispose
Освобождает неуправляемую память из по данного массива
Этот метод потоко-безопасен
Данный метод вызывается автоматически во время сборки мусора, если объект ещё не удалён

# NativeArray<T>.GetEnumerator
Возвращает перечислитель данного массива

# NativeArray<T>.IndexOf(T)
Возвращает индекс по которому находится указанный элемент
Если элемент таковой найден - возвращает nil

# NativeArray<T>.Item[integer]
Возвращает или задаёт элемент массива по указанному индексу
Данное свойство проверяет правильность переданных индексов

# NativeArray<T>.SliceArea[IntRange]
Возвращает описание области памяти для указанного среза элементов
Данное свойство проверяет правильность переданных индексов

# NativeArray<T>.SliceAreaUnchecked[IntRange]
Возвращает описание области памяти для указанного среза элементов
Данное свойство не проверяет правильность переданных индексов

# NativeArrayEnumerator<T>
Представляет перечислитель для типа NativeArray<>

# NativeArrayEnumerator<T>.(NativeArray<T>)
Создаёт перечислитель для указанного массива

# NativeArrayEnumerator<T>.Current
Возвращает элемент массива на который указывает данный перечислитель
Данное свойство проверяет правильность переданных индексов

# NativeArrayEnumerator<T>.Dispose
Обнуляет ссылку перечислителя на массив

# NativeArrayEnumerator<T>.MoveNext
Переходит к следующему элементу массива
Возвращаемое значение указывает можно ли читать данные из свойства Current

# NativeArrayEnumerator<T>.Reset
Сбрасывает перечислитель в его исходное положение

# NativeMemoryArea
Описывает неуправляемою область памяти

# NativeMemoryArea.(IntPtr, UIntPtr)
Создаёт описание указанной области памяти

# NativeMemoryArea.CopyFrom(NativeMemoryArea)
Копирует данные из указанной области памяти в данную
Области памяти не должны пересекаться. Иначе поведение неопределено
Если пересечение возможно, используйте соответствующий .CopyOverlapped* метод
Кол-во копируемых байт берётся из данной области памяти, даже если указанная область памяти имеет меньший размер
Если надо скопировать минимум размеров данной и указанной области памяти используйте статический метод NativeMemoryArea.CopyMinSize

# NativeMemoryArea.CopyFrom<T>(array of T)
# NativeMemoryArea.CopyFrom<T>(T)
Копирует данные из указанной области памяти в данную
Области памяти не должны пересекаться. Иначе поведение неопределено
Если пересечение возможно, используйте соответствующий .CopyOverlapped* метод
Кол-во копируемых байт берётся из данной области памяти, даже если указанная область памяти имеет меньший размер

# NativeMemoryArea.CopyMinSize(NativeMemoryArea, NativeMemoryArea)
Копирует данные между указанными областями памяти
Области памяти не должны пересекаться. Иначе поведение неопределено
Если пересечение возможно, используйте соответствующий .CopyOverlapped* метод
Количество копируемых байт равняется минимальному размеру указанных областей памяти

# NativeMemoryArea.CopyOverlappedFrom(NativeMemoryArea)
Копирует данные из указанной области памяти в данную
Области памяти могут пересекаться, но взамен данный метод немного медленнее соответствующего метода без Overlapped в названии
Кол-во копируемых байт берётся из данной области памяти, даже если указанная область памяти имеет меньший размер
Если надо скопировать минимум размеров данной и указанной области памяти используйте статический метод NativeMemoryArea.CopyOverlappedMinSize

# NativeMemoryArea.CopyOverlappedFrom<T>(array of T)
# NativeMemoryArea.CopyOverlappedFrom<T>(T)
Копирует данные из указанной области памяти в данную
Области памяти могут пересекаться, но взамен данный метод немного медленнее соответствующего метода без Overlapped в названии
Кол-во копируемых байт берётся из данной области памяти, даже если указанная область памяти имеет меньший размер

# NativeMemoryArea.CopyOverlappedMinSize(NativeMemoryArea, NativeMemoryArea)
Копирует данные между указанными областями памяти
Области памяти могут пересекаться, но взамен данный метод немного медленнее соответствующего метода без Overlapped в названии
Количество копируемых байт равняется минимальному размеру указанных областей памяти

# NativeMemoryArea.CopyOverlappedTo(NativeMemoryArea)
Копирует данные из данной области памяти в указанную
Области памяти могут пересекаться, но взамен данный метод немного медленнее соответствующего метода без Overlapped в названии
Кол-во копируемых байт берётся из данной области памяти, даже если указанная область памяти имеет меньший размер
Если надо скопировать минимум размеров данной и указанной области памяти используйте статический метод NativeMemoryArea.CopyOverlappedMinSize

# NativeMemoryArea.CopyOverlappedTo<T>(array of T)
# NativeMemoryArea.CopyOverlappedTo<T>(T)
Копирует данные из данной области памяти в указанную
Области памяти могут пересекаться, но взамен данный метод немного медленнее соответствующего метода без Overlapped в названии
Кол-во копируемых байт берётся из данной области памяти, даже если указанная область памяти имеет меньший размер

# NativeMemoryArea.CopyTo(NativeMemoryArea)
Копирует данные из данной области памяти в указанную
Области памяти не должны пересекаться. Иначе поведение неопределено
Если пересечение возможно, используйте соответствующий .CopyOverlapped* метод
Кол-во копируемых байт берётся из данной области памяти, даже если указанная область памяти имеет меньший размер
Если надо скопировать минимум размеров данной и указанной области памяти используйте статический метод NativeMemoryArea.CopyMinSize

# NativeMemoryArea.CopyTo<T>(array of T)
# NativeMemoryArea.CopyTo<T>(T)
Копирует данные из данной области памяти в указанную
Области памяти не должны пересекаться. Иначе поведение неопределено
Если пересечение возможно, используйте соответствующий .CopyOverlapped* метод
Кол-во копируемых байт берётся из данной области памяти, даже если указанная область памяти имеет меньший размер

# NativeMemoryArea.Fill(byte)
Заполняет всю область памяти указанными байтами

# NativeMemoryArea.FillZero
Заполняет всю область памяти нулевыми байтами

# NativeValue<T>
Представляет запись, значение которой хранится в неуправляемой области памяти

# NativeValue<T>.
Выделяет и обнуляет область неуправляемой памяти

# NativeValue<T>.(T)
Выделяет область неуправляемой памяти и сохраняет в него указанное значение

# NativeValue<T>.Dispose
Освобождает значение, сохранённое неуправляемой памяти
Ничего не делает, если значение уже освобождено
Данный метод вызывается автоматически во время сборки мусора, если объект ещё не удалён

# NativeValue<T>.Pointer
Возвращает указатель на значение, сохранённое неуправляемой памяти

# NativeValue<T>.Value
Возвращает или задаёт значение, сохранённое неуправляемой памяти

# OpenCLABCInternalException
Исключение, кидаемое при неожиданном поведении внутренностей OpenCLABC
Если это исключение было кинуто - пишите в issue

# ParameterQueue<T>
Представляет очередь-параметр
Очереди-параметры ничего не выполняют, но возвращает установленное при запуске очереди значение

# ParameterQueue<T>.(string)
Создаёт новую очередь-параметр
name указывает имя параметра

# ParameterQueue<T>.(string, T)
Создаёт новую очередь-параметр
name указывает имя параметра
Указанное значение будет использоваться если при запуске очереди значение параметра небыло установлено

# ParameterQueue<T>.Default
Значение, которое будет использоваться если при запуске очереди значение параметра небыло установлено

# ParameterQueue<T>.DefaultDefined
Указывает, установлено ли значение, которое будет использоваться если при запуске очереди значение параметра небыло установлено

# ParameterQueue<T>.Name
Имя параметра

# ParameterQueue<T>.NewSetter(T)
Создаёт установщик данного параметра
Если передать этот установщик в метод запуска очереди,
при выполнении параметр будет иметь указанное значение

# ParameterQueueSetter
Представляет установщик очереди-параметра ParameterQueue<T>, созданный методом .NewSetter
Если передать этот установщик в метод запуска очереди,
при выполнении параметр будет иметь указанное значение

# WaitFor(WaitMarker)
Создаёт очередь, ожидающую сигнала выполненности от заданного маркера

# WaitMarker
Представляет маркер для Wait очередей
Данный тип не является очередью
Но при выполнении преобразуется в очередь, выполняющую .SendSignal исходного маркера

# WaitMarker.Create
Создаёт новый простой маркер

# WaitMarker.SendSignal
Посылает сигнал выполненности всем ожидающим Wait очередям

