unit Settings;

{$savepcu false} //TODO

// Всё пространство разделено на блоки этой ширины и высоты
// Если камеру приближают - просчитываются 4 более блока меньшего масштаба:
// Cтолько же точек, но эти точки упакованы ближе друг к другу
// Чем больше блоки - тем быстрее их считает и тем больше использует памяти
const block_w_pow = 9;
const block_w = 1 shl block_w_pow; // 512
// Одновременно может просчитываться max_GPU_inst блоков
// Каждый из видимых блоков нужного масштаба будет по очереди
// пытаться сделать ещё 1 шаг рекуррентной функции "z_next(z) = z*z + c" для каждой точки
// Где "z" это предыдущее значение (изначально 0), а "c" это координата точки
const max_GPU_inst = 5;
// Сколько надо прибавить к масштабу камеры чтобы получить текущий масштаб просчитываемых блоков
// Масштаб это степень двойки
// -1 значит на каждый пиксель экрана придётся хотя бы 4 (2х2) просчитанные точки
const scale_shift = -1; // <=0
// Блок максимального размера это 2х2
// Таким образом вся просчитываемая область разбита на минимум 4 блока, по 1 на угол
// При приближении камеры каждый из этих угловых блоков будет далее разбивать на 4 меньших блока
const max_block_scale = 1; // Не менять - эта константа много где неявно задана

// Отрисованные блоки хранит в VRAM (памяти GPU)
const max_VRAM = 1610612736; // 1.5 GB
// Если VRAM заканчивается - старые блоки отправляет в RAM (в обычную оперативную память)
const max_RAM = 4294967296; // 4 GB
// Если в RAM есть место, но отрисованный блок был там долго - тоже удалить
// (иначе его отправит в файл подкачки, а потом, при подгрузке назад - будет лагать)
const RAM_life_span_seconds = 15*60; // 15 минут

// Чтобы для каждого кадра не пересчитывать
// среднее арифметическое всех точек под каждым пикселем,
// Каждому блоку создаст мипмапы таких размеров:
//
// (block_w/2) * (block_w/2)
// (block_w/4) * (block_w/4)
// ...
// 2 * 2
// 1 * 1
const mipmap_total_size = block_w*block_w div 3;

// Последним шагом считаеться шаг где |z_next|>2
// На шаге=0 z=0, а значит для точек |c|>2 на шаг 1 уже не переключится
// На шаге>0 |z|<=2, иначе на этот шаг не переключилось бы
// Тогда |z*z+c| максимум будет 2*2+2=6
// Таким образом чтобы представить целую часть результата вычисления надо максимум 3 бита
// И затем ещё +1 бит для знака (+ или -)
const z_int_bits = 4; // 0..31
// А точность (кол-во бит) после точки будет масштаб+block_w_pow+z_extra_precision_bits
// 16 доп. бит значит что для заметной ошибки надо минимум столько операций:
// LogN(1+2**-16, 1.5) ~= 26572
const z_extra_precision_bits = 16; // >=0
// Таким образом кол-во байт на 1 точку:
// > 4 (состояние) + 4 (кол-во шагов) + z_component_size * 2 (действительная и мнимая компоненты "z")
// Где компонента z будет записью из нескольких cardinal (32-битных беззнаковых целых)
// > z_component_size = Trunc( (z_int_bits + -point_scale + z_extra_precision_bits) / 32 )*4
// Значит объём VRAM на 1 блок:
// > VRAM = (block_w*block_w) * (8 + 2*z_component_size)
// > VRAM/(block_w*block_w) = 8 + 2*z_component_size
// > VRAM/(block_w*block_w) - 8 = 2*z_component_size
// > VRAM/(block_w*block_w)/2 - 4 = z_component_size
const max_z_component_size = max_VRAM/(block_w*block_w)/2 - 4; // 3068
// Минимальный уровень масштаба, на котором максимум можно нарисовать 1 блок
// На самом деле, если у вас на экране одновременно показывает "n" блоков
// То максимальный масштаб без глюков будет max_z_scale_bits/n
// Но до этого масштаба всё равно будет сложно до-скролить
const max_z_scale_bits_raw = max_z_component_size/4*32 - z_int_bits - block_w_pow - z_extra_precision_bits; // 24515
const max_z_scale_bits_rounded = Trunc(max_z_component_size/4)*32 - z_int_bits - block_w_pow - z_extra_precision_bits; // 24515

end.