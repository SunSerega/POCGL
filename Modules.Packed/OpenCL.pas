
//*****************************************************************************************************\\
// Copyright (©) Sergey Latchenko ( github.com/SunSerega | forum.mmcs.sfedu.ru/u/sun_serega )
// This code is distributed under the Unlicense
// For details see LICENSE file or this:
// https://github.com/SunSerega/POCGL/blob/master/LICENSE
//*****************************************************************************************************\\
// Copyright (©) Сергей Латченко ( github.com/SunSerega | forum.mmcs.sfedu.ru/u/sun_serega )
// Данный код распространяется с лицензией Unlicense
// Подробнее в файле LICENSE или тут:
// https://github.com/SunSerega/POCGL/blob/master/LICENSE
//*****************************************************************************************************\\

///
///Код переведён отсюда:
///   https://github.com/KhronosGroup/OpenCL-Docs/tree/master/xml
///
///Спецификации всех версий OpenCL:
///   https://www.khronos.org/registry/OpenCL/
///
///Если чего-либо не хватает, или найдена ошибка - писать сюда:
///   https://github.com/SunSerega/POCGL/issues
///
unit OpenCL;

{$zerobasedstrings}

interface

uses System;
uses System.Runtime.InteropServices;
uses System.Runtime.CompilerServices;

type
  
  {$region Вспомогательные типы}
  
  ///
  clAcceleratorInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ACCELERATOR_DESCRIPTOR:      clAcceleratorInfo read new clAcceleratorInfo($4090);
    public static property ACCELERATOR_REFERENCE_COUNT: clAcceleratorInfo read new clAcceleratorInfo($4091);
    public static property ACCELERATOR_CONTEXT:         clAcceleratorInfo read new clAcceleratorInfo($4092);
    public static property ACCELERATOR_TYPE:            clAcceleratorInfo read new clAcceleratorInfo($4093);
    
    public function ToString: string; override;
    begin
      if ACCELERATOR_DESCRIPTOR = self then
        Result := 'ACCELERATOR_DESCRIPTOR' else
      if ACCELERATOR_REFERENCE_COUNT = self then
        Result := 'ACCELERATOR_REFERENCE_COUNT' else
      if ACCELERATOR_CONTEXT = self then
        Result := 'ACCELERATOR_CONTEXT' else
      if ACCELERATOR_TYPE = self then
        Result := 'ACCELERATOR_TYPE' else
        Result := $'clAcceleratorInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clAcceleratorType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ACCELERATOR_TYPE_MOTION_ESTIMATION: clAcceleratorType read new clAcceleratorType(0);
    
    public function ToString: string; override;
    begin
      if ACCELERATOR_TYPE_MOTION_ESTIMATION = self then
        Result := 'ACCELERATOR_TYPE_MOTION_ESTIMATION' else
        Result := $'clAcceleratorType[{self.val}]';
    end;
    
  end;
  
  ///
  clAddressingMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ADDRESS_NONE:            clAddressingMode read new clAddressingMode($1130);
    public static property ADDRESS_CLAMP_TO_EDGE:   clAddressingMode read new clAddressingMode($1131);
    public static property ADDRESS_CLAMP:           clAddressingMode read new clAddressingMode($1132);
    public static property ADDRESS_REPEAT:          clAddressingMode read new clAddressingMode($1133);
    public static property ADDRESS_MIRRORED_REPEAT: clAddressingMode read new clAddressingMode($1134);
    
    public function ToString: string; override;
    begin
      if ADDRESS_NONE = self then
        Result := 'ADDRESS_NONE' else
      if ADDRESS_CLAMP_TO_EDGE = self then
        Result := 'ADDRESS_CLAMP_TO_EDGE' else
      if ADDRESS_CLAMP = self then
        Result := 'ADDRESS_CLAMP' else
      if ADDRESS_REPEAT = self then
        Result := 'ADDRESS_REPEAT' else
      if ADDRESS_MIRRORED_REPEAT = self then
        Result := 'ADDRESS_MIRRORED_REPEAT' else
        Result := $'clAddressingMode[{self.val}]';
    end;
    
  end;
  
  ///
  clAllocationType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MEM_ION_HOST_PTR:                   clAllocationType read new clAllocationType($40A8);
    public static property MEM_ANDROID_NATIVE_BUFFER_HOST_PTR: clAllocationType read new clAllocationType($40C6);
    
    public function ToString: string; override;
    begin
      if MEM_ION_HOST_PTR = self then
        Result := 'MEM_ION_HOST_PTR' else
      if MEM_ANDROID_NATIVE_BUFFER_HOST_PTR = self then
        Result := 'MEM_ANDROID_NATIVE_BUFFER_HOST_PTR' else
        Result := $'clAllocationType[{self.val}]';
    end;
    
  end;
  
  ///
  clBool = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FALSE:        clBool read new clBool(0);
    public static property NON_BLOCKING: clBool read new clBool(0);
    public static property TRUE:         clBool read new clBool($0001);
    public static property BLOCKING:     clBool read new clBool($0001);
    
    public function ToString: string; override;
    begin
      if FALSE = self then
        Result := 'FALSE' else
      if TRUE = self then
        Result := 'TRUE' else
        Result := $'clBool[{self.val}]';
    end;
    
    public static function operator implicit(b: clBool): boolean := b<>FALSE;
    public static function operator implicit(b: boolean): clBool := new clBool(UInt32(b));
    
    public static function operator not(b: clBool): clBool := if b then FALSE else TRUE;
    
  end;
  
  ///
  clBufferCreateType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BUFFER_CREATE_TYPE_REGION: clBufferCreateType read new clBufferCreateType($1220);
    
    public function ToString: string; override;
    begin
      if BUFFER_CREATE_TYPE_REGION = self then
        Result := 'BUFFER_CREATE_TYPE_REGION' else
        Result := $'clBufferCreateType[{self.val}]';
    end;
    
  end;
  
  ///
  clBuildStatus = record
    public val: Int32;
    public constructor(val: Int32) := self.val := val;
    
    public static property BUILD_SUCCESS:     clBuildStatus read new clBuildStatus(0);
    public static property BUILD_NONE:        clBuildStatus read new clBuildStatus(-1);
    public static property BUILD_ERROR:       clBuildStatus read new clBuildStatus(-2);
    public static property BUILD_IN_PROGRESS: clBuildStatus read new clBuildStatus(-3);
    
    public function ToString: string; override;
    begin
      if BUILD_SUCCESS = self then
        Result := 'BUILD_SUCCESS' else
      if BUILD_NONE = self then
        Result := 'BUILD_NONE' else
      if BUILD_ERROR = self then
        Result := 'BUILD_ERROR' else
      if BUILD_IN_PROGRESS = self then
        Result := 'BUILD_IN_PROGRESS' else
        Result := $'clBuildStatus[{self.val}]';
    end;
    
  end;
  
  ///
  clChannelOrder = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property R:             clChannelOrder read new clChannelOrder($10B0);
    public static property A:             clChannelOrder read new clChannelOrder($10B1);
    public static property RG:            clChannelOrder read new clChannelOrder($10B2);
    public static property RA:            clChannelOrder read new clChannelOrder($10B3);
    public static property RGB:           clChannelOrder read new clChannelOrder($10B4);
    public static property RGBA:          clChannelOrder read new clChannelOrder($10B5);
    public static property BGRA:          clChannelOrder read new clChannelOrder($10B6);
    public static property ARGB:          clChannelOrder read new clChannelOrder($10B7);
    public static property INTENSITY:     clChannelOrder read new clChannelOrder($10B8);
    public static property LUMINANCE:     clChannelOrder read new clChannelOrder($10B9);
    public static property Rx:            clChannelOrder read new clChannelOrder($10BA);
    public static property RGx:           clChannelOrder read new clChannelOrder($10BB);
    public static property RGBx:          clChannelOrder read new clChannelOrder($10BC);
    public static property DEPTH:         clChannelOrder read new clChannelOrder($10BD);
    public static property DEPTH_STENCIL: clChannelOrder read new clChannelOrder($10BE);
    public static property sRGB:          clChannelOrder read new clChannelOrder($10BF);
    public static property sRGBx:         clChannelOrder read new clChannelOrder($10C0);
    public static property sRGBA:         clChannelOrder read new clChannelOrder($10C1);
    public static property sBGRA:         clChannelOrder read new clChannelOrder($10C2);
    public static property ABGR:          clChannelOrder read new clChannelOrder($10C3);
    public static property YUYV:          clChannelOrder read new clChannelOrder($4076);
    public static property UYVY:          clChannelOrder read new clChannelOrder($4077);
    public static property YVYU:          clChannelOrder read new clChannelOrder($4078);
    public static property VYUY:          clChannelOrder read new clChannelOrder($4079);
    public static property NV21:          clChannelOrder read new clChannelOrder($40D0);
    public static property YV12:          clChannelOrder read new clChannelOrder($40D1);
    public static property NV12:          clChannelOrder read new clChannelOrder($410E);
    
    public function ToString: string; override;
    begin
      if R = self then
        Result := 'R' else
      if A = self then
        Result := 'A' else
      if RG = self then
        Result := 'RG' else
      if RA = self then
        Result := 'RA' else
      if RGB = self then
        Result := 'RGB' else
      if RGBA = self then
        Result := 'RGBA' else
      if BGRA = self then
        Result := 'BGRA' else
      if ARGB = self then
        Result := 'ARGB' else
      if INTENSITY = self then
        Result := 'INTENSITY' else
      if LUMINANCE = self then
        Result := 'LUMINANCE' else
      if Rx = self then
        Result := 'Rx' else
      if RGx = self then
        Result := 'RGx' else
      if RGBx = self then
        Result := 'RGBx' else
      if DEPTH = self then
        Result := 'DEPTH' else
      if DEPTH_STENCIL = self then
        Result := 'DEPTH_STENCIL' else
      if sRGB = self then
        Result := 'sRGB' else
      if sRGBx = self then
        Result := 'sRGBx' else
      if sRGBA = self then
        Result := 'sRGBA' else
      if sBGRA = self then
        Result := 'sBGRA' else
      if ABGR = self then
        Result := 'ABGR' else
      if YUYV = self then
        Result := 'YUYV' else
      if UYVY = self then
        Result := 'UYVY' else
      if YVYU = self then
        Result := 'YVYU' else
      if VYUY = self then
        Result := 'VYUY' else
      if NV21 = self then
        Result := 'NV21' else
      if YV12 = self then
        Result := 'YV12' else
      if NV12 = self then
        Result := 'NV12' else
        Result := $'clChannelOrder[{self.val}]';
    end;
    
  end;
  
  ///
  clChannelType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SNORM_INT8:         clChannelType read new clChannelType($10D0);
    public static property SNORM_INT16:        clChannelType read new clChannelType($10D1);
    public static property UNORM_INT8:         clChannelType read new clChannelType($10D2);
    public static property UNORM_INT16:        clChannelType read new clChannelType($10D3);
    public static property UNORM_SHORT_565:    clChannelType read new clChannelType($10D4);
    public static property UNORM_SHORT_555:    clChannelType read new clChannelType($10D5);
    public static property UNORM_INT_101010:   clChannelType read new clChannelType($10D6);
    public static property SIGNED_INT8:        clChannelType read new clChannelType($10D7);
    public static property SIGNED_INT16:       clChannelType read new clChannelType($10D8);
    public static property SIGNED_INT32:       clChannelType read new clChannelType($10D9);
    public static property UNSIGNED_INT8:      clChannelType read new clChannelType($10DA);
    public static property UNSIGNED_INT16:     clChannelType read new clChannelType($10DB);
    public static property UNSIGNED_INT32:     clChannelType read new clChannelType($10DC);
    public static property HALF_FLOAT:         clChannelType read new clChannelType($10DD);
    public static property FLOAT:              clChannelType read new clChannelType($10DE);
    public static property UNORM_INT24:        clChannelType read new clChannelType($10DF);
    public static property UNORM_INT_101010_2: clChannelType read new clChannelType($10E0);
    public static property UNSIGNED_INT_RAW10: clChannelType read new clChannelType($10E3);
    public static property UNSIGNED_INT_RAW12: clChannelType read new clChannelType($10E4);
    
    public function ToString: string; override;
    begin
      if SNORM_INT8 = self then
        Result := 'SNORM_INT8' else
      if SNORM_INT16 = self then
        Result := 'SNORM_INT16' else
      if UNORM_INT8 = self then
        Result := 'UNORM_INT8' else
      if UNORM_INT16 = self then
        Result := 'UNORM_INT16' else
      if UNORM_SHORT_565 = self then
        Result := 'UNORM_SHORT_565' else
      if UNORM_SHORT_555 = self then
        Result := 'UNORM_SHORT_555' else
      if UNORM_INT_101010 = self then
        Result := 'UNORM_INT_101010' else
      if SIGNED_INT8 = self then
        Result := 'SIGNED_INT8' else
      if SIGNED_INT16 = self then
        Result := 'SIGNED_INT16' else
      if SIGNED_INT32 = self then
        Result := 'SIGNED_INT32' else
      if UNSIGNED_INT8 = self then
        Result := 'UNSIGNED_INT8' else
      if UNSIGNED_INT16 = self then
        Result := 'UNSIGNED_INT16' else
      if UNSIGNED_INT32 = self then
        Result := 'UNSIGNED_INT32' else
      if HALF_FLOAT = self then
        Result := 'HALF_FLOAT' else
      if FLOAT = self then
        Result := 'FLOAT' else
      if UNORM_INT24 = self then
        Result := 'UNORM_INT24' else
      if UNORM_INT_101010_2 = self then
        Result := 'UNORM_INT_101010_2' else
      if UNSIGNED_INT_RAW10 = self then
        Result := 'UNSIGNED_INT_RAW10' else
      if UNSIGNED_INT_RAW12 = self then
        Result := 'UNSIGNED_INT_RAW12' else
        Result := $'clChannelType[{self.val}]';
    end;
    
  end;
  
  ///
  clCommandBufferInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property COMMAND_BUFFER_QUEUES:           clCommandBufferInfo read new clCommandBufferInfo($1294);
    public static property COMMAND_BUFFER_NUM_QUEUES:       clCommandBufferInfo read new clCommandBufferInfo($1295);
    public static property COMMAND_BUFFER_REFERENCE_COUNT:  clCommandBufferInfo read new clCommandBufferInfo($1296);
    public static property COMMAND_BUFFER_STATE:            clCommandBufferInfo read new clCommandBufferInfo($1297);
    public static property COMMAND_BUFFER_PROPERTIES_ARRAY: clCommandBufferInfo read new clCommandBufferInfo($1298);
    public static property COMMAND_BUFFER_CONTEXT:          clCommandBufferInfo read new clCommandBufferInfo($1299);
    
    public function ToString: string; override;
    begin
      if COMMAND_BUFFER_QUEUES = self then
        Result := 'COMMAND_BUFFER_QUEUES' else
      if COMMAND_BUFFER_NUM_QUEUES = self then
        Result := 'COMMAND_BUFFER_NUM_QUEUES' else
      if COMMAND_BUFFER_REFERENCE_COUNT = self then
        Result := 'COMMAND_BUFFER_REFERENCE_COUNT' else
      if COMMAND_BUFFER_STATE = self then
        Result := 'COMMAND_BUFFER_STATE' else
      if COMMAND_BUFFER_PROPERTIES_ARRAY = self then
        Result := 'COMMAND_BUFFER_PROPERTIES_ARRAY' else
      if COMMAND_BUFFER_CONTEXT = self then
        Result := 'COMMAND_BUFFER_CONTEXT' else
        Result := $'clCommandBufferInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clCommandBufferProperties = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property COMMAND_BUFFER_FLAGS: clCommandBufferProperties read new clCommandBufferProperties($1293);
    
    public function ToString: string; override;
    begin
      if COMMAND_BUFFER_FLAGS = self then
        Result := 'COMMAND_BUFFER_FLAGS' else
        Result := $'clCommandBufferProperties[{self.val}]';
    end;
    
  end;
  
  ///
  clCommandBufferState = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property COMMAND_BUFFER_STATE_RECORDING:  clCommandBufferState read new clCommandBufferState(0);
    public static property COMMAND_BUFFER_STATE_EXECUTABLE: clCommandBufferState read new clCommandBufferState($0001);
    public static property COMMAND_BUFFER_STATE_PENDING:    clCommandBufferState read new clCommandBufferState($0002);
    
    public function ToString: string; override;
    begin
      if COMMAND_BUFFER_STATE_RECORDING = self then
        Result := 'COMMAND_BUFFER_STATE_RECORDING' else
      if COMMAND_BUFFER_STATE_EXECUTABLE = self then
        Result := 'COMMAND_BUFFER_STATE_EXECUTABLE' else
      if COMMAND_BUFFER_STATE_PENDING = self then
        Result := 'COMMAND_BUFFER_STATE_PENDING' else
        Result := $'clCommandBufferState[{self.val}]';
    end;
    
  end;
  
  ///
  clCommandBufferStructureType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property STRUCTURE_TYPE_MUTABLE_BASE_CONFIG:     clCommandBufferStructureType read new clCommandBufferStructureType(0);
    public static property STRUCTURE_TYPE_MUTABLE_DISPATCH_CONFIG: clCommandBufferStructureType read new clCommandBufferStructureType($0001);
    
    public function ToString: string; override;
    begin
      if STRUCTURE_TYPE_MUTABLE_BASE_CONFIG = self then
        Result := 'STRUCTURE_TYPE_MUTABLE_BASE_CONFIG' else
      if STRUCTURE_TYPE_MUTABLE_DISPATCH_CONFIG = self then
        Result := 'STRUCTURE_TYPE_MUTABLE_DISPATCH_CONFIG' else
        Result := $'clCommandBufferStructureType[{self.val}]';
    end;
    
  end;
  
  ///
  clCommandExecutionStatus = record
    public val: Int32;
    public constructor(val: Int32) := self.val := val;
    
    public static property COMPLETE:  clCommandExecutionStatus read new clCommandExecutionStatus(0);
    public static property RUNNING:   clCommandExecutionStatus read new clCommandExecutionStatus($0001);
    public static property SUBMITTED: clCommandExecutionStatus read new clCommandExecutionStatus($0002);
    public static property QUEUED:    clCommandExecutionStatus read new clCommandExecutionStatus($0003);
    
    public function ToString: string; override;
    begin
      if COMPLETE = self then
        Result := 'COMPLETE' else
      if RUNNING = self then
        Result := 'RUNNING' else
      if SUBMITTED = self then
        Result := 'SUBMITTED' else
      if QUEUED = self then
        Result := 'QUEUED' else
        Result := $'clCommandExecutionStatus[{self.val}]';
    end;
    
    public function IS_ERROR := val < 0;
    
  end;
  
  ///
  clCommandQueueCapabilities = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property QUEUE_DEFAULT_CAPABILITIES:                    clCommandQueueCapabilities read new clCommandQueueCapabilities(0);
    public static property QUEUE_CAPABILITY_CREATE_SINGLE_QUEUE_EVENTS:   clCommandQueueCapabilities read new clCommandQueueCapabilities(1 shl 0);
    public static property QUEUE_CAPABILITY_CREATE_CROSS_QUEUE_EVENTS:    clCommandQueueCapabilities read new clCommandQueueCapabilities(1 shl 1);
    public static property QUEUE_CAPABILITY_SINGLE_QUEUE_EVENT_WAIT_LIST: clCommandQueueCapabilities read new clCommandQueueCapabilities(1 shl 2);
    public static property QUEUE_CAPABILITY_CROSS_QUEUE_EVENT_WAIT_LIST:  clCommandQueueCapabilities read new clCommandQueueCapabilities(1 shl 3);
    public static property QUEUE_CAPABILITY_TRANSFER_BUFFER:              clCommandQueueCapabilities read new clCommandQueueCapabilities(1 shl 8);
    public static property QUEUE_CAPABILITY_TRANSFER_BUFFER_RECT:         clCommandQueueCapabilities read new clCommandQueueCapabilities(1 shl 9);
    public static property QUEUE_CAPABILITY_MAP_BUFFER:                   clCommandQueueCapabilities read new clCommandQueueCapabilities(1 shl 10);
    public static property QUEUE_CAPABILITY_FILL_BUFFER:                  clCommandQueueCapabilities read new clCommandQueueCapabilities(1 shl 11);
    public static property QUEUE_CAPABILITY_TRANSFER_IMAGE:               clCommandQueueCapabilities read new clCommandQueueCapabilities(1 shl 12);
    public static property QUEUE_CAPABILITY_MAP_IMAGE:                    clCommandQueueCapabilities read new clCommandQueueCapabilities(1 shl 13);
    public static property QUEUE_CAPABILITY_FILL_IMAGE:                   clCommandQueueCapabilities read new clCommandQueueCapabilities(1 shl 14);
    public static property QUEUE_CAPABILITY_TRANSFER_BUFFER_IMAGE:        clCommandQueueCapabilities read new clCommandQueueCapabilities(1 shl 15);
    public static property QUEUE_CAPABILITY_TRANSFER_IMAGE_BUFFER:        clCommandQueueCapabilities read new clCommandQueueCapabilities(1 shl 16);
    public static property QUEUE_CAPABILITY_MARKER:                       clCommandQueueCapabilities read new clCommandQueueCapabilities(1 shl 24);
    public static property QUEUE_CAPABILITY_BARRIER:                      clCommandQueueCapabilities read new clCommandQueueCapabilities(1 shl 25);
    public static property QUEUE_CAPABILITY_KERNEL:                       clCommandQueueCapabilities read new clCommandQueueCapabilities(1 shl 26);
    
    public property ANY_FLAGS: boolean read self.val<>0;
    
    public static function operator+(v1, v2: clCommandQueueCapabilities) := new clCommandQueueCapabilities(v1.val or v2.val);
    public static function operator or(v1, v2: clCommandQueueCapabilities) := new clCommandQueueCapabilities(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clCommandQueueCapabilities; v2: clCommandQueueCapabilities) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clCommandQueueCapabilities) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'QUEUE_DEFAULT_CAPABILITIES';
        exit;
      end;
      if QUEUE_CAPABILITY_CREATE_SINGLE_QUEUE_EVENTS in self then
      begin
        res += 'QUEUE_CAPABILITY_CREATE_SINGLE_QUEUE_EVENTS+';
        left_val := left_val and not QUEUE_CAPABILITY_CREATE_SINGLE_QUEUE_EVENTS.val;
      end;
      if QUEUE_CAPABILITY_CREATE_CROSS_QUEUE_EVENTS in self then
      begin
        res += 'QUEUE_CAPABILITY_CREATE_CROSS_QUEUE_EVENTS+';
        left_val := left_val and not QUEUE_CAPABILITY_CREATE_CROSS_QUEUE_EVENTS.val;
      end;
      if QUEUE_CAPABILITY_SINGLE_QUEUE_EVENT_WAIT_LIST in self then
      begin
        res += 'QUEUE_CAPABILITY_SINGLE_QUEUE_EVENT_WAIT_LIST+';
        left_val := left_val and not QUEUE_CAPABILITY_SINGLE_QUEUE_EVENT_WAIT_LIST.val;
      end;
      if QUEUE_CAPABILITY_CROSS_QUEUE_EVENT_WAIT_LIST in self then
      begin
        res += 'QUEUE_CAPABILITY_CROSS_QUEUE_EVENT_WAIT_LIST+';
        left_val := left_val and not QUEUE_CAPABILITY_CROSS_QUEUE_EVENT_WAIT_LIST.val;
      end;
      if QUEUE_CAPABILITY_TRANSFER_BUFFER in self then
      begin
        res += 'QUEUE_CAPABILITY_TRANSFER_BUFFER+';
        left_val := left_val and not QUEUE_CAPABILITY_TRANSFER_BUFFER.val;
      end;
      if QUEUE_CAPABILITY_TRANSFER_BUFFER_RECT in self then
      begin
        res += 'QUEUE_CAPABILITY_TRANSFER_BUFFER_RECT+';
        left_val := left_val and not QUEUE_CAPABILITY_TRANSFER_BUFFER_RECT.val;
      end;
      if QUEUE_CAPABILITY_MAP_BUFFER in self then
      begin
        res += 'QUEUE_CAPABILITY_MAP_BUFFER+';
        left_val := left_val and not QUEUE_CAPABILITY_MAP_BUFFER.val;
      end;
      if QUEUE_CAPABILITY_FILL_BUFFER in self then
      begin
        res += 'QUEUE_CAPABILITY_FILL_BUFFER+';
        left_val := left_val and not QUEUE_CAPABILITY_FILL_BUFFER.val;
      end;
      if QUEUE_CAPABILITY_TRANSFER_IMAGE in self then
      begin
        res += 'QUEUE_CAPABILITY_TRANSFER_IMAGE+';
        left_val := left_val and not QUEUE_CAPABILITY_TRANSFER_IMAGE.val;
      end;
      if QUEUE_CAPABILITY_MAP_IMAGE in self then
      begin
        res += 'QUEUE_CAPABILITY_MAP_IMAGE+';
        left_val := left_val and not QUEUE_CAPABILITY_MAP_IMAGE.val;
      end;
      if QUEUE_CAPABILITY_FILL_IMAGE in self then
      begin
        res += 'QUEUE_CAPABILITY_FILL_IMAGE+';
        left_val := left_val and not QUEUE_CAPABILITY_FILL_IMAGE.val;
      end;
      if QUEUE_CAPABILITY_TRANSFER_BUFFER_IMAGE in self then
      begin
        res += 'QUEUE_CAPABILITY_TRANSFER_BUFFER_IMAGE+';
        left_val := left_val and not QUEUE_CAPABILITY_TRANSFER_BUFFER_IMAGE.val;
      end;
      if QUEUE_CAPABILITY_TRANSFER_IMAGE_BUFFER in self then
      begin
        res += 'QUEUE_CAPABILITY_TRANSFER_IMAGE_BUFFER+';
        left_val := left_val and not QUEUE_CAPABILITY_TRANSFER_IMAGE_BUFFER.val;
      end;
      if QUEUE_CAPABILITY_MARKER in self then
      begin
        res += 'QUEUE_CAPABILITY_MARKER+';
        left_val := left_val and not QUEUE_CAPABILITY_MARKER.val;
      end;
      if QUEUE_CAPABILITY_BARRIER in self then
      begin
        res += 'QUEUE_CAPABILITY_BARRIER+';
        left_val := left_val and not QUEUE_CAPABILITY_BARRIER.val;
      end;
      if QUEUE_CAPABILITY_KERNEL in self then
      begin
        res += 'QUEUE_CAPABILITY_KERNEL+';
        left_val := left_val and not QUEUE_CAPABILITY_KERNEL.val;
      end;
      if left_val<>0 then
      begin
        res += 'clCommandQueueCapabilities[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clCommandQueueInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property QUEUE_CONTEXT:          clCommandQueueInfo read new clCommandQueueInfo($1090);
    public static property QUEUE_DEVICE:           clCommandQueueInfo read new clCommandQueueInfo($1091);
    public static property QUEUE_REFERENCE_COUNT:  clCommandQueueInfo read new clCommandQueueInfo($1092);
    public static property QUEUE_PROPERTIES:       clCommandQueueInfo read new clCommandQueueInfo($1093);
    public static property QUEUE_SIZE:             clCommandQueueInfo read new clCommandQueueInfo($1094);
    public static property QUEUE_DEVICE_DEFAULT:   clCommandQueueInfo read new clCommandQueueInfo($1095);
    public static property QUEUE_PROPERTIES_ARRAY: clCommandQueueInfo read new clCommandQueueInfo($1098);
    public static property QUEUE_FAMILY:           clCommandQueueInfo read new clCommandQueueInfo($418C);
    public static property QUEUE_INDEX:            clCommandQueueInfo read new clCommandQueueInfo($418D);
    
    public function ToString: string; override;
    begin
      if QUEUE_CONTEXT = self then
        Result := 'QUEUE_CONTEXT' else
      if QUEUE_DEVICE = self then
        Result := 'QUEUE_DEVICE' else
      if QUEUE_REFERENCE_COUNT = self then
        Result := 'QUEUE_REFERENCE_COUNT' else
      if QUEUE_PROPERTIES = self then
        Result := 'QUEUE_PROPERTIES' else
      if QUEUE_SIZE = self then
        Result := 'QUEUE_SIZE' else
      if QUEUE_DEVICE_DEFAULT = self then
        Result := 'QUEUE_DEVICE_DEFAULT' else
      if QUEUE_PROPERTIES_ARRAY = self then
        Result := 'QUEUE_PROPERTIES_ARRAY' else
      if QUEUE_FAMILY = self then
        Result := 'QUEUE_FAMILY' else
      if QUEUE_INDEX = self then
        Result := 'QUEUE_INDEX' else
        Result := $'clCommandQueueInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clCommandQueueProperties = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property NONE:                                clCommandQueueProperties read new clCommandQueueProperties(0);
    public static property QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE: clCommandQueueProperties read new clCommandQueueProperties(1 shl 0);
    public static property QUEUE_PROFILING_ENABLE:              clCommandQueueProperties read new clCommandQueueProperties(1 shl 1);
    public static property QUEUE_ON_DEVICE:                     clCommandQueueProperties read new clCommandQueueProperties(1 shl 2);
    public static property QUEUE_ON_DEVICE_DEFAULT:             clCommandQueueProperties read new clCommandQueueProperties(1 shl 3);
    public static property QUEUE_NO_SYNC_OPERATIONS:            clCommandQueueProperties read new clCommandQueueProperties(1 shl 29);
    public static property QUEUE_THREAD_LOCAL_EXEC_ENABLE:      clCommandQueueProperties read new clCommandQueueProperties(1 shl 31);
    
    public property ANY_FLAGS: boolean read self.val<>0;
    
    public static function operator+(v1, v2: clCommandQueueProperties) := new clCommandQueueProperties(v1.val or v2.val);
    public static function operator or(v1, v2: clCommandQueueProperties) := new clCommandQueueProperties(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clCommandQueueProperties; v2: clCommandQueueProperties) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clCommandQueueProperties) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'NONE';
        exit;
      end;
      if QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE in self then
      begin
        res += 'QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE+';
        left_val := left_val and not QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE.val;
      end;
      if QUEUE_PROFILING_ENABLE in self then
      begin
        res += 'QUEUE_PROFILING_ENABLE+';
        left_val := left_val and not QUEUE_PROFILING_ENABLE.val;
      end;
      if QUEUE_ON_DEVICE in self then
      begin
        res += 'QUEUE_ON_DEVICE+';
        left_val := left_val and not QUEUE_ON_DEVICE.val;
      end;
      if QUEUE_ON_DEVICE_DEFAULT in self then
      begin
        res += 'QUEUE_ON_DEVICE_DEFAULT+';
        left_val := left_val and not QUEUE_ON_DEVICE_DEFAULT.val;
      end;
      if QUEUE_NO_SYNC_OPERATIONS in self then
      begin
        res += 'QUEUE_NO_SYNC_OPERATIONS+';
        left_val := left_val and not QUEUE_NO_SYNC_OPERATIONS.val;
      end;
      if QUEUE_THREAD_LOCAL_EXEC_ENABLE in self then
      begin
        res += 'QUEUE_THREAD_LOCAL_EXEC_ENABLE+';
        left_val := left_val and not QUEUE_THREAD_LOCAL_EXEC_ENABLE.val;
      end;
      if left_val<>0 then
      begin
        res += 'clCommandQueueProperties[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clCommandTerminationReason = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property COMMAND_TERMINATION_COMPLETION:         clCommandTerminationReason read new clCommandTerminationReason(0);
    public static property COMMAND_TERMINATION_CONTROLLED_SUCCESS: clCommandTerminationReason read new clCommandTerminationReason($0001);
    public static property COMMAND_TERMINATION_CONTROLLED_FAILURE: clCommandTerminationReason read new clCommandTerminationReason($0002);
    public static property COMMAND_TERMINATION_ERROR:              clCommandTerminationReason read new clCommandTerminationReason($0003);
    
    public function ToString: string; override;
    begin
      if COMMAND_TERMINATION_COMPLETION = self then
        Result := 'COMMAND_TERMINATION_COMPLETION' else
      if COMMAND_TERMINATION_CONTROLLED_SUCCESS = self then
        Result := 'COMMAND_TERMINATION_CONTROLLED_SUCCESS' else
      if COMMAND_TERMINATION_CONTROLLED_FAILURE = self then
        Result := 'COMMAND_TERMINATION_CONTROLLED_FAILURE' else
      if COMMAND_TERMINATION_ERROR = self then
        Result := 'COMMAND_TERMINATION_ERROR' else
        Result := $'clCommandTerminationReason[{self.val}]';
    end;
    
  end;
  
  ///
  clCommandType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property COMMAND_NDRANGE_KERNEL:                clCommandType read new clCommandType($11F0);
    public static property COMMAND_TASK:                          clCommandType read new clCommandType($11F1);
    public static property COMMAND_NATIVE_KERNEL:                 clCommandType read new clCommandType($11F2);
    public static property COMMAND_READ_BUFFER:                   clCommandType read new clCommandType($11F3);
    public static property COMMAND_WRITE_BUFFER:                  clCommandType read new clCommandType($11F4);
    public static property COMMAND_COPY_BUFFER:                   clCommandType read new clCommandType($11F5);
    public static property COMMAND_READ_IMAGE:                    clCommandType read new clCommandType($11F6);
    public static property COMMAND_WRITE_IMAGE:                   clCommandType read new clCommandType($11F7);
    public static property COMMAND_COPY_IMAGE:                    clCommandType read new clCommandType($11F8);
    public static property COMMAND_COPY_IMAGE_TO_BUFFER:          clCommandType read new clCommandType($11F9);
    public static property COMMAND_COPY_BUFFER_TO_IMAGE:          clCommandType read new clCommandType($11FA);
    public static property COMMAND_MAP_BUFFER:                    clCommandType read new clCommandType($11FB);
    public static property COMMAND_MAP_IMAGE:                     clCommandType read new clCommandType($11FC);
    public static property COMMAND_UNMAP_MEM_OBJECT:              clCommandType read new clCommandType($11FD);
    public static property COMMAND_MARKER:                        clCommandType read new clCommandType($11FE);
    public static property COMMAND_ACQUIRE_GL_OBJECTS:            clCommandType read new clCommandType($11FF);
    public static property COMMAND_RELEASE_GL_OBJECTS:            clCommandType read new clCommandType($1200);
    public static property COMMAND_READ_BUFFER_RECT:              clCommandType read new clCommandType($1201);
    public static property COMMAND_WRITE_BUFFER_RECT:             clCommandType read new clCommandType($1202);
    public static property COMMAND_COPY_BUFFER_RECT:              clCommandType read new clCommandType($1203);
    public static property COMMAND_USER:                          clCommandType read new clCommandType($1204);
    public static property COMMAND_BARRIER:                       clCommandType read new clCommandType($1205);
    public static property COMMAND_MIGRATE_MEM_OBJECTS:           clCommandType read new clCommandType($1206);
    public static property COMMAND_FILL_BUFFER:                   clCommandType read new clCommandType($1207);
    public static property COMMAND_FILL_IMAGE:                    clCommandType read new clCommandType($1208);
    public static property COMMAND_SVM_FREE:                      clCommandType read new clCommandType($1209);
    public static property COMMAND_SVM_MEMCPY:                    clCommandType read new clCommandType($120A);
    public static property COMMAND_SVM_MEMFILL:                   clCommandType read new clCommandType($120B);
    public static property COMMAND_SVM_MAP:                       clCommandType read new clCommandType($120C);
    public static property COMMAND_SVM_UNMAP:                     clCommandType read new clCommandType($120D);
    public static property COMMAND_SVM_MIGRATE_MEM:               clCommandType read new clCommandType($120E);
    public static property COMMAND_COMMAND_BUFFER:                clCommandType read new clCommandType($12A8);
    public static property COMMAND_GL_FENCE_SYNC_OBJECT:          clCommandType read new clCommandType($200D);
    public static property COMMAND_ACQUIRE_DX9_MEDIA_SURFACES:    clCommandType read new clCommandType($202B);
    public static property COMMAND_RELEASE_DX9_MEDIA_SURFACES:    clCommandType read new clCommandType($202C);
    public static property COMMAND_ACQUIRE_EGL_OBJECTS:           clCommandType read new clCommandType($202D);
    public static property COMMAND_RELEASE_EGL_OBJECTS:           clCommandType read new clCommandType($202E);
    public static property COMMAND_EGL_FENCE_SYNC_OBJECT:         clCommandType read new clCommandType($202F);
    public static property COMMAND_SEMAPHORE_WAIT:                clCommandType read new clCommandType($2042);
    public static property COMMAND_SEMAPHORE_SIGNAL:              clCommandType read new clCommandType($2043);
    public static property COMMAND_ACQUIRE_EXTERNAL_MEM_OBJECTS:  clCommandType read new clCommandType($2047);
    public static property COMMAND_RELEASE_EXTERNAL_MEM_OBJECTS:  clCommandType read new clCommandType($2048);
    public static property COMMAND_ACQUIRE_D3D10_OBJECTS:         clCommandType read new clCommandType($4017);
    public static property COMMAND_RELEASE_D3D10_OBJECTS:         clCommandType read new clCommandType($4018);
    public static property COMMAND_ACQUIRE_D3D11_OBJECTS:         clCommandType read new clCommandType($4020);
    public static property COMMAND_RELEASE_D3D11_OBJECTS:         clCommandType read new clCommandType($4021);
    public static property COMMAND_ACQUIRE_DX9_OBJECTS:           clCommandType read new clCommandType($402A);
    public static property COMMAND_RELEASE_DX9_OBJECTS:           clCommandType read new clCommandType($402B);
    public static property COMMAND_MIGRATE_MEM_OBJECT:            clCommandType read new clCommandType($4040);
    public static property COMMAND_ACQUIRE_VA_API_MEDIA_SURFACES: clCommandType read new clCommandType($409A);
    public static property COMMAND_RELEASE_VA_API_MEDIA_SURFACES: clCommandType read new clCommandType($409B);
    public static property COMMAND_SVM_FREE_ARM:                  clCommandType read new clCommandType($40BA);
    public static property COMMAND_SVM_MEMCPY_ARM:                clCommandType read new clCommandType($40BB);
    public static property COMMAND_SVM_MEMFILL_ARM:               clCommandType read new clCommandType($40BC);
    public static property COMMAND_SVM_MAP_ARM:                   clCommandType read new clCommandType($40BD);
    public static property COMMAND_SVM_UNMAP_ARM:                 clCommandType read new clCommandType($40BE);
    public static property COMMAND_ACQUIRE_GRALLOC_OBJECTS:       clCommandType read new clCommandType($40D2);
    public static property COMMAND_RELEASE_GRALLOC_OBJECTS:       clCommandType read new clCommandType($40D3);
    public static property COMMAND_GENERATE_MIPMAP:               clCommandType read new clCommandType($40D6);
    public static property COMMAND_MEMFILL:                       clCommandType read new clCommandType($4204);
    public static property COMMAND_MEMCPY:                        clCommandType read new clCommandType($4205);
    public static property COMMAND_MIGRATEMEM:                    clCommandType read new clCommandType($4206);
    public static property COMMAND_MEMADVISE:                     clCommandType read new clCommandType($4207);
    public static property COMMAND_READ_HOST_PIPE:                clCommandType read new clCommandType($4214);
    public static property COMMAND_WRITE_HOST_PIPE:               clCommandType read new clCommandType($4215);
    
    public function ToString: string; override;
    begin
      if COMMAND_NDRANGE_KERNEL = self then
        Result := 'COMMAND_NDRANGE_KERNEL' else
      if COMMAND_TASK = self then
        Result := 'COMMAND_TASK' else
      if COMMAND_NATIVE_KERNEL = self then
        Result := 'COMMAND_NATIVE_KERNEL' else
      if COMMAND_READ_BUFFER = self then
        Result := 'COMMAND_READ_BUFFER' else
      if COMMAND_WRITE_BUFFER = self then
        Result := 'COMMAND_WRITE_BUFFER' else
      if COMMAND_COPY_BUFFER = self then
        Result := 'COMMAND_COPY_BUFFER' else
      if COMMAND_READ_IMAGE = self then
        Result := 'COMMAND_READ_IMAGE' else
      if COMMAND_WRITE_IMAGE = self then
        Result := 'COMMAND_WRITE_IMAGE' else
      if COMMAND_COPY_IMAGE = self then
        Result := 'COMMAND_COPY_IMAGE' else
      if COMMAND_COPY_IMAGE_TO_BUFFER = self then
        Result := 'COMMAND_COPY_IMAGE_TO_BUFFER' else
      if COMMAND_COPY_BUFFER_TO_IMAGE = self then
        Result := 'COMMAND_COPY_BUFFER_TO_IMAGE' else
      if COMMAND_MAP_BUFFER = self then
        Result := 'COMMAND_MAP_BUFFER' else
      if COMMAND_MAP_IMAGE = self then
        Result := 'COMMAND_MAP_IMAGE' else
      if COMMAND_UNMAP_MEM_OBJECT = self then
        Result := 'COMMAND_UNMAP_MEM_OBJECT' else
      if COMMAND_MARKER = self then
        Result := 'COMMAND_MARKER' else
      if COMMAND_ACQUIRE_GL_OBJECTS = self then
        Result := 'COMMAND_ACQUIRE_GL_OBJECTS' else
      if COMMAND_RELEASE_GL_OBJECTS = self then
        Result := 'COMMAND_RELEASE_GL_OBJECTS' else
      if COMMAND_READ_BUFFER_RECT = self then
        Result := 'COMMAND_READ_BUFFER_RECT' else
      if COMMAND_WRITE_BUFFER_RECT = self then
        Result := 'COMMAND_WRITE_BUFFER_RECT' else
      if COMMAND_COPY_BUFFER_RECT = self then
        Result := 'COMMAND_COPY_BUFFER_RECT' else
      if COMMAND_USER = self then
        Result := 'COMMAND_USER' else
      if COMMAND_BARRIER = self then
        Result := 'COMMAND_BARRIER' else
      if COMMAND_MIGRATE_MEM_OBJECTS = self then
        Result := 'COMMAND_MIGRATE_MEM_OBJECTS' else
      if COMMAND_FILL_BUFFER = self then
        Result := 'COMMAND_FILL_BUFFER' else
      if COMMAND_FILL_IMAGE = self then
        Result := 'COMMAND_FILL_IMAGE' else
      if COMMAND_SVM_FREE = self then
        Result := 'COMMAND_SVM_FREE' else
      if COMMAND_SVM_MEMCPY = self then
        Result := 'COMMAND_SVM_MEMCPY' else
      if COMMAND_SVM_MEMFILL = self then
        Result := 'COMMAND_SVM_MEMFILL' else
      if COMMAND_SVM_MAP = self then
        Result := 'COMMAND_SVM_MAP' else
      if COMMAND_SVM_UNMAP = self then
        Result := 'COMMAND_SVM_UNMAP' else
      if COMMAND_SVM_MIGRATE_MEM = self then
        Result := 'COMMAND_SVM_MIGRATE_MEM' else
      if COMMAND_COMMAND_BUFFER = self then
        Result := 'COMMAND_COMMAND_BUFFER' else
      if COMMAND_GL_FENCE_SYNC_OBJECT = self then
        Result := 'COMMAND_GL_FENCE_SYNC_OBJECT' else
      if COMMAND_ACQUIRE_DX9_MEDIA_SURFACES = self then
        Result := 'COMMAND_ACQUIRE_DX9_MEDIA_SURFACES' else
      if COMMAND_RELEASE_DX9_MEDIA_SURFACES = self then
        Result := 'COMMAND_RELEASE_DX9_MEDIA_SURFACES' else
      if COMMAND_ACQUIRE_EGL_OBJECTS = self then
        Result := 'COMMAND_ACQUIRE_EGL_OBJECTS' else
      if COMMAND_RELEASE_EGL_OBJECTS = self then
        Result := 'COMMAND_RELEASE_EGL_OBJECTS' else
      if COMMAND_EGL_FENCE_SYNC_OBJECT = self then
        Result := 'COMMAND_EGL_FENCE_SYNC_OBJECT' else
      if COMMAND_SEMAPHORE_WAIT = self then
        Result := 'COMMAND_SEMAPHORE_WAIT' else
      if COMMAND_SEMAPHORE_SIGNAL = self then
        Result := 'COMMAND_SEMAPHORE_SIGNAL' else
      if COMMAND_ACQUIRE_EXTERNAL_MEM_OBJECTS = self then
        Result := 'COMMAND_ACQUIRE_EXTERNAL_MEM_OBJECTS' else
      if COMMAND_RELEASE_EXTERNAL_MEM_OBJECTS = self then
        Result := 'COMMAND_RELEASE_EXTERNAL_MEM_OBJECTS' else
      if COMMAND_ACQUIRE_D3D10_OBJECTS = self then
        Result := 'COMMAND_ACQUIRE_D3D10_OBJECTS' else
      if COMMAND_RELEASE_D3D10_OBJECTS = self then
        Result := 'COMMAND_RELEASE_D3D10_OBJECTS' else
      if COMMAND_ACQUIRE_D3D11_OBJECTS = self then
        Result := 'COMMAND_ACQUIRE_D3D11_OBJECTS' else
      if COMMAND_RELEASE_D3D11_OBJECTS = self then
        Result := 'COMMAND_RELEASE_D3D11_OBJECTS' else
      if COMMAND_ACQUIRE_DX9_OBJECTS = self then
        Result := 'COMMAND_ACQUIRE_DX9_OBJECTS' else
      if COMMAND_RELEASE_DX9_OBJECTS = self then
        Result := 'COMMAND_RELEASE_DX9_OBJECTS' else
      if COMMAND_MIGRATE_MEM_OBJECT = self then
        Result := 'COMMAND_MIGRATE_MEM_OBJECT' else
      if COMMAND_ACQUIRE_VA_API_MEDIA_SURFACES = self then
        Result := 'COMMAND_ACQUIRE_VA_API_MEDIA_SURFACES' else
      if COMMAND_RELEASE_VA_API_MEDIA_SURFACES = self then
        Result := 'COMMAND_RELEASE_VA_API_MEDIA_SURFACES' else
      if COMMAND_SVM_FREE_ARM = self then
        Result := 'COMMAND_SVM_FREE_ARM' else
      if COMMAND_SVM_MEMCPY_ARM = self then
        Result := 'COMMAND_SVM_MEMCPY_ARM' else
      if COMMAND_SVM_MEMFILL_ARM = self then
        Result := 'COMMAND_SVM_MEMFILL_ARM' else
      if COMMAND_SVM_MAP_ARM = self then
        Result := 'COMMAND_SVM_MAP_ARM' else
      if COMMAND_SVM_UNMAP_ARM = self then
        Result := 'COMMAND_SVM_UNMAP_ARM' else
      if COMMAND_ACQUIRE_GRALLOC_OBJECTS = self then
        Result := 'COMMAND_ACQUIRE_GRALLOC_OBJECTS' else
      if COMMAND_RELEASE_GRALLOC_OBJECTS = self then
        Result := 'COMMAND_RELEASE_GRALLOC_OBJECTS' else
      if COMMAND_GENERATE_MIPMAP = self then
        Result := 'COMMAND_GENERATE_MIPMAP' else
      if COMMAND_MEMFILL = self then
        Result := 'COMMAND_MEMFILL' else
      if COMMAND_MEMCPY = self then
        Result := 'COMMAND_MEMCPY' else
      if COMMAND_MIGRATEMEM = self then
        Result := 'COMMAND_MIGRATEMEM' else
      if COMMAND_MEMADVISE = self then
        Result := 'COMMAND_MEMADVISE' else
      if COMMAND_READ_HOST_PIPE = self then
        Result := 'COMMAND_READ_HOST_PIPE' else
      if COMMAND_WRITE_HOST_PIPE = self then
        Result := 'COMMAND_WRITE_HOST_PIPE' else
        Result := $'clCommandType[{self.val}]';
    end;
    
  end;
  
  ///
  clContextInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CONTEXT_REFERENCE_COUNT:               clContextInfo read new clContextInfo($1080);
    public static property CONTEXT_DEVICES:                       clContextInfo read new clContextInfo($1081);
    public static property CONTEXT_PROPERTIES:                    clContextInfo read new clContextInfo($1082);
    public static property CONTEXT_NUM_DEVICES:                   clContextInfo read new clContextInfo($1083);
    public static property CONTEXT_D3D10_PREFER_SHARED_RESOURCES: clContextInfo read new clContextInfo($402C);
    public static property CONTEXT_D3D11_PREFER_SHARED_RESOURCES: clContextInfo read new clContextInfo($402D);
    public static property CONTEXT_VA_API_DISPLAY:                clContextInfo read new clContextInfo($4097);
    
    public function ToString: string; override;
    begin
      if CONTEXT_REFERENCE_COUNT = self then
        Result := 'CONTEXT_REFERENCE_COUNT' else
      if CONTEXT_DEVICES = self then
        Result := 'CONTEXT_DEVICES' else
      if CONTEXT_PROPERTIES = self then
        Result := 'CONTEXT_PROPERTIES' else
      if CONTEXT_NUM_DEVICES = self then
        Result := 'CONTEXT_NUM_DEVICES' else
      if CONTEXT_D3D10_PREFER_SHARED_RESOURCES = self then
        Result := 'CONTEXT_D3D10_PREFER_SHARED_RESOURCES' else
      if CONTEXT_D3D11_PREFER_SHARED_RESOURCES = self then
        Result := 'CONTEXT_D3D11_PREFER_SHARED_RESOURCES' else
      if CONTEXT_VA_API_DISPLAY = self then
        Result := 'CONTEXT_VA_API_DISPLAY' else
        Result := $'clContextInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clContextProperties = record
    public val: IntPtr;
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property CONTEXT_PLATFORM:          clContextProperties read new clContextProperties($1084);
    public static property CONTEXT_INTEROP_USER_SYNC: clContextProperties read new clContextProperties($1085);
    public static property GL_CONTEXT:                clContextProperties read new clContextProperties($2008);
    public static property EGL_DISPLAY:               clContextProperties read new clContextProperties($2009);
    public static property GLX_DISPLAY:               clContextProperties read new clContextProperties($200A);
    public static property WGL_HDC:                   clContextProperties read new clContextProperties($200B);
    public static property CGL_SHAREGROUP:            clContextProperties read new clContextProperties($200C);
    public static property CONTEXT_ADAPTER_D3D9:      clContextProperties read new clContextProperties($2025);
    public static property CONTEXT_ADAPTER_D3D9EX:    clContextProperties read new clContextProperties($2026);
    public static property CONTEXT_ADAPTER_DXVA:      clContextProperties read new clContextProperties($2027);
    public static property CONTEXT_MEMORY_INITIALIZE: clContextProperties read new clContextProperties($2030);
    public static property CONTEXT_TERMINATE:         clContextProperties read new clContextProperties($2032);
    public static property CONTEXT_D3D10_DEVICE:      clContextProperties read new clContextProperties($4014);
    public static property CONTEXT_D3D11_DEVICE:      clContextProperties read new clContextProperties($401D);
    public static property CONTEXT_D3D9_DEVICE:       clContextProperties read new clContextProperties($4026);
    public static property CONTEXT_D3D9EX_DEVICE:     clContextProperties read new clContextProperties($4072);
    public static property CONTEXT_DXVA_DEVICE:       clContextProperties read new clContextProperties($4073);
    public static property PRINTF_CALLBACK:           clContextProperties read new clContextProperties($40B0);
    public static property PRINTF_BUFFERSIZE:         clContextProperties read new clContextProperties($40B1);
    public static property CONTEXT_SHOW_DIAGNOSTICS:  clContextProperties read new clContextProperties($4106);
    
    public function ToString: string; override;
    begin
      if CONTEXT_PLATFORM = self then
        Result := 'CONTEXT_PLATFORM' else
      if CONTEXT_INTEROP_USER_SYNC = self then
        Result := 'CONTEXT_INTEROP_USER_SYNC' else
      if GL_CONTEXT = self then
        Result := 'GL_CONTEXT' else
      if EGL_DISPLAY = self then
        Result := 'EGL_DISPLAY' else
      if GLX_DISPLAY = self then
        Result := 'GLX_DISPLAY' else
      if WGL_HDC = self then
        Result := 'WGL_HDC' else
      if CGL_SHAREGROUP = self then
        Result := 'CGL_SHAREGROUP' else
      if CONTEXT_ADAPTER_D3D9 = self then
        Result := 'CONTEXT_ADAPTER_D3D9' else
      if CONTEXT_ADAPTER_D3D9EX = self then
        Result := 'CONTEXT_ADAPTER_D3D9EX' else
      if CONTEXT_ADAPTER_DXVA = self then
        Result := 'CONTEXT_ADAPTER_DXVA' else
      if CONTEXT_MEMORY_INITIALIZE = self then
        Result := 'CONTEXT_MEMORY_INITIALIZE' else
      if CONTEXT_TERMINATE = self then
        Result := 'CONTEXT_TERMINATE' else
      if CONTEXT_D3D10_DEVICE = self then
        Result := 'CONTEXT_D3D10_DEVICE' else
      if CONTEXT_D3D11_DEVICE = self then
        Result := 'CONTEXT_D3D11_DEVICE' else
      if CONTEXT_D3D9_DEVICE = self then
        Result := 'CONTEXT_D3D9_DEVICE' else
      if CONTEXT_D3D9EX_DEVICE = self then
        Result := 'CONTEXT_D3D9EX_DEVICE' else
      if CONTEXT_DXVA_DEVICE = self then
        Result := 'CONTEXT_DXVA_DEVICE' else
      if PRINTF_CALLBACK = self then
        Result := 'PRINTF_CALLBACK' else
      if PRINTF_BUFFERSIZE = self then
        Result := 'PRINTF_BUFFERSIZE' else
      if CONTEXT_SHOW_DIAGNOSTICS = self then
        Result := 'CONTEXT_SHOW_DIAGNOSTICS' else
        Result := $'clContextProperties[{self.val}]';
    end;
    
  end;
  
  ///
  clD3D10DeviceSet = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PREFERRED_DEVICES_FOR_D3D10: clD3D10DeviceSet read new clD3D10DeviceSet($4012);
    public static property ALL_DEVICES_FOR_D3D10:       clD3D10DeviceSet read new clD3D10DeviceSet($4013);
    
    public function ToString: string; override;
    begin
      if PREFERRED_DEVICES_FOR_D3D10 = self then
        Result := 'PREFERRED_DEVICES_FOR_D3D10' else
      if ALL_DEVICES_FOR_D3D10 = self then
        Result := 'ALL_DEVICES_FOR_D3D10' else
        Result := $'clD3D10DeviceSet[{self.val}]';
    end;
    
  end;
  
  ///
  clD3D10DeviceSource = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property D3D10_DEVICE:       clD3D10DeviceSource read new clD3D10DeviceSource($4010);
    public static property D3D10_DXGI_ADAPTER: clD3D10DeviceSource read new clD3D10DeviceSource($4011);
    
    public function ToString: string; override;
    begin
      if D3D10_DEVICE = self then
        Result := 'D3D10_DEVICE' else
      if D3D10_DXGI_ADAPTER = self then
        Result := 'D3D10_DXGI_ADAPTER' else
        Result := $'clD3D10DeviceSource[{self.val}]';
    end;
    
  end;
  
  ///
  clD3D11DeviceSet = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PREFERRED_DEVICES_FOR_D3D11: clD3D11DeviceSet read new clD3D11DeviceSet($401B);
    public static property ALL_DEVICES_FOR_D3D11:       clD3D11DeviceSet read new clD3D11DeviceSet($401C);
    
    public function ToString: string; override;
    begin
      if PREFERRED_DEVICES_FOR_D3D11 = self then
        Result := 'PREFERRED_DEVICES_FOR_D3D11' else
      if ALL_DEVICES_FOR_D3D11 = self then
        Result := 'ALL_DEVICES_FOR_D3D11' else
        Result := $'clD3D11DeviceSet[{self.val}]';
    end;
    
  end;
  
  ///
  clD3D11DeviceSource = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property D3D11_DEVICE:       clD3D11DeviceSource read new clD3D11DeviceSource($4019);
    public static property D3D11_DXGI_ADAPTER: clD3D11DeviceSource read new clD3D11DeviceSource($401A);
    
    public function ToString: string; override;
    begin
      if D3D11_DEVICE = self then
        Result := 'D3D11_DEVICE' else
      if D3D11_DXGI_ADAPTER = self then
        Result := 'D3D11_DXGI_ADAPTER' else
        Result := $'clD3D11DeviceSource[{self.val}]';
    end;
    
  end;
  
  ///
  clDeviceAffinityDomain = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property DEVICE_AFFINITY_DOMAIN_NUMA:               clDeviceAffinityDomain read new clDeviceAffinityDomain(1 shl 0);
    public static property DEVICE_AFFINITY_DOMAIN_L4_CACHE:           clDeviceAffinityDomain read new clDeviceAffinityDomain(1 shl 1);
    public static property DEVICE_AFFINITY_DOMAIN_L3_CACHE:           clDeviceAffinityDomain read new clDeviceAffinityDomain(1 shl 2);
    public static property DEVICE_AFFINITY_DOMAIN_L2_CACHE:           clDeviceAffinityDomain read new clDeviceAffinityDomain(1 shl 3);
    public static property DEVICE_AFFINITY_DOMAIN_L1_CACHE:           clDeviceAffinityDomain read new clDeviceAffinityDomain(1 shl 4);
    public static property DEVICE_AFFINITY_DOMAIN_NEXT_PARTITIONABLE: clDeviceAffinityDomain read new clDeviceAffinityDomain(1 shl 5);
    
    public static function operator+(v1, v2: clDeviceAffinityDomain) := new clDeviceAffinityDomain(v1.val or v2.val);
    public static function operator or(v1, v2: clDeviceAffinityDomain) := new clDeviceAffinityDomain(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clDeviceAffinityDomain; v2: clDeviceAffinityDomain) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clDeviceAffinityDomain) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clDeviceAffinityDomain[0]';
        exit;
      end;
      if DEVICE_AFFINITY_DOMAIN_NUMA in self then
      begin
        res += 'DEVICE_AFFINITY_DOMAIN_NUMA+';
        left_val := left_val and not DEVICE_AFFINITY_DOMAIN_NUMA.val;
      end;
      if DEVICE_AFFINITY_DOMAIN_L4_CACHE in self then
      begin
        res += 'DEVICE_AFFINITY_DOMAIN_L4_CACHE+';
        left_val := left_val and not DEVICE_AFFINITY_DOMAIN_L4_CACHE.val;
      end;
      if DEVICE_AFFINITY_DOMAIN_L3_CACHE in self then
      begin
        res += 'DEVICE_AFFINITY_DOMAIN_L3_CACHE+';
        left_val := left_val and not DEVICE_AFFINITY_DOMAIN_L3_CACHE.val;
      end;
      if DEVICE_AFFINITY_DOMAIN_L2_CACHE in self then
      begin
        res += 'DEVICE_AFFINITY_DOMAIN_L2_CACHE+';
        left_val := left_val and not DEVICE_AFFINITY_DOMAIN_L2_CACHE.val;
      end;
      if DEVICE_AFFINITY_DOMAIN_L1_CACHE in self then
      begin
        res += 'DEVICE_AFFINITY_DOMAIN_L1_CACHE+';
        left_val := left_val and not DEVICE_AFFINITY_DOMAIN_L1_CACHE.val;
      end;
      if DEVICE_AFFINITY_DOMAIN_NEXT_PARTITIONABLE in self then
      begin
        res += 'DEVICE_AFFINITY_DOMAIN_NEXT_PARTITIONABLE+';
        left_val := left_val and not DEVICE_AFFINITY_DOMAIN_NEXT_PARTITIONABLE.val;
      end;
      if left_val<>0 then
      begin
        res += 'clDeviceAffinityDomain[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clDeviceAtomicCapabilities = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property DEVICE_ATOMIC_ORDER_RELAXED:     clDeviceAtomicCapabilities read new clDeviceAtomicCapabilities(1 shl 0);
    public static property DEVICE_ATOMIC_ORDER_ACQ_REL:     clDeviceAtomicCapabilities read new clDeviceAtomicCapabilities(1 shl 1);
    public static property DEVICE_ATOMIC_ORDER_SEQ_CST:     clDeviceAtomicCapabilities read new clDeviceAtomicCapabilities(1 shl 2);
    public static property DEVICE_ATOMIC_SCOPE_WORK_ITEM:   clDeviceAtomicCapabilities read new clDeviceAtomicCapabilities(1 shl 3);
    public static property DEVICE_ATOMIC_SCOPE_WORK_GROUP:  clDeviceAtomicCapabilities read new clDeviceAtomicCapabilities(1 shl 4);
    public static property DEVICE_ATOMIC_SCOPE_DEVICE:      clDeviceAtomicCapabilities read new clDeviceAtomicCapabilities(1 shl 5);
    public static property DEVICE_ATOMIC_SCOPE_ALL_DEVICES: clDeviceAtomicCapabilities read new clDeviceAtomicCapabilities(1 shl 6);
    
    public static function operator+(v1, v2: clDeviceAtomicCapabilities) := new clDeviceAtomicCapabilities(v1.val or v2.val);
    public static function operator or(v1, v2: clDeviceAtomicCapabilities) := new clDeviceAtomicCapabilities(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clDeviceAtomicCapabilities; v2: clDeviceAtomicCapabilities) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clDeviceAtomicCapabilities) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clDeviceAtomicCapabilities[0]';
        exit;
      end;
      if DEVICE_ATOMIC_ORDER_RELAXED in self then
      begin
        res += 'DEVICE_ATOMIC_ORDER_RELAXED+';
        left_val := left_val and not DEVICE_ATOMIC_ORDER_RELAXED.val;
      end;
      if DEVICE_ATOMIC_ORDER_ACQ_REL in self then
      begin
        res += 'DEVICE_ATOMIC_ORDER_ACQ_REL+';
        left_val := left_val and not DEVICE_ATOMIC_ORDER_ACQ_REL.val;
      end;
      if DEVICE_ATOMIC_ORDER_SEQ_CST in self then
      begin
        res += 'DEVICE_ATOMIC_ORDER_SEQ_CST+';
        left_val := left_val and not DEVICE_ATOMIC_ORDER_SEQ_CST.val;
      end;
      if DEVICE_ATOMIC_SCOPE_WORK_ITEM in self then
      begin
        res += 'DEVICE_ATOMIC_SCOPE_WORK_ITEM+';
        left_val := left_val and not DEVICE_ATOMIC_SCOPE_WORK_ITEM.val;
      end;
      if DEVICE_ATOMIC_SCOPE_WORK_GROUP in self then
      begin
        res += 'DEVICE_ATOMIC_SCOPE_WORK_GROUP+';
        left_val := left_val and not DEVICE_ATOMIC_SCOPE_WORK_GROUP.val;
      end;
      if DEVICE_ATOMIC_SCOPE_DEVICE in self then
      begin
        res += 'DEVICE_ATOMIC_SCOPE_DEVICE+';
        left_val := left_val and not DEVICE_ATOMIC_SCOPE_DEVICE.val;
      end;
      if DEVICE_ATOMIC_SCOPE_ALL_DEVICES in self then
      begin
        res += 'DEVICE_ATOMIC_SCOPE_ALL_DEVICES+';
        left_val := left_val and not DEVICE_ATOMIC_SCOPE_ALL_DEVICES.val;
      end;
      if left_val<>0 then
      begin
        res += 'clDeviceAtomicCapabilities[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clDeviceAvcMeVersion = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property AVC_ME_VERSION_0: clDeviceAvcMeVersion read new clDeviceAvcMeVersion(0);
    public static property AVC_ME_VERSION_1: clDeviceAvcMeVersion read new clDeviceAvcMeVersion($0001);
    
    public function ToString: string; override;
    begin
      if AVC_ME_VERSION_0 = self then
        Result := 'AVC_ME_VERSION_0' else
      if AVC_ME_VERSION_1 = self then
        Result := 'AVC_ME_VERSION_1' else
        Result := $'clDeviceAvcMeVersion[{self.val}]';
    end;
    
  end;
  
  ///
  clDeviceCommandBufferCapabilities = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property COMMAND_BUFFER_CAPABILITY_KERNEL_PRINTF:       clDeviceCommandBufferCapabilities read new clDeviceCommandBufferCapabilities(1 shl 0);
    public static property COMMAND_BUFFER_CAPABILITY_DEVICE_SIDE_ENQUEUE: clDeviceCommandBufferCapabilities read new clDeviceCommandBufferCapabilities(1 shl 1);
    public static property COMMAND_BUFFER_CAPABILITY_SIMULTANEOUS_USE:    clDeviceCommandBufferCapabilities read new clDeviceCommandBufferCapabilities(1 shl 2);
    public static property COMMAND_BUFFER_CAPABILITY_OUT_OF_ORDER:        clDeviceCommandBufferCapabilities read new clDeviceCommandBufferCapabilities(1 shl 3);
    public static property COMMAND_BUFFER_CAPABILITY_MULTIPLE_QUEUE:      clDeviceCommandBufferCapabilities read new clDeviceCommandBufferCapabilities(1 shl 4);
    
    public static function operator+(v1, v2: clDeviceCommandBufferCapabilities) := new clDeviceCommandBufferCapabilities(v1.val or v2.val);
    public static function operator or(v1, v2: clDeviceCommandBufferCapabilities) := new clDeviceCommandBufferCapabilities(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clDeviceCommandBufferCapabilities; v2: clDeviceCommandBufferCapabilities) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clDeviceCommandBufferCapabilities) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clDeviceCommandBufferCapabilities[0]';
        exit;
      end;
      if COMMAND_BUFFER_CAPABILITY_KERNEL_PRINTF in self then
      begin
        res += 'COMMAND_BUFFER_CAPABILITY_KERNEL_PRINTF+';
        left_val := left_val and not COMMAND_BUFFER_CAPABILITY_KERNEL_PRINTF.val;
      end;
      if COMMAND_BUFFER_CAPABILITY_DEVICE_SIDE_ENQUEUE in self then
      begin
        res += 'COMMAND_BUFFER_CAPABILITY_DEVICE_SIDE_ENQUEUE+';
        left_val := left_val and not COMMAND_BUFFER_CAPABILITY_DEVICE_SIDE_ENQUEUE.val;
      end;
      if COMMAND_BUFFER_CAPABILITY_SIMULTANEOUS_USE in self then
      begin
        res += 'COMMAND_BUFFER_CAPABILITY_SIMULTANEOUS_USE+';
        left_val := left_val and not COMMAND_BUFFER_CAPABILITY_SIMULTANEOUS_USE.val;
      end;
      if COMMAND_BUFFER_CAPABILITY_OUT_OF_ORDER in self then
      begin
        res += 'COMMAND_BUFFER_CAPABILITY_OUT_OF_ORDER+';
        left_val := left_val and not COMMAND_BUFFER_CAPABILITY_OUT_OF_ORDER.val;
      end;
      if COMMAND_BUFFER_CAPABILITY_MULTIPLE_QUEUE in self then
      begin
        res += 'COMMAND_BUFFER_CAPABILITY_MULTIPLE_QUEUE+';
        left_val := left_val and not COMMAND_BUFFER_CAPABILITY_MULTIPLE_QUEUE.val;
      end;
      if left_val<>0 then
      begin
        res += 'clDeviceCommandBufferCapabilities[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clDeviceControlledTerminationCapabilities = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property DEVICE_CONTROLLED_TERMINATION_SUCCESS: clDeviceControlledTerminationCapabilities read new clDeviceControlledTerminationCapabilities(1 shl 0);
    public static property DEVICE_CONTROLLED_TERMINATION_FAILURE: clDeviceControlledTerminationCapabilities read new clDeviceControlledTerminationCapabilities(1 shl 1);
    public static property DEVICE_CONTROLLED_TERMINATION_QUERY:   clDeviceControlledTerminationCapabilities read new clDeviceControlledTerminationCapabilities(1 shl 2);
    
    public static function operator+(v1, v2: clDeviceControlledTerminationCapabilities) := new clDeviceControlledTerminationCapabilities(v1.val or v2.val);
    public static function operator or(v1, v2: clDeviceControlledTerminationCapabilities) := new clDeviceControlledTerminationCapabilities(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clDeviceControlledTerminationCapabilities; v2: clDeviceControlledTerminationCapabilities) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clDeviceControlledTerminationCapabilities) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clDeviceControlledTerminationCapabilities[0]';
        exit;
      end;
      if DEVICE_CONTROLLED_TERMINATION_SUCCESS in self then
      begin
        res += 'DEVICE_CONTROLLED_TERMINATION_SUCCESS+';
        left_val := left_val and not DEVICE_CONTROLLED_TERMINATION_SUCCESS.val;
      end;
      if DEVICE_CONTROLLED_TERMINATION_FAILURE in self then
      begin
        res += 'DEVICE_CONTROLLED_TERMINATION_FAILURE+';
        left_val := left_val and not DEVICE_CONTROLLED_TERMINATION_FAILURE.val;
      end;
      if DEVICE_CONTROLLED_TERMINATION_QUERY in self then
      begin
        res += 'DEVICE_CONTROLLED_TERMINATION_QUERY+';
        left_val := left_val and not DEVICE_CONTROLLED_TERMINATION_QUERY.val;
      end;
      if left_val<>0 then
      begin
        res += 'clDeviceControlledTerminationCapabilities[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clDeviceExecCapabilities = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property EXEC_KERNEL:        clDeviceExecCapabilities read new clDeviceExecCapabilities(1 shl 0);
    public static property EXEC_NATIVE_KERNEL: clDeviceExecCapabilities read new clDeviceExecCapabilities(1 shl 1);
    
    public static function operator+(v1, v2: clDeviceExecCapabilities) := new clDeviceExecCapabilities(v1.val or v2.val);
    public static function operator or(v1, v2: clDeviceExecCapabilities) := new clDeviceExecCapabilities(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clDeviceExecCapabilities; v2: clDeviceExecCapabilities) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clDeviceExecCapabilities) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clDeviceExecCapabilities[0]';
        exit;
      end;
      if EXEC_KERNEL in self then
      begin
        res += 'EXEC_KERNEL+';
        left_val := left_val and not EXEC_KERNEL.val;
      end;
      if EXEC_NATIVE_KERNEL in self then
      begin
        res += 'EXEC_NATIVE_KERNEL+';
        left_val := left_val and not EXEC_NATIVE_KERNEL.val;
      end;
      if left_val<>0 then
      begin
        res += 'clDeviceExecCapabilities[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clDeviceFeatureCapabilities = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property DEVICE_FEATURE_FLAG_DP4A: clDeviceFeatureCapabilities read new clDeviceFeatureCapabilities(1 shl 0);
    public static property DEVICE_FEATURE_FLAG_DPAS: clDeviceFeatureCapabilities read new clDeviceFeatureCapabilities(1 shl 1);
    
    public static function operator+(v1, v2: clDeviceFeatureCapabilities) := new clDeviceFeatureCapabilities(v1.val or v2.val);
    public static function operator or(v1, v2: clDeviceFeatureCapabilities) := new clDeviceFeatureCapabilities(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clDeviceFeatureCapabilities; v2: clDeviceFeatureCapabilities) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clDeviceFeatureCapabilities) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clDeviceFeatureCapabilities[0]';
        exit;
      end;
      if DEVICE_FEATURE_FLAG_DP4A in self then
      begin
        res += 'DEVICE_FEATURE_FLAG_DP4A+';
        left_val := left_val and not DEVICE_FEATURE_FLAG_DP4A.val;
      end;
      if DEVICE_FEATURE_FLAG_DPAS in self then
      begin
        res += 'DEVICE_FEATURE_FLAG_DPAS+';
        left_val := left_val and not DEVICE_FEATURE_FLAG_DPAS.val;
      end;
      if left_val<>0 then
      begin
        res += 'clDeviceFeatureCapabilities[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clDeviceFpAtomicCapabilities = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property DEVICE_GLOBAL_FP_ATOMIC_LOAD_STORE: clDeviceFpAtomicCapabilities read new clDeviceFpAtomicCapabilities(1 shl 0);
    public static property DEVICE_GLOBAL_FP_ATOMIC_ADD:        clDeviceFpAtomicCapabilities read new clDeviceFpAtomicCapabilities(1 shl 1);
    public static property DEVICE_GLOBAL_FP_ATOMIC_MIN_MAX:    clDeviceFpAtomicCapabilities read new clDeviceFpAtomicCapabilities(1 shl 2);
    public static property DEVICE_LOCAL_FP_ATOMIC_LOAD_STORE:  clDeviceFpAtomicCapabilities read new clDeviceFpAtomicCapabilities(1 shl 16);
    public static property DEVICE_LOCAL_FP_ATOMIC_ADD:         clDeviceFpAtomicCapabilities read new clDeviceFpAtomicCapabilities(1 shl 17);
    public static property DEVICE_LOCAL_FP_ATOMIC_MIN_MAX:     clDeviceFpAtomicCapabilities read new clDeviceFpAtomicCapabilities(1 shl 18);
    
    public static function operator+(v1, v2: clDeviceFpAtomicCapabilities) := new clDeviceFpAtomicCapabilities(v1.val or v2.val);
    public static function operator or(v1, v2: clDeviceFpAtomicCapabilities) := new clDeviceFpAtomicCapabilities(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clDeviceFpAtomicCapabilities; v2: clDeviceFpAtomicCapabilities) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clDeviceFpAtomicCapabilities) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clDeviceFpAtomicCapabilities[0]';
        exit;
      end;
      if DEVICE_GLOBAL_FP_ATOMIC_LOAD_STORE in self then
      begin
        res += 'DEVICE_GLOBAL_FP_ATOMIC_LOAD_STORE+';
        left_val := left_val and not DEVICE_GLOBAL_FP_ATOMIC_LOAD_STORE.val;
      end;
      if DEVICE_GLOBAL_FP_ATOMIC_ADD in self then
      begin
        res += 'DEVICE_GLOBAL_FP_ATOMIC_ADD+';
        left_val := left_val and not DEVICE_GLOBAL_FP_ATOMIC_ADD.val;
      end;
      if DEVICE_GLOBAL_FP_ATOMIC_MIN_MAX in self then
      begin
        res += 'DEVICE_GLOBAL_FP_ATOMIC_MIN_MAX+';
        left_val := left_val and not DEVICE_GLOBAL_FP_ATOMIC_MIN_MAX.val;
      end;
      if DEVICE_LOCAL_FP_ATOMIC_LOAD_STORE in self then
      begin
        res += 'DEVICE_LOCAL_FP_ATOMIC_LOAD_STORE+';
        left_val := left_val and not DEVICE_LOCAL_FP_ATOMIC_LOAD_STORE.val;
      end;
      if DEVICE_LOCAL_FP_ATOMIC_ADD in self then
      begin
        res += 'DEVICE_LOCAL_FP_ATOMIC_ADD+';
        left_val := left_val and not DEVICE_LOCAL_FP_ATOMIC_ADD.val;
      end;
      if DEVICE_LOCAL_FP_ATOMIC_MIN_MAX in self then
      begin
        res += 'DEVICE_LOCAL_FP_ATOMIC_MIN_MAX+';
        left_val := left_val and not DEVICE_LOCAL_FP_ATOMIC_MIN_MAX.val;
      end;
      if left_val<>0 then
      begin
        res += 'clDeviceFpAtomicCapabilities[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clDeviceFPConfig = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property FP_DENORM:                        clDeviceFPConfig read new clDeviceFPConfig(1 shl 0);
    public static property FP_INF_NAN:                       clDeviceFPConfig read new clDeviceFPConfig(1 shl 1);
    public static property FP_ROUND_TO_NEAREST:              clDeviceFPConfig read new clDeviceFPConfig(1 shl 2);
    public static property FP_ROUND_TO_ZERO:                 clDeviceFPConfig read new clDeviceFPConfig(1 shl 3);
    public static property FP_ROUND_TO_INF:                  clDeviceFPConfig read new clDeviceFPConfig(1 shl 4);
    public static property FP_FMA:                           clDeviceFPConfig read new clDeviceFPConfig(1 shl 5);
    public static property FP_SOFT_FLOAT:                    clDeviceFPConfig read new clDeviceFPConfig(1 shl 6);
    public static property FP_CORRECTLY_ROUNDED_DIVIDE_SQRT: clDeviceFPConfig read new clDeviceFPConfig(1 shl 7);
    
    public static function operator+(v1, v2: clDeviceFPConfig) := new clDeviceFPConfig(v1.val or v2.val);
    public static function operator or(v1, v2: clDeviceFPConfig) := new clDeviceFPConfig(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clDeviceFPConfig; v2: clDeviceFPConfig) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clDeviceFPConfig) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clDeviceFPConfig[0]';
        exit;
      end;
      if FP_DENORM in self then
      begin
        res += 'FP_DENORM+';
        left_val := left_val and not FP_DENORM.val;
      end;
      if FP_INF_NAN in self then
      begin
        res += 'FP_INF_NAN+';
        left_val := left_val and not FP_INF_NAN.val;
      end;
      if FP_ROUND_TO_NEAREST in self then
      begin
        res += 'FP_ROUND_TO_NEAREST+';
        left_val := left_val and not FP_ROUND_TO_NEAREST.val;
      end;
      if FP_ROUND_TO_ZERO in self then
      begin
        res += 'FP_ROUND_TO_ZERO+';
        left_val := left_val and not FP_ROUND_TO_ZERO.val;
      end;
      if FP_ROUND_TO_INF in self then
      begin
        res += 'FP_ROUND_TO_INF+';
        left_val := left_val and not FP_ROUND_TO_INF.val;
      end;
      if FP_FMA in self then
      begin
        res += 'FP_FMA+';
        left_val := left_val and not FP_FMA.val;
      end;
      if FP_SOFT_FLOAT in self then
      begin
        res += 'FP_SOFT_FLOAT+';
        left_val := left_val and not FP_SOFT_FLOAT.val;
      end;
      if FP_CORRECTLY_ROUNDED_DIVIDE_SQRT in self then
      begin
        res += 'FP_CORRECTLY_ROUNDED_DIVIDE_SQRT+';
        left_val := left_val and not FP_CORRECTLY_ROUNDED_DIVIDE_SQRT.val;
      end;
      if left_val<>0 then
      begin
        res += 'clDeviceFPConfig[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clDeviceInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DEVICE_TYPE:                                                      clDeviceInfo read new clDeviceInfo($1000);
    public static property DEVICE_VENDOR_ID:                                                 clDeviceInfo read new clDeviceInfo($1001);
    public static property DEVICE_MAX_COMPUTE_UNITS:                                         clDeviceInfo read new clDeviceInfo($1002);
    public static property DEVICE_MAX_WORK_ITEM_DIMENSIONS:                                  clDeviceInfo read new clDeviceInfo($1003);
    public static property DEVICE_MAX_WORK_GROUP_SIZE:                                       clDeviceInfo read new clDeviceInfo($1004);
    public static property DEVICE_MAX_WORK_ITEM_SIZES:                                       clDeviceInfo read new clDeviceInfo($1005);
    public static property DEVICE_PREFERRED_VECTOR_WIDTH_CHAR:                               clDeviceInfo read new clDeviceInfo($1006);
    public static property DEVICE_PREFERRED_VECTOR_WIDTH_SHORT:                              clDeviceInfo read new clDeviceInfo($1007);
    public static property DEVICE_PREFERRED_VECTOR_WIDTH_INT:                                clDeviceInfo read new clDeviceInfo($1008);
    public static property DEVICE_PREFERRED_VECTOR_WIDTH_LONG:                               clDeviceInfo read new clDeviceInfo($1009);
    public static property DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT:                              clDeviceInfo read new clDeviceInfo($100A);
    public static property DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE:                             clDeviceInfo read new clDeviceInfo($100B);
    public static property DEVICE_MAX_CLOCK_FREQUENCY:                                       clDeviceInfo read new clDeviceInfo($100C);
    public static property DEVICE_ADDRESS_BITS:                                              clDeviceInfo read new clDeviceInfo($100D);
    public static property DEVICE_MAX_READ_IMAGE_ARGS:                                       clDeviceInfo read new clDeviceInfo($100E);
    public static property DEVICE_MAX_WRITE_IMAGE_ARGS:                                      clDeviceInfo read new clDeviceInfo($100F);
    public static property DEVICE_MAX_MEM_ALLOC_SIZE:                                        clDeviceInfo read new clDeviceInfo($1010);
    public static property DEVICE_IMAGE2D_MAX_WIDTH:                                         clDeviceInfo read new clDeviceInfo($1011);
    public static property DEVICE_IMAGE2D_MAX_HEIGHT:                                        clDeviceInfo read new clDeviceInfo($1012);
    public static property DEVICE_IMAGE3D_MAX_WIDTH:                                         clDeviceInfo read new clDeviceInfo($1013);
    public static property DEVICE_IMAGE3D_MAX_HEIGHT:                                        clDeviceInfo read new clDeviceInfo($1014);
    public static property DEVICE_IMAGE3D_MAX_DEPTH:                                         clDeviceInfo read new clDeviceInfo($1015);
    public static property DEVICE_IMAGE_SUPPORT:                                             clDeviceInfo read new clDeviceInfo($1016);
    public static property DEVICE_MAX_PARAMETER_SIZE:                                        clDeviceInfo read new clDeviceInfo($1017);
    public static property DEVICE_MAX_SAMPLERS:                                              clDeviceInfo read new clDeviceInfo($1018);
    public static property DEVICE_MEM_BASE_ADDR_ALIGN:                                       clDeviceInfo read new clDeviceInfo($1019);
    public static property DEVICE_MIN_DATA_TYPE_ALIGN_SIZE:                                  clDeviceInfo read new clDeviceInfo($101A);
    public static property DEVICE_SINGLE_FP_CONFIG:                                          clDeviceInfo read new clDeviceInfo($101B);
    public static property DEVICE_GLOBAL_MEM_CACHE_TYPE:                                     clDeviceInfo read new clDeviceInfo($101C);
    public static property DEVICE_GLOBAL_MEM_CACHELINE_SIZE:                                 clDeviceInfo read new clDeviceInfo($101D);
    public static property DEVICE_GLOBAL_MEM_CACHE_SIZE:                                     clDeviceInfo read new clDeviceInfo($101E);
    public static property DEVICE_GLOBAL_MEM_SIZE:                                           clDeviceInfo read new clDeviceInfo($101F);
    public static property DEVICE_MAX_CONSTANT_BUFFER_SIZE:                                  clDeviceInfo read new clDeviceInfo($1020);
    public static property DEVICE_MAX_CONSTANT_ARGS:                                         clDeviceInfo read new clDeviceInfo($1021);
    public static property DEVICE_LOCAL_MEM_TYPE:                                            clDeviceInfo read new clDeviceInfo($1022);
    public static property DEVICE_LOCAL_MEM_SIZE:                                            clDeviceInfo read new clDeviceInfo($1023);
    public static property DEVICE_ERROR_CORRECTION_SUPPORT:                                  clDeviceInfo read new clDeviceInfo($1024);
    public static property DEVICE_PROFILING_TIMER_RESOLUTION:                                clDeviceInfo read new clDeviceInfo($1025);
    public static property DEVICE_ENDIAN_LITTLE:                                             clDeviceInfo read new clDeviceInfo($1026);
    public static property DEVICE_AVAILABLE:                                                 clDeviceInfo read new clDeviceInfo($1027);
    public static property DEVICE_COMPILER_AVAILABLE:                                        clDeviceInfo read new clDeviceInfo($1028);
    public static property DEVICE_EXECUTION_CAPABILITIES:                                    clDeviceInfo read new clDeviceInfo($1029);
    public static property DEVICE_QUEUE_PROPERTIES:                                          clDeviceInfo read new clDeviceInfo($102A);
    public static property DEVICE_QUEUE_ON_HOST_PROPERTIES:                                  clDeviceInfo read new clDeviceInfo($102A);
    public static property DEVICE_NAME:                                                      clDeviceInfo read new clDeviceInfo($102B);
    public static property DEVICE_VENDOR:                                                    clDeviceInfo read new clDeviceInfo($102C);
    public static property DRIVER_VERSION:                                                   clDeviceInfo read new clDeviceInfo($102D);
    public static property DEVICE_PROFILE:                                                   clDeviceInfo read new clDeviceInfo($102E);
    public static property DEVICE_VERSION:                                                   clDeviceInfo read new clDeviceInfo($102F);
    public static property DEVICE_EXTENSIONS:                                                clDeviceInfo read new clDeviceInfo($1030);
    public static property DEVICE_PLATFORM:                                                  clDeviceInfo read new clDeviceInfo($1031);
    public static property DEVICE_DOUBLE_FP_CONFIG:                                          clDeviceInfo read new clDeviceInfo($1032);
    public static property DEVICE_HALF_FP_CONFIG:                                            clDeviceInfo read new clDeviceInfo($1033);
    public static property DEVICE_PREFERRED_VECTOR_WIDTH_HALF:                               clDeviceInfo read new clDeviceInfo($1034);
    public static property DEVICE_HOST_UNIFIED_MEMORY:                                       clDeviceInfo read new clDeviceInfo($1035);
    public static property DEVICE_NATIVE_VECTOR_WIDTH_CHAR:                                  clDeviceInfo read new clDeviceInfo($1036);
    public static property DEVICE_NATIVE_VECTOR_WIDTH_SHORT:                                 clDeviceInfo read new clDeviceInfo($1037);
    public static property DEVICE_NATIVE_VECTOR_WIDTH_INT:                                   clDeviceInfo read new clDeviceInfo($1038);
    public static property DEVICE_NATIVE_VECTOR_WIDTH_LONG:                                  clDeviceInfo read new clDeviceInfo($1039);
    public static property DEVICE_NATIVE_VECTOR_WIDTH_FLOAT:                                 clDeviceInfo read new clDeviceInfo($103A);
    public static property DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE:                                clDeviceInfo read new clDeviceInfo($103B);
    public static property DEVICE_NATIVE_VECTOR_WIDTH_HALF:                                  clDeviceInfo read new clDeviceInfo($103C);
    public static property DEVICE_OPENCL_C_VERSION:                                          clDeviceInfo read new clDeviceInfo($103D);
    public static property DEVICE_LINKER_AVAILABLE:                                          clDeviceInfo read new clDeviceInfo($103E);
    public static property DEVICE_BUILT_IN_KERNELS:                                          clDeviceInfo read new clDeviceInfo($103F);
    public static property DEVICE_IMAGE_MAX_BUFFER_SIZE:                                     clDeviceInfo read new clDeviceInfo($1040);
    public static property DEVICE_IMAGE_MAX_ARRAY_SIZE:                                      clDeviceInfo read new clDeviceInfo($1041);
    public static property DEVICE_PARENT_DEVICE:                                             clDeviceInfo read new clDeviceInfo($1042);
    public static property DEVICE_PARTITION_MAX_SUB_DEVICES:                                 clDeviceInfo read new clDeviceInfo($1043);
    public static property DEVICE_PARTITION_PROPERTIES:                                      clDeviceInfo read new clDeviceInfo($1044);
    public static property DEVICE_PARTITION_AFFINITY_DOMAIN:                                 clDeviceInfo read new clDeviceInfo($1045);
    public static property DEVICE_PARTITION_TYPE:                                            clDeviceInfo read new clDeviceInfo($1046);
    public static property DEVICE_REFERENCE_COUNT:                                           clDeviceInfo read new clDeviceInfo($1047);
    public static property DEVICE_PREFERRED_INTEROP_USER_SYNC:                               clDeviceInfo read new clDeviceInfo($1048);
    public static property DEVICE_PRINTF_BUFFER_SIZE:                                        clDeviceInfo read new clDeviceInfo($1049);
    public static property DEVICE_IMAGE_PITCH_ALIGNMENT:                                     clDeviceInfo read new clDeviceInfo($104A);
    public static property DEVICE_IMAGE_BASE_ADDRESS_ALIGNMENT:                              clDeviceInfo read new clDeviceInfo($104B);
    public static property DEVICE_MAX_READ_WRITE_IMAGE_ARGS:                                 clDeviceInfo read new clDeviceInfo($104C);
    public static property DEVICE_MAX_GLOBAL_VARIABLE_SIZE:                                  clDeviceInfo read new clDeviceInfo($104D);
    public static property DEVICE_QUEUE_ON_DEVICE_PROPERTIES:                                clDeviceInfo read new clDeviceInfo($104E);
    public static property DEVICE_QUEUE_ON_DEVICE_PREFERRED_SIZE:                            clDeviceInfo read new clDeviceInfo($104F);
    public static property DEVICE_QUEUE_ON_DEVICE_MAX_SIZE:                                  clDeviceInfo read new clDeviceInfo($1050);
    public static property DEVICE_MAX_ON_DEVICE_QUEUES:                                      clDeviceInfo read new clDeviceInfo($1051);
    public static property DEVICE_MAX_ON_DEVICE_EVENTS:                                      clDeviceInfo read new clDeviceInfo($1052);
    public static property DEVICE_SVM_CAPABILITIES:                                          clDeviceInfo read new clDeviceInfo($1053);
    public static property DEVICE_GLOBAL_VARIABLE_PREFERRED_TOTAL_SIZE:                      clDeviceInfo read new clDeviceInfo($1054);
    public static property DEVICE_MAX_PIPE_ARGS:                                             clDeviceInfo read new clDeviceInfo($1055);
    public static property DEVICE_PIPE_MAX_ACTIVE_RESERVATIONS:                              clDeviceInfo read new clDeviceInfo($1056);
    public static property DEVICE_PIPE_MAX_PACKET_SIZE:                                      clDeviceInfo read new clDeviceInfo($1057);
    public static property DEVICE_PREFERRED_PLATFORM_ATOMIC_ALIGNMENT:                       clDeviceInfo read new clDeviceInfo($1058);
    public static property DEVICE_PREFERRED_GLOBAL_ATOMIC_ALIGNMENT:                         clDeviceInfo read new clDeviceInfo($1059);
    public static property DEVICE_PREFERRED_LOCAL_ATOMIC_ALIGNMENT:                          clDeviceInfo read new clDeviceInfo($105A);
    public static property DEVICE_IL_VERSION:                                                clDeviceInfo read new clDeviceInfo($105B);
    public static property DEVICE_MAX_NUM_SUB_GROUPS:                                        clDeviceInfo read new clDeviceInfo($105C);
    public static property DEVICE_SUB_GROUP_INDEPENDENT_FORWARD_PROGRESS:                    clDeviceInfo read new clDeviceInfo($105D);
    public static property DEVICE_NUMERIC_VERSION:                                           clDeviceInfo read new clDeviceInfo($105E);
    public static property DEVICE_OPENCL_C_NUMERIC_VERSION:                                  clDeviceInfo read new clDeviceInfo($105F);
    public static property DEVICE_EXTENSIONS_WITH_VERSION:                                   clDeviceInfo read new clDeviceInfo($1060);
    public static property DEVICE_ILS_WITH_VERSION:                                          clDeviceInfo read new clDeviceInfo($1061);
    public static property DEVICE_BUILT_IN_KERNELS_WITH_VERSION:                             clDeviceInfo read new clDeviceInfo($1062);
    public static property DEVICE_ATOMIC_MEMORY_CAPABILITIES:                                clDeviceInfo read new clDeviceInfo($1063);
    public static property DEVICE_ATOMIC_FENCE_CAPABILITIES:                                 clDeviceInfo read new clDeviceInfo($1064);
    public static property DEVICE_NON_UNIFORM_WORK_GROUP_SUPPORT:                            clDeviceInfo read new clDeviceInfo($1065);
    public static property DEVICE_OPENCL_C_ALL_VERSIONS:                                     clDeviceInfo read new clDeviceInfo($1066);
    public static property DEVICE_PREFERRED_WORK_GROUP_SIZE_MULTIPLE:                        clDeviceInfo read new clDeviceInfo($1067);
    public static property DEVICE_WORK_GROUP_COLLECTIVE_FUNCTIONS_SUPPORT:                   clDeviceInfo read new clDeviceInfo($1068);
    public static property DEVICE_GENERIC_ADDRESS_SPACE_SUPPORT:                             clDeviceInfo read new clDeviceInfo($1069);
    public static property DEVICE_UUID:                                                      clDeviceInfo read new clDeviceInfo($106A);
    public static property DRIVER_UUID:                                                      clDeviceInfo read new clDeviceInfo($106B);
    public static property DEVICE_LUID_VALID:                                                clDeviceInfo read new clDeviceInfo($106C);
    public static property DEVICE_LUID:                                                      clDeviceInfo read new clDeviceInfo($106D);
    public static property DEVICE_NODE_MASK:                                                 clDeviceInfo read new clDeviceInfo($106E);
    public static property DEVICE_OPENCL_C_FEATURES:                                         clDeviceInfo read new clDeviceInfo($106F);
    public static property DEVICE_DEVICE_ENQUEUE_CAPABILITIES:                               clDeviceInfo read new clDeviceInfo($1070);
    public static property DEVICE_PIPE_SUPPORT:                                              clDeviceInfo read new clDeviceInfo($1071);
    public static property DEVICE_LATEST_CONFORMANCE_VERSION_PASSED:                         clDeviceInfo read new clDeviceInfo($1072);
    public static property DEVICE_INTEGER_DOT_PRODUCT_CAPABILITIES:                          clDeviceInfo read new clDeviceInfo($1073);
    public static property DEVICE_INTEGER_DOT_PRODUCT_ACCELERATION_PROPERTIES_8BIT:          clDeviceInfo read new clDeviceInfo($1074);
    public static property DEVICE_INTEGER_DOT_PRODUCT_ACCELERATION_PROPERTIES_4x8BIT_PACKED: clDeviceInfo read new clDeviceInfo($1075);
    public static property DEVICE_COMMAND_BUFFER_CAPABILITIES:                               clDeviceInfo read new clDeviceInfo($12A9);
    public static property DEVICE_COMMAND_BUFFER_REQUIRED_QUEUE_PROPERTIES:                  clDeviceInfo read new clDeviceInfo($12AA);
    public static property DEVICE_COMMAND_BUFFER_NUM_SYNC_DEVICES:                           clDeviceInfo read new clDeviceInfo($12AB);
    public static property DEVICE_COMMAND_BUFFER_SYNC_DEVICES:                               clDeviceInfo read new clDeviceInfo($12AC);
    public static property DEVICE_MUTABLE_DISPATCH_CAPABILITIES:                             clDeviceInfo read new clDeviceInfo($12B0);
    public static property DEVICE_TERMINATE_CAPABILITY:                                      clDeviceInfo read new clDeviceInfo($2031);
    public static property DEVICE_MAX_NAMED_BARRIER_COUNT:                                   clDeviceInfo read new clDeviceInfo($2035);
    public static property DEVICE_SEMAPHORE_TYPES:                                           clDeviceInfo read new clDeviceInfo($204C);
    public static property DEVICE_SEMAPHORE_IMPORT_HANDLE_TYPES:                             clDeviceInfo read new clDeviceInfo($204D);
    public static property DEVICE_SEMAPHORE_EXPORT_HANDLE_TYPES:                             clDeviceInfo read new clDeviceInfo($204E);
    public static property DEVICE_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES:                       clDeviceInfo read new clDeviceInfo($204F);
    public static property DEVICE_EXTERNAL_MEMORY_IMPORT_ASSUME_LINEAR_IMAGES_HANDLE_TYPES:  clDeviceInfo read new clDeviceInfo($2052);
    public static property DEVICE_COMPUTE_CAPABILITY_MAJOR:                                  clDeviceInfo read new clDeviceInfo($4000);
    public static property DEVICE_COMPUTE_CAPABILITY_MINOR:                                  clDeviceInfo read new clDeviceInfo($4001);
    public static property DEVICE_REGISTERS_PER_BLOCK:                                       clDeviceInfo read new clDeviceInfo($4002);
    public static property DEVICE_WARP_SIZE:                                                 clDeviceInfo read new clDeviceInfo($4003);
    public static property DEVICE_GPU_OVERLAP:                                               clDeviceInfo read new clDeviceInfo($4004);
    public static property DEVICE_KERNEL_EXEC_TIMEOUT:                                       clDeviceInfo read new clDeviceInfo($4005);
    public static property DEVICE_INTEGRATED_MEMORY:                                         clDeviceInfo read new clDeviceInfo($4006);
    public static property DEVICE_PREFERRED_WORK_GROUP_SIZE:                                 clDeviceInfo read new clDeviceInfo($4030);
    public static property DEVICE_MAX_WORK_GROUP_SIZE_AMD:                                   clDeviceInfo read new clDeviceInfo($4031);
    public static property DEVICE_PREFERRED_CONSTANT_BUFFER_SIZE:                            clDeviceInfo read new clDeviceInfo($4033);
    public static property DEVICE_PCIE_ID:                                                   clDeviceInfo read new clDeviceInfo($4034);
    public static property DEVICE_PROFILING_TIMER_OFFSET:                                    clDeviceInfo read new clDeviceInfo($4036);
    public static property DEVICE_TOPOLOGY:                                                  clDeviceInfo read new clDeviceInfo($4037);
    public static property DEVICE_BOARD_NAME:                                                clDeviceInfo read new clDeviceInfo($4038);
    public static property DEVICE_GLOBAL_FREE_MEMORY:                                        clDeviceInfo read new clDeviceInfo($4039);
    public static property DEVICE_SIMD_PER_COMPUTE_UNIT:                                     clDeviceInfo read new clDeviceInfo($4040);
    public static property DEVICE_SIMD_WIDTH:                                                clDeviceInfo read new clDeviceInfo($4041);
    public static property DEVICE_SIMD_INSTRUCTION_WIDTH:                                    clDeviceInfo read new clDeviceInfo($4042);
    public static property DEVICE_WAVEFRONT_WIDTH:                                           clDeviceInfo read new clDeviceInfo($4043);
    public static property DEVICE_GLOBAL_MEM_CHANNELS:                                       clDeviceInfo read new clDeviceInfo($4044);
    public static property DEVICE_GLOBAL_MEM_CHANNEL_BANKS:                                  clDeviceInfo read new clDeviceInfo($4045);
    public static property DEVICE_GLOBAL_MEM_CHANNEL_BANK_WIDTH:                             clDeviceInfo read new clDeviceInfo($4046);
    public static property DEVICE_LOCAL_MEM_SIZE_PER_COMPUTE_UNIT:                           clDeviceInfo read new clDeviceInfo($4047);
    public static property DEVICE_LOCAL_MEM_BANKS:                                           clDeviceInfo read new clDeviceInfo($4048);
    public static property DEVICE_THREAD_TRACE_SUPPORTED:                                    clDeviceInfo read new clDeviceInfo($4049);
    public static property DEVICE_GFXIP_MAJOR:                                               clDeviceInfo read new clDeviceInfo($404A);
    public static property DEVICE_GFXIP_MINOR:                                               clDeviceInfo read new clDeviceInfo($404B);
    public static property DEVICE_AVAILABLE_ASYNC_QUEUES:                                    clDeviceInfo read new clDeviceInfo($404C);
    public static property DEVICE_PARENT_DEVICE_EXT:                                         clDeviceInfo read new clDeviceInfo($4054);
    public static property DEVICE_PARTITION_TYPES:                                           clDeviceInfo read new clDeviceInfo($4055);
    public static property DEVICE_AFFINITY_DOMAINS:                                          clDeviceInfo read new clDeviceInfo($4056);
    public static property DEVICE_REFERENCE_COUNT_EXT:                                       clDeviceInfo read new clDeviceInfo($4057);
    public static property DEVICE_PARTITION_STYLE:                                           clDeviceInfo read new clDeviceInfo($4058);
    public static property DEVICE_ME_VERSION:                                                clDeviceInfo read new clDeviceInfo($407E);
    public static property DEVICE_EXT_MEM_PADDING_IN_BYTES:                                  clDeviceInfo read new clDeviceInfo($40A0);
    public static property DEVICE_PAGE_SIZE:                                                 clDeviceInfo read new clDeviceInfo($40A1);
    public static property DEVICE_SVM_CAPABILITIES_ARM:                                      clDeviceInfo read new clDeviceInfo($40B6);
    public static property DEVICE_COMPUTE_UNITS_BITFIELD:                                    clDeviceInfo read new clDeviceInfo($40BF);
    public static property DEVICE_MEMORY_CAPABILITIES:                                       clDeviceInfo read new clDeviceInfo($40D8);
    public static property DEVICE_SPIR_VERSIONS:                                             clDeviceInfo read new clDeviceInfo($40E0);
    public static property DEVICE_SIMULTANEOUS_INTEROPS:                                     clDeviceInfo read new clDeviceInfo($4104);
    public static property DEVICE_NUM_SIMULTANEOUS_INTEROPS:                                 clDeviceInfo read new clDeviceInfo($4105);
    public static property DEVICE_SUB_GROUP_SIZES:                                           clDeviceInfo read new clDeviceInfo($4108);
    public static property DEVICE_AVC_ME_VERSION:                                            clDeviceInfo read new clDeviceInfo($410B);
    public static property DEVICE_AVC_ME_SUPPORTS_TEXTURE_SAMPLER_USE:                       clDeviceInfo read new clDeviceInfo($410C);
    public static property DEVICE_AVC_ME_SUPPORTS_PREEMPTION:                                clDeviceInfo read new clDeviceInfo($410D);
    public static property DEVICE_PCI_BUS_INFO:                                              clDeviceInfo read new clDeviceInfo($410F);
    public static property DEVICE_PLANAR_YUV_MAX_WIDTH:                                      clDeviceInfo read new clDeviceInfo($417E);
    public static property DEVICE_PLANAR_YUV_MAX_HEIGHT:                                     clDeviceInfo read new clDeviceInfo($417F);
    public static property DEVICE_QUEUE_FAMILY_PROPERTIES:                                   clDeviceInfo read new clDeviceInfo($418B);
    public static property DEVICE_HOST_MEM_CAPABILITIES:                                     clDeviceInfo read new clDeviceInfo($4190);
    public static property DEVICE_DEVICE_MEM_CAPABILITIES:                                   clDeviceInfo read new clDeviceInfo($4191);
    public static property DEVICE_SINGLE_DEVICE_SHARED_MEM_CAPABILITIES:                     clDeviceInfo read new clDeviceInfo($4192);
    public static property DEVICE_CROSS_DEVICE_SHARED_MEM_CAPABILITIES:                      clDeviceInfo read new clDeviceInfo($4193);
    public static property DEVICE_SHARED_SYSTEM_MEM_CAPABILITIES:                            clDeviceInfo read new clDeviceInfo($4194);
    public static property DEVICE_JOB_SLOTS:                                                 clDeviceInfo read new clDeviceInfo($41E0);
    public static property DEVICE_SCHEDULING_CONTROLS_CAPABILITIES:                          clDeviceInfo read new clDeviceInfo($41E4);
    public static property DEVICE_MAX_WARP_COUNT:                                            clDeviceInfo read new clDeviceInfo($41EA);
    public static property DEVICE_SUPPORTED_REGISTER_ALLOCATIONS:                            clDeviceInfo read new clDeviceInfo($41EB);
    public static property DEVICE_CONTROLLED_TERMINATION_CAPABILITIES:                       clDeviceInfo read new clDeviceInfo($41EE);
    public static property DEVICE_CXX_FOR_OPENCL_NUMERIC_VERSION:                            clDeviceInfo read new clDeviceInfo($4230);
    public static property DEVICE_SINGLE_FP_ATOMIC_CAPABILITIES:                             clDeviceInfo read new clDeviceInfo($4231);
    public static property DEVICE_DOUBLE_FP_ATOMIC_CAPABILITIES:                             clDeviceInfo read new clDeviceInfo($4232);
    public static property DEVICE_HALF_FP_ATOMIC_CAPABILITIES:                               clDeviceInfo read new clDeviceInfo($4233);
    public static property DEVICE_IP_VERSION:                                                clDeviceInfo read new clDeviceInfo($4250);
    public static property DEVICE_ID:                                                        clDeviceInfo read new clDeviceInfo($4251);
    public static property DEVICE_NUM_SLICES:                                                clDeviceInfo read new clDeviceInfo($4252);
    public static property DEVICE_NUM_SUB_SLICES_PER_SLICE:                                  clDeviceInfo read new clDeviceInfo($4253);
    public static property DEVICE_NUM_EUS_PER_SUB_SLICE:                                     clDeviceInfo read new clDeviceInfo($4254);
    public static property DEVICE_NUM_THREADS_PER_EU:                                        clDeviceInfo read new clDeviceInfo($4255);
    public static property DEVICE_FEATURE_CAPABILITIES:                                      clDeviceInfo read new clDeviceInfo($4256);
    
    public function ToString: string; override;
    begin
      if DEVICE_TYPE = self then
        Result := 'DEVICE_TYPE' else
      if DEVICE_VENDOR_ID = self then
        Result := 'DEVICE_VENDOR_ID' else
      if DEVICE_MAX_COMPUTE_UNITS = self then
        Result := 'DEVICE_MAX_COMPUTE_UNITS' else
      if DEVICE_MAX_WORK_ITEM_DIMENSIONS = self then
        Result := 'DEVICE_MAX_WORK_ITEM_DIMENSIONS' else
      if DEVICE_MAX_WORK_GROUP_SIZE = self then
        Result := 'DEVICE_MAX_WORK_GROUP_SIZE' else
      if DEVICE_MAX_WORK_ITEM_SIZES = self then
        Result := 'DEVICE_MAX_WORK_ITEM_SIZES' else
      if DEVICE_PREFERRED_VECTOR_WIDTH_CHAR = self then
        Result := 'DEVICE_PREFERRED_VECTOR_WIDTH_CHAR' else
      if DEVICE_PREFERRED_VECTOR_WIDTH_SHORT = self then
        Result := 'DEVICE_PREFERRED_VECTOR_WIDTH_SHORT' else
      if DEVICE_PREFERRED_VECTOR_WIDTH_INT = self then
        Result := 'DEVICE_PREFERRED_VECTOR_WIDTH_INT' else
      if DEVICE_PREFERRED_VECTOR_WIDTH_LONG = self then
        Result := 'DEVICE_PREFERRED_VECTOR_WIDTH_LONG' else
      if DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT = self then
        Result := 'DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT' else
      if DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE = self then
        Result := 'DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE' else
      if DEVICE_MAX_CLOCK_FREQUENCY = self then
        Result := 'DEVICE_MAX_CLOCK_FREQUENCY' else
      if DEVICE_ADDRESS_BITS = self then
        Result := 'DEVICE_ADDRESS_BITS' else
      if DEVICE_MAX_READ_IMAGE_ARGS = self then
        Result := 'DEVICE_MAX_READ_IMAGE_ARGS' else
      if DEVICE_MAX_WRITE_IMAGE_ARGS = self then
        Result := 'DEVICE_MAX_WRITE_IMAGE_ARGS' else
      if DEVICE_MAX_MEM_ALLOC_SIZE = self then
        Result := 'DEVICE_MAX_MEM_ALLOC_SIZE' else
      if DEVICE_IMAGE2D_MAX_WIDTH = self then
        Result := 'DEVICE_IMAGE2D_MAX_WIDTH' else
      if DEVICE_IMAGE2D_MAX_HEIGHT = self then
        Result := 'DEVICE_IMAGE2D_MAX_HEIGHT' else
      if DEVICE_IMAGE3D_MAX_WIDTH = self then
        Result := 'DEVICE_IMAGE3D_MAX_WIDTH' else
      if DEVICE_IMAGE3D_MAX_HEIGHT = self then
        Result := 'DEVICE_IMAGE3D_MAX_HEIGHT' else
      if DEVICE_IMAGE3D_MAX_DEPTH = self then
        Result := 'DEVICE_IMAGE3D_MAX_DEPTH' else
      if DEVICE_IMAGE_SUPPORT = self then
        Result := 'DEVICE_IMAGE_SUPPORT' else
      if DEVICE_MAX_PARAMETER_SIZE = self then
        Result := 'DEVICE_MAX_PARAMETER_SIZE' else
      if DEVICE_MAX_SAMPLERS = self then
        Result := 'DEVICE_MAX_SAMPLERS' else
      if DEVICE_MEM_BASE_ADDR_ALIGN = self then
        Result := 'DEVICE_MEM_BASE_ADDR_ALIGN' else
      if DEVICE_MIN_DATA_TYPE_ALIGN_SIZE = self then
        Result := 'DEVICE_MIN_DATA_TYPE_ALIGN_SIZE' else
      if DEVICE_SINGLE_FP_CONFIG = self then
        Result := 'DEVICE_SINGLE_FP_CONFIG' else
      if DEVICE_GLOBAL_MEM_CACHE_TYPE = self then
        Result := 'DEVICE_GLOBAL_MEM_CACHE_TYPE' else
      if DEVICE_GLOBAL_MEM_CACHELINE_SIZE = self then
        Result := 'DEVICE_GLOBAL_MEM_CACHELINE_SIZE' else
      if DEVICE_GLOBAL_MEM_CACHE_SIZE = self then
        Result := 'DEVICE_GLOBAL_MEM_CACHE_SIZE' else
      if DEVICE_GLOBAL_MEM_SIZE = self then
        Result := 'DEVICE_GLOBAL_MEM_SIZE' else
      if DEVICE_MAX_CONSTANT_BUFFER_SIZE = self then
        Result := 'DEVICE_MAX_CONSTANT_BUFFER_SIZE' else
      if DEVICE_MAX_CONSTANT_ARGS = self then
        Result := 'DEVICE_MAX_CONSTANT_ARGS' else
      if DEVICE_LOCAL_MEM_TYPE = self then
        Result := 'DEVICE_LOCAL_MEM_TYPE' else
      if DEVICE_LOCAL_MEM_SIZE = self then
        Result := 'DEVICE_LOCAL_MEM_SIZE' else
      if DEVICE_ERROR_CORRECTION_SUPPORT = self then
        Result := 'DEVICE_ERROR_CORRECTION_SUPPORT' else
      if DEVICE_PROFILING_TIMER_RESOLUTION = self then
        Result := 'DEVICE_PROFILING_TIMER_RESOLUTION' else
      if DEVICE_ENDIAN_LITTLE = self then
        Result := 'DEVICE_ENDIAN_LITTLE' else
      if DEVICE_AVAILABLE = self then
        Result := 'DEVICE_AVAILABLE' else
      if DEVICE_COMPILER_AVAILABLE = self then
        Result := 'DEVICE_COMPILER_AVAILABLE' else
      if DEVICE_EXECUTION_CAPABILITIES = self then
        Result := 'DEVICE_EXECUTION_CAPABILITIES' else
      if DEVICE_QUEUE_PROPERTIES = self then
        Result := 'DEVICE_QUEUE_PROPERTIES' else
      if DEVICE_NAME = self then
        Result := 'DEVICE_NAME' else
      if DEVICE_VENDOR = self then
        Result := 'DEVICE_VENDOR' else
      if DRIVER_VERSION = self then
        Result := 'DRIVER_VERSION' else
      if DEVICE_PROFILE = self then
        Result := 'DEVICE_PROFILE' else
      if DEVICE_VERSION = self then
        Result := 'DEVICE_VERSION' else
      if DEVICE_EXTENSIONS = self then
        Result := 'DEVICE_EXTENSIONS' else
      if DEVICE_PLATFORM = self then
        Result := 'DEVICE_PLATFORM' else
      if DEVICE_DOUBLE_FP_CONFIG = self then
        Result := 'DEVICE_DOUBLE_FP_CONFIG' else
      if DEVICE_HALF_FP_CONFIG = self then
        Result := 'DEVICE_HALF_FP_CONFIG' else
      if DEVICE_PREFERRED_VECTOR_WIDTH_HALF = self then
        Result := 'DEVICE_PREFERRED_VECTOR_WIDTH_HALF' else
      if DEVICE_HOST_UNIFIED_MEMORY = self then
        Result := 'DEVICE_HOST_UNIFIED_MEMORY' else
      if DEVICE_NATIVE_VECTOR_WIDTH_CHAR = self then
        Result := 'DEVICE_NATIVE_VECTOR_WIDTH_CHAR' else
      if DEVICE_NATIVE_VECTOR_WIDTH_SHORT = self then
        Result := 'DEVICE_NATIVE_VECTOR_WIDTH_SHORT' else
      if DEVICE_NATIVE_VECTOR_WIDTH_INT = self then
        Result := 'DEVICE_NATIVE_VECTOR_WIDTH_INT' else
      if DEVICE_NATIVE_VECTOR_WIDTH_LONG = self then
        Result := 'DEVICE_NATIVE_VECTOR_WIDTH_LONG' else
      if DEVICE_NATIVE_VECTOR_WIDTH_FLOAT = self then
        Result := 'DEVICE_NATIVE_VECTOR_WIDTH_FLOAT' else
      if DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE = self then
        Result := 'DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE' else
      if DEVICE_NATIVE_VECTOR_WIDTH_HALF = self then
        Result := 'DEVICE_NATIVE_VECTOR_WIDTH_HALF' else
      if DEVICE_OPENCL_C_VERSION = self then
        Result := 'DEVICE_OPENCL_C_VERSION' else
      if DEVICE_LINKER_AVAILABLE = self then
        Result := 'DEVICE_LINKER_AVAILABLE' else
      if DEVICE_BUILT_IN_KERNELS = self then
        Result := 'DEVICE_BUILT_IN_KERNELS' else
      if DEVICE_IMAGE_MAX_BUFFER_SIZE = self then
        Result := 'DEVICE_IMAGE_MAX_BUFFER_SIZE' else
      if DEVICE_IMAGE_MAX_ARRAY_SIZE = self then
        Result := 'DEVICE_IMAGE_MAX_ARRAY_SIZE' else
      if DEVICE_PARENT_DEVICE = self then
        Result := 'DEVICE_PARENT_DEVICE' else
      if DEVICE_PARTITION_MAX_SUB_DEVICES = self then
        Result := 'DEVICE_PARTITION_MAX_SUB_DEVICES' else
      if DEVICE_PARTITION_PROPERTIES = self then
        Result := 'DEVICE_PARTITION_PROPERTIES' else
      if DEVICE_PARTITION_AFFINITY_DOMAIN = self then
        Result := 'DEVICE_PARTITION_AFFINITY_DOMAIN' else
      if DEVICE_PARTITION_TYPE = self then
        Result := 'DEVICE_PARTITION_TYPE' else
      if DEVICE_REFERENCE_COUNT = self then
        Result := 'DEVICE_REFERENCE_COUNT' else
      if DEVICE_PREFERRED_INTEROP_USER_SYNC = self then
        Result := 'DEVICE_PREFERRED_INTEROP_USER_SYNC' else
      if DEVICE_PRINTF_BUFFER_SIZE = self then
        Result := 'DEVICE_PRINTF_BUFFER_SIZE' else
      if DEVICE_IMAGE_PITCH_ALIGNMENT = self then
        Result := 'DEVICE_IMAGE_PITCH_ALIGNMENT' else
      if DEVICE_IMAGE_BASE_ADDRESS_ALIGNMENT = self then
        Result := 'DEVICE_IMAGE_BASE_ADDRESS_ALIGNMENT' else
      if DEVICE_MAX_READ_WRITE_IMAGE_ARGS = self then
        Result := 'DEVICE_MAX_READ_WRITE_IMAGE_ARGS' else
      if DEVICE_MAX_GLOBAL_VARIABLE_SIZE = self then
        Result := 'DEVICE_MAX_GLOBAL_VARIABLE_SIZE' else
      if DEVICE_QUEUE_ON_DEVICE_PROPERTIES = self then
        Result := 'DEVICE_QUEUE_ON_DEVICE_PROPERTIES' else
      if DEVICE_QUEUE_ON_DEVICE_PREFERRED_SIZE = self then
        Result := 'DEVICE_QUEUE_ON_DEVICE_PREFERRED_SIZE' else
      if DEVICE_QUEUE_ON_DEVICE_MAX_SIZE = self then
        Result := 'DEVICE_QUEUE_ON_DEVICE_MAX_SIZE' else
      if DEVICE_MAX_ON_DEVICE_QUEUES = self then
        Result := 'DEVICE_MAX_ON_DEVICE_QUEUES' else
      if DEVICE_MAX_ON_DEVICE_EVENTS = self then
        Result := 'DEVICE_MAX_ON_DEVICE_EVENTS' else
      if DEVICE_SVM_CAPABILITIES = self then
        Result := 'DEVICE_SVM_CAPABILITIES' else
      if DEVICE_GLOBAL_VARIABLE_PREFERRED_TOTAL_SIZE = self then
        Result := 'DEVICE_GLOBAL_VARIABLE_PREFERRED_TOTAL_SIZE' else
      if DEVICE_MAX_PIPE_ARGS = self then
        Result := 'DEVICE_MAX_PIPE_ARGS' else
      if DEVICE_PIPE_MAX_ACTIVE_RESERVATIONS = self then
        Result := 'DEVICE_PIPE_MAX_ACTIVE_RESERVATIONS' else
      if DEVICE_PIPE_MAX_PACKET_SIZE = self then
        Result := 'DEVICE_PIPE_MAX_PACKET_SIZE' else
      if DEVICE_PREFERRED_PLATFORM_ATOMIC_ALIGNMENT = self then
        Result := 'DEVICE_PREFERRED_PLATFORM_ATOMIC_ALIGNMENT' else
      if DEVICE_PREFERRED_GLOBAL_ATOMIC_ALIGNMENT = self then
        Result := 'DEVICE_PREFERRED_GLOBAL_ATOMIC_ALIGNMENT' else
      if DEVICE_PREFERRED_LOCAL_ATOMIC_ALIGNMENT = self then
        Result := 'DEVICE_PREFERRED_LOCAL_ATOMIC_ALIGNMENT' else
      if DEVICE_IL_VERSION = self then
        Result := 'DEVICE_IL_VERSION' else
      if DEVICE_MAX_NUM_SUB_GROUPS = self then
        Result := 'DEVICE_MAX_NUM_SUB_GROUPS' else
      if DEVICE_SUB_GROUP_INDEPENDENT_FORWARD_PROGRESS = self then
        Result := 'DEVICE_SUB_GROUP_INDEPENDENT_FORWARD_PROGRESS' else
      if DEVICE_NUMERIC_VERSION = self then
        Result := 'DEVICE_NUMERIC_VERSION' else
      if DEVICE_OPENCL_C_NUMERIC_VERSION = self then
        Result := 'DEVICE_OPENCL_C_NUMERIC_VERSION' else
      if DEVICE_EXTENSIONS_WITH_VERSION = self then
        Result := 'DEVICE_EXTENSIONS_WITH_VERSION' else
      if DEVICE_ILS_WITH_VERSION = self then
        Result := 'DEVICE_ILS_WITH_VERSION' else
      if DEVICE_BUILT_IN_KERNELS_WITH_VERSION = self then
        Result := 'DEVICE_BUILT_IN_KERNELS_WITH_VERSION' else
      if DEVICE_ATOMIC_MEMORY_CAPABILITIES = self then
        Result := 'DEVICE_ATOMIC_MEMORY_CAPABILITIES' else
      if DEVICE_ATOMIC_FENCE_CAPABILITIES = self then
        Result := 'DEVICE_ATOMIC_FENCE_CAPABILITIES' else
      if DEVICE_NON_UNIFORM_WORK_GROUP_SUPPORT = self then
        Result := 'DEVICE_NON_UNIFORM_WORK_GROUP_SUPPORT' else
      if DEVICE_OPENCL_C_ALL_VERSIONS = self then
        Result := 'DEVICE_OPENCL_C_ALL_VERSIONS' else
      if DEVICE_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = self then
        Result := 'DEVICE_PREFERRED_WORK_GROUP_SIZE_MULTIPLE' else
      if DEVICE_WORK_GROUP_COLLECTIVE_FUNCTIONS_SUPPORT = self then
        Result := 'DEVICE_WORK_GROUP_COLLECTIVE_FUNCTIONS_SUPPORT' else
      if DEVICE_GENERIC_ADDRESS_SPACE_SUPPORT = self then
        Result := 'DEVICE_GENERIC_ADDRESS_SPACE_SUPPORT' else
      if DEVICE_UUID = self then
        Result := 'DEVICE_UUID' else
      if DRIVER_UUID = self then
        Result := 'DRIVER_UUID' else
      if DEVICE_LUID_VALID = self then
        Result := 'DEVICE_LUID_VALID' else
      if DEVICE_LUID = self then
        Result := 'DEVICE_LUID' else
      if DEVICE_NODE_MASK = self then
        Result := 'DEVICE_NODE_MASK' else
      if DEVICE_OPENCL_C_FEATURES = self then
        Result := 'DEVICE_OPENCL_C_FEATURES' else
      if DEVICE_DEVICE_ENQUEUE_CAPABILITIES = self then
        Result := 'DEVICE_DEVICE_ENQUEUE_CAPABILITIES' else
      if DEVICE_PIPE_SUPPORT = self then
        Result := 'DEVICE_PIPE_SUPPORT' else
      if DEVICE_LATEST_CONFORMANCE_VERSION_PASSED = self then
        Result := 'DEVICE_LATEST_CONFORMANCE_VERSION_PASSED' else
      if DEVICE_INTEGER_DOT_PRODUCT_CAPABILITIES = self then
        Result := 'DEVICE_INTEGER_DOT_PRODUCT_CAPABILITIES' else
      if DEVICE_INTEGER_DOT_PRODUCT_ACCELERATION_PROPERTIES_8BIT = self then
        Result := 'DEVICE_INTEGER_DOT_PRODUCT_ACCELERATION_PROPERTIES_8BIT' else
      if DEVICE_INTEGER_DOT_PRODUCT_ACCELERATION_PROPERTIES_4x8BIT_PACKED = self then
        Result := 'DEVICE_INTEGER_DOT_PRODUCT_ACCELERATION_PROPERTIES_4x8BIT_PACKED' else
      if DEVICE_COMMAND_BUFFER_CAPABILITIES = self then
        Result := 'DEVICE_COMMAND_BUFFER_CAPABILITIES' else
      if DEVICE_COMMAND_BUFFER_REQUIRED_QUEUE_PROPERTIES = self then
        Result := 'DEVICE_COMMAND_BUFFER_REQUIRED_QUEUE_PROPERTIES' else
      if DEVICE_COMMAND_BUFFER_NUM_SYNC_DEVICES = self then
        Result := 'DEVICE_COMMAND_BUFFER_NUM_SYNC_DEVICES' else
      if DEVICE_COMMAND_BUFFER_SYNC_DEVICES = self then
        Result := 'DEVICE_COMMAND_BUFFER_SYNC_DEVICES' else
      if DEVICE_MUTABLE_DISPATCH_CAPABILITIES = self then
        Result := 'DEVICE_MUTABLE_DISPATCH_CAPABILITIES' else
      if DEVICE_TERMINATE_CAPABILITY = self then
        Result := 'DEVICE_TERMINATE_CAPABILITY' else
      if DEVICE_MAX_NAMED_BARRIER_COUNT = self then
        Result := 'DEVICE_MAX_NAMED_BARRIER_COUNT' else
      if DEVICE_SEMAPHORE_TYPES = self then
        Result := 'DEVICE_SEMAPHORE_TYPES' else
      if DEVICE_SEMAPHORE_IMPORT_HANDLE_TYPES = self then
        Result := 'DEVICE_SEMAPHORE_IMPORT_HANDLE_TYPES' else
      if DEVICE_SEMAPHORE_EXPORT_HANDLE_TYPES = self then
        Result := 'DEVICE_SEMAPHORE_EXPORT_HANDLE_TYPES' else
      if DEVICE_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES = self then
        Result := 'DEVICE_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES' else
      if DEVICE_EXTERNAL_MEMORY_IMPORT_ASSUME_LINEAR_IMAGES_HANDLE_TYPES = self then
        Result := 'DEVICE_EXTERNAL_MEMORY_IMPORT_ASSUME_LINEAR_IMAGES_HANDLE_TYPES' else
      if DEVICE_COMPUTE_CAPABILITY_MAJOR = self then
        Result := 'DEVICE_COMPUTE_CAPABILITY_MAJOR' else
      if DEVICE_COMPUTE_CAPABILITY_MINOR = self then
        Result := 'DEVICE_COMPUTE_CAPABILITY_MINOR' else
      if DEVICE_REGISTERS_PER_BLOCK = self then
        Result := 'DEVICE_REGISTERS_PER_BLOCK' else
      if DEVICE_WARP_SIZE = self then
        Result := 'DEVICE_WARP_SIZE' else
      if DEVICE_GPU_OVERLAP = self then
        Result := 'DEVICE_GPU_OVERLAP' else
      if DEVICE_KERNEL_EXEC_TIMEOUT = self then
        Result := 'DEVICE_KERNEL_EXEC_TIMEOUT' else
      if DEVICE_INTEGRATED_MEMORY = self then
        Result := 'DEVICE_INTEGRATED_MEMORY' else
      if DEVICE_PREFERRED_WORK_GROUP_SIZE = self then
        Result := 'DEVICE_PREFERRED_WORK_GROUP_SIZE' else
      if DEVICE_MAX_WORK_GROUP_SIZE_AMD = self then
        Result := 'DEVICE_MAX_WORK_GROUP_SIZE_AMD' else
      if DEVICE_PREFERRED_CONSTANT_BUFFER_SIZE = self then
        Result := 'DEVICE_PREFERRED_CONSTANT_BUFFER_SIZE' else
      if DEVICE_PCIE_ID = self then
        Result := 'DEVICE_PCIE_ID' else
      if DEVICE_PROFILING_TIMER_OFFSET = self then
        Result := 'DEVICE_PROFILING_TIMER_OFFSET' else
      if DEVICE_TOPOLOGY = self then
        Result := 'DEVICE_TOPOLOGY' else
      if DEVICE_BOARD_NAME = self then
        Result := 'DEVICE_BOARD_NAME' else
      if DEVICE_GLOBAL_FREE_MEMORY = self then
        Result := 'DEVICE_GLOBAL_FREE_MEMORY' else
      if DEVICE_SIMD_PER_COMPUTE_UNIT = self then
        Result := 'DEVICE_SIMD_PER_COMPUTE_UNIT' else
      if DEVICE_SIMD_WIDTH = self then
        Result := 'DEVICE_SIMD_WIDTH' else
      if DEVICE_SIMD_INSTRUCTION_WIDTH = self then
        Result := 'DEVICE_SIMD_INSTRUCTION_WIDTH' else
      if DEVICE_WAVEFRONT_WIDTH = self then
        Result := 'DEVICE_WAVEFRONT_WIDTH' else
      if DEVICE_GLOBAL_MEM_CHANNELS = self then
        Result := 'DEVICE_GLOBAL_MEM_CHANNELS' else
      if DEVICE_GLOBAL_MEM_CHANNEL_BANKS = self then
        Result := 'DEVICE_GLOBAL_MEM_CHANNEL_BANKS' else
      if DEVICE_GLOBAL_MEM_CHANNEL_BANK_WIDTH = self then
        Result := 'DEVICE_GLOBAL_MEM_CHANNEL_BANK_WIDTH' else
      if DEVICE_LOCAL_MEM_SIZE_PER_COMPUTE_UNIT = self then
        Result := 'DEVICE_LOCAL_MEM_SIZE_PER_COMPUTE_UNIT' else
      if DEVICE_LOCAL_MEM_BANKS = self then
        Result := 'DEVICE_LOCAL_MEM_BANKS' else
      if DEVICE_THREAD_TRACE_SUPPORTED = self then
        Result := 'DEVICE_THREAD_TRACE_SUPPORTED' else
      if DEVICE_GFXIP_MAJOR = self then
        Result := 'DEVICE_GFXIP_MAJOR' else
      if DEVICE_GFXIP_MINOR = self then
        Result := 'DEVICE_GFXIP_MINOR' else
      if DEVICE_AVAILABLE_ASYNC_QUEUES = self then
        Result := 'DEVICE_AVAILABLE_ASYNC_QUEUES' else
      if DEVICE_PARENT_DEVICE_EXT = self then
        Result := 'DEVICE_PARENT_DEVICE_EXT' else
      if DEVICE_PARTITION_TYPES = self then
        Result := 'DEVICE_PARTITION_TYPES' else
      if DEVICE_AFFINITY_DOMAINS = self then
        Result := 'DEVICE_AFFINITY_DOMAINS' else
      if DEVICE_REFERENCE_COUNT_EXT = self then
        Result := 'DEVICE_REFERENCE_COUNT_EXT' else
      if DEVICE_PARTITION_STYLE = self then
        Result := 'DEVICE_PARTITION_STYLE' else
      if DEVICE_ME_VERSION = self then
        Result := 'DEVICE_ME_VERSION' else
      if DEVICE_EXT_MEM_PADDING_IN_BYTES = self then
        Result := 'DEVICE_EXT_MEM_PADDING_IN_BYTES' else
      if DEVICE_PAGE_SIZE = self then
        Result := 'DEVICE_PAGE_SIZE' else
      if DEVICE_SVM_CAPABILITIES_ARM = self then
        Result := 'DEVICE_SVM_CAPABILITIES_ARM' else
      if DEVICE_COMPUTE_UNITS_BITFIELD = self then
        Result := 'DEVICE_COMPUTE_UNITS_BITFIELD' else
      if DEVICE_MEMORY_CAPABILITIES = self then
        Result := 'DEVICE_MEMORY_CAPABILITIES' else
      if DEVICE_SPIR_VERSIONS = self then
        Result := 'DEVICE_SPIR_VERSIONS' else
      if DEVICE_SIMULTANEOUS_INTEROPS = self then
        Result := 'DEVICE_SIMULTANEOUS_INTEROPS' else
      if DEVICE_NUM_SIMULTANEOUS_INTEROPS = self then
        Result := 'DEVICE_NUM_SIMULTANEOUS_INTEROPS' else
      if DEVICE_SUB_GROUP_SIZES = self then
        Result := 'DEVICE_SUB_GROUP_SIZES' else
      if DEVICE_AVC_ME_VERSION = self then
        Result := 'DEVICE_AVC_ME_VERSION' else
      if DEVICE_AVC_ME_SUPPORTS_TEXTURE_SAMPLER_USE = self then
        Result := 'DEVICE_AVC_ME_SUPPORTS_TEXTURE_SAMPLER_USE' else
      if DEVICE_AVC_ME_SUPPORTS_PREEMPTION = self then
        Result := 'DEVICE_AVC_ME_SUPPORTS_PREEMPTION' else
      if DEVICE_PCI_BUS_INFO = self then
        Result := 'DEVICE_PCI_BUS_INFO' else
      if DEVICE_PLANAR_YUV_MAX_WIDTH = self then
        Result := 'DEVICE_PLANAR_YUV_MAX_WIDTH' else
      if DEVICE_PLANAR_YUV_MAX_HEIGHT = self then
        Result := 'DEVICE_PLANAR_YUV_MAX_HEIGHT' else
      if DEVICE_QUEUE_FAMILY_PROPERTIES = self then
        Result := 'DEVICE_QUEUE_FAMILY_PROPERTIES' else
      if DEVICE_HOST_MEM_CAPABILITIES = self then
        Result := 'DEVICE_HOST_MEM_CAPABILITIES' else
      if DEVICE_DEVICE_MEM_CAPABILITIES = self then
        Result := 'DEVICE_DEVICE_MEM_CAPABILITIES' else
      if DEVICE_SINGLE_DEVICE_SHARED_MEM_CAPABILITIES = self then
        Result := 'DEVICE_SINGLE_DEVICE_SHARED_MEM_CAPABILITIES' else
      if DEVICE_CROSS_DEVICE_SHARED_MEM_CAPABILITIES = self then
        Result := 'DEVICE_CROSS_DEVICE_SHARED_MEM_CAPABILITIES' else
      if DEVICE_SHARED_SYSTEM_MEM_CAPABILITIES = self then
        Result := 'DEVICE_SHARED_SYSTEM_MEM_CAPABILITIES' else
      if DEVICE_JOB_SLOTS = self then
        Result := 'DEVICE_JOB_SLOTS' else
      if DEVICE_SCHEDULING_CONTROLS_CAPABILITIES = self then
        Result := 'DEVICE_SCHEDULING_CONTROLS_CAPABILITIES' else
      if DEVICE_MAX_WARP_COUNT = self then
        Result := 'DEVICE_MAX_WARP_COUNT' else
      if DEVICE_SUPPORTED_REGISTER_ALLOCATIONS = self then
        Result := 'DEVICE_SUPPORTED_REGISTER_ALLOCATIONS' else
      if DEVICE_CONTROLLED_TERMINATION_CAPABILITIES = self then
        Result := 'DEVICE_CONTROLLED_TERMINATION_CAPABILITIES' else
      if DEVICE_CXX_FOR_OPENCL_NUMERIC_VERSION = self then
        Result := 'DEVICE_CXX_FOR_OPENCL_NUMERIC_VERSION' else
      if DEVICE_SINGLE_FP_ATOMIC_CAPABILITIES = self then
        Result := 'DEVICE_SINGLE_FP_ATOMIC_CAPABILITIES' else
      if DEVICE_DOUBLE_FP_ATOMIC_CAPABILITIES = self then
        Result := 'DEVICE_DOUBLE_FP_ATOMIC_CAPABILITIES' else
      if DEVICE_HALF_FP_ATOMIC_CAPABILITIES = self then
        Result := 'DEVICE_HALF_FP_ATOMIC_CAPABILITIES' else
      if DEVICE_IP_VERSION = self then
        Result := 'DEVICE_IP_VERSION' else
      if DEVICE_ID = self then
        Result := 'DEVICE_ID' else
      if DEVICE_NUM_SLICES = self then
        Result := 'DEVICE_NUM_SLICES' else
      if DEVICE_NUM_SUB_SLICES_PER_SLICE = self then
        Result := 'DEVICE_NUM_SUB_SLICES_PER_SLICE' else
      if DEVICE_NUM_EUS_PER_SUB_SLICE = self then
        Result := 'DEVICE_NUM_EUS_PER_SUB_SLICE' else
      if DEVICE_NUM_THREADS_PER_EU = self then
        Result := 'DEVICE_NUM_THREADS_PER_EU' else
      if DEVICE_FEATURE_CAPABILITIES = self then
        Result := 'DEVICE_FEATURE_CAPABILITIES' else
        Result := $'clDeviceInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clDeviceIntegerDotProductCapabilities = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property DEVICE_INTEGER_DOT_PRODUCT_INPUT_4x8BIT_PACKED: clDeviceIntegerDotProductCapabilities read new clDeviceIntegerDotProductCapabilities(1 shl 0);
    public static property DEVICE_INTEGER_DOT_PRODUCT_INPUT_4x8BIT:        clDeviceIntegerDotProductCapabilities read new clDeviceIntegerDotProductCapabilities(1 shl 1);
    
    public static function operator+(v1, v2: clDeviceIntegerDotProductCapabilities) := new clDeviceIntegerDotProductCapabilities(v1.val or v2.val);
    public static function operator or(v1, v2: clDeviceIntegerDotProductCapabilities) := new clDeviceIntegerDotProductCapabilities(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clDeviceIntegerDotProductCapabilities; v2: clDeviceIntegerDotProductCapabilities) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clDeviceIntegerDotProductCapabilities) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clDeviceIntegerDotProductCapabilities[0]';
        exit;
      end;
      if DEVICE_INTEGER_DOT_PRODUCT_INPUT_4x8BIT_PACKED in self then
      begin
        res += 'DEVICE_INTEGER_DOT_PRODUCT_INPUT_4x8BIT_PACKED+';
        left_val := left_val and not DEVICE_INTEGER_DOT_PRODUCT_INPUT_4x8BIT_PACKED.val;
      end;
      if DEVICE_INTEGER_DOT_PRODUCT_INPUT_4x8BIT in self then
      begin
        res += 'DEVICE_INTEGER_DOT_PRODUCT_INPUT_4x8BIT+';
        left_val := left_val and not DEVICE_INTEGER_DOT_PRODUCT_INPUT_4x8BIT.val;
      end;
      if left_val<>0 then
      begin
        res += 'clDeviceIntegerDotProductCapabilities[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clDeviceLocalMemType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property LOCAL:  clDeviceLocalMemType read new clDeviceLocalMemType($0001);
    public static property GLOBAL: clDeviceLocalMemType read new clDeviceLocalMemType($0002);
    
    public function ToString: string; override;
    begin
      if LOCAL = self then
        Result := 'LOCAL' else
      if GLOBAL = self then
        Result := 'GLOBAL' else
        Result := $'clDeviceLocalMemType[{self.val}]';
    end;
    
  end;
  
  ///
  clDeviceMemCacheType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:             clDeviceMemCacheType read new clDeviceMemCacheType(0);
    public static property READ_ONLY_CACHE:  clDeviceMemCacheType read new clDeviceMemCacheType($0001);
    public static property READ_WRITE_CACHE: clDeviceMemCacheType read new clDeviceMemCacheType($0002);
    
    public function ToString: string; override;
    begin
      if NONE = self then
        Result := 'NONE' else
      if READ_ONLY_CACHE = self then
        Result := 'READ_ONLY_CACHE' else
      if READ_WRITE_CACHE = self then
        Result := 'READ_WRITE_CACHE' else
        Result := $'clDeviceMemCacheType[{self.val}]';
    end;
    
  end;
  
  ///
  clDeviceMeVersion = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ME_VERSION_LEGACY:         clDeviceMeVersion read new clDeviceMeVersion(0);
    public static property ME_VERSION_ADVANCED_VER_1: clDeviceMeVersion read new clDeviceMeVersion($0001);
    public static property ME_VERSION_ADVANCED_VER_2: clDeviceMeVersion read new clDeviceMeVersion($0002);
    
    public function ToString: string; override;
    begin
      if ME_VERSION_LEGACY = self then
        Result := 'ME_VERSION_LEGACY' else
      if ME_VERSION_ADVANCED_VER_1 = self then
        Result := 'ME_VERSION_ADVANCED_VER_1' else
      if ME_VERSION_ADVANCED_VER_2 = self then
        Result := 'ME_VERSION_ADVANCED_VER_2' else
        Result := $'clDeviceMeVersion[{self.val}]';
    end;
    
  end;
  
  ///
  clDeviceOnDeviceEnqueueCapabilities = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property DEVICE_QUEUE_SUPPORTED:           clDeviceOnDeviceEnqueueCapabilities read new clDeviceOnDeviceEnqueueCapabilities(1 shl 0);
    public static property DEVICE_QUEUE_REPLACEABLE_DEFAULT: clDeviceOnDeviceEnqueueCapabilities read new clDeviceOnDeviceEnqueueCapabilities(1 shl 1);
    
    public static function operator+(v1, v2: clDeviceOnDeviceEnqueueCapabilities) := new clDeviceOnDeviceEnqueueCapabilities(v1.val or v2.val);
    public static function operator or(v1, v2: clDeviceOnDeviceEnqueueCapabilities) := new clDeviceOnDeviceEnqueueCapabilities(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clDeviceOnDeviceEnqueueCapabilities; v2: clDeviceOnDeviceEnqueueCapabilities) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clDeviceOnDeviceEnqueueCapabilities) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clDeviceOnDeviceEnqueueCapabilities[0]';
        exit;
      end;
      if DEVICE_QUEUE_SUPPORTED in self then
      begin
        res += 'DEVICE_QUEUE_SUPPORTED+';
        left_val := left_val and not DEVICE_QUEUE_SUPPORTED.val;
      end;
      if DEVICE_QUEUE_REPLACEABLE_DEFAULT in self then
      begin
        res += 'DEVICE_QUEUE_REPLACEABLE_DEFAULT+';
        left_val := left_val and not DEVICE_QUEUE_REPLACEABLE_DEFAULT.val;
      end;
      if left_val<>0 then
      begin
        res += 'clDeviceOnDeviceEnqueueCapabilities[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clDevicePartitionProperty = record
    public val: IntPtr;
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property DEVICE_PARTITION_BY_COUNTS_LIST_END: clDevicePartitionProperty read new clDevicePartitionProperty(0);
    public static property PARTITION_BY_NAMES_LIST_END:         clDevicePartitionProperty read new clDevicePartitionProperty(-1);
    public static property DEVICE_PARTITION_EQUALLY:            clDevicePartitionProperty read new clDevicePartitionProperty($1086);
    public static property DEVICE_PARTITION_BY_COUNTS:          clDevicePartitionProperty read new clDevicePartitionProperty($1087);
    public static property DEVICE_PARTITION_BY_AFFINITY_DOMAIN: clDevicePartitionProperty read new clDevicePartitionProperty($1088);
    public static property DEVICE_PARTITION_BY_NAMES:           clDevicePartitionProperty read new clDevicePartitionProperty($4052);
    
    public function ToString: string; override;
    begin
      if DEVICE_PARTITION_BY_COUNTS_LIST_END = self then
        Result := 'DEVICE_PARTITION_BY_COUNTS_LIST_END' else
      if PARTITION_BY_NAMES_LIST_END = self then
        Result := 'PARTITION_BY_NAMES_LIST_END' else
      if DEVICE_PARTITION_EQUALLY = self then
        Result := 'DEVICE_PARTITION_EQUALLY' else
      if DEVICE_PARTITION_BY_COUNTS = self then
        Result := 'DEVICE_PARTITION_BY_COUNTS' else
      if DEVICE_PARTITION_BY_AFFINITY_DOMAIN = self then
        Result := 'DEVICE_PARTITION_BY_AFFINITY_DOMAIN' else
      if DEVICE_PARTITION_BY_NAMES = self then
        Result := 'DEVICE_PARTITION_BY_NAMES' else
        Result := $'clDevicePartitionProperty[{self.val}]';
    end;
    
  end;
  
  ///
  clDeviceSchedulingControlsCapabilities = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property DEVICE_SCHEDULING_KERNEL_BATCHING:               clDeviceSchedulingControlsCapabilities read new clDeviceSchedulingControlsCapabilities(1 shl 0);
    public static property DEVICE_SCHEDULING_WORKGROUP_BATCH_SIZE:          clDeviceSchedulingControlsCapabilities read new clDeviceSchedulingControlsCapabilities(1 shl 1);
    public static property DEVICE_SCHEDULING_WORKGROUP_BATCH_SIZE_MODIFIER: clDeviceSchedulingControlsCapabilities read new clDeviceSchedulingControlsCapabilities(1 shl 2);
    public static property DEVICE_SCHEDULING_DEFERRED_FLUSH:                clDeviceSchedulingControlsCapabilities read new clDeviceSchedulingControlsCapabilities(1 shl 3);
    public static property DEVICE_SCHEDULING_REGISTER_ALLOCATION:           clDeviceSchedulingControlsCapabilities read new clDeviceSchedulingControlsCapabilities(1 shl 4);
    public static property DEVICE_SCHEDULING_WARP_THROTTLING:               clDeviceSchedulingControlsCapabilities read new clDeviceSchedulingControlsCapabilities(1 shl 5);
    public static property DEVICE_SCHEDULING_COMPUTE_UNIT_BATCH_QUEUE_SIZE: clDeviceSchedulingControlsCapabilities read new clDeviceSchedulingControlsCapabilities(1 shl 6);
    public static property DEVICE_SCHEDULING_COMPUTE_UNIT_LIMIT:            clDeviceSchedulingControlsCapabilities read new clDeviceSchedulingControlsCapabilities(1 shl 7);
    
    public static function operator+(v1, v2: clDeviceSchedulingControlsCapabilities) := new clDeviceSchedulingControlsCapabilities(v1.val or v2.val);
    public static function operator or(v1, v2: clDeviceSchedulingControlsCapabilities) := new clDeviceSchedulingControlsCapabilities(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clDeviceSchedulingControlsCapabilities; v2: clDeviceSchedulingControlsCapabilities) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clDeviceSchedulingControlsCapabilities) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clDeviceSchedulingControlsCapabilities[0]';
        exit;
      end;
      if DEVICE_SCHEDULING_KERNEL_BATCHING in self then
      begin
        res += 'DEVICE_SCHEDULING_KERNEL_BATCHING+';
        left_val := left_val and not DEVICE_SCHEDULING_KERNEL_BATCHING.val;
      end;
      if DEVICE_SCHEDULING_WORKGROUP_BATCH_SIZE in self then
      begin
        res += 'DEVICE_SCHEDULING_WORKGROUP_BATCH_SIZE+';
        left_val := left_val and not DEVICE_SCHEDULING_WORKGROUP_BATCH_SIZE.val;
      end;
      if DEVICE_SCHEDULING_WORKGROUP_BATCH_SIZE_MODIFIER in self then
      begin
        res += 'DEVICE_SCHEDULING_WORKGROUP_BATCH_SIZE_MODIFIER+';
        left_val := left_val and not DEVICE_SCHEDULING_WORKGROUP_BATCH_SIZE_MODIFIER.val;
      end;
      if DEVICE_SCHEDULING_DEFERRED_FLUSH in self then
      begin
        res += 'DEVICE_SCHEDULING_DEFERRED_FLUSH+';
        left_val := left_val and not DEVICE_SCHEDULING_DEFERRED_FLUSH.val;
      end;
      if DEVICE_SCHEDULING_REGISTER_ALLOCATION in self then
      begin
        res += 'DEVICE_SCHEDULING_REGISTER_ALLOCATION+';
        left_val := left_val and not DEVICE_SCHEDULING_REGISTER_ALLOCATION.val;
      end;
      if DEVICE_SCHEDULING_WARP_THROTTLING in self then
      begin
        res += 'DEVICE_SCHEDULING_WARP_THROTTLING+';
        left_val := left_val and not DEVICE_SCHEDULING_WARP_THROTTLING.val;
      end;
      if DEVICE_SCHEDULING_COMPUTE_UNIT_BATCH_QUEUE_SIZE in self then
      begin
        res += 'DEVICE_SCHEDULING_COMPUTE_UNIT_BATCH_QUEUE_SIZE+';
        left_val := left_val and not DEVICE_SCHEDULING_COMPUTE_UNIT_BATCH_QUEUE_SIZE.val;
      end;
      if DEVICE_SCHEDULING_COMPUTE_UNIT_LIMIT in self then
      begin
        res += 'DEVICE_SCHEDULING_COMPUTE_UNIT_LIMIT+';
        left_val := left_val and not DEVICE_SCHEDULING_COMPUTE_UNIT_LIMIT.val;
      end;
      if left_val<>0 then
      begin
        res += 'clDeviceSchedulingControlsCapabilities[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clDeviceSVMCapabilities = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property DEVICE_SVM_COARSE_GRAIN_BUFFER: clDeviceSVMCapabilities read new clDeviceSVMCapabilities(1 shl 0);
    public static property DEVICE_SVM_FINE_GRAIN_BUFFER:   clDeviceSVMCapabilities read new clDeviceSVMCapabilities(1 shl 1);
    public static property DEVICE_SVM_FINE_GRAIN_SYSTEM:   clDeviceSVMCapabilities read new clDeviceSVMCapabilities(1 shl 2);
    public static property DEVICE_SVM_ATOMICS:             clDeviceSVMCapabilities read new clDeviceSVMCapabilities(1 shl 3);
    
    public static function operator+(v1, v2: clDeviceSVMCapabilities) := new clDeviceSVMCapabilities(v1.val or v2.val);
    public static function operator or(v1, v2: clDeviceSVMCapabilities) := new clDeviceSVMCapabilities(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clDeviceSVMCapabilities; v2: clDeviceSVMCapabilities) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clDeviceSVMCapabilities) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clDeviceSVMCapabilities[0]';
        exit;
      end;
      if DEVICE_SVM_COARSE_GRAIN_BUFFER in self then
      begin
        res += 'DEVICE_SVM_COARSE_GRAIN_BUFFER+';
        left_val := left_val and not DEVICE_SVM_COARSE_GRAIN_BUFFER.val;
      end;
      if DEVICE_SVM_FINE_GRAIN_BUFFER in self then
      begin
        res += 'DEVICE_SVM_FINE_GRAIN_BUFFER+';
        left_val := left_val and not DEVICE_SVM_FINE_GRAIN_BUFFER.val;
      end;
      if DEVICE_SVM_FINE_GRAIN_SYSTEM in self then
      begin
        res += 'DEVICE_SVM_FINE_GRAIN_SYSTEM+';
        left_val := left_val and not DEVICE_SVM_FINE_GRAIN_SYSTEM.val;
      end;
      if DEVICE_SVM_ATOMICS in self then
      begin
        res += 'DEVICE_SVM_ATOMICS+';
        left_val := left_val and not DEVICE_SVM_ATOMICS.val;
      end;
      if left_val<>0 then
      begin
        res += 'clDeviceSVMCapabilities[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clDeviceTerminateCapability = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property DEVICE_TERMINATE_CAPABILITY_CONTEXT: clDeviceTerminateCapability read new clDeviceTerminateCapability(1 shl 0);
    
    public static function operator+(v1, v2: clDeviceTerminateCapability) := new clDeviceTerminateCapability(v1.val or v2.val);
    public static function operator or(v1, v2: clDeviceTerminateCapability) := new clDeviceTerminateCapability(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clDeviceTerminateCapability; v2: clDeviceTerminateCapability) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clDeviceTerminateCapability) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clDeviceTerminateCapability[0]';
        exit;
      end;
      if DEVICE_TERMINATE_CAPABILITY_CONTEXT in self then
      begin
        res += 'DEVICE_TERMINATE_CAPABILITY_CONTEXT+';
        left_val := left_val and not DEVICE_TERMINATE_CAPABILITY_CONTEXT.val;
      end;
      if left_val<>0 then
      begin
        res += 'clDeviceTerminateCapability[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clDeviceType = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property DEVICE_TYPE_DEFAULT:     clDeviceType read new clDeviceType(1 shl 0);
    public static property DEVICE_TYPE_CPU:         clDeviceType read new clDeviceType(1 shl 1);
    public static property DEVICE_TYPE_GPU:         clDeviceType read new clDeviceType(1 shl 2);
    public static property DEVICE_TYPE_ACCELERATOR: clDeviceType read new clDeviceType(1 shl 3);
    public static property DEVICE_TYPE_CUSTOM:      clDeviceType read new clDeviceType(1 shl 4);
    public static property DEVICE_TYPE_ALL:         clDeviceType read new clDeviceType($FFFFFFFF);
    
    public static function operator+(v1, v2: clDeviceType) := new clDeviceType(v1.val or v2.val);
    public static function operator or(v1, v2: clDeviceType) := new clDeviceType(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clDeviceType; v2: clDeviceType) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clDeviceType) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clDeviceType[0]';
        exit;
      end;
      if DEVICE_TYPE_DEFAULT in self then
      begin
        res += 'DEVICE_TYPE_DEFAULT+';
        left_val := left_val and not DEVICE_TYPE_DEFAULT.val;
      end;
      if DEVICE_TYPE_CPU in self then
      begin
        res += 'DEVICE_TYPE_CPU+';
        left_val := left_val and not DEVICE_TYPE_CPU.val;
      end;
      if DEVICE_TYPE_GPU in self then
      begin
        res += 'DEVICE_TYPE_GPU+';
        left_val := left_val and not DEVICE_TYPE_GPU.val;
      end;
      if DEVICE_TYPE_ACCELERATOR in self then
      begin
        res += 'DEVICE_TYPE_ACCELERATOR+';
        left_val := left_val and not DEVICE_TYPE_ACCELERATOR.val;
      end;
      if DEVICE_TYPE_CUSTOM in self then
      begin
        res += 'DEVICE_TYPE_CUSTOM+';
        left_val := left_val and not DEVICE_TYPE_CUSTOM.val;
      end;
      if DEVICE_TYPE_ALL in self then
      begin
        res += 'DEVICE_TYPE_ALL+';
        left_val := left_val and not DEVICE_TYPE_ALL.val;
      end;
      if left_val<>0 then
      begin
        res += 'clDeviceType[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clDeviceUnifiedSharedMemoryCapabilities = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property UNIFIED_SHARED_MEMORY_ACCESS:                   clDeviceUnifiedSharedMemoryCapabilities read new clDeviceUnifiedSharedMemoryCapabilities(1 shl 0);
    public static property UNIFIED_SHARED_MEMORY_ATOMIC_ACCESS:            clDeviceUnifiedSharedMemoryCapabilities read new clDeviceUnifiedSharedMemoryCapabilities(1 shl 1);
    public static property UNIFIED_SHARED_MEMORY_CONCURRENT_ACCESS:        clDeviceUnifiedSharedMemoryCapabilities read new clDeviceUnifiedSharedMemoryCapabilities(1 shl 2);
    public static property UNIFIED_SHARED_MEMORY_CONCURRENT_ATOMIC_ACCESS: clDeviceUnifiedSharedMemoryCapabilities read new clDeviceUnifiedSharedMemoryCapabilities(1 shl 3);
    
    public static function operator+(v1, v2: clDeviceUnifiedSharedMemoryCapabilities) := new clDeviceUnifiedSharedMemoryCapabilities(v1.val or v2.val);
    public static function operator or(v1, v2: clDeviceUnifiedSharedMemoryCapabilities) := new clDeviceUnifiedSharedMemoryCapabilities(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clDeviceUnifiedSharedMemoryCapabilities; v2: clDeviceUnifiedSharedMemoryCapabilities) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clDeviceUnifiedSharedMemoryCapabilities) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clDeviceUnifiedSharedMemoryCapabilities[0]';
        exit;
      end;
      if UNIFIED_SHARED_MEMORY_ACCESS in self then
      begin
        res += 'UNIFIED_SHARED_MEMORY_ACCESS+';
        left_val := left_val and not UNIFIED_SHARED_MEMORY_ACCESS.val;
      end;
      if UNIFIED_SHARED_MEMORY_ATOMIC_ACCESS in self then
      begin
        res += 'UNIFIED_SHARED_MEMORY_ATOMIC_ACCESS+';
        left_val := left_val and not UNIFIED_SHARED_MEMORY_ATOMIC_ACCESS.val;
      end;
      if UNIFIED_SHARED_MEMORY_CONCURRENT_ACCESS in self then
      begin
        res += 'UNIFIED_SHARED_MEMORY_CONCURRENT_ACCESS+';
        left_val := left_val and not UNIFIED_SHARED_MEMORY_CONCURRENT_ACCESS.val;
      end;
      if UNIFIED_SHARED_MEMORY_CONCURRENT_ATOMIC_ACCESS in self then
      begin
        res += 'UNIFIED_SHARED_MEMORY_CONCURRENT_ATOMIC_ACCESS+';
        left_val := left_val and not UNIFIED_SHARED_MEMORY_CONCURRENT_ATOMIC_ACCESS.val;
      end;
      if left_val<>0 then
      begin
        res += 'clDeviceUnifiedSharedMemoryCapabilities[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clDx9DeviceSet = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PREFERRED_DEVICES_FOR_DX9: clDx9DeviceSet read new clDx9DeviceSet($4024);
    public static property ALL_DEVICES_FOR_DX9:       clDx9DeviceSet read new clDx9DeviceSet($4025);
    
    public function ToString: string; override;
    begin
      if PREFERRED_DEVICES_FOR_DX9 = self then
        Result := 'PREFERRED_DEVICES_FOR_DX9' else
      if ALL_DEVICES_FOR_DX9 = self then
        Result := 'ALL_DEVICES_FOR_DX9' else
        Result := $'clDx9DeviceSet[{self.val}]';
    end;
    
  end;
  
  ///
  clDx9DeviceSource = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property D3D9_DEVICE:   clDx9DeviceSource read new clDx9DeviceSource($4022);
    public static property D3D9EX_DEVICE: clDx9DeviceSource read new clDx9DeviceSource($4070);
    public static property DXVA_DEVICE:   clDx9DeviceSource read new clDx9DeviceSource($4071);
    
    public function ToString: string; override;
    begin
      if D3D9_DEVICE = self then
        Result := 'D3D9_DEVICE' else
      if D3D9EX_DEVICE = self then
        Result := 'D3D9EX_DEVICE' else
      if DXVA_DEVICE = self then
        Result := 'DXVA_DEVICE' else
        Result := $'clDx9DeviceSource[{self.val}]';
    end;
    
  end;
  
  ///
  clDx9MediaAdapterSet = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PREFERRED_DEVICES_FOR_DX9_MEDIA_ADAPTER: clDx9MediaAdapterSet read new clDx9MediaAdapterSet($2023);
    public static property ALL_DEVICES_FOR_DX9_MEDIA_ADAPTER:       clDx9MediaAdapterSet read new clDx9MediaAdapterSet($2024);
    
    public function ToString: string; override;
    begin
      if PREFERRED_DEVICES_FOR_DX9_MEDIA_ADAPTER = self then
        Result := 'PREFERRED_DEVICES_FOR_DX9_MEDIA_ADAPTER' else
      if ALL_DEVICES_FOR_DX9_MEDIA_ADAPTER = self then
        Result := 'ALL_DEVICES_FOR_DX9_MEDIA_ADAPTER' else
        Result := $'clDx9MediaAdapterSet[{self.val}]';
    end;
    
  end;
  
  ///
  clDx9MediaAdapterType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ADAPTER_D3D9:   clDx9MediaAdapterType read new clDx9MediaAdapterType($2020);
    public static property ADAPTER_D3D9EX: clDx9MediaAdapterType read new clDx9MediaAdapterType($2021);
    public static property ADAPTER_DXVA:   clDx9MediaAdapterType read new clDx9MediaAdapterType($2022);
    
    public function ToString: string; override;
    begin
      if ADAPTER_D3D9 = self then
        Result := 'ADAPTER_D3D9' else
      if ADAPTER_D3D9EX = self then
        Result := 'ADAPTER_D3D9EX' else
      if ADAPTER_DXVA = self then
        Result := 'ADAPTER_DXVA' else
        Result := $'clDx9MediaAdapterType[{self.val}]';
    end;
    
  end;
  
  ///
  clEglImageProperties = record
    public val: IntPtr;
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property EGL_YUV_PLANE: clEglImageProperties read new clEglImageProperties($4107);
    
    public function ToString: string; override;
    begin
      if EGL_YUV_PLANE = self then
        Result := 'EGL_YUV_PLANE' else
        Result := $'clEglImageProperties[{self.val}]';
    end;
    
  end;
  
  ///
  clErrorCode = record
    public val: Int32;
    public constructor(val: Int32) := self.val := val;
    
    public static property SUCCESS:                                   clErrorCode read new clErrorCode(0);
    public static property DEVICE_NOT_FOUND:                          clErrorCode read new clErrorCode(-1);
    public static property DEVICE_NOT_AVAILABLE:                      clErrorCode read new clErrorCode(-2);
    public static property COMPILER_NOT_AVAILABLE:                    clErrorCode read new clErrorCode(-3);
    public static property MEM_OBJECT_ALLOCATION_FAILURE:             clErrorCode read new clErrorCode(-4);
    public static property OUT_OF_RESOURCES:                          clErrorCode read new clErrorCode(-5);
    public static property OUT_OF_HOST_MEMORY:                        clErrorCode read new clErrorCode(-6);
    public static property PROFILING_INFO_NOT_AVAILABLE:              clErrorCode read new clErrorCode(-7);
    public static property MEM_COPY_OVERLAP:                          clErrorCode read new clErrorCode(-8);
    public static property IMAGE_FORMAT_MISMATCH:                     clErrorCode read new clErrorCode(-9);
    public static property IMAGE_FORMAT_NOT_SUPPORTED:                clErrorCode read new clErrorCode(-10);
    public static property BUILD_PROGRAM_FAILURE:                     clErrorCode read new clErrorCode(-11);
    public static property MAP_FAILURE:                               clErrorCode read new clErrorCode(-12);
    public static property MISALIGNED_SUB_BUFFER_OFFSET:              clErrorCode read new clErrorCode(-13);
    public static property EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST: clErrorCode read new clErrorCode(-14);
    public static property COMPILE_PROGRAM_FAILURE:                   clErrorCode read new clErrorCode(-15);
    public static property LINKER_NOT_AVAILABLE:                      clErrorCode read new clErrorCode(-16);
    public static property LINK_PROGRAM_FAILURE:                      clErrorCode read new clErrorCode(-17);
    public static property DEVICE_PARTITION_FAILED:                   clErrorCode read new clErrorCode(-18);
    public static property KERNEL_ARG_INFO_NOT_AVAILABLE:             clErrorCode read new clErrorCode(-19);
    public static property INVALID_VALUE:                             clErrorCode read new clErrorCode(-30);
    public static property INVALID_DEVICE_TYPE:                       clErrorCode read new clErrorCode(-31);
    public static property INVALID_PLATFORM:                          clErrorCode read new clErrorCode(-32);
    public static property INVALID_DEVICE:                            clErrorCode read new clErrorCode(-33);
    public static property INVALID_CONTEXT:                           clErrorCode read new clErrorCode(-34);
    public static property INVALID_QUEUE_PROPERTIES:                  clErrorCode read new clErrorCode(-35);
    public static property INVALID_COMMAND_QUEUE:                     clErrorCode read new clErrorCode(-36);
    public static property INVALID_HOST_PTR:                          clErrorCode read new clErrorCode(-37);
    public static property INVALID_MEM_OBJECT:                        clErrorCode read new clErrorCode(-38);
    public static property INVALID_IMAGE_FORMAT_DESCRIPTOR:           clErrorCode read new clErrorCode(-39);
    public static property INVALID_IMAGE_SIZE:                        clErrorCode read new clErrorCode(-40);
    public static property INVALID_SAMPLER:                           clErrorCode read new clErrorCode(-41);
    public static property INVALID_BINARY:                            clErrorCode read new clErrorCode(-42);
    public static property INVALID_BUILD_OPTIONS:                     clErrorCode read new clErrorCode(-43);
    public static property INVALID_PROGRAM:                           clErrorCode read new clErrorCode(-44);
    public static property INVALID_PROGRAM_EXECUTABLE:                clErrorCode read new clErrorCode(-45);
    public static property INVALID_KERNEL_NAME:                       clErrorCode read new clErrorCode(-46);
    public static property INVALID_KERNEL_DEFINITION:                 clErrorCode read new clErrorCode(-47);
    public static property INVALID_KERNEL:                            clErrorCode read new clErrorCode(-48);
    public static property INVALID_ARG_INDEX:                         clErrorCode read new clErrorCode(-49);
    public static property INVALID_ARG_VALUE:                         clErrorCode read new clErrorCode(-50);
    public static property INVALID_ARG_SIZE:                          clErrorCode read new clErrorCode(-51);
    public static property INVALID_KERNEL_ARGS:                       clErrorCode read new clErrorCode(-52);
    public static property INVALID_WORK_DIMENSION:                    clErrorCode read new clErrorCode(-53);
    public static property INVALID_WORK_GROUP_SIZE:                   clErrorCode read new clErrorCode(-54);
    public static property INVALID_WORK_ITEM_SIZE:                    clErrorCode read new clErrorCode(-55);
    public static property INVALID_GLOBAL_OFFSET:                     clErrorCode read new clErrorCode(-56);
    public static property INVALID_EVENT_WAIT_LIST:                   clErrorCode read new clErrorCode(-57);
    public static property INVALID_EVENT:                             clErrorCode read new clErrorCode(-58);
    public static property INVALID_OPERATION:                         clErrorCode read new clErrorCode(-59);
    public static property INVALID_GL_OBJECT:                         clErrorCode read new clErrorCode(-60);
    public static property INVALID_BUFFER_SIZE:                       clErrorCode read new clErrorCode(-61);
    public static property INVALID_MIP_LEVEL:                         clErrorCode read new clErrorCode(-62);
    public static property INVALID_GLOBAL_WORK_SIZE:                  clErrorCode read new clErrorCode(-63);
    public static property INVALID_PROPERTY:                          clErrorCode read new clErrorCode(-64);
    public static property INVALID_IMAGE_DESCRIPTOR:                  clErrorCode read new clErrorCode(-65);
    public static property INVALID_COMPILER_OPTIONS:                  clErrorCode read new clErrorCode(-66);
    public static property INVALID_LINKER_OPTIONS:                    clErrorCode read new clErrorCode(-67);
    public static property INVALID_DEVICE_PARTITION_COUNT:            clErrorCode read new clErrorCode(-68);
    public static property INVALID_PIPE_SIZE:                         clErrorCode read new clErrorCode(-69);
    public static property INVALID_DEVICE_QUEUE:                      clErrorCode read new clErrorCode(-70);
    public static property INVALID_SPEC_ID:                           clErrorCode read new clErrorCode(-71);
    public static property MAX_SIZE_RESTRICTION_EXCEEDED:             clErrorCode read new clErrorCode(-72);
    public static property INVALID_GL_SHAREGROUP_REFERENCE:           clErrorCode read new clErrorCode(-1000);
    public static property PLATFORM_NOT_FOUND:                        clErrorCode read new clErrorCode(-1001);
    public static property INVALID_D3D10_DEVICE:                      clErrorCode read new clErrorCode(-1002);
    public static property INVALID_D3D10_RESOURCE:                    clErrorCode read new clErrorCode(-1003);
    public static property D3D10_RESOURCE_ALREADY_ACQUIRED:           clErrorCode read new clErrorCode(-1004);
    public static property D3D10_RESOURCE_NOT_ACQUIRED:               clErrorCode read new clErrorCode(-1005);
    public static property INVALID_D3D11_DEVICE:                      clErrorCode read new clErrorCode(-1006);
    public static property INVALID_D3D11_RESOURCE:                    clErrorCode read new clErrorCode(-1007);
    public static property D3D11_RESOURCE_ALREADY_ACQUIRED:           clErrorCode read new clErrorCode(-1008);
    public static property D3D11_RESOURCE_NOT_ACQUIRED:               clErrorCode read new clErrorCode(-1009);
    public static property INVALID_DX9_MEDIA_ADAPTER:                 clErrorCode read new clErrorCode(-1010);
    public static property INVALID_DX9_DEVICE:                        clErrorCode read new clErrorCode(-1010);
    public static property INVALID_DX9_MEDIA_SURFACE:                 clErrorCode read new clErrorCode(-1011);
    public static property INVALID_DX9_RESOURCE:                      clErrorCode read new clErrorCode(-1011);
    public static property DX9_MEDIA_SURFACE_ALREADY_ACQUIRED:        clErrorCode read new clErrorCode(-1012);
    public static property DX9_RESOURCE_ALREADY_ACQUIRED:             clErrorCode read new clErrorCode(-1012);
    public static property DX9_MEDIA_SURFACE_NOT_ACQUIRED:            clErrorCode read new clErrorCode(-1013);
    public static property DX9_RESOURCE_NOT_ACQUIRED:                 clErrorCode read new clErrorCode(-1013);
    public static property DEVICE_PARTITION_FAILED_EXT:               clErrorCode read new clErrorCode(-1057);
    public static property INVALID_PARTITION_COUNT:                   clErrorCode read new clErrorCode(-1058);
    public static property INVALID_PARTITION_NAME:                    clErrorCode read new clErrorCode(-1059);
    public static property EGL_RESOURCE_NOT_ACQUIRED:                 clErrorCode read new clErrorCode(-1092);
    public static property INVALID_EGL_OBJECT:                        clErrorCode read new clErrorCode(-1093);
    public static property INVALID_ACCELERATOR:                       clErrorCode read new clErrorCode(-1094);
    public static property INVALID_ACCELERATOR_TYPE:                  clErrorCode read new clErrorCode(-1095);
    public static property INVALID_ACCELERATOR_DESCRIPTOR:            clErrorCode read new clErrorCode(-1096);
    public static property ACCELERATOR_TYPE_NOT_SUPPORTED:            clErrorCode read new clErrorCode(-1097);
    public static property INVALID_VA_API_MEDIA_ADAPTER:              clErrorCode read new clErrorCode(-1098);
    public static property INVALID_VA_API_MEDIA_SURFACE:              clErrorCode read new clErrorCode(-1099);
    public static property VA_API_MEDIA_SURFACE_ALREADY_ACQUIRED:     clErrorCode read new clErrorCode(-1100);
    public static property VA_API_MEDIA_SURFACE_NOT_ACQUIRED:         clErrorCode read new clErrorCode(-1101);
    public static property COMMAND_TERMINATED_ITSELF_WITH_FAILURE:    clErrorCode read new clErrorCode(-1108);
    public static property CONTEXT_TERMINATED:                        clErrorCode read new clErrorCode(-1121);
    public static property INVALID_COMMAND_BUFFER:                    clErrorCode read new clErrorCode(-1138);
    public static property INVALID_SYNC_POINT_WAIT_LIST:              clErrorCode read new clErrorCode(-1139);
    public static property INCOMPATIBLE_COMMAND_QUEUE:                clErrorCode read new clErrorCode(-1140);
    public static property INVALID_MUTABLE_COMMAND:                   clErrorCode read new clErrorCode(-1141);
    public static property INVALID_SEMAPHORE:                         clErrorCode read new clErrorCode(-1142);
    public static property KERNEL_EXECUTION_ERROR:                    clErrorCode read new clErrorCode(-9999);
    public static property GRALLOC_RESOURCE_NOT_ACQUIRED:             clErrorCode read new clErrorCode($40D4);
    public static property INVALID_GRALLOC_OBJECT:                    clErrorCode read new clErrorCode($40D5);
    
    public function ToString: string; override;
    begin
      if SUCCESS = self then
        Result := 'SUCCESS' else
      if DEVICE_NOT_FOUND = self then
        Result := 'DEVICE_NOT_FOUND' else
      if DEVICE_NOT_AVAILABLE = self then
        Result := 'DEVICE_NOT_AVAILABLE' else
      if COMPILER_NOT_AVAILABLE = self then
        Result := 'COMPILER_NOT_AVAILABLE' else
      if MEM_OBJECT_ALLOCATION_FAILURE = self then
        Result := 'MEM_OBJECT_ALLOCATION_FAILURE' else
      if OUT_OF_RESOURCES = self then
        Result := 'OUT_OF_RESOURCES' else
      if OUT_OF_HOST_MEMORY = self then
        Result := 'OUT_OF_HOST_MEMORY' else
      if PROFILING_INFO_NOT_AVAILABLE = self then
        Result := 'PROFILING_INFO_NOT_AVAILABLE' else
      if MEM_COPY_OVERLAP = self then
        Result := 'MEM_COPY_OVERLAP' else
      if IMAGE_FORMAT_MISMATCH = self then
        Result := 'IMAGE_FORMAT_MISMATCH' else
      if IMAGE_FORMAT_NOT_SUPPORTED = self then
        Result := 'IMAGE_FORMAT_NOT_SUPPORTED' else
      if BUILD_PROGRAM_FAILURE = self then
        Result := 'BUILD_PROGRAM_FAILURE' else
      if MAP_FAILURE = self then
        Result := 'MAP_FAILURE' else
      if MISALIGNED_SUB_BUFFER_OFFSET = self then
        Result := 'MISALIGNED_SUB_BUFFER_OFFSET' else
      if EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST = self then
        Result := 'EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST' else
      if COMPILE_PROGRAM_FAILURE = self then
        Result := 'COMPILE_PROGRAM_FAILURE' else
      if LINKER_NOT_AVAILABLE = self then
        Result := 'LINKER_NOT_AVAILABLE' else
      if LINK_PROGRAM_FAILURE = self then
        Result := 'LINK_PROGRAM_FAILURE' else
      if DEVICE_PARTITION_FAILED = self then
        Result := 'DEVICE_PARTITION_FAILED' else
      if KERNEL_ARG_INFO_NOT_AVAILABLE = self then
        Result := 'KERNEL_ARG_INFO_NOT_AVAILABLE' else
      if INVALID_VALUE = self then
        Result := 'INVALID_VALUE' else
      if INVALID_DEVICE_TYPE = self then
        Result := 'INVALID_DEVICE_TYPE' else
      if INVALID_PLATFORM = self then
        Result := 'INVALID_PLATFORM' else
      if INVALID_DEVICE = self then
        Result := 'INVALID_DEVICE' else
      if INVALID_CONTEXT = self then
        Result := 'INVALID_CONTEXT' else
      if INVALID_QUEUE_PROPERTIES = self then
        Result := 'INVALID_QUEUE_PROPERTIES' else
      if INVALID_COMMAND_QUEUE = self then
        Result := 'INVALID_COMMAND_QUEUE' else
      if INVALID_HOST_PTR = self then
        Result := 'INVALID_HOST_PTR' else
      if INVALID_MEM_OBJECT = self then
        Result := 'INVALID_MEM_OBJECT' else
      if INVALID_IMAGE_FORMAT_DESCRIPTOR = self then
        Result := 'INVALID_IMAGE_FORMAT_DESCRIPTOR' else
      if INVALID_IMAGE_SIZE = self then
        Result := 'INVALID_IMAGE_SIZE' else
      if INVALID_SAMPLER = self then
        Result := 'INVALID_SAMPLER' else
      if INVALID_BINARY = self then
        Result := 'INVALID_BINARY' else
      if INVALID_BUILD_OPTIONS = self then
        Result := 'INVALID_BUILD_OPTIONS' else
      if INVALID_PROGRAM = self then
        Result := 'INVALID_PROGRAM' else
      if INVALID_PROGRAM_EXECUTABLE = self then
        Result := 'INVALID_PROGRAM_EXECUTABLE' else
      if INVALID_KERNEL_NAME = self then
        Result := 'INVALID_KERNEL_NAME' else
      if INVALID_KERNEL_DEFINITION = self then
        Result := 'INVALID_KERNEL_DEFINITION' else
      if INVALID_KERNEL = self then
        Result := 'INVALID_KERNEL' else
      if INVALID_ARG_INDEX = self then
        Result := 'INVALID_ARG_INDEX' else
      if INVALID_ARG_VALUE = self then
        Result := 'INVALID_ARG_VALUE' else
      if INVALID_ARG_SIZE = self then
        Result := 'INVALID_ARG_SIZE' else
      if INVALID_KERNEL_ARGS = self then
        Result := 'INVALID_KERNEL_ARGS' else
      if INVALID_WORK_DIMENSION = self then
        Result := 'INVALID_WORK_DIMENSION' else
      if INVALID_WORK_GROUP_SIZE = self then
        Result := 'INVALID_WORK_GROUP_SIZE' else
      if INVALID_WORK_ITEM_SIZE = self then
        Result := 'INVALID_WORK_ITEM_SIZE' else
      if INVALID_GLOBAL_OFFSET = self then
        Result := 'INVALID_GLOBAL_OFFSET' else
      if INVALID_EVENT_WAIT_LIST = self then
        Result := 'INVALID_EVENT_WAIT_LIST' else
      if INVALID_EVENT = self then
        Result := 'INVALID_EVENT' else
      if INVALID_OPERATION = self then
        Result := 'INVALID_OPERATION' else
      if INVALID_GL_OBJECT = self then
        Result := 'INVALID_GL_OBJECT' else
      if INVALID_BUFFER_SIZE = self then
        Result := 'INVALID_BUFFER_SIZE' else
      if INVALID_MIP_LEVEL = self then
        Result := 'INVALID_MIP_LEVEL' else
      if INVALID_GLOBAL_WORK_SIZE = self then
        Result := 'INVALID_GLOBAL_WORK_SIZE' else
      if INVALID_PROPERTY = self then
        Result := 'INVALID_PROPERTY' else
      if INVALID_IMAGE_DESCRIPTOR = self then
        Result := 'INVALID_IMAGE_DESCRIPTOR' else
      if INVALID_COMPILER_OPTIONS = self then
        Result := 'INVALID_COMPILER_OPTIONS' else
      if INVALID_LINKER_OPTIONS = self then
        Result := 'INVALID_LINKER_OPTIONS' else
      if INVALID_DEVICE_PARTITION_COUNT = self then
        Result := 'INVALID_DEVICE_PARTITION_COUNT' else
      if INVALID_PIPE_SIZE = self then
        Result := 'INVALID_PIPE_SIZE' else
      if INVALID_DEVICE_QUEUE = self then
        Result := 'INVALID_DEVICE_QUEUE' else
      if INVALID_SPEC_ID = self then
        Result := 'INVALID_SPEC_ID' else
      if MAX_SIZE_RESTRICTION_EXCEEDED = self then
        Result := 'MAX_SIZE_RESTRICTION_EXCEEDED' else
      if INVALID_GL_SHAREGROUP_REFERENCE = self then
        Result := 'INVALID_GL_SHAREGROUP_REFERENCE' else
      if PLATFORM_NOT_FOUND = self then
        Result := 'PLATFORM_NOT_FOUND' else
      if INVALID_D3D10_DEVICE = self then
        Result := 'INVALID_D3D10_DEVICE' else
      if INVALID_D3D10_RESOURCE = self then
        Result := 'INVALID_D3D10_RESOURCE' else
      if D3D10_RESOURCE_ALREADY_ACQUIRED = self then
        Result := 'D3D10_RESOURCE_ALREADY_ACQUIRED' else
      if D3D10_RESOURCE_NOT_ACQUIRED = self then
        Result := 'D3D10_RESOURCE_NOT_ACQUIRED' else
      if INVALID_D3D11_DEVICE = self then
        Result := 'INVALID_D3D11_DEVICE' else
      if INVALID_D3D11_RESOURCE = self then
        Result := 'INVALID_D3D11_RESOURCE' else
      if D3D11_RESOURCE_ALREADY_ACQUIRED = self then
        Result := 'D3D11_RESOURCE_ALREADY_ACQUIRED' else
      if D3D11_RESOURCE_NOT_ACQUIRED = self then
        Result := 'D3D11_RESOURCE_NOT_ACQUIRED' else
      if INVALID_DX9_MEDIA_ADAPTER = self then
        Result := 'INVALID_DX9_MEDIA_ADAPTER' else
      if INVALID_DX9_MEDIA_SURFACE = self then
        Result := 'INVALID_DX9_MEDIA_SURFACE' else
      if DX9_MEDIA_SURFACE_ALREADY_ACQUIRED = self then
        Result := 'DX9_MEDIA_SURFACE_ALREADY_ACQUIRED' else
      if DX9_MEDIA_SURFACE_NOT_ACQUIRED = self then
        Result := 'DX9_MEDIA_SURFACE_NOT_ACQUIRED' else
      if DEVICE_PARTITION_FAILED_EXT = self then
        Result := 'DEVICE_PARTITION_FAILED_EXT' else
      if INVALID_PARTITION_COUNT = self then
        Result := 'INVALID_PARTITION_COUNT' else
      if INVALID_PARTITION_NAME = self then
        Result := 'INVALID_PARTITION_NAME' else
      if EGL_RESOURCE_NOT_ACQUIRED = self then
        Result := 'EGL_RESOURCE_NOT_ACQUIRED' else
      if INVALID_EGL_OBJECT = self then
        Result := 'INVALID_EGL_OBJECT' else
      if INVALID_ACCELERATOR = self then
        Result := 'INVALID_ACCELERATOR' else
      if INVALID_ACCELERATOR_TYPE = self then
        Result := 'INVALID_ACCELERATOR_TYPE' else
      if INVALID_ACCELERATOR_DESCRIPTOR = self then
        Result := 'INVALID_ACCELERATOR_DESCRIPTOR' else
      if ACCELERATOR_TYPE_NOT_SUPPORTED = self then
        Result := 'ACCELERATOR_TYPE_NOT_SUPPORTED' else
      if INVALID_VA_API_MEDIA_ADAPTER = self then
        Result := 'INVALID_VA_API_MEDIA_ADAPTER' else
      if INVALID_VA_API_MEDIA_SURFACE = self then
        Result := 'INVALID_VA_API_MEDIA_SURFACE' else
      if VA_API_MEDIA_SURFACE_ALREADY_ACQUIRED = self then
        Result := 'VA_API_MEDIA_SURFACE_ALREADY_ACQUIRED' else
      if VA_API_MEDIA_SURFACE_NOT_ACQUIRED = self then
        Result := 'VA_API_MEDIA_SURFACE_NOT_ACQUIRED' else
      if COMMAND_TERMINATED_ITSELF_WITH_FAILURE = self then
        Result := 'COMMAND_TERMINATED_ITSELF_WITH_FAILURE' else
      if CONTEXT_TERMINATED = self then
        Result := 'CONTEXT_TERMINATED' else
      if INVALID_COMMAND_BUFFER = self then
        Result := 'INVALID_COMMAND_BUFFER' else
      if INVALID_SYNC_POINT_WAIT_LIST = self then
        Result := 'INVALID_SYNC_POINT_WAIT_LIST' else
      if INCOMPATIBLE_COMMAND_QUEUE = self then
        Result := 'INCOMPATIBLE_COMMAND_QUEUE' else
      if INVALID_MUTABLE_COMMAND = self then
        Result := 'INVALID_MUTABLE_COMMAND' else
      if INVALID_SEMAPHORE = self then
        Result := 'INVALID_SEMAPHORE' else
      if KERNEL_EXECUTION_ERROR = self then
        Result := 'KERNEL_EXECUTION_ERROR' else
      if GRALLOC_RESOURCE_NOT_ACQUIRED = self then
        Result := 'GRALLOC_RESOURCE_NOT_ACQUIRED' else
      if INVALID_GRALLOC_OBJECT = self then
        Result := 'INVALID_GRALLOC_OBJECT' else
        Result := $'clErrorCode[{self.val}]';
    end;
    
    public function IS_ERROR := val<>0;
    
    public procedure RaiseIfError;
    
    public static function operator explicit(st: clCommandExecutionStatus): clErrorCode := new clErrorCode(st.val);
    public static function operator explicit(ec: clErrorCode): clCommandExecutionStatus := new clCommandExecutionStatus(ec.val);
    
  end;
  
  ///
  clEventInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property EVENT_COMMAND_QUEUE:              clEventInfo read new clEventInfo($11D0);
    public static property EVENT_COMMAND_TYPE:               clEventInfo read new clEventInfo($11D1);
    public static property EVENT_REFERENCE_COUNT:            clEventInfo read new clEventInfo($11D2);
    public static property EVENT_COMMAND_EXECUTION_STATUS:   clEventInfo read new clEventInfo($11D3);
    public static property EVENT_CONTEXT:                    clEventInfo read new clEventInfo($11D4);
    public static property EVENT_COMMAND_TERMINATION_REASON: clEventInfo read new clEventInfo($41ED);
    
    public function ToString: string; override;
    begin
      if EVENT_COMMAND_QUEUE = self then
        Result := 'EVENT_COMMAND_QUEUE' else
      if EVENT_COMMAND_TYPE = self then
        Result := 'EVENT_COMMAND_TYPE' else
      if EVENT_REFERENCE_COUNT = self then
        Result := 'EVENT_REFERENCE_COUNT' else
      if EVENT_COMMAND_EXECUTION_STATUS = self then
        Result := 'EVENT_COMMAND_EXECUTION_STATUS' else
      if EVENT_CONTEXT = self then
        Result := 'EVENT_CONTEXT' else
      if EVENT_COMMAND_TERMINATION_REASON = self then
        Result := 'EVENT_COMMAND_TERMINATION_REASON' else
        Result := $'clEventInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clExternalMemoryHandleType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property EXTERNAL_MEMORY_HANDLE_OPAQUE_FD:         clExternalMemoryHandleType read new clExternalMemoryHandleType($2060);
    public static property EXTERNAL_MEMORY_HANDLE_OPAQUE_WIN32:      clExternalMemoryHandleType read new clExternalMemoryHandleType($2061);
    public static property EXTERNAL_MEMORY_HANDLE_OPAQUE_WIN32_KMT:  clExternalMemoryHandleType read new clExternalMemoryHandleType($2062);
    public static property EXTERNAL_MEMORY_HANDLE_D3D11_TEXTURE:     clExternalMemoryHandleType read new clExternalMemoryHandleType($2063);
    public static property EXTERNAL_MEMORY_HANDLE_D3D11_TEXTURE_KMT: clExternalMemoryHandleType read new clExternalMemoryHandleType($2064);
    public static property EXTERNAL_MEMORY_HANDLE_D3D12_HEAP:        clExternalMemoryHandleType read new clExternalMemoryHandleType($2065);
    public static property EXTERNAL_MEMORY_HANDLE_D3D12_RESOURCE:    clExternalMemoryHandleType read new clExternalMemoryHandleType($2066);
    public static property EXTERNAL_MEMORY_HANDLE_DMA_BUF:           clExternalMemoryHandleType read new clExternalMemoryHandleType($2067);
    
    public function ToString: string; override;
    begin
      if EXTERNAL_MEMORY_HANDLE_OPAQUE_FD = self then
        Result := 'EXTERNAL_MEMORY_HANDLE_OPAQUE_FD' else
      if EXTERNAL_MEMORY_HANDLE_OPAQUE_WIN32 = self then
        Result := 'EXTERNAL_MEMORY_HANDLE_OPAQUE_WIN32' else
      if EXTERNAL_MEMORY_HANDLE_OPAQUE_WIN32_KMT = self then
        Result := 'EXTERNAL_MEMORY_HANDLE_OPAQUE_WIN32_KMT' else
      if EXTERNAL_MEMORY_HANDLE_D3D11_TEXTURE = self then
        Result := 'EXTERNAL_MEMORY_HANDLE_D3D11_TEXTURE' else
      if EXTERNAL_MEMORY_HANDLE_D3D11_TEXTURE_KMT = self then
        Result := 'EXTERNAL_MEMORY_HANDLE_D3D11_TEXTURE_KMT' else
      if EXTERNAL_MEMORY_HANDLE_D3D12_HEAP = self then
        Result := 'EXTERNAL_MEMORY_HANDLE_D3D12_HEAP' else
      if EXTERNAL_MEMORY_HANDLE_D3D12_RESOURCE = self then
        Result := 'EXTERNAL_MEMORY_HANDLE_D3D12_RESOURCE' else
      if EXTERNAL_MEMORY_HANDLE_DMA_BUF = self then
        Result := 'EXTERNAL_MEMORY_HANDLE_DMA_BUF' else
        Result := $'clExternalMemoryHandleType[{self.val}]';
    end;
    
  end;
  
  ///
  clExternalSemaphoreHandleType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SEMAPHORE_HANDLE_OPAQUE_FD:        clExternalSemaphoreHandleType read new clExternalSemaphoreHandleType($2055);
    public static property SEMAPHORE_HANDLE_OPAQUE_WIN32:     clExternalSemaphoreHandleType read new clExternalSemaphoreHandleType($2056);
    public static property SEMAPHORE_HANDLE_OPAQUE_WIN32_KMT: clExternalSemaphoreHandleType read new clExternalSemaphoreHandleType($2057);
    public static property SEMAPHORE_HANDLE_SYNC_FD:          clExternalSemaphoreHandleType read new clExternalSemaphoreHandleType($2058);
    public static property SEMAPHORE_HANDLE_D3D12_FENCE:      clExternalSemaphoreHandleType read new clExternalSemaphoreHandleType($2059);
    
    public function ToString: string; override;
    begin
      if SEMAPHORE_HANDLE_OPAQUE_FD = self then
        Result := 'SEMAPHORE_HANDLE_OPAQUE_FD' else
      if SEMAPHORE_HANDLE_OPAQUE_WIN32 = self then
        Result := 'SEMAPHORE_HANDLE_OPAQUE_WIN32' else
      if SEMAPHORE_HANDLE_OPAQUE_WIN32_KMT = self then
        Result := 'SEMAPHORE_HANDLE_OPAQUE_WIN32_KMT' else
      if SEMAPHORE_HANDLE_SYNC_FD = self then
        Result := 'SEMAPHORE_HANDLE_SYNC_FD' else
      if SEMAPHORE_HANDLE_D3D12_FENCE = self then
        Result := 'SEMAPHORE_HANDLE_D3D12_FENCE' else
        Result := $'clExternalSemaphoreHandleType[{self.val}]';
    end;
    
  end;
  
  ///
  clFilterMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FILTER_NEAREST: clFilterMode read new clFilterMode($1140);
    public static property FILTER_LINEAR:  clFilterMode read new clFilterMode($1141);
    
    public function ToString: string; override;
    begin
      if FILTER_NEAREST = self then
        Result := 'FILTER_NEAREST' else
      if FILTER_LINEAR = self then
        Result := 'FILTER_LINEAR' else
        Result := $'clFilterMode[{self.val}]';
    end;
    
  end;
  
  ///
  clGlContextInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CURRENT_DEVICE_FOR_GL_CONTEXT: clGlContextInfo read new clGlContextInfo($2006);
    public static property DEVICES_FOR_GL_CONTEXT:        clGlContextInfo read new clGlContextInfo($2007);
    
    public function ToString: string; override;
    begin
      if CURRENT_DEVICE_FOR_GL_CONTEXT = self then
        Result := 'CURRENT_DEVICE_FOR_GL_CONTEXT' else
      if DEVICES_FOR_GL_CONTEXT = self then
        Result := 'DEVICES_FOR_GL_CONTEXT' else
        Result := $'clGlContextInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clGlObjectType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property GL_OBJECT_BUFFER:          clGlObjectType read new clGlObjectType($2000);
    public static property GL_OBJECT_TEXTURE2D:       clGlObjectType read new clGlObjectType($2001);
    public static property GL_OBJECT_TEXTURE3D:       clGlObjectType read new clGlObjectType($2002);
    public static property GL_OBJECT_RENDERBUFFER:    clGlObjectType read new clGlObjectType($2003);
    public static property GL_OBJECT_TEXTURE2D_ARRAY: clGlObjectType read new clGlObjectType($200E);
    public static property GL_OBJECT_TEXTURE1D:       clGlObjectType read new clGlObjectType($200F);
    public static property GL_OBJECT_TEXTURE1D_ARRAY: clGlObjectType read new clGlObjectType($2010);
    public static property GL_OBJECT_TEXTURE_BUFFER:  clGlObjectType read new clGlObjectType($2011);
    
    public function ToString: string; override;
    begin
      if GL_OBJECT_BUFFER = self then
        Result := 'GL_OBJECT_BUFFER' else
      if GL_OBJECT_TEXTURE2D = self then
        Result := 'GL_OBJECT_TEXTURE2D' else
      if GL_OBJECT_TEXTURE3D = self then
        Result := 'GL_OBJECT_TEXTURE3D' else
      if GL_OBJECT_RENDERBUFFER = self then
        Result := 'GL_OBJECT_RENDERBUFFER' else
      if GL_OBJECT_TEXTURE2D_ARRAY = self then
        Result := 'GL_OBJECT_TEXTURE2D_ARRAY' else
      if GL_OBJECT_TEXTURE1D = self then
        Result := 'GL_OBJECT_TEXTURE1D' else
      if GL_OBJECT_TEXTURE1D_ARRAY = self then
        Result := 'GL_OBJECT_TEXTURE1D_ARRAY' else
      if GL_OBJECT_TEXTURE_BUFFER = self then
        Result := 'GL_OBJECT_TEXTURE_BUFFER' else
        Result := $'clGlObjectType[{self.val}]';
    end;
    
  end;
  
  ///
  clGlTextureInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property GL_TEXTURE_TARGET: clGlTextureInfo read new clGlTextureInfo($2004);
    public static property GL_MIPMAP_LEVEL:   clGlTextureInfo read new clGlTextureInfo($2005);
    public static property GL_NUM_SAMPLES:    clGlTextureInfo read new clGlTextureInfo($2012);
    
    public function ToString: string; override;
    begin
      if GL_TEXTURE_TARGET = self then
        Result := 'GL_TEXTURE_TARGET' else
      if GL_MIPMAP_LEVEL = self then
        Result := 'GL_MIPMAP_LEVEL' else
      if GL_NUM_SAMPLES = self then
        Result := 'GL_NUM_SAMPLES' else
        Result := $'clGlTextureInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clHostCachePolicy = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MEM_HOST_UNCACHED:        clHostCachePolicy read new clHostCachePolicy($40A4);
    public static property MEM_HOST_WRITEBACK:       clHostCachePolicy read new clHostCachePolicy($40A5);
    public static property MEM_HOST_WRITETHROUGH:    clHostCachePolicy read new clHostCachePolicy($40A6);
    public static property MEM_HOST_WRITE_COMBINING: clHostCachePolicy read new clHostCachePolicy($40A7);
    public static property MEM_HOST_IOCOHERENT:      clHostCachePolicy read new clHostCachePolicy($40A9);
    
    public function ToString: string; override;
    begin
      if MEM_HOST_UNCACHED = self then
        Result := 'MEM_HOST_UNCACHED' else
      if MEM_HOST_WRITEBACK = self then
        Result := 'MEM_HOST_WRITEBACK' else
      if MEM_HOST_WRITETHROUGH = self then
        Result := 'MEM_HOST_WRITETHROUGH' else
      if MEM_HOST_WRITE_COMBINING = self then
        Result := 'MEM_HOST_WRITE_COMBINING' else
      if MEM_HOST_IOCOHERENT = self then
        Result := 'MEM_HOST_IOCOHERENT' else
        Result := $'clHostCachePolicy[{self.val}]';
    end;
    
  end;
  
  ///
  clIcdlInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ICDL_OCL_VERSION: clIcdlInfo read new clIcdlInfo($0001);
    public static property ICDL_VERSION:     clIcdlInfo read new clIcdlInfo($0002);
    public static property ICDL_NAME:        clIcdlInfo read new clIcdlInfo($0003);
    public static property ICDL_VENDOR:      clIcdlInfo read new clIcdlInfo($0004);
    
    public function ToString: string; override;
    begin
      if ICDL_OCL_VERSION = self then
        Result := 'ICDL_OCL_VERSION' else
      if ICDL_VERSION = self then
        Result := 'ICDL_VERSION' else
      if ICDL_NAME = self then
        Result := 'ICDL_NAME' else
      if ICDL_VENDOR = self then
        Result := 'ICDL_VENDOR' else
        Result := $'clIcdlInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clImageInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property IMAGE_FORMAT:            clImageInfo read new clImageInfo($1110);
    public static property IMAGE_ELEMENT_SIZE:      clImageInfo read new clImageInfo($1111);
    public static property IMAGE_ROW_PITCH:         clImageInfo read new clImageInfo($1112);
    public static property IMAGE_SLICE_PITCH:       clImageInfo read new clImageInfo($1113);
    public static property IMAGE_WIDTH:             clImageInfo read new clImageInfo($1114);
    public static property IMAGE_HEIGHT:            clImageInfo read new clImageInfo($1115);
    public static property IMAGE_DEPTH:             clImageInfo read new clImageInfo($1116);
    public static property IMAGE_ARRAY_SIZE:        clImageInfo read new clImageInfo($1117);
    public static property IMAGE_BUFFER:            clImageInfo read new clImageInfo($1118);
    public static property IMAGE_NUM_MIP_LEVELS:    clImageInfo read new clImageInfo($1119);
    public static property IMAGE_NUM_SAMPLES:       clImageInfo read new clImageInfo($111A);
    public static property IMAGE_DX9_MEDIA_PLANE:   clImageInfo read new clImageInfo($202A);
    public static property IMAGE_D3D10_SUBRESOURCE: clImageInfo read new clImageInfo($4016);
    public static property IMAGE_D3D11_SUBRESOURCE: clImageInfo read new clImageInfo($401F);
    public static property IMAGE_DX9_PLANE:         clImageInfo read new clImageInfo($4075);
    public static property IMAGE_VA_API_PLANE:      clImageInfo read new clImageInfo($4099);
    public static property EGL_YUV_PLANE:           clImageInfo read new clImageInfo($4107);
    
    public function ToString: string; override;
    begin
      if IMAGE_FORMAT = self then
        Result := 'IMAGE_FORMAT' else
      if IMAGE_ELEMENT_SIZE = self then
        Result := 'IMAGE_ELEMENT_SIZE' else
      if IMAGE_ROW_PITCH = self then
        Result := 'IMAGE_ROW_PITCH' else
      if IMAGE_SLICE_PITCH = self then
        Result := 'IMAGE_SLICE_PITCH' else
      if IMAGE_WIDTH = self then
        Result := 'IMAGE_WIDTH' else
      if IMAGE_HEIGHT = self then
        Result := 'IMAGE_HEIGHT' else
      if IMAGE_DEPTH = self then
        Result := 'IMAGE_DEPTH' else
      if IMAGE_ARRAY_SIZE = self then
        Result := 'IMAGE_ARRAY_SIZE' else
      if IMAGE_BUFFER = self then
        Result := 'IMAGE_BUFFER' else
      if IMAGE_NUM_MIP_LEVELS = self then
        Result := 'IMAGE_NUM_MIP_LEVELS' else
      if IMAGE_NUM_SAMPLES = self then
        Result := 'IMAGE_NUM_SAMPLES' else
      if IMAGE_DX9_MEDIA_PLANE = self then
        Result := 'IMAGE_DX9_MEDIA_PLANE' else
      if IMAGE_D3D10_SUBRESOURCE = self then
        Result := 'IMAGE_D3D10_SUBRESOURCE' else
      if IMAGE_D3D11_SUBRESOURCE = self then
        Result := 'IMAGE_D3D11_SUBRESOURCE' else
      if IMAGE_DX9_PLANE = self then
        Result := 'IMAGE_DX9_PLANE' else
      if IMAGE_VA_API_PLANE = self then
        Result := 'IMAGE_VA_API_PLANE' else
      if EGL_YUV_PLANE = self then
        Result := 'EGL_YUV_PLANE' else
        Result := $'clImageInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clImagePitchInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property IMAGE_ROW_PITCH:       clImagePitchInfo read new clImagePitchInfo($1112);
    public static property IMAGE_SLICE_PITCH:     clImagePitchInfo read new clImagePitchInfo($1113);
    public static property IMAGE_ROW_ALIGNMENT:   clImagePitchInfo read new clImagePitchInfo($40A2);
    public static property IMAGE_SLICE_ALIGNMENT: clImagePitchInfo read new clImagePitchInfo($40A3);
    
    public function ToString: string; override;
    begin
      if IMAGE_ROW_PITCH = self then
        Result := 'IMAGE_ROW_PITCH' else
      if IMAGE_SLICE_PITCH = self then
        Result := 'IMAGE_SLICE_PITCH' else
      if IMAGE_ROW_ALIGNMENT = self then
        Result := 'IMAGE_ROW_ALIGNMENT' else
      if IMAGE_SLICE_ALIGNMENT = self then
        Result := 'IMAGE_SLICE_ALIGNMENT' else
        Result := $'clImagePitchInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clImageRequirementsInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property IMAGE_REQUIREMENTS_ROW_PITCH_ALIGNMENT:    clImageRequirementsInfo read new clImageRequirementsInfo($1290);
    public static property IMAGE_REQUIREMENTS_SLICE_PITCH_ALIGNMENT:  clImageRequirementsInfo read new clImageRequirementsInfo($1291);
    public static property IMAGE_REQUIREMENTS_BASE_ADDRESS_ALIGNMENT: clImageRequirementsInfo read new clImageRequirementsInfo($1292);
    public static property IMAGE_REQUIREMENTS_SIZE:                   clImageRequirementsInfo read new clImageRequirementsInfo($12B2);
    public static property IMAGE_REQUIREMENTS_MAX_WIDTH:              clImageRequirementsInfo read new clImageRequirementsInfo($12B3);
    public static property IMAGE_REQUIREMENTS_MAX_HEIGHT:             clImageRequirementsInfo read new clImageRequirementsInfo($12B4);
    public static property IMAGE_REQUIREMENTS_MAX_DEPTH:              clImageRequirementsInfo read new clImageRequirementsInfo($12B5);
    public static property IMAGE_REQUIREMENTS_MAX_ARRAY_SIZE:         clImageRequirementsInfo read new clImageRequirementsInfo($12B6);
    
    public function ToString: string; override;
    begin
      if IMAGE_REQUIREMENTS_ROW_PITCH_ALIGNMENT = self then
        Result := 'IMAGE_REQUIREMENTS_ROW_PITCH_ALIGNMENT' else
      if IMAGE_REQUIREMENTS_SLICE_PITCH_ALIGNMENT = self then
        Result := 'IMAGE_REQUIREMENTS_SLICE_PITCH_ALIGNMENT' else
      if IMAGE_REQUIREMENTS_BASE_ADDRESS_ALIGNMENT = self then
        Result := 'IMAGE_REQUIREMENTS_BASE_ADDRESS_ALIGNMENT' else
      if IMAGE_REQUIREMENTS_SIZE = self then
        Result := 'IMAGE_REQUIREMENTS_SIZE' else
      if IMAGE_REQUIREMENTS_MAX_WIDTH = self then
        Result := 'IMAGE_REQUIREMENTS_MAX_WIDTH' else
      if IMAGE_REQUIREMENTS_MAX_HEIGHT = self then
        Result := 'IMAGE_REQUIREMENTS_MAX_HEIGHT' else
      if IMAGE_REQUIREMENTS_MAX_DEPTH = self then
        Result := 'IMAGE_REQUIREMENTS_MAX_DEPTH' else
      if IMAGE_REQUIREMENTS_MAX_ARRAY_SIZE = self then
        Result := 'IMAGE_REQUIREMENTS_MAX_ARRAY_SIZE' else
        Result := $'clImageRequirementsInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clImportProperties = record
    public val: IntPtr;
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property IMPORT_TYPE:                                clImportProperties read new clImportProperties($40B2);
    public static property IMPORT_TYPE_PROTECTED:                      clImportProperties read new clImportProperties($40B5);
    public static property IMPORT_DMA_BUF_DATA_CONSISTENCY_WITH_HOST:  clImportProperties read new clImportProperties($41E3);
    public static property IMPORT_ANDROID_HARDWARE_BUFFER_PLANE_INDEX: clImportProperties read new clImportProperties($41EF);
    public static property IMPORT_ANDROID_HARDWARE_BUFFER_LAYER_INDEX: clImportProperties read new clImportProperties($41F0);
    
    public function ToString: string; override;
    begin
      if IMPORT_TYPE = self then
        Result := 'IMPORT_TYPE' else
      if IMPORT_TYPE_PROTECTED = self then
        Result := 'IMPORT_TYPE_PROTECTED' else
      if IMPORT_DMA_BUF_DATA_CONSISTENCY_WITH_HOST = self then
        Result := 'IMPORT_DMA_BUF_DATA_CONSISTENCY_WITH_HOST' else
      if IMPORT_ANDROID_HARDWARE_BUFFER_PLANE_INDEX = self then
        Result := 'IMPORT_ANDROID_HARDWARE_BUFFER_PLANE_INDEX' else
      if IMPORT_ANDROID_HARDWARE_BUFFER_LAYER_INDEX = self then
        Result := 'IMPORT_ANDROID_HARDWARE_BUFFER_LAYER_INDEX' else
        Result := $'clImportProperties[{self.val}]';
    end;
    
  end;
  
  ///
  clKernelArgAccessQualifier = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property KERNEL_ARG_ACCESS_READ_ONLY:  clKernelArgAccessQualifier read new clKernelArgAccessQualifier($11A0);
    public static property KERNEL_ARG_ACCESS_WRITE_ONLY: clKernelArgAccessQualifier read new clKernelArgAccessQualifier($11A1);
    public static property KERNEL_ARG_ACCESS_READ_WRITE: clKernelArgAccessQualifier read new clKernelArgAccessQualifier($11A2);
    public static property KERNEL_ARG_ACCESS_NONE:       clKernelArgAccessQualifier read new clKernelArgAccessQualifier($11A3);
    
    public function ToString: string; override;
    begin
      if KERNEL_ARG_ACCESS_READ_ONLY = self then
        Result := 'KERNEL_ARG_ACCESS_READ_ONLY' else
      if KERNEL_ARG_ACCESS_WRITE_ONLY = self then
        Result := 'KERNEL_ARG_ACCESS_WRITE_ONLY' else
      if KERNEL_ARG_ACCESS_READ_WRITE = self then
        Result := 'KERNEL_ARG_ACCESS_READ_WRITE' else
      if KERNEL_ARG_ACCESS_NONE = self then
        Result := 'KERNEL_ARG_ACCESS_NONE' else
        Result := $'clKernelArgAccessQualifier[{self.val}]';
    end;
    
  end;
  
  ///
  clKernelArgAddressQualifier = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property KERNEL_ARG_ADDRESS_GLOBAL:   clKernelArgAddressQualifier read new clKernelArgAddressQualifier($119B);
    public static property KERNEL_ARG_ADDRESS_LOCAL:    clKernelArgAddressQualifier read new clKernelArgAddressQualifier($119C);
    public static property KERNEL_ARG_ADDRESS_CONSTANT: clKernelArgAddressQualifier read new clKernelArgAddressQualifier($119D);
    public static property KERNEL_ARG_ADDRESS_PRIVATE:  clKernelArgAddressQualifier read new clKernelArgAddressQualifier($119E);
    
    public function ToString: string; override;
    begin
      if KERNEL_ARG_ADDRESS_GLOBAL = self then
        Result := 'KERNEL_ARG_ADDRESS_GLOBAL' else
      if KERNEL_ARG_ADDRESS_LOCAL = self then
        Result := 'KERNEL_ARG_ADDRESS_LOCAL' else
      if KERNEL_ARG_ADDRESS_CONSTANT = self then
        Result := 'KERNEL_ARG_ADDRESS_CONSTANT' else
      if KERNEL_ARG_ADDRESS_PRIVATE = self then
        Result := 'KERNEL_ARG_ADDRESS_PRIVATE' else
        Result := $'clKernelArgAddressQualifier[{self.val}]';
    end;
    
  end;
  
  ///
  clKernelArgInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property KERNEL_ARG_ADDRESS_QUALIFIER: clKernelArgInfo read new clKernelArgInfo($1196);
    public static property KERNEL_ARG_ACCESS_QUALIFIER:  clKernelArgInfo read new clKernelArgInfo($1197);
    public static property KERNEL_ARG_TYPE_NAME:         clKernelArgInfo read new clKernelArgInfo($1198);
    public static property KERNEL_ARG_TYPE_QUALIFIER:    clKernelArgInfo read new clKernelArgInfo($1199);
    public static property KERNEL_ARG_NAME:              clKernelArgInfo read new clKernelArgInfo($119A);
    
    public function ToString: string; override;
    begin
      if KERNEL_ARG_ADDRESS_QUALIFIER = self then
        Result := 'KERNEL_ARG_ADDRESS_QUALIFIER' else
      if KERNEL_ARG_ACCESS_QUALIFIER = self then
        Result := 'KERNEL_ARG_ACCESS_QUALIFIER' else
      if KERNEL_ARG_TYPE_NAME = self then
        Result := 'KERNEL_ARG_TYPE_NAME' else
      if KERNEL_ARG_TYPE_QUALIFIER = self then
        Result := 'KERNEL_ARG_TYPE_QUALIFIER' else
      if KERNEL_ARG_NAME = self then
        Result := 'KERNEL_ARG_NAME' else
        Result := $'clKernelArgInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clKernelArgTypeQualifier = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property KERNEL_ARG_TYPE_NONE:     clKernelArgTypeQualifier read new clKernelArgTypeQualifier(0);
    public static property KERNEL_ARG_TYPE_CONST:    clKernelArgTypeQualifier read new clKernelArgTypeQualifier(1 shl 0);
    public static property KERNEL_ARG_TYPE_RESTRICT: clKernelArgTypeQualifier read new clKernelArgTypeQualifier(1 shl 1);
    public static property KERNEL_ARG_TYPE_VOLATILE: clKernelArgTypeQualifier read new clKernelArgTypeQualifier(1 shl 2);
    public static property KERNEL_ARG_TYPE_PIPE:     clKernelArgTypeQualifier read new clKernelArgTypeQualifier(1 shl 3);
    
    public property ANY_FLAGS: boolean read self.val<>0;
    
    public static function operator+(v1, v2: clKernelArgTypeQualifier) := new clKernelArgTypeQualifier(v1.val or v2.val);
    public static function operator or(v1, v2: clKernelArgTypeQualifier) := new clKernelArgTypeQualifier(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clKernelArgTypeQualifier; v2: clKernelArgTypeQualifier) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clKernelArgTypeQualifier) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'KERNEL_ARG_TYPE_NONE';
        exit;
      end;
      if KERNEL_ARG_TYPE_CONST in self then
      begin
        res += 'KERNEL_ARG_TYPE_CONST+';
        left_val := left_val and not KERNEL_ARG_TYPE_CONST.val;
      end;
      if KERNEL_ARG_TYPE_RESTRICT in self then
      begin
        res += 'KERNEL_ARG_TYPE_RESTRICT+';
        left_val := left_val and not KERNEL_ARG_TYPE_RESTRICT.val;
      end;
      if KERNEL_ARG_TYPE_VOLATILE in self then
      begin
        res += 'KERNEL_ARG_TYPE_VOLATILE+';
        left_val := left_val and not KERNEL_ARG_TYPE_VOLATILE.val;
      end;
      if KERNEL_ARG_TYPE_PIPE in self then
      begin
        res += 'KERNEL_ARG_TYPE_PIPE+';
        left_val := left_val and not KERNEL_ARG_TYPE_PIPE.val;
      end;
      if left_val<>0 then
      begin
        res += 'clKernelArgTypeQualifier[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clKernelExecInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property KERNEL_EXEC_INFO_SVM_PTRS:                        clKernelExecInfo read new clKernelExecInfo($11B6);
    public static property KERNEL_EXEC_INFO_SVM_FINE_GRAIN_SYSTEM:           clKernelExecInfo read new clKernelExecInfo($11B7);
    public static property KERNEL_EXEC_INFO_WORKGROUP_BATCH_SIZE:            clKernelExecInfo read new clKernelExecInfo($41E5);
    public static property KERNEL_EXEC_INFO_WORKGROUP_BATCH_SIZE_MODIFIER:   clKernelExecInfo read new clKernelExecInfo($41E6);
    public static property KERNEL_EXEC_INFO_WARP_COUNT_LIMIT:                clKernelExecInfo read new clKernelExecInfo($41E8);
    public static property KERNEL_EXEC_INFO_COMPUTE_UNIT_MAX_QUEUED_BATCHES: clKernelExecInfo read new clKernelExecInfo($41F1);
    public static property KERNEL_EXEC_INFO_INDIRECT_HOST_ACCESS:            clKernelExecInfo read new clKernelExecInfo($4200);
    public static property KERNEL_EXEC_INFO_INDIRECT_DEVICE_ACCESS:          clKernelExecInfo read new clKernelExecInfo($4201);
    public static property KERNEL_EXEC_INFO_INDIRECT_SHARED_ACCESS:          clKernelExecInfo read new clKernelExecInfo($4202);
    public static property KERNEL_EXEC_INFO_USM_PTRS:                        clKernelExecInfo read new clKernelExecInfo($4203);
    
    public function ToString: string; override;
    begin
      if KERNEL_EXEC_INFO_SVM_PTRS = self then
        Result := 'KERNEL_EXEC_INFO_SVM_PTRS' else
      if KERNEL_EXEC_INFO_SVM_FINE_GRAIN_SYSTEM = self then
        Result := 'KERNEL_EXEC_INFO_SVM_FINE_GRAIN_SYSTEM' else
      if KERNEL_EXEC_INFO_WORKGROUP_BATCH_SIZE = self then
        Result := 'KERNEL_EXEC_INFO_WORKGROUP_BATCH_SIZE' else
      if KERNEL_EXEC_INFO_WORKGROUP_BATCH_SIZE_MODIFIER = self then
        Result := 'KERNEL_EXEC_INFO_WORKGROUP_BATCH_SIZE_MODIFIER' else
      if KERNEL_EXEC_INFO_WARP_COUNT_LIMIT = self then
        Result := 'KERNEL_EXEC_INFO_WARP_COUNT_LIMIT' else
      if KERNEL_EXEC_INFO_COMPUTE_UNIT_MAX_QUEUED_BATCHES = self then
        Result := 'KERNEL_EXEC_INFO_COMPUTE_UNIT_MAX_QUEUED_BATCHES' else
      if KERNEL_EXEC_INFO_INDIRECT_HOST_ACCESS = self then
        Result := 'KERNEL_EXEC_INFO_INDIRECT_HOST_ACCESS' else
      if KERNEL_EXEC_INFO_INDIRECT_DEVICE_ACCESS = self then
        Result := 'KERNEL_EXEC_INFO_INDIRECT_DEVICE_ACCESS' else
      if KERNEL_EXEC_INFO_INDIRECT_SHARED_ACCESS = self then
        Result := 'KERNEL_EXEC_INFO_INDIRECT_SHARED_ACCESS' else
      if KERNEL_EXEC_INFO_USM_PTRS = self then
        Result := 'KERNEL_EXEC_INFO_USM_PTRS' else
        Result := $'clKernelExecInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clKernelInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property KERNEL_FUNCTION_NAME:   clKernelInfo read new clKernelInfo($1190);
    public static property KERNEL_NUM_ARGS:        clKernelInfo read new clKernelInfo($1191);
    public static property KERNEL_REFERENCE_COUNT: clKernelInfo read new clKernelInfo($1192);
    public static property KERNEL_CONTEXT:         clKernelInfo read new clKernelInfo($1193);
    public static property KERNEL_PROGRAM:         clKernelInfo read new clKernelInfo($1194);
    public static property KERNEL_ATTRIBUTES:      clKernelInfo read new clKernelInfo($1195);
    public static property KERNEL_MAX_WARP_COUNT:  clKernelInfo read new clKernelInfo($41E9);
    
    public function ToString: string; override;
    begin
      if KERNEL_FUNCTION_NAME = self then
        Result := 'KERNEL_FUNCTION_NAME' else
      if KERNEL_NUM_ARGS = self then
        Result := 'KERNEL_NUM_ARGS' else
      if KERNEL_REFERENCE_COUNT = self then
        Result := 'KERNEL_REFERENCE_COUNT' else
      if KERNEL_CONTEXT = self then
        Result := 'KERNEL_CONTEXT' else
      if KERNEL_PROGRAM = self then
        Result := 'KERNEL_PROGRAM' else
      if KERNEL_ATTRIBUTES = self then
        Result := 'KERNEL_ATTRIBUTES' else
      if KERNEL_MAX_WARP_COUNT = self then
        Result := 'KERNEL_MAX_WARP_COUNT' else
        Result := $'clKernelInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clKernelSubGroupInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property KERNEL_LOCAL_SIZE_FOR_SUB_GROUP_COUNT: clKernelSubGroupInfo read new clKernelSubGroupInfo($11B8);
    public static property KERNEL_MAX_NUM_SUB_GROUPS:             clKernelSubGroupInfo read new clKernelSubGroupInfo($11B9);
    public static property KERNEL_COMPILE_NUM_SUB_GROUPS:         clKernelSubGroupInfo read new clKernelSubGroupInfo($11BA);
    public static property KERNEL_MAX_SUB_GROUP_SIZE_FOR_NDRANGE: clKernelSubGroupInfo read new clKernelSubGroupInfo($2033);
    public static property KERNEL_SUB_GROUP_COUNT_FOR_NDRANGE:    clKernelSubGroupInfo read new clKernelSubGroupInfo($2034);
    public static property KERNEL_COMPILE_SUB_GROUP_SIZE:         clKernelSubGroupInfo read new clKernelSubGroupInfo($410A);
    
    public function ToString: string; override;
    begin
      if KERNEL_LOCAL_SIZE_FOR_SUB_GROUP_COUNT = self then
        Result := 'KERNEL_LOCAL_SIZE_FOR_SUB_GROUP_COUNT' else
      if KERNEL_MAX_NUM_SUB_GROUPS = self then
        Result := 'KERNEL_MAX_NUM_SUB_GROUPS' else
      if KERNEL_COMPILE_NUM_SUB_GROUPS = self then
        Result := 'KERNEL_COMPILE_NUM_SUB_GROUPS' else
      if KERNEL_MAX_SUB_GROUP_SIZE_FOR_NDRANGE = self then
        Result := 'KERNEL_MAX_SUB_GROUP_SIZE_FOR_NDRANGE' else
      if KERNEL_SUB_GROUP_COUNT_FOR_NDRANGE = self then
        Result := 'KERNEL_SUB_GROUP_COUNT_FOR_NDRANGE' else
      if KERNEL_COMPILE_SUB_GROUP_SIZE = self then
        Result := 'KERNEL_COMPILE_SUB_GROUP_SIZE' else
        Result := $'clKernelSubGroupInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clKernelWorkGroupInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property KERNEL_WORK_GROUP_SIZE:                    clKernelWorkGroupInfo read new clKernelWorkGroupInfo($11B0);
    public static property KERNEL_COMPILE_WORK_GROUP_SIZE:            clKernelWorkGroupInfo read new clKernelWorkGroupInfo($11B1);
    public static property KERNEL_LOCAL_MEM_SIZE:                     clKernelWorkGroupInfo read new clKernelWorkGroupInfo($11B2);
    public static property KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE: clKernelWorkGroupInfo read new clKernelWorkGroupInfo($11B3);
    public static property KERNEL_PRIVATE_MEM_SIZE:                   clKernelWorkGroupInfo read new clKernelWorkGroupInfo($11B4);
    public static property KERNEL_GLOBAL_WORK_SIZE:                   clKernelWorkGroupInfo read new clKernelWorkGroupInfo($11B5);
    public static property KERNEL_SPILL_MEM_SIZE:                     clKernelWorkGroupInfo read new clKernelWorkGroupInfo($4109);
    
    public function ToString: string; override;
    begin
      if KERNEL_WORK_GROUP_SIZE = self then
        Result := 'KERNEL_WORK_GROUP_SIZE' else
      if KERNEL_COMPILE_WORK_GROUP_SIZE = self then
        Result := 'KERNEL_COMPILE_WORK_GROUP_SIZE' else
      if KERNEL_LOCAL_MEM_SIZE = self then
        Result := 'KERNEL_LOCAL_MEM_SIZE' else
      if KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = self then
        Result := 'KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE' else
      if KERNEL_PRIVATE_MEM_SIZE = self then
        Result := 'KERNEL_PRIVATE_MEM_SIZE' else
      if KERNEL_GLOBAL_WORK_SIZE = self then
        Result := 'KERNEL_GLOBAL_WORK_SIZE' else
      if KERNEL_SPILL_MEM_SIZE = self then
        Result := 'KERNEL_SPILL_MEM_SIZE' else
        Result := $'clKernelWorkGroupInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clKhronosVendorId = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property KHRONOS_VENDOR_ID_CODEPLAY: clKhronosVendorId read new clKhronosVendorId($10004);
    public static property KHRONOS_VENDOR_ID:          clKhronosVendorId read new clKhronosVendorId($10006);
    
    public function ToString: string; override;
    begin
      if KHRONOS_VENDOR_ID_CODEPLAY = self then
        Result := 'KHRONOS_VENDOR_ID_CODEPLAY' else
      if KHRONOS_VENDOR_ID = self then
        Result := 'KHRONOS_VENDOR_ID' else
        Result := $'clKhronosVendorId[{self.val}]';
    end;
    
  end;
  
  ///
  clLayerInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property LAYER_API_VERSION: clLayerInfo read new clLayerInfo($4240);
    public static property LAYER_NAME:        clLayerInfo read new clLayerInfo($4241);
    
    public function ToString: string; override;
    begin
      if LAYER_API_VERSION = self then
        Result := 'LAYER_API_VERSION' else
      if LAYER_NAME = self then
        Result := 'LAYER_NAME' else
        Result := $'clLayerInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clMapFlags = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property MAP_READ:                    clMapFlags read new clMapFlags(1 shl 0);
    public static property MAP_WRITE:                   clMapFlags read new clMapFlags(1 shl 1);
    public static property MAP_WRITE_INVALIDATE_REGION: clMapFlags read new clMapFlags(1 shl 2);
    
    public static function operator+(v1, v2: clMapFlags) := new clMapFlags(v1.val or v2.val);
    public static function operator or(v1, v2: clMapFlags) := new clMapFlags(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clMapFlags; v2: clMapFlags) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clMapFlags) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clMapFlags[0]';
        exit;
      end;
      if MAP_READ in self then
      begin
        res += 'MAP_READ+';
        left_val := left_val and not MAP_READ.val;
      end;
      if MAP_WRITE in self then
      begin
        res += 'MAP_WRITE+';
        left_val := left_val and not MAP_WRITE.val;
      end;
      if MAP_WRITE_INVALIDATE_REGION in self then
      begin
        res += 'MAP_WRITE_INVALIDATE_REGION+';
        left_val := left_val and not MAP_WRITE_INVALIDATE_REGION.val;
      end;
      if left_val<>0 then
      begin
        res += 'clMapFlags[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clMbBlockType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ME_MB_TYPE_16x16: clMbBlockType read new clMbBlockType(0);
    public static property ME_MB_TYPE_8x8:   clMbBlockType read new clMbBlockType($0001);
    public static property ME_MB_TYPE_4x4:   clMbBlockType read new clMbBlockType($0002);
    
    public function ToString: string; override;
    begin
      if ME_MB_TYPE_16x16 = self then
        Result := 'ME_MB_TYPE_16x16' else
      if ME_MB_TYPE_8x8 = self then
        Result := 'ME_MB_TYPE_8x8' else
      if ME_MB_TYPE_4x4 = self then
        Result := 'ME_MB_TYPE_4x4' else
        Result := $'clMbBlockType[{self.val}]';
    end;
    
  end;
  
  ///
  clMemFlags = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property MEM_READ_WRITE:                clMemFlags read new clMemFlags(1 shl 0);
    public static property MEM_WRITE_ONLY:                clMemFlags read new clMemFlags(1 shl 1);
    public static property MEM_READ_ONLY:                 clMemFlags read new clMemFlags(1 shl 2);
    public static property MEM_USE_HOST_PTR:              clMemFlags read new clMemFlags(1 shl 3);
    public static property MEM_ALLOC_HOST_PTR:            clMemFlags read new clMemFlags(1 shl 4);
    public static property MEM_COPY_HOST_PTR:             clMemFlags read new clMemFlags(1 shl 5);
    public static property MEM_HOST_WRITE_ONLY:           clMemFlags read new clMemFlags(1 shl 7);
    public static property MEM_HOST_READ_ONLY:            clMemFlags read new clMemFlags(1 shl 8);
    public static property MEM_HOST_NO_ACCESS:            clMemFlags read new clMemFlags(1 shl 9);
    public static property MEM_SVM_FINE_GRAIN_BUFFER:     clMemFlags read new clMemFlags(1 shl 10);
    public static property MEM_SVM_ATOMICS:               clMemFlags read new clMemFlags(1 shl 11);
    public static property MEM_KERNEL_READ_AND_WRITE:     clMemFlags read new clMemFlags(1 shl 12);
    public static property MEM_FORCE_HOST_MEMORY:         clMemFlags read new clMemFlags(1 shl 20);
    public static property MEM_NO_ACCESS:                 clMemFlags read new clMemFlags(1 shl 24);
    public static property MEM_ACCESS_FLAGS_UNRESTRICTED: clMemFlags read new clMemFlags(1 shl 25);
    public static property MEM_USE_UNCACHED_CPU_MEMORY:   clMemFlags read new clMemFlags(1 shl 26);
    public static property MEM_USE_CACHED_CPU_MEMORY:     clMemFlags read new clMemFlags(1 shl 27);
    public static property MEM_USE_GRALLOC_PTR:           clMemFlags read new clMemFlags(1 shl 28);
    public static property MEM_EXT_HOST_PTR:              clMemFlags read new clMemFlags(1 shl 29);
    public static property MEM_PROTECTED_ALLOC:           clMemFlags read new clMemFlags(1 shl 36);
    
    public static function operator+(v1, v2: clMemFlags) := new clMemFlags(v1.val or v2.val);
    public static function operator or(v1, v2: clMemFlags) := new clMemFlags(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clMemFlags; v2: clMemFlags) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clMemFlags) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clMemFlags[0]';
        exit;
      end;
      if MEM_READ_WRITE in self then
      begin
        res += 'MEM_READ_WRITE+';
        left_val := left_val and not MEM_READ_WRITE.val;
      end;
      if MEM_WRITE_ONLY in self then
      begin
        res += 'MEM_WRITE_ONLY+';
        left_val := left_val and not MEM_WRITE_ONLY.val;
      end;
      if MEM_READ_ONLY in self then
      begin
        res += 'MEM_READ_ONLY+';
        left_val := left_val and not MEM_READ_ONLY.val;
      end;
      if MEM_USE_HOST_PTR in self then
      begin
        res += 'MEM_USE_HOST_PTR+';
        left_val := left_val and not MEM_USE_HOST_PTR.val;
      end;
      if MEM_ALLOC_HOST_PTR in self then
      begin
        res += 'MEM_ALLOC_HOST_PTR+';
        left_val := left_val and not MEM_ALLOC_HOST_PTR.val;
      end;
      if MEM_COPY_HOST_PTR in self then
      begin
        res += 'MEM_COPY_HOST_PTR+';
        left_val := left_val and not MEM_COPY_HOST_PTR.val;
      end;
      if MEM_HOST_WRITE_ONLY in self then
      begin
        res += 'MEM_HOST_WRITE_ONLY+';
        left_val := left_val and not MEM_HOST_WRITE_ONLY.val;
      end;
      if MEM_HOST_READ_ONLY in self then
      begin
        res += 'MEM_HOST_READ_ONLY+';
        left_val := left_val and not MEM_HOST_READ_ONLY.val;
      end;
      if MEM_HOST_NO_ACCESS in self then
      begin
        res += 'MEM_HOST_NO_ACCESS+';
        left_val := left_val and not MEM_HOST_NO_ACCESS.val;
      end;
      if MEM_SVM_FINE_GRAIN_BUFFER in self then
      begin
        res += 'MEM_SVM_FINE_GRAIN_BUFFER+';
        left_val := left_val and not MEM_SVM_FINE_GRAIN_BUFFER.val;
      end;
      if MEM_SVM_ATOMICS in self then
      begin
        res += 'MEM_SVM_ATOMICS+';
        left_val := left_val and not MEM_SVM_ATOMICS.val;
      end;
      if MEM_KERNEL_READ_AND_WRITE in self then
      begin
        res += 'MEM_KERNEL_READ_AND_WRITE+';
        left_val := left_val and not MEM_KERNEL_READ_AND_WRITE.val;
      end;
      if MEM_FORCE_HOST_MEMORY in self then
      begin
        res += 'MEM_FORCE_HOST_MEMORY+';
        left_val := left_val and not MEM_FORCE_HOST_MEMORY.val;
      end;
      if MEM_NO_ACCESS in self then
      begin
        res += 'MEM_NO_ACCESS+';
        left_val := left_val and not MEM_NO_ACCESS.val;
      end;
      if MEM_ACCESS_FLAGS_UNRESTRICTED in self then
      begin
        res += 'MEM_ACCESS_FLAGS_UNRESTRICTED+';
        left_val := left_val and not MEM_ACCESS_FLAGS_UNRESTRICTED.val;
      end;
      if MEM_USE_UNCACHED_CPU_MEMORY in self then
      begin
        res += 'MEM_USE_UNCACHED_CPU_MEMORY+';
        left_val := left_val and not MEM_USE_UNCACHED_CPU_MEMORY.val;
      end;
      if MEM_USE_CACHED_CPU_MEMORY in self then
      begin
        res += 'MEM_USE_CACHED_CPU_MEMORY+';
        left_val := left_val and not MEM_USE_CACHED_CPU_MEMORY.val;
      end;
      if MEM_USE_GRALLOC_PTR in self then
      begin
        res += 'MEM_USE_GRALLOC_PTR+';
        left_val := left_val and not MEM_USE_GRALLOC_PTR.val;
      end;
      if MEM_EXT_HOST_PTR in self then
      begin
        res += 'MEM_EXT_HOST_PTR+';
        left_val := left_val and not MEM_EXT_HOST_PTR.val;
      end;
      if MEM_PROTECTED_ALLOC in self then
      begin
        res += 'MEM_PROTECTED_ALLOC+';
        left_val := left_val and not MEM_PROTECTED_ALLOC.val;
      end;
      if left_val<>0 then
      begin
        res += 'clMemFlags[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clMemInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MEM_TYPE:                   clMemInfo read new clMemInfo($1100);
    public static property MEM_FLAGS:                  clMemInfo read new clMemInfo($1101);
    public static property MEM_SIZE:                   clMemInfo read new clMemInfo($1102);
    public static property MEM_HOST_PTR:               clMemInfo read new clMemInfo($1103);
    public static property MEM_MAP_COUNT:              clMemInfo read new clMemInfo($1104);
    public static property MEM_REFERENCE_COUNT:        clMemInfo read new clMemInfo($1105);
    public static property MEM_CONTEXT:                clMemInfo read new clMemInfo($1106);
    public static property MEM_ASSOCIATED_MEMOBJECT:   clMemInfo read new clMemInfo($1107);
    public static property MEM_OFFSET:                 clMemInfo read new clMemInfo($1108);
    public static property MEM_USES_SVM_POINTER:       clMemInfo read new clMemInfo($1109);
    public static property MEM_PROPERTIES:             clMemInfo read new clMemInfo($110A);
    public static property MEM_DX9_MEDIA_ADAPTER_TYPE: clMemInfo read new clMemInfo($2028);
    public static property MEM_DX9_MEDIA_SURFACE_INFO: clMemInfo read new clMemInfo($2029);
    public static property MEM_D3D10_RESOURCE:         clMemInfo read new clMemInfo($4015);
    public static property MEM_D3D11_RESOURCE:         clMemInfo read new clMemInfo($401E);
    public static property MEM_DX9_RESOURCE:           clMemInfo read new clMemInfo($4027);
    public static property MEM_DX9_SHARED_HANDLE:      clMemInfo read new clMemInfo($4074);
    public static property MEM_VA_API_MEDIA_SURFACE:   clMemInfo read new clMemInfo($4098);
    public static property MEM_USES_SVM_POINTER_ARM:   clMemInfo read new clMemInfo($40B7);
    public static property MEM_ALLOC_FLAGS_INTEL:      clMemInfo read new clMemInfo($4195);
    public static property MEM_ALLOC_TYPE:             clMemInfo read new clMemInfo($419A);
    public static property MEM_ALLOC_BASE_PTR:         clMemInfo read new clMemInfo($419B);
    public static property MEM_ALLOC_SIZE:             clMemInfo read new clMemInfo($419C);
    public static property MEM_ALLOC_DEVICE:           clMemInfo read new clMemInfo($419D);
    
    public function ToString: string; override;
    begin
      if MEM_TYPE = self then
        Result := 'MEM_TYPE' else
      if MEM_FLAGS = self then
        Result := 'MEM_FLAGS' else
      if MEM_SIZE = self then
        Result := 'MEM_SIZE' else
      if MEM_HOST_PTR = self then
        Result := 'MEM_HOST_PTR' else
      if MEM_MAP_COUNT = self then
        Result := 'MEM_MAP_COUNT' else
      if MEM_REFERENCE_COUNT = self then
        Result := 'MEM_REFERENCE_COUNT' else
      if MEM_CONTEXT = self then
        Result := 'MEM_CONTEXT' else
      if MEM_ASSOCIATED_MEMOBJECT = self then
        Result := 'MEM_ASSOCIATED_MEMOBJECT' else
      if MEM_OFFSET = self then
        Result := 'MEM_OFFSET' else
      if MEM_USES_SVM_POINTER = self then
        Result := 'MEM_USES_SVM_POINTER' else
      if MEM_PROPERTIES = self then
        Result := 'MEM_PROPERTIES' else
      if MEM_DX9_MEDIA_ADAPTER_TYPE = self then
        Result := 'MEM_DX9_MEDIA_ADAPTER_TYPE' else
      if MEM_DX9_MEDIA_SURFACE_INFO = self then
        Result := 'MEM_DX9_MEDIA_SURFACE_INFO' else
      if MEM_D3D10_RESOURCE = self then
        Result := 'MEM_D3D10_RESOURCE' else
      if MEM_D3D11_RESOURCE = self then
        Result := 'MEM_D3D11_RESOURCE' else
      if MEM_DX9_RESOURCE = self then
        Result := 'MEM_DX9_RESOURCE' else
      if MEM_DX9_SHARED_HANDLE = self then
        Result := 'MEM_DX9_SHARED_HANDLE' else
      if MEM_VA_API_MEDIA_SURFACE = self then
        Result := 'MEM_VA_API_MEDIA_SURFACE' else
      if MEM_USES_SVM_POINTER_ARM = self then
        Result := 'MEM_USES_SVM_POINTER_ARM' else
      if MEM_ALLOC_FLAGS_INTEL = self then
        Result := 'MEM_ALLOC_FLAGS_INTEL' else
      if MEM_ALLOC_TYPE = self then
        Result := 'MEM_ALLOC_TYPE' else
      if MEM_ALLOC_BASE_PTR = self then
        Result := 'MEM_ALLOC_BASE_PTR' else
      if MEM_ALLOC_SIZE = self then
        Result := 'MEM_ALLOC_SIZE' else
      if MEM_ALLOC_DEVICE = self then
        Result := 'MEM_ALLOC_DEVICE' else
        Result := $'clMemInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clMemMigrationFlags = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property MIGRATE_MEM_OBJECT_HOST:              clMemMigrationFlags read new clMemMigrationFlags(1 shl 0);
    public static property MIGRATE_MEM_OBJECT_CONTENT_UNDEFINED: clMemMigrationFlags read new clMemMigrationFlags(1 shl 1);
    
    public static function operator+(v1, v2: clMemMigrationFlags) := new clMemMigrationFlags(v1.val or v2.val);
    public static function operator or(v1, v2: clMemMigrationFlags) := new clMemMigrationFlags(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clMemMigrationFlags; v2: clMemMigrationFlags) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clMemMigrationFlags) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clMemMigrationFlags[0]';
        exit;
      end;
      if MIGRATE_MEM_OBJECT_HOST in self then
      begin
        res += 'MIGRATE_MEM_OBJECT_HOST+';
        left_val := left_val and not MIGRATE_MEM_OBJECT_HOST.val;
      end;
      if MIGRATE_MEM_OBJECT_CONTENT_UNDEFINED in self then
      begin
        res += 'MIGRATE_MEM_OBJECT_CONTENT_UNDEFINED+';
        left_val := left_val and not MIGRATE_MEM_OBJECT_CONTENT_UNDEFINED.val;
      end;
      if left_val<>0 then
      begin
        res += 'clMemMigrationFlags[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clMemObjectType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MEM_OBJECT_BUFFER:         clMemObjectType read new clMemObjectType($10F0);
    public static property MEM_OBJECT_IMAGE2D:        clMemObjectType read new clMemObjectType($10F1);
    public static property MEM_OBJECT_IMAGE3D:        clMemObjectType read new clMemObjectType($10F2);
    public static property MEM_OBJECT_IMAGE2D_ARRAY:  clMemObjectType read new clMemObjectType($10F3);
    public static property MEM_OBJECT_IMAGE1D:        clMemObjectType read new clMemObjectType($10F4);
    public static property MEM_OBJECT_IMAGE1D_ARRAY:  clMemObjectType read new clMemObjectType($10F5);
    public static property MEM_OBJECT_IMAGE1D_BUFFER: clMemObjectType read new clMemObjectType($10F6);
    public static property MEM_OBJECT_PIPE:           clMemObjectType read new clMemObjectType($10F7);
    
    public function ToString: string; override;
    begin
      if MEM_OBJECT_BUFFER = self then
        Result := 'MEM_OBJECT_BUFFER' else
      if MEM_OBJECT_IMAGE2D = self then
        Result := 'MEM_OBJECT_IMAGE2D' else
      if MEM_OBJECT_IMAGE3D = self then
        Result := 'MEM_OBJECT_IMAGE3D' else
      if MEM_OBJECT_IMAGE2D_ARRAY = self then
        Result := 'MEM_OBJECT_IMAGE2D_ARRAY' else
      if MEM_OBJECT_IMAGE1D = self then
        Result := 'MEM_OBJECT_IMAGE1D' else
      if MEM_OBJECT_IMAGE1D_ARRAY = self then
        Result := 'MEM_OBJECT_IMAGE1D_ARRAY' else
      if MEM_OBJECT_IMAGE1D_BUFFER = self then
        Result := 'MEM_OBJECT_IMAGE1D_BUFFER' else
      if MEM_OBJECT_PIPE = self then
        Result := 'MEM_OBJECT_PIPE' else
        Result := $'clMemObjectType[{self.val}]';
    end;
    
  end;
  
  ///
  clMemProperties = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property MEM_DEVICE_HANDLE_LIST_END:    clMemProperties read new clMemProperties(0);
    public static property MEM_DEVICE_HANDLE_LIST:        clMemProperties read new clMemProperties($2051);
    public static property MEM_ALLOC_FLAGS_IMG:           clMemProperties read new clMemProperties($40D7);
    public static property MEM_LOCALLY_UNCACHED_RESOURCE: clMemProperties read new clMemProperties($4218);
    public static property MEM_DEVICE_ID:                 clMemProperties read new clMemProperties($4219);
    
    public function ToString: string; override;
    begin
      if MEM_DEVICE_HANDLE_LIST_END = self then
        Result := 'MEM_DEVICE_HANDLE_LIST_END' else
      if MEM_DEVICE_HANDLE_LIST = self then
        Result := 'MEM_DEVICE_HANDLE_LIST' else
      if MEM_ALLOC_FLAGS_IMG = self then
        Result := 'MEM_ALLOC_FLAGS_IMG' else
      if MEM_LOCALLY_UNCACHED_RESOURCE = self then
        Result := 'MEM_LOCALLY_UNCACHED_RESOURCE' else
      if MEM_DEVICE_ID = self then
        Result := 'MEM_DEVICE_ID' else
        Result := $'clMemProperties[{self.val}]';
    end;
    
  end;
  
  ///
  clMipmapFilterMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MIPMAP_FILTER_ANY: clMipmapFilterMode read new clMipmapFilterMode(0);
    public static property MIPMAP_FILTER_BOX: clMipmapFilterMode read new clMipmapFilterMode($0001);
    
    public function ToString: string; override;
    begin
      if MIPMAP_FILTER_ANY = self then
        Result := 'MIPMAP_FILTER_ANY' else
      if MIPMAP_FILTER_BOX = self then
        Result := 'MIPMAP_FILTER_BOX' else
        Result := $'clMipmapFilterMode[{self.val}]';
    end;
    
  end;
  
  ///
  clMutableCommandInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MUTABLE_COMMAND_COMMAND_QUEUE:       clMutableCommandInfo read new clMutableCommandInfo($12A0);
    public static property MUTABLE_COMMAND_COMMAND_BUFFER:      clMutableCommandInfo read new clMutableCommandInfo($12A1);
    public static property MUTABLE_DISPATCH_PROPERTIES_ARRAY:   clMutableCommandInfo read new clMutableCommandInfo($12A2);
    public static property MUTABLE_DISPATCH_KERNEL:             clMutableCommandInfo read new clMutableCommandInfo($12A3);
    public static property MUTABLE_DISPATCH_DIMENSIONS:         clMutableCommandInfo read new clMutableCommandInfo($12A4);
    public static property MUTABLE_DISPATCH_GLOBAL_WORK_OFFSET: clMutableCommandInfo read new clMutableCommandInfo($12A5);
    public static property MUTABLE_DISPATCH_GLOBAL_WORK_SIZE:   clMutableCommandInfo read new clMutableCommandInfo($12A6);
    public static property MUTABLE_DISPATCH_LOCAL_WORK_SIZE:    clMutableCommandInfo read new clMutableCommandInfo($12A7);
    public static property MUTABLE_COMMAND_COMMAND_TYPE:        clMutableCommandInfo read new clMutableCommandInfo($12AD);
    
    public function ToString: string; override;
    begin
      if MUTABLE_COMMAND_COMMAND_QUEUE = self then
        Result := 'MUTABLE_COMMAND_COMMAND_QUEUE' else
      if MUTABLE_COMMAND_COMMAND_BUFFER = self then
        Result := 'MUTABLE_COMMAND_COMMAND_BUFFER' else
      if MUTABLE_DISPATCH_PROPERTIES_ARRAY = self then
        Result := 'MUTABLE_DISPATCH_PROPERTIES_ARRAY' else
      if MUTABLE_DISPATCH_KERNEL = self then
        Result := 'MUTABLE_DISPATCH_KERNEL' else
      if MUTABLE_DISPATCH_DIMENSIONS = self then
        Result := 'MUTABLE_DISPATCH_DIMENSIONS' else
      if MUTABLE_DISPATCH_GLOBAL_WORK_OFFSET = self then
        Result := 'MUTABLE_DISPATCH_GLOBAL_WORK_OFFSET' else
      if MUTABLE_DISPATCH_GLOBAL_WORK_SIZE = self then
        Result := 'MUTABLE_DISPATCH_GLOBAL_WORK_SIZE' else
      if MUTABLE_DISPATCH_LOCAL_WORK_SIZE = self then
        Result := 'MUTABLE_DISPATCH_LOCAL_WORK_SIZE' else
      if MUTABLE_COMMAND_COMMAND_TYPE = self then
        Result := 'MUTABLE_COMMAND_COMMAND_TYPE' else
        Result := $'clMutableCommandInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clMutableDispatchFields = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property MUTABLE_DISPATCH_GLOBAL_OFFSET: clMutableDispatchFields read new clMutableDispatchFields(1 shl 0);
    public static property MUTABLE_DISPATCH_GLOBAL_SIZE:   clMutableDispatchFields read new clMutableDispatchFields(1 shl 1);
    public static property MUTABLE_DISPATCH_LOCAL_SIZE:    clMutableDispatchFields read new clMutableDispatchFields(1 shl 2);
    public static property MUTABLE_DISPATCH_ARGUMENTS:     clMutableDispatchFields read new clMutableDispatchFields(1 shl 3);
    public static property MUTABLE_DISPATCH_EXEC_INFO:     clMutableDispatchFields read new clMutableDispatchFields(1 shl 4);
    
    public static function operator+(v1, v2: clMutableDispatchFields) := new clMutableDispatchFields(v1.val or v2.val);
    public static function operator or(v1, v2: clMutableDispatchFields) := new clMutableDispatchFields(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clMutableDispatchFields; v2: clMutableDispatchFields) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clMutableDispatchFields) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clMutableDispatchFields[0]';
        exit;
      end;
      if MUTABLE_DISPATCH_GLOBAL_OFFSET in self then
      begin
        res += 'MUTABLE_DISPATCH_GLOBAL_OFFSET+';
        left_val := left_val and not MUTABLE_DISPATCH_GLOBAL_OFFSET.val;
      end;
      if MUTABLE_DISPATCH_GLOBAL_SIZE in self then
      begin
        res += 'MUTABLE_DISPATCH_GLOBAL_SIZE+';
        left_val := left_val and not MUTABLE_DISPATCH_GLOBAL_SIZE.val;
      end;
      if MUTABLE_DISPATCH_LOCAL_SIZE in self then
      begin
        res += 'MUTABLE_DISPATCH_LOCAL_SIZE+';
        left_val := left_val and not MUTABLE_DISPATCH_LOCAL_SIZE.val;
      end;
      if MUTABLE_DISPATCH_ARGUMENTS in self then
      begin
        res += 'MUTABLE_DISPATCH_ARGUMENTS+';
        left_val := left_val and not MUTABLE_DISPATCH_ARGUMENTS.val;
      end;
      if MUTABLE_DISPATCH_EXEC_INFO in self then
      begin
        res += 'MUTABLE_DISPATCH_EXEC_INFO+';
        left_val := left_val and not MUTABLE_DISPATCH_EXEC_INFO.val;
      end;
      if left_val<>0 then
      begin
        res += 'clMutableDispatchFields[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clNDRangeKernelCommandProperties = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property MUTABLE_DISPATCH_UPDATABLE_FIELDS: clNDRangeKernelCommandProperties read new clNDRangeKernelCommandProperties($12B1);
    
    public function ToString: string; override;
    begin
      if MUTABLE_DISPATCH_UPDATABLE_FIELDS = self then
        Result := 'MUTABLE_DISPATCH_UPDATABLE_FIELDS' else
        Result := $'clNDRangeKernelCommandProperties[{self.val}]';
    end;
    
  end;
  
  ///
  clPipeInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PIPE_PACKET_SIZE: clPipeInfo read new clPipeInfo($1120);
    public static property PIPE_MAX_PACKETS: clPipeInfo read new clPipeInfo($1121);
    public static property PIPE_PROPERTIES:  clPipeInfo read new clPipeInfo($1122);
    
    public function ToString: string; override;
    begin
      if PIPE_PACKET_SIZE = self then
        Result := 'PIPE_PACKET_SIZE' else
      if PIPE_MAX_PACKETS = self then
        Result := 'PIPE_MAX_PACKETS' else
      if PIPE_PROPERTIES = self then
        Result := 'PIPE_PROPERTIES' else
        Result := $'clPipeInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clPlatformCommandBufferCapabilities = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property COMMAND_BUFFER_PLATFORM_UNIVERSAL_SYNC:  clPlatformCommandBufferCapabilities read new clPlatformCommandBufferCapabilities(1 shl 0);
    public static property COMMAND_BUFFER_PLATFORM_REMAP_QUEUES:    clPlatformCommandBufferCapabilities read new clPlatformCommandBufferCapabilities(1 shl 1);
    public static property COMMAND_BUFFER_PLATFORM_AUTOMATIC_REMAP: clPlatformCommandBufferCapabilities read new clPlatformCommandBufferCapabilities(1 shl 2);
    
    public static function operator+(v1, v2: clPlatformCommandBufferCapabilities) := new clPlatformCommandBufferCapabilities(v1.val or v2.val);
    public static function operator or(v1, v2: clPlatformCommandBufferCapabilities) := new clPlatformCommandBufferCapabilities(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clPlatformCommandBufferCapabilities; v2: clPlatformCommandBufferCapabilities) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clPlatformCommandBufferCapabilities) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clPlatformCommandBufferCapabilities[0]';
        exit;
      end;
      if COMMAND_BUFFER_PLATFORM_UNIVERSAL_SYNC in self then
      begin
        res += 'COMMAND_BUFFER_PLATFORM_UNIVERSAL_SYNC+';
        left_val := left_val and not COMMAND_BUFFER_PLATFORM_UNIVERSAL_SYNC.val;
      end;
      if COMMAND_BUFFER_PLATFORM_REMAP_QUEUES in self then
      begin
        res += 'COMMAND_BUFFER_PLATFORM_REMAP_QUEUES+';
        left_val := left_val and not COMMAND_BUFFER_PLATFORM_REMAP_QUEUES.val;
      end;
      if COMMAND_BUFFER_PLATFORM_AUTOMATIC_REMAP in self then
      begin
        res += 'COMMAND_BUFFER_PLATFORM_AUTOMATIC_REMAP+';
        left_val := left_val and not COMMAND_BUFFER_PLATFORM_AUTOMATIC_REMAP.val;
      end;
      if left_val<>0 then
      begin
        res += 'clPlatformCommandBufferCapabilities[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clPlatformInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PLATFORM_PROFILE:                             clPlatformInfo read new clPlatformInfo($0900);
    public static property PLATFORM_VERSION:                             clPlatformInfo read new clPlatformInfo($0901);
    public static property PLATFORM_NAME:                                clPlatformInfo read new clPlatformInfo($0902);
    public static property PLATFORM_VENDOR:                              clPlatformInfo read new clPlatformInfo($0903);
    public static property PLATFORM_EXTENSIONS:                          clPlatformInfo read new clPlatformInfo($0904);
    public static property PLATFORM_HOST_TIMER_RESOLUTION:               clPlatformInfo read new clPlatformInfo($0905);
    public static property PLATFORM_NUMERIC_VERSION:                     clPlatformInfo read new clPlatformInfo($0906);
    public static property PLATFORM_EXTENSIONS_WITH_VERSION:             clPlatformInfo read new clPlatformInfo($0907);
    public static property PLATFORM_COMMAND_BUFFER_CAPABILITIES:         clPlatformInfo read new clPlatformInfo($0908);
    public static property PLATFORM_ICD_SUFFIX:                          clPlatformInfo read new clPlatformInfo($0920);
    public static property PLATFORM_SEMAPHORE_TYPES:                     clPlatformInfo read new clPlatformInfo($2036);
    public static property PLATFORM_SEMAPHORE_IMPORT_HANDLE_TYPES:       clPlatformInfo read new clPlatformInfo($2037);
    public static property PLATFORM_SEMAPHORE_EXPORT_HANDLE_TYPES:       clPlatformInfo read new clPlatformInfo($2038);
    public static property PLATFORM_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES: clPlatformInfo read new clPlatformInfo($2044);
    
    public function ToString: string; override;
    begin
      if PLATFORM_PROFILE = self then
        Result := 'PLATFORM_PROFILE' else
      if PLATFORM_VERSION = self then
        Result := 'PLATFORM_VERSION' else
      if PLATFORM_NAME = self then
        Result := 'PLATFORM_NAME' else
      if PLATFORM_VENDOR = self then
        Result := 'PLATFORM_VENDOR' else
      if PLATFORM_EXTENSIONS = self then
        Result := 'PLATFORM_EXTENSIONS' else
      if PLATFORM_HOST_TIMER_RESOLUTION = self then
        Result := 'PLATFORM_HOST_TIMER_RESOLUTION' else
      if PLATFORM_NUMERIC_VERSION = self then
        Result := 'PLATFORM_NUMERIC_VERSION' else
      if PLATFORM_EXTENSIONS_WITH_VERSION = self then
        Result := 'PLATFORM_EXTENSIONS_WITH_VERSION' else
      if PLATFORM_COMMAND_BUFFER_CAPABILITIES = self then
        Result := 'PLATFORM_COMMAND_BUFFER_CAPABILITIES' else
      if PLATFORM_ICD_SUFFIX = self then
        Result := 'PLATFORM_ICD_SUFFIX' else
      if PLATFORM_SEMAPHORE_TYPES = self then
        Result := 'PLATFORM_SEMAPHORE_TYPES' else
      if PLATFORM_SEMAPHORE_IMPORT_HANDLE_TYPES = self then
        Result := 'PLATFORM_SEMAPHORE_IMPORT_HANDLE_TYPES' else
      if PLATFORM_SEMAPHORE_EXPORT_HANDLE_TYPES = self then
        Result := 'PLATFORM_SEMAPHORE_EXPORT_HANDLE_TYPES' else
      if PLATFORM_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES = self then
        Result := 'PLATFORM_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES' else
        Result := $'clPlatformInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clProfilingInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PROFILING_COMMAND_QUEUED:   clProfilingInfo read new clProfilingInfo($1280);
    public static property PROFILING_COMMAND_SUBMIT:   clProfilingInfo read new clProfilingInfo($1281);
    public static property PROFILING_COMMAND_START:    clProfilingInfo read new clProfilingInfo($1282);
    public static property PROFILING_COMMAND_END:      clProfilingInfo read new clProfilingInfo($1283);
    public static property PROFILING_COMMAND_COMPLETE: clProfilingInfo read new clProfilingInfo($1284);
    
    public function ToString: string; override;
    begin
      if PROFILING_COMMAND_QUEUED = self then
        Result := 'PROFILING_COMMAND_QUEUED' else
      if PROFILING_COMMAND_SUBMIT = self then
        Result := 'PROFILING_COMMAND_SUBMIT' else
      if PROFILING_COMMAND_START = self then
        Result := 'PROFILING_COMMAND_START' else
      if PROFILING_COMMAND_END = self then
        Result := 'PROFILING_COMMAND_END' else
      if PROFILING_COMMAND_COMPLETE = self then
        Result := 'PROFILING_COMMAND_COMPLETE' else
        Result := $'clProfilingInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clProgramBinaryType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PROGRAM_BINARY_TYPE_NONE:            clProgramBinaryType read new clProgramBinaryType(0);
    public static property PROGRAM_BINARY_TYPE_COMPILED_OBJECT: clProgramBinaryType read new clProgramBinaryType($0001);
    public static property PROGRAM_BINARY_TYPE_LIBRARY:         clProgramBinaryType read new clProgramBinaryType($0002);
    public static property PROGRAM_BINARY_TYPE_EXECUTABLE:      clProgramBinaryType read new clProgramBinaryType($0004);
    public static property PROGRAM_BINARY_TYPE_INTERMEDIATE:    clProgramBinaryType read new clProgramBinaryType($40E1);
    
    public function ToString: string; override;
    begin
      if PROGRAM_BINARY_TYPE_NONE = self then
        Result := 'PROGRAM_BINARY_TYPE_NONE' else
      if PROGRAM_BINARY_TYPE_COMPILED_OBJECT = self then
        Result := 'PROGRAM_BINARY_TYPE_COMPILED_OBJECT' else
      if PROGRAM_BINARY_TYPE_LIBRARY = self then
        Result := 'PROGRAM_BINARY_TYPE_LIBRARY' else
      if PROGRAM_BINARY_TYPE_EXECUTABLE = self then
        Result := 'PROGRAM_BINARY_TYPE_EXECUTABLE' else
      if PROGRAM_BINARY_TYPE_INTERMEDIATE = self then
        Result := 'PROGRAM_BINARY_TYPE_INTERMEDIATE' else
        Result := $'clProgramBinaryType[{self.val}]';
    end;
    
  end;
  
  ///
  clProgramBuildInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PROGRAM_BUILD_STATUS:                     clProgramBuildInfo read new clProgramBuildInfo($1181);
    public static property PROGRAM_BUILD_OPTIONS:                    clProgramBuildInfo read new clProgramBuildInfo($1182);
    public static property PROGRAM_BUILD_LOG:                        clProgramBuildInfo read new clProgramBuildInfo($1183);
    public static property PROGRAM_BINARY_TYPE:                      clProgramBuildInfo read new clProgramBuildInfo($1184);
    public static property PROGRAM_BUILD_GLOBAL_VARIABLE_TOTAL_SIZE: clProgramBuildInfo read new clProgramBuildInfo($1185);
    
    public function ToString: string; override;
    begin
      if PROGRAM_BUILD_STATUS = self then
        Result := 'PROGRAM_BUILD_STATUS' else
      if PROGRAM_BUILD_OPTIONS = self then
        Result := 'PROGRAM_BUILD_OPTIONS' else
      if PROGRAM_BUILD_LOG = self then
        Result := 'PROGRAM_BUILD_LOG' else
      if PROGRAM_BINARY_TYPE = self then
        Result := 'PROGRAM_BINARY_TYPE' else
      if PROGRAM_BUILD_GLOBAL_VARIABLE_TOTAL_SIZE = self then
        Result := 'PROGRAM_BUILD_GLOBAL_VARIABLE_TOTAL_SIZE' else
        Result := $'clProgramBuildInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clProgramInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PROGRAM_REFERENCE_COUNT:            clProgramInfo read new clProgramInfo($1160);
    public static property PROGRAM_CONTEXT:                    clProgramInfo read new clProgramInfo($1161);
    public static property PROGRAM_NUM_DEVICES:                clProgramInfo read new clProgramInfo($1162);
    public static property PROGRAM_DEVICES:                    clProgramInfo read new clProgramInfo($1163);
    public static property PROGRAM_SOURCE:                     clProgramInfo read new clProgramInfo($1164);
    public static property PROGRAM_BINARY_SIZES:               clProgramInfo read new clProgramInfo($1165);
    public static property PROGRAM_BINARIES:                   clProgramInfo read new clProgramInfo($1166);
    public static property PROGRAM_NUM_KERNELS:                clProgramInfo read new clProgramInfo($1167);
    public static property PROGRAM_KERNEL_NAMES:               clProgramInfo read new clProgramInfo($1168);
    public static property PROGRAM_IL:                         clProgramInfo read new clProgramInfo($1169);
    public static property PROGRAM_SCOPE_GLOBAL_CTORS_PRESENT: clProgramInfo read new clProgramInfo($116A);
    public static property PROGRAM_SCOPE_GLOBAL_DTORS_PRESENT: clProgramInfo read new clProgramInfo($116B);
    public static property PROGRAM_NUM_HOST_PIPES:             clProgramInfo read new clProgramInfo($4216);
    public static property PROGRAM_HOST_PIPE_NAMES:            clProgramInfo read new clProgramInfo($4217);
    
    public function ToString: string; override;
    begin
      if PROGRAM_REFERENCE_COUNT = self then
        Result := 'PROGRAM_REFERENCE_COUNT' else
      if PROGRAM_CONTEXT = self then
        Result := 'PROGRAM_CONTEXT' else
      if PROGRAM_NUM_DEVICES = self then
        Result := 'PROGRAM_NUM_DEVICES' else
      if PROGRAM_DEVICES = self then
        Result := 'PROGRAM_DEVICES' else
      if PROGRAM_SOURCE = self then
        Result := 'PROGRAM_SOURCE' else
      if PROGRAM_BINARY_SIZES = self then
        Result := 'PROGRAM_BINARY_SIZES' else
      if PROGRAM_BINARIES = self then
        Result := 'PROGRAM_BINARIES' else
      if PROGRAM_NUM_KERNELS = self then
        Result := 'PROGRAM_NUM_KERNELS' else
      if PROGRAM_KERNEL_NAMES = self then
        Result := 'PROGRAM_KERNEL_NAMES' else
      if PROGRAM_IL = self then
        Result := 'PROGRAM_IL' else
      if PROGRAM_SCOPE_GLOBAL_CTORS_PRESENT = self then
        Result := 'PROGRAM_SCOPE_GLOBAL_CTORS_PRESENT' else
      if PROGRAM_SCOPE_GLOBAL_DTORS_PRESENT = self then
        Result := 'PROGRAM_SCOPE_GLOBAL_DTORS_PRESENT' else
      if PROGRAM_NUM_HOST_PIPES = self then
        Result := 'PROGRAM_NUM_HOST_PIPES' else
      if PROGRAM_HOST_PIPE_NAMES = self then
        Result := 'PROGRAM_HOST_PIPE_NAMES' else
        Result := $'clProgramInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clQueueProperties = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property QUEUE_PRIORITY:           clQueueProperties read new clQueueProperties($1096);
    public static property QUEUE_THROTTLE:           clQueueProperties read new clQueueProperties($1097);
    public static property QUEUE_FAMILY:             clQueueProperties read new clQueueProperties($418C);
    public static property QUEUE_INDEX:              clQueueProperties read new clQueueProperties($418D);
    public static property QUEUE_JOB_SLOT:           clQueueProperties read new clQueueProperties($41E1);
    public static property QUEUE_KERNEL_BATCHING:    clQueueProperties read new clQueueProperties($41E7);
    public static property QUEUE_DEFERRED_FLUSH:     clQueueProperties read new clQueueProperties($41EC);
    public static property QUEUE_COMPUTE_UNIT_LIMIT: clQueueProperties read new clQueueProperties($41F3);
    
    public function ToString: string; override;
    begin
      if QUEUE_PRIORITY = self then
        Result := 'QUEUE_PRIORITY' else
      if QUEUE_THROTTLE = self then
        Result := 'QUEUE_THROTTLE' else
      if QUEUE_FAMILY = self then
        Result := 'QUEUE_FAMILY' else
      if QUEUE_INDEX = self then
        Result := 'QUEUE_INDEX' else
      if QUEUE_JOB_SLOT = self then
        Result := 'QUEUE_JOB_SLOT' else
      if QUEUE_KERNEL_BATCHING = self then
        Result := 'QUEUE_KERNEL_BATCHING' else
      if QUEUE_DEFERRED_FLUSH = self then
        Result := 'QUEUE_DEFERRED_FLUSH' else
      if QUEUE_COMPUTE_UNIT_LIMIT = self then
        Result := 'QUEUE_COMPUTE_UNIT_LIMIT' else
        Result := $'clQueueProperties[{self.val}]';
    end;
    
  end;
  
  ///
  clSadAdjustMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ME_SAD_ADJUST_MODE_NONE: clSadAdjustMode read new clSadAdjustMode(0);
    public static property ME_SAD_ADJUST_MODE_HAAR: clSadAdjustMode read new clSadAdjustMode($0001);
    
    public function ToString: string; override;
    begin
      if ME_SAD_ADJUST_MODE_NONE = self then
        Result := 'ME_SAD_ADJUST_MODE_NONE' else
      if ME_SAD_ADJUST_MODE_HAAR = self then
        Result := 'ME_SAD_ADJUST_MODE_HAAR' else
        Result := $'clSadAdjustMode[{self.val}]';
    end;
    
  end;
  
  ///
  clSamplerInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SAMPLER_REFERENCE_COUNT:   clSamplerInfo read new clSamplerInfo($1150);
    public static property SAMPLER_CONTEXT:           clSamplerInfo read new clSamplerInfo($1151);
    public static property SAMPLER_NORMALIZED_COORDS: clSamplerInfo read new clSamplerInfo($1152);
    public static property SAMPLER_ADDRESSING_MODE:   clSamplerInfo read new clSamplerInfo($1153);
    public static property SAMPLER_FILTER_MODE:       clSamplerInfo read new clSamplerInfo($1154);
    public static property SAMPLER_MIP_FILTER_MODE:   clSamplerInfo read new clSamplerInfo($1155);
    public static property SAMPLER_LOD_MIN:           clSamplerInfo read new clSamplerInfo($1156);
    public static property SAMPLER_LOD_MAX:           clSamplerInfo read new clSamplerInfo($1157);
    public static property SAMPLER_PROPERTIES:        clSamplerInfo read new clSamplerInfo($1158);
    
    public function ToString: string; override;
    begin
      if SAMPLER_REFERENCE_COUNT = self then
        Result := 'SAMPLER_REFERENCE_COUNT' else
      if SAMPLER_CONTEXT = self then
        Result := 'SAMPLER_CONTEXT' else
      if SAMPLER_NORMALIZED_COORDS = self then
        Result := 'SAMPLER_NORMALIZED_COORDS' else
      if SAMPLER_ADDRESSING_MODE = self then
        Result := 'SAMPLER_ADDRESSING_MODE' else
      if SAMPLER_FILTER_MODE = self then
        Result := 'SAMPLER_FILTER_MODE' else
      if SAMPLER_MIP_FILTER_MODE = self then
        Result := 'SAMPLER_MIP_FILTER_MODE' else
      if SAMPLER_LOD_MIN = self then
        Result := 'SAMPLER_LOD_MIN' else
      if SAMPLER_LOD_MAX = self then
        Result := 'SAMPLER_LOD_MAX' else
      if SAMPLER_PROPERTIES = self then
        Result := 'SAMPLER_PROPERTIES' else
        Result := $'clSamplerInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clSamplerProperties = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property SAMPLER_MIP_FILTER_MODE: clSamplerProperties read new clSamplerProperties($1155);
    public static property SAMPLER_LOD_MIN:         clSamplerProperties read new clSamplerProperties($1156);
    public static property SAMPLER_LOD_MAX:         clSamplerProperties read new clSamplerProperties($1157);
    
    public function ToString: string; override;
    begin
      if SAMPLER_MIP_FILTER_MODE = self then
        Result := 'SAMPLER_MIP_FILTER_MODE' else
      if SAMPLER_LOD_MIN = self then
        Result := 'SAMPLER_LOD_MIN' else
      if SAMPLER_LOD_MAX = self then
        Result := 'SAMPLER_LOD_MAX' else
        Result := $'clSamplerProperties[{self.val}]';
    end;
    
  end;
  
  ///
  clSearchPathType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ME_SEARCH_PATH_RADIUS_2_2:   clSearchPathType read new clSearchPathType(0);
    public static property ME_SEARCH_PATH_RADIUS_4_4:   clSearchPathType read new clSearchPathType($0001);
    public static property ME_SEARCH_PATH_RADIUS_16_12: clSearchPathType read new clSearchPathType($0005);
    
    public function ToString: string; override;
    begin
      if ME_SEARCH_PATH_RADIUS_2_2 = self then
        Result := 'ME_SEARCH_PATH_RADIUS_2_2' else
      if ME_SEARCH_PATH_RADIUS_4_4 = self then
        Result := 'ME_SEARCH_PATH_RADIUS_4_4' else
      if ME_SEARCH_PATH_RADIUS_16_12 = self then
        Result := 'ME_SEARCH_PATH_RADIUS_16_12' else
        Result := $'clSearchPathType[{self.val}]';
    end;
    
  end;
  
  ///
  clSemaphoreInfo = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SEMAPHORE_CONTEXT:             clSemaphoreInfo read new clSemaphoreInfo($2039);
    public static property SEMAPHORE_REFERENCE_COUNT:     clSemaphoreInfo read new clSemaphoreInfo($203A);
    public static property SEMAPHORE_PROPERTIES:          clSemaphoreInfo read new clSemaphoreInfo($203B);
    public static property SEMAPHORE_PAYLOAD:             clSemaphoreInfo read new clSemaphoreInfo($203C);
    public static property SEMAPHORE_TYPE:                clSemaphoreInfo read new clSemaphoreInfo($203D);
    public static property SEMAPHORE_EXPORT_HANDLE_TYPES: clSemaphoreInfo read new clSemaphoreInfo($203F);
    public static property SEMAPHORE_DEVICE_HANDLE_LIST:  clSemaphoreInfo read new clSemaphoreInfo($2053);
    public static property SEMAPHORE_EXPORTABLE:          clSemaphoreInfo read new clSemaphoreInfo($2054);
    
    public function ToString: string; override;
    begin
      if SEMAPHORE_CONTEXT = self then
        Result := 'SEMAPHORE_CONTEXT' else
      if SEMAPHORE_REFERENCE_COUNT = self then
        Result := 'SEMAPHORE_REFERENCE_COUNT' else
      if SEMAPHORE_PROPERTIES = self then
        Result := 'SEMAPHORE_PROPERTIES' else
      if SEMAPHORE_PAYLOAD = self then
        Result := 'SEMAPHORE_PAYLOAD' else
      if SEMAPHORE_TYPE = self then
        Result := 'SEMAPHORE_TYPE' else
      if SEMAPHORE_EXPORT_HANDLE_TYPES = self then
        Result := 'SEMAPHORE_EXPORT_HANDLE_TYPES' else
      if SEMAPHORE_DEVICE_HANDLE_LIST = self then
        Result := 'SEMAPHORE_DEVICE_HANDLE_LIST' else
      if SEMAPHORE_EXPORTABLE = self then
        Result := 'SEMAPHORE_EXPORTABLE' else
        Result := $'clSemaphoreInfo[{self.val}]';
    end;
    
  end;
  
  ///
  clSemaphoreProperties = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property SEMAPHORE_EXPORT_HANDLE_TYPES_LIST_END: clSemaphoreProperties read new clSemaphoreProperties(0);
    public static property SEMAPHORE_DEVICE_HANDLE_LIST_END:       clSemaphoreProperties read new clSemaphoreProperties(0);
    public static property SEMAPHORE_TYPE:                         clSemaphoreProperties read new clSemaphoreProperties($203D);
    public static property SEMAPHORE_EXPORT_HANDLE_TYPES:          clSemaphoreProperties read new clSemaphoreProperties($203F);
    public static property SEMAPHORE_DEVICE_HANDLE_LIST:           clSemaphoreProperties read new clSemaphoreProperties($2053);
    
    public function ToString: string; override;
    begin
      if SEMAPHORE_EXPORT_HANDLE_TYPES_LIST_END = self then
        Result := 'SEMAPHORE_EXPORT_HANDLE_TYPES_LIST_END' else
      if SEMAPHORE_TYPE = self then
        Result := 'SEMAPHORE_TYPE' else
      if SEMAPHORE_EXPORT_HANDLE_TYPES = self then
        Result := 'SEMAPHORE_EXPORT_HANDLE_TYPES' else
      if SEMAPHORE_DEVICE_HANDLE_LIST = self then
        Result := 'SEMAPHORE_DEVICE_HANDLE_LIST' else
        Result := $'clSemaphoreProperties[{self.val}]';
    end;
    
  end;
  
  ///
  clSemaphoreType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SEMAPHORE_TYPE_BINARY: clSemaphoreType read new clSemaphoreType($0001);
    
    public function ToString: string; override;
    begin
      if SEMAPHORE_TYPE_BINARY = self then
        Result := 'SEMAPHORE_TYPE_BINARY' else
        Result := $'clSemaphoreType[{self.val}]';
    end;
    
  end;
  
  ///
  clSubpixelMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ME_SUBPIXEL_MODE_INTEGER: clSubpixelMode read new clSubpixelMode(0);
    public static property ME_SUBPIXEL_MODE_HPEL:    clSubpixelMode read new clSubpixelMode($0001);
    public static property ME_SUBPIXEL_MODE_QPEL:    clSubpixelMode read new clSubpixelMode($0002);
    
    public function ToString: string; override;
    begin
      if ME_SUBPIXEL_MODE_INTEGER = self then
        Result := 'ME_SUBPIXEL_MODE_INTEGER' else
      if ME_SUBPIXEL_MODE_HPEL = self then
        Result := 'ME_SUBPIXEL_MODE_HPEL' else
      if ME_SUBPIXEL_MODE_QPEL = self then
        Result := 'ME_SUBPIXEL_MODE_QPEL' else
        Result := $'clSubpixelMode[{self.val}]';
    end;
    
  end;
  
  ///
  clSvmMemFlags = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property MEM_READ_WRITE:            clSvmMemFlags read new clSvmMemFlags(1 shl 0);
    public static property MEM_WRITE_ONLY:            clSvmMemFlags read new clSvmMemFlags(1 shl 1);
    public static property MEM_READ_ONLY:             clSvmMemFlags read new clSvmMemFlags(1 shl 2);
    public static property MEM_USE_HOST_PTR:          clSvmMemFlags read new clSvmMemFlags(1 shl 3);
    public static property MEM_ALLOC_HOST_PTR:        clSvmMemFlags read new clSvmMemFlags(1 shl 4);
    public static property MEM_COPY_HOST_PTR:         clSvmMemFlags read new clSvmMemFlags(1 shl 5);
    public static property MEM_HOST_WRITE_ONLY:       clSvmMemFlags read new clSvmMemFlags(1 shl 7);
    public static property MEM_HOST_READ_ONLY:        clSvmMemFlags read new clSvmMemFlags(1 shl 8);
    public static property MEM_HOST_NO_ACCESS:        clSvmMemFlags read new clSvmMemFlags(1 shl 9);
    public static property MEM_SVM_FINE_GRAIN_BUFFER: clSvmMemFlags read new clSvmMemFlags(1 shl 10);
    public static property MEM_SVM_ATOMICS:           clSvmMemFlags read new clSvmMemFlags(1 shl 11);
    public static property MEM_KERNEL_READ_AND_WRITE: clSvmMemFlags read new clSvmMemFlags(1 shl 12);
    
    public static function operator+(v1, v2: clSvmMemFlags) := new clSvmMemFlags(v1.val or v2.val);
    public static function operator or(v1, v2: clSvmMemFlags) := new clSvmMemFlags(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clSvmMemFlags; v2: clSvmMemFlags) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clSvmMemFlags) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clSvmMemFlags[0]';
        exit;
      end;
      if MEM_READ_WRITE in self then
      begin
        res += 'MEM_READ_WRITE+';
        left_val := left_val and not MEM_READ_WRITE.val;
      end;
      if MEM_WRITE_ONLY in self then
      begin
        res += 'MEM_WRITE_ONLY+';
        left_val := left_val and not MEM_WRITE_ONLY.val;
      end;
      if MEM_READ_ONLY in self then
      begin
        res += 'MEM_READ_ONLY+';
        left_val := left_val and not MEM_READ_ONLY.val;
      end;
      if MEM_USE_HOST_PTR in self then
      begin
        res += 'MEM_USE_HOST_PTR+';
        left_val := left_val and not MEM_USE_HOST_PTR.val;
      end;
      if MEM_ALLOC_HOST_PTR in self then
      begin
        res += 'MEM_ALLOC_HOST_PTR+';
        left_val := left_val and not MEM_ALLOC_HOST_PTR.val;
      end;
      if MEM_COPY_HOST_PTR in self then
      begin
        res += 'MEM_COPY_HOST_PTR+';
        left_val := left_val and not MEM_COPY_HOST_PTR.val;
      end;
      if MEM_HOST_WRITE_ONLY in self then
      begin
        res += 'MEM_HOST_WRITE_ONLY+';
        left_val := left_val and not MEM_HOST_WRITE_ONLY.val;
      end;
      if MEM_HOST_READ_ONLY in self then
      begin
        res += 'MEM_HOST_READ_ONLY+';
        left_val := left_val and not MEM_HOST_READ_ONLY.val;
      end;
      if MEM_HOST_NO_ACCESS in self then
      begin
        res += 'MEM_HOST_NO_ACCESS+';
        left_val := left_val and not MEM_HOST_NO_ACCESS.val;
      end;
      if MEM_SVM_FINE_GRAIN_BUFFER in self then
      begin
        res += 'MEM_SVM_FINE_GRAIN_BUFFER+';
        left_val := left_val and not MEM_SVM_FINE_GRAIN_BUFFER.val;
      end;
      if MEM_SVM_ATOMICS in self then
      begin
        res += 'MEM_SVM_ATOMICS+';
        left_val := left_val and not MEM_SVM_ATOMICS.val;
      end;
      if MEM_KERNEL_READ_AND_WRITE in self then
      begin
        res += 'MEM_KERNEL_READ_AND_WRITE+';
        left_val := left_val and not MEM_KERNEL_READ_AND_WRITE.val;
      end;
      if left_val<>0 then
      begin
        res += 'clSvmMemFlags[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clUnifiedSharedMemoryType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MEM_TYPE_UNKNOWN: clUnifiedSharedMemoryType read new clUnifiedSharedMemoryType($4196);
    public static property MEM_TYPE_HOST:    clUnifiedSharedMemoryType read new clUnifiedSharedMemoryType($4197);
    public static property MEM_TYPE_DEVICE:  clUnifiedSharedMemoryType read new clUnifiedSharedMemoryType($4198);
    public static property MEM_TYPE_SHARED:  clUnifiedSharedMemoryType read new clUnifiedSharedMemoryType($4199);
    
    public function ToString: string; override;
    begin
      if MEM_TYPE_UNKNOWN = self then
        Result := 'MEM_TYPE_UNKNOWN' else
      if MEM_TYPE_HOST = self then
        Result := 'MEM_TYPE_HOST' else
      if MEM_TYPE_DEVICE = self then
        Result := 'MEM_TYPE_DEVICE' else
      if MEM_TYPE_SHARED = self then
        Result := 'MEM_TYPE_SHARED' else
        Result := $'clUnifiedSharedMemoryType[{self.val}]';
    end;
    
  end;
  
  ///
  clVaApiDeviceSet = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property PREFERRED_DEVICES_FOR_VA_API: clVaApiDeviceSet read new clVaApiDeviceSet($4095);
    public static property ALL_DEVICES_FOR_VA_API:       clVaApiDeviceSet read new clVaApiDeviceSet($4096);
    
    public function ToString: string; override;
    begin
      if PREFERRED_DEVICES_FOR_VA_API = self then
        Result := 'PREFERRED_DEVICES_FOR_VA_API' else
      if ALL_DEVICES_FOR_VA_API = self then
        Result := 'ALL_DEVICES_FOR_VA_API' else
        Result := $'clVaApiDeviceSet[{self.val}]';
    end;
    
  end;
  
  ///
  clVaApiDeviceSource = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VA_API_DISPLAY: clVaApiDeviceSource read new clVaApiDeviceSource($4094);
    
    public function ToString: string; override;
    begin
      if VA_API_DISPLAY = self then
        Result := 'VA_API_DISPLAY' else
        Result := $'clVaApiDeviceSource[{self.val}]';
    end;
    
  end;
  
  ///
  clKernelExecInfoARM = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property KERNEL_EXEC_INFO_SVM_PTRS_ARM:              clKernelExecInfoARM read new clKernelExecInfoARM($40B8);
    public static property KERNEL_EXEC_INFO_SVM_FINE_GRAIN_SYSTEM_ARM: clKernelExecInfoARM read new clKernelExecInfoARM($40B9);
    
    public function ToString: string; override;
    begin
      if KERNEL_EXEC_INFO_SVM_PTRS_ARM = self then
        Result := 'KERNEL_EXEC_INFO_SVM_PTRS_ARM' else
      if KERNEL_EXEC_INFO_SVM_FINE_GRAIN_SYSTEM_ARM = self then
        Result := 'KERNEL_EXEC_INFO_SVM_FINE_GRAIN_SYSTEM_ARM' else
        Result := $'clKernelExecInfoARM[{self.val}]';
    end;
    
  end;
  
  ///
  clDevicePartitionPropertyEXT = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property PARTITION_BY_COUNTS_LIST_END:            clDevicePartitionPropertyEXT read new clDevicePartitionPropertyEXT(0);
    public static property PROPERTIES_LIST_END:                     clDevicePartitionPropertyEXT read new clDevicePartitionPropertyEXT(0);
    public static property PARTITION_BY_NAMES_LIST_END:             clDevicePartitionPropertyEXT read new clDevicePartitionPropertyEXT(-1);
    public static property DEVICE_PARTITION_EQUALLY_EXT:            clDevicePartitionPropertyEXT read new clDevicePartitionPropertyEXT($4050);
    public static property DEVICE_PARTITION_BY_COUNTS_EXT:          clDevicePartitionPropertyEXT read new clDevicePartitionPropertyEXT($4051);
    public static property DEVICE_PARTITION_BY_NAMES:               clDevicePartitionPropertyEXT read new clDevicePartitionPropertyEXT($4052);
    public static property DEVICE_PARTITION_BY_AFFINITY_DOMAIN_EXT: clDevicePartitionPropertyEXT read new clDevicePartitionPropertyEXT($4053);
    
    public function ToString: string; override;
    begin
      if PARTITION_BY_COUNTS_LIST_END = self then
        Result := 'PARTITION_BY_COUNTS_LIST_END' else
      if PARTITION_BY_NAMES_LIST_END = self then
        Result := 'PARTITION_BY_NAMES_LIST_END' else
      if DEVICE_PARTITION_EQUALLY_EXT = self then
        Result := 'DEVICE_PARTITION_EQUALLY_EXT' else
      if DEVICE_PARTITION_BY_COUNTS_EXT = self then
        Result := 'DEVICE_PARTITION_BY_COUNTS_EXT' else
      if DEVICE_PARTITION_BY_NAMES = self then
        Result := 'DEVICE_PARTITION_BY_NAMES' else
      if DEVICE_PARTITION_BY_AFFINITY_DOMAIN_EXT = self then
        Result := 'DEVICE_PARTITION_BY_AFFINITY_DOMAIN_EXT' else
        Result := $'clDevicePartitionPropertyEXT[{self.val}]';
    end;
    
  end;
  
  ///
  clMemAllocFlagsIMG = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property MEM_ALLOC_RELAX_REQUIREMENTS: clMemAllocFlagsIMG read new clMemAllocFlagsIMG(1 shl 0);
    public static property MEM_ALLOC_GPU_WRITE_COMBINE:  clMemAllocFlagsIMG read new clMemAllocFlagsIMG(1 shl 1);
    public static property MEM_ALLOC_GPU_CACHED:         clMemAllocFlagsIMG read new clMemAllocFlagsIMG(1 shl 2);
    public static property MEM_ALLOC_CPU_LOCAL:          clMemAllocFlagsIMG read new clMemAllocFlagsIMG(1 shl 3);
    public static property MEM_ALLOC_GPU_LOCAL:          clMemAllocFlagsIMG read new clMemAllocFlagsIMG(1 shl 4);
    public static property MEM_ALLOC_GPU_PRIVATE:        clMemAllocFlagsIMG read new clMemAllocFlagsIMG(1 shl 5);
    
    public static function operator+(v1, v2: clMemAllocFlagsIMG) := new clMemAllocFlagsIMG(v1.val or v2.val);
    public static function operator or(v1, v2: clMemAllocFlagsIMG) := new clMemAllocFlagsIMG(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clMemAllocFlagsIMG; v2: clMemAllocFlagsIMG) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clMemAllocFlagsIMG) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clMemAllocFlagsIMG[0]';
        exit;
      end;
      if MEM_ALLOC_RELAX_REQUIREMENTS in self then
      begin
        res += 'MEM_ALLOC_RELAX_REQUIREMENTS+';
        left_val := left_val and not MEM_ALLOC_RELAX_REQUIREMENTS.val;
      end;
      if MEM_ALLOC_GPU_WRITE_COMBINE in self then
      begin
        res += 'MEM_ALLOC_GPU_WRITE_COMBINE+';
        left_val := left_val and not MEM_ALLOC_GPU_WRITE_COMBINE.val;
      end;
      if MEM_ALLOC_GPU_CACHED in self then
      begin
        res += 'MEM_ALLOC_GPU_CACHED+';
        left_val := left_val and not MEM_ALLOC_GPU_CACHED.val;
      end;
      if MEM_ALLOC_CPU_LOCAL in self then
      begin
        res += 'MEM_ALLOC_CPU_LOCAL+';
        left_val := left_val and not MEM_ALLOC_CPU_LOCAL.val;
      end;
      if MEM_ALLOC_GPU_LOCAL in self then
      begin
        res += 'MEM_ALLOC_GPU_LOCAL+';
        left_val := left_val and not MEM_ALLOC_GPU_LOCAL.val;
      end;
      if MEM_ALLOC_GPU_PRIVATE in self then
      begin
        res += 'MEM_ALLOC_GPU_PRIVATE+';
        left_val := left_val and not MEM_ALLOC_GPU_PRIVATE.val;
      end;
      if left_val<>0 then
      begin
        res += 'clMemAllocFlagsIMG[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clMemAllocFlagsINTEL = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property MEM_ALLOC_WRITE_COMBINED:           clMemAllocFlagsINTEL read new clMemAllocFlagsINTEL(1 shl 0);
    public static property MEM_ALLOC_INITIAL_PLACEMENT_DEVICE: clMemAllocFlagsINTEL read new clMemAllocFlagsINTEL(1 shl 1);
    public static property MEM_ALLOC_INITIAL_PLACEMENT_HOST:   clMemAllocFlagsINTEL read new clMemAllocFlagsINTEL(1 shl 2);
    
    public static function operator+(v1, v2: clMemAllocFlagsINTEL) := new clMemAllocFlagsINTEL(v1.val or v2.val);
    public static function operator or(v1, v2: clMemAllocFlagsINTEL) := new clMemAllocFlagsINTEL(v1.val or v2.val);
    
    public static procedure operator+=(var v1: clMemAllocFlagsINTEL; v2: clMemAllocFlagsINTEL) := v1 := v1+v2;
    
    public static function operator in(v1, v2: clMemAllocFlagsINTEL) := v1.val and v2.val = v1.val;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      var left_val := self.val;
      if left_val=0 then
      begin
        Result := 'clMemAllocFlagsINTEL[0]';
        exit;
      end;
      if MEM_ALLOC_WRITE_COMBINED in self then
      begin
        res += 'MEM_ALLOC_WRITE_COMBINED+';
        left_val := left_val and not MEM_ALLOC_WRITE_COMBINED.val;
      end;
      if MEM_ALLOC_INITIAL_PLACEMENT_DEVICE in self then
      begin
        res += 'MEM_ALLOC_INITIAL_PLACEMENT_DEVICE+';
        left_val := left_val and not MEM_ALLOC_INITIAL_PLACEMENT_DEVICE.val;
      end;
      if MEM_ALLOC_INITIAL_PLACEMENT_HOST in self then
      begin
        res += 'MEM_ALLOC_INITIAL_PLACEMENT_HOST+';
        left_val := left_val and not MEM_ALLOC_INITIAL_PLACEMENT_HOST.val;
      end;
      if left_val<>0 then
      begin
        res += 'clMemAllocFlagsINTEL[';
        res += self.val.ToString;
        res += ']+';
      end;
      res.Length -= 1;
      Result := res.ToString;
    end;
    
  end;
  
  ///
  clMemInfoINTEL = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property MEM_ALLOC_BUFFER_LOCATION: clMemInfoINTEL read new clMemInfoINTEL($419E);
    
    public function ToString: string; override;
    begin
      if MEM_ALLOC_BUFFER_LOCATION = self then
        Result := 'MEM_ALLOC_BUFFER_LOCATION' else
        Result := $'clMemInfoINTEL[{self.val}]';
    end;
    
  end;
  
  ///
  clMemPropertiesINTEL = record
    public val: UInt64;
    public constructor(val: UInt64) := self.val := val;
    
    public static property MEM_ALLOC_FLAGS_INTEL:     clMemPropertiesINTEL read new clMemPropertiesINTEL($4195);
    public static property MEM_ALLOC_BUFFER_LOCATION: clMemPropertiesINTEL read new clMemPropertiesINTEL($419E);
    public static property MEM_CHANNEL:               clMemPropertiesINTEL read new clMemPropertiesINTEL($4213);
    
    public function ToString: string; override;
    begin
      if MEM_ALLOC_FLAGS_INTEL = self then
        Result := 'MEM_ALLOC_FLAGS_INTEL' else
      if MEM_ALLOC_BUFFER_LOCATION = self then
        Result := 'MEM_ALLOC_BUFFER_LOCATION' else
      if MEM_CHANNEL = self then
        Result := 'MEM_CHANNEL' else
        Result := $'clMemPropertiesINTEL[{self.val}]';
    end;
    
  end;
  
  ///
  cl_accelerator = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: cl_accelerator read default(cl_accelerator);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'cl_accelerator[{self.val}]';
    
  end;
  
  ///
  cl_command_buffer = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: cl_command_buffer read default(cl_command_buffer);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'cl_command_buffer[{self.val}]';
    
  end;
  
  ///
  cl_command_queue = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: cl_command_queue read default(cl_command_queue);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'cl_command_queue[{self.val}]';
    
  end;
  
  ///
  cl_context = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: cl_context read default(cl_context);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'cl_context[{self.val}]';
    
  end;
  
  ///
  cl_device_id = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: cl_device_id read default(cl_device_id);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'cl_device_id[{self.val}]';
    
  end;
  
  ///
  cl_eglDisplay = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: cl_eglDisplay read default(cl_eglDisplay);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'cl_eglDisplay[{self.val}]';
    
  end;
  
  ///
  cl_eglImage = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: cl_eglImage read default(cl_eglImage);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'cl_eglImage[{self.val}]';
    
  end;
  
  ///
  cl_eglSync = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: cl_eglSync read default(cl_eglSync);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'cl_eglSync[{self.val}]';
    
  end;
  
  ///
  cl_event = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: cl_event read default(cl_event);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'cl_event[{self.val}]';
    
  end;
  
  ///
  cl_GLsync = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: cl_GLsync read default(cl_GLsync);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'cl_GLsync[{self.val}]';
    
  end;
  
  ///
  cl_icd_dispatch = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: cl_icd_dispatch read default(cl_icd_dispatch);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'cl_icd_dispatch[{self.val}]';
    
  end;
  
  ///
  cl_kernel = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: cl_kernel read default(cl_kernel);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'cl_kernel[{self.val}]';
    
  end;
  
  ///
  cl_mem = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: cl_mem read default(cl_mem);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'cl_mem[{self.val}]';
    
  end;
  
  ///
  cl_mutable_command = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: cl_mutable_command read default(cl_mutable_command);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'cl_mutable_command[{self.val}]';
    
  end;
  
  ///
  cl_platform_id = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: cl_platform_id read default(cl_platform_id);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'cl_platform_id[{self.val}]';
    
  end;
  
  ///
  cl_program = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: cl_program read default(cl_program);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'cl_program[{self.val}]';
    
  end;
  
  ///
  cl_sampler = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: cl_sampler read default(cl_sampler);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'cl_sampler[{self.val}]';
    
  end;
  
  ///
  cl_semaphore = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: cl_semaphore read default(cl_semaphore);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'cl_semaphore[{self.val}]';
    
  end;
  
  ///
  va_image_format = record
    public val: UInt32;
    
    public constructor(val: UInt32) := self.val := val;
    
    public static property Zero: va_image_format read default(va_image_format);
    
    private static val_sz := Marshal.SizeOf&<UInt32>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'va_image_format[{self.val}]';
    
  end;
  
  ///
  va_surface_id = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: va_surface_id read default(va_surface_id);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'va_surface_id[{self.val}]';
    
  end;
  
  ///
  d3d_pixel_format = record
    public val: UInt32;
    
    public constructor(val: UInt32) := self.val := val;
    
    public static property Zero: d3d_pixel_format read default(d3d_pixel_format);
    
    private static val_sz := Marshal.SizeOf&<UInt32>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'d3d_pixel_format[{self.val}]';
    
  end;
  
  ///
  d3d_surface9 = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: d3d_surface9 read default(d3d_surface9);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'d3d_surface9[{self.val}]';
    
  end;
  
  ///
  d3d10_buffer = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: d3d10_buffer read default(d3d10_buffer);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'d3d10_buffer[{self.val}]';
    
  end;
  
  ///
  d3d10_texture_2d = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: d3d10_texture_2d read default(d3d10_texture_2d);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'d3d10_texture_2d[{self.val}]';
    
  end;
  
  ///
  d3d10_texture_3d = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: d3d10_texture_3d read default(d3d10_texture_3d);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'d3d10_texture_3d[{self.val}]';
    
  end;
  
  ///
  d3d11_buffer = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: d3d11_buffer read default(d3d11_buffer);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'d3d11_buffer[{self.val}]';
    
  end;
  
  ///
  d3d11_texture_2d = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: d3d11_texture_2d read default(d3d11_texture_2d);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'d3d11_texture_2d[{self.val}]';
    
  end;
  
  ///
  d3d11_texture_3d = record
    public val: IntPtr;
    
    public constructor(val: IntPtr) := self.val := val;
    public constructor(val: Int32) := self.val := new IntPtr(val);
    public constructor(val: Int64) := self.val := new IntPtr(val);
    
    public static property Zero: d3d11_texture_3d read default(d3d11_texture_3d);
    
    private static val_sz := Marshal.SizeOf&<IntPtr>;
    public static property Size: integer read val_sz;
    public property ValSize: integer read integer(val_sz);
    
    public function ToString: string; override := $'d3d11_texture_3d[{self.val}]';
    
  end;
  
  [StructLayout(LayoutKind.Explicit, Size = 64)]
  ///
  value_ansi_string_64 = record
    
    public property AnsiChars[i: integer]: Byte
      read Marshal.ReadByte(new IntPtr(@self), i)
      write Marshal.WriteByte(new IntPtr(@self), i, value); default;
    public property Chars[i: integer]: char read char(AnsiChars[i]) write AnsiChars[i] := Byte(value);
    
    public constructor(s: string; allow_trim: boolean := false);
    begin
      var len := s.Length;
      if len>63 then
        if allow_trim then
          len := 63 else
          raise new System.OverflowException;
      
      self.AnsiChars[len] := 0;
      for var i := 0 to len-1 do
        self.Chars[i] := s[i];
      
    end;
    
    public function ToString: string; override;
    begin
      var copy := self;
      Result := Marshal.PtrToStringAnsi(new IntPtr(@copy));
    end;
    
    public static function operator implicit(s: string): value_ansi_string_64 := new value_ansi_string_64(s);
    public static function operator explicit(s: string): value_ansi_string_64 := new value_ansi_string_64(s, true);
    
    public static function operator implicit(s: value_ansi_string_64): string := s.ToString;
    
  end;
  
  ///
  cl_buffer_region = record
    public origin: UIntPtr;
    public size: UIntPtr;
    
    public constructor(origin: UIntPtr; size: UIntPtr);
    begin
      self.origin := origin;
      self.size   := size;
    end;
    
  end;
  
  ///
  cl_device_integer_dot_product_acceleration_properties = record
    public signed_accelerated: clBool;
    public unsigned_accelerated: clBool;
    public mixed_signedness_accelerated: clBool;
    public accumulating_saturating_signed_accelerated: clBool;
    public accumulating_saturating_unsigned_accelerated: clBool;
    public accumulating_saturating_mixed_signedness_accelerated: clBool;
    
    public constructor(signed_accelerated: clBool; unsigned_accelerated: clBool; mixed_signedness_accelerated: clBool; accumulating_saturating_signed_accelerated: clBool; accumulating_saturating_unsigned_accelerated: clBool; accumulating_saturating_mixed_signedness_accelerated: clBool);
    begin
      self.signed_accelerated                                   := signed_accelerated;
      self.unsigned_accelerated                                 := unsigned_accelerated;
      self.mixed_signedness_accelerated                         := mixed_signedness_accelerated;
      self.accumulating_saturating_signed_accelerated           := accumulating_saturating_signed_accelerated;
      self.accumulating_saturating_unsigned_accelerated         := accumulating_saturating_unsigned_accelerated;
      self.accumulating_saturating_mixed_signedness_accelerated := accumulating_saturating_mixed_signedness_accelerated;
    end;
    
  end;
  
  ///
  cl_device_pci_bus_info = record
    public pci_domain: UInt32;
    public pci_bus: UInt32;
    public pci_device: UInt32;
    public pci_function: UInt32;
    
    public constructor(pci_domain: UInt32; pci_bus: UInt32; pci_device: UInt32; pci_function: UInt32);
    begin
      self.pci_domain   := pci_domain;
      self.pci_bus      := pci_bus;
      self.pci_device   := pci_device;
      self.pci_function := pci_function;
    end;
    
  end;
  
  ///
  cl_dx9_surface_info = record
    public resource: d3d_surface9;
    public shared_handle: IntPtr;
    
    public constructor(resource: d3d_surface9; shared_handle: IntPtr);
    begin
      self.resource      := resource;
      self.shared_handle := shared_handle;
    end;
    
  end;
  
  ///
  cl_image_desc = record
    public image_type: clMemObjectType;
    public image_width: UIntPtr;
    public image_height: UIntPtr;
    public image_depth: UIntPtr;
    public image_array_size: UIntPtr;
    public image_row_pitch: UIntPtr;
    public image_slice_pitch: UIntPtr;
    public num_mip_levels: UInt32;
    public num_samples: UInt32;
    public mem_object: cl_mem;
    
    public constructor(image_type: clMemObjectType; image_width: UIntPtr; image_height: UIntPtr; image_depth: UIntPtr; image_array_size: UIntPtr; image_row_pitch: UIntPtr; image_slice_pitch: UIntPtr; num_mip_levels: UInt32; num_samples: UInt32; mem_object: cl_mem);
    begin
      self.image_type        := image_type;
      self.image_width       := image_width;
      self.image_height      := image_height;
      self.image_depth       := image_depth;
      self.image_array_size  := image_array_size;
      self.image_row_pitch   := image_row_pitch;
      self.image_slice_pitch := image_slice_pitch;
      self.num_mip_levels    := num_mip_levels;
      self.num_samples       := num_samples;
      self.mem_object        := mem_object;
    end;
    
  end;
  
  ///
  cl_image_format = record
    public image_channel_order: clChannelOrder;
    public image_channel_data_type: clChannelType;
    
    public constructor(image_channel_order: clChannelOrder; image_channel_data_type: clChannelType);
    begin
      self.image_channel_order     := image_channel_order;
      self.image_channel_data_type := image_channel_data_type;
    end;
    
  end;
  
  ///
  cl_mem_ext_host_ptr = record
    public allocation_type: clAllocationType;
    public host_cache_policy: clHostCachePolicy;
    
    public constructor(allocation_type: clAllocationType; host_cache_policy: clHostCachePolicy);
    begin
      self.allocation_type   := allocation_type;
      self.host_cache_policy := host_cache_policy;
    end;
    
  end;
  
  ///
  cl_mem_android_native_buffer_host_ptr = record
    public ext_host_ptr: cl_mem_ext_host_ptr;
    public anb_ptr: IntPtr;
    
    public constructor(ext_host_ptr: cl_mem_ext_host_ptr; anb_ptr: IntPtr);
    begin
      self.ext_host_ptr := ext_host_ptr;
      self.anb_ptr      := anb_ptr;
    end;
    
  end;
  
  ///
  cl_mem_ion_host_ptr = record
    public ext_host_ptr: cl_mem_ext_host_ptr;
    public ion_filedesc: Int32;
    public ion_hostptr: IntPtr;
    
    public constructor(ext_host_ptr: cl_mem_ext_host_ptr; ion_filedesc: Int32; ion_hostptr: IntPtr);
    begin
      self.ext_host_ptr := ext_host_ptr;
      self.ion_filedesc := ion_filedesc;
      self.ion_hostptr  := ion_hostptr;
    end;
    
  end;
  
  ///
  cl_motion_estimation_desc = record
    public mb_block_type: clMbBlockType;
    public subpixel_mode: clSubpixelMode;
    public sad_adjust_mode: clSadAdjustMode;
    public search_path_type: clSearchPathType;
    
    public constructor(mb_block_type: clMbBlockType; subpixel_mode: clSubpixelMode; sad_adjust_mode: clSadAdjustMode; search_path_type: clSearchPathType);
    begin
      self.mb_block_type    := mb_block_type;
      self.subpixel_mode    := subpixel_mode;
      self.sad_adjust_mode  := sad_adjust_mode;
      self.search_path_type := search_path_type;
    end;
    
  end;
  
  ///
  cl_mutable_dispatch_arg = record
    public arg_index: UInt32;
    public arg_size: UIntPtr;
    public arg_value: IntPtr;
    
    public constructor(arg_index: UInt32; arg_size: UIntPtr; arg_value: IntPtr);
    begin
      self.arg_index := arg_index;
      self.arg_size  := arg_size;
      self.arg_value := arg_value;
    end;
    
  end;
  
  ///
  cl_mutable_dispatch_exec_info = record
    public param_name: UInt32;
    public param_value_size: UIntPtr;
    public param_value: IntPtr;
    
    public constructor(param_name: UInt32; param_value_size: UIntPtr; param_value: IntPtr);
    begin
      self.param_name       := param_name;
      self.param_value_size := param_value_size;
      self.param_value      := param_value;
    end;
    
  end;
  
  ///
  cl_mutable_dispatch_config = record
    public &type: clCommandBufferStructureType;
    public next: IntPtr;
    public command: cl_mutable_command;
    public num_args: UInt32;
    public num_svm_args: UInt32;
    public num_exec_infos: UInt32;
    public work_dim: UInt32;
    public arg_list: ^cl_mutable_dispatch_arg;
    public arg_svm_list: ^cl_mutable_dispatch_arg;
    public exec_info_list: ^cl_mutable_dispatch_exec_info;
    public global_work_offset: ^UIntPtr;
    public global_work_size: ^UIntPtr;
    public local_work_size: ^UIntPtr;
    
    public constructor(&type: clCommandBufferStructureType; next: IntPtr; command: cl_mutable_command; num_args: UInt32; num_svm_args: UInt32; num_exec_infos: UInt32; work_dim: UInt32; arg_list: ^cl_mutable_dispatch_arg; arg_svm_list: ^cl_mutable_dispatch_arg; exec_info_list: ^cl_mutable_dispatch_exec_info; global_work_offset: ^UIntPtr; global_work_size: ^UIntPtr; local_work_size: ^UIntPtr);
    begin
      self.type               := &type;
      self.next               := next;
      self.command            := command;
      self.num_args           := num_args;
      self.num_svm_args       := num_svm_args;
      self.num_exec_infos     := num_exec_infos;
      self.work_dim           := work_dim;
      self.arg_list           := arg_list;
      self.arg_svm_list       := arg_svm_list;
      self.exec_info_list     := exec_info_list;
      self.global_work_offset := global_work_offset;
      self.global_work_size   := global_work_size;
      self.local_work_size    := local_work_size;
    end;
    
  end;
  
  ///
  cl_mutable_base_config = record
    public &type: clCommandBufferStructureType;
    public next: IntPtr;
    public num_mutable_dispatch: UInt32;
    public mutable_dispatch_list: ^cl_mutable_dispatch_config;
    
    public constructor(&type: clCommandBufferStructureType; next: IntPtr; num_mutable_dispatch: UInt32; mutable_dispatch_list: ^cl_mutable_dispatch_config);
    begin
      self.type                  := &type;
      self.next                  := next;
      self.num_mutable_dispatch  := num_mutable_dispatch;
      self.mutable_dispatch_list := mutable_dispatch_list;
    end;
    
  end;
  
  ///
  cl_name_version = record
    public version: UInt32;
    public name: value_ansi_string_64;
    
    public constructor(version: UInt32; name: value_ansi_string_64);
    begin
      self.version := version;
      self.name    := name;
    end;
    
    public function ToString: string; override;
      const v_major_bits = 10;
      const v_minor_bits = 10;
      const v_patch_bits = 12;
    begin
      var sb := new StringBuilder;
      sb += '(';
      
      sb += 'v=';
      sb.Append(version shr (v_minor_bits+v_patch_bits));
      sb += '.';
      sb.Append(version shr v_patch_bits and (1 shl v_minor_bits - 1));
      sb += ':';
      sb.Append(version and (1 shl v_patch_bits - 1));
      
      sb += ' name="';
      sb += name.ToString;
      sb += '"';
      
      sb += ')';
      Result := sb.ToString;
    end;
    
  end;
  
  ///
  cl_queue_family_properties = record
    public properties: clCommandQueueProperties;
    public capabilities: clCommandQueueCapabilities;
    public count: UInt32;
    public name: value_ansi_string_64;
    
    public constructor(properties: clCommandQueueProperties; capabilities: clCommandQueueCapabilities; count: UInt32; name: value_ansi_string_64);
    begin
      self.properties   := properties;
      self.capabilities := capabilities;
      self.count        := count;
      self.name         := name;
    end;
    
  end;
  
  [System.Security.SuppressUnmanagedCodeSecurity]
  [UnmanagedFunctionPointer(CallingConvention.StdCall)]
  ///
  clContextDestructorCallback = procedure(context: cl_context; user_data: IntPtr);
  
  [System.Security.SuppressUnmanagedCodeSecurity]
  [UnmanagedFunctionPointer(CallingConvention.StdCall)]
  ///
  clCreateContextCallback = procedure(errinfo: string; private_info: IntPtr; cb: UIntPtr; user_data: IntPtr);
  
  [System.Security.SuppressUnmanagedCodeSecurity]
  [UnmanagedFunctionPointer(CallingConvention.StdCall)]
  ///
  clEnqueueNativeKernelCallback = procedure(user_data: IntPtr);
  
  [System.Security.SuppressUnmanagedCodeSecurity]
  [UnmanagedFunctionPointer(CallingConvention.StdCall)]
  ///
  clEnqueueSVMFreeCallback = procedure(queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: ^IntPtr; user_data: IntPtr);
  
  [System.Security.SuppressUnmanagedCodeSecurity]
  [UnmanagedFunctionPointer(CallingConvention.StdCall)]
  ///
  clEventCallback = procedure(&event: cl_event; event_command_status: clCommandExecutionStatus; user_data: IntPtr);
  
  [System.Security.SuppressUnmanagedCodeSecurity]
  [UnmanagedFunctionPointer(CallingConvention.StdCall)]
  ///
  clMemObjectDestructorCallback = procedure(memobj: cl_mem; user_data: IntPtr);
  
  [System.Security.SuppressUnmanagedCodeSecurity]
  [UnmanagedFunctionPointer(CallingConvention.StdCall)]
  ///
  clProgramCallback = procedure(&program: cl_program; user_data: IntPtr);
  
  {$endregion Вспомогательные типы}
  
  {$region Особые типы}
  
  ///Исключение, которое кидает clErrorCode.RaiseIfError
  OpenCLException = sealed class(Exception)
    private ec: clErrorCode;
    ///Код ошибки
    public property Code: clErrorCode read ec;
    
    ///
    public constructor(ec: clErrorCode; message: string);
    begin
      inherited Create(message);
      self.ec := ec;
    end;
    
    ///
    public constructor(ec: clErrorCode) :=
      Create(ec, $'Ошибка OpenCL: {ec}');
    
  end;
  
  {$endregion Особые типы}
  
  {$region Подпрограммы ядра}
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  cl = static class
    
    // added in cl1.0
    private static function ntv_BuildProgram_1(&program: cl_program; num_devices: UInt32; var device_list: cl_device_id; options: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
    external 'OpenCL' name 'clBuildProgram';
    private static function ntv_BuildProgram_2(&program: cl_program; num_devices: UInt32; device_list: IntPtr; options: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
    external 'OpenCL' name 'clBuildProgram';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function BuildProgram(&program: cl_program; num_devices: UInt32; device_list: array of cl_device_id; options: string; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
    begin
      var options_str_ptr := Marshal.StringToHGlobalAnsi(options);
      try
        Result := BuildProgram(&program, num_devices, device_list, options_str_ptr, pfn_notify, user_data);
      finally
        Marshal.FreeHGlobal(options_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function BuildProgram(&program: cl_program; num_devices: UInt32; device_list: array of cl_device_id; options: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
    type PCl_device_id = ^cl_device_id;
    begin
      Result := if (device_list<>nil) and (device_list.Length<>0) then
        ntv_BuildProgram_1(&program, num_devices, device_list[0], options, pfn_notify, user_data) else
        ntv_BuildProgram_1(&program, num_devices, PCl_device_id(nil)^, options, pfn_notify, user_data);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function BuildProgram(&program: cl_program; num_devices: UInt32; var device_list: cl_device_id; options: string; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
    begin
      var options_str_ptr := Marshal.StringToHGlobalAnsi(options);
      try
        Result := ntv_BuildProgram_1(&program, num_devices, device_list, options_str_ptr, pfn_notify, user_data);
      finally
        Marshal.FreeHGlobal(options_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function BuildProgram(&program: cl_program; num_devices: UInt32; var device_list: cl_device_id; options: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode :=
      ntv_BuildProgram_1(&program, num_devices, device_list, options, pfn_notify, user_data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function BuildProgram(&program: cl_program; num_devices: UInt32; device_list: IntPtr; options: string; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
    begin
      var options_str_ptr := Marshal.StringToHGlobalAnsi(options);
      try
        Result := ntv_BuildProgram_2(&program, num_devices, device_list, options_str_ptr, pfn_notify, user_data);
      finally
        Marshal.FreeHGlobal(options_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function BuildProgram(&program: cl_program; num_devices: UInt32; device_list: IntPtr; options: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode :=
      ntv_BuildProgram_2(&program, num_devices, device_list, options, pfn_notify, user_data);
    
    // added in cl2.1
    private static function ntv_CloneKernel_1(source_kernel: cl_kernel; var errcode_ret: clErrorCode): cl_kernel;
    external 'OpenCL' name 'clCloneKernel';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CloneKernel(source_kernel: cl_kernel; var errcode_ret: clErrorCode): cl_kernel :=
      ntv_CloneKernel_1(source_kernel, errcode_ret);
    
    // added in cl1.2
    private static function ntv_CompileProgram_1(&program: cl_program; num_devices: UInt32; var device_list: cl_device_id; options: IntPtr; num_input_headers: UInt32; var input_headers: cl_program; var header_include_names: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
    external 'OpenCL' name 'clCompileProgram';
    private static function ntv_CompileProgram_2(&program: cl_program; num_devices: UInt32; var device_list: cl_device_id; options: IntPtr; num_input_headers: UInt32; var input_headers: cl_program; header_include_names: pointer; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
    external 'OpenCL' name 'clCompileProgram';
    private static function ntv_CompileProgram_3(&program: cl_program; num_devices: UInt32; var device_list: cl_device_id; options: IntPtr; num_input_headers: UInt32; input_headers: IntPtr; var header_include_names: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
    external 'OpenCL' name 'clCompileProgram';
    private static function ntv_CompileProgram_4(&program: cl_program; num_devices: UInt32; var device_list: cl_device_id; options: IntPtr; num_input_headers: UInt32; input_headers: IntPtr; header_include_names: pointer; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
    external 'OpenCL' name 'clCompileProgram';
    private static function ntv_CompileProgram_5(&program: cl_program; num_devices: UInt32; device_list: IntPtr; options: IntPtr; num_input_headers: UInt32; var input_headers: cl_program; var header_include_names: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
    external 'OpenCL' name 'clCompileProgram';
    private static function ntv_CompileProgram_6(&program: cl_program; num_devices: UInt32; device_list: IntPtr; options: IntPtr; num_input_headers: UInt32; var input_headers: cl_program; header_include_names: pointer; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
    external 'OpenCL' name 'clCompileProgram';
    private static function ntv_CompileProgram_7(&program: cl_program; num_devices: UInt32; device_list: IntPtr; options: IntPtr; num_input_headers: UInt32; input_headers: IntPtr; var header_include_names: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
    external 'OpenCL' name 'clCompileProgram';
    private static function ntv_CompileProgram_8(&program: cl_program; num_devices: UInt32; device_list: IntPtr; options: IntPtr; num_input_headers: UInt32; input_headers: IntPtr; header_include_names: pointer; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
    external 'OpenCL' name 'clCompileProgram';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CompileProgram(&program: cl_program; num_devices: UInt32; device_list: array of cl_device_id; options: string; num_input_headers: UInt32; input_headers: array of cl_program; header_include_names: array of string; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
    begin
      var options_str_ptr := Marshal.StringToHGlobalAnsi(options);
      try
        Result := CompileProgram(&program, num_devices, device_list, options_str_ptr, num_input_headers, input_headers, header_include_names, pfn_notify, user_data);
      finally
        Marshal.FreeHGlobal(options_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CompileProgram(&program: cl_program; num_devices: UInt32; device_list: array of cl_device_id; options: IntPtr; num_input_headers: UInt32; input_headers: array of cl_program; header_include_names: array of string; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
    type PCl_device_id = ^cl_device_id;
    type PCl_program = ^cl_program;
    begin
      if (header_include_names=nil) or (header_include_names.Length=0) then
      begin
        Result := if (device_list<>nil) and (device_list.Length<>0) then
          if (input_headers<>nil) and (input_headers.Length<>0) then
            ntv_CompileProgram_2(&program, num_devices, device_list[0], options, num_input_headers, input_headers[0], nil, pfn_notify, user_data) else
            ntv_CompileProgram_2(&program, num_devices, device_list[0], options, num_input_headers, PCl_program(nil)^, nil, pfn_notify, user_data) else
          if (input_headers<>nil) and (input_headers.Length<>0) then
            ntv_CompileProgram_2(&program, num_devices, PCl_device_id(nil)^, options, num_input_headers, input_headers[0], nil, pfn_notify, user_data) else
            ntv_CompileProgram_2(&program, num_devices, PCl_device_id(nil)^, options, num_input_headers, PCl_program(nil)^, nil, pfn_notify, user_data);
        exit;
      end;
      var header_include_names_temp_arr: array of IntPtr;
      try
        begin
          var header_include_names_org_el_1 := header_include_names;
          var header_include_names_len_1 := header_include_names_org_el_1.Length;
          SetLength(header_include_names_temp_arr, header_include_names_len_1);
          var header_include_names_tmp_el_1 := header_include_names_temp_arr;
          for var header_include_names_ind_1 := 0 to header_include_names_len_1-1 do
          begin
            var header_include_names_org_el_2 := header_include_names_org_el_1[header_include_names_ind_1];
            if (header_include_names_org_el_2=nil) or (header_include_names_org_el_2.Length=0) then continue;
            header_include_names_tmp_el_1[header_include_names_ind_1] := Marshal.StringToHGlobalAnsi(header_include_names_org_el_2);
          end;
        end;
        Result := if (device_list<>nil) and (device_list.Length<>0) then
          if (input_headers<>nil) and (input_headers.Length<>0) then
            ntv_CompileProgram_1(&program, num_devices, device_list[0], options, num_input_headers, input_headers[0], header_include_names_temp_arr[0], pfn_notify, user_data) else
            ntv_CompileProgram_1(&program, num_devices, device_list[0], options, num_input_headers, PCl_program(nil)^, header_include_names_temp_arr[0], pfn_notify, user_data) else
          if (input_headers<>nil) and (input_headers.Length<>0) then
            ntv_CompileProgram_1(&program, num_devices, PCl_device_id(nil)^, options, num_input_headers, input_headers[0], header_include_names_temp_arr[0], pfn_notify, user_data) else
            ntv_CompileProgram_1(&program, num_devices, PCl_device_id(nil)^, options, num_input_headers, PCl_program(nil)^, header_include_names_temp_arr[0], pfn_notify, user_data);
      finally
         foreach var arr_el1 in header_include_names_temp_arr do Marshal.FreeHGlobal(arr_el1);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CompileProgram(&program: cl_program; num_devices: UInt32; var device_list: cl_device_id; options: string; num_input_headers: UInt32; var input_headers: cl_program; var header_include_names: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
    begin
      var options_str_ptr := Marshal.StringToHGlobalAnsi(options);
      try
        Result := ntv_CompileProgram_1(&program, num_devices, device_list, options_str_ptr, num_input_headers, input_headers, header_include_names, pfn_notify, user_data);
      finally
        Marshal.FreeHGlobal(options_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CompileProgram(&program: cl_program; num_devices: UInt32; var device_list: cl_device_id; options: string; num_input_headers: UInt32; var input_headers: cl_program; header_include_names: pointer; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
    begin
      var options_str_ptr := Marshal.StringToHGlobalAnsi(options);
      try
        Result := ntv_CompileProgram_2(&program, num_devices, device_list, options_str_ptr, num_input_headers, input_headers, header_include_names, pfn_notify, user_data);
      finally
        Marshal.FreeHGlobal(options_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CompileProgram(&program: cl_program; num_devices: UInt32; var device_list: cl_device_id; options: string; num_input_headers: UInt32; input_headers: IntPtr; var header_include_names: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
    begin
      var options_str_ptr := Marshal.StringToHGlobalAnsi(options);
      try
        Result := ntv_CompileProgram_3(&program, num_devices, device_list, options_str_ptr, num_input_headers, input_headers, header_include_names, pfn_notify, user_data);
      finally
        Marshal.FreeHGlobal(options_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CompileProgram(&program: cl_program; num_devices: UInt32; var device_list: cl_device_id; options: string; num_input_headers: UInt32; input_headers: IntPtr; header_include_names: pointer; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
    begin
      var options_str_ptr := Marshal.StringToHGlobalAnsi(options);
      try
        Result := ntv_CompileProgram_4(&program, num_devices, device_list, options_str_ptr, num_input_headers, input_headers, header_include_names, pfn_notify, user_data);
      finally
        Marshal.FreeHGlobal(options_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CompileProgram(&program: cl_program; num_devices: UInt32; var device_list: cl_device_id; options: IntPtr; num_input_headers: UInt32; var input_headers: cl_program; var header_include_names: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode :=
      ntv_CompileProgram_1(&program, num_devices, device_list, options, num_input_headers, input_headers, header_include_names, pfn_notify, user_data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CompileProgram(&program: cl_program; num_devices: UInt32; var device_list: cl_device_id; options: IntPtr; num_input_headers: UInt32; var input_headers: cl_program; header_include_names: pointer; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode :=
      ntv_CompileProgram_2(&program, num_devices, device_list, options, num_input_headers, input_headers, header_include_names, pfn_notify, user_data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CompileProgram(&program: cl_program; num_devices: UInt32; var device_list: cl_device_id; options: IntPtr; num_input_headers: UInt32; input_headers: IntPtr; var header_include_names: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode :=
      ntv_CompileProgram_3(&program, num_devices, device_list, options, num_input_headers, input_headers, header_include_names, pfn_notify, user_data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CompileProgram(&program: cl_program; num_devices: UInt32; var device_list: cl_device_id; options: IntPtr; num_input_headers: UInt32; input_headers: IntPtr; header_include_names: pointer; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode :=
      ntv_CompileProgram_4(&program, num_devices, device_list, options, num_input_headers, input_headers, header_include_names, pfn_notify, user_data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CompileProgram(&program: cl_program; num_devices: UInt32; device_list: IntPtr; options: string; num_input_headers: UInt32; var input_headers: cl_program; var header_include_names: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
    begin
      var options_str_ptr := Marshal.StringToHGlobalAnsi(options);
      try
        Result := ntv_CompileProgram_5(&program, num_devices, device_list, options_str_ptr, num_input_headers, input_headers, header_include_names, pfn_notify, user_data);
      finally
        Marshal.FreeHGlobal(options_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CompileProgram(&program: cl_program; num_devices: UInt32; device_list: IntPtr; options: string; num_input_headers: UInt32; var input_headers: cl_program; header_include_names: pointer; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
    begin
      var options_str_ptr := Marshal.StringToHGlobalAnsi(options);
      try
        Result := ntv_CompileProgram_6(&program, num_devices, device_list, options_str_ptr, num_input_headers, input_headers, header_include_names, pfn_notify, user_data);
      finally
        Marshal.FreeHGlobal(options_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CompileProgram(&program: cl_program; num_devices: UInt32; device_list: IntPtr; options: string; num_input_headers: UInt32; input_headers: IntPtr; var header_include_names: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
    begin
      var options_str_ptr := Marshal.StringToHGlobalAnsi(options);
      try
        Result := ntv_CompileProgram_7(&program, num_devices, device_list, options_str_ptr, num_input_headers, input_headers, header_include_names, pfn_notify, user_data);
      finally
        Marshal.FreeHGlobal(options_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CompileProgram(&program: cl_program; num_devices: UInt32; device_list: IntPtr; options: string; num_input_headers: UInt32; input_headers: IntPtr; header_include_names: pointer; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
    begin
      var options_str_ptr := Marshal.StringToHGlobalAnsi(options);
      try
        Result := ntv_CompileProgram_8(&program, num_devices, device_list, options_str_ptr, num_input_headers, input_headers, header_include_names, pfn_notify, user_data);
      finally
        Marshal.FreeHGlobal(options_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CompileProgram(&program: cl_program; num_devices: UInt32; device_list: IntPtr; options: IntPtr; num_input_headers: UInt32; var input_headers: cl_program; var header_include_names: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode :=
      ntv_CompileProgram_5(&program, num_devices, device_list, options, num_input_headers, input_headers, header_include_names, pfn_notify, user_data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CompileProgram(&program: cl_program; num_devices: UInt32; device_list: IntPtr; options: IntPtr; num_input_headers: UInt32; var input_headers: cl_program; header_include_names: pointer; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode :=
      ntv_CompileProgram_6(&program, num_devices, device_list, options, num_input_headers, input_headers, header_include_names, pfn_notify, user_data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CompileProgram(&program: cl_program; num_devices: UInt32; device_list: IntPtr; options: IntPtr; num_input_headers: UInt32; input_headers: IntPtr; var header_include_names: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode :=
      ntv_CompileProgram_7(&program, num_devices, device_list, options, num_input_headers, input_headers, header_include_names, pfn_notify, user_data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CompileProgram(&program: cl_program; num_devices: UInt32; device_list: IntPtr; options: IntPtr; num_input_headers: UInt32; input_headers: IntPtr; header_include_names: pointer; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode :=
      ntv_CompileProgram_8(&program, num_devices, device_list, options, num_input_headers, input_headers, header_include_names, pfn_notify, user_data);
    
    // added in cl1.0
    private static function ntv_CreateBuffer_1(context: cl_context; flags: clMemFlags; size: UIntPtr; var host_ptr: cl_mem_android_native_buffer_host_ptr; var errcode_ret: clErrorCode): cl_mem;
    external 'OpenCL' name 'clCreateBuffer';
    private static function ntv_CreateBuffer_2(context: cl_context; flags: clMemFlags; size: UIntPtr; var host_ptr: cl_mem_ext_host_ptr; var errcode_ret: clErrorCode): cl_mem;
    external 'OpenCL' name 'clCreateBuffer';
    private static function ntv_CreateBuffer_3(context: cl_context; flags: clMemFlags; size: UIntPtr; var host_ptr: cl_mem_ion_host_ptr; var errcode_ret: clErrorCode): cl_mem;
    external 'OpenCL' name 'clCreateBuffer';
    private static function ntv_CreateBuffer_4(context: cl_context; flags: clMemFlags; size: UIntPtr; var host_ptr: Byte; var errcode_ret: clErrorCode): cl_mem;
    external 'OpenCL' name 'clCreateBuffer';
    private static function ntv_CreateBuffer_5(context: cl_context; flags: clMemFlags; size: UIntPtr; host_ptr: pointer; var errcode_ret: clErrorCode): cl_mem;
    external 'OpenCL' name 'clCreateBuffer';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateBuffer<T>(context: cl_context; flags: clMemFlags; size: UIntPtr; host_ptr: array of T; var errcode_ret: clErrorCode): cl_mem; where T: record;
    type PT = ^T;
    begin
      Result := if (host_ptr<>nil) and (host_ptr.Length<>0) then
        CreateBuffer(context, flags, size, host_ptr[0], errcode_ret) else
        CreateBuffer(context, flags, size, PT(nil)^, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateBuffer(context: cl_context; flags: clMemFlags; size: UIntPtr; var host_ptr: cl_mem_android_native_buffer_host_ptr; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateBuffer_1(context, flags, size, host_ptr, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateBuffer(context: cl_context; flags: clMemFlags; size: UIntPtr; var host_ptr: cl_mem_ext_host_ptr; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateBuffer_2(context, flags, size, host_ptr, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateBuffer(context: cl_context; flags: clMemFlags; size: UIntPtr; var host_ptr: cl_mem_ion_host_ptr; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateBuffer_3(context, flags, size, host_ptr, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateBuffer<T>(context: cl_context; flags: clMemFlags; size: UIntPtr; var host_ptr: T; var errcode_ret: clErrorCode): cl_mem; where T: record;
    begin
      Result := ntv_CreateBuffer_4(context, flags, size, PByte(pointer(@host_ptr))^, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateBuffer(context: cl_context; flags: clMemFlags; size: UIntPtr; host_ptr: pointer; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateBuffer_5(context, flags, size, host_ptr, errcode_ret);
    
    // added in cl3.0
    private static function ntv_CreateBufferWithProperties_1(context: cl_context; var properties: clMemProperties; flags: clMemFlags; size: UIntPtr; host_ptr: IntPtr; var errcode_ret: clErrorCode): cl_mem;
    external 'OpenCL' name 'clCreateBufferWithProperties';
    private static function ntv_CreateBufferWithProperties_2(context: cl_context; properties: IntPtr; flags: clMemFlags; size: UIntPtr; host_ptr: IntPtr; var errcode_ret: clErrorCode): cl_mem;
    external 'OpenCL' name 'clCreateBufferWithProperties';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateBufferWithProperties(context: cl_context; properties: array of clMemProperties; flags: clMemFlags; size: UIntPtr; host_ptr: IntPtr; var errcode_ret: clErrorCode): cl_mem;
    type PClMemProperties = ^clMemProperties;
    begin
      Result := if (properties<>nil) and (properties.Length<>0) then
        ntv_CreateBufferWithProperties_1(context, properties[0], flags, size, host_ptr, errcode_ret) else
        ntv_CreateBufferWithProperties_1(context, PClMemProperties(nil)^, flags, size, host_ptr, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateBufferWithProperties(context: cl_context; var properties: clMemProperties; flags: clMemFlags; size: UIntPtr; host_ptr: IntPtr; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateBufferWithProperties_1(context, properties, flags, size, host_ptr, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateBufferWithProperties(context: cl_context; properties: IntPtr; flags: clMemFlags; size: UIntPtr; host_ptr: IntPtr; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateBufferWithProperties_2(context, properties, flags, size, host_ptr, errcode_ret);
    
    // added in cl1.0
    private static function ntv_CreateCommandQueue_1(context: cl_context; device: cl_device_id; properties: clCommandQueueProperties; var errcode_ret: clErrorCode): cl_command_queue;
    external 'OpenCL' name 'clCreateCommandQueue';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateCommandQueue(context: cl_context; device: cl_device_id; properties: clCommandQueueProperties; var errcode_ret: clErrorCode): cl_command_queue :=
      ntv_CreateCommandQueue_1(context, device, properties, errcode_ret);
    
    // added in cl2.0
    private static function ntv_CreateCommandQueueWithProperties_1(context: cl_context; device: cl_device_id; var properties: clQueueProperties; var errcode_ret: clErrorCode): cl_command_queue;
    external 'OpenCL' name 'clCreateCommandQueueWithProperties';
    private static function ntv_CreateCommandQueueWithProperties_2(context: cl_context; device: cl_device_id; properties: IntPtr; var errcode_ret: clErrorCode): cl_command_queue;
    external 'OpenCL' name 'clCreateCommandQueueWithProperties';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateCommandQueueWithProperties(context: cl_context; device: cl_device_id; properties: array of clQueueProperties; var errcode_ret: clErrorCode): cl_command_queue;
    type PClQueueProperties = ^clQueueProperties;
    begin
      Result := if (properties<>nil) and (properties.Length<>0) then
        ntv_CreateCommandQueueWithProperties_1(context, device, properties[0], errcode_ret) else
        ntv_CreateCommandQueueWithProperties_1(context, device, PClQueueProperties(nil)^, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateCommandQueueWithProperties(context: cl_context; device: cl_device_id; var properties: clQueueProperties; var errcode_ret: clErrorCode): cl_command_queue :=
      ntv_CreateCommandQueueWithProperties_1(context, device, properties, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateCommandQueueWithProperties(context: cl_context; device: cl_device_id; properties: IntPtr; var errcode_ret: clErrorCode): cl_command_queue :=
      ntv_CreateCommandQueueWithProperties_2(context, device, properties, errcode_ret);
    
    // added in cl1.0
    private static function ntv_CreateContext_1(var properties: clContextProperties; num_devices: UInt32; var devices: cl_device_id; pfn_notify: clCreateContextCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_context;
    external 'OpenCL' name 'clCreateContext';
    private static function ntv_CreateContext_2(var properties: clContextProperties; num_devices: UInt32; devices: IntPtr; pfn_notify: clCreateContextCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_context;
    external 'OpenCL' name 'clCreateContext';
    private static function ntv_CreateContext_3(properties: IntPtr; num_devices: UInt32; var devices: cl_device_id; pfn_notify: clCreateContextCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_context;
    external 'OpenCL' name 'clCreateContext';
    private static function ntv_CreateContext_4(properties: IntPtr; num_devices: UInt32; devices: IntPtr; pfn_notify: clCreateContextCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_context;
    external 'OpenCL' name 'clCreateContext';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateContext(properties: array of clContextProperties; num_devices: UInt32; devices: array of cl_device_id; pfn_notify: clCreateContextCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_context;
    type PClContextProperties = ^clContextProperties;
    type PCl_device_id = ^cl_device_id;
    begin
      Result := if (devices<>nil) and (devices.Length<>0) then
        if (properties<>nil) and (properties.Length<>0) then
          ntv_CreateContext_1(properties[0], num_devices, devices[0], pfn_notify, user_data, errcode_ret) else
          ntv_CreateContext_1(PClContextProperties(nil)^, num_devices, devices[0], pfn_notify, user_data, errcode_ret) else
        if (properties<>nil) and (properties.Length<>0) then
          ntv_CreateContext_1(properties[0], num_devices, PCl_device_id(nil)^, pfn_notify, user_data, errcode_ret) else
          ntv_CreateContext_1(PClContextProperties(nil)^, num_devices, PCl_device_id(nil)^, pfn_notify, user_data, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateContext(var properties: clContextProperties; num_devices: UInt32; var devices: cl_device_id; pfn_notify: clCreateContextCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_context :=
      ntv_CreateContext_1(properties, num_devices, devices, pfn_notify, user_data, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateContext(var properties: clContextProperties; num_devices: UInt32; devices: IntPtr; pfn_notify: clCreateContextCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_context :=
      ntv_CreateContext_2(properties, num_devices, devices, pfn_notify, user_data, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateContext(properties: IntPtr; num_devices: UInt32; var devices: cl_device_id; pfn_notify: clCreateContextCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_context :=
      ntv_CreateContext_3(properties, num_devices, devices, pfn_notify, user_data, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateContext(properties: IntPtr; num_devices: UInt32; devices: IntPtr; pfn_notify: clCreateContextCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_context :=
      ntv_CreateContext_4(properties, num_devices, devices, pfn_notify, user_data, errcode_ret);
    
    // added in cl1.0
    private static function ntv_CreateContextFromType_1(var properties: clContextProperties; device_type: clDeviceType; pfn_notify: clCreateContextCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_context;
    external 'OpenCL' name 'clCreateContextFromType';
    private static function ntv_CreateContextFromType_2(properties: IntPtr; device_type: clDeviceType; pfn_notify: clCreateContextCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_context;
    external 'OpenCL' name 'clCreateContextFromType';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateContextFromType(properties: array of clContextProperties; device_type: clDeviceType; pfn_notify: clCreateContextCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_context;
    type PClContextProperties = ^clContextProperties;
    begin
      Result := if (properties<>nil) and (properties.Length<>0) then
        ntv_CreateContextFromType_1(properties[0], device_type, pfn_notify, user_data, errcode_ret) else
        ntv_CreateContextFromType_1(PClContextProperties(nil)^, device_type, pfn_notify, user_data, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateContextFromType(var properties: clContextProperties; device_type: clDeviceType; pfn_notify: clCreateContextCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_context :=
      ntv_CreateContextFromType_1(properties, device_type, pfn_notify, user_data, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateContextFromType(properties: IntPtr; device_type: clDeviceType; pfn_notify: clCreateContextCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_context :=
      ntv_CreateContextFromType_2(properties, device_type, pfn_notify, user_data, errcode_ret);
    
    // added in cl1.2
    private static function ntv_CreateImage_1(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; var host_ptr: cl_mem_android_native_buffer_host_ptr; var errcode_ret: clErrorCode): cl_mem;
    external 'OpenCL' name 'clCreateImage';
    private static function ntv_CreateImage_2(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; var host_ptr: cl_mem_ext_host_ptr; var errcode_ret: clErrorCode): cl_mem;
    external 'OpenCL' name 'clCreateImage';
    private static function ntv_CreateImage_3(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; var host_ptr: cl_mem_ion_host_ptr; var errcode_ret: clErrorCode): cl_mem;
    external 'OpenCL' name 'clCreateImage';
    private static function ntv_CreateImage_4(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; var host_ptr: Byte; var errcode_ret: clErrorCode): cl_mem;
    external 'OpenCL' name 'clCreateImage';
    private static function ntv_CreateImage_5(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; host_ptr: pointer; var errcode_ret: clErrorCode): cl_mem;
    external 'OpenCL' name 'clCreateImage';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateImage<T>(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; host_ptr: array of T; var errcode_ret: clErrorCode): cl_mem; where T: record;
    type PT = ^T;
    begin
      Result := if (host_ptr<>nil) and (host_ptr.Length<>0) then
        CreateImage(context, flags, image_format, image_desc, host_ptr[0], errcode_ret) else
        CreateImage(context, flags, image_format, image_desc, PT(nil)^, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateImage(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; var host_ptr: cl_mem_android_native_buffer_host_ptr; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateImage_1(context, flags, image_format, image_desc, host_ptr, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateImage(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; var host_ptr: cl_mem_ext_host_ptr; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateImage_2(context, flags, image_format, image_desc, host_ptr, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateImage(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; var host_ptr: cl_mem_ion_host_ptr; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateImage_3(context, flags, image_format, image_desc, host_ptr, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateImage<T>(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; var host_ptr: T; var errcode_ret: clErrorCode): cl_mem; where T: record;
    begin
      Result := ntv_CreateImage_4(context, flags, image_format, image_desc, PByte(pointer(@host_ptr))^, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateImage(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; host_ptr: pointer; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateImage_5(context, flags, image_format, image_desc, host_ptr, errcode_ret);
    
    // added in cl1.0
    private static function ntv_CreateImage2D_1(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; image_width: UIntPtr; image_height: UIntPtr; image_row_pitch: UIntPtr; var host_ptr: cl_mem_android_native_buffer_host_ptr; var errcode_ret: clErrorCode): cl_mem;
    external 'OpenCL' name 'clCreateImage2D';
    private static function ntv_CreateImage2D_2(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; image_width: UIntPtr; image_height: UIntPtr; image_row_pitch: UIntPtr; var host_ptr: cl_mem_ext_host_ptr; var errcode_ret: clErrorCode): cl_mem;
    external 'OpenCL' name 'clCreateImage2D';
    private static function ntv_CreateImage2D_3(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; image_width: UIntPtr; image_height: UIntPtr; image_row_pitch: UIntPtr; var host_ptr: cl_mem_ion_host_ptr; var errcode_ret: clErrorCode): cl_mem;
    external 'OpenCL' name 'clCreateImage2D';
    private static function ntv_CreateImage2D_4(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; image_width: UIntPtr; image_height: UIntPtr; image_row_pitch: UIntPtr; host_ptr: IntPtr; var errcode_ret: clErrorCode): cl_mem;
    external 'OpenCL' name 'clCreateImage2D';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateImage2D(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; image_width: UIntPtr; image_height: UIntPtr; image_row_pitch: UIntPtr; var host_ptr: cl_mem_android_native_buffer_host_ptr; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateImage2D_1(context, flags, image_format, image_width, image_height, image_row_pitch, host_ptr, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateImage2D(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; image_width: UIntPtr; image_height: UIntPtr; image_row_pitch: UIntPtr; var host_ptr: cl_mem_ext_host_ptr; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateImage2D_2(context, flags, image_format, image_width, image_height, image_row_pitch, host_ptr, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateImage2D(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; image_width: UIntPtr; image_height: UIntPtr; image_row_pitch: UIntPtr; var host_ptr: cl_mem_ion_host_ptr; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateImage2D_3(context, flags, image_format, image_width, image_height, image_row_pitch, host_ptr, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateImage2D(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; image_width: UIntPtr; image_height: UIntPtr; image_row_pitch: UIntPtr; host_ptr: IntPtr; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateImage2D_4(context, flags, image_format, image_width, image_height, image_row_pitch, host_ptr, errcode_ret);
    
    // added in cl1.0
    private static function ntv_CreateImage3D_1(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; image_width: UIntPtr; image_height: UIntPtr; image_depth: UIntPtr; image_row_pitch: UIntPtr; image_slice_pitch: UIntPtr; var host_ptr: cl_mem_ext_host_ptr; var errcode_ret: clErrorCode): cl_mem;
    external 'OpenCL' name 'clCreateImage3D';
    private static function ntv_CreateImage3D_2(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; image_width: UIntPtr; image_height: UIntPtr; image_depth: UIntPtr; image_row_pitch: UIntPtr; image_slice_pitch: UIntPtr; var host_ptr: cl_mem_ion_host_ptr; var errcode_ret: clErrorCode): cl_mem;
    external 'OpenCL' name 'clCreateImage3D';
    private static function ntv_CreateImage3D_3(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; image_width: UIntPtr; image_height: UIntPtr; image_depth: UIntPtr; image_row_pitch: UIntPtr; image_slice_pitch: UIntPtr; host_ptr: IntPtr; var errcode_ret: clErrorCode): cl_mem;
    external 'OpenCL' name 'clCreateImage3D';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateImage3D(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; image_width: UIntPtr; image_height: UIntPtr; image_depth: UIntPtr; image_row_pitch: UIntPtr; image_slice_pitch: UIntPtr; var host_ptr: cl_mem_ext_host_ptr; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateImage3D_1(context, flags, image_format, image_width, image_height, image_depth, image_row_pitch, image_slice_pitch, host_ptr, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateImage3D(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; image_width: UIntPtr; image_height: UIntPtr; image_depth: UIntPtr; image_row_pitch: UIntPtr; image_slice_pitch: UIntPtr; var host_ptr: cl_mem_ion_host_ptr; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateImage3D_2(context, flags, image_format, image_width, image_height, image_depth, image_row_pitch, image_slice_pitch, host_ptr, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateImage3D(context: cl_context; flags: clMemFlags; var image_format: cl_image_format; image_width: UIntPtr; image_height: UIntPtr; image_depth: UIntPtr; image_row_pitch: UIntPtr; image_slice_pitch: UIntPtr; host_ptr: IntPtr; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateImage3D_3(context, flags, image_format, image_width, image_height, image_depth, image_row_pitch, image_slice_pitch, host_ptr, errcode_ret);
    
    // added in cl3.0
    private static function ntv_CreateImageWithProperties_1(context: cl_context; var properties: clMemProperties; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; var host_ptr: Byte; var errcode_ret: clErrorCode): cl_mem;
    external 'OpenCL' name 'clCreateImageWithProperties';
    private static function ntv_CreateImageWithProperties_2(context: cl_context; var properties: clMemProperties; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; host_ptr: pointer; var errcode_ret: clErrorCode): cl_mem;
    external 'OpenCL' name 'clCreateImageWithProperties';
    private static function ntv_CreateImageWithProperties_3(context: cl_context; properties: IntPtr; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; var host_ptr: Byte; var errcode_ret: clErrorCode): cl_mem;
    external 'OpenCL' name 'clCreateImageWithProperties';
    private static function ntv_CreateImageWithProperties_4(context: cl_context; properties: IntPtr; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; host_ptr: pointer; var errcode_ret: clErrorCode): cl_mem;
    external 'OpenCL' name 'clCreateImageWithProperties';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateImageWithProperties<T>(context: cl_context; properties: array of clMemProperties; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; host_ptr: array of T; var errcode_ret: clErrorCode): cl_mem; where T: record;
    type PClMemProperties = ^clMemProperties;
    type PT = ^T;
    begin
      Result := if (properties<>nil) and (properties.Length<>0) then
        if (host_ptr<>nil) and (host_ptr.Length<>0) then
          CreateImageWithProperties(context, properties[0], flags, image_format, image_desc, host_ptr[0], errcode_ret) else
          CreateImageWithProperties(context, properties[0], flags, image_format, image_desc, PT(nil)^, errcode_ret) else
        if (host_ptr<>nil) and (host_ptr.Length<>0) then
          CreateImageWithProperties(context, PClMemProperties(nil)^, flags, image_format, image_desc, host_ptr[0], errcode_ret) else
          CreateImageWithProperties(context, PClMemProperties(nil)^, flags, image_format, image_desc, PT(nil)^, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateImageWithProperties<T>(context: cl_context; var properties: clMemProperties; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; var host_ptr: T; var errcode_ret: clErrorCode): cl_mem; where T: record;
    begin
      Result := ntv_CreateImageWithProperties_1(context, properties, flags, image_format, image_desc, PByte(pointer(@host_ptr))^, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateImageWithProperties(context: cl_context; var properties: clMemProperties; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; host_ptr: pointer; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateImageWithProperties_2(context, properties, flags, image_format, image_desc, host_ptr, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateImageWithProperties<T>(context: cl_context; properties: IntPtr; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; var host_ptr: T; var errcode_ret: clErrorCode): cl_mem; where T: record;
    begin
      Result := ntv_CreateImageWithProperties_3(context, properties, flags, image_format, image_desc, PByte(pointer(@host_ptr))^, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateImageWithProperties(context: cl_context; properties: IntPtr; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; host_ptr: pointer; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateImageWithProperties_4(context, properties, flags, image_format, image_desc, host_ptr, errcode_ret);
    
    // added in cl1.0
    private static function ntv_CreateKernel_1(&program: cl_program; kernel_name: IntPtr; var errcode_ret: clErrorCode): cl_kernel;
    external 'OpenCL' name 'clCreateKernel';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateKernel(&program: cl_program; kernel_name: string; var errcode_ret: clErrorCode): cl_kernel;
    begin
      var kernel_name_str_ptr := Marshal.StringToHGlobalAnsi(kernel_name);
      try
        Result := ntv_CreateKernel_1(&program, kernel_name_str_ptr, errcode_ret);
      finally
        Marshal.FreeHGlobal(kernel_name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateKernel(&program: cl_program; kernel_name: IntPtr; var errcode_ret: clErrorCode): cl_kernel :=
      ntv_CreateKernel_1(&program, kernel_name, errcode_ret);
    
    // added in cl1.0
    private static function ntv_CreateKernelsInProgram_1(&program: cl_program; num_kernels: UInt32; var kernels: cl_kernel; var num_kernels_ret: UInt32): clErrorCode;
    external 'OpenCL' name 'clCreateKernelsInProgram';
    private static function ntv_CreateKernelsInProgram_2(&program: cl_program; num_kernels: UInt32; var kernels: cl_kernel; num_kernels_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clCreateKernelsInProgram';
    private static function ntv_CreateKernelsInProgram_3(&program: cl_program; num_kernels: UInt32; kernels: IntPtr; var num_kernels_ret: UInt32): clErrorCode;
    external 'OpenCL' name 'clCreateKernelsInProgram';
    private static function ntv_CreateKernelsInProgram_4(&program: cl_program; num_kernels: UInt32; kernels: IntPtr; num_kernels_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clCreateKernelsInProgram';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateKernelsInProgram(&program: cl_program; num_kernels: UInt32; var kernels: cl_kernel; var num_kernels_ret: UInt32): clErrorCode :=
      ntv_CreateKernelsInProgram_1(&program, num_kernels, kernels, num_kernels_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateKernelsInProgram(&program: cl_program; num_kernels: UInt32; var kernels: cl_kernel; num_kernels_ret: IntPtr): clErrorCode :=
      ntv_CreateKernelsInProgram_2(&program, num_kernels, kernels, num_kernels_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateKernelsInProgram(&program: cl_program; num_kernels: UInt32; kernels: IntPtr; var num_kernels_ret: UInt32): clErrorCode :=
      ntv_CreateKernelsInProgram_3(&program, num_kernels, kernels, num_kernels_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateKernelsInProgram(&program: cl_program; num_kernels: UInt32; kernels: IntPtr; num_kernels_ret: IntPtr): clErrorCode :=
      ntv_CreateKernelsInProgram_4(&program, num_kernels, kernels, num_kernels_ret);
    
    // added in cl2.0
    private static function ntv_CreatePipe_1(context: cl_context; flags: clMemFlags; pipe_packet_size: UInt32; pipe_max_packets: UInt32; properties: pointer; var errcode_ret: clErrorCode): cl_mem;
    external 'OpenCL' name 'clCreatePipe';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreatePipe(context: cl_context; flags: clMemFlags; pipe_packet_size: UInt32; pipe_max_packets: UInt32; properties: pointer; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreatePipe_1(context, flags, pipe_packet_size, pipe_max_packets, properties, errcode_ret);
    
    // added in cl1.0
    private static function ntv_CreateProgramWithBinary_1(context: cl_context; num_devices: UInt32; var device_list: cl_device_id; var lengths: UIntPtr; var binaries: IntPtr; var binary_status: clErrorCode; var errcode_ret: clErrorCode): cl_program;
    external 'OpenCL' name 'clCreateProgramWithBinary';
    private static function ntv_CreateProgramWithBinary_2(context: cl_context; num_devices: UInt32; var device_list: cl_device_id; var lengths: UIntPtr; binaries: pointer; var binary_status: clErrorCode; var errcode_ret: clErrorCode): cl_program;
    external 'OpenCL' name 'clCreateProgramWithBinary';
    private static function ntv_CreateProgramWithBinary_3(context: cl_context; num_devices: UInt32; var device_list: cl_device_id; var lengths: UIntPtr; var binaries: IntPtr; var binary_status: clErrorCode; errcode_ret: IntPtr): cl_program;
    external 'OpenCL' name 'clCreateProgramWithBinary';
    private static function ntv_CreateProgramWithBinary_4(context: cl_context; num_devices: UInt32; var device_list: cl_device_id; var lengths: UIntPtr; binaries: pointer; var binary_status: clErrorCode; errcode_ret: IntPtr): cl_program;
    external 'OpenCL' name 'clCreateProgramWithBinary';
    private static function ntv_CreateProgramWithBinary_5(context: cl_context; num_devices: UInt32; var device_list: cl_device_id; var lengths: UIntPtr; var binaries: IntPtr; binary_status: IntPtr; var errcode_ret: clErrorCode): cl_program;
    external 'OpenCL' name 'clCreateProgramWithBinary';
    private static function ntv_CreateProgramWithBinary_6(context: cl_context; num_devices: UInt32; device_list: IntPtr; lengths: IntPtr; binaries: pointer; var binary_status: clErrorCode; var errcode_ret: clErrorCode): cl_program;
    external 'OpenCL' name 'clCreateProgramWithBinary';
    private static function ntv_CreateProgramWithBinary_7(context: cl_context; num_devices: UInt32; device_list: IntPtr; lengths: IntPtr; binaries: pointer; var binary_status: clErrorCode; errcode_ret: IntPtr): cl_program;
    external 'OpenCL' name 'clCreateProgramWithBinary';
    private static function ntv_CreateProgramWithBinary_8(context: cl_context; num_devices: UInt32; device_list: IntPtr; lengths: IntPtr; binaries: pointer; binary_status: IntPtr; var errcode_ret: clErrorCode): cl_program;
    external 'OpenCL' name 'clCreateProgramWithBinary';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithBinary(context: cl_context; num_devices: UInt32; device_list: array of cl_device_id; lengths: array of UIntPtr; binaries: array of array of Byte; binary_status: array of clErrorCode; var errcode_ret: clErrorCode): cl_program;
    type PCl_device_id = ^cl_device_id;
    type PUIntPtr = ^UIntPtr;
    type PClErrorCode = ^clErrorCode;
    begin
      if (binaries=nil) or (binaries.Length=0) then
      begin
        Result := if (device_list<>nil) and (device_list.Length<>0) then
          if (lengths<>nil) and (lengths.Length<>0) then
            if (binary_status<>nil) and (binary_status.Length<>0) then
              ntv_CreateProgramWithBinary_2(context, num_devices, device_list[0], lengths[0], nil, binary_status[0], errcode_ret) else
              ntv_CreateProgramWithBinary_2(context, num_devices, device_list[0], lengths[0], nil, PClErrorCode(nil)^, errcode_ret) else
            if (binary_status<>nil) and (binary_status.Length<>0) then
              ntv_CreateProgramWithBinary_2(context, num_devices, device_list[0], PUIntPtr(nil)^, nil, binary_status[0], errcode_ret) else
              ntv_CreateProgramWithBinary_2(context, num_devices, device_list[0], PUIntPtr(nil)^, nil, PClErrorCode(nil)^, errcode_ret) else
          if (lengths<>nil) and (lengths.Length<>0) then
            if (binary_status<>nil) and (binary_status.Length<>0) then
              ntv_CreateProgramWithBinary_2(context, num_devices, PCl_device_id(nil)^, lengths[0], nil, binary_status[0], errcode_ret) else
              ntv_CreateProgramWithBinary_2(context, num_devices, PCl_device_id(nil)^, lengths[0], nil, PClErrorCode(nil)^, errcode_ret) else
            if (binary_status<>nil) and (binary_status.Length<>0) then
              ntv_CreateProgramWithBinary_2(context, num_devices, PCl_device_id(nil)^, PUIntPtr(nil)^, nil, binary_status[0], errcode_ret) else
              ntv_CreateProgramWithBinary_2(context, num_devices, PCl_device_id(nil)^, PUIntPtr(nil)^, nil, PClErrorCode(nil)^, errcode_ret);
        exit;
      end;
      var binaries_temp_arr: array of IntPtr;
      try
        begin
          var binaries_el_sz := Marshal.SizeOf&<Byte>;
          var binaries_org_el_1 := binaries;
          var binaries_len_1 := binaries_org_el_1.Length;
          SetLength(binaries_temp_arr, binaries_len_1);
          var binaries_tmp_el_1 := binaries_temp_arr;
          for var binaries_ind_1 := 0 to binaries_len_1-1 do
          begin
            var binaries_org_el_2 := binaries_org_el_1[binaries_ind_1];
            if (binaries_org_el_2=nil) or (binaries_org_el_2.Length=0) then continue;
            var binaries_len_2 := binaries_org_el_2.Length;
            var binaries_tmp_el_2_ptr := Marshal.AllocHGlobal(binaries_len_2 * binaries_el_sz);
            binaries_tmp_el_1[binaries_ind_1] := binaries_tmp_el_2_ptr;
            for var binaries_ind_2 := 0 to binaries_len_2-1 do
            begin
              var binaries_tmp_el_2_ptr_typed: ^Byte := binaries_tmp_el_2_ptr.ToPointer;
              binaries_tmp_el_2_ptr_typed^ := binaries_org_el_2[binaries_ind_2];
              binaries_tmp_el_2_ptr := binaries_tmp_el_2_ptr + binaries_el_sz;
            end;
          end;
        end;
        Result := if (device_list<>nil) and (device_list.Length<>0) then
          if (lengths<>nil) and (lengths.Length<>0) then
            if (binary_status<>nil) and (binary_status.Length<>0) then
              ntv_CreateProgramWithBinary_1(context, num_devices, device_list[0], lengths[0], binaries_temp_arr[0], binary_status[0], errcode_ret) else
              ntv_CreateProgramWithBinary_1(context, num_devices, device_list[0], lengths[0], binaries_temp_arr[0], PClErrorCode(nil)^, errcode_ret) else
            if (binary_status<>nil) and (binary_status.Length<>0) then
              ntv_CreateProgramWithBinary_1(context, num_devices, device_list[0], PUIntPtr(nil)^, binaries_temp_arr[0], binary_status[0], errcode_ret) else
              ntv_CreateProgramWithBinary_1(context, num_devices, device_list[0], PUIntPtr(nil)^, binaries_temp_arr[0], PClErrorCode(nil)^, errcode_ret) else
          if (lengths<>nil) and (lengths.Length<>0) then
            if (binary_status<>nil) and (binary_status.Length<>0) then
              ntv_CreateProgramWithBinary_1(context, num_devices, PCl_device_id(nil)^, lengths[0], binaries_temp_arr[0], binary_status[0], errcode_ret) else
              ntv_CreateProgramWithBinary_1(context, num_devices, PCl_device_id(nil)^, lengths[0], binaries_temp_arr[0], PClErrorCode(nil)^, errcode_ret) else
            if (binary_status<>nil) and (binary_status.Length<>0) then
              ntv_CreateProgramWithBinary_1(context, num_devices, PCl_device_id(nil)^, PUIntPtr(nil)^, binaries_temp_arr[0], binary_status[0], errcode_ret) else
              ntv_CreateProgramWithBinary_1(context, num_devices, PCl_device_id(nil)^, PUIntPtr(nil)^, binaries_temp_arr[0], PClErrorCode(nil)^, errcode_ret);
      finally
         foreach var arr_el1 in binaries_temp_arr do Marshal.FreeHGlobal(arr_el1);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithBinary(context: cl_context; num_devices: UInt32; device_list: array of cl_device_id; lengths: array of UIntPtr; binaries: array of array of Byte; binary_status: array of clErrorCode; errcode_ret: IntPtr): cl_program;
    type PCl_device_id = ^cl_device_id;
    type PUIntPtr = ^UIntPtr;
    type PClErrorCode = ^clErrorCode;
    begin
      if (binaries=nil) or (binaries.Length=0) then
      begin
        Result := if (device_list<>nil) and (device_list.Length<>0) then
          if (lengths<>nil) and (lengths.Length<>0) then
            if (binary_status<>nil) and (binary_status.Length<>0) then
              ntv_CreateProgramWithBinary_4(context, num_devices, device_list[0], lengths[0], nil, binary_status[0], errcode_ret) else
              ntv_CreateProgramWithBinary_4(context, num_devices, device_list[0], lengths[0], nil, PClErrorCode(nil)^, errcode_ret) else
            if (binary_status<>nil) and (binary_status.Length<>0) then
              ntv_CreateProgramWithBinary_4(context, num_devices, device_list[0], PUIntPtr(nil)^, nil, binary_status[0], errcode_ret) else
              ntv_CreateProgramWithBinary_4(context, num_devices, device_list[0], PUIntPtr(nil)^, nil, PClErrorCode(nil)^, errcode_ret) else
          if (lengths<>nil) and (lengths.Length<>0) then
            if (binary_status<>nil) and (binary_status.Length<>0) then
              ntv_CreateProgramWithBinary_4(context, num_devices, PCl_device_id(nil)^, lengths[0], nil, binary_status[0], errcode_ret) else
              ntv_CreateProgramWithBinary_4(context, num_devices, PCl_device_id(nil)^, lengths[0], nil, PClErrorCode(nil)^, errcode_ret) else
            if (binary_status<>nil) and (binary_status.Length<>0) then
              ntv_CreateProgramWithBinary_4(context, num_devices, PCl_device_id(nil)^, PUIntPtr(nil)^, nil, binary_status[0], errcode_ret) else
              ntv_CreateProgramWithBinary_4(context, num_devices, PCl_device_id(nil)^, PUIntPtr(nil)^, nil, PClErrorCode(nil)^, errcode_ret);
        exit;
      end;
      var binaries_temp_arr: array of IntPtr;
      try
        begin
          var binaries_el_sz := Marshal.SizeOf&<Byte>;
          var binaries_org_el_1 := binaries;
          var binaries_len_1 := binaries_org_el_1.Length;
          SetLength(binaries_temp_arr, binaries_len_1);
          var binaries_tmp_el_1 := binaries_temp_arr;
          for var binaries_ind_1 := 0 to binaries_len_1-1 do
          begin
            var binaries_org_el_2 := binaries_org_el_1[binaries_ind_1];
            if (binaries_org_el_2=nil) or (binaries_org_el_2.Length=0) then continue;
            var binaries_len_2 := binaries_org_el_2.Length;
            var binaries_tmp_el_2_ptr := Marshal.AllocHGlobal(binaries_len_2 * binaries_el_sz);
            binaries_tmp_el_1[binaries_ind_1] := binaries_tmp_el_2_ptr;
            for var binaries_ind_2 := 0 to binaries_len_2-1 do
            begin
              var binaries_tmp_el_2_ptr_typed: ^Byte := binaries_tmp_el_2_ptr.ToPointer;
              binaries_tmp_el_2_ptr_typed^ := binaries_org_el_2[binaries_ind_2];
              binaries_tmp_el_2_ptr := binaries_tmp_el_2_ptr + binaries_el_sz;
            end;
          end;
        end;
        Result := if (device_list<>nil) and (device_list.Length<>0) then
          if (lengths<>nil) and (lengths.Length<>0) then
            if (binary_status<>nil) and (binary_status.Length<>0) then
              ntv_CreateProgramWithBinary_3(context, num_devices, device_list[0], lengths[0], binaries_temp_arr[0], binary_status[0], errcode_ret) else
              ntv_CreateProgramWithBinary_3(context, num_devices, device_list[0], lengths[0], binaries_temp_arr[0], PClErrorCode(nil)^, errcode_ret) else
            if (binary_status<>nil) and (binary_status.Length<>0) then
              ntv_CreateProgramWithBinary_3(context, num_devices, device_list[0], PUIntPtr(nil)^, binaries_temp_arr[0], binary_status[0], errcode_ret) else
              ntv_CreateProgramWithBinary_3(context, num_devices, device_list[0], PUIntPtr(nil)^, binaries_temp_arr[0], PClErrorCode(nil)^, errcode_ret) else
          if (lengths<>nil) and (lengths.Length<>0) then
            if (binary_status<>nil) and (binary_status.Length<>0) then
              ntv_CreateProgramWithBinary_3(context, num_devices, PCl_device_id(nil)^, lengths[0], binaries_temp_arr[0], binary_status[0], errcode_ret) else
              ntv_CreateProgramWithBinary_3(context, num_devices, PCl_device_id(nil)^, lengths[0], binaries_temp_arr[0], PClErrorCode(nil)^, errcode_ret) else
            if (binary_status<>nil) and (binary_status.Length<>0) then
              ntv_CreateProgramWithBinary_3(context, num_devices, PCl_device_id(nil)^, PUIntPtr(nil)^, binaries_temp_arr[0], binary_status[0], errcode_ret) else
              ntv_CreateProgramWithBinary_3(context, num_devices, PCl_device_id(nil)^, PUIntPtr(nil)^, binaries_temp_arr[0], PClErrorCode(nil)^, errcode_ret);
      finally
         foreach var arr_el1 in binaries_temp_arr do Marshal.FreeHGlobal(arr_el1);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithBinary(context: cl_context; num_devices: UInt32; var device_list: cl_device_id; var lengths: UIntPtr; var binaries: IntPtr; var binary_status: clErrorCode; var errcode_ret: clErrorCode): cl_program :=
      ntv_CreateProgramWithBinary_1(context, num_devices, device_list, lengths, binaries, binary_status, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithBinary(context: cl_context; num_devices: UInt32; var device_list: cl_device_id; var lengths: UIntPtr; var binaries: IntPtr; var binary_status: clErrorCode; errcode_ret: IntPtr): cl_program :=
      ntv_CreateProgramWithBinary_3(context, num_devices, device_list, lengths, binaries, binary_status, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithBinary(context: cl_context; num_devices: UInt32; var device_list: cl_device_id; var lengths: UIntPtr; var binaries: IntPtr; binary_status: IntPtr; var errcode_ret: clErrorCode): cl_program :=
      ntv_CreateProgramWithBinary_5(context, num_devices, device_list, lengths, binaries, binary_status, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithBinary(context: cl_context; num_devices: UInt32; device_list: IntPtr; lengths: IntPtr; binaries: pointer; var binary_status: clErrorCode; var errcode_ret: clErrorCode): cl_program :=
      ntv_CreateProgramWithBinary_6(context, num_devices, device_list, lengths, binaries, binary_status, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithBinary(context: cl_context; num_devices: UInt32; device_list: IntPtr; lengths: IntPtr; binaries: pointer; var binary_status: clErrorCode; errcode_ret: IntPtr): cl_program :=
      ntv_CreateProgramWithBinary_7(context, num_devices, device_list, lengths, binaries, binary_status, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithBinary(context: cl_context; num_devices: UInt32; device_list: IntPtr; lengths: IntPtr; binaries: pointer; binary_status: IntPtr; var errcode_ret: clErrorCode): cl_program :=
      ntv_CreateProgramWithBinary_8(context, num_devices, device_list, lengths, binaries, binary_status, errcode_ret);
    
    // added in cl1.2
    private static function ntv_CreateProgramWithBuiltInKernels_1(context: cl_context; num_devices: UInt32; var device_list: cl_device_id; kernel_names: IntPtr; var errcode_ret: clErrorCode): cl_program;
    external 'OpenCL' name 'clCreateProgramWithBuiltInKernels';
    private static function ntv_CreateProgramWithBuiltInKernels_2(context: cl_context; num_devices: UInt32; device_list: IntPtr; kernel_names: IntPtr; var errcode_ret: clErrorCode): cl_program;
    external 'OpenCL' name 'clCreateProgramWithBuiltInKernels';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithBuiltInKernels(context: cl_context; num_devices: UInt32; device_list: array of cl_device_id; kernel_names: string; var errcode_ret: clErrorCode): cl_program;
    begin
      var kernel_names_str_ptr := Marshal.StringToHGlobalAnsi(kernel_names);
      try
        Result := CreateProgramWithBuiltInKernels(context, num_devices, device_list, kernel_names_str_ptr, errcode_ret);
      finally
        Marshal.FreeHGlobal(kernel_names_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithBuiltInKernels(context: cl_context; num_devices: UInt32; device_list: array of cl_device_id; kernel_names: IntPtr; var errcode_ret: clErrorCode): cl_program;
    type PCl_device_id = ^cl_device_id;
    begin
      Result := if (device_list<>nil) and (device_list.Length<>0) then
        ntv_CreateProgramWithBuiltInKernels_1(context, num_devices, device_list[0], kernel_names, errcode_ret) else
        ntv_CreateProgramWithBuiltInKernels_1(context, num_devices, PCl_device_id(nil)^, kernel_names, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithBuiltInKernels(context: cl_context; num_devices: UInt32; var device_list: cl_device_id; kernel_names: string; var errcode_ret: clErrorCode): cl_program;
    begin
      var kernel_names_str_ptr := Marshal.StringToHGlobalAnsi(kernel_names);
      try
        Result := ntv_CreateProgramWithBuiltInKernels_1(context, num_devices, device_list, kernel_names_str_ptr, errcode_ret);
      finally
        Marshal.FreeHGlobal(kernel_names_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithBuiltInKernels(context: cl_context; num_devices: UInt32; var device_list: cl_device_id; kernel_names: IntPtr; var errcode_ret: clErrorCode): cl_program :=
      ntv_CreateProgramWithBuiltInKernels_1(context, num_devices, device_list, kernel_names, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithBuiltInKernels(context: cl_context; num_devices: UInt32; device_list: IntPtr; kernel_names: string; var errcode_ret: clErrorCode): cl_program;
    begin
      var kernel_names_str_ptr := Marshal.StringToHGlobalAnsi(kernel_names);
      try
        Result := ntv_CreateProgramWithBuiltInKernels_2(context, num_devices, device_list, kernel_names_str_ptr, errcode_ret);
      finally
        Marshal.FreeHGlobal(kernel_names_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithBuiltInKernels(context: cl_context; num_devices: UInt32; device_list: IntPtr; kernel_names: IntPtr; var errcode_ret: clErrorCode): cl_program :=
      ntv_CreateProgramWithBuiltInKernels_2(context, num_devices, device_list, kernel_names, errcode_ret);
    
    // added in cl2.1
    private static function ntv_CreateProgramWithIL_1(context: cl_context; var il: Byte; length: UIntPtr; var errcode_ret: clErrorCode): cl_program;
    external 'OpenCL' name 'clCreateProgramWithIL';
    private static function ntv_CreateProgramWithIL_2(context: cl_context; il: IntPtr; length: UIntPtr; var errcode_ret: clErrorCode): cl_program;
    external 'OpenCL' name 'clCreateProgramWithIL';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithIL(context: cl_context; il: array of Byte; length: UIntPtr; var errcode_ret: clErrorCode): cl_program;
    type PByte = ^Byte;
    begin
      Result := if (il<>nil) and (il.Length<>0) then
        ntv_CreateProgramWithIL_1(context, il[0], length, errcode_ret) else
        ntv_CreateProgramWithIL_1(context, PByte(nil)^, length, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithIL(context: cl_context; var il: Byte; length: UIntPtr; var errcode_ret: clErrorCode): cl_program :=
      ntv_CreateProgramWithIL_1(context, il, length, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithIL(context: cl_context; il: IntPtr; length: UIntPtr; var errcode_ret: clErrorCode): cl_program :=
      ntv_CreateProgramWithIL_2(context, il, length, errcode_ret);
    
    // added in cl1.0
    private static function ntv_CreateProgramWithSource_1(context: cl_context; count: UInt32; var strings: IntPtr; var lengths: UIntPtr; var errcode_ret: clErrorCode): cl_program;
    external 'OpenCL' name 'clCreateProgramWithSource';
    private static function ntv_CreateProgramWithSource_2(context: cl_context; count: UInt32; strings: pointer; var lengths: UIntPtr; var errcode_ret: clErrorCode): cl_program;
    external 'OpenCL' name 'clCreateProgramWithSource';
    private static function ntv_CreateProgramWithSource_3(context: cl_context; count: UInt32; var strings: IntPtr; lengths: IntPtr; var errcode_ret: clErrorCode): cl_program;
    external 'OpenCL' name 'clCreateProgramWithSource';
    private static function ntv_CreateProgramWithSource_4(context: cl_context; count: UInt32; strings: pointer; lengths: IntPtr; var errcode_ret: clErrorCode): cl_program;
    external 'OpenCL' name 'clCreateProgramWithSource';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithSource(context: cl_context; count: UInt32; strings: array of string; lengths: array of UIntPtr; var errcode_ret: clErrorCode): cl_program;
    type PUIntPtr = ^UIntPtr;
    begin
      if (strings=nil) or (strings.Length=0) then
      begin
        Result := if (lengths<>nil) and (lengths.Length<>0) then
          ntv_CreateProgramWithSource_2(context, count, nil, lengths[0], errcode_ret) else
          ntv_CreateProgramWithSource_2(context, count, nil, PUIntPtr(nil)^, errcode_ret);
        exit;
      end;
      var strings_temp_arr: array of IntPtr;
      try
        begin
          var strings_org_el_1 := strings;
          var strings_len_1 := strings_org_el_1.Length;
          SetLength(strings_temp_arr, strings_len_1);
          var strings_tmp_el_1 := strings_temp_arr;
          for var strings_ind_1 := 0 to strings_len_1-1 do
          begin
            var strings_org_el_2 := strings_org_el_1[strings_ind_1];
            if (strings_org_el_2=nil) or (strings_org_el_2.Length=0) then continue;
            strings_tmp_el_1[strings_ind_1] := Marshal.StringToHGlobalAnsi(strings_org_el_2);
          end;
        end;
        Result := if (lengths<>nil) and (lengths.Length<>0) then
          ntv_CreateProgramWithSource_1(context, count, strings_temp_arr[0], lengths[0], errcode_ret) else
          ntv_CreateProgramWithSource_1(context, count, strings_temp_arr[0], PUIntPtr(nil)^, errcode_ret);
      finally
         foreach var arr_el1 in strings_temp_arr do Marshal.FreeHGlobal(arr_el1);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithSource(context: cl_context; count: UInt32; var strings: IntPtr; var lengths: UIntPtr; var errcode_ret: clErrorCode): cl_program :=
      ntv_CreateProgramWithSource_1(context, count, strings, lengths, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithSource(context: cl_context; count: UInt32; var strings: IntPtr; lengths: IntPtr; var errcode_ret: clErrorCode): cl_program :=
      ntv_CreateProgramWithSource_3(context, count, strings, lengths, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithSource(context: cl_context; count: UInt32; strings: pointer; var lengths: UIntPtr; var errcode_ret: clErrorCode): cl_program :=
      ntv_CreateProgramWithSource_2(context, count, strings, lengths, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateProgramWithSource(context: cl_context; count: UInt32; strings: pointer; lengths: IntPtr; var errcode_ret: clErrorCode): cl_program :=
      ntv_CreateProgramWithSource_4(context, count, strings, lengths, errcode_ret);
    
    // added in cl1.0
    private static function ntv_CreateSampler_1(context: cl_context; normalized_coords: clBool; addressing_mode: clAddressingMode; filter_mode: clFilterMode; var errcode_ret: clErrorCode): cl_sampler;
    external 'OpenCL' name 'clCreateSampler';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateSampler(context: cl_context; normalized_coords: clBool; addressing_mode: clAddressingMode; filter_mode: clFilterMode; var errcode_ret: clErrorCode): cl_sampler :=
      ntv_CreateSampler_1(context, normalized_coords, addressing_mode, filter_mode, errcode_ret);
    
    // added in cl2.0
    private static function ntv_CreateSamplerWithProperties_1(context: cl_context; var sampler_properties: clSamplerProperties; var errcode_ret: clErrorCode): cl_sampler;
    external 'OpenCL' name 'clCreateSamplerWithProperties';
    private static function ntv_CreateSamplerWithProperties_2(context: cl_context; sampler_properties: IntPtr; var errcode_ret: clErrorCode): cl_sampler;
    external 'OpenCL' name 'clCreateSamplerWithProperties';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateSamplerWithProperties(context: cl_context; sampler_properties: array of clSamplerProperties; var errcode_ret: clErrorCode): cl_sampler;
    type PClSamplerProperties = ^clSamplerProperties;
    begin
      Result := if (sampler_properties<>nil) and (sampler_properties.Length<>0) then
        ntv_CreateSamplerWithProperties_1(context, sampler_properties[0], errcode_ret) else
        ntv_CreateSamplerWithProperties_1(context, PClSamplerProperties(nil)^, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateSamplerWithProperties(context: cl_context; var sampler_properties: clSamplerProperties; var errcode_ret: clErrorCode): cl_sampler :=
      ntv_CreateSamplerWithProperties_1(context, sampler_properties, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateSamplerWithProperties(context: cl_context; sampler_properties: IntPtr; var errcode_ret: clErrorCode): cl_sampler :=
      ntv_CreateSamplerWithProperties_2(context, sampler_properties, errcode_ret);
    
    // added in cl1.1
    private static function ntv_CreateSubBuffer_1(buffer: cl_mem; flags: clMemFlags; buffer_create_type: clBufferCreateType; var buffer_create_info: cl_buffer_region; var errcode_ret: clErrorCode): cl_mem;
    external 'OpenCL' name 'clCreateSubBuffer';
    private static function ntv_CreateSubBuffer_2(buffer: cl_mem; flags: clMemFlags; buffer_create_type: clBufferCreateType; buffer_create_info: IntPtr; var errcode_ret: clErrorCode): cl_mem;
    external 'OpenCL' name 'clCreateSubBuffer';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateSubBuffer(buffer: cl_mem; flags: clMemFlags; buffer_create_type: clBufferCreateType; var buffer_create_info: cl_buffer_region; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateSubBuffer_1(buffer, flags, buffer_create_type, buffer_create_info, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateSubBuffer(buffer: cl_mem; flags: clMemFlags; buffer_create_type: clBufferCreateType; buffer_create_info: IntPtr; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateSubBuffer_2(buffer, flags, buffer_create_type, buffer_create_info, errcode_ret);
    
    // added in cl1.2
    private static function ntv_CreateSubDevices_1(in_device: cl_device_id; var properties: clDevicePartitionProperty; num_devices: UInt32; var out_devices: cl_device_id; var num_devices_ret: UInt32): clErrorCode;
    external 'OpenCL' name 'clCreateSubDevices';
    private static function ntv_CreateSubDevices_2(in_device: cl_device_id; var properties: clDevicePartitionProperty; num_devices: UInt32; var out_devices: cl_device_id; num_devices_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clCreateSubDevices';
    private static function ntv_CreateSubDevices_3(in_device: cl_device_id; var properties: clDevicePartitionProperty; num_devices: UInt32; out_devices: IntPtr; var num_devices_ret: UInt32): clErrorCode;
    external 'OpenCL' name 'clCreateSubDevices';
    private static function ntv_CreateSubDevices_4(in_device: cl_device_id; var properties: clDevicePartitionProperty; num_devices: UInt32; out_devices: IntPtr; num_devices_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clCreateSubDevices';
    private static function ntv_CreateSubDevices_5(in_device: cl_device_id; properties: IntPtr; num_devices: UInt32; var out_devices: cl_device_id; var num_devices_ret: UInt32): clErrorCode;
    external 'OpenCL' name 'clCreateSubDevices';
    private static function ntv_CreateSubDevices_6(in_device: cl_device_id; properties: IntPtr; num_devices: UInt32; var out_devices: cl_device_id; num_devices_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clCreateSubDevices';
    private static function ntv_CreateSubDevices_7(in_device: cl_device_id; properties: IntPtr; num_devices: UInt32; out_devices: IntPtr; var num_devices_ret: UInt32): clErrorCode;
    external 'OpenCL' name 'clCreateSubDevices';
    private static function ntv_CreateSubDevices_8(in_device: cl_device_id; properties: IntPtr; num_devices: UInt32; out_devices: IntPtr; num_devices_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clCreateSubDevices';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateSubDevices(in_device: cl_device_id; properties: array of clDevicePartitionProperty; num_devices: UInt32; var out_devices: cl_device_id; var num_devices_ret: UInt32): clErrorCode;
    type PClDevicePartitionProperty = ^clDevicePartitionProperty;
    begin
      Result := if (properties<>nil) and (properties.Length<>0) then
        ntv_CreateSubDevices_1(in_device, properties[0], num_devices, out_devices, num_devices_ret) else
        ntv_CreateSubDevices_1(in_device, PClDevicePartitionProperty(nil)^, num_devices, out_devices, num_devices_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateSubDevices(in_device: cl_device_id; properties: array of clDevicePartitionProperty; num_devices: UInt32; var out_devices: cl_device_id; num_devices_ret: IntPtr): clErrorCode;
    type PClDevicePartitionProperty = ^clDevicePartitionProperty;
    begin
      Result := if (properties<>nil) and (properties.Length<>0) then
        ntv_CreateSubDevices_2(in_device, properties[0], num_devices, out_devices, num_devices_ret) else
        ntv_CreateSubDevices_2(in_device, PClDevicePartitionProperty(nil)^, num_devices, out_devices, num_devices_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateSubDevices(in_device: cl_device_id; properties: array of clDevicePartitionProperty; num_devices: UInt32; out_devices: IntPtr; var num_devices_ret: UInt32): clErrorCode;
    type PClDevicePartitionProperty = ^clDevicePartitionProperty;
    begin
      Result := if (properties<>nil) and (properties.Length<>0) then
        ntv_CreateSubDevices_3(in_device, properties[0], num_devices, out_devices, num_devices_ret) else
        ntv_CreateSubDevices_3(in_device, PClDevicePartitionProperty(nil)^, num_devices, out_devices, num_devices_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateSubDevices(in_device: cl_device_id; properties: array of clDevicePartitionProperty; num_devices: UInt32; out_devices: IntPtr; num_devices_ret: IntPtr): clErrorCode;
    type PClDevicePartitionProperty = ^clDevicePartitionProperty;
    begin
      Result := if (properties<>nil) and (properties.Length<>0) then
        ntv_CreateSubDevices_4(in_device, properties[0], num_devices, out_devices, num_devices_ret) else
        ntv_CreateSubDevices_4(in_device, PClDevicePartitionProperty(nil)^, num_devices, out_devices, num_devices_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateSubDevices(in_device: cl_device_id; var properties: clDevicePartitionProperty; num_devices: UInt32; var out_devices: cl_device_id; var num_devices_ret: UInt32): clErrorCode :=
      ntv_CreateSubDevices_1(in_device, properties, num_devices, out_devices, num_devices_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateSubDevices(in_device: cl_device_id; var properties: clDevicePartitionProperty; num_devices: UInt32; var out_devices: cl_device_id; num_devices_ret: IntPtr): clErrorCode :=
      ntv_CreateSubDevices_2(in_device, properties, num_devices, out_devices, num_devices_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateSubDevices(in_device: cl_device_id; var properties: clDevicePartitionProperty; num_devices: UInt32; out_devices: IntPtr; var num_devices_ret: UInt32): clErrorCode :=
      ntv_CreateSubDevices_3(in_device, properties, num_devices, out_devices, num_devices_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateSubDevices(in_device: cl_device_id; var properties: clDevicePartitionProperty; num_devices: UInt32; out_devices: IntPtr; num_devices_ret: IntPtr): clErrorCode :=
      ntv_CreateSubDevices_4(in_device, properties, num_devices, out_devices, num_devices_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateSubDevices(in_device: cl_device_id; properties: IntPtr; num_devices: UInt32; var out_devices: cl_device_id; var num_devices_ret: UInt32): clErrorCode :=
      ntv_CreateSubDevices_5(in_device, properties, num_devices, out_devices, num_devices_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateSubDevices(in_device: cl_device_id; properties: IntPtr; num_devices: UInt32; var out_devices: cl_device_id; num_devices_ret: IntPtr): clErrorCode :=
      ntv_CreateSubDevices_6(in_device, properties, num_devices, out_devices, num_devices_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateSubDevices(in_device: cl_device_id; properties: IntPtr; num_devices: UInt32; out_devices: IntPtr; var num_devices_ret: UInt32): clErrorCode :=
      ntv_CreateSubDevices_7(in_device, properties, num_devices, out_devices, num_devices_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateSubDevices(in_device: cl_device_id; properties: IntPtr; num_devices: UInt32; out_devices: IntPtr; num_devices_ret: IntPtr): clErrorCode :=
      ntv_CreateSubDevices_8(in_device, properties, num_devices, out_devices, num_devices_ret);
    
    // added in cl1.1
    private static function ntv_CreateUserEvent_1(context: cl_context; var errcode_ret: clErrorCode): cl_event;
    external 'OpenCL' name 'clCreateUserEvent';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function CreateUserEvent(context: cl_context; var errcode_ret: clErrorCode): cl_event :=
      ntv_CreateUserEvent_1(context, errcode_ret);
    
    // added in cl1.0
    private static function ntv_EnqueueBarrier_1(command_queue: cl_command_queue): clErrorCode;
    external 'OpenCL' name 'clEnqueueBarrier';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueBarrier(command_queue: cl_command_queue): clErrorCode :=
      ntv_EnqueueBarrier_1(command_queue);
    
    // added in cl1.2
    private static function ntv_EnqueueBarrierWithWaitList_1(command_queue: cl_command_queue; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueBarrierWithWaitList';
    private static function ntv_EnqueueBarrierWithWaitList_2(command_queue: cl_command_queue; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueBarrierWithWaitList';
    private static function ntv_EnqueueBarrierWithWaitList_3(command_queue: cl_command_queue; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueBarrierWithWaitList';
    private static function ntv_EnqueueBarrierWithWaitList_4(command_queue: cl_command_queue; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueBarrierWithWaitList';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueBarrierWithWaitList(command_queue: cl_command_queue; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueBarrierWithWaitList_1(command_queue, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueBarrierWithWaitList_1(command_queue, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueBarrierWithWaitList(command_queue: cl_command_queue; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueBarrierWithWaitList_2(command_queue, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueBarrierWithWaitList_2(command_queue, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueBarrierWithWaitList(command_queue: cl_command_queue; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueBarrierWithWaitList_1(command_queue, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueBarrierWithWaitList(command_queue: cl_command_queue; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueBarrierWithWaitList_2(command_queue, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueBarrierWithWaitList(command_queue: cl_command_queue; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueBarrierWithWaitList_3(command_queue, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueBarrierWithWaitList(command_queue: cl_command_queue; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueBarrierWithWaitList_4(command_queue, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.0
    private static function ntv_EnqueueCopyBuffer_1(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_offset: UIntPtr; dst_offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueCopyBuffer';
    private static function ntv_EnqueueCopyBuffer_2(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_offset: UIntPtr; dst_offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueCopyBuffer';
    private static function ntv_EnqueueCopyBuffer_3(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_offset: UIntPtr; dst_offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueCopyBuffer';
    private static function ntv_EnqueueCopyBuffer_4(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_offset: UIntPtr; dst_offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueCopyBuffer';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBuffer(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_offset: UIntPtr; dst_offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueCopyBuffer_1(command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueCopyBuffer_1(command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBuffer(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_offset: UIntPtr; dst_offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueCopyBuffer_2(command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueCopyBuffer_2(command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBuffer(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_offset: UIntPtr; dst_offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueCopyBuffer_1(command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBuffer(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_offset: UIntPtr; dst_offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueCopyBuffer_2(command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBuffer(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_offset: UIntPtr; dst_offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueCopyBuffer_3(command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBuffer(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_offset: UIntPtr; dst_offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueCopyBuffer_4(command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.1
    private static function ntv_EnqueueCopyBufferRect_1(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueCopyBufferRect';
    private static function ntv_EnqueueCopyBufferRect_2(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueCopyBufferRect';
    private static function ntv_EnqueueCopyBufferRect_3(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueCopyBufferRect';
    private static function ntv_EnqueueCopyBufferRect_4(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueCopyBufferRect';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferRect(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_origin: array of UIntPtr; dst_origin: array of UIntPtr; region: array of UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueCopyBufferRect(command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueCopyBufferRect(command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferRect(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_origin: array of UIntPtr; dst_origin: array of UIntPtr; region: array of UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueCopyBufferRect(command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueCopyBufferRect(command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferRect(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_origin: array of UIntPtr; dst_origin: array of UIntPtr; region: array of UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    type PUIntPtr = ^UIntPtr;
    begin
      Result := if (region<>nil) and (region.Length<>0) then
        if (dst_origin<>nil) and (dst_origin.Length<>0) then
          if (src_origin<>nil) and (src_origin.Length<>0) then
            ntv_EnqueueCopyBufferRect_1(command_queue, src_buffer, dst_buffer, src_origin[0], dst_origin[0], region[0], src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyBufferRect_1(command_queue, src_buffer, dst_buffer, PUIntPtr(nil)^, dst_origin[0], region[0], src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
          if (src_origin<>nil) and (src_origin.Length<>0) then
            ntv_EnqueueCopyBufferRect_1(command_queue, src_buffer, dst_buffer, src_origin[0], PUIntPtr(nil)^, region[0], src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyBufferRect_1(command_queue, src_buffer, dst_buffer, PUIntPtr(nil)^, PUIntPtr(nil)^, region[0], src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
        if (dst_origin<>nil) and (dst_origin.Length<>0) then
          if (src_origin<>nil) and (src_origin.Length<>0) then
            ntv_EnqueueCopyBufferRect_1(command_queue, src_buffer, dst_buffer, src_origin[0], dst_origin[0], PUIntPtr(nil)^, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyBufferRect_1(command_queue, src_buffer, dst_buffer, PUIntPtr(nil)^, dst_origin[0], PUIntPtr(nil)^, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
          if (src_origin<>nil) and (src_origin.Length<>0) then
            ntv_EnqueueCopyBufferRect_1(command_queue, src_buffer, dst_buffer, src_origin[0], PUIntPtr(nil)^, PUIntPtr(nil)^, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyBufferRect_1(command_queue, src_buffer, dst_buffer, PUIntPtr(nil)^, PUIntPtr(nil)^, PUIntPtr(nil)^, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferRect(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_origin: array of UIntPtr; dst_origin: array of UIntPtr; region: array of UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    type PUIntPtr = ^UIntPtr;
    begin
      Result := if (region<>nil) and (region.Length<>0) then
        if (dst_origin<>nil) and (dst_origin.Length<>0) then
          if (src_origin<>nil) and (src_origin.Length<>0) then
            ntv_EnqueueCopyBufferRect_2(command_queue, src_buffer, dst_buffer, src_origin[0], dst_origin[0], region[0], src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyBufferRect_2(command_queue, src_buffer, dst_buffer, PUIntPtr(nil)^, dst_origin[0], region[0], src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
          if (src_origin<>nil) and (src_origin.Length<>0) then
            ntv_EnqueueCopyBufferRect_2(command_queue, src_buffer, dst_buffer, src_origin[0], PUIntPtr(nil)^, region[0], src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyBufferRect_2(command_queue, src_buffer, dst_buffer, PUIntPtr(nil)^, PUIntPtr(nil)^, region[0], src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
        if (dst_origin<>nil) and (dst_origin.Length<>0) then
          if (src_origin<>nil) and (src_origin.Length<>0) then
            ntv_EnqueueCopyBufferRect_2(command_queue, src_buffer, dst_buffer, src_origin[0], dst_origin[0], PUIntPtr(nil)^, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyBufferRect_2(command_queue, src_buffer, dst_buffer, PUIntPtr(nil)^, dst_origin[0], PUIntPtr(nil)^, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
          if (src_origin<>nil) and (src_origin.Length<>0) then
            ntv_EnqueueCopyBufferRect_2(command_queue, src_buffer, dst_buffer, src_origin[0], PUIntPtr(nil)^, PUIntPtr(nil)^, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyBufferRect_2(command_queue, src_buffer, dst_buffer, PUIntPtr(nil)^, PUIntPtr(nil)^, PUIntPtr(nil)^, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferRect(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_origin: array of UIntPtr; dst_origin: array of UIntPtr; region: array of UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    type PUIntPtr = ^UIntPtr;
    begin
      Result := if (region<>nil) and (region.Length<>0) then
        if (dst_origin<>nil) and (dst_origin.Length<>0) then
          if (src_origin<>nil) and (src_origin.Length<>0) then
            ntv_EnqueueCopyBufferRect_3(command_queue, src_buffer, dst_buffer, src_origin[0], dst_origin[0], region[0], src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyBufferRect_3(command_queue, src_buffer, dst_buffer, PUIntPtr(nil)^, dst_origin[0], region[0], src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
          if (src_origin<>nil) and (src_origin.Length<>0) then
            ntv_EnqueueCopyBufferRect_3(command_queue, src_buffer, dst_buffer, src_origin[0], PUIntPtr(nil)^, region[0], src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyBufferRect_3(command_queue, src_buffer, dst_buffer, PUIntPtr(nil)^, PUIntPtr(nil)^, region[0], src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
        if (dst_origin<>nil) and (dst_origin.Length<>0) then
          if (src_origin<>nil) and (src_origin.Length<>0) then
            ntv_EnqueueCopyBufferRect_3(command_queue, src_buffer, dst_buffer, src_origin[0], dst_origin[0], PUIntPtr(nil)^, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyBufferRect_3(command_queue, src_buffer, dst_buffer, PUIntPtr(nil)^, dst_origin[0], PUIntPtr(nil)^, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
          if (src_origin<>nil) and (src_origin.Length<>0) then
            ntv_EnqueueCopyBufferRect_3(command_queue, src_buffer, dst_buffer, src_origin[0], PUIntPtr(nil)^, PUIntPtr(nil)^, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyBufferRect_3(command_queue, src_buffer, dst_buffer, PUIntPtr(nil)^, PUIntPtr(nil)^, PUIntPtr(nil)^, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferRect(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_origin: array of UIntPtr; dst_origin: array of UIntPtr; region: array of UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    type PUIntPtr = ^UIntPtr;
    begin
      Result := if (region<>nil) and (region.Length<>0) then
        if (dst_origin<>nil) and (dst_origin.Length<>0) then
          if (src_origin<>nil) and (src_origin.Length<>0) then
            ntv_EnqueueCopyBufferRect_4(command_queue, src_buffer, dst_buffer, src_origin[0], dst_origin[0], region[0], src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyBufferRect_4(command_queue, src_buffer, dst_buffer, PUIntPtr(nil)^, dst_origin[0], region[0], src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
          if (src_origin<>nil) and (src_origin.Length<>0) then
            ntv_EnqueueCopyBufferRect_4(command_queue, src_buffer, dst_buffer, src_origin[0], PUIntPtr(nil)^, region[0], src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyBufferRect_4(command_queue, src_buffer, dst_buffer, PUIntPtr(nil)^, PUIntPtr(nil)^, region[0], src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
        if (dst_origin<>nil) and (dst_origin.Length<>0) then
          if (src_origin<>nil) and (src_origin.Length<>0) then
            ntv_EnqueueCopyBufferRect_4(command_queue, src_buffer, dst_buffer, src_origin[0], dst_origin[0], PUIntPtr(nil)^, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyBufferRect_4(command_queue, src_buffer, dst_buffer, PUIntPtr(nil)^, dst_origin[0], PUIntPtr(nil)^, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
          if (src_origin<>nil) and (src_origin.Length<>0) then
            ntv_EnqueueCopyBufferRect_4(command_queue, src_buffer, dst_buffer, src_origin[0], PUIntPtr(nil)^, PUIntPtr(nil)^, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyBufferRect_4(command_queue, src_buffer, dst_buffer, PUIntPtr(nil)^, PUIntPtr(nil)^, PUIntPtr(nil)^, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferRect(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueCopyBufferRect_1(command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueCopyBufferRect_1(command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferRect(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueCopyBufferRect_2(command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueCopyBufferRect_2(command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferRect(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueCopyBufferRect_1(command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferRect(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueCopyBufferRect_2(command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferRect(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueCopyBufferRect_3(command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferRect(command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueCopyBufferRect_4(command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.0
    private static function ntv_EnqueueCopyBufferToImage_1(command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueCopyBufferToImage';
    private static function ntv_EnqueueCopyBufferToImage_2(command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueCopyBufferToImage';
    private static function ntv_EnqueueCopyBufferToImage_3(command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueCopyBufferToImage';
    private static function ntv_EnqueueCopyBufferToImage_4(command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueCopyBufferToImage';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferToImage(command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; dst_origin: array of UIntPtr; region: array of UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueCopyBufferToImage(command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueCopyBufferToImage(command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferToImage(command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; dst_origin: array of UIntPtr; region: array of UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueCopyBufferToImage(command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueCopyBufferToImage(command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferToImage(command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; dst_origin: array of UIntPtr; region: array of UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    type PUIntPtr = ^UIntPtr;
    begin
      Result := if (region<>nil) and (region.Length<>0) then
        if (dst_origin<>nil) and (dst_origin.Length<>0) then
          ntv_EnqueueCopyBufferToImage_1(command_queue, src_buffer, dst_image, src_offset, dst_origin[0], region[0], num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueCopyBufferToImage_1(command_queue, src_buffer, dst_image, src_offset, PUIntPtr(nil)^, region[0], num_events_in_wait_list, event_wait_list, &event) else
        if (dst_origin<>nil) and (dst_origin.Length<>0) then
          ntv_EnqueueCopyBufferToImage_1(command_queue, src_buffer, dst_image, src_offset, dst_origin[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueCopyBufferToImage_1(command_queue, src_buffer, dst_image, src_offset, PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferToImage(command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; dst_origin: array of UIntPtr; region: array of UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    type PUIntPtr = ^UIntPtr;
    begin
      Result := if (region<>nil) and (region.Length<>0) then
        if (dst_origin<>nil) and (dst_origin.Length<>0) then
          ntv_EnqueueCopyBufferToImage_2(command_queue, src_buffer, dst_image, src_offset, dst_origin[0], region[0], num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueCopyBufferToImage_2(command_queue, src_buffer, dst_image, src_offset, PUIntPtr(nil)^, region[0], num_events_in_wait_list, event_wait_list, &event) else
        if (dst_origin<>nil) and (dst_origin.Length<>0) then
          ntv_EnqueueCopyBufferToImage_2(command_queue, src_buffer, dst_image, src_offset, dst_origin[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueCopyBufferToImage_2(command_queue, src_buffer, dst_image, src_offset, PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferToImage(command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; dst_origin: array of UIntPtr; region: array of UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    type PUIntPtr = ^UIntPtr;
    begin
      Result := if (region<>nil) and (region.Length<>0) then
        if (dst_origin<>nil) and (dst_origin.Length<>0) then
          ntv_EnqueueCopyBufferToImage_3(command_queue, src_buffer, dst_image, src_offset, dst_origin[0], region[0], num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueCopyBufferToImage_3(command_queue, src_buffer, dst_image, src_offset, PUIntPtr(nil)^, region[0], num_events_in_wait_list, event_wait_list, &event) else
        if (dst_origin<>nil) and (dst_origin.Length<>0) then
          ntv_EnqueueCopyBufferToImage_3(command_queue, src_buffer, dst_image, src_offset, dst_origin[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueCopyBufferToImage_3(command_queue, src_buffer, dst_image, src_offset, PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferToImage(command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; dst_origin: array of UIntPtr; region: array of UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    type PUIntPtr = ^UIntPtr;
    begin
      Result := if (region<>nil) and (region.Length<>0) then
        if (dst_origin<>nil) and (dst_origin.Length<>0) then
          ntv_EnqueueCopyBufferToImage_4(command_queue, src_buffer, dst_image, src_offset, dst_origin[0], region[0], num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueCopyBufferToImage_4(command_queue, src_buffer, dst_image, src_offset, PUIntPtr(nil)^, region[0], num_events_in_wait_list, event_wait_list, &event) else
        if (dst_origin<>nil) and (dst_origin.Length<>0) then
          ntv_EnqueueCopyBufferToImage_4(command_queue, src_buffer, dst_image, src_offset, dst_origin[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueCopyBufferToImage_4(command_queue, src_buffer, dst_image, src_offset, PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferToImage(command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueCopyBufferToImage_1(command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueCopyBufferToImage_1(command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferToImage(command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueCopyBufferToImage_2(command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueCopyBufferToImage_2(command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferToImage(command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueCopyBufferToImage_1(command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferToImage(command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueCopyBufferToImage_2(command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferToImage(command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueCopyBufferToImage_3(command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyBufferToImage(command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueCopyBufferToImage_4(command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.0
    private static function ntv_EnqueueCopyImage_1(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueCopyImage';
    private static function ntv_EnqueueCopyImage_2(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueCopyImage';
    private static function ntv_EnqueueCopyImage_3(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueCopyImage';
    private static function ntv_EnqueueCopyImage_4(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueCopyImage';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImage(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; src_origin: array of UIntPtr; dst_origin: array of UIntPtr; region: array of UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueCopyImage(command_queue, src_image, dst_image, src_origin, dst_origin, region, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueCopyImage(command_queue, src_image, dst_image, src_origin, dst_origin, region, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImage(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; src_origin: array of UIntPtr; dst_origin: array of UIntPtr; region: array of UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueCopyImage(command_queue, src_image, dst_image, src_origin, dst_origin, region, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueCopyImage(command_queue, src_image, dst_image, src_origin, dst_origin, region, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImage(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; src_origin: array of UIntPtr; dst_origin: array of UIntPtr; region: array of UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    type PUIntPtr = ^UIntPtr;
    begin
      Result := if (dst_origin<>nil) and (dst_origin.Length<>0) then
        if (src_origin<>nil) and (src_origin.Length<>0) then
          if (region<>nil) and (region.Length<>0) then
            ntv_EnqueueCopyImage_1(command_queue, src_image, dst_image, src_origin[0], dst_origin[0], region[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyImage_1(command_queue, src_image, dst_image, src_origin[0], dst_origin[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          if (region<>nil) and (region.Length<>0) then
            ntv_EnqueueCopyImage_1(command_queue, src_image, dst_image, PUIntPtr(nil)^, dst_origin[0], region[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyImage_1(command_queue, src_image, dst_image, PUIntPtr(nil)^, dst_origin[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
        if (src_origin<>nil) and (src_origin.Length<>0) then
          if (region<>nil) and (region.Length<>0) then
            ntv_EnqueueCopyImage_1(command_queue, src_image, dst_image, src_origin[0], PUIntPtr(nil)^, region[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyImage_1(command_queue, src_image, dst_image, src_origin[0], PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          if (region<>nil) and (region.Length<>0) then
            ntv_EnqueueCopyImage_1(command_queue, src_image, dst_image, PUIntPtr(nil)^, PUIntPtr(nil)^, region[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyImage_1(command_queue, src_image, dst_image, PUIntPtr(nil)^, PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImage(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; src_origin: array of UIntPtr; dst_origin: array of UIntPtr; region: array of UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    type PUIntPtr = ^UIntPtr;
    begin
      Result := if (dst_origin<>nil) and (dst_origin.Length<>0) then
        if (src_origin<>nil) and (src_origin.Length<>0) then
          if (region<>nil) and (region.Length<>0) then
            ntv_EnqueueCopyImage_2(command_queue, src_image, dst_image, src_origin[0], dst_origin[0], region[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyImage_2(command_queue, src_image, dst_image, src_origin[0], dst_origin[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          if (region<>nil) and (region.Length<>0) then
            ntv_EnqueueCopyImage_2(command_queue, src_image, dst_image, PUIntPtr(nil)^, dst_origin[0], region[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyImage_2(command_queue, src_image, dst_image, PUIntPtr(nil)^, dst_origin[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
        if (src_origin<>nil) and (src_origin.Length<>0) then
          if (region<>nil) and (region.Length<>0) then
            ntv_EnqueueCopyImage_2(command_queue, src_image, dst_image, src_origin[0], PUIntPtr(nil)^, region[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyImage_2(command_queue, src_image, dst_image, src_origin[0], PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          if (region<>nil) and (region.Length<>0) then
            ntv_EnqueueCopyImage_2(command_queue, src_image, dst_image, PUIntPtr(nil)^, PUIntPtr(nil)^, region[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyImage_2(command_queue, src_image, dst_image, PUIntPtr(nil)^, PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImage(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; src_origin: array of UIntPtr; dst_origin: array of UIntPtr; region: array of UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    type PUIntPtr = ^UIntPtr;
    begin
      Result := if (dst_origin<>nil) and (dst_origin.Length<>0) then
        if (src_origin<>nil) and (src_origin.Length<>0) then
          if (region<>nil) and (region.Length<>0) then
            ntv_EnqueueCopyImage_3(command_queue, src_image, dst_image, src_origin[0], dst_origin[0], region[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyImage_3(command_queue, src_image, dst_image, src_origin[0], dst_origin[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          if (region<>nil) and (region.Length<>0) then
            ntv_EnqueueCopyImage_3(command_queue, src_image, dst_image, PUIntPtr(nil)^, dst_origin[0], region[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyImage_3(command_queue, src_image, dst_image, PUIntPtr(nil)^, dst_origin[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
        if (src_origin<>nil) and (src_origin.Length<>0) then
          if (region<>nil) and (region.Length<>0) then
            ntv_EnqueueCopyImage_3(command_queue, src_image, dst_image, src_origin[0], PUIntPtr(nil)^, region[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyImage_3(command_queue, src_image, dst_image, src_origin[0], PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          if (region<>nil) and (region.Length<>0) then
            ntv_EnqueueCopyImage_3(command_queue, src_image, dst_image, PUIntPtr(nil)^, PUIntPtr(nil)^, region[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyImage_3(command_queue, src_image, dst_image, PUIntPtr(nil)^, PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImage(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; src_origin: array of UIntPtr; dst_origin: array of UIntPtr; region: array of UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    type PUIntPtr = ^UIntPtr;
    begin
      Result := if (dst_origin<>nil) and (dst_origin.Length<>0) then
        if (src_origin<>nil) and (src_origin.Length<>0) then
          if (region<>nil) and (region.Length<>0) then
            ntv_EnqueueCopyImage_4(command_queue, src_image, dst_image, src_origin[0], dst_origin[0], region[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyImage_4(command_queue, src_image, dst_image, src_origin[0], dst_origin[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          if (region<>nil) and (region.Length<>0) then
            ntv_EnqueueCopyImage_4(command_queue, src_image, dst_image, PUIntPtr(nil)^, dst_origin[0], region[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyImage_4(command_queue, src_image, dst_image, PUIntPtr(nil)^, dst_origin[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
        if (src_origin<>nil) and (src_origin.Length<>0) then
          if (region<>nil) and (region.Length<>0) then
            ntv_EnqueueCopyImage_4(command_queue, src_image, dst_image, src_origin[0], PUIntPtr(nil)^, region[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyImage_4(command_queue, src_image, dst_image, src_origin[0], PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          if (region<>nil) and (region.Length<>0) then
            ntv_EnqueueCopyImage_4(command_queue, src_image, dst_image, PUIntPtr(nil)^, PUIntPtr(nil)^, region[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueCopyImage_4(command_queue, src_image, dst_image, PUIntPtr(nil)^, PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImage(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueCopyImage_1(command_queue, src_image, dst_image, src_origin, dst_origin, region, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueCopyImage_1(command_queue, src_image, dst_image, src_origin, dst_origin, region, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImage(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueCopyImage_2(command_queue, src_image, dst_image, src_origin, dst_origin, region, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueCopyImage_2(command_queue, src_image, dst_image, src_origin, dst_origin, region, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImage(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueCopyImage_1(command_queue, src_image, dst_image, src_origin, dst_origin, region, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImage(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueCopyImage_2(command_queue, src_image, dst_image, src_origin, dst_origin, region, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImage(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueCopyImage_3(command_queue, src_image, dst_image, src_origin, dst_origin, region, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImage(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueCopyImage_4(command_queue, src_image, dst_image, src_origin, dst_origin, region, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.0
    private static function ntv_EnqueueCopyImageToBuffer_1(command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var region: UIntPtr; dst_offset: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueCopyImageToBuffer';
    private static function ntv_EnqueueCopyImageToBuffer_2(command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var region: UIntPtr; dst_offset: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueCopyImageToBuffer';
    private static function ntv_EnqueueCopyImageToBuffer_3(command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var region: UIntPtr; dst_offset: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueCopyImageToBuffer';
    private static function ntv_EnqueueCopyImageToBuffer_4(command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var region: UIntPtr; dst_offset: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueCopyImageToBuffer';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImageToBuffer(command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; src_origin: array of UIntPtr; region: array of UIntPtr; dst_offset: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueCopyImageToBuffer(command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueCopyImageToBuffer(command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImageToBuffer(command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; src_origin: array of UIntPtr; region: array of UIntPtr; dst_offset: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueCopyImageToBuffer(command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueCopyImageToBuffer(command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImageToBuffer(command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; src_origin: array of UIntPtr; region: array of UIntPtr; dst_offset: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    type PUIntPtr = ^UIntPtr;
    begin
      Result := if (region<>nil) and (region.Length<>0) then
        if (src_origin<>nil) and (src_origin.Length<>0) then
          ntv_EnqueueCopyImageToBuffer_1(command_queue, src_image, dst_buffer, src_origin[0], region[0], dst_offset, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueCopyImageToBuffer_1(command_queue, src_image, dst_buffer, PUIntPtr(nil)^, region[0], dst_offset, num_events_in_wait_list, event_wait_list, &event) else
        if (src_origin<>nil) and (src_origin.Length<>0) then
          ntv_EnqueueCopyImageToBuffer_1(command_queue, src_image, dst_buffer, src_origin[0], PUIntPtr(nil)^, dst_offset, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueCopyImageToBuffer_1(command_queue, src_image, dst_buffer, PUIntPtr(nil)^, PUIntPtr(nil)^, dst_offset, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImageToBuffer(command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; src_origin: array of UIntPtr; region: array of UIntPtr; dst_offset: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    type PUIntPtr = ^UIntPtr;
    begin
      Result := if (region<>nil) and (region.Length<>0) then
        if (src_origin<>nil) and (src_origin.Length<>0) then
          ntv_EnqueueCopyImageToBuffer_2(command_queue, src_image, dst_buffer, src_origin[0], region[0], dst_offset, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueCopyImageToBuffer_2(command_queue, src_image, dst_buffer, PUIntPtr(nil)^, region[0], dst_offset, num_events_in_wait_list, event_wait_list, &event) else
        if (src_origin<>nil) and (src_origin.Length<>0) then
          ntv_EnqueueCopyImageToBuffer_2(command_queue, src_image, dst_buffer, src_origin[0], PUIntPtr(nil)^, dst_offset, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueCopyImageToBuffer_2(command_queue, src_image, dst_buffer, PUIntPtr(nil)^, PUIntPtr(nil)^, dst_offset, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImageToBuffer(command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; src_origin: array of UIntPtr; region: array of UIntPtr; dst_offset: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    type PUIntPtr = ^UIntPtr;
    begin
      Result := if (region<>nil) and (region.Length<>0) then
        if (src_origin<>nil) and (src_origin.Length<>0) then
          ntv_EnqueueCopyImageToBuffer_3(command_queue, src_image, dst_buffer, src_origin[0], region[0], dst_offset, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueCopyImageToBuffer_3(command_queue, src_image, dst_buffer, PUIntPtr(nil)^, region[0], dst_offset, num_events_in_wait_list, event_wait_list, &event) else
        if (src_origin<>nil) and (src_origin.Length<>0) then
          ntv_EnqueueCopyImageToBuffer_3(command_queue, src_image, dst_buffer, src_origin[0], PUIntPtr(nil)^, dst_offset, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueCopyImageToBuffer_3(command_queue, src_image, dst_buffer, PUIntPtr(nil)^, PUIntPtr(nil)^, dst_offset, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImageToBuffer(command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; src_origin: array of UIntPtr; region: array of UIntPtr; dst_offset: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    type PUIntPtr = ^UIntPtr;
    begin
      Result := if (region<>nil) and (region.Length<>0) then
        if (src_origin<>nil) and (src_origin.Length<>0) then
          ntv_EnqueueCopyImageToBuffer_4(command_queue, src_image, dst_buffer, src_origin[0], region[0], dst_offset, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueCopyImageToBuffer_4(command_queue, src_image, dst_buffer, PUIntPtr(nil)^, region[0], dst_offset, num_events_in_wait_list, event_wait_list, &event) else
        if (src_origin<>nil) and (src_origin.Length<>0) then
          ntv_EnqueueCopyImageToBuffer_4(command_queue, src_image, dst_buffer, src_origin[0], PUIntPtr(nil)^, dst_offset, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueCopyImageToBuffer_4(command_queue, src_image, dst_buffer, PUIntPtr(nil)^, PUIntPtr(nil)^, dst_offset, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImageToBuffer(command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var region: UIntPtr; dst_offset: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueCopyImageToBuffer_1(command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueCopyImageToBuffer_1(command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImageToBuffer(command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var region: UIntPtr; dst_offset: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueCopyImageToBuffer_2(command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueCopyImageToBuffer_2(command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImageToBuffer(command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var region: UIntPtr; dst_offset: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueCopyImageToBuffer_1(command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImageToBuffer(command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var region: UIntPtr; dst_offset: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueCopyImageToBuffer_2(command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImageToBuffer(command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var region: UIntPtr; dst_offset: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueCopyImageToBuffer_3(command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueCopyImageToBuffer(command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var region: UIntPtr; dst_offset: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueCopyImageToBuffer_4(command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.2
    private static function ntv_EnqueueFillBuffer_1(command_queue: cl_command_queue; buffer: cl_mem; var pattern: Byte; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueFillBuffer';
    private static function ntv_EnqueueFillBuffer_2(command_queue: cl_command_queue; buffer: cl_mem; var pattern: Byte; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueFillBuffer';
    private static function ntv_EnqueueFillBuffer_3(command_queue: cl_command_queue; buffer: cl_mem; var pattern: Byte; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueFillBuffer';
    private static function ntv_EnqueueFillBuffer_4(command_queue: cl_command_queue; buffer: cl_mem; var pattern: Byte; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueFillBuffer';
    private static function ntv_EnqueueFillBuffer_5(command_queue: cl_command_queue; buffer: cl_mem; pattern: pointer; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueFillBuffer';
    private static function ntv_EnqueueFillBuffer_6(command_queue: cl_command_queue; buffer: cl_mem; pattern: pointer; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueFillBuffer';
    private static function ntv_EnqueueFillBuffer_7(command_queue: cl_command_queue; buffer: cl_mem; pattern: pointer; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueFillBuffer';
    private static function ntv_EnqueueFillBuffer_8(command_queue: cl_command_queue; buffer: cl_mem; pattern: pointer; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueFillBuffer';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; pattern: array of T; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode; where T: record;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueFillBuffer(command_queue, buffer, pattern, pattern_size, offset, size, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueFillBuffer(command_queue, buffer, pattern, pattern_size, offset, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; pattern: array of T; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode; where T: record;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueFillBuffer(command_queue, buffer, pattern, pattern_size, offset, size, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueFillBuffer(command_queue, buffer, pattern, pattern_size, offset, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; pattern: array of T; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode; where T: record;
    type PT = ^T;
    begin
      Result := if (pattern<>nil) and (pattern.Length<>0) then
        EnqueueFillBuffer(command_queue, buffer, pattern[0], pattern_size, offset, size, num_events_in_wait_list, event_wait_list, &event) else
        EnqueueFillBuffer(command_queue, buffer, PT(nil)^, pattern_size, offset, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; pattern: array of T; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode; where T: record;
    type PT = ^T;
    begin
      Result := if (pattern<>nil) and (pattern.Length<>0) then
        EnqueueFillBuffer(command_queue, buffer, pattern[0], pattern_size, offset, size, num_events_in_wait_list, event_wait_list, &event) else
        EnqueueFillBuffer(command_queue, buffer, PT(nil)^, pattern_size, offset, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; pattern: array of T; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode; where T: record;
    type PT = ^T;
    begin
      Result := if (pattern<>nil) and (pattern.Length<>0) then
        EnqueueFillBuffer(command_queue, buffer, pattern[0], pattern_size, offset, size, num_events_in_wait_list, event_wait_list, &event) else
        EnqueueFillBuffer(command_queue, buffer, PT(nil)^, pattern_size, offset, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; pattern: array of T; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode; where T: record;
    type PT = ^T;
    begin
      Result := if (pattern<>nil) and (pattern.Length<>0) then
        EnqueueFillBuffer(command_queue, buffer, pattern[0], pattern_size, offset, size, num_events_in_wait_list, event_wait_list, &event) else
        EnqueueFillBuffer(command_queue, buffer, PT(nil)^, pattern_size, offset, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; var pattern: T; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode; where T: record;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueFillBuffer(command_queue, buffer, pattern, pattern_size, offset, size, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueFillBuffer(command_queue, buffer, pattern, pattern_size, offset, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; var pattern: T; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode; where T: record;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueFillBuffer(command_queue, buffer, pattern, pattern_size, offset, size, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueFillBuffer(command_queue, buffer, pattern, pattern_size, offset, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; var pattern: T; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueFillBuffer_1(command_queue, buffer, PByte(pointer(@pattern))^, pattern_size, offset, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; var pattern: T; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueFillBuffer_2(command_queue, buffer, PByte(pointer(@pattern))^, pattern_size, offset, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; var pattern: T; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueFillBuffer_3(command_queue, buffer, PByte(pointer(@pattern))^, pattern_size, offset, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; var pattern: T; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueFillBuffer_4(command_queue, buffer, PByte(pointer(@pattern))^, pattern_size, offset, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillBuffer(command_queue: cl_command_queue; buffer: cl_mem; pattern: pointer; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueFillBuffer_5(command_queue, buffer, pattern, pattern_size, offset, size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueFillBuffer_5(command_queue, buffer, pattern, pattern_size, offset, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillBuffer(command_queue: cl_command_queue; buffer: cl_mem; pattern: pointer; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueFillBuffer_6(command_queue, buffer, pattern, pattern_size, offset, size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueFillBuffer_6(command_queue, buffer, pattern, pattern_size, offset, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillBuffer(command_queue: cl_command_queue; buffer: cl_mem; pattern: pointer; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueFillBuffer_5(command_queue, buffer, pattern, pattern_size, offset, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillBuffer(command_queue: cl_command_queue; buffer: cl_mem; pattern: pointer; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueFillBuffer_6(command_queue, buffer, pattern, pattern_size, offset, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillBuffer(command_queue: cl_command_queue; buffer: cl_mem; pattern: pointer; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueFillBuffer_7(command_queue, buffer, pattern, pattern_size, offset, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillBuffer(command_queue: cl_command_queue; buffer: cl_mem; pattern: pointer; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueFillBuffer_8(command_queue, buffer, pattern, pattern_size, offset, size, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.2
    private static function ntv_EnqueueFillImage_1(command_queue: cl_command_queue; image: cl_mem; var fill_color: Byte; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueFillImage';
    private static function ntv_EnqueueFillImage_2(command_queue: cl_command_queue; image: cl_mem; var fill_color: Byte; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueFillImage';
    private static function ntv_EnqueueFillImage_3(command_queue: cl_command_queue; image: cl_mem; var fill_color: Byte; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueFillImage';
    private static function ntv_EnqueueFillImage_4(command_queue: cl_command_queue; image: cl_mem; var fill_color: Byte; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueFillImage';
    private static function ntv_EnqueueFillImage_5(command_queue: cl_command_queue; image: cl_mem; fill_color: pointer; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueFillImage';
    private static function ntv_EnqueueFillImage_6(command_queue: cl_command_queue; image: cl_mem; fill_color: pointer; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueFillImage';
    private static function ntv_EnqueueFillImage_7(command_queue: cl_command_queue; image: cl_mem; fill_color: pointer; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueFillImage';
    private static function ntv_EnqueueFillImage_8(command_queue: cl_command_queue; image: cl_mem; fill_color: pointer; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueFillImage';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillImage<T>(command_queue: cl_command_queue; image: cl_mem; var fill_color: T; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode; where T: record;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueFillImage(command_queue, image, fill_color, origin, region, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueFillImage(command_queue, image, fill_color, origin, region, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillImage<T>(command_queue: cl_command_queue; image: cl_mem; var fill_color: T; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode; where T: record;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueFillImage(command_queue, image, fill_color, origin, region, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueFillImage(command_queue, image, fill_color, origin, region, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillImage<T>(command_queue: cl_command_queue; image: cl_mem; var fill_color: T; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueFillImage_1(command_queue, image, PByte(pointer(@fill_color))^, origin, region, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillImage<T>(command_queue: cl_command_queue; image: cl_mem; var fill_color: T; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueFillImage_2(command_queue, image, PByte(pointer(@fill_color))^, origin, region, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillImage<T>(command_queue: cl_command_queue; image: cl_mem; var fill_color: T; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueFillImage_3(command_queue, image, PByte(pointer(@fill_color))^, origin, region, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillImage<T>(command_queue: cl_command_queue; image: cl_mem; var fill_color: T; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueFillImage_4(command_queue, image, PByte(pointer(@fill_color))^, origin, region, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillImage(command_queue: cl_command_queue; image: cl_mem; fill_color: pointer; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueFillImage_5(command_queue, image, fill_color, origin, region, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueFillImage_5(command_queue, image, fill_color, origin, region, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillImage(command_queue: cl_command_queue; image: cl_mem; fill_color: pointer; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueFillImage_6(command_queue, image, fill_color, origin, region, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueFillImage_6(command_queue, image, fill_color, origin, region, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillImage(command_queue: cl_command_queue; image: cl_mem; fill_color: pointer; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueFillImage_5(command_queue, image, fill_color, origin, region, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillImage(command_queue: cl_command_queue; image: cl_mem; fill_color: pointer; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueFillImage_6(command_queue, image, fill_color, origin, region, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillImage(command_queue: cl_command_queue; image: cl_mem; fill_color: pointer; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueFillImage_7(command_queue, image, fill_color, origin, region, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueFillImage(command_queue: cl_command_queue; image: cl_mem; fill_color: pointer; var origin: UIntPtr; var region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueFillImage_8(command_queue, image, fill_color, origin, region, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.0
    private static function ntv_EnqueueMapBuffer_1(command_queue: cl_command_queue; buffer: cl_mem; blocking_map: clBool; map_flags: clMapFlags; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event; var errcode_ret: clErrorCode): IntPtr;
    external 'OpenCL' name 'clEnqueueMapBuffer';
    private static function ntv_EnqueueMapBuffer_2(command_queue: cl_command_queue; buffer: cl_mem; blocking_map: clBool; map_flags: clMapFlags; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr; var errcode_ret: clErrorCode): IntPtr;
    external 'OpenCL' name 'clEnqueueMapBuffer';
    private static function ntv_EnqueueMapBuffer_3(command_queue: cl_command_queue; buffer: cl_mem; blocking_map: clBool; map_flags: clMapFlags; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event; var errcode_ret: clErrorCode): IntPtr;
    external 'OpenCL' name 'clEnqueueMapBuffer';
    private static function ntv_EnqueueMapBuffer_4(command_queue: cl_command_queue; buffer: cl_mem; blocking_map: clBool; map_flags: clMapFlags; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr; var errcode_ret: clErrorCode): IntPtr;
    external 'OpenCL' name 'clEnqueueMapBuffer';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapBuffer(command_queue: cl_command_queue; buffer: cl_mem; blocking_map: clBool; map_flags: clMapFlags; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event; var errcode_ret: clErrorCode): IntPtr;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueMapBuffer_1(command_queue, buffer, blocking_map, map_flags, offset, size, num_events_in_wait_list, event_wait_list[0], &event, errcode_ret) else
        ntv_EnqueueMapBuffer_1(command_queue, buffer, blocking_map, map_flags, offset, size, num_events_in_wait_list, PCl_event(nil)^, &event, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapBuffer(command_queue: cl_command_queue; buffer: cl_mem; blocking_map: clBool; map_flags: clMapFlags; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr; var errcode_ret: clErrorCode): IntPtr;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueMapBuffer_2(command_queue, buffer, blocking_map, map_flags, offset, size, num_events_in_wait_list, event_wait_list[0], &event, errcode_ret) else
        ntv_EnqueueMapBuffer_2(command_queue, buffer, blocking_map, map_flags, offset, size, num_events_in_wait_list, PCl_event(nil)^, &event, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapBuffer(command_queue: cl_command_queue; buffer: cl_mem; blocking_map: clBool; map_flags: clMapFlags; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event; var errcode_ret: clErrorCode): IntPtr :=
      ntv_EnqueueMapBuffer_1(command_queue, buffer, blocking_map, map_flags, offset, size, num_events_in_wait_list, event_wait_list, &event, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapBuffer(command_queue: cl_command_queue; buffer: cl_mem; blocking_map: clBool; map_flags: clMapFlags; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr; var errcode_ret: clErrorCode): IntPtr :=
      ntv_EnqueueMapBuffer_2(command_queue, buffer, blocking_map, map_flags, offset, size, num_events_in_wait_list, event_wait_list, &event, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapBuffer(command_queue: cl_command_queue; buffer: cl_mem; blocking_map: clBool; map_flags: clMapFlags; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event; var errcode_ret: clErrorCode): IntPtr :=
      ntv_EnqueueMapBuffer_3(command_queue, buffer, blocking_map, map_flags, offset, size, num_events_in_wait_list, event_wait_list, &event, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapBuffer(command_queue: cl_command_queue; buffer: cl_mem; blocking_map: clBool; map_flags: clMapFlags; offset: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr; var errcode_ret: clErrorCode): IntPtr :=
      ntv_EnqueueMapBuffer_4(command_queue, buffer, blocking_map, map_flags, offset, size, num_events_in_wait_list, event_wait_list, &event, errcode_ret);
    
    // added in cl1.0
    private static function ntv_EnqueueMapImage_1(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; var origin: UIntPtr; var region: UIntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event; var errcode_ret: clErrorCode): IntPtr;
    external 'OpenCL' name 'clEnqueueMapImage';
    private static function ntv_EnqueueMapImage_2(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; var origin: UIntPtr; var region: UIntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr; var errcode_ret: clErrorCode): IntPtr;
    external 'OpenCL' name 'clEnqueueMapImage';
    private static function ntv_EnqueueMapImage_3(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; var origin: UIntPtr; var region: UIntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event; var errcode_ret: clErrorCode): IntPtr;
    external 'OpenCL' name 'clEnqueueMapImage';
    private static function ntv_EnqueueMapImage_4(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; var origin: UIntPtr; var region: UIntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr; var errcode_ret: clErrorCode): IntPtr;
    external 'OpenCL' name 'clEnqueueMapImage';
    private static function ntv_EnqueueMapImage_5(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; origin: IntPtr; region: IntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event; var errcode_ret: clErrorCode): IntPtr;
    external 'OpenCL' name 'clEnqueueMapImage';
    private static function ntv_EnqueueMapImage_6(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; origin: IntPtr; region: IntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr; var errcode_ret: clErrorCode): IntPtr;
    external 'OpenCL' name 'clEnqueueMapImage';
    private static function ntv_EnqueueMapImage_7(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; origin: IntPtr; region: IntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event; var errcode_ret: clErrorCode): IntPtr;
    external 'OpenCL' name 'clEnqueueMapImage';
    private static function ntv_EnqueueMapImage_8(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; origin: IntPtr; region: IntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr; var errcode_ret: clErrorCode): IntPtr;
    external 'OpenCL' name 'clEnqueueMapImage';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapImage(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; origin: array of UIntPtr; region: array of UIntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event; var errcode_ret: clErrorCode): IntPtr;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueMapImage(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list[0], &event, errcode_ret) else
        EnqueueMapImage(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, PCl_event(nil)^, &event, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapImage(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; origin: array of UIntPtr; region: array of UIntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr; var errcode_ret: clErrorCode): IntPtr;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueMapImage(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list[0], &event, errcode_ret) else
        EnqueueMapImage(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, PCl_event(nil)^, &event, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapImage(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; origin: array of UIntPtr; region: array of UIntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event; var errcode_ret: clErrorCode): IntPtr;
    type PUIntPtr = ^UIntPtr;
    begin
      Result := if (region<>nil) and (region.Length<>0) then
        if (origin<>nil) and (origin.Length<>0) then
          ntv_EnqueueMapImage_1(command_queue, image, blocking_map, map_flags, origin[0], region[0], image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret) else
          ntv_EnqueueMapImage_1(command_queue, image, blocking_map, map_flags, PUIntPtr(nil)^, region[0], image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret) else
        if (origin<>nil) and (origin.Length<>0) then
          ntv_EnqueueMapImage_1(command_queue, image, blocking_map, map_flags, origin[0], PUIntPtr(nil)^, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret) else
          ntv_EnqueueMapImage_1(command_queue, image, blocking_map, map_flags, PUIntPtr(nil)^, PUIntPtr(nil)^, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapImage(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; origin: array of UIntPtr; region: array of UIntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr; var errcode_ret: clErrorCode): IntPtr;
    type PUIntPtr = ^UIntPtr;
    begin
      Result := if (region<>nil) and (region.Length<>0) then
        if (origin<>nil) and (origin.Length<>0) then
          ntv_EnqueueMapImage_2(command_queue, image, blocking_map, map_flags, origin[0], region[0], image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret) else
          ntv_EnqueueMapImage_2(command_queue, image, blocking_map, map_flags, PUIntPtr(nil)^, region[0], image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret) else
        if (origin<>nil) and (origin.Length<>0) then
          ntv_EnqueueMapImage_2(command_queue, image, blocking_map, map_flags, origin[0], PUIntPtr(nil)^, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret) else
          ntv_EnqueueMapImage_2(command_queue, image, blocking_map, map_flags, PUIntPtr(nil)^, PUIntPtr(nil)^, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapImage(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; origin: array of UIntPtr; region: array of UIntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event; var errcode_ret: clErrorCode): IntPtr;
    type PUIntPtr = ^UIntPtr;
    begin
      Result := if (region<>nil) and (region.Length<>0) then
        if (origin<>nil) and (origin.Length<>0) then
          ntv_EnqueueMapImage_3(command_queue, image, blocking_map, map_flags, origin[0], region[0], image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret) else
          ntv_EnqueueMapImage_3(command_queue, image, blocking_map, map_flags, PUIntPtr(nil)^, region[0], image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret) else
        if (origin<>nil) and (origin.Length<>0) then
          ntv_EnqueueMapImage_3(command_queue, image, blocking_map, map_flags, origin[0], PUIntPtr(nil)^, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret) else
          ntv_EnqueueMapImage_3(command_queue, image, blocking_map, map_flags, PUIntPtr(nil)^, PUIntPtr(nil)^, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapImage(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; origin: array of UIntPtr; region: array of UIntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr; var errcode_ret: clErrorCode): IntPtr;
    type PUIntPtr = ^UIntPtr;
    begin
      Result := if (region<>nil) and (region.Length<>0) then
        if (origin<>nil) and (origin.Length<>0) then
          ntv_EnqueueMapImage_4(command_queue, image, blocking_map, map_flags, origin[0], region[0], image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret) else
          ntv_EnqueueMapImage_4(command_queue, image, blocking_map, map_flags, PUIntPtr(nil)^, region[0], image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret) else
        if (origin<>nil) and (origin.Length<>0) then
          ntv_EnqueueMapImage_4(command_queue, image, blocking_map, map_flags, origin[0], PUIntPtr(nil)^, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret) else
          ntv_EnqueueMapImage_4(command_queue, image, blocking_map, map_flags, PUIntPtr(nil)^, PUIntPtr(nil)^, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapImage(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; var origin: UIntPtr; var region: UIntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event; var errcode_ret: clErrorCode): IntPtr;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueMapImage_1(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list[0], &event, errcode_ret) else
        ntv_EnqueueMapImage_1(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, PCl_event(nil)^, &event, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapImage(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; var origin: UIntPtr; var region: UIntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr; var errcode_ret: clErrorCode): IntPtr;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueMapImage_2(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list[0], &event, errcode_ret) else
        ntv_EnqueueMapImage_2(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, PCl_event(nil)^, &event, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapImage(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; var origin: UIntPtr; var region: UIntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event; var errcode_ret: clErrorCode): IntPtr :=
      ntv_EnqueueMapImage_1(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapImage(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; var origin: UIntPtr; var region: UIntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr; var errcode_ret: clErrorCode): IntPtr :=
      ntv_EnqueueMapImage_2(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapImage(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; var origin: UIntPtr; var region: UIntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event; var errcode_ret: clErrorCode): IntPtr :=
      ntv_EnqueueMapImage_3(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapImage(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; var origin: UIntPtr; var region: UIntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr; var errcode_ret: clErrorCode): IntPtr :=
      ntv_EnqueueMapImage_4(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapImage(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; origin: IntPtr; region: IntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event; var errcode_ret: clErrorCode): IntPtr;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueMapImage_5(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list[0], &event, errcode_ret) else
        ntv_EnqueueMapImage_5(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, PCl_event(nil)^, &event, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapImage(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; origin: IntPtr; region: IntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr; var errcode_ret: clErrorCode): IntPtr;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueMapImage_6(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list[0], &event, errcode_ret) else
        ntv_EnqueueMapImage_6(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, PCl_event(nil)^, &event, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapImage(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; origin: IntPtr; region: IntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event; var errcode_ret: clErrorCode): IntPtr :=
      ntv_EnqueueMapImage_5(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapImage(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; origin: IntPtr; region: IntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr; var errcode_ret: clErrorCode): IntPtr :=
      ntv_EnqueueMapImage_6(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapImage(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; origin: IntPtr; region: IntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event; var errcode_ret: clErrorCode): IntPtr :=
      ntv_EnqueueMapImage_7(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMapImage(command_queue: cl_command_queue; image: cl_mem; blocking_map: clBool; map_flags: clMapFlags; origin: IntPtr; region: IntPtr; var image_row_pitch: UIntPtr; var image_slice_pitch: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr; var errcode_ret: clErrorCode): IntPtr :=
      ntv_EnqueueMapImage_8(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, &event, errcode_ret);
    
    // added in cl1.0
    private static function ntv_EnqueueMarker_1(command_queue: cl_command_queue; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueMarker';
    private static function ntv_EnqueueMarker_2(command_queue: cl_command_queue; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueMarker';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMarker(command_queue: cl_command_queue; &event: array of cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (&event<>nil) and (&event.Length<>0) then
        ntv_EnqueueMarker_1(command_queue, &event[0]) else
        ntv_EnqueueMarker_1(command_queue, PCl_event(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMarker(command_queue: cl_command_queue; var &event: cl_event): clErrorCode :=
      ntv_EnqueueMarker_1(command_queue, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMarker(command_queue: cl_command_queue; &event: IntPtr): clErrorCode :=
      ntv_EnqueueMarker_2(command_queue, &event);
    
    // added in cl1.2
    private static function ntv_EnqueueMarkerWithWaitList_1(command_queue: cl_command_queue; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueMarkerWithWaitList';
    private static function ntv_EnqueueMarkerWithWaitList_2(command_queue: cl_command_queue; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueMarkerWithWaitList';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMarkerWithWaitList(command_queue: cl_command_queue; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueMarkerWithWaitList_1(command_queue, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueMarkerWithWaitList_1(command_queue, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMarkerWithWaitList(command_queue: cl_command_queue; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueMarkerWithWaitList_1(command_queue, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMarkerWithWaitList(command_queue: cl_command_queue; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueMarkerWithWaitList_2(command_queue, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.2
    private static function ntv_EnqueueMigrateMemObjects_1(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueMigrateMemObjects';
    private static function ntv_EnqueueMigrateMemObjects_2(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueMigrateMemObjects';
    private static function ntv_EnqueueMigrateMemObjects_3(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueMigrateMemObjects';
    private static function ntv_EnqueueMigrateMemObjects_4(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueMigrateMemObjects';
    private static function ntv_EnqueueMigrateMemObjects_5(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueMigrateMemObjects';
    private static function ntv_EnqueueMigrateMemObjects_6(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueMigrateMemObjects';
    private static function ntv_EnqueueMigrateMemObjects_7(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueMigrateMemObjects';
    private static function ntv_EnqueueMigrateMemObjects_8(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueMigrateMemObjects';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMigrateMemObjects(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: array of cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueMigrateMemObjects(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueMigrateMemObjects(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMigrateMemObjects(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: array of cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueMigrateMemObjects(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueMigrateMemObjects(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMigrateMemObjects(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: array of cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueMigrateMemObjects_1(command_queue, num_mem_objects, mem_objects[0], flags, num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueMigrateMemObjects_1(command_queue, num_mem_objects, PCl_mem(nil)^, flags, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMigrateMemObjects(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: array of cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueMigrateMemObjects_2(command_queue, num_mem_objects, mem_objects[0], flags, num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueMigrateMemObjects_2(command_queue, num_mem_objects, PCl_mem(nil)^, flags, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMigrateMemObjects(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: array of cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueMigrateMemObjects_3(command_queue, num_mem_objects, mem_objects[0], flags, num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueMigrateMemObjects_3(command_queue, num_mem_objects, PCl_mem(nil)^, flags, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMigrateMemObjects(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: array of cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueMigrateMemObjects_4(command_queue, num_mem_objects, mem_objects[0], flags, num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueMigrateMemObjects_4(command_queue, num_mem_objects, PCl_mem(nil)^, flags, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMigrateMemObjects(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueMigrateMemObjects_1(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueMigrateMemObjects_1(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMigrateMemObjects(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueMigrateMemObjects_2(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueMigrateMemObjects_2(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMigrateMemObjects(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueMigrateMemObjects_1(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMigrateMemObjects(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueMigrateMemObjects_2(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMigrateMemObjects(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueMigrateMemObjects_3(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMigrateMemObjects(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueMigrateMemObjects_4(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMigrateMemObjects(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueMigrateMemObjects_5(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueMigrateMemObjects_5(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMigrateMemObjects(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueMigrateMemObjects_6(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueMigrateMemObjects_6(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMigrateMemObjects(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueMigrateMemObjects_5(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMigrateMemObjects(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueMigrateMemObjects_6(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMigrateMemObjects(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueMigrateMemObjects_7(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueMigrateMemObjects(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueMigrateMemObjects_8(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.0
    private static function ntv_EnqueueNativeKernel_1(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; var mem_list: cl_mem; var args_mem_loc: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueNativeKernel';
    private static function ntv_EnqueueNativeKernel_2(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; var mem_list: cl_mem; var args_mem_loc: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueNativeKernel';
    private static function ntv_EnqueueNativeKernel_3(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; var mem_list: cl_mem; var args_mem_loc: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueNativeKernel';
    private static function ntv_EnqueueNativeKernel_4(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; var mem_list: cl_mem; var args_mem_loc: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueNativeKernel';
    private static function ntv_EnqueueNativeKernel_5(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; mem_list: IntPtr; args_mem_loc: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueNativeKernel';
    private static function ntv_EnqueueNativeKernel_6(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; mem_list: IntPtr; args_mem_loc: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueNativeKernel';
    private static function ntv_EnqueueNativeKernel_7(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; mem_list: IntPtr; args_mem_loc: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueNativeKernel';
    private static function ntv_EnqueueNativeKernel_8(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; mem_list: IntPtr; args_mem_loc: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueNativeKernel';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNativeKernel(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; mem_list: array of cl_mem; args_mem_loc: array of IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueNativeKernel(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueNativeKernel(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNativeKernel(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; mem_list: array of cl_mem; args_mem_loc: array of IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueNativeKernel(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueNativeKernel(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNativeKernel(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; mem_list: array of cl_mem; args_mem_loc: array of IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    type PIntPtr = ^IntPtr;
    begin
      Result := if (args_mem_loc<>nil) and (args_mem_loc.Length<>0) then
        if (mem_list<>nil) and (mem_list.Length<>0) then
          ntv_EnqueueNativeKernel_1(command_queue, user_func, args, cb_args, num_mem_objects, mem_list[0], args_mem_loc[0], num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueNativeKernel_1(command_queue, user_func, args, cb_args, num_mem_objects, PCl_mem(nil)^, args_mem_loc[0], num_events_in_wait_list, event_wait_list, &event) else
        if (mem_list<>nil) and (mem_list.Length<>0) then
          ntv_EnqueueNativeKernel_1(command_queue, user_func, args, cb_args, num_mem_objects, mem_list[0], PIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueNativeKernel_1(command_queue, user_func, args, cb_args, num_mem_objects, PCl_mem(nil)^, PIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNativeKernel(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; mem_list: array of cl_mem; args_mem_loc: array of IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    type PIntPtr = ^IntPtr;
    begin
      Result := if (args_mem_loc<>nil) and (args_mem_loc.Length<>0) then
        if (mem_list<>nil) and (mem_list.Length<>0) then
          ntv_EnqueueNativeKernel_2(command_queue, user_func, args, cb_args, num_mem_objects, mem_list[0], args_mem_loc[0], num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueNativeKernel_2(command_queue, user_func, args, cb_args, num_mem_objects, PCl_mem(nil)^, args_mem_loc[0], num_events_in_wait_list, event_wait_list, &event) else
        if (mem_list<>nil) and (mem_list.Length<>0) then
          ntv_EnqueueNativeKernel_2(command_queue, user_func, args, cb_args, num_mem_objects, mem_list[0], PIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueNativeKernel_2(command_queue, user_func, args, cb_args, num_mem_objects, PCl_mem(nil)^, PIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNativeKernel(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; mem_list: array of cl_mem; args_mem_loc: array of IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    type PIntPtr = ^IntPtr;
    begin
      Result := if (args_mem_loc<>nil) and (args_mem_loc.Length<>0) then
        if (mem_list<>nil) and (mem_list.Length<>0) then
          ntv_EnqueueNativeKernel_3(command_queue, user_func, args, cb_args, num_mem_objects, mem_list[0], args_mem_loc[0], num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueNativeKernel_3(command_queue, user_func, args, cb_args, num_mem_objects, PCl_mem(nil)^, args_mem_loc[0], num_events_in_wait_list, event_wait_list, &event) else
        if (mem_list<>nil) and (mem_list.Length<>0) then
          ntv_EnqueueNativeKernel_3(command_queue, user_func, args, cb_args, num_mem_objects, mem_list[0], PIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueNativeKernel_3(command_queue, user_func, args, cb_args, num_mem_objects, PCl_mem(nil)^, PIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNativeKernel(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; mem_list: array of cl_mem; args_mem_loc: array of IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    type PIntPtr = ^IntPtr;
    begin
      Result := if (args_mem_loc<>nil) and (args_mem_loc.Length<>0) then
        if (mem_list<>nil) and (mem_list.Length<>0) then
          ntv_EnqueueNativeKernel_4(command_queue, user_func, args, cb_args, num_mem_objects, mem_list[0], args_mem_loc[0], num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueNativeKernel_4(command_queue, user_func, args, cb_args, num_mem_objects, PCl_mem(nil)^, args_mem_loc[0], num_events_in_wait_list, event_wait_list, &event) else
        if (mem_list<>nil) and (mem_list.Length<>0) then
          ntv_EnqueueNativeKernel_4(command_queue, user_func, args, cb_args, num_mem_objects, mem_list[0], PIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueNativeKernel_4(command_queue, user_func, args, cb_args, num_mem_objects, PCl_mem(nil)^, PIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNativeKernel(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; var mem_list: cl_mem; var args_mem_loc: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueNativeKernel_1(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueNativeKernel_1(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNativeKernel(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; var mem_list: cl_mem; var args_mem_loc: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueNativeKernel_2(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueNativeKernel_2(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNativeKernel(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; var mem_list: cl_mem; var args_mem_loc: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueNativeKernel_1(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNativeKernel(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; var mem_list: cl_mem; var args_mem_loc: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueNativeKernel_2(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNativeKernel(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; var mem_list: cl_mem; var args_mem_loc: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueNativeKernel_3(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNativeKernel(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; var mem_list: cl_mem; var args_mem_loc: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueNativeKernel_4(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNativeKernel(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; mem_list: IntPtr; args_mem_loc: pointer; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueNativeKernel_5(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueNativeKernel_5(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNativeKernel(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; mem_list: IntPtr; args_mem_loc: pointer; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueNativeKernel_6(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueNativeKernel_6(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNativeKernel(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; mem_list: IntPtr; args_mem_loc: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueNativeKernel_5(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNativeKernel(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; mem_list: IntPtr; args_mem_loc: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueNativeKernel_6(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNativeKernel(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; mem_list: IntPtr; args_mem_loc: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueNativeKernel_7(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNativeKernel(command_queue: cl_command_queue; user_func: clEnqueueNativeKernelCallback; args: IntPtr; cb_args: UIntPtr; num_mem_objects: UInt32; mem_list: IntPtr; args_mem_loc: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueNativeKernel_8(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.0
    private static function ntv_EnqueueNDRangeKernel_1(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueNDRangeKernel';
    private static function ntv_EnqueueNDRangeKernel_2(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueNDRangeKernel';
    private static function ntv_EnqueueNDRangeKernel_3(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueNDRangeKernel';
    private static function ntv_EnqueueNDRangeKernel_4(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueNDRangeKernel';
    private static function ntv_EnqueueNDRangeKernel_5(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueNDRangeKernel';
    private static function ntv_EnqueueNDRangeKernel_6(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueNDRangeKernel';
    private static function ntv_EnqueueNDRangeKernel_7(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueNDRangeKernel';
    private static function ntv_EnqueueNDRangeKernel_8(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueNDRangeKernel';
    private static function ntv_EnqueueNDRangeKernel_9(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueNDRangeKernel';
    private static function ntv_EnqueueNDRangeKernel_10(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueNDRangeKernel';
    private static function ntv_EnqueueNDRangeKernel_11(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueNDRangeKernel';
    private static function ntv_EnqueueNDRangeKernel_12(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueNDRangeKernel';
    private static function ntv_EnqueueNDRangeKernel_13(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueNDRangeKernel';
    private static function ntv_EnqueueNDRangeKernel_14(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueNDRangeKernel';
    private static function ntv_EnqueueNDRangeKernel_15(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueNDRangeKernel';
    private static function ntv_EnqueueNDRangeKernel_16(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueNDRangeKernel';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: array of UIntPtr; global_work_size: array of UIntPtr; local_work_size: array of UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueNDRangeKernel(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueNDRangeKernel(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: array of UIntPtr; global_work_size: array of UIntPtr; local_work_size: array of UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueNDRangeKernel(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueNDRangeKernel(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: array of UIntPtr; global_work_size: array of UIntPtr; local_work_size: array of UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    type PUIntPtr = ^UIntPtr;
    begin
      Result := if (global_work_size<>nil) and (global_work_size.Length<>0) then
        if (global_work_offset<>nil) and (global_work_offset.Length<>0) then
          if (local_work_size<>nil) and (local_work_size.Length<>0) then
            ntv_EnqueueNDRangeKernel_1(command_queue, kernel, work_dim, global_work_offset[0], global_work_size[0], local_work_size[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueNDRangeKernel_1(command_queue, kernel, work_dim, global_work_offset[0], global_work_size[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          if (local_work_size<>nil) and (local_work_size.Length<>0) then
            ntv_EnqueueNDRangeKernel_1(command_queue, kernel, work_dim, PUIntPtr(nil)^, global_work_size[0], local_work_size[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueNDRangeKernel_1(command_queue, kernel, work_dim, PUIntPtr(nil)^, global_work_size[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
        if (global_work_offset<>nil) and (global_work_offset.Length<>0) then
          if (local_work_size<>nil) and (local_work_size.Length<>0) then
            ntv_EnqueueNDRangeKernel_1(command_queue, kernel, work_dim, global_work_offset[0], PUIntPtr(nil)^, local_work_size[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueNDRangeKernel_1(command_queue, kernel, work_dim, global_work_offset[0], PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          if (local_work_size<>nil) and (local_work_size.Length<>0) then
            ntv_EnqueueNDRangeKernel_1(command_queue, kernel, work_dim, PUIntPtr(nil)^, PUIntPtr(nil)^, local_work_size[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueNDRangeKernel_1(command_queue, kernel, work_dim, PUIntPtr(nil)^, PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: array of UIntPtr; global_work_size: array of UIntPtr; local_work_size: array of UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    type PUIntPtr = ^UIntPtr;
    begin
      Result := if (global_work_size<>nil) and (global_work_size.Length<>0) then
        if (global_work_offset<>nil) and (global_work_offset.Length<>0) then
          if (local_work_size<>nil) and (local_work_size.Length<>0) then
            ntv_EnqueueNDRangeKernel_2(command_queue, kernel, work_dim, global_work_offset[0], global_work_size[0], local_work_size[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueNDRangeKernel_2(command_queue, kernel, work_dim, global_work_offset[0], global_work_size[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          if (local_work_size<>nil) and (local_work_size.Length<>0) then
            ntv_EnqueueNDRangeKernel_2(command_queue, kernel, work_dim, PUIntPtr(nil)^, global_work_size[0], local_work_size[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueNDRangeKernel_2(command_queue, kernel, work_dim, PUIntPtr(nil)^, global_work_size[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
        if (global_work_offset<>nil) and (global_work_offset.Length<>0) then
          if (local_work_size<>nil) and (local_work_size.Length<>0) then
            ntv_EnqueueNDRangeKernel_2(command_queue, kernel, work_dim, global_work_offset[0], PUIntPtr(nil)^, local_work_size[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueNDRangeKernel_2(command_queue, kernel, work_dim, global_work_offset[0], PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          if (local_work_size<>nil) and (local_work_size.Length<>0) then
            ntv_EnqueueNDRangeKernel_2(command_queue, kernel, work_dim, PUIntPtr(nil)^, PUIntPtr(nil)^, local_work_size[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueNDRangeKernel_2(command_queue, kernel, work_dim, PUIntPtr(nil)^, PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: array of UIntPtr; global_work_size: array of UIntPtr; local_work_size: array of UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    type PUIntPtr = ^UIntPtr;
    begin
      Result := if (global_work_size<>nil) and (global_work_size.Length<>0) then
        if (global_work_offset<>nil) and (global_work_offset.Length<>0) then
          if (local_work_size<>nil) and (local_work_size.Length<>0) then
            ntv_EnqueueNDRangeKernel_3(command_queue, kernel, work_dim, global_work_offset[0], global_work_size[0], local_work_size[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueNDRangeKernel_3(command_queue, kernel, work_dim, global_work_offset[0], global_work_size[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          if (local_work_size<>nil) and (local_work_size.Length<>0) then
            ntv_EnqueueNDRangeKernel_3(command_queue, kernel, work_dim, PUIntPtr(nil)^, global_work_size[0], local_work_size[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueNDRangeKernel_3(command_queue, kernel, work_dim, PUIntPtr(nil)^, global_work_size[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
        if (global_work_offset<>nil) and (global_work_offset.Length<>0) then
          if (local_work_size<>nil) and (local_work_size.Length<>0) then
            ntv_EnqueueNDRangeKernel_3(command_queue, kernel, work_dim, global_work_offset[0], PUIntPtr(nil)^, local_work_size[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueNDRangeKernel_3(command_queue, kernel, work_dim, global_work_offset[0], PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          if (local_work_size<>nil) and (local_work_size.Length<>0) then
            ntv_EnqueueNDRangeKernel_3(command_queue, kernel, work_dim, PUIntPtr(nil)^, PUIntPtr(nil)^, local_work_size[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueNDRangeKernel_3(command_queue, kernel, work_dim, PUIntPtr(nil)^, PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: array of UIntPtr; global_work_size: array of UIntPtr; local_work_size: array of UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    type PUIntPtr = ^UIntPtr;
    begin
      Result := if (global_work_size<>nil) and (global_work_size.Length<>0) then
        if (global_work_offset<>nil) and (global_work_offset.Length<>0) then
          if (local_work_size<>nil) and (local_work_size.Length<>0) then
            ntv_EnqueueNDRangeKernel_4(command_queue, kernel, work_dim, global_work_offset[0], global_work_size[0], local_work_size[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueNDRangeKernel_4(command_queue, kernel, work_dim, global_work_offset[0], global_work_size[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          if (local_work_size<>nil) and (local_work_size.Length<>0) then
            ntv_EnqueueNDRangeKernel_4(command_queue, kernel, work_dim, PUIntPtr(nil)^, global_work_size[0], local_work_size[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueNDRangeKernel_4(command_queue, kernel, work_dim, PUIntPtr(nil)^, global_work_size[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
        if (global_work_offset<>nil) and (global_work_offset.Length<>0) then
          if (local_work_size<>nil) and (local_work_size.Length<>0) then
            ntv_EnqueueNDRangeKernel_4(command_queue, kernel, work_dim, global_work_offset[0], PUIntPtr(nil)^, local_work_size[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueNDRangeKernel_4(command_queue, kernel, work_dim, global_work_offset[0], PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          if (local_work_size<>nil) and (local_work_size.Length<>0) then
            ntv_EnqueueNDRangeKernel_4(command_queue, kernel, work_dim, PUIntPtr(nil)^, PUIntPtr(nil)^, local_work_size[0], num_events_in_wait_list, event_wait_list, &event) else
            ntv_EnqueueNDRangeKernel_4(command_queue, kernel, work_dim, PUIntPtr(nil)^, PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueNDRangeKernel_1(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueNDRangeKernel_1(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueNDRangeKernel_2(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueNDRangeKernel_2(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueNDRangeKernel_1(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueNDRangeKernel_2(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueNDRangeKernel_3(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueNDRangeKernel_4(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueNDRangeKernel_5(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueNDRangeKernel_5(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueNDRangeKernel_6(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueNDRangeKernel_6(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueNDRangeKernel_5(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueNDRangeKernel_6(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueNDRangeKernel_7(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueNDRangeKernel_8(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueNDRangeKernel_9(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueNDRangeKernel_9(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueNDRangeKernel_10(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueNDRangeKernel_10(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueNDRangeKernel_9(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueNDRangeKernel_10(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueNDRangeKernel_11(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueNDRangeKernel_12(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueNDRangeKernel_13(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueNDRangeKernel_13(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueNDRangeKernel_14(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueNDRangeKernel_14(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueNDRangeKernel_13(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueNDRangeKernel_14(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueNDRangeKernel_15(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueNDRangeKernel(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; local_work_size: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueNDRangeKernel_16(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.0
    private static function ntv_EnqueueReadBuffer_1(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueReadBuffer';
    private static function ntv_EnqueueReadBuffer_2(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueReadBuffer';
    private static function ntv_EnqueueReadBuffer_3(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueReadBuffer';
    private static function ntv_EnqueueReadBuffer_4(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueReadBuffer';
    private static function ntv_EnqueueReadBuffer_5(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueReadBuffer';
    private static function ntv_EnqueueReadBuffer_6(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueReadBuffer';
    private static function ntv_EnqueueReadBuffer_7(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueReadBuffer';
    private static function ntv_EnqueueReadBuffer_8(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueReadBuffer';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; ptr: array of T; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode; where T: record;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueReadBuffer(command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueReadBuffer(command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; ptr: array of T; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode; where T: record;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueReadBuffer(command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueReadBuffer(command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; ptr: array of T; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode; where T: record;
    type PT = ^T;
    begin
      Result := if (ptr<>nil) and (ptr.Length<>0) then
        EnqueueReadBuffer(command_queue, buffer, blocking_read, offset, size, ptr[0], num_events_in_wait_list, event_wait_list, &event) else
        EnqueueReadBuffer(command_queue, buffer, blocking_read, offset, size, PT(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; ptr: array of T; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode; where T: record;
    type PT = ^T;
    begin
      Result := if (ptr<>nil) and (ptr.Length<>0) then
        EnqueueReadBuffer(command_queue, buffer, blocking_read, offset, size, ptr[0], num_events_in_wait_list, event_wait_list, &event) else
        EnqueueReadBuffer(command_queue, buffer, blocking_read, offset, size, PT(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; ptr: array of T; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode; where T: record;
    type PT = ^T;
    begin
      Result := if (ptr<>nil) and (ptr.Length<>0) then
        EnqueueReadBuffer(command_queue, buffer, blocking_read, offset, size, ptr[0], num_events_in_wait_list, event_wait_list, &event) else
        EnqueueReadBuffer(command_queue, buffer, blocking_read, offset, size, PT(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; ptr: array of T; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode; where T: record;
    type PT = ^T;
    begin
      Result := if (ptr<>nil) and (ptr.Length<>0) then
        EnqueueReadBuffer(command_queue, buffer, blocking_read, offset, size, ptr[0], num_events_in_wait_list, event_wait_list, &event) else
        EnqueueReadBuffer(command_queue, buffer, blocking_read, offset, size, PT(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode; where T: record;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueReadBuffer(command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueReadBuffer(command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode; where T: record;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueReadBuffer(command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueReadBuffer(command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueReadBuffer_1(command_queue, buffer, blocking_read, offset, size, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueReadBuffer_2(command_queue, buffer, blocking_read, offset, size, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueReadBuffer_3(command_queue, buffer, blocking_read, offset, size, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueReadBuffer_4(command_queue, buffer, blocking_read, offset, size, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBuffer(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReadBuffer_5(command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReadBuffer_5(command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBuffer(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReadBuffer_6(command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReadBuffer_6(command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBuffer(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReadBuffer_5(command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBuffer(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReadBuffer_6(command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBuffer(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReadBuffer_7(command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBuffer(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReadBuffer_8(command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.1
    private static function ntv_EnqueueReadBufferRect_1(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueReadBufferRect';
    private static function ntv_EnqueueReadBufferRect_2(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueReadBufferRect';
    private static function ntv_EnqueueReadBufferRect_3(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueReadBufferRect';
    private static function ntv_EnqueueReadBufferRect_4(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueReadBufferRect';
    private static function ntv_EnqueueReadBufferRect_5(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueReadBufferRect';
    private static function ntv_EnqueueReadBufferRect_6(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueReadBufferRect';
    private static function ntv_EnqueueReadBufferRect_7(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueReadBufferRect';
    private static function ntv_EnqueueReadBufferRect_8(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueReadBufferRect';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBufferRect<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode; where T: record;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueReadBufferRect(command_queue, buffer, blocking_read, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueReadBufferRect(command_queue, buffer, blocking_read, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBufferRect<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode; where T: record;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueReadBufferRect(command_queue, buffer, blocking_read, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueReadBufferRect(command_queue, buffer, blocking_read, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBufferRect<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueReadBufferRect_1(command_queue, buffer, blocking_read, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBufferRect<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueReadBufferRect_2(command_queue, buffer, blocking_read, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBufferRect<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueReadBufferRect_3(command_queue, buffer, blocking_read, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBufferRect<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueReadBufferRect_4(command_queue, buffer, blocking_read, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBufferRect(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReadBufferRect_5(command_queue, buffer, blocking_read, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReadBufferRect_5(command_queue, buffer, blocking_read, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBufferRect(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReadBufferRect_6(command_queue, buffer, blocking_read, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReadBufferRect_6(command_queue, buffer, blocking_read, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBufferRect(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReadBufferRect_5(command_queue, buffer, blocking_read, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBufferRect(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReadBufferRect_6(command_queue, buffer, blocking_read, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBufferRect(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReadBufferRect_7(command_queue, buffer, blocking_read, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadBufferRect(command_queue: cl_command_queue; buffer: cl_mem; blocking_read: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReadBufferRect_8(command_queue, buffer, blocking_read, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.0
    private static function ntv_EnqueueReadImage_1(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueReadImage';
    private static function ntv_EnqueueReadImage_2(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueReadImage';
    private static function ntv_EnqueueReadImage_3(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueReadImage';
    private static function ntv_EnqueueReadImage_4(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueReadImage';
    private static function ntv_EnqueueReadImage_5(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueReadImage';
    private static function ntv_EnqueueReadImage_6(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueReadImage';
    private static function ntv_EnqueueReadImage_7(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueReadImage';
    private static function ntv_EnqueueReadImage_8(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueReadImage';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadImage<T>(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode; where T: record;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueReadImage(command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueReadImage(command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadImage<T>(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode; where T: record;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueReadImage(command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueReadImage(command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadImage<T>(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueReadImage_1(command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadImage<T>(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueReadImage_2(command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadImage<T>(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueReadImage_3(command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadImage<T>(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueReadImage_4(command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadImage(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReadImage_5(command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReadImage_5(command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadImage(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReadImage_6(command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReadImage_6(command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadImage(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReadImage_5(command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadImage(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReadImage_6(command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadImage(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReadImage_7(command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueReadImage(command_queue: cl_command_queue; image: cl_mem; blocking_read: clBool; var origin: UIntPtr; var region: UIntPtr; row_pitch: UIntPtr; slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReadImage_8(command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, ptr, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl2.0
    private static function ntv_EnqueueSVMFree_1(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueSVMFree';
    private static function ntv_EnqueueSVMFree_2(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueSVMFree';
    private static function ntv_EnqueueSVMFree_3(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueSVMFree';
    private static function ntv_EnqueueSVMFree_4(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueSVMFree';
    private static function ntv_EnqueueSVMFree_5(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueSVMFree';
    private static function ntv_EnqueueSVMFree_6(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueSVMFree';
    private static function ntv_EnqueueSVMFree_7(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueSVMFree';
    private static function ntv_EnqueueSVMFree_8(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueSVMFree';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMFree(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: array of IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueSVMFree(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueSVMFree(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMFree(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: array of IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueSVMFree(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueSVMFree(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMFree(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: array of IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    type PIntPtr = ^IntPtr;
    begin
      Result := if (svm_pointers<>nil) and (svm_pointers.Length<>0) then
        ntv_EnqueueSVMFree_1(command_queue, num_svm_pointers, svm_pointers[0], pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueSVMFree_1(command_queue, num_svm_pointers, PIntPtr(nil)^, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMFree(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: array of IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    type PIntPtr = ^IntPtr;
    begin
      Result := if (svm_pointers<>nil) and (svm_pointers.Length<>0) then
        ntv_EnqueueSVMFree_2(command_queue, num_svm_pointers, svm_pointers[0], pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueSVMFree_2(command_queue, num_svm_pointers, PIntPtr(nil)^, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMFree(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: array of IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    type PIntPtr = ^IntPtr;
    begin
      Result := if (svm_pointers<>nil) and (svm_pointers.Length<>0) then
        ntv_EnqueueSVMFree_3(command_queue, num_svm_pointers, svm_pointers[0], pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueSVMFree_3(command_queue, num_svm_pointers, PIntPtr(nil)^, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMFree(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: array of IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    type PIntPtr = ^IntPtr;
    begin
      Result := if (svm_pointers<>nil) and (svm_pointers.Length<>0) then
        ntv_EnqueueSVMFree_4(command_queue, num_svm_pointers, svm_pointers[0], pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueSVMFree_4(command_queue, num_svm_pointers, PIntPtr(nil)^, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMFree(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMFree_1(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMFree_1(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMFree(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMFree_2(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMFree_2(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMFree(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMFree_1(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMFree(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMFree_2(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMFree(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMFree_3(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMFree(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMFree_4(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMFree(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMFree_5(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMFree_5(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMFree(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMFree_6(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMFree_6(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMFree(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMFree_5(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMFree(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMFree_6(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMFree(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMFree_7(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMFree(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMFree_8(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl2.0
    private static function ntv_EnqueueSVMMap_1(command_queue: cl_command_queue; blocking_map: clBool; flags: clMapFlags; svm_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueSVMMap';
    private static function ntv_EnqueueSVMMap_2(command_queue: cl_command_queue; blocking_map: clBool; flags: clMapFlags; svm_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueSVMMap';
    private static function ntv_EnqueueSVMMap_3(command_queue: cl_command_queue; blocking_map: clBool; flags: clMapFlags; svm_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueSVMMap';
    private static function ntv_EnqueueSVMMap_4(command_queue: cl_command_queue; blocking_map: clBool; flags: clMapFlags; svm_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueSVMMap';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMap(command_queue: cl_command_queue; blocking_map: clBool; flags: clMapFlags; svm_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMMap_1(command_queue, blocking_map, flags, svm_ptr, size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMMap_1(command_queue, blocking_map, flags, svm_ptr, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMap(command_queue: cl_command_queue; blocking_map: clBool; flags: clMapFlags; svm_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMMap_2(command_queue, blocking_map, flags, svm_ptr, size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMMap_2(command_queue, blocking_map, flags, svm_ptr, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMap(command_queue: cl_command_queue; blocking_map: clBool; flags: clMapFlags; svm_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMMap_1(command_queue, blocking_map, flags, svm_ptr, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMap(command_queue: cl_command_queue; blocking_map: clBool; flags: clMapFlags; svm_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMMap_2(command_queue, blocking_map, flags, svm_ptr, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMap(command_queue: cl_command_queue; blocking_map: clBool; flags: clMapFlags; svm_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMMap_3(command_queue, blocking_map, flags, svm_ptr, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMap(command_queue: cl_command_queue; blocking_map: clBool; flags: clMapFlags; svm_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMMap_4(command_queue, blocking_map, flags, svm_ptr, size, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl2.0
    private static function ntv_EnqueueSVMMemcpy_1(command_queue: cl_command_queue; blocking_copy: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueSVMMemcpy';
    private static function ntv_EnqueueSVMMemcpy_2(command_queue: cl_command_queue; blocking_copy: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueSVMMemcpy';
    private static function ntv_EnqueueSVMMemcpy_3(command_queue: cl_command_queue; blocking_copy: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueSVMMemcpy';
    private static function ntv_EnqueueSVMMemcpy_4(command_queue: cl_command_queue; blocking_copy: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueSVMMemcpy';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemcpy(command_queue: cl_command_queue; blocking_copy: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMMemcpy_1(command_queue, blocking_copy, dst_ptr, src_ptr, size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMMemcpy_1(command_queue, blocking_copy, dst_ptr, src_ptr, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemcpy(command_queue: cl_command_queue; blocking_copy: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMMemcpy_2(command_queue, blocking_copy, dst_ptr, src_ptr, size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMMemcpy_2(command_queue, blocking_copy, dst_ptr, src_ptr, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemcpy(command_queue: cl_command_queue; blocking_copy: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMMemcpy_1(command_queue, blocking_copy, dst_ptr, src_ptr, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemcpy(command_queue: cl_command_queue; blocking_copy: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMMemcpy_2(command_queue, blocking_copy, dst_ptr, src_ptr, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemcpy(command_queue: cl_command_queue; blocking_copy: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMMemcpy_3(command_queue, blocking_copy, dst_ptr, src_ptr, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemcpy(command_queue: cl_command_queue; blocking_copy: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMMemcpy_4(command_queue, blocking_copy, dst_ptr, src_ptr, size, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl2.0
    private static function ntv_EnqueueSVMMemFill_1(command_queue: cl_command_queue; svm_ptr: IntPtr; var pattern: Byte; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueSVMMemFill';
    private static function ntv_EnqueueSVMMemFill_2(command_queue: cl_command_queue; svm_ptr: IntPtr; var pattern: Byte; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueSVMMemFill';
    private static function ntv_EnqueueSVMMemFill_3(command_queue: cl_command_queue; svm_ptr: IntPtr; var pattern: Byte; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueSVMMemFill';
    private static function ntv_EnqueueSVMMemFill_4(command_queue: cl_command_queue; svm_ptr: IntPtr; var pattern: Byte; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueSVMMemFill';
    private static function ntv_EnqueueSVMMemFill_5(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: pointer; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueSVMMemFill';
    private static function ntv_EnqueueSVMMemFill_6(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: pointer; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueSVMMemFill';
    private static function ntv_EnqueueSVMMemFill_7(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: pointer; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueSVMMemFill';
    private static function ntv_EnqueueSVMMemFill_8(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: pointer; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueSVMMemFill';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemFill<T>(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: array of T; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode; where T: record;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueSVMMemFill(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueSVMMemFill(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemFill<T>(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: array of T; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode; where T: record;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueSVMMemFill(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueSVMMemFill(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemFill<T>(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: array of T; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode; where T: record;
    type PT = ^T;
    begin
      Result := if (pattern<>nil) and (pattern.Length<>0) then
        EnqueueSVMMemFill(command_queue, svm_ptr, pattern[0], pattern_size, size, num_events_in_wait_list, event_wait_list, &event) else
        EnqueueSVMMemFill(command_queue, svm_ptr, PT(nil)^, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemFill<T>(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: array of T; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode; where T: record;
    type PT = ^T;
    begin
      Result := if (pattern<>nil) and (pattern.Length<>0) then
        EnqueueSVMMemFill(command_queue, svm_ptr, pattern[0], pattern_size, size, num_events_in_wait_list, event_wait_list, &event) else
        EnqueueSVMMemFill(command_queue, svm_ptr, PT(nil)^, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemFill<T>(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: array of T; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode; where T: record;
    type PT = ^T;
    begin
      Result := if (pattern<>nil) and (pattern.Length<>0) then
        EnqueueSVMMemFill(command_queue, svm_ptr, pattern[0], pattern_size, size, num_events_in_wait_list, event_wait_list, &event) else
        EnqueueSVMMemFill(command_queue, svm_ptr, PT(nil)^, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemFill<T>(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: array of T; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode; where T: record;
    type PT = ^T;
    begin
      Result := if (pattern<>nil) and (pattern.Length<>0) then
        EnqueueSVMMemFill(command_queue, svm_ptr, pattern[0], pattern_size, size, num_events_in_wait_list, event_wait_list, &event) else
        EnqueueSVMMemFill(command_queue, svm_ptr, PT(nil)^, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemFill<T>(command_queue: cl_command_queue; svm_ptr: IntPtr; var pattern: T; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode; where T: record;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueSVMMemFill(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueSVMMemFill(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemFill<T>(command_queue: cl_command_queue; svm_ptr: IntPtr; var pattern: T; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode; where T: record;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueSVMMemFill(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueSVMMemFill(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemFill<T>(command_queue: cl_command_queue; svm_ptr: IntPtr; var pattern: T; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueSVMMemFill_1(command_queue, svm_ptr, PByte(pointer(@pattern))^, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemFill<T>(command_queue: cl_command_queue; svm_ptr: IntPtr; var pattern: T; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueSVMMemFill_2(command_queue, svm_ptr, PByte(pointer(@pattern))^, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemFill<T>(command_queue: cl_command_queue; svm_ptr: IntPtr; var pattern: T; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueSVMMemFill_3(command_queue, svm_ptr, PByte(pointer(@pattern))^, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemFill<T>(command_queue: cl_command_queue; svm_ptr: IntPtr; var pattern: T; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueSVMMemFill_4(command_queue, svm_ptr, PByte(pointer(@pattern))^, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemFill(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: pointer; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMMemFill_5(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMMemFill_5(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemFill(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: pointer; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMMemFill_6(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMMemFill_6(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemFill(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: pointer; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMMemFill_5(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemFill(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: pointer; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMMemFill_6(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemFill(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: pointer; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMMemFill_7(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMemFill(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: pointer; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMMemFill_8(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl2.1
    private static function ntv_EnqueueSVMMigrateMem_1(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; var sizes: UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueSVMMigrateMem';
    private static function ntv_EnqueueSVMMigrateMem_2(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; var sizes: UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueSVMMigrateMem';
    private static function ntv_EnqueueSVMMigrateMem_3(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; var sizes: UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueSVMMigrateMem';
    private static function ntv_EnqueueSVMMigrateMem_4(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; var sizes: UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueSVMMigrateMem';
    private static function ntv_EnqueueSVMMigrateMem_5(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; sizes: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueSVMMigrateMem';
    private static function ntv_EnqueueSVMMigrateMem_6(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; sizes: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueSVMMigrateMem';
    private static function ntv_EnqueueSVMMigrateMem_7(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; sizes: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueSVMMigrateMem';
    private static function ntv_EnqueueSVMMigrateMem_8(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; sizes: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueSVMMigrateMem';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMigrateMem(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: array of IntPtr; sizes: array of UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueSVMMigrateMem(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueSVMMigrateMem(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMigrateMem(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: array of IntPtr; sizes: array of UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueSVMMigrateMem(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueSVMMigrateMem(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMigrateMem(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: array of IntPtr; sizes: array of UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    type PIntPtr = ^IntPtr;
    type PUIntPtr = ^UIntPtr;
    begin
      Result := if (sizes<>nil) and (sizes.Length<>0) then
        if (svm_pointers<>nil) and (svm_pointers.Length<>0) then
          ntv_EnqueueSVMMigrateMem_1(command_queue, num_svm_pointers, svm_pointers[0], sizes[0], flags, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueSVMMigrateMem_1(command_queue, num_svm_pointers, PIntPtr(nil)^, sizes[0], flags, num_events_in_wait_list, event_wait_list, &event) else
        if (svm_pointers<>nil) and (svm_pointers.Length<>0) then
          ntv_EnqueueSVMMigrateMem_1(command_queue, num_svm_pointers, svm_pointers[0], PUIntPtr(nil)^, flags, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueSVMMigrateMem_1(command_queue, num_svm_pointers, PIntPtr(nil)^, PUIntPtr(nil)^, flags, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMigrateMem(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: array of IntPtr; sizes: array of UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    type PIntPtr = ^IntPtr;
    type PUIntPtr = ^UIntPtr;
    begin
      Result := if (sizes<>nil) and (sizes.Length<>0) then
        if (svm_pointers<>nil) and (svm_pointers.Length<>0) then
          ntv_EnqueueSVMMigrateMem_2(command_queue, num_svm_pointers, svm_pointers[0], sizes[0], flags, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueSVMMigrateMem_2(command_queue, num_svm_pointers, PIntPtr(nil)^, sizes[0], flags, num_events_in_wait_list, event_wait_list, &event) else
        if (svm_pointers<>nil) and (svm_pointers.Length<>0) then
          ntv_EnqueueSVMMigrateMem_2(command_queue, num_svm_pointers, svm_pointers[0], PUIntPtr(nil)^, flags, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueSVMMigrateMem_2(command_queue, num_svm_pointers, PIntPtr(nil)^, PUIntPtr(nil)^, flags, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMigrateMem(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: array of IntPtr; sizes: array of UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    type PIntPtr = ^IntPtr;
    type PUIntPtr = ^UIntPtr;
    begin
      Result := if (sizes<>nil) and (sizes.Length<>0) then
        if (svm_pointers<>nil) and (svm_pointers.Length<>0) then
          ntv_EnqueueSVMMigrateMem_3(command_queue, num_svm_pointers, svm_pointers[0], sizes[0], flags, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueSVMMigrateMem_3(command_queue, num_svm_pointers, PIntPtr(nil)^, sizes[0], flags, num_events_in_wait_list, event_wait_list, &event) else
        if (svm_pointers<>nil) and (svm_pointers.Length<>0) then
          ntv_EnqueueSVMMigrateMem_3(command_queue, num_svm_pointers, svm_pointers[0], PUIntPtr(nil)^, flags, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueSVMMigrateMem_3(command_queue, num_svm_pointers, PIntPtr(nil)^, PUIntPtr(nil)^, flags, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMigrateMem(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: array of IntPtr; sizes: array of UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    type PIntPtr = ^IntPtr;
    type PUIntPtr = ^UIntPtr;
    begin
      Result := if (sizes<>nil) and (sizes.Length<>0) then
        if (svm_pointers<>nil) and (svm_pointers.Length<>0) then
          ntv_EnqueueSVMMigrateMem_4(command_queue, num_svm_pointers, svm_pointers[0], sizes[0], flags, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueSVMMigrateMem_4(command_queue, num_svm_pointers, PIntPtr(nil)^, sizes[0], flags, num_events_in_wait_list, event_wait_list, &event) else
        if (svm_pointers<>nil) and (svm_pointers.Length<>0) then
          ntv_EnqueueSVMMigrateMem_4(command_queue, num_svm_pointers, svm_pointers[0], PUIntPtr(nil)^, flags, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueSVMMigrateMem_4(command_queue, num_svm_pointers, PIntPtr(nil)^, PUIntPtr(nil)^, flags, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMigrateMem(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; var sizes: UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMMigrateMem_1(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMMigrateMem_1(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMigrateMem(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; var sizes: UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMMigrateMem_2(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMMigrateMem_2(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMigrateMem(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; var sizes: UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMMigrateMem_1(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMigrateMem(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; var sizes: UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMMigrateMem_2(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMigrateMem(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; var sizes: UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMMigrateMem_3(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMigrateMem(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; var sizes: UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMMigrateMem_4(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMigrateMem(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; sizes: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMMigrateMem_5(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMMigrateMem_5(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMigrateMem(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; sizes: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMMigrateMem_6(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMMigrateMem_6(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMigrateMem(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; sizes: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMMigrateMem_5(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMigrateMem(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; sizes: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMMigrateMem_6(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMigrateMem(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; sizes: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMMigrateMem_7(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMMigrateMem(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; sizes: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMMigrateMem_8(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl2.0
    private static function ntv_EnqueueSVMUnmap_1(command_queue: cl_command_queue; svm_ptr: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueSVMUnmap';
    private static function ntv_EnqueueSVMUnmap_2(command_queue: cl_command_queue; svm_ptr: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueSVMUnmap';
    private static function ntv_EnqueueSVMUnmap_3(command_queue: cl_command_queue; svm_ptr: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueSVMUnmap';
    private static function ntv_EnqueueSVMUnmap_4(command_queue: cl_command_queue; svm_ptr: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueSVMUnmap';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMUnmap(command_queue: cl_command_queue; svm_ptr: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMUnmap_1(command_queue, svm_ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMUnmap_1(command_queue, svm_ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMUnmap(command_queue: cl_command_queue; svm_ptr: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMUnmap_2(command_queue, svm_ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMUnmap_2(command_queue, svm_ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMUnmap(command_queue: cl_command_queue; svm_ptr: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMUnmap_1(command_queue, svm_ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMUnmap(command_queue: cl_command_queue; svm_ptr: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMUnmap_2(command_queue, svm_ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMUnmap(command_queue: cl_command_queue; svm_ptr: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMUnmap_3(command_queue, svm_ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueSVMUnmap(command_queue: cl_command_queue; svm_ptr: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMUnmap_4(command_queue, svm_ptr, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.0
    private static function ntv_EnqueueTask_1(command_queue: cl_command_queue; kernel: cl_kernel; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueTask';
    private static function ntv_EnqueueTask_2(command_queue: cl_command_queue; kernel: cl_kernel; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueTask';
    private static function ntv_EnqueueTask_3(command_queue: cl_command_queue; kernel: cl_kernel; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueTask';
    private static function ntv_EnqueueTask_4(command_queue: cl_command_queue; kernel: cl_kernel; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueTask';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueTask(command_queue: cl_command_queue; kernel: cl_kernel; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueTask_1(command_queue, kernel, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueTask_1(command_queue, kernel, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueTask(command_queue: cl_command_queue; kernel: cl_kernel; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueTask_2(command_queue, kernel, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueTask_2(command_queue, kernel, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueTask(command_queue: cl_command_queue; kernel: cl_kernel; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueTask_1(command_queue, kernel, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueTask(command_queue: cl_command_queue; kernel: cl_kernel; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueTask_2(command_queue, kernel, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueTask(command_queue: cl_command_queue; kernel: cl_kernel; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueTask_3(command_queue, kernel, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueTask(command_queue: cl_command_queue; kernel: cl_kernel; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueTask_4(command_queue, kernel, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.0
    private static function ntv_EnqueueUnmapMemObject_1(command_queue: cl_command_queue; memobj: cl_mem; mapped_ptr: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueUnmapMemObject';
    private static function ntv_EnqueueUnmapMemObject_2(command_queue: cl_command_queue; memobj: cl_mem; mapped_ptr: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueUnmapMemObject';
    private static function ntv_EnqueueUnmapMemObject_3(command_queue: cl_command_queue; memobj: cl_mem; mapped_ptr: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueUnmapMemObject';
    private static function ntv_EnqueueUnmapMemObject_4(command_queue: cl_command_queue; memobj: cl_mem; mapped_ptr: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueUnmapMemObject';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueUnmapMemObject(command_queue: cl_command_queue; memobj: cl_mem; mapped_ptr: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueUnmapMemObject_1(command_queue, memobj, mapped_ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueUnmapMemObject_1(command_queue, memobj, mapped_ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueUnmapMemObject(command_queue: cl_command_queue; memobj: cl_mem; mapped_ptr: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueUnmapMemObject_2(command_queue, memobj, mapped_ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueUnmapMemObject_2(command_queue, memobj, mapped_ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueUnmapMemObject(command_queue: cl_command_queue; memobj: cl_mem; mapped_ptr: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueUnmapMemObject_1(command_queue, memobj, mapped_ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueUnmapMemObject(command_queue: cl_command_queue; memobj: cl_mem; mapped_ptr: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueUnmapMemObject_2(command_queue, memobj, mapped_ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueUnmapMemObject(command_queue: cl_command_queue; memobj: cl_mem; mapped_ptr: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueUnmapMemObject_3(command_queue, memobj, mapped_ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueUnmapMemObject(command_queue: cl_command_queue; memobj: cl_mem; mapped_ptr: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueUnmapMemObject_4(command_queue, memobj, mapped_ptr, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.0
    private static function ntv_EnqueueWaitForEvents_1(command_queue: cl_command_queue; num_events: UInt32; var event_list: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueWaitForEvents';
    private static function ntv_EnqueueWaitForEvents_2(command_queue: cl_command_queue; num_events: UInt32; event_list: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueWaitForEvents';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWaitForEvents(command_queue: cl_command_queue; num_events: UInt32; event_list: array of cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_list<>nil) and (event_list.Length<>0) then
        ntv_EnqueueWaitForEvents_1(command_queue, num_events, event_list[0]) else
        ntv_EnqueueWaitForEvents_1(command_queue, num_events, PCl_event(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWaitForEvents(command_queue: cl_command_queue; num_events: UInt32; var event_list: cl_event): clErrorCode :=
      ntv_EnqueueWaitForEvents_1(command_queue, num_events, event_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWaitForEvents(command_queue: cl_command_queue; num_events: UInt32; event_list: IntPtr): clErrorCode :=
      ntv_EnqueueWaitForEvents_2(command_queue, num_events, event_list);
    
    // added in cl1.0
    private static function ntv_EnqueueWriteBuffer_1(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueWriteBuffer';
    private static function ntv_EnqueueWriteBuffer_2(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueWriteBuffer';
    private static function ntv_EnqueueWriteBuffer_3(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueWriteBuffer';
    private static function ntv_EnqueueWriteBuffer_4(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueWriteBuffer';
    private static function ntv_EnqueueWriteBuffer_5(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueWriteBuffer';
    private static function ntv_EnqueueWriteBuffer_6(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueWriteBuffer';
    private static function ntv_EnqueueWriteBuffer_7(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueWriteBuffer';
    private static function ntv_EnqueueWriteBuffer_8(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueWriteBuffer';
    private static function ntv_EnqueueWriteBuffer_9(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueWriteBuffer';
    private static function ntv_EnqueueWriteBuffer_10(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueWriteBuffer';
    private static function ntv_EnqueueWriteBuffer_11(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueWriteBuffer';
    private static function ntv_EnqueueWriteBuffer_12(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueWriteBuffer';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; ptr: array of T; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode; where T: record;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueWriteBuffer(command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueWriteBuffer(command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; ptr: array of T; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode; where T: record;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueWriteBuffer(command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueWriteBuffer(command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    private [MethodImpl(MethodImplOptions.AggressiveInlining)] static function temp_EnqueueWriteBuffer_1<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueWriteBuffer_1(command_queue, buffer, blocking_write, offset, size, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; ptr: array of T; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode; where T: record;
    type PT = ^T;
    begin
      Result := if (ptr<>nil) and (ptr.Length<>0) then
        temp_EnqueueWriteBuffer_1(command_queue, buffer, blocking_write, offset, size, ptr[0], num_events_in_wait_list, event_wait_list, &event) else
        temp_EnqueueWriteBuffer_1(command_queue, buffer, blocking_write, offset, size, PT(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    private [MethodImpl(MethodImplOptions.AggressiveInlining)] static function temp_EnqueueWriteBuffer_2<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueWriteBuffer_2(command_queue, buffer, blocking_write, offset, size, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; ptr: array of T; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode; where T: record;
    type PT = ^T;
    begin
      Result := if (ptr<>nil) and (ptr.Length<>0) then
        temp_EnqueueWriteBuffer_2(command_queue, buffer, blocking_write, offset, size, ptr[0], num_events_in_wait_list, event_wait_list, &event) else
        temp_EnqueueWriteBuffer_2(command_queue, buffer, blocking_write, offset, size, PT(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    private [MethodImpl(MethodImplOptions.AggressiveInlining)] static function temp_EnqueueWriteBuffer_3<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueWriteBuffer_3(command_queue, buffer, blocking_write, offset, size, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; ptr: array of T; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode; where T: record;
    type PT = ^T;
    begin
      Result := if (ptr<>nil) and (ptr.Length<>0) then
        temp_EnqueueWriteBuffer_3(command_queue, buffer, blocking_write, offset, size, ptr[0], num_events_in_wait_list, event_wait_list, &event) else
        temp_EnqueueWriteBuffer_3(command_queue, buffer, blocking_write, offset, size, PT(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    private [MethodImpl(MethodImplOptions.AggressiveInlining)] static function temp_EnqueueWriteBuffer_4<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueWriteBuffer_4(command_queue, buffer, blocking_write, offset, size, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; ptr: array of T; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode; where T: record;
    type PT = ^T;
    begin
      Result := if (ptr<>nil) and (ptr.Length<>0) then
        temp_EnqueueWriteBuffer_4(command_queue, buffer, blocking_write, offset, size, ptr[0], num_events_in_wait_list, event_wait_list, &event) else
        temp_EnqueueWriteBuffer_4(command_queue, buffer, blocking_write, offset, size, PT(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode; where T: record;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueWriteBuffer(command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueWriteBuffer(command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode; where T: record;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueWriteBuffer(command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueWriteBuffer(command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueWriteBuffer_5(command_queue, buffer, blocking_write, offset, size, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueWriteBuffer_6(command_queue, buffer, blocking_write, offset, size, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueWriteBuffer_7(command_queue, buffer, blocking_write, offset, size, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBuffer<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueWriteBuffer_8(command_queue, buffer, blocking_write, offset, size, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBuffer(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueWriteBuffer_9(command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueWriteBuffer_9(command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBuffer(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueWriteBuffer_10(command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueWriteBuffer_10(command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBuffer(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueWriteBuffer_9(command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBuffer(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueWriteBuffer_10(command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBuffer(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueWriteBuffer_11(command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBuffer(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; offset: UIntPtr; size: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueWriteBuffer_12(command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.1
    private static function ntv_EnqueueWriteBufferRect_1(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueWriteBufferRect';
    private static function ntv_EnqueueWriteBufferRect_2(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueWriteBufferRect';
    private static function ntv_EnqueueWriteBufferRect_3(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueWriteBufferRect';
    private static function ntv_EnqueueWriteBufferRect_4(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueWriteBufferRect';
    private static function ntv_EnqueueWriteBufferRect_5(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueWriteBufferRect';
    private static function ntv_EnqueueWriteBufferRect_6(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueWriteBufferRect';
    private static function ntv_EnqueueWriteBufferRect_7(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueWriteBufferRect';
    private static function ntv_EnqueueWriteBufferRect_8(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueWriteBufferRect';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBufferRect<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode; where T: record;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueWriteBufferRect(command_queue, buffer, blocking_write, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueWriteBufferRect(command_queue, buffer, blocking_write, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBufferRect<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode; where T: record;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueWriteBufferRect(command_queue, buffer, blocking_write, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueWriteBufferRect(command_queue, buffer, blocking_write, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBufferRect<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueWriteBufferRect_1(command_queue, buffer, blocking_write, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBufferRect<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueWriteBufferRect_2(command_queue, buffer, blocking_write, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBufferRect<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueWriteBufferRect_3(command_queue, buffer, blocking_write, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBufferRect<T>(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueWriteBufferRect_4(command_queue, buffer, blocking_write, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBufferRect(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueWriteBufferRect_5(command_queue, buffer, blocking_write, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueWriteBufferRect_5(command_queue, buffer, blocking_write, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBufferRect(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueWriteBufferRect_6(command_queue, buffer, blocking_write, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueWriteBufferRect_6(command_queue, buffer, blocking_write, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBufferRect(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueWriteBufferRect_5(command_queue, buffer, blocking_write, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBufferRect(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueWriteBufferRect_6(command_queue, buffer, blocking_write, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBufferRect(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueWriteBufferRect_7(command_queue, buffer, blocking_write, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteBufferRect(command_queue: cl_command_queue; buffer: cl_mem; blocking_write: clBool; var buffer_origin: UIntPtr; var host_origin: UIntPtr; var region: UIntPtr; buffer_row_pitch: UIntPtr; buffer_slice_pitch: UIntPtr; host_row_pitch: UIntPtr; host_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueWriteBufferRect_8(command_queue, buffer, blocking_write, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.0
    private static function ntv_EnqueueWriteImage_1(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueWriteImage';
    private static function ntv_EnqueueWriteImage_2(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueWriteImage';
    private static function ntv_EnqueueWriteImage_3(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueWriteImage';
    private static function ntv_EnqueueWriteImage_4(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; var ptr: Byte; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueWriteImage';
    private static function ntv_EnqueueWriteImage_5(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueWriteImage';
    private static function ntv_EnqueueWriteImage_6(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueWriteImage';
    private static function ntv_EnqueueWriteImage_7(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    external 'OpenCL' name 'clEnqueueWriteImage';
    private static function ntv_EnqueueWriteImage_8(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    external 'OpenCL' name 'clEnqueueWriteImage';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteImage<T>(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode; where T: record;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueWriteImage(command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueWriteImage(command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteImage<T>(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode; where T: record;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueWriteImage(command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueWriteImage(command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteImage<T>(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueWriteImage_1(command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteImage<T>(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueWriteImage_2(command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteImage<T>(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueWriteImage_3(command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteImage<T>(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; var ptr: T; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueWriteImage_4(command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, PByte(pointer(@ptr))^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteImage(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueWriteImage_5(command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueWriteImage_5(command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteImage(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueWriteImage_6(command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueWriteImage_6(command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteImage(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueWriteImage_5(command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteImage(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueWriteImage_6(command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteImage(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueWriteImage_7(command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function EnqueueWriteImage(command_queue: cl_command_queue; image: cl_mem; blocking_write: clBool; var origin: UIntPtr; var region: UIntPtr; input_row_pitch: UIntPtr; input_slice_pitch: UIntPtr; ptr: pointer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueWriteImage_8(command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, ptr, num_events_in_wait_list, event_wait_list, &event);
    
    // added in cl1.0
    private static function ntv_Finish_1(command_queue: cl_command_queue): clErrorCode;
    external 'OpenCL' name 'clFinish';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function Finish(command_queue: cl_command_queue): clErrorCode :=
      ntv_Finish_1(command_queue);
    
    // added in cl1.0
    private static function ntv_Flush_1(command_queue: cl_command_queue): clErrorCode;
    external 'OpenCL' name 'clFlush';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function Flush(command_queue: cl_command_queue): clErrorCode :=
      ntv_Flush_1(command_queue);
    
    // added in cl1.0
    private static function ntv_GetCommandQueueInfo_1(command_queue: cl_command_queue; param_name: clCommandQueueInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode;
    external 'OpenCL' name 'clGetCommandQueueInfo';
    private static function ntv_GetCommandQueueInfo_2(command_queue: cl_command_queue; param_name: clCommandQueueInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetCommandQueueInfo';
    private static function ntv_GetCommandQueueInfo_3(command_queue: cl_command_queue; param_name: clCommandQueueInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode;
    external 'OpenCL' name 'clGetCommandQueueInfo';
    private static function ntv_GetCommandQueueInfo_4(command_queue: cl_command_queue; param_name: clCommandQueueInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetCommandQueueInfo';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCommandQueueInfo<T>(command_queue: cl_command_queue; param_name: clCommandQueueInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetCommandQueueInfo_1(command_queue, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCommandQueueInfo<T>(command_queue: cl_command_queue; param_name: clCommandQueueInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetCommandQueueInfo_2(command_queue, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCommandQueueInfo(command_queue: cl_command_queue; param_name: clCommandQueueInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetCommandQueueInfo_3(command_queue, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCommandQueueInfo(command_queue: cl_command_queue; param_name: clCommandQueueInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetCommandQueueInfo_4(command_queue, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCommandQueueInfo_QUEUE_CONTEXT(command_queue: cl_command_queue; var param_value: cl_context; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_context>);
      var param_value_ret_size: UIntPtr;
      Result := GetCommandQueueInfo(command_queue, clCommandQueueInfo.QUEUE_CONTEXT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCommandQueueInfo_QUEUE_DEVICE(command_queue: cl_command_queue; var param_value: cl_device_id; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_device_id>);
      var param_value_ret_size: UIntPtr;
      Result := GetCommandQueueInfo(command_queue, clCommandQueueInfo.QUEUE_DEVICE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCommandQueueInfo_QUEUE_REFERENCE_COUNT(command_queue: cl_command_queue; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetCommandQueueInfo(command_queue, clCommandQueueInfo.QUEUE_REFERENCE_COUNT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCommandQueueInfo_QUEUE_PROPERTIES(command_queue: cl_command_queue; var param_value: clCommandQueueProperties; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clCommandQueueProperties>);
      var param_value_ret_size: UIntPtr;
      Result := GetCommandQueueInfo(command_queue, clCommandQueueInfo.QUEUE_PROPERTIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCommandQueueInfo_QUEUE_SIZE(command_queue: cl_command_queue; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetCommandQueueInfo(command_queue, clCommandQueueInfo.QUEUE_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCommandQueueInfo_QUEUE_DEVICE_DEFAULT(command_queue: cl_command_queue; var param_value: cl_command_queue; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_command_queue>);
      var param_value_ret_size: UIntPtr;
      Result := GetCommandQueueInfo(command_queue, clCommandQueueInfo.QUEUE_DEVICE_DEFAULT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCommandQueueInfo_QUEUE_PROPERTIES_ARRAY(command_queue: cl_command_queue; var param_value: array of clQueueProperties): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetCommandQueueInfo_3(command_queue, clCommandQueueInfo.QUEUE_PROPERTIES_ARRAY, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new clQueueProperties[param_value_sz.ToUInt64 div Marshal.SizeOf&<clQueueProperties>];
      Result := GetCommandQueueInfo(command_queue, clCommandQueueInfo.QUEUE_PROPERTIES_ARRAY, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCommandQueueInfo_QUEUE_PROPERTIES_ARRAY(command_queue: cl_command_queue; param_value_count: UInt32; var param_value: clQueueProperties): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<clQueueProperties>);
      Result := GetCommandQueueInfo(command_queue, clCommandQueueInfo.QUEUE_PROPERTIES_ARRAY, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCommandQueueInfo_QUEUE_FAMILY(command_queue: cl_command_queue; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetCommandQueueInfo(command_queue, clCommandQueueInfo.QUEUE_FAMILY, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetCommandQueueInfo_QUEUE_INDEX(command_queue: cl_command_queue; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetCommandQueueInfo(command_queue, clCommandQueueInfo.QUEUE_INDEX, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    
    // added in cl1.0
    private static function ntv_GetContextInfo_1(context: cl_context; param_name: clContextInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode;
    external 'OpenCL' name 'clGetContextInfo';
    private static function ntv_GetContextInfo_2(context: cl_context; param_name: clContextInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetContextInfo';
    private static function ntv_GetContextInfo_3(context: cl_context; param_name: clContextInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode;
    external 'OpenCL' name 'clGetContextInfo';
    private static function ntv_GetContextInfo_4(context: cl_context; param_name: clContextInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetContextInfo';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetContextInfo<T>(context: cl_context; param_name: clContextInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetContextInfo_1(context, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetContextInfo<T>(context: cl_context; param_name: clContextInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetContextInfo_2(context, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetContextInfo(context: cl_context; param_name: clContextInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetContextInfo_3(context, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetContextInfo(context: cl_context; param_name: clContextInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetContextInfo_4(context, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetContextInfo_CONTEXT_REFERENCE_COUNT(context: cl_context; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetContextInfo(context, clContextInfo.CONTEXT_REFERENCE_COUNT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetContextInfo_CONTEXT_DEVICES(context: cl_context; var param_value: array of cl_device_id): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetContextInfo_3(context, clContextInfo.CONTEXT_DEVICES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new cl_device_id[param_value_sz.ToUInt64 div Marshal.SizeOf&<cl_device_id>];
      Result := GetContextInfo(context, clContextInfo.CONTEXT_DEVICES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetContextInfo_CONTEXT_DEVICES(context: cl_context; param_value_count: UInt32; var param_value: cl_device_id): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<cl_device_id>);
      Result := GetContextInfo(context, clContextInfo.CONTEXT_DEVICES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetContextInfo_CONTEXT_PROPERTIES(context: cl_context; var param_value: clContextProperties; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clContextProperties>);
      var param_value_ret_size: UIntPtr;
      Result := GetContextInfo(context, clContextInfo.CONTEXT_PROPERTIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetContextInfo_CONTEXT_NUM_DEVICES(context: cl_context; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetContextInfo(context, clContextInfo.CONTEXT_NUM_DEVICES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetContextInfo_CONTEXT_D3D10_PREFER_SHARED_RESOURCES(context: cl_context; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetContextInfo(context, clContextInfo.CONTEXT_D3D10_PREFER_SHARED_RESOURCES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetContextInfo_CONTEXT_D3D11_PREFER_SHARED_RESOURCES(context: cl_context; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetContextInfo(context, clContextInfo.CONTEXT_D3D11_PREFER_SHARED_RESOURCES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetContextInfo_CONTEXT_VA_API_DISPLAY(context: cl_context; var param_value: IntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<IntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetContextInfo(context, clContextInfo.CONTEXT_VA_API_DISPLAY, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    
    // added in cl2.1
    private static function ntv_GetDeviceAndHostTimer_1(device: cl_device_id; var device_timestamp: UInt64; var host_timestamp: UInt64): clErrorCode;
    external 'OpenCL' name 'clGetDeviceAndHostTimer';
    private static function ntv_GetDeviceAndHostTimer_2(device: cl_device_id; var device_timestamp: UInt64; host_timestamp: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetDeviceAndHostTimer';
    private static function ntv_GetDeviceAndHostTimer_3(device: cl_device_id; device_timestamp: IntPtr; var host_timestamp: UInt64): clErrorCode;
    external 'OpenCL' name 'clGetDeviceAndHostTimer';
    private static function ntv_GetDeviceAndHostTimer_4(device: cl_device_id; device_timestamp: IntPtr; host_timestamp: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetDeviceAndHostTimer';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceAndHostTimer(device: cl_device_id; var device_timestamp: UInt64; var host_timestamp: UInt64): clErrorCode :=
      ntv_GetDeviceAndHostTimer_1(device, device_timestamp, host_timestamp);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceAndHostTimer(device: cl_device_id; var device_timestamp: UInt64; host_timestamp: IntPtr): clErrorCode :=
      ntv_GetDeviceAndHostTimer_2(device, device_timestamp, host_timestamp);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceAndHostTimer(device: cl_device_id; device_timestamp: IntPtr; var host_timestamp: UInt64): clErrorCode :=
      ntv_GetDeviceAndHostTimer_3(device, device_timestamp, host_timestamp);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceAndHostTimer(device: cl_device_id; device_timestamp: IntPtr; host_timestamp: IntPtr): clErrorCode :=
      ntv_GetDeviceAndHostTimer_4(device, device_timestamp, host_timestamp);
    
    // added in cl1.0
    private static function ntv_GetDeviceIDs_1(platform: cl_platform_id; device_type: clDeviceType; num_entries: UInt32; var devices: cl_device_id; var num_devices: UInt32): clErrorCode;
    external 'OpenCL' name 'clGetDeviceIDs';
    private static function ntv_GetDeviceIDs_2(platform: cl_platform_id; device_type: clDeviceType; num_entries: UInt32; var devices: cl_device_id; num_devices: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetDeviceIDs';
    private static function ntv_GetDeviceIDs_3(platform: cl_platform_id; device_type: clDeviceType; num_entries: UInt32; devices: IntPtr; var num_devices: UInt32): clErrorCode;
    external 'OpenCL' name 'clGetDeviceIDs';
    private static function ntv_GetDeviceIDs_4(platform: cl_platform_id; device_type: clDeviceType; num_entries: UInt32; devices: IntPtr; num_devices: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetDeviceIDs';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceIDs(platform: cl_platform_id; device_type: clDeviceType; num_entries: UInt32; var devices: cl_device_id; var num_devices: UInt32): clErrorCode :=
      ntv_GetDeviceIDs_1(platform, device_type, num_entries, devices, num_devices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceIDs(platform: cl_platform_id; device_type: clDeviceType; num_entries: UInt32; var devices: cl_device_id; num_devices: IntPtr): clErrorCode :=
      ntv_GetDeviceIDs_2(platform, device_type, num_entries, devices, num_devices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceIDs(platform: cl_platform_id; device_type: clDeviceType; num_entries: UInt32; devices: IntPtr; var num_devices: UInt32): clErrorCode :=
      ntv_GetDeviceIDs_3(platform, device_type, num_entries, devices, num_devices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceIDs(platform: cl_platform_id; device_type: clDeviceType; num_entries: UInt32; devices: IntPtr; num_devices: IntPtr): clErrorCode :=
      ntv_GetDeviceIDs_4(platform, device_type, num_entries, devices, num_devices);
    
    // added in cl1.0
    private static function ntv_GetDeviceInfo_1(device: cl_device_id; param_name: clDeviceInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode;
    external 'OpenCL' name 'clGetDeviceInfo';
    private static function ntv_GetDeviceInfo_2(device: cl_device_id; param_name: clDeviceInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetDeviceInfo';
    private static function ntv_GetDeviceInfo_3(device: cl_device_id; param_name: clDeviceInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode;
    external 'OpenCL' name 'clGetDeviceInfo';
    private static function ntv_GetDeviceInfo_4(device: cl_device_id; param_name: clDeviceInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetDeviceInfo';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo<T>(device: cl_device_id; param_name: clDeviceInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetDeviceInfo_1(device, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo<T>(device: cl_device_id; param_name: clDeviceInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetDeviceInfo_2(device, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo(device: cl_device_id; param_name: clDeviceInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetDeviceInfo_3(device, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo(device: cl_device_id; param_name: clDeviceInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetDeviceInfo_4(device, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_TYPE(device: cl_device_id; var param_value: clDeviceType; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceType>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_TYPE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_VENDOR_ID(device: cl_device_id; var param_value: clKhronosVendorId; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clKhronosVendorId>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_VENDOR_ID, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_COMPUTE_UNITS(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_COMPUTE_UNITS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_WORK_ITEM_DIMENSIONS(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_WORK_ITEM_DIMENSIONS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_WORK_GROUP_SIZE(device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_WORK_GROUP_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_WORK_ITEM_SIZES(device: cl_device_id; var param_value: array of UIntPtr): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_MAX_WORK_ITEM_SIZES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new UIntPtr[param_value_sz.ToUInt64 div Marshal.SizeOf&<UIntPtr>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_WORK_ITEM_SIZES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_WORK_ITEM_SIZES(device: cl_device_id; param_value_count: UInt32; var param_value: UIntPtr): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<UIntPtr>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_WORK_ITEM_SIZES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PREFERRED_VECTOR_WIDTH_CHAR(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PREFERRED_VECTOR_WIDTH_CHAR, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PREFERRED_VECTOR_WIDTH_SHORT(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PREFERRED_VECTOR_WIDTH_SHORT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PREFERRED_VECTOR_WIDTH_INT(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PREFERRED_VECTOR_WIDTH_INT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PREFERRED_VECTOR_WIDTH_LONG(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PREFERRED_VECTOR_WIDTH_LONG, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_CLOCK_FREQUENCY(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_CLOCK_FREQUENCY, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_ADDRESS_BITS(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_ADDRESS_BITS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_READ_IMAGE_ARGS(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_READ_IMAGE_ARGS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_WRITE_IMAGE_ARGS(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_WRITE_IMAGE_ARGS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_MEM_ALLOC_SIZE(device: cl_device_id; var param_value: UInt64; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt64>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_MEM_ALLOC_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_IMAGE2D_MAX_WIDTH(device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_IMAGE2D_MAX_WIDTH, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_IMAGE2D_MAX_HEIGHT(device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_IMAGE2D_MAX_HEIGHT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_IMAGE3D_MAX_WIDTH(device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_IMAGE3D_MAX_WIDTH, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_IMAGE3D_MAX_HEIGHT(device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_IMAGE3D_MAX_HEIGHT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_IMAGE3D_MAX_DEPTH(device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_IMAGE3D_MAX_DEPTH, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_IMAGE_SUPPORT(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_IMAGE_SUPPORT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_PARAMETER_SIZE(device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_PARAMETER_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_SAMPLERS(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_SAMPLERS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MEM_BASE_ADDR_ALIGN(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MEM_BASE_ADDR_ALIGN, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MIN_DATA_TYPE_ALIGN_SIZE(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MIN_DATA_TYPE_ALIGN_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SINGLE_FP_CONFIG(device: cl_device_id; var param_value: clDeviceFPConfig; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceFPConfig>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SINGLE_FP_CONFIG, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_GLOBAL_MEM_CACHE_TYPE(device: cl_device_id; var param_value: clDeviceMemCacheType; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceMemCacheType>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_GLOBAL_MEM_CACHE_TYPE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_GLOBAL_MEM_CACHELINE_SIZE(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_GLOBAL_MEM_CACHELINE_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_GLOBAL_MEM_CACHE_SIZE(device: cl_device_id; var param_value: UInt64; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt64>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_GLOBAL_MEM_CACHE_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_GLOBAL_MEM_SIZE(device: cl_device_id; var param_value: UInt64; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt64>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_GLOBAL_MEM_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_CONSTANT_BUFFER_SIZE(device: cl_device_id; var param_value: UInt64; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt64>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_CONSTANT_BUFFER_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_CONSTANT_ARGS(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_CONSTANT_ARGS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_LOCAL_MEM_TYPE(device: cl_device_id; var param_value: clDeviceLocalMemType; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceLocalMemType>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_LOCAL_MEM_TYPE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_LOCAL_MEM_SIZE(device: cl_device_id; var param_value: UInt64; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt64>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_LOCAL_MEM_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_ERROR_CORRECTION_SUPPORT(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_ERROR_CORRECTION_SUPPORT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PROFILING_TIMER_RESOLUTION(device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PROFILING_TIMER_RESOLUTION, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_ENDIAN_LITTLE(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_ENDIAN_LITTLE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_AVAILABLE(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_AVAILABLE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_COMPILER_AVAILABLE(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_COMPILER_AVAILABLE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_EXECUTION_CAPABILITIES(device: cl_device_id; var param_value: clDeviceExecCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceExecCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_EXECUTION_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_QUEUE_PROPERTIES(device: cl_device_id; var param_value: clCommandQueueProperties; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clCommandQueueProperties>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_QUEUE_PROPERTIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_QUEUE_ON_HOST_PROPERTIES(device: cl_device_id; var param_value: clCommandQueueProperties; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clCommandQueueProperties>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_QUEUE_ON_HOST_PROPERTIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_NAME(device: cl_device_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_NAME, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetDeviceInfo_4(device, clDeviceInfo.DEVICE_NAME, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_VENDOR(device: cl_device_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_VENDOR, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetDeviceInfo_4(device, clDeviceInfo.DEVICE_VENDOR, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DRIVER_VERSION(device: cl_device_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DRIVER_VERSION, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetDeviceInfo_4(device, clDeviceInfo.DRIVER_VERSION, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PROFILE(device: cl_device_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_PROFILE, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetDeviceInfo_4(device, clDeviceInfo.DEVICE_PROFILE, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_VERSION(device: cl_device_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_VERSION, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetDeviceInfo_4(device, clDeviceInfo.DEVICE_VERSION, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_EXTENSIONS(device: cl_device_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_EXTENSIONS, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetDeviceInfo_4(device, clDeviceInfo.DEVICE_EXTENSIONS, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PLATFORM(device: cl_device_id; var param_value: cl_platform_id; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_platform_id>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PLATFORM, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_DOUBLE_FP_CONFIG(device: cl_device_id; var param_value: clDeviceFPConfig; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceFPConfig>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_DOUBLE_FP_CONFIG, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_HALF_FP_CONFIG(device: cl_device_id; var param_value: clDeviceFPConfig; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceFPConfig>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_HALF_FP_CONFIG, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PREFERRED_VECTOR_WIDTH_HALF(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PREFERRED_VECTOR_WIDTH_HALF, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_HOST_UNIFIED_MEMORY(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_HOST_UNIFIED_MEMORY, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_NATIVE_VECTOR_WIDTH_CHAR(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_NATIVE_VECTOR_WIDTH_CHAR, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_NATIVE_VECTOR_WIDTH_SHORT(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_NATIVE_VECTOR_WIDTH_SHORT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_NATIVE_VECTOR_WIDTH_INT(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_NATIVE_VECTOR_WIDTH_INT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_NATIVE_VECTOR_WIDTH_LONG(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_NATIVE_VECTOR_WIDTH_LONG, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_NATIVE_VECTOR_WIDTH_FLOAT(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_NATIVE_VECTOR_WIDTH_FLOAT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_NATIVE_VECTOR_WIDTH_HALF(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_NATIVE_VECTOR_WIDTH_HALF, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_OPENCL_C_VERSION(device: cl_device_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_OPENCL_C_VERSION, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetDeviceInfo_4(device, clDeviceInfo.DEVICE_OPENCL_C_VERSION, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_LINKER_AVAILABLE(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_LINKER_AVAILABLE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_BUILT_IN_KERNELS(device: cl_device_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_BUILT_IN_KERNELS, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetDeviceInfo_4(device, clDeviceInfo.DEVICE_BUILT_IN_KERNELS, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_IMAGE_MAX_BUFFER_SIZE(device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_IMAGE_MAX_BUFFER_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_IMAGE_MAX_ARRAY_SIZE(device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_IMAGE_MAX_ARRAY_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PARENT_DEVICE(device: cl_device_id; var param_value: cl_device_id; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_device_id>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PARENT_DEVICE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PARTITION_MAX_SUB_DEVICES(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PARTITION_MAX_SUB_DEVICES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PARTITION_PROPERTIES(device: cl_device_id; var param_value: array of clDevicePartitionProperty): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_PARTITION_PROPERTIES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new clDevicePartitionProperty[param_value_sz.ToUInt64 div Marshal.SizeOf&<clDevicePartitionProperty>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PARTITION_PROPERTIES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PARTITION_PROPERTIES(device: cl_device_id; param_value_count: UInt32; var param_value: clDevicePartitionProperty): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<clDevicePartitionProperty>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PARTITION_PROPERTIES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PARTITION_AFFINITY_DOMAIN(device: cl_device_id; var param_value: clDeviceAffinityDomain; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceAffinityDomain>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PARTITION_AFFINITY_DOMAIN, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PARTITION_TYPE(device: cl_device_id; var param_value: array of clDevicePartitionProperty): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_PARTITION_TYPE, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new clDevicePartitionProperty[param_value_sz.ToUInt64 div Marshal.SizeOf&<clDevicePartitionProperty>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PARTITION_TYPE, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PARTITION_TYPE(device: cl_device_id; param_value_count: UInt32; var param_value: clDevicePartitionProperty): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<clDevicePartitionProperty>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PARTITION_TYPE, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_REFERENCE_COUNT(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_REFERENCE_COUNT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PREFERRED_INTEROP_USER_SYNC(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PREFERRED_INTEROP_USER_SYNC, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PRINTF_BUFFER_SIZE(device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PRINTF_BUFFER_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_IMAGE_PITCH_ALIGNMENT(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_IMAGE_PITCH_ALIGNMENT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_IMAGE_BASE_ADDRESS_ALIGNMENT(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_IMAGE_BASE_ADDRESS_ALIGNMENT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_READ_WRITE_IMAGE_ARGS(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_READ_WRITE_IMAGE_ARGS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_GLOBAL_VARIABLE_SIZE(device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_GLOBAL_VARIABLE_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_QUEUE_ON_DEVICE_PROPERTIES(device: cl_device_id; var param_value: clCommandQueueProperties; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clCommandQueueProperties>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_QUEUE_ON_DEVICE_PROPERTIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_QUEUE_ON_DEVICE_PREFERRED_SIZE(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_QUEUE_ON_DEVICE_PREFERRED_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_QUEUE_ON_DEVICE_MAX_SIZE(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_QUEUE_ON_DEVICE_MAX_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_ON_DEVICE_QUEUES(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_ON_DEVICE_QUEUES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_ON_DEVICE_EVENTS(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_ON_DEVICE_EVENTS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SVM_CAPABILITIES(device: cl_device_id; var param_value: clDeviceSVMCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceSVMCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SVM_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_GLOBAL_VARIABLE_PREFERRED_TOTAL_SIZE(device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_GLOBAL_VARIABLE_PREFERRED_TOTAL_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_PIPE_ARGS(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_PIPE_ARGS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PIPE_MAX_ACTIVE_RESERVATIONS(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PIPE_MAX_ACTIVE_RESERVATIONS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PIPE_MAX_PACKET_SIZE(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PIPE_MAX_PACKET_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PREFERRED_PLATFORM_ATOMIC_ALIGNMENT(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PREFERRED_PLATFORM_ATOMIC_ALIGNMENT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PREFERRED_GLOBAL_ATOMIC_ALIGNMENT(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PREFERRED_GLOBAL_ATOMIC_ALIGNMENT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PREFERRED_LOCAL_ATOMIC_ALIGNMENT(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PREFERRED_LOCAL_ATOMIC_ALIGNMENT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_IL_VERSION(device: cl_device_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_IL_VERSION, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetDeviceInfo_4(device, clDeviceInfo.DEVICE_IL_VERSION, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_NUM_SUB_GROUPS(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_NUM_SUB_GROUPS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SUB_GROUP_INDEPENDENT_FORWARD_PROGRESS(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SUB_GROUP_INDEPENDENT_FORWARD_PROGRESS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_NUMERIC_VERSION(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_NUMERIC_VERSION, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_OPENCL_C_NUMERIC_VERSION(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_OPENCL_C_NUMERIC_VERSION, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_EXTENSIONS_WITH_VERSION(device: cl_device_id; var param_value: array of cl_name_version): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_EXTENSIONS_WITH_VERSION, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new cl_name_version[param_value_sz.ToUInt64 div Marshal.SizeOf&<cl_name_version>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_EXTENSIONS_WITH_VERSION, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_EXTENSIONS_WITH_VERSION(device: cl_device_id; param_value_count: UInt32; var param_value: cl_name_version): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<cl_name_version>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_EXTENSIONS_WITH_VERSION, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_ILS_WITH_VERSION(device: cl_device_id; var param_value: array of cl_name_version): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_ILS_WITH_VERSION, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new cl_name_version[param_value_sz.ToUInt64 div Marshal.SizeOf&<cl_name_version>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_ILS_WITH_VERSION, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_ILS_WITH_VERSION(device: cl_device_id; param_value_count: UInt32; var param_value: cl_name_version): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<cl_name_version>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_ILS_WITH_VERSION, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_BUILT_IN_KERNELS_WITH_VERSION(device: cl_device_id; var param_value: array of cl_name_version): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_BUILT_IN_KERNELS_WITH_VERSION, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new cl_name_version[param_value_sz.ToUInt64 div Marshal.SizeOf&<cl_name_version>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_BUILT_IN_KERNELS_WITH_VERSION, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_BUILT_IN_KERNELS_WITH_VERSION(device: cl_device_id; param_value_count: UInt32; var param_value: cl_name_version): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<cl_name_version>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_BUILT_IN_KERNELS_WITH_VERSION, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_ATOMIC_MEMORY_CAPABILITIES(device: cl_device_id; var param_value: clDeviceAtomicCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceAtomicCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_ATOMIC_MEMORY_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_ATOMIC_FENCE_CAPABILITIES(device: cl_device_id; var param_value: clDeviceAtomicCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceAtomicCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_ATOMIC_FENCE_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_NON_UNIFORM_WORK_GROUP_SUPPORT(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_NON_UNIFORM_WORK_GROUP_SUPPORT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_OPENCL_C_ALL_VERSIONS(device: cl_device_id; var param_value: array of cl_name_version): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_OPENCL_C_ALL_VERSIONS, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new cl_name_version[param_value_sz.ToUInt64 div Marshal.SizeOf&<cl_name_version>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_OPENCL_C_ALL_VERSIONS, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_OPENCL_C_ALL_VERSIONS(device: cl_device_id; param_value_count: UInt32; var param_value: cl_name_version): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<cl_name_version>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_OPENCL_C_ALL_VERSIONS, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PREFERRED_WORK_GROUP_SIZE_MULTIPLE(device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_WORK_GROUP_COLLECTIVE_FUNCTIONS_SUPPORT(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_WORK_GROUP_COLLECTIVE_FUNCTIONS_SUPPORT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_GENERIC_ADDRESS_SPACE_SUPPORT(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_GENERIC_ADDRESS_SPACE_SUPPORT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_UUID(device: cl_device_id; var param_value: array of Byte; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(16*Marshal.SizeOf&<Byte>);
      var param_value_temp_res := new Byte[16];
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_UUID, param_value_sz,param_value_temp_res[0],param_value_ret_size);
      param_value := param_value_temp_res;
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_UUID(device: cl_device_id; param_value_count: UInt32; var param_value: Byte; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<Byte>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_UUID, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DRIVER_UUID(device: cl_device_id; var param_value: array of Byte; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(16*Marshal.SizeOf&<Byte>);
      var param_value_temp_res := new Byte[16];
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DRIVER_UUID, param_value_sz,param_value_temp_res[0],param_value_ret_size);
      param_value := param_value_temp_res;
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DRIVER_UUID(device: cl_device_id; param_value_count: UInt32; var param_value: Byte; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<Byte>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DRIVER_UUID, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_LUID_VALID(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_LUID_VALID, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_LUID(device: cl_device_id; var param_value: array of Byte; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(8*Marshal.SizeOf&<Byte>);
      var param_value_temp_res := new Byte[8];
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_LUID, param_value_sz,param_value_temp_res[0],param_value_ret_size);
      param_value := param_value_temp_res;
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_LUID(device: cl_device_id; param_value_count: UInt32; var param_value: Byte; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<Byte>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_LUID, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_NODE_MASK(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_NODE_MASK, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_OPENCL_C_FEATURES(device: cl_device_id; var param_value: array of cl_name_version): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_OPENCL_C_FEATURES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new cl_name_version[param_value_sz.ToUInt64 div Marshal.SizeOf&<cl_name_version>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_OPENCL_C_FEATURES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_OPENCL_C_FEATURES(device: cl_device_id; param_value_count: UInt32; var param_value: cl_name_version): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<cl_name_version>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_OPENCL_C_FEATURES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_DEVICE_ENQUEUE_CAPABILITIES(device: cl_device_id; var param_value: clDeviceOnDeviceEnqueueCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceOnDeviceEnqueueCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_DEVICE_ENQUEUE_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PIPE_SUPPORT(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PIPE_SUPPORT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_LATEST_CONFORMANCE_VERSION_PASSED(device: cl_device_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_LATEST_CONFORMANCE_VERSION_PASSED, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetDeviceInfo_4(device, clDeviceInfo.DEVICE_LATEST_CONFORMANCE_VERSION_PASSED, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_INTEGER_DOT_PRODUCT_CAPABILITIES(device: cl_device_id; var param_value: clDeviceIntegerDotProductCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceIntegerDotProductCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_INTEGER_DOT_PRODUCT_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_INTEGER_DOT_PRODUCT_ACCELERATION_PROPERTIES_8BIT(device: cl_device_id; var param_value: cl_device_integer_dot_product_acceleration_properties; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_device_integer_dot_product_acceleration_properties>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_INTEGER_DOT_PRODUCT_ACCELERATION_PROPERTIES_8BIT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_INTEGER_DOT_PRODUCT_ACCELERATION_PROPERTIES_4x8BIT_PACKED(device: cl_device_id; var param_value: cl_device_integer_dot_product_acceleration_properties; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_device_integer_dot_product_acceleration_properties>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_INTEGER_DOT_PRODUCT_ACCELERATION_PROPERTIES_4x8BIT_PACKED, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_COMMAND_BUFFER_CAPABILITIES(device: cl_device_id; var param_value: clDeviceCommandBufferCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceCommandBufferCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_COMMAND_BUFFER_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_COMMAND_BUFFER_REQUIRED_QUEUE_PROPERTIES(device: cl_device_id; var param_value: clCommandQueueProperties; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clCommandQueueProperties>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_COMMAND_BUFFER_REQUIRED_QUEUE_PROPERTIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_COMMAND_BUFFER_NUM_SYNC_DEVICES(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_COMMAND_BUFFER_NUM_SYNC_DEVICES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_COMMAND_BUFFER_SYNC_DEVICES(device: cl_device_id; var param_value: array of cl_device_id): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_COMMAND_BUFFER_SYNC_DEVICES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new cl_device_id[param_value_sz.ToUInt64 div Marshal.SizeOf&<cl_device_id>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_COMMAND_BUFFER_SYNC_DEVICES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_COMMAND_BUFFER_SYNC_DEVICES(device: cl_device_id; param_value_count: UInt32; var param_value: cl_device_id): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<cl_device_id>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_COMMAND_BUFFER_SYNC_DEVICES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MUTABLE_DISPATCH_CAPABILITIES(device: cl_device_id; var param_value: clMutableDispatchFields; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clMutableDispatchFields>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MUTABLE_DISPATCH_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_TERMINATE_CAPABILITY(device: cl_device_id; var param_value: clDeviceTerminateCapability; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceTerminateCapability>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_TERMINATE_CAPABILITY, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_NAMED_BARRIER_COUNT(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_NAMED_BARRIER_COUNT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SEMAPHORE_TYPES(device: cl_device_id; var param_value: array of clSemaphoreType): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_SEMAPHORE_TYPES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new clSemaphoreType[param_value_sz.ToUInt64 div Marshal.SizeOf&<clSemaphoreType>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SEMAPHORE_TYPES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SEMAPHORE_TYPES(device: cl_device_id; param_value_count: UInt32; var param_value: clSemaphoreType): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<clSemaphoreType>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SEMAPHORE_TYPES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SEMAPHORE_IMPORT_HANDLE_TYPES(device: cl_device_id; var param_value: array of clExternalSemaphoreHandleType): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_SEMAPHORE_IMPORT_HANDLE_TYPES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new clExternalSemaphoreHandleType[param_value_sz.ToUInt64 div Marshal.SizeOf&<clExternalSemaphoreHandleType>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SEMAPHORE_IMPORT_HANDLE_TYPES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SEMAPHORE_IMPORT_HANDLE_TYPES(device: cl_device_id; param_value_count: UInt32; var param_value: clExternalSemaphoreHandleType): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<clExternalSemaphoreHandleType>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SEMAPHORE_IMPORT_HANDLE_TYPES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SEMAPHORE_EXPORT_HANDLE_TYPES(device: cl_device_id; var param_value: array of clExternalSemaphoreHandleType): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_SEMAPHORE_EXPORT_HANDLE_TYPES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new clExternalSemaphoreHandleType[param_value_sz.ToUInt64 div Marshal.SizeOf&<clExternalSemaphoreHandleType>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SEMAPHORE_EXPORT_HANDLE_TYPES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SEMAPHORE_EXPORT_HANDLE_TYPES(device: cl_device_id; param_value_count: UInt32; var param_value: clExternalSemaphoreHandleType): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<clExternalSemaphoreHandleType>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SEMAPHORE_EXPORT_HANDLE_TYPES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES(device: cl_device_id; var param_value: array of clExternalMemoryHandleType): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new clExternalMemoryHandleType[param_value_sz.ToUInt64 div Marshal.SizeOf&<clExternalMemoryHandleType>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES(device: cl_device_id; param_value_count: UInt32; var param_value: clExternalMemoryHandleType): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<clExternalMemoryHandleType>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_EXTERNAL_MEMORY_IMPORT_ASSUME_LINEAR_IMAGES_HANDLE_TYPES(device: cl_device_id; var param_value: array of clExternalMemoryHandleType): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_EXTERNAL_MEMORY_IMPORT_ASSUME_LINEAR_IMAGES_HANDLE_TYPES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new clExternalMemoryHandleType[param_value_sz.ToUInt64 div Marshal.SizeOf&<clExternalMemoryHandleType>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_EXTERNAL_MEMORY_IMPORT_ASSUME_LINEAR_IMAGES_HANDLE_TYPES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_EXTERNAL_MEMORY_IMPORT_ASSUME_LINEAR_IMAGES_HANDLE_TYPES(device: cl_device_id; param_value_count: UInt32; var param_value: clExternalMemoryHandleType): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<clExternalMemoryHandleType>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_EXTERNAL_MEMORY_IMPORT_ASSUME_LINEAR_IMAGES_HANDLE_TYPES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_COMPUTE_CAPABILITY_MAJOR(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_COMPUTE_CAPABILITY_MAJOR, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_COMPUTE_CAPABILITY_MINOR(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_COMPUTE_CAPABILITY_MINOR, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_REGISTERS_PER_BLOCK(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_REGISTERS_PER_BLOCK, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_WARP_SIZE(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_WARP_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_GPU_OVERLAP(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_GPU_OVERLAP, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_KERNEL_EXEC_TIMEOUT(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_KERNEL_EXEC_TIMEOUT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_INTEGRATED_MEMORY(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_INTEGRATED_MEMORY, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PARENT_DEVICE_EXT(device: cl_device_id; var param_value: cl_device_id; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_device_id>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PARENT_DEVICE_EXT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PARTITION_TYPES(device: cl_device_id; var param_value: array of clDevicePartitionProperty): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_PARTITION_TYPES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new clDevicePartitionProperty[param_value_sz.ToUInt64 div Marshal.SizeOf&<clDevicePartitionProperty>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PARTITION_TYPES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PARTITION_TYPES(device: cl_device_id; param_value_count: UInt32; var param_value: clDevicePartitionProperty): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<clDevicePartitionProperty>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PARTITION_TYPES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_AFFINITY_DOMAINS(device: cl_device_id; var param_value: clDeviceAffinityDomain; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceAffinityDomain>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_AFFINITY_DOMAINS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_REFERENCE_COUNT_EXT(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_REFERENCE_COUNT_EXT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PARTITION_STYLE(device: cl_device_id; var param_value: clDevicePartitionProperty; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDevicePartitionProperty>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PARTITION_STYLE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_ME_VERSION(device: cl_device_id; var param_value: clDeviceMeVersion; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceMeVersion>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_ME_VERSION, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SVM_CAPABILITIES_ARM(device: cl_device_id; var param_value: clDeviceSVMCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceSVMCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SVM_CAPABILITIES_ARM, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_COMPUTE_UNITS_BITFIELD(device: cl_device_id; var param_value: UInt64; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt64>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_COMPUTE_UNITS_BITFIELD, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MEMORY_CAPABILITIES(device: cl_device_id; var param_value: clMemAllocFlagsIMG; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clMemAllocFlagsIMG>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MEMORY_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SPIR_VERSIONS(device: cl_device_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_SPIR_VERSIONS, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetDeviceInfo_4(device, clDeviceInfo.DEVICE_SPIR_VERSIONS, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SIMULTANEOUS_INTEROPS(device: cl_device_id; var param_value: array of UInt32): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_SIMULTANEOUS_INTEROPS, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new UInt32[param_value_sz.ToUInt64 div Marshal.SizeOf&<UInt32>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SIMULTANEOUS_INTEROPS, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SIMULTANEOUS_INTEROPS(device: cl_device_id; param_value_count: UInt32; var param_value: UInt32): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<UInt32>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SIMULTANEOUS_INTEROPS, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_NUM_SIMULTANEOUS_INTEROPS(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_NUM_SIMULTANEOUS_INTEROPS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SUB_GROUP_SIZES(device: cl_device_id; var param_value: array of UIntPtr): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_SUB_GROUP_SIZES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new UIntPtr[param_value_sz.ToUInt64 div Marshal.SizeOf&<UIntPtr>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SUB_GROUP_SIZES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SUB_GROUP_SIZES(device: cl_device_id; param_value_count: UInt32; var param_value: UIntPtr): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<UIntPtr>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SUB_GROUP_SIZES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_AVC_ME_VERSION(device: cl_device_id; var param_value: clDeviceAvcMeVersion; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceAvcMeVersion>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_AVC_ME_VERSION, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_AVC_ME_SUPPORTS_TEXTURE_SAMPLER_USE(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_AVC_ME_SUPPORTS_TEXTURE_SAMPLER_USE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_AVC_ME_SUPPORTS_PREEMPTION(device: cl_device_id; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_AVC_ME_SUPPORTS_PREEMPTION, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PCI_BUS_INFO(device: cl_device_id; var param_value: cl_device_pci_bus_info; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_device_pci_bus_info>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PCI_BUS_INFO, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PLANAR_YUV_MAX_WIDTH(device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PLANAR_YUV_MAX_WIDTH, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_PLANAR_YUV_MAX_HEIGHT(device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_PLANAR_YUV_MAX_HEIGHT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_QUEUE_FAMILY_PROPERTIES(device: cl_device_id; var param_value: array of cl_queue_family_properties): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_QUEUE_FAMILY_PROPERTIES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new cl_queue_family_properties[param_value_sz.ToUInt64 div Marshal.SizeOf&<cl_queue_family_properties>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_QUEUE_FAMILY_PROPERTIES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_QUEUE_FAMILY_PROPERTIES(device: cl_device_id; param_value_count: UInt32; var param_value: cl_queue_family_properties): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<cl_queue_family_properties>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_QUEUE_FAMILY_PROPERTIES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_HOST_MEM_CAPABILITIES(device: cl_device_id; var param_value: clDeviceUnifiedSharedMemoryCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceUnifiedSharedMemoryCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_HOST_MEM_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_DEVICE_MEM_CAPABILITIES(device: cl_device_id; var param_value: clDeviceUnifiedSharedMemoryCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceUnifiedSharedMemoryCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_DEVICE_MEM_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SINGLE_DEVICE_SHARED_MEM_CAPABILITIES(device: cl_device_id; var param_value: clDeviceUnifiedSharedMemoryCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceUnifiedSharedMemoryCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SINGLE_DEVICE_SHARED_MEM_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_CROSS_DEVICE_SHARED_MEM_CAPABILITIES(device: cl_device_id; var param_value: clDeviceUnifiedSharedMemoryCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceUnifiedSharedMemoryCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_CROSS_DEVICE_SHARED_MEM_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SHARED_SYSTEM_MEM_CAPABILITIES(device: cl_device_id; var param_value: clDeviceUnifiedSharedMemoryCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceUnifiedSharedMemoryCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SHARED_SYSTEM_MEM_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_JOB_SLOTS(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_JOB_SLOTS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SCHEDULING_CONTROLS_CAPABILITIES(device: cl_device_id; var param_value: clDeviceSchedulingControlsCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceSchedulingControlsCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SCHEDULING_CONTROLS_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_MAX_WARP_COUNT(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_MAX_WARP_COUNT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SUPPORTED_REGISTER_ALLOCATIONS(device: cl_device_id; var param_value: array of Int32): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetDeviceInfo_3(device, clDeviceInfo.DEVICE_SUPPORTED_REGISTER_ALLOCATIONS, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new Int32[param_value_sz.ToUInt64 div Marshal.SizeOf&<Int32>];
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SUPPORTED_REGISTER_ALLOCATIONS, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SUPPORTED_REGISTER_ALLOCATIONS(device: cl_device_id; param_value_count: UInt32; var param_value: Int32): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<Int32>);
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SUPPORTED_REGISTER_ALLOCATIONS, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_CONTROLLED_TERMINATION_CAPABILITIES(device: cl_device_id; var param_value: clDeviceControlledTerminationCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceControlledTerminationCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_CONTROLLED_TERMINATION_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_CXX_FOR_OPENCL_NUMERIC_VERSION(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_CXX_FOR_OPENCL_NUMERIC_VERSION, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_SINGLE_FP_ATOMIC_CAPABILITIES(device: cl_device_id; var param_value: clDeviceFpAtomicCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceFpAtomicCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_SINGLE_FP_ATOMIC_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_DOUBLE_FP_ATOMIC_CAPABILITIES(device: cl_device_id; var param_value: clDeviceFpAtomicCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceFpAtomicCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_DOUBLE_FP_ATOMIC_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_HALF_FP_ATOMIC_CAPABILITIES(device: cl_device_id; var param_value: clDeviceFpAtomicCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceFpAtomicCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_HALF_FP_ATOMIC_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_IP_VERSION(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_IP_VERSION, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_ID(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_ID, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_NUM_SLICES(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_NUM_SLICES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_NUM_SUB_SLICES_PER_SLICE(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_NUM_SUB_SLICES_PER_SLICE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_NUM_EUS_PER_SUB_SLICE(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_NUM_EUS_PER_SUB_SLICE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_NUM_THREADS_PER_EU(device: cl_device_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_NUM_THREADS_PER_EU, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetDeviceInfo_DEVICE_FEATURE_CAPABILITIES(device: cl_device_id; var param_value: clDeviceFeatureCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDeviceFeatureCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceInfo(device, clDeviceInfo.DEVICE_FEATURE_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    
    // added in cl1.0
    private static function ntv_GetEventInfo_1(&event: cl_event; param_name: clEventInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode;
    external 'OpenCL' name 'clGetEventInfo';
    private static function ntv_GetEventInfo_2(&event: cl_event; param_name: clEventInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetEventInfo';
    private static function ntv_GetEventInfo_3(&event: cl_event; param_name: clEventInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode;
    external 'OpenCL' name 'clGetEventInfo';
    private static function ntv_GetEventInfo_4(&event: cl_event; param_name: clEventInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetEventInfo';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventInfo<T>(&event: cl_event; param_name: clEventInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetEventInfo_1(&event, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventInfo<T>(&event: cl_event; param_name: clEventInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetEventInfo_2(&event, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventInfo_EVENT_COMMAND_QUEUE(&event: cl_event; var param_value: cl_command_queue; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_command_queue>);
      var param_value_ret_size: UIntPtr;
      Result := GetEventInfo(&event, clEventInfo.EVENT_COMMAND_QUEUE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventInfo_EVENT_COMMAND_TYPE(&event: cl_event; var param_value: clCommandType; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clCommandType>);
      var param_value_ret_size: UIntPtr;
      Result := GetEventInfo(&event, clEventInfo.EVENT_COMMAND_TYPE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventInfo_EVENT_REFERENCE_COUNT(&event: cl_event; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetEventInfo(&event, clEventInfo.EVENT_REFERENCE_COUNT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventInfo_EVENT_COMMAND_EXECUTION_STATUS(&event: cl_event; var param_value: clCommandExecutionStatus; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clCommandExecutionStatus>);
      var param_value_ret_size: UIntPtr;
      Result := GetEventInfo(&event, clEventInfo.EVENT_COMMAND_EXECUTION_STATUS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventInfo_EVENT_CONTEXT(&event: cl_event; var param_value: cl_context; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_context>);
      var param_value_ret_size: UIntPtr;
      Result := GetEventInfo(&event, clEventInfo.EVENT_CONTEXT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventInfo_EVENT_COMMAND_TERMINATION_REASON(&event: cl_event; var param_value: clCommandTerminationReason; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clCommandTerminationReason>);
      var param_value_ret_size: UIntPtr;
      Result := GetEventInfo(&event, clEventInfo.EVENT_COMMAND_TERMINATION_REASON, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventInfo(&event: cl_event; param_name: clEventInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetEventInfo_3(&event, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventInfo(&event: cl_event; param_name: clEventInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetEventInfo_4(&event, param_name, param_value_size, param_value, param_value_size_ret);
    
    // added in cl1.0
    private static function ntv_GetEventProfilingInfo_1(&event: cl_event; param_name: clProfilingInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode;
    external 'OpenCL' name 'clGetEventProfilingInfo';
    private static function ntv_GetEventProfilingInfo_2(&event: cl_event; param_name: clProfilingInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetEventProfilingInfo';
    private static function ntv_GetEventProfilingInfo_3(&event: cl_event; param_name: clProfilingInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode;
    external 'OpenCL' name 'clGetEventProfilingInfo';
    private static function ntv_GetEventProfilingInfo_4(&event: cl_event; param_name: clProfilingInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetEventProfilingInfo';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventProfilingInfo<T>(&event: cl_event; param_name: clProfilingInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetEventProfilingInfo_1(&event, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventProfilingInfo<T>(&event: cl_event; param_name: clProfilingInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetEventProfilingInfo_2(&event, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventProfilingInfo_PROFILING_COMMAND_QUEUED(&event: cl_event; var param_value: UInt64; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt64>);
      var param_value_ret_size: UIntPtr;
      Result := GetEventProfilingInfo(&event, clProfilingInfo.PROFILING_COMMAND_QUEUED, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventProfilingInfo_PROFILING_COMMAND_SUBMIT(&event: cl_event; var param_value: UInt64; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt64>);
      var param_value_ret_size: UIntPtr;
      Result := GetEventProfilingInfo(&event, clProfilingInfo.PROFILING_COMMAND_SUBMIT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventProfilingInfo_PROFILING_COMMAND_START(&event: cl_event; var param_value: UInt64; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt64>);
      var param_value_ret_size: UIntPtr;
      Result := GetEventProfilingInfo(&event, clProfilingInfo.PROFILING_COMMAND_START, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventProfilingInfo_PROFILING_COMMAND_END(&event: cl_event; var param_value: UInt64; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt64>);
      var param_value_ret_size: UIntPtr;
      Result := GetEventProfilingInfo(&event, clProfilingInfo.PROFILING_COMMAND_END, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventProfilingInfo_PROFILING_COMMAND_COMPLETE(&event: cl_event; var param_value: UInt64; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt64>);
      var param_value_ret_size: UIntPtr;
      Result := GetEventProfilingInfo(&event, clProfilingInfo.PROFILING_COMMAND_COMPLETE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventProfilingInfo(&event: cl_event; param_name: clProfilingInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetEventProfilingInfo_3(&event, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEventProfilingInfo(&event: cl_event; param_name: clProfilingInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetEventProfilingInfo_4(&event, param_name, param_value_size, param_value, param_value_size_ret);
    
    // added in cl1.0
    private static function ntv_GetExtensionFunctionAddress_1(func_name: IntPtr): IntPtr;
    external 'OpenCL' name 'clGetExtensionFunctionAddress';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetExtensionFunctionAddress(func_name: string): IntPtr;
    begin
      var func_name_str_ptr := Marshal.StringToHGlobalAnsi(func_name);
      try
        Result := ntv_GetExtensionFunctionAddress_1(func_name_str_ptr);
      finally
        Marshal.FreeHGlobal(func_name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetExtensionFunctionAddress(func_name: IntPtr): IntPtr :=
      ntv_GetExtensionFunctionAddress_1(func_name);
    
    // added in cl1.2
    private static function ntv_GetExtensionFunctionAddressForPlatform_1(platform: cl_platform_id; func_name: IntPtr): IntPtr;
    external 'OpenCL' name 'clGetExtensionFunctionAddressForPlatform';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetExtensionFunctionAddressForPlatform(platform: cl_platform_id; func_name: string): IntPtr;
    begin
      var func_name_str_ptr := Marshal.StringToHGlobalAnsi(func_name);
      try
        Result := ntv_GetExtensionFunctionAddressForPlatform_1(platform, func_name_str_ptr);
      finally
        Marshal.FreeHGlobal(func_name_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetExtensionFunctionAddressForPlatform(platform: cl_platform_id; func_name: IntPtr): IntPtr :=
      ntv_GetExtensionFunctionAddressForPlatform_1(platform, func_name);
    
    // added in cl2.1
    private static function ntv_GetHostTimer_1(device: cl_device_id; var host_timestamp: UInt64): clErrorCode;
    external 'OpenCL' name 'clGetHostTimer';
    private static function ntv_GetHostTimer_2(device: cl_device_id; host_timestamp: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetHostTimer';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetHostTimer(device: cl_device_id; var host_timestamp: UInt64): clErrorCode :=
      ntv_GetHostTimer_1(device, host_timestamp);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetHostTimer(device: cl_device_id; host_timestamp: IntPtr): clErrorCode :=
      ntv_GetHostTimer_2(device, host_timestamp);
    
    // added in cl1.0
    private static function ntv_GetImageInfo_1(image: cl_mem; param_name: clImageInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode;
    external 'OpenCL' name 'clGetImageInfo';
    private static function ntv_GetImageInfo_2(image: cl_mem; param_name: clImageInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetImageInfo';
    private static function ntv_GetImageInfo_3(image: cl_mem; param_name: clImageInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode;
    external 'OpenCL' name 'clGetImageInfo';
    private static function ntv_GetImageInfo_4(image: cl_mem; param_name: clImageInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetImageInfo';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo<T>(image: cl_mem; param_name: clImageInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetImageInfo_1(image, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo<T>(image: cl_mem; param_name: clImageInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetImageInfo_2(image, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo_IMAGE_FORMAT(image: cl_mem; var param_value: cl_image_format; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_image_format>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageInfo(image, clImageInfo.IMAGE_FORMAT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo_IMAGE_ELEMENT_SIZE(image: cl_mem; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageInfo(image, clImageInfo.IMAGE_ELEMENT_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo_IMAGE_ROW_PITCH(image: cl_mem; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageInfo(image, clImageInfo.IMAGE_ROW_PITCH, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo_IMAGE_SLICE_PITCH(image: cl_mem; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageInfo(image, clImageInfo.IMAGE_SLICE_PITCH, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo_IMAGE_WIDTH(image: cl_mem; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageInfo(image, clImageInfo.IMAGE_WIDTH, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo_IMAGE_HEIGHT(image: cl_mem; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageInfo(image, clImageInfo.IMAGE_HEIGHT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo_IMAGE_DEPTH(image: cl_mem; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageInfo(image, clImageInfo.IMAGE_DEPTH, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo_IMAGE_ARRAY_SIZE(image: cl_mem; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageInfo(image, clImageInfo.IMAGE_ARRAY_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo_IMAGE_BUFFER(image: cl_mem; var param_value: cl_mem; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_mem>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageInfo(image, clImageInfo.IMAGE_BUFFER, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo_IMAGE_NUM_MIP_LEVELS(image: cl_mem; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageInfo(image, clImageInfo.IMAGE_NUM_MIP_LEVELS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo_IMAGE_NUM_SAMPLES(image: cl_mem; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageInfo(image, clImageInfo.IMAGE_NUM_SAMPLES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo_IMAGE_DX9_MEDIA_PLANE(image: cl_mem; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageInfo(image, clImageInfo.IMAGE_DX9_MEDIA_PLANE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo_IMAGE_D3D10_SUBRESOURCE(image: cl_mem; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageInfo(image, clImageInfo.IMAGE_D3D10_SUBRESOURCE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo_IMAGE_D3D11_SUBRESOURCE(image: cl_mem; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageInfo(image, clImageInfo.IMAGE_D3D11_SUBRESOURCE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo_IMAGE_DX9_PLANE(image: cl_mem; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageInfo(image, clImageInfo.IMAGE_DX9_PLANE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo_IMAGE_VA_API_PLANE(image: cl_mem; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageInfo(image, clImageInfo.IMAGE_VA_API_PLANE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo_EGL_YUV_PLANE(image: cl_mem; var param_value: Int32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<Int32>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageInfo(image, clImageInfo.EGL_YUV_PLANE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo(image: cl_mem; param_name: clImageInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetImageInfo_3(image, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetImageInfo(image: cl_mem; param_name: clImageInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetImageInfo_4(image, param_name, param_value_size, param_value, param_value_size_ret);
    
    // added in cl1.2
    private static function ntv_GetKernelArgInfo_1(kernel: cl_kernel; arg_index: UInt32; param_name: clKernelArgInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode;
    external 'OpenCL' name 'clGetKernelArgInfo';
    private static function ntv_GetKernelArgInfo_2(kernel: cl_kernel; arg_index: UInt32; param_name: clKernelArgInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetKernelArgInfo';
    private static function ntv_GetKernelArgInfo_3(kernel: cl_kernel; arg_index: UInt32; param_name: clKernelArgInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode;
    external 'OpenCL' name 'clGetKernelArgInfo';
    private static function ntv_GetKernelArgInfo_4(kernel: cl_kernel; arg_index: UInt32; param_name: clKernelArgInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetKernelArgInfo';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelArgInfo<T>(kernel: cl_kernel; arg_index: UInt32; param_name: clKernelArgInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetKernelArgInfo_1(kernel, arg_index, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelArgInfo<T>(kernel: cl_kernel; arg_index: UInt32; param_name: clKernelArgInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetKernelArgInfo_2(kernel, arg_index, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelArgInfo(kernel: cl_kernel; arg_index: UInt32; param_name: clKernelArgInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetKernelArgInfo_3(kernel, arg_index, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelArgInfo(kernel: cl_kernel; arg_index: UInt32; param_name: clKernelArgInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetKernelArgInfo_4(kernel, arg_index, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelArgInfo_KERNEL_ARG_ADDRESS_QUALIFIER(kernel: cl_kernel; arg_index: UInt32; var param_value: clKernelArgAddressQualifier; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clKernelArgAddressQualifier>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelArgInfo(kernel, arg_index, clKernelArgInfo.KERNEL_ARG_ADDRESS_QUALIFIER, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelArgInfo_KERNEL_ARG_ACCESS_QUALIFIER(kernel: cl_kernel; arg_index: UInt32; var param_value: clKernelArgAccessQualifier; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clKernelArgAccessQualifier>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelArgInfo(kernel, arg_index, clKernelArgInfo.KERNEL_ARG_ACCESS_QUALIFIER, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelArgInfo_KERNEL_ARG_TYPE_NAME(kernel: cl_kernel; arg_index: UInt32; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetKernelArgInfo_3(kernel, arg_index, clKernelArgInfo.KERNEL_ARG_TYPE_NAME, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetKernelArgInfo_4(kernel, arg_index, clKernelArgInfo.KERNEL_ARG_TYPE_NAME, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelArgInfo_KERNEL_ARG_TYPE_QUALIFIER(kernel: cl_kernel; arg_index: UInt32; var param_value: clKernelArgTypeQualifier; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clKernelArgTypeQualifier>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelArgInfo(kernel, arg_index, clKernelArgInfo.KERNEL_ARG_TYPE_QUALIFIER, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelArgInfo_KERNEL_ARG_NAME(kernel: cl_kernel; arg_index: UInt32; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetKernelArgInfo_3(kernel, arg_index, clKernelArgInfo.KERNEL_ARG_NAME, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetKernelArgInfo_4(kernel, arg_index, clKernelArgInfo.KERNEL_ARG_NAME, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    
    // added in cl1.0
    private static function ntv_GetKernelInfo_1(kernel: cl_kernel; param_name: clKernelInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode;
    external 'OpenCL' name 'clGetKernelInfo';
    private static function ntv_GetKernelInfo_2(kernel: cl_kernel; param_name: clKernelInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetKernelInfo';
    private static function ntv_GetKernelInfo_3(kernel: cl_kernel; param_name: clKernelInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode;
    external 'OpenCL' name 'clGetKernelInfo';
    private static function ntv_GetKernelInfo_4(kernel: cl_kernel; param_name: clKernelInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetKernelInfo';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelInfo<T>(kernel: cl_kernel; param_name: clKernelInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetKernelInfo_1(kernel, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelInfo<T>(kernel: cl_kernel; param_name: clKernelInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetKernelInfo_2(kernel, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelInfo(kernel: cl_kernel; param_name: clKernelInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetKernelInfo_3(kernel, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelInfo(kernel: cl_kernel; param_name: clKernelInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetKernelInfo_4(kernel, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelInfo_KERNEL_FUNCTION_NAME(kernel: cl_kernel; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetKernelInfo_3(kernel, clKernelInfo.KERNEL_FUNCTION_NAME, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetKernelInfo_4(kernel, clKernelInfo.KERNEL_FUNCTION_NAME, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelInfo_KERNEL_NUM_ARGS(kernel: cl_kernel; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelInfo(kernel, clKernelInfo.KERNEL_NUM_ARGS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelInfo_KERNEL_REFERENCE_COUNT(kernel: cl_kernel; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelInfo(kernel, clKernelInfo.KERNEL_REFERENCE_COUNT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelInfo_KERNEL_CONTEXT(kernel: cl_kernel; var param_value: cl_context; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_context>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelInfo(kernel, clKernelInfo.KERNEL_CONTEXT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelInfo_KERNEL_PROGRAM(kernel: cl_kernel; var param_value: cl_program; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_program>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelInfo(kernel, clKernelInfo.KERNEL_PROGRAM, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelInfo_KERNEL_ATTRIBUTES(kernel: cl_kernel; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetKernelInfo_3(kernel, clKernelInfo.KERNEL_ATTRIBUTES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetKernelInfo_4(kernel, clKernelInfo.KERNEL_ATTRIBUTES, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelInfo_KERNEL_MAX_WARP_COUNT(kernel: cl_kernel; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelInfo(kernel, clKernelInfo.KERNEL_MAX_WARP_COUNT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    
    // added in cl2.1
    private static function ntv_GetKernelSubGroupInfo_1(kernel: cl_kernel; device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; var input_value: Byte; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode;
    external 'OpenCL' name 'clGetKernelSubGroupInfo';
    private static function ntv_GetKernelSubGroupInfo_2(kernel: cl_kernel; device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; var input_value: Byte; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetKernelSubGroupInfo';
    private static function ntv_GetKernelSubGroupInfo_3(kernel: cl_kernel; device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; var input_value: Byte; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode;
    external 'OpenCL' name 'clGetKernelSubGroupInfo';
    private static function ntv_GetKernelSubGroupInfo_4(kernel: cl_kernel; device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; var input_value: Byte; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetKernelSubGroupInfo';
    private static function ntv_GetKernelSubGroupInfo_5(kernel: cl_kernel; device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; input_value: pointer; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode;
    external 'OpenCL' name 'clGetKernelSubGroupInfo';
    private static function ntv_GetKernelSubGroupInfo_6(kernel: cl_kernel; device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; input_value: pointer; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetKernelSubGroupInfo';
    private static function ntv_GetKernelSubGroupInfo_7(kernel: cl_kernel; device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; input_value: pointer; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode;
    external 'OpenCL' name 'clGetKernelSubGroupInfo';
    private static function ntv_GetKernelSubGroupInfo_8(kernel: cl_kernel; device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; input_value: pointer; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetKernelSubGroupInfo';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelSubGroupInfo<TInp,T>(kernel: cl_kernel; device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; var input_value: TInp; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where TInp, T: record;
    begin
      Result := ntv_GetKernelSubGroupInfo_1(kernel, device, param_name, input_value_size, PByte(pointer(@input_value))^, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelSubGroupInfo<TInp,T>(kernel: cl_kernel; device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; var input_value: TInp; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where TInp, T: record;
    begin
      Result := ntv_GetKernelSubGroupInfo_2(kernel, device, param_name, input_value_size, PByte(pointer(@input_value))^, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelSubGroupInfo<TInp>(kernel: cl_kernel; device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; var input_value: TInp; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode; where TInp: record;
    begin
      Result := ntv_GetKernelSubGroupInfo_3(kernel, device, param_name, input_value_size, PByte(pointer(@input_value))^, param_value_size, param_value, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelSubGroupInfo<TInp>(kernel: cl_kernel; device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; var input_value: TInp; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode; where TInp: record;
    begin
      Result := ntv_GetKernelSubGroupInfo_4(kernel, device, param_name, input_value_size, PByte(pointer(@input_value))^, param_value_size, param_value, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelSubGroupInfo<T>(kernel: cl_kernel; device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; input_value: pointer; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetKernelSubGroupInfo_5(kernel, device, param_name, input_value_size, input_value, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelSubGroupInfo<T>(kernel: cl_kernel; device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; input_value: pointer; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetKernelSubGroupInfo_6(kernel, device, param_name, input_value_size, input_value, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelSubGroupInfo(kernel: cl_kernel; device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; input_value: pointer; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetKernelSubGroupInfo_7(kernel, device, param_name, input_value_size, input_value, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelSubGroupInfo(kernel: cl_kernel; device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; input_value: pointer; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetKernelSubGroupInfo_8(kernel, device, param_name, input_value_size, input_value, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelSubGroupInfo_KERNEL_LOCAL_SIZE_FOR_SUB_GROUP_COUNT(kernel: cl_kernel; device: cl_device_id; input_value: UIntPtr; var param_value: array of UIntPtr): clErrorCode;
    begin
      var input_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_sz: UIntPtr;
      Result := GetKernelSubGroupInfo(kernel, device, clKernelSubGroupInfo.KERNEL_LOCAL_SIZE_FOR_SUB_GROUP_COUNT, input_value_sz,input_value, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new UIntPtr[param_value_sz.ToUInt64 div Marshal.SizeOf&<UIntPtr>];
      Result := GetKernelSubGroupInfo(kernel, device, clKernelSubGroupInfo.KERNEL_LOCAL_SIZE_FOR_SUB_GROUP_COUNT, input_value_sz,input_value, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelSubGroupInfo_KERNEL_LOCAL_SIZE_FOR_SUB_GROUP_COUNT(kernel: cl_kernel; device: cl_device_id; input_value: UIntPtr; param_value_count: UInt32; var param_value: UIntPtr): clErrorCode;
    begin
      var input_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<UIntPtr>);
      Result := GetKernelSubGroupInfo(kernel, device, clKernelSubGroupInfo.KERNEL_LOCAL_SIZE_FOR_SUB_GROUP_COUNT, input_value_sz,input_value, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelSubGroupInfo_KERNEL_MAX_NUM_SUB_GROUPS(kernel: cl_kernel; device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelSubGroupInfo(kernel, device, clKernelSubGroupInfo.KERNEL_MAX_NUM_SUB_GROUPS, UIntPtr.Zero,nil, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelSubGroupInfo_KERNEL_COMPILE_NUM_SUB_GROUPS(kernel: cl_kernel; device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelSubGroupInfo(kernel, device, clKernelSubGroupInfo.KERNEL_COMPILE_NUM_SUB_GROUPS, UIntPtr.Zero,nil, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelSubGroupInfo_KERNEL_MAX_SUB_GROUP_SIZE_FOR_NDRANGE(kernel: cl_kernel; device: cl_device_id; input_value: array of UIntPtr; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var input_value_sz := new UIntPtr(input_value.Length*Marshal.SizeOf&<UIntPtr>);
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelSubGroupInfo(kernel, device, clKernelSubGroupInfo.KERNEL_MAX_SUB_GROUP_SIZE_FOR_NDRANGE, input_value_sz,input_value[0], param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelSubGroupInfo_KERNEL_MAX_SUB_GROUP_SIZE_FOR_NDRANGE(kernel: cl_kernel; device: cl_device_id; input_value_count: UInt32; var input_value: UIntPtr; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var input_value_sz := new UIntPtr(input_value_count*Marshal.SizeOf&<UIntPtr>);
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelSubGroupInfo(kernel, device, clKernelSubGroupInfo.KERNEL_MAX_SUB_GROUP_SIZE_FOR_NDRANGE, input_value_sz,input_value, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelSubGroupInfo_KERNEL_SUB_GROUP_COUNT_FOR_NDRANGE(kernel: cl_kernel; device: cl_device_id; input_value: array of UIntPtr; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var input_value_sz := new UIntPtr(input_value.Length*Marshal.SizeOf&<UIntPtr>);
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelSubGroupInfo(kernel, device, clKernelSubGroupInfo.KERNEL_SUB_GROUP_COUNT_FOR_NDRANGE, input_value_sz,input_value[0], param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelSubGroupInfo_KERNEL_SUB_GROUP_COUNT_FOR_NDRANGE(kernel: cl_kernel; device: cl_device_id; input_value_count: UInt32; var input_value: UIntPtr; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var input_value_sz := new UIntPtr(input_value_count*Marshal.SizeOf&<UIntPtr>);
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelSubGroupInfo(kernel, device, clKernelSubGroupInfo.KERNEL_SUB_GROUP_COUNT_FOR_NDRANGE, input_value_sz,input_value, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelSubGroupInfo_KERNEL_COMPILE_SUB_GROUP_SIZE(kernel: cl_kernel; device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelSubGroupInfo(kernel, device, clKernelSubGroupInfo.KERNEL_COMPILE_SUB_GROUP_SIZE, UIntPtr.Zero,nil, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    
    // added in cl1.0
    private static function ntv_GetKernelWorkGroupInfo_1(kernel: cl_kernel; device: cl_device_id; param_name: clKernelWorkGroupInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode;
    external 'OpenCL' name 'clGetKernelWorkGroupInfo';
    private static function ntv_GetKernelWorkGroupInfo_2(kernel: cl_kernel; device: cl_device_id; param_name: clKernelWorkGroupInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetKernelWorkGroupInfo';
    private static function ntv_GetKernelWorkGroupInfo_3(kernel: cl_kernel; device: cl_device_id; param_name: clKernelWorkGroupInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode;
    external 'OpenCL' name 'clGetKernelWorkGroupInfo';
    private static function ntv_GetKernelWorkGroupInfo_4(kernel: cl_kernel; device: cl_device_id; param_name: clKernelWorkGroupInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetKernelWorkGroupInfo';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelWorkGroupInfo<T>(kernel: cl_kernel; device: cl_device_id; param_name: clKernelWorkGroupInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetKernelWorkGroupInfo_1(kernel, device, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelWorkGroupInfo<T>(kernel: cl_kernel; device: cl_device_id; param_name: clKernelWorkGroupInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetKernelWorkGroupInfo_2(kernel, device, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelWorkGroupInfo_KERNEL_WORK_GROUP_SIZE(kernel: cl_kernel; device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelWorkGroupInfo(kernel, device, clKernelWorkGroupInfo.KERNEL_WORK_GROUP_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelWorkGroupInfo_KERNEL_COMPILE_WORK_GROUP_SIZE(kernel: cl_kernel; device: cl_device_id; var param_value: array of UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(3*Marshal.SizeOf&<UIntPtr>);
      var param_value_temp_res := new UIntPtr[3];
      var param_value_ret_size: UIntPtr;
      Result := GetKernelWorkGroupInfo(kernel, device, clKernelWorkGroupInfo.KERNEL_COMPILE_WORK_GROUP_SIZE, param_value_sz,param_value_temp_res[0],param_value_ret_size);
      param_value := param_value_temp_res;
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelWorkGroupInfo_KERNEL_COMPILE_WORK_GROUP_SIZE(kernel: cl_kernel; device: cl_device_id; param_value_count: UInt32; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelWorkGroupInfo(kernel, device, clKernelWorkGroupInfo.KERNEL_COMPILE_WORK_GROUP_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelWorkGroupInfo_KERNEL_LOCAL_MEM_SIZE(kernel: cl_kernel; device: cl_device_id; var param_value: UInt64; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt64>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelWorkGroupInfo(kernel, device, clKernelWorkGroupInfo.KERNEL_LOCAL_MEM_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelWorkGroupInfo_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE(kernel: cl_kernel; device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelWorkGroupInfo(kernel, device, clKernelWorkGroupInfo.KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelWorkGroupInfo_KERNEL_PRIVATE_MEM_SIZE(kernel: cl_kernel; device: cl_device_id; var param_value: UInt64; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt64>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelWorkGroupInfo(kernel, device, clKernelWorkGroupInfo.KERNEL_PRIVATE_MEM_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelWorkGroupInfo_KERNEL_GLOBAL_WORK_SIZE(kernel: cl_kernel; device: cl_device_id; var param_value: array of UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(3*Marshal.SizeOf&<UIntPtr>);
      var param_value_temp_res := new UIntPtr[3];
      var param_value_ret_size: UIntPtr;
      Result := GetKernelWorkGroupInfo(kernel, device, clKernelWorkGroupInfo.KERNEL_GLOBAL_WORK_SIZE, param_value_sz,param_value_temp_res[0],param_value_ret_size);
      param_value := param_value_temp_res;
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelWorkGroupInfo_KERNEL_GLOBAL_WORK_SIZE(kernel: cl_kernel; device: cl_device_id; param_value_count: UInt32; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelWorkGroupInfo(kernel, device, clKernelWorkGroupInfo.KERNEL_GLOBAL_WORK_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelWorkGroupInfo_KERNEL_SPILL_MEM_SIZE(kernel: cl_kernel; device: cl_device_id; var param_value: UInt64; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt64>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelWorkGroupInfo(kernel, device, clKernelWorkGroupInfo.KERNEL_SPILL_MEM_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelWorkGroupInfo(kernel: cl_kernel; device: cl_device_id; param_name: clKernelWorkGroupInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetKernelWorkGroupInfo_3(kernel, device, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetKernelWorkGroupInfo(kernel: cl_kernel; device: cl_device_id; param_name: clKernelWorkGroupInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetKernelWorkGroupInfo_4(kernel, device, param_name, param_value_size, param_value, param_value_size_ret);
    
    // added in cl1.0
    private static function ntv_GetMemObjectInfo_1(memobj: cl_mem; param_name: clMemInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode;
    external 'OpenCL' name 'clGetMemObjectInfo';
    private static function ntv_GetMemObjectInfo_2(memobj: cl_mem; param_name: clMemInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetMemObjectInfo';
    private static function ntv_GetMemObjectInfo_3(memobj: cl_mem; param_name: clMemInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode;
    external 'OpenCL' name 'clGetMemObjectInfo';
    private static function ntv_GetMemObjectInfo_4(memobj: cl_mem; param_name: clMemInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetMemObjectInfo';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo<T>(memobj: cl_mem; param_name: clMemInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetMemObjectInfo_1(memobj, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo<T>(memobj: cl_mem; param_name: clMemInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetMemObjectInfo_2(memobj, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo(memobj: cl_mem; param_name: clMemInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetMemObjectInfo_3(memobj, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo(memobj: cl_mem; param_name: clMemInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetMemObjectInfo_4(memobj, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_TYPE(memobj: cl_mem; var param_value: clMemObjectType; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clMemObjectType>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_TYPE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_FLAGS(memobj: cl_mem; var param_value: clMemFlags; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clMemFlags>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_FLAGS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_SIZE(memobj: cl_mem; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_HOST_PTR(memobj: cl_mem; var param_value: IntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<IntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_HOST_PTR, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_MAP_COUNT(memobj: cl_mem; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_MAP_COUNT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_REFERENCE_COUNT(memobj: cl_mem; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_REFERENCE_COUNT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_CONTEXT(memobj: cl_mem; var param_value: cl_context; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_context>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_CONTEXT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_ASSOCIATED_MEMOBJECT(memobj: cl_mem; var param_value: cl_mem; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_mem>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_ASSOCIATED_MEMOBJECT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_OFFSET(memobj: cl_mem; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_OFFSET, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_USES_SVM_POINTER(memobj: cl_mem; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_USES_SVM_POINTER, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_PROPERTIES(memobj: cl_mem; var param_value: array of clMemProperties): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetMemObjectInfo_3(memobj, clMemInfo.MEM_PROPERTIES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new clMemProperties[param_value_sz.ToUInt64 div Marshal.SizeOf&<clMemProperties>];
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_PROPERTIES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_PROPERTIES(memobj: cl_mem; param_value_count: UInt32; var param_value: clMemProperties): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<clMemProperties>);
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_PROPERTIES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_DX9_MEDIA_ADAPTER_TYPE(memobj: cl_mem; var param_value: clDx9MediaAdapterType; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clDx9MediaAdapterType>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_DX9_MEDIA_ADAPTER_TYPE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_DX9_MEDIA_SURFACE_INFO(memobj: cl_mem; var param_value: cl_dx9_surface_info; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_dx9_surface_info>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_DX9_MEDIA_SURFACE_INFO, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_D3D10_RESOURCE(memobj: cl_mem; var param_value: IntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<IntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_D3D10_RESOURCE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_D3D11_RESOURCE(memobj: cl_mem; var param_value: IntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<IntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_D3D11_RESOURCE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_DX9_RESOURCE(memobj: cl_mem; var param_value: IntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<IntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_DX9_RESOURCE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_DX9_SHARED_HANDLE(memobj: cl_mem; var param_value: IntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<IntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_DX9_SHARED_HANDLE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_VA_API_MEDIA_SURFACE(memobj: cl_mem; var param_value: IntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<IntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_VA_API_MEDIA_SURFACE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_USES_SVM_POINTER_ARM(memobj: cl_mem; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_USES_SVM_POINTER_ARM, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_ALLOC_FLAGS_INTEL(memobj: cl_mem; var param_value: clMemAllocFlagsINTEL; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clMemAllocFlagsINTEL>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_ALLOC_FLAGS_INTEL, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_ALLOC_TYPE(memobj: cl_mem; var param_value: clUnifiedSharedMemoryType; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clUnifiedSharedMemoryType>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_ALLOC_TYPE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_ALLOC_BASE_PTR(memobj: cl_mem; var param_value: IntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<IntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_ALLOC_BASE_PTR, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_ALLOC_SIZE(memobj: cl_mem; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_ALLOC_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetMemObjectInfo_MEM_ALLOC_DEVICE(memobj: cl_mem; var param_value: cl_device_id; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_device_id>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemObjectInfo(memobj, clMemInfo.MEM_ALLOC_DEVICE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    
    // added in cl2.0
    private static function ntv_GetPipeInfo_1(pipe: cl_mem; param_name: clPipeInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode;
    external 'OpenCL' name 'clGetPipeInfo';
    private static function ntv_GetPipeInfo_2(pipe: cl_mem; param_name: clPipeInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetPipeInfo';
    private static function ntv_GetPipeInfo_3(pipe: cl_mem; param_name: clPipeInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode;
    external 'OpenCL' name 'clGetPipeInfo';
    private static function ntv_GetPipeInfo_4(pipe: cl_mem; param_name: clPipeInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetPipeInfo';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPipeInfo<T>(pipe: cl_mem; param_name: clPipeInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetPipeInfo_1(pipe, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPipeInfo<T>(pipe: cl_mem; param_name: clPipeInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetPipeInfo_2(pipe, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPipeInfo_PIPE_PACKET_SIZE(pipe: cl_mem; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetPipeInfo(pipe, clPipeInfo.PIPE_PACKET_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPipeInfo_PIPE_MAX_PACKETS(pipe: cl_mem; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetPipeInfo(pipe, clPipeInfo.PIPE_MAX_PACKETS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPipeInfo_PIPE_PROPERTIES(pipe: cl_mem; var param_value: IntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<IntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetPipeInfo(pipe, clPipeInfo.PIPE_PROPERTIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPipeInfo(pipe: cl_mem; param_name: clPipeInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetPipeInfo_3(pipe, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPipeInfo(pipe: cl_mem; param_name: clPipeInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetPipeInfo_4(pipe, param_name, param_value_size, param_value, param_value_size_ret);
    
    // added in cl1.0
    private static function ntv_GetPlatformIDs_1(num_entries: UInt32; var platforms: cl_platform_id; var num_platforms: UInt32): clErrorCode;
    external 'OpenCL' name 'clGetPlatformIDs';
    private static function ntv_GetPlatformIDs_2(num_entries: UInt32; var platforms: cl_platform_id; num_platforms: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetPlatformIDs';
    private static function ntv_GetPlatformIDs_3(num_entries: UInt32; platforms: IntPtr; var num_platforms: UInt32): clErrorCode;
    external 'OpenCL' name 'clGetPlatformIDs';
    private static function ntv_GetPlatformIDs_4(num_entries: UInt32; platforms: IntPtr; num_platforms: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetPlatformIDs';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformIDs(num_entries: UInt32; var platforms: cl_platform_id; var num_platforms: UInt32): clErrorCode :=
      ntv_GetPlatformIDs_1(num_entries, platforms, num_platforms);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformIDs(num_entries: UInt32; var platforms: cl_platform_id; num_platforms: IntPtr): clErrorCode :=
      ntv_GetPlatformIDs_2(num_entries, platforms, num_platforms);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformIDs(num_entries: UInt32; platforms: IntPtr; var num_platforms: UInt32): clErrorCode :=
      ntv_GetPlatformIDs_3(num_entries, platforms, num_platforms);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformIDs(num_entries: UInt32; platforms: IntPtr; num_platforms: IntPtr): clErrorCode :=
      ntv_GetPlatformIDs_4(num_entries, platforms, num_platforms);
    
    // added in cl1.0
    private static function ntv_GetPlatformInfo_1(platform: cl_platform_id; param_name: clPlatformInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode;
    external 'OpenCL' name 'clGetPlatformInfo';
    private static function ntv_GetPlatformInfo_2(platform: cl_platform_id; param_name: clPlatformInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetPlatformInfo';
    private static function ntv_GetPlatformInfo_3(platform: cl_platform_id; param_name: clPlatformInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode;
    external 'OpenCL' name 'clGetPlatformInfo';
    private static function ntv_GetPlatformInfo_4(platform: cl_platform_id; param_name: clPlatformInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetPlatformInfo';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo<T>(platform: cl_platform_id; param_name: clPlatformInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetPlatformInfo_1(platform, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo<T>(platform: cl_platform_id; param_name: clPlatformInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetPlatformInfo_2(platform, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo(platform: cl_platform_id; param_name: clPlatformInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetPlatformInfo_3(platform, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo(platform: cl_platform_id; param_name: clPlatformInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetPlatformInfo_4(platform, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_PROFILE(platform: cl_platform_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetPlatformInfo_3(platform, clPlatformInfo.PLATFORM_PROFILE, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetPlatformInfo_4(platform, clPlatformInfo.PLATFORM_PROFILE, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_VERSION(platform: cl_platform_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetPlatformInfo_3(platform, clPlatformInfo.PLATFORM_VERSION, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetPlatformInfo_4(platform, clPlatformInfo.PLATFORM_VERSION, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_NAME(platform: cl_platform_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetPlatformInfo_3(platform, clPlatformInfo.PLATFORM_NAME, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetPlatformInfo_4(platform, clPlatformInfo.PLATFORM_NAME, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_VENDOR(platform: cl_platform_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetPlatformInfo_3(platform, clPlatformInfo.PLATFORM_VENDOR, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetPlatformInfo_4(platform, clPlatformInfo.PLATFORM_VENDOR, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_EXTENSIONS(platform: cl_platform_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetPlatformInfo_3(platform, clPlatformInfo.PLATFORM_EXTENSIONS, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetPlatformInfo_4(platform, clPlatformInfo.PLATFORM_EXTENSIONS, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_HOST_TIMER_RESOLUTION(platform: cl_platform_id; var param_value: UInt64; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt64>);
      var param_value_ret_size: UIntPtr;
      Result := GetPlatformInfo(platform, clPlatformInfo.PLATFORM_HOST_TIMER_RESOLUTION, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_NUMERIC_VERSION(platform: cl_platform_id; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetPlatformInfo(platform, clPlatformInfo.PLATFORM_NUMERIC_VERSION, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_EXTENSIONS_WITH_VERSION(platform: cl_platform_id; var param_value: array of cl_name_version): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetPlatformInfo_3(platform, clPlatformInfo.PLATFORM_EXTENSIONS_WITH_VERSION, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new cl_name_version[param_value_sz.ToUInt64 div Marshal.SizeOf&<cl_name_version>];
      Result := GetPlatformInfo(platform, clPlatformInfo.PLATFORM_EXTENSIONS_WITH_VERSION, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_EXTENSIONS_WITH_VERSION(platform: cl_platform_id; param_value_count: UInt32; var param_value: cl_name_version): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<cl_name_version>);
      Result := GetPlatformInfo(platform, clPlatformInfo.PLATFORM_EXTENSIONS_WITH_VERSION, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_COMMAND_BUFFER_CAPABILITIES(platform: cl_platform_id; var param_value: clPlatformCommandBufferCapabilities; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clPlatformCommandBufferCapabilities>);
      var param_value_ret_size: UIntPtr;
      Result := GetPlatformInfo(platform, clPlatformInfo.PLATFORM_COMMAND_BUFFER_CAPABILITIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_ICD_SUFFIX(platform: cl_platform_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetPlatformInfo_3(platform, clPlatformInfo.PLATFORM_ICD_SUFFIX, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetPlatformInfo_4(platform, clPlatformInfo.PLATFORM_ICD_SUFFIX, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_SEMAPHORE_TYPES(platform: cl_platform_id; var param_value: array of clSemaphoreType): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetPlatformInfo_3(platform, clPlatformInfo.PLATFORM_SEMAPHORE_TYPES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new clSemaphoreType[param_value_sz.ToUInt64 div Marshal.SizeOf&<clSemaphoreType>];
      Result := GetPlatformInfo(platform, clPlatformInfo.PLATFORM_SEMAPHORE_TYPES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_SEMAPHORE_TYPES(platform: cl_platform_id; param_value_count: UInt32; var param_value: clSemaphoreType): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<clSemaphoreType>);
      Result := GetPlatformInfo(platform, clPlatformInfo.PLATFORM_SEMAPHORE_TYPES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_SEMAPHORE_IMPORT_HANDLE_TYPES(platform: cl_platform_id; var param_value: array of clExternalSemaphoreHandleType): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetPlatformInfo_3(platform, clPlatformInfo.PLATFORM_SEMAPHORE_IMPORT_HANDLE_TYPES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new clExternalSemaphoreHandleType[param_value_sz.ToUInt64 div Marshal.SizeOf&<clExternalSemaphoreHandleType>];
      Result := GetPlatformInfo(platform, clPlatformInfo.PLATFORM_SEMAPHORE_IMPORT_HANDLE_TYPES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_SEMAPHORE_IMPORT_HANDLE_TYPES(platform: cl_platform_id; param_value_count: UInt32; var param_value: clExternalSemaphoreHandleType): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<clExternalSemaphoreHandleType>);
      Result := GetPlatformInfo(platform, clPlatformInfo.PLATFORM_SEMAPHORE_IMPORT_HANDLE_TYPES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_SEMAPHORE_EXPORT_HANDLE_TYPES(platform: cl_platform_id; var param_value: array of clExternalSemaphoreHandleType): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetPlatformInfo_3(platform, clPlatformInfo.PLATFORM_SEMAPHORE_EXPORT_HANDLE_TYPES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new clExternalSemaphoreHandleType[param_value_sz.ToUInt64 div Marshal.SizeOf&<clExternalSemaphoreHandleType>];
      Result := GetPlatformInfo(platform, clPlatformInfo.PLATFORM_SEMAPHORE_EXPORT_HANDLE_TYPES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_SEMAPHORE_EXPORT_HANDLE_TYPES(platform: cl_platform_id; param_value_count: UInt32; var param_value: clExternalSemaphoreHandleType): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<clExternalSemaphoreHandleType>);
      Result := GetPlatformInfo(platform, clPlatformInfo.PLATFORM_SEMAPHORE_EXPORT_HANDLE_TYPES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES(platform: cl_platform_id; var param_value: array of clExternalMemoryHandleType): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetPlatformInfo_3(platform, clPlatformInfo.PLATFORM_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new clExternalMemoryHandleType[param_value_sz.ToUInt64 div Marshal.SizeOf&<clExternalMemoryHandleType>];
      Result := GetPlatformInfo(platform, clPlatformInfo.PLATFORM_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPlatformInfo_PLATFORM_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES(platform: cl_platform_id; param_value_count: UInt32; var param_value: clExternalMemoryHandleType): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<clExternalMemoryHandleType>);
      Result := GetPlatformInfo(platform, clPlatformInfo.PLATFORM_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES, param_value_sz,param_value,IntPtr.Zero);
    end;
    
    // added in cl1.0
    private static function ntv_GetProgramBuildInfo_1(&program: cl_program; device: cl_device_id; param_name: clProgramBuildInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode;
    external 'OpenCL' name 'clGetProgramBuildInfo';
    private static function ntv_GetProgramBuildInfo_2(&program: cl_program; device: cl_device_id; param_name: clProgramBuildInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetProgramBuildInfo';
    private static function ntv_GetProgramBuildInfo_3(&program: cl_program; device: cl_device_id; param_name: clProgramBuildInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode;
    external 'OpenCL' name 'clGetProgramBuildInfo';
    private static function ntv_GetProgramBuildInfo_4(&program: cl_program; device: cl_device_id; param_name: clProgramBuildInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetProgramBuildInfo';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramBuildInfo<T>(&program: cl_program; device: cl_device_id; param_name: clProgramBuildInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetProgramBuildInfo_1(&program, device, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramBuildInfo<T>(&program: cl_program; device: cl_device_id; param_name: clProgramBuildInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetProgramBuildInfo_2(&program, device, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramBuildInfo(&program: cl_program; device: cl_device_id; param_name: clProgramBuildInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetProgramBuildInfo_3(&program, device, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramBuildInfo(&program: cl_program; device: cl_device_id; param_name: clProgramBuildInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetProgramBuildInfo_4(&program, device, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramBuildInfo_PROGRAM_BUILD_STATUS(&program: cl_program; device: cl_device_id; var param_value: clBuildStatus; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBuildStatus>);
      var param_value_ret_size: UIntPtr;
      Result := GetProgramBuildInfo(&program, device, clProgramBuildInfo.PROGRAM_BUILD_STATUS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramBuildInfo_PROGRAM_BUILD_OPTIONS(&program: cl_program; device: cl_device_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetProgramBuildInfo_3(&program, device, clProgramBuildInfo.PROGRAM_BUILD_OPTIONS, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetProgramBuildInfo_4(&program, device, clProgramBuildInfo.PROGRAM_BUILD_OPTIONS, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramBuildInfo_PROGRAM_BUILD_LOG(&program: cl_program; device: cl_device_id; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetProgramBuildInfo_3(&program, device, clProgramBuildInfo.PROGRAM_BUILD_LOG, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetProgramBuildInfo_4(&program, device, clProgramBuildInfo.PROGRAM_BUILD_LOG, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramBuildInfo_PROGRAM_BINARY_TYPE(&program: cl_program; device: cl_device_id; var param_value: clProgramBinaryType; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clProgramBinaryType>);
      var param_value_ret_size: UIntPtr;
      Result := GetProgramBuildInfo(&program, device, clProgramBuildInfo.PROGRAM_BINARY_TYPE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramBuildInfo_PROGRAM_BUILD_GLOBAL_VARIABLE_TOTAL_SIZE(&program: cl_program; device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetProgramBuildInfo(&program, device, clProgramBuildInfo.PROGRAM_BUILD_GLOBAL_VARIABLE_TOTAL_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    
    // added in cl1.0
    private static function ntv_GetProgramInfo_1(&program: cl_program; param_name: clProgramInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode;
    external 'OpenCL' name 'clGetProgramInfo';
    private static function ntv_GetProgramInfo_2(&program: cl_program; param_name: clProgramInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetProgramInfo';
    private static function ntv_GetProgramInfo_3(&program: cl_program; param_name: clProgramInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode;
    external 'OpenCL' name 'clGetProgramInfo';
    private static function ntv_GetProgramInfo_4(&program: cl_program; param_name: clProgramInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetProgramInfo';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo<T>(&program: cl_program; param_name: clProgramInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetProgramInfo_1(&program, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo<T>(&program: cl_program; param_name: clProgramInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetProgramInfo_2(&program, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo(&program: cl_program; param_name: clProgramInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetProgramInfo_3(&program, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo(&program: cl_program; param_name: clProgramInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetProgramInfo_4(&program, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo_PROGRAM_REFERENCE_COUNT(&program: cl_program; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetProgramInfo(&program, clProgramInfo.PROGRAM_REFERENCE_COUNT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo_PROGRAM_CONTEXT(&program: cl_program; var param_value: cl_context; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_context>);
      var param_value_ret_size: UIntPtr;
      Result := GetProgramInfo(&program, clProgramInfo.PROGRAM_CONTEXT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo_PROGRAM_NUM_DEVICES(&program: cl_program; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetProgramInfo(&program, clProgramInfo.PROGRAM_NUM_DEVICES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo_PROGRAM_DEVICES(&program: cl_program; var param_value: array of cl_device_id): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetProgramInfo_3(&program, clProgramInfo.PROGRAM_DEVICES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new cl_device_id[param_value_sz.ToUInt64 div Marshal.SizeOf&<cl_device_id>];
      Result := GetProgramInfo(&program, clProgramInfo.PROGRAM_DEVICES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo_PROGRAM_DEVICES(&program: cl_program; param_value_count: UInt32; var param_value: cl_device_id): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<cl_device_id>);
      Result := GetProgramInfo(&program, clProgramInfo.PROGRAM_DEVICES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo_PROGRAM_SOURCE(&program: cl_program; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetProgramInfo_3(&program, clProgramInfo.PROGRAM_SOURCE, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetProgramInfo_4(&program, clProgramInfo.PROGRAM_SOURCE, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo_PROGRAM_BINARY_SIZES(&program: cl_program; var param_value: array of UIntPtr): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetProgramInfo_3(&program, clProgramInfo.PROGRAM_BINARY_SIZES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new UIntPtr[param_value_sz.ToUInt64 div Marshal.SizeOf&<UIntPtr>];
      Result := GetProgramInfo(&program, clProgramInfo.PROGRAM_BINARY_SIZES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo_PROGRAM_BINARY_SIZES(&program: cl_program; param_value_count: UInt32; var param_value: UIntPtr): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<UIntPtr>);
      Result := GetProgramInfo(&program, clProgramInfo.PROGRAM_BINARY_SIZES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo_PROGRAM_BINARIES(&program: cl_program; param_value_count: UInt32; var param_value: IntPtr): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<IntPtr>);
      Result := GetProgramInfo(&program, clProgramInfo.PROGRAM_BINARIES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo_PROGRAM_NUM_KERNELS(&program: cl_program; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetProgramInfo(&program, clProgramInfo.PROGRAM_NUM_KERNELS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo_PROGRAM_KERNEL_NAMES(&program: cl_program; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetProgramInfo_3(&program, clProgramInfo.PROGRAM_KERNEL_NAMES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetProgramInfo_4(&program, clProgramInfo.PROGRAM_KERNEL_NAMES, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo_PROGRAM_IL(&program: cl_program; var param_value: array of Byte): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetProgramInfo_3(&program, clProgramInfo.PROGRAM_IL, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new Byte[param_value_sz.ToUInt64 div Marshal.SizeOf&<Byte>];
      Result := GetProgramInfo(&program, clProgramInfo.PROGRAM_IL, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo_PROGRAM_IL(&program: cl_program; param_value_count: UInt32; var param_value: Byte): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<Byte>);
      Result := GetProgramInfo(&program, clProgramInfo.PROGRAM_IL, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo_PROGRAM_SCOPE_GLOBAL_CTORS_PRESENT(&program: cl_program; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetProgramInfo(&program, clProgramInfo.PROGRAM_SCOPE_GLOBAL_CTORS_PRESENT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo_PROGRAM_SCOPE_GLOBAL_DTORS_PRESENT(&program: cl_program; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetProgramInfo(&program, clProgramInfo.PROGRAM_SCOPE_GLOBAL_DTORS_PRESENT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo_PROGRAM_NUM_HOST_PIPES(&program: cl_program; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetProgramInfo(&program, clProgramInfo.PROGRAM_NUM_HOST_PIPES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetProgramInfo_PROGRAM_HOST_PIPE_NAMES(&program: cl_program; var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetProgramInfo_3(&program, clProgramInfo.PROGRAM_HOST_PIPE_NAMES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetProgramInfo_4(&program, clProgramInfo.PROGRAM_HOST_PIPE_NAMES, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    
    // added in cl1.0
    private static function ntv_GetSamplerInfo_1(sampler: cl_sampler; param_name: clSamplerInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode;
    external 'OpenCL' name 'clGetSamplerInfo';
    private static function ntv_GetSamplerInfo_2(sampler: cl_sampler; param_name: clSamplerInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetSamplerInfo';
    private static function ntv_GetSamplerInfo_3(sampler: cl_sampler; param_name: clSamplerInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode;
    external 'OpenCL' name 'clGetSamplerInfo';
    private static function ntv_GetSamplerInfo_4(sampler: cl_sampler; param_name: clSamplerInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetSamplerInfo';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetSamplerInfo<T>(sampler: cl_sampler; param_name: clSamplerInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetSamplerInfo_1(sampler, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetSamplerInfo<T>(sampler: cl_sampler; param_name: clSamplerInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetSamplerInfo_2(sampler, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetSamplerInfo(sampler: cl_sampler; param_name: clSamplerInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetSamplerInfo_3(sampler, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetSamplerInfo(sampler: cl_sampler; param_name: clSamplerInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetSamplerInfo_4(sampler, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetSamplerInfo_SAMPLER_REFERENCE_COUNT(sampler: cl_sampler; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetSamplerInfo(sampler, clSamplerInfo.SAMPLER_REFERENCE_COUNT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetSamplerInfo_SAMPLER_CONTEXT(sampler: cl_sampler; var param_value: cl_context; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_context>);
      var param_value_ret_size: UIntPtr;
      Result := GetSamplerInfo(sampler, clSamplerInfo.SAMPLER_CONTEXT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetSamplerInfo_SAMPLER_NORMALIZED_COORDS(sampler: cl_sampler; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetSamplerInfo(sampler, clSamplerInfo.SAMPLER_NORMALIZED_COORDS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetSamplerInfo_SAMPLER_ADDRESSING_MODE(sampler: cl_sampler; var param_value: clAddressingMode; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clAddressingMode>);
      var param_value_ret_size: UIntPtr;
      Result := GetSamplerInfo(sampler, clSamplerInfo.SAMPLER_ADDRESSING_MODE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetSamplerInfo_SAMPLER_FILTER_MODE(sampler: cl_sampler; var param_value: clFilterMode; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clFilterMode>);
      var param_value_ret_size: UIntPtr;
      Result := GetSamplerInfo(sampler, clSamplerInfo.SAMPLER_FILTER_MODE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetSamplerInfo_SAMPLER_MIP_FILTER_MODE(sampler: cl_sampler; var param_value: clFilterMode; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clFilterMode>);
      var param_value_ret_size: UIntPtr;
      Result := GetSamplerInfo(sampler, clSamplerInfo.SAMPLER_MIP_FILTER_MODE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetSamplerInfo_SAMPLER_LOD_MIN(sampler: cl_sampler; var param_value: single; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<single>);
      var param_value_ret_size: UIntPtr;
      Result := GetSamplerInfo(sampler, clSamplerInfo.SAMPLER_LOD_MIN, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetSamplerInfo_SAMPLER_LOD_MAX(sampler: cl_sampler; var param_value: single; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<single>);
      var param_value_ret_size: UIntPtr;
      Result := GetSamplerInfo(sampler, clSamplerInfo.SAMPLER_LOD_MAX, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetSamplerInfo_SAMPLER_PROPERTIES(sampler: cl_sampler; var param_value: array of clSamplerProperties): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetSamplerInfo_3(sampler, clSamplerInfo.SAMPLER_PROPERTIES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new clSamplerProperties[param_value_sz.ToUInt64 div Marshal.SizeOf&<clSamplerProperties>];
      Result := GetSamplerInfo(sampler, clSamplerInfo.SAMPLER_PROPERTIES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetSamplerInfo_SAMPLER_PROPERTIES(sampler: cl_sampler; param_value_count: UInt32; var param_value: clSamplerProperties): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<clSamplerProperties>);
      Result := GetSamplerInfo(sampler, clSamplerInfo.SAMPLER_PROPERTIES, param_value_sz,param_value,IntPtr.Zero);
    end;
    
    // added in cl1.0
    private static function ntv_GetSupportedImageFormats_1(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; num_entries: UInt32; var image_formats: cl_image_format; var num_image_formats: UInt32): clErrorCode;
    external 'OpenCL' name 'clGetSupportedImageFormats';
    private static function ntv_GetSupportedImageFormats_2(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; num_entries: UInt32; var image_formats: cl_image_format; num_image_formats: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetSupportedImageFormats';
    private static function ntv_GetSupportedImageFormats_3(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; num_entries: UInt32; image_formats: IntPtr; var num_image_formats: UInt32): clErrorCode;
    external 'OpenCL' name 'clGetSupportedImageFormats';
    private static function ntv_GetSupportedImageFormats_4(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; num_entries: UInt32; image_formats: IntPtr; num_image_formats: IntPtr): clErrorCode;
    external 'OpenCL' name 'clGetSupportedImageFormats';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetSupportedImageFormats(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; num_entries: UInt32; var image_formats: cl_image_format; var num_image_formats: UInt32): clErrorCode :=
      ntv_GetSupportedImageFormats_1(context, flags, image_type, num_entries, image_formats, num_image_formats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetSupportedImageFormats(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; num_entries: UInt32; var image_formats: cl_image_format; num_image_formats: IntPtr): clErrorCode :=
      ntv_GetSupportedImageFormats_2(context, flags, image_type, num_entries, image_formats, num_image_formats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetSupportedImageFormats(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; num_entries: UInt32; image_formats: IntPtr; var num_image_formats: UInt32): clErrorCode :=
      ntv_GetSupportedImageFormats_3(context, flags, image_type, num_entries, image_formats, num_image_formats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetSupportedImageFormats(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; num_entries: UInt32; image_formats: IntPtr; num_image_formats: IntPtr): clErrorCode :=
      ntv_GetSupportedImageFormats_4(context, flags, image_type, num_entries, image_formats, num_image_formats);
    
    // added in cl1.2
    private static function ntv_LinkProgram_1(context: cl_context; num_devices: UInt32; var device_list: cl_device_id; options: IntPtr; num_input_programs: UInt32; var input_programs: cl_program; pfn_notify: clProgramCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_program;
    external 'OpenCL' name 'clLinkProgram';
    private static function ntv_LinkProgram_2(context: cl_context; num_devices: UInt32; var device_list: cl_device_id; options: IntPtr; num_input_programs: UInt32; input_programs: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_program;
    external 'OpenCL' name 'clLinkProgram';
    private static function ntv_LinkProgram_3(context: cl_context; num_devices: UInt32; device_list: IntPtr; options: IntPtr; num_input_programs: UInt32; var input_programs: cl_program; pfn_notify: clProgramCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_program;
    external 'OpenCL' name 'clLinkProgram';
    private static function ntv_LinkProgram_4(context: cl_context; num_devices: UInt32; device_list: IntPtr; options: IntPtr; num_input_programs: UInt32; input_programs: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_program;
    external 'OpenCL' name 'clLinkProgram';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function LinkProgram(context: cl_context; num_devices: UInt32; device_list: array of cl_device_id; options: string; num_input_programs: UInt32; input_programs: array of cl_program; pfn_notify: clProgramCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_program;
    begin
      var options_str_ptr := Marshal.StringToHGlobalAnsi(options);
      try
        Result := LinkProgram(context, num_devices, device_list, options_str_ptr, num_input_programs, input_programs, pfn_notify, user_data, errcode_ret);
      finally
        Marshal.FreeHGlobal(options_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function LinkProgram(context: cl_context; num_devices: UInt32; device_list: array of cl_device_id; options: IntPtr; num_input_programs: UInt32; input_programs: array of cl_program; pfn_notify: clProgramCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_program;
    type PCl_device_id = ^cl_device_id;
    type PCl_program = ^cl_program;
    begin
      Result := if (input_programs<>nil) and (input_programs.Length<>0) then
        if (device_list<>nil) and (device_list.Length<>0) then
          ntv_LinkProgram_1(context, num_devices, device_list[0], options, num_input_programs, input_programs[0], pfn_notify, user_data, errcode_ret) else
          ntv_LinkProgram_1(context, num_devices, PCl_device_id(nil)^, options, num_input_programs, input_programs[0], pfn_notify, user_data, errcode_ret) else
        if (device_list<>nil) and (device_list.Length<>0) then
          ntv_LinkProgram_1(context, num_devices, device_list[0], options, num_input_programs, PCl_program(nil)^, pfn_notify, user_data, errcode_ret) else
          ntv_LinkProgram_1(context, num_devices, PCl_device_id(nil)^, options, num_input_programs, PCl_program(nil)^, pfn_notify, user_data, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function LinkProgram(context: cl_context; num_devices: UInt32; var device_list: cl_device_id; options: string; num_input_programs: UInt32; var input_programs: cl_program; pfn_notify: clProgramCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_program;
    begin
      var options_str_ptr := Marshal.StringToHGlobalAnsi(options);
      try
        Result := ntv_LinkProgram_1(context, num_devices, device_list, options_str_ptr, num_input_programs, input_programs, pfn_notify, user_data, errcode_ret);
      finally
        Marshal.FreeHGlobal(options_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function LinkProgram(context: cl_context; num_devices: UInt32; var device_list: cl_device_id; options: string; num_input_programs: UInt32; input_programs: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_program;
    begin
      var options_str_ptr := Marshal.StringToHGlobalAnsi(options);
      try
        Result := ntv_LinkProgram_2(context, num_devices, device_list, options_str_ptr, num_input_programs, input_programs, pfn_notify, user_data, errcode_ret);
      finally
        Marshal.FreeHGlobal(options_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function LinkProgram(context: cl_context; num_devices: UInt32; var device_list: cl_device_id; options: IntPtr; num_input_programs: UInt32; var input_programs: cl_program; pfn_notify: clProgramCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_program :=
      ntv_LinkProgram_1(context, num_devices, device_list, options, num_input_programs, input_programs, pfn_notify, user_data, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function LinkProgram(context: cl_context; num_devices: UInt32; var device_list: cl_device_id; options: IntPtr; num_input_programs: UInt32; input_programs: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_program :=
      ntv_LinkProgram_2(context, num_devices, device_list, options, num_input_programs, input_programs, pfn_notify, user_data, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function LinkProgram(context: cl_context; num_devices: UInt32; device_list: IntPtr; options: string; num_input_programs: UInt32; var input_programs: cl_program; pfn_notify: clProgramCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_program;
    begin
      var options_str_ptr := Marshal.StringToHGlobalAnsi(options);
      try
        Result := ntv_LinkProgram_3(context, num_devices, device_list, options_str_ptr, num_input_programs, input_programs, pfn_notify, user_data, errcode_ret);
      finally
        Marshal.FreeHGlobal(options_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function LinkProgram(context: cl_context; num_devices: UInt32; device_list: IntPtr; options: string; num_input_programs: UInt32; input_programs: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_program;
    begin
      var options_str_ptr := Marshal.StringToHGlobalAnsi(options);
      try
        Result := ntv_LinkProgram_4(context, num_devices, device_list, options_str_ptr, num_input_programs, input_programs, pfn_notify, user_data, errcode_ret);
      finally
        Marshal.FreeHGlobal(options_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function LinkProgram(context: cl_context; num_devices: UInt32; device_list: IntPtr; options: IntPtr; num_input_programs: UInt32; var input_programs: cl_program; pfn_notify: clProgramCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_program :=
      ntv_LinkProgram_3(context, num_devices, device_list, options, num_input_programs, input_programs, pfn_notify, user_data, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function LinkProgram(context: cl_context; num_devices: UInt32; device_list: IntPtr; options: IntPtr; num_input_programs: UInt32; input_programs: IntPtr; pfn_notify: clProgramCallback; user_data: IntPtr; var errcode_ret: clErrorCode): cl_program :=
      ntv_LinkProgram_4(context, num_devices, device_list, options, num_input_programs, input_programs, pfn_notify, user_data, errcode_ret);
    
    // added in cl1.0
    private static function ntv_ReleaseCommandQueue_1(command_queue: cl_command_queue): clErrorCode;
    external 'OpenCL' name 'clReleaseCommandQueue';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ReleaseCommandQueue(command_queue: cl_command_queue): clErrorCode :=
      ntv_ReleaseCommandQueue_1(command_queue);
    
    // added in cl1.0
    private static function ntv_ReleaseContext_1(context: cl_context): clErrorCode;
    external 'OpenCL' name 'clReleaseContext';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ReleaseContext(context: cl_context): clErrorCode :=
      ntv_ReleaseContext_1(context);
    
    // added in cl1.2
    private static function ntv_ReleaseDevice_1(device: cl_device_id): clErrorCode;
    external 'OpenCL' name 'clReleaseDevice';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ReleaseDevice(device: cl_device_id): clErrorCode :=
      ntv_ReleaseDevice_1(device);
    
    // added in cl1.0
    private static function ntv_ReleaseEvent_1(&event: cl_event): clErrorCode;
    external 'OpenCL' name 'clReleaseEvent';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ReleaseEvent(&event: cl_event): clErrorCode :=
      ntv_ReleaseEvent_1(&event);
    
    // added in cl1.0
    private static function ntv_ReleaseKernel_1(kernel: cl_kernel): clErrorCode;
    external 'OpenCL' name 'clReleaseKernel';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ReleaseKernel(kernel: cl_kernel): clErrorCode :=
      ntv_ReleaseKernel_1(kernel);
    
    // added in cl1.0
    private static function ntv_ReleaseMemObject_1(memobj: cl_mem): clErrorCode;
    external 'OpenCL' name 'clReleaseMemObject';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ReleaseMemObject(memobj: cl_mem): clErrorCode :=
      ntv_ReleaseMemObject_1(memobj);
    
    // added in cl1.0
    private static function ntv_ReleaseProgram_1(&program: cl_program): clErrorCode;
    external 'OpenCL' name 'clReleaseProgram';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ReleaseProgram(&program: cl_program): clErrorCode :=
      ntv_ReleaseProgram_1(&program);
    
    // added in cl1.0
    private static function ntv_ReleaseSampler_1(sampler: cl_sampler): clErrorCode;
    external 'OpenCL' name 'clReleaseSampler';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ReleaseSampler(sampler: cl_sampler): clErrorCode :=
      ntv_ReleaseSampler_1(sampler);
    
    // added in cl1.0
    private static function ntv_RetainCommandQueue_1(command_queue: cl_command_queue): clErrorCode;
    external 'OpenCL' name 'clRetainCommandQueue';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function RetainCommandQueue(command_queue: cl_command_queue): clErrorCode :=
      ntv_RetainCommandQueue_1(command_queue);
    
    // added in cl1.0
    private static function ntv_RetainContext_1(context: cl_context): clErrorCode;
    external 'OpenCL' name 'clRetainContext';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function RetainContext(context: cl_context): clErrorCode :=
      ntv_RetainContext_1(context);
    
    // added in cl1.2
    private static function ntv_RetainDevice_1(device: cl_device_id): clErrorCode;
    external 'OpenCL' name 'clRetainDevice';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function RetainDevice(device: cl_device_id): clErrorCode :=
      ntv_RetainDevice_1(device);
    
    // added in cl1.0
    private static function ntv_RetainEvent_1(&event: cl_event): clErrorCode;
    external 'OpenCL' name 'clRetainEvent';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function RetainEvent(&event: cl_event): clErrorCode :=
      ntv_RetainEvent_1(&event);
    
    // added in cl1.0
    private static function ntv_RetainKernel_1(kernel: cl_kernel): clErrorCode;
    external 'OpenCL' name 'clRetainKernel';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function RetainKernel(kernel: cl_kernel): clErrorCode :=
      ntv_RetainKernel_1(kernel);
    
    // added in cl1.0
    private static function ntv_RetainMemObject_1(memobj: cl_mem): clErrorCode;
    external 'OpenCL' name 'clRetainMemObject';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function RetainMemObject(memobj: cl_mem): clErrorCode :=
      ntv_RetainMemObject_1(memobj);
    
    // added in cl1.0
    private static function ntv_RetainProgram_1(&program: cl_program): clErrorCode;
    external 'OpenCL' name 'clRetainProgram';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function RetainProgram(&program: cl_program): clErrorCode :=
      ntv_RetainProgram_1(&program);
    
    // added in cl1.0
    private static function ntv_RetainSampler_1(sampler: cl_sampler): clErrorCode;
    external 'OpenCL' name 'clRetainSampler';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function RetainSampler(sampler: cl_sampler): clErrorCode :=
      ntv_RetainSampler_1(sampler);
    
    // added in cl1.0
    private static function ntv_SetCommandQueueProperty_1(command_queue: cl_command_queue; properties: clCommandQueueProperties; enable: clBool; var old_properties: clCommandQueueProperties): clErrorCode;
    external 'OpenCL' name 'clSetCommandQueueProperty';
    private static function ntv_SetCommandQueueProperty_2(command_queue: cl_command_queue; properties: clCommandQueueProperties; enable: clBool; old_properties: IntPtr): clErrorCode;
    external 'OpenCL' name 'clSetCommandQueueProperty';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetCommandQueueProperty(command_queue: cl_command_queue; properties: clCommandQueueProperties; enable: clBool; old_properties: array of clCommandQueueProperties): clErrorCode;
    type PClCommandQueueProperties = ^clCommandQueueProperties;
    begin
      Result := if (old_properties<>nil) and (old_properties.Length<>0) then
        ntv_SetCommandQueueProperty_1(command_queue, properties, enable, old_properties[0]) else
        ntv_SetCommandQueueProperty_1(command_queue, properties, enable, PClCommandQueueProperties(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetCommandQueueProperty(command_queue: cl_command_queue; properties: clCommandQueueProperties; enable: clBool; var old_properties: clCommandQueueProperties): clErrorCode :=
      ntv_SetCommandQueueProperty_1(command_queue, properties, enable, old_properties);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetCommandQueueProperty(command_queue: cl_command_queue; properties: clCommandQueueProperties; enable: clBool; old_properties: IntPtr): clErrorCode :=
      ntv_SetCommandQueueProperty_2(command_queue, properties, enable, old_properties);
    
    // added in cl3.0
    private static function ntv_SetContextDestructorCallback_1(context: cl_context; pfn_notify: clContextDestructorCallback; user_data: IntPtr): clErrorCode;
    external 'OpenCL' name 'clSetContextDestructorCallback';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetContextDestructorCallback(context: cl_context; pfn_notify: clContextDestructorCallback; user_data: IntPtr): clErrorCode :=
      ntv_SetContextDestructorCallback_1(context, pfn_notify, user_data);
    
    // added in cl2.1
    private static function ntv_SetDefaultDeviceCommandQueue_1(context: cl_context; device: cl_device_id; command_queue: cl_command_queue): clErrorCode;
    external 'OpenCL' name 'clSetDefaultDeviceCommandQueue';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetDefaultDeviceCommandQueue(context: cl_context; device: cl_device_id; command_queue: cl_command_queue): clErrorCode :=
      ntv_SetDefaultDeviceCommandQueue_1(context, device, command_queue);
    
    // added in cl1.1
    private static function ntv_SetEventCallback_1(&event: cl_event; command_exec_callback_type: clCommandExecutionStatus; pfn_notify: clEventCallback; user_data: IntPtr): clErrorCode;
    external 'OpenCL' name 'clSetEventCallback';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetEventCallback(&event: cl_event; command_exec_callback_type: clCommandExecutionStatus; pfn_notify: clEventCallback; user_data: IntPtr): clErrorCode :=
      ntv_SetEventCallback_1(&event, command_exec_callback_type, pfn_notify, user_data);
    
    // added in cl1.0
    private static function ntv_SetKernelArg_1(kernel: cl_kernel; arg_index: UInt32; arg_size: UIntPtr; var arg_value: Byte): clErrorCode;
    external 'OpenCL' name 'clSetKernelArg';
    private static function ntv_SetKernelArg_2(kernel: cl_kernel; arg_index: UInt32; arg_size: UIntPtr; arg_value: pointer): clErrorCode;
    external 'OpenCL' name 'clSetKernelArg';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetKernelArg<T>(kernel: cl_kernel; arg_index: UInt32; arg_size: UIntPtr; var arg_value: T): clErrorCode; where T: record;
    begin
      Result := ntv_SetKernelArg_1(kernel, arg_index, arg_size, PByte(pointer(@arg_value))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetKernelArg(kernel: cl_kernel; arg_index: UInt32; arg_size: UIntPtr; arg_value: pointer): clErrorCode :=
      ntv_SetKernelArg_2(kernel, arg_index, arg_size, arg_value);
    
    // added in cl2.0
    private static function ntv_SetKernelArgSVMPointer_1(kernel: cl_kernel; arg_index: UInt32; arg_value: IntPtr): clErrorCode;
    external 'OpenCL' name 'clSetKernelArgSVMPointer';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetKernelArgSVMPointer(kernel: cl_kernel; arg_index: UInt32; arg_value: IntPtr): clErrorCode :=
      ntv_SetKernelArgSVMPointer_1(kernel, arg_index, arg_value);
    
    // added in cl2.0
    private static function ntv_SetKernelExecInfo_1(kernel: cl_kernel; param_name: clKernelExecInfo; param_value_size: UIntPtr; var param_value: Byte): clErrorCode;
    external 'OpenCL' name 'clSetKernelExecInfo';
    private static function ntv_SetKernelExecInfo_2(kernel: cl_kernel; param_name: clKernelExecInfo; param_value_size: UIntPtr; param_value: pointer): clErrorCode;
    external 'OpenCL' name 'clSetKernelExecInfo';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetKernelExecInfo<TInp>(kernel: cl_kernel; param_name: clKernelExecInfo; param_value_size: UIntPtr; var param_value: TInp): clErrorCode; where TInp: record;
    begin
      Result := ntv_SetKernelExecInfo_1(kernel, param_name, param_value_size, PByte(pointer(@param_value))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetKernelExecInfo_KERNEL_EXEC_INFO_SVM_PTRS(kernel: cl_kernel; param_value: array of IntPtr): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value.Length*Marshal.SizeOf&<IntPtr>);
      Result := SetKernelExecInfo(kernel, clKernelExecInfo.KERNEL_EXEC_INFO_SVM_PTRS, param_value_sz,param_value[0]);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetKernelExecInfo_KERNEL_EXEC_INFO_SVM_PTRS(kernel: cl_kernel; param_value_count: UInt32; var param_value: IntPtr): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<IntPtr>);
      Result := SetKernelExecInfo(kernel, clKernelExecInfo.KERNEL_EXEC_INFO_SVM_PTRS, param_value_sz,param_value);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetKernelExecInfo_KERNEL_EXEC_INFO_SVM_FINE_GRAIN_SYSTEM(kernel: cl_kernel; param_value: clBool): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      Result := SetKernelExecInfo(kernel, clKernelExecInfo.KERNEL_EXEC_INFO_SVM_FINE_GRAIN_SYSTEM, param_value_sz,param_value);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetKernelExecInfo_KERNEL_EXEC_INFO_WORKGROUP_BATCH_SIZE(kernel: cl_kernel; param_value: UInt32): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      Result := SetKernelExecInfo(kernel, clKernelExecInfo.KERNEL_EXEC_INFO_WORKGROUP_BATCH_SIZE, param_value_sz,param_value);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetKernelExecInfo_KERNEL_EXEC_INFO_WORKGROUP_BATCH_SIZE_MODIFIER(kernel: cl_kernel; param_value: Int32): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<Int32>);
      Result := SetKernelExecInfo(kernel, clKernelExecInfo.KERNEL_EXEC_INFO_WORKGROUP_BATCH_SIZE_MODIFIER, param_value_sz,param_value);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetKernelExecInfo_KERNEL_EXEC_INFO_WARP_COUNT_LIMIT(kernel: cl_kernel; param_value: UInt32): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      Result := SetKernelExecInfo(kernel, clKernelExecInfo.KERNEL_EXEC_INFO_WARP_COUNT_LIMIT, param_value_sz,param_value);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetKernelExecInfo_KERNEL_EXEC_INFO_COMPUTE_UNIT_MAX_QUEUED_BATCHES(kernel: cl_kernel; param_value: UInt32): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      Result := SetKernelExecInfo(kernel, clKernelExecInfo.KERNEL_EXEC_INFO_COMPUTE_UNIT_MAX_QUEUED_BATCHES, param_value_sz,param_value);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetKernelExecInfo_KERNEL_EXEC_INFO_INDIRECT_HOST_ACCESS(kernel: cl_kernel; param_value: clBool): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      Result := SetKernelExecInfo(kernel, clKernelExecInfo.KERNEL_EXEC_INFO_INDIRECT_HOST_ACCESS, param_value_sz,param_value);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetKernelExecInfo_KERNEL_EXEC_INFO_INDIRECT_DEVICE_ACCESS(kernel: cl_kernel; param_value: clBool): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      Result := SetKernelExecInfo(kernel, clKernelExecInfo.KERNEL_EXEC_INFO_INDIRECT_DEVICE_ACCESS, param_value_sz,param_value);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetKernelExecInfo_KERNEL_EXEC_INFO_INDIRECT_SHARED_ACCESS(kernel: cl_kernel; param_value: clBool): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      Result := SetKernelExecInfo(kernel, clKernelExecInfo.KERNEL_EXEC_INFO_INDIRECT_SHARED_ACCESS, param_value_sz,param_value);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetKernelExecInfo_KERNEL_EXEC_INFO_USM_PTRS(kernel: cl_kernel; param_value: array of IntPtr): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value.Length*Marshal.SizeOf&<IntPtr>);
      Result := SetKernelExecInfo(kernel, clKernelExecInfo.KERNEL_EXEC_INFO_USM_PTRS, param_value_sz,param_value[0]);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetKernelExecInfo_KERNEL_EXEC_INFO_USM_PTRS(kernel: cl_kernel; param_value_count: UInt32; var param_value: IntPtr): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<IntPtr>);
      Result := SetKernelExecInfo(kernel, clKernelExecInfo.KERNEL_EXEC_INFO_USM_PTRS, param_value_sz,param_value);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetKernelExecInfo(kernel: cl_kernel; param_name: clKernelExecInfo; param_value_size: UIntPtr; param_value: pointer): clErrorCode :=
      ntv_SetKernelExecInfo_2(kernel, param_name, param_value_size, param_value);
    
    // added in cl1.1
    private static function ntv_SetMemObjectDestructorCallback_1(memobj: cl_mem; pfn_notify: clMemObjectDestructorCallback; user_data: IntPtr): clErrorCode;
    external 'OpenCL' name 'clSetMemObjectDestructorCallback';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetMemObjectDestructorCallback(memobj: cl_mem; pfn_notify: clMemObjectDestructorCallback; user_data: IntPtr): clErrorCode :=
      ntv_SetMemObjectDestructorCallback_1(memobj, pfn_notify, user_data);
    
    // added in cl2.2
    private static function ntv_SetProgramReleaseCallback_1(&program: cl_program; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode;
    external 'OpenCL' name 'clSetProgramReleaseCallback';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetProgramReleaseCallback(&program: cl_program; pfn_notify: clProgramCallback; user_data: IntPtr): clErrorCode :=
      ntv_SetProgramReleaseCallback_1(&program, pfn_notify, user_data);
    
    // added in cl2.2
    private static function ntv_SetProgramSpecializationConstant_1(&program: cl_program; spec_id: UInt32; spec_size: UIntPtr; var spec_value: Byte): clErrorCode;
    external 'OpenCL' name 'clSetProgramSpecializationConstant';
    private static function ntv_SetProgramSpecializationConstant_2(&program: cl_program; spec_id: UInt32; spec_size: UIntPtr; spec_value: pointer): clErrorCode;
    external 'OpenCL' name 'clSetProgramSpecializationConstant';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetProgramSpecializationConstant<T>(&program: cl_program; spec_id: UInt32; spec_size: UIntPtr; spec_value: array of T): clErrorCode; where T: record;
    type PT = ^T;
    begin
      Result := if (spec_value<>nil) and (spec_value.Length<>0) then
        SetProgramSpecializationConstant(&program, spec_id, spec_size, spec_value[0]) else
        SetProgramSpecializationConstant(&program, spec_id, spec_size, PT(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetProgramSpecializationConstant<T>(&program: cl_program; spec_id: UInt32; spec_size: UIntPtr; var spec_value: T): clErrorCode; where T: record;
    begin
      Result := ntv_SetProgramSpecializationConstant_1(&program, spec_id, spec_size, PByte(pointer(@spec_value))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetProgramSpecializationConstant(&program: cl_program; spec_id: UInt32; spec_size: UIntPtr; spec_value: pointer): clErrorCode :=
      ntv_SetProgramSpecializationConstant_2(&program, spec_id, spec_size, spec_value);
    
    // added in cl1.1
    private static function ntv_SetUserEventStatus_1(&event: cl_event; execution_status: clCommandExecutionStatus): clErrorCode;
    external 'OpenCL' name 'clSetUserEventStatus';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetUserEventStatus(&event: cl_event; execution_status: clCommandExecutionStatus): clErrorCode :=
      ntv_SetUserEventStatus_1(&event, execution_status);
    
    // added in cl2.0
    private static function ntv_SVMAlloc_1(context: cl_context; flags: clSvmMemFlags; size: UIntPtr; alignment: UInt32): IntPtr;
    external 'OpenCL' name 'clSVMAlloc';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SVMAlloc(context: cl_context; flags: clSvmMemFlags; size: UIntPtr; alignment: UInt32): IntPtr :=
      ntv_SVMAlloc_1(context, flags, size, alignment);
    
    // added in cl2.0
    private static procedure ntv_SVMFree_1(context: cl_context; svm_pointer: IntPtr);
    external 'OpenCL' name 'clSVMFree';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static procedure SVMFree(context: cl_context; svm_pointer: IntPtr) :=
      ntv_SVMFree_1(context, svm_pointer);
    
    // added in cl1.0
    private static function ntv_UnloadCompiler_1: clErrorCode;
    external 'OpenCL' name 'clUnloadCompiler';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function UnloadCompiler: clErrorCode :=
      ntv_UnloadCompiler_1;
    
    // added in cl1.2
    private static function ntv_UnloadPlatformCompiler_1(platform: cl_platform_id): clErrorCode;
    external 'OpenCL' name 'clUnloadPlatformCompiler';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function UnloadPlatformCompiler(platform: cl_platform_id): clErrorCode :=
      ntv_UnloadPlatformCompiler_1(platform);
    
    // added in cl1.0
    private static function ntv_WaitForEvents_1(num_events: UInt32; var event_list: cl_event): clErrorCode;
    external 'OpenCL' name 'clWaitForEvents';
    private static function ntv_WaitForEvents_2(num_events: UInt32; event_list: IntPtr): clErrorCode;
    external 'OpenCL' name 'clWaitForEvents';
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function WaitForEvents(num_events: UInt32; event_list: array of cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_list<>nil) and (event_list.Length<>0) then
        ntv_WaitForEvents_1(num_events, event_list[0]) else
        ntv_WaitForEvents_1(num_events, PCl_event(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function WaitForEvents(num_events: UInt32; var event_list: cl_event): clErrorCode :=
      ntv_WaitForEvents_1(num_events, event_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function WaitForEvents(num_events: UInt32; event_list: IntPtr): clErrorCode :=
      ntv_WaitForEvents_2(num_events, event_list);
    
  end;
  
  {$endregion Подпрограммы ядра}
  
  {$region Подпрограммы расширений}
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clLoaderInfo = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clLoaderInfo(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_loader_info';
    
    public GetICDLoaderInfoOCLICD_adr := GetProcAddress('clGetICDLoaderInfoOCLICD');
    private ntv_GetICDLoaderInfoOCLICD_1 := GetProcOrNil&<function(param_name: clIcdlInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode>(GetICDLoaderInfoOCLICD_adr);
    private ntv_GetICDLoaderInfoOCLICD_2 := GetProcOrNil&<function(param_name: clIcdlInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode>(GetICDLoaderInfoOCLICD_adr);
    private ntv_GetICDLoaderInfoOCLICD_3 := GetProcOrNil&<function(param_name: clIcdlInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode>(GetICDLoaderInfoOCLICD_adr);
    private ntv_GetICDLoaderInfoOCLICD_4 := GetProcOrNil&<function(param_name: clIcdlInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode>(GetICDLoaderInfoOCLICD_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetICDLoaderInfoOCLICD<T>(param_name: clIcdlInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetICDLoaderInfoOCLICD_1(param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetICDLoaderInfoOCLICD<T>(param_name: clIcdlInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetICDLoaderInfoOCLICD_2(param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetICDLoaderInfoOCLICD(param_name: clIcdlInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetICDLoaderInfoOCLICD_3(param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetICDLoaderInfoOCLICD(param_name: clIcdlInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetICDLoaderInfoOCLICD_4(param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetICDLoaderInfoOCLICD_ICDL_OCL_VERSION(var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetICDLoaderInfoOCLICD_3(clIcdlInfo.ICDL_OCL_VERSION, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetICDLoaderInfoOCLICD_4(clIcdlInfo.ICDL_OCL_VERSION, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetICDLoaderInfoOCLICD_ICDL_VERSION(var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetICDLoaderInfoOCLICD_3(clIcdlInfo.ICDL_VERSION, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetICDLoaderInfoOCLICD_4(clIcdlInfo.ICDL_VERSION, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetICDLoaderInfoOCLICD_ICDL_NAME(var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetICDLoaderInfoOCLICD_3(clIcdlInfo.ICDL_NAME, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetICDLoaderInfoOCLICD_4(clIcdlInfo.ICDL_NAME, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetICDLoaderInfoOCLICD_ICDL_VENDOR(var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetICDLoaderInfoOCLICD_3(clIcdlInfo.ICDL_VENDOR, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetICDLoaderInfoOCLICD_4(clIcdlInfo.ICDL_VENDOR, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clLoaderLayers = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clLoaderLayers(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_loader_layers';
    
    public GetLayerInfo_adr := GetProcAddress('clGetLayerInfo');
    private ntv_GetLayerInfo_1 := GetProcOrNil&<function(param_name: clLayerInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode>(GetLayerInfo_adr);
    private ntv_GetLayerInfo_2 := GetProcOrNil&<function(param_name: clLayerInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode>(GetLayerInfo_adr);
    private ntv_GetLayerInfo_3 := GetProcOrNil&<function(param_name: clLayerInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode>(GetLayerInfo_adr);
    private ntv_GetLayerInfo_4 := GetProcOrNil&<function(param_name: clLayerInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode>(GetLayerInfo_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetLayerInfo<T>(param_name: clLayerInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetLayerInfo_1(param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetLayerInfo<T>(param_name: clLayerInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetLayerInfo_2(param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetLayerInfo(param_name: clLayerInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetLayerInfo_3(param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetLayerInfo(param_name: clLayerInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetLayerInfo_4(param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetLayerInfo_LAYER_API_VERSION(var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetLayerInfo(clLayerInfo.LAYER_API_VERSION, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetLayerInfo_LAYER_NAME(var param_value: string): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetLayerInfo_3(clLayerInfo.LAYER_NAME, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := Marshal.AllocHGlobal(IntPtr(param_value_sz.ToPointer));
      try
        Result := ntv_GetLayerInfo_4(clLayerInfo.LAYER_NAME, param_value_sz,param_value_temp_res.ToPointer,IntPtr.Zero);
        param_value := Marshal.PtrToStringAnsi(param_value_temp_res);
      finally
        Marshal.FreeHGlobal(param_value_temp_res);
      end;
    end;
    
    public InitLayer_adr := GetProcAddress('clInitLayer');
    private ntv_InitLayer_1 := GetProcOrNil&<function(num_entries: UInt32; target_dispatch: cl_icd_dispatch; var num_entries_ret: UInt32; var layer_dispatch_ret: cl_icd_dispatch): clErrorCode>(InitLayer_adr);
    private ntv_InitLayer_2 := GetProcOrNil&<function(num_entries: UInt32; target_dispatch: cl_icd_dispatch; var num_entries_ret: UInt32; layer_dispatch_ret: IntPtr): clErrorCode>(InitLayer_adr);
    private ntv_InitLayer_3 := GetProcOrNil&<function(num_entries: UInt32; target_dispatch: cl_icd_dispatch; num_entries_ret: IntPtr; var layer_dispatch_ret: cl_icd_dispatch): clErrorCode>(InitLayer_adr);
    private ntv_InitLayer_4 := GetProcOrNil&<function(num_entries: UInt32; target_dispatch: cl_icd_dispatch; num_entries_ret: IntPtr; layer_dispatch_ret: IntPtr): clErrorCode>(InitLayer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function InitLayer(num_entries: UInt32; target_dispatch: cl_icd_dispatch; var num_entries_ret: UInt32; var layer_dispatch_ret: cl_icd_dispatch): clErrorCode :=
      ntv_InitLayer_1(num_entries, target_dispatch, num_entries_ret, layer_dispatch_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function InitLayer(num_entries: UInt32; target_dispatch: cl_icd_dispatch; var num_entries_ret: UInt32; layer_dispatch_ret: IntPtr): clErrorCode :=
      ntv_InitLayer_2(num_entries, target_dispatch, num_entries_ret, layer_dispatch_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function InitLayer(num_entries: UInt32; target_dispatch: cl_icd_dispatch; num_entries_ret: IntPtr; var layer_dispatch_ret: cl_icd_dispatch): clErrorCode :=
      ntv_InitLayer_3(num_entries, target_dispatch, num_entries_ret, layer_dispatch_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function InitLayer(num_entries: UInt32; target_dispatch: cl_icd_dispatch; num_entries_ret: IntPtr; layer_dispatch_ret: IntPtr): clErrorCode :=
      ntv_InitLayer_4(num_entries, target_dispatch, num_entries_ret, layer_dispatch_ret);
    
  end;
  
  ///
  clDeviceAttributeQueryAMD = static class
    public const ExtensionString = 'cl_amd_device_attribute_query';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clContextLoggingFunctionsAPPLE = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clContextLoggingFunctionsAPPLE(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_APPLE_ContextLoggingFunctions';
    
    public LogMessagesToSystemLogAPPLE_adr := GetProcAddress('clLogMessagesToSystemLogAPPLE');
    private ntv_LogMessagesToSystemLogAPPLE_1 := GetProcOrNil&<procedure(errstr: IntPtr; private_info: IntPtr; cb: UIntPtr; user_data: IntPtr)>(LogMessagesToSystemLogAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LogMessagesToSystemLogAPPLE(errstr: string; private_info: IntPtr; cb: UIntPtr; user_data: IntPtr);
    begin
      var errstr_str_ptr := Marshal.StringToHGlobalAnsi(errstr);
      try
        ntv_LogMessagesToSystemLogAPPLE_1(errstr_str_ptr, private_info, cb, user_data);
      finally
        Marshal.FreeHGlobal(errstr_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LogMessagesToSystemLogAPPLE(errstr: IntPtr; private_info: IntPtr; cb: UIntPtr; user_data: IntPtr) :=
      ntv_LogMessagesToSystemLogAPPLE_1(errstr, private_info, cb, user_data);
    
    public LogMessagesToStdoutAPPLE_adr := GetProcAddress('clLogMessagesToStdoutAPPLE');
    private ntv_LogMessagesToStdoutAPPLE_1 := GetProcOrNil&<procedure(errstr: IntPtr; private_info: IntPtr; cb: UIntPtr; user_data: IntPtr)>(LogMessagesToStdoutAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LogMessagesToStdoutAPPLE(errstr: string; private_info: IntPtr; cb: UIntPtr; user_data: IntPtr);
    begin
      var errstr_str_ptr := Marshal.StringToHGlobalAnsi(errstr);
      try
        ntv_LogMessagesToStdoutAPPLE_1(errstr_str_ptr, private_info, cb, user_data);
      finally
        Marshal.FreeHGlobal(errstr_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LogMessagesToStdoutAPPLE(errstr: IntPtr; private_info: IntPtr; cb: UIntPtr; user_data: IntPtr) :=
      ntv_LogMessagesToStdoutAPPLE_1(errstr, private_info, cb, user_data);
    
    public LogMessagesToStderrAPPLE_adr := GetProcAddress('clLogMessagesToStderrAPPLE');
    private ntv_LogMessagesToStderrAPPLE_1 := GetProcOrNil&<procedure(errstr: IntPtr; private_info: IntPtr; cb: UIntPtr; user_data: IntPtr)>(LogMessagesToStderrAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LogMessagesToStderrAPPLE(errstr: string; private_info: IntPtr; cb: UIntPtr; user_data: IntPtr);
    begin
      var errstr_str_ptr := Marshal.StringToHGlobalAnsi(errstr);
      try
        ntv_LogMessagesToStderrAPPLE_1(errstr_str_ptr, private_info, cb, user_data);
      finally
        Marshal.FreeHGlobal(errstr_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LogMessagesToStderrAPPLE(errstr: IntPtr; private_info: IntPtr; cb: UIntPtr; user_data: IntPtr) :=
      ntv_LogMessagesToStderrAPPLE_1(errstr, private_info, cb, user_data);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clSetMemObjectDestructorAPPLE = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clSetMemObjectDestructorAPPLE(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_APPLE_SetMemObjectDestructor';
    
    public SetMemObjectDestructorAPPLE_adr := GetProcAddress('clSetMemObjectDestructorAPPLE');
    private ntv_SetMemObjectDestructorAPPLE_1 := GetProcOrNil&<function(memobj: cl_mem; pfn_notify: clMemObjectDestructorCallback; user_data: IntPtr): clErrorCode>(SetMemObjectDestructorAPPLE_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetMemObjectDestructorAPPLE(memobj: cl_mem; pfn_notify: clMemObjectDestructorCallback; user_data: IntPtr): clErrorCode :=
      ntv_SetMemObjectDestructorAPPLE_1(memobj, pfn_notify, user_data);
    
  end;
  
  ///
  clControlledKernelTerminationARM = static class
    public const ExtensionString = 'cl_arm_controlled_kernel_termination';
  end;
  
  ///
  clGetCoreIdARM = static class
    public const ExtensionString = 'cl_arm_get_core_id';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clImportMemoryARM = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clImportMemoryARM(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_arm_import_memory';
    
    public ImportMemoryARM_adr := GetProcAddress('clImportMemoryARM');
    private ntv_ImportMemoryARM_1 := GetProcOrNil&<function(context: cl_context; flags: clMemFlags; var properties: clImportProperties; memory: IntPtr; size: UIntPtr; var errcode_ret: clErrorCode): cl_mem>(ImportMemoryARM_adr);
    private ntv_ImportMemoryARM_2 := GetProcOrNil&<function(context: cl_context; flags: clMemFlags; properties: IntPtr; memory: IntPtr; size: UIntPtr; var errcode_ret: clErrorCode): cl_mem>(ImportMemoryARM_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ImportMemoryARM(context: cl_context; flags: clMemFlags; properties: array of clImportProperties; memory: IntPtr; size: UIntPtr; var errcode_ret: clErrorCode): cl_mem;
    type PClImportProperties = ^clImportProperties;
    begin
      Result := if (properties<>nil) and (properties.Length<>0) then
        ntv_ImportMemoryARM_1(context, flags, properties[0], memory, size, errcode_ret) else
        ntv_ImportMemoryARM_1(context, flags, PClImportProperties(nil)^, memory, size, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ImportMemoryARM(context: cl_context; flags: clMemFlags; var properties: clImportProperties; memory: IntPtr; size: UIntPtr; var errcode_ret: clErrorCode): cl_mem :=
      ntv_ImportMemoryARM_1(context, flags, properties, memory, size, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ImportMemoryARM(context: cl_context; flags: clMemFlags; properties: IntPtr; memory: IntPtr; size: UIntPtr; var errcode_ret: clErrorCode): cl_mem :=
      ntv_ImportMemoryARM_2(context, flags, properties, memory, size, errcode_ret);
    
  end;
  
  ///
  clJobSlotSelectionARM = static class
    public const ExtensionString = 'cl_arm_job_slot_selection';
  end;
  
  ///
  clPrintfARM = static class
    public const ExtensionString = 'cl_arm_printf';
  end;
  
  ///
  clProtectedMemoryAllocationARM = static class
    public const ExtensionString = 'cl_arm_protected_memory_allocation';
  end;
  
  ///
  clSchedulingControlsARM = static class
    public const ExtensionString = 'cl_arm_scheduling_controls';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clSharedVirtualMemoryARM = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clSharedVirtualMemoryARM(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_arm_shared_virtual_memory';
    
    public SVMAllocARM_adr := GetProcAddress('clSVMAllocARM');
    private ntv_SVMAllocARM_1 := GetProcOrNil&<function(context: cl_context; flags: clSvmMemFlags; size: UIntPtr; alignment: UInt32): IntPtr>(SVMAllocARM_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SVMAllocARM(context: cl_context; flags: clSvmMemFlags; size: UIntPtr; alignment: UInt32): IntPtr :=
      ntv_SVMAllocARM_1(context, flags, size, alignment);
    
    public SVMFreeARM_adr := GetProcAddress('clSVMFreeARM');
    private ntv_SVMFreeARM_1 := GetProcOrNil&<procedure(context: cl_context; svm_pointer: IntPtr)>(SVMFreeARM_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SVMFreeARM(context: cl_context; svm_pointer: IntPtr) :=
      ntv_SVMFreeARM_1(context, svm_pointer);
    
    public EnqueueSVMFreeARM_adr := GetProcAddress('clEnqueueSVMFreeARM');
    private ntv_EnqueueSVMFreeARM_1 := GetProcOrNil&<function(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueSVMFreeARM_adr);
    private ntv_EnqueueSVMFreeARM_2 := GetProcOrNil&<function(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueSVMFreeARM_adr);
    private ntv_EnqueueSVMFreeARM_3 := GetProcOrNil&<function(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueSVMFreeARM_adr);
    private ntv_EnqueueSVMFreeARM_4 := GetProcOrNil&<function(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueSVMFreeARM_adr);
    private ntv_EnqueueSVMFreeARM_5 := GetProcOrNil&<function(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueSVMFreeARM_adr);
    private ntv_EnqueueSVMFreeARM_6 := GetProcOrNil&<function(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueSVMFreeARM_adr);
    private ntv_EnqueueSVMFreeARM_7 := GetProcOrNil&<function(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueSVMFreeARM_adr);
    private ntv_EnqueueSVMFreeARM_8 := GetProcOrNil&<function(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueSVMFreeARM_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMFreeARM(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: array of IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueSVMFreeARM(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueSVMFreeARM(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMFreeARM(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: array of IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueSVMFreeARM(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueSVMFreeARM(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMFreeARM(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: array of IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    type PIntPtr = ^IntPtr;
    begin
      Result := if (svm_pointers<>nil) and (svm_pointers.Length<>0) then
        ntv_EnqueueSVMFreeARM_1(command_queue, num_svm_pointers, svm_pointers[0], pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueSVMFreeARM_1(command_queue, num_svm_pointers, PIntPtr(nil)^, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMFreeARM(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: array of IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    type PIntPtr = ^IntPtr;
    begin
      Result := if (svm_pointers<>nil) and (svm_pointers.Length<>0) then
        ntv_EnqueueSVMFreeARM_2(command_queue, num_svm_pointers, svm_pointers[0], pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueSVMFreeARM_2(command_queue, num_svm_pointers, PIntPtr(nil)^, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMFreeARM(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: array of IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    type PIntPtr = ^IntPtr;
    begin
      Result := if (svm_pointers<>nil) and (svm_pointers.Length<>0) then
        ntv_EnqueueSVMFreeARM_3(command_queue, num_svm_pointers, svm_pointers[0], pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueSVMFreeARM_3(command_queue, num_svm_pointers, PIntPtr(nil)^, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMFreeARM(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: array of IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    type PIntPtr = ^IntPtr;
    begin
      Result := if (svm_pointers<>nil) and (svm_pointers.Length<>0) then
        ntv_EnqueueSVMFreeARM_4(command_queue, num_svm_pointers, svm_pointers[0], pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueSVMFreeARM_4(command_queue, num_svm_pointers, PIntPtr(nil)^, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMFreeARM(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMFreeARM_1(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMFreeARM_1(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMFreeARM(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMFreeARM_2(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMFreeARM_2(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMFreeARM(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMFreeARM_1(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMFreeARM(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMFreeARM_2(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMFreeARM(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMFreeARM_3(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMFreeARM(command_queue: cl_command_queue; num_svm_pointers: UInt32; var svm_pointers: IntPtr; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMFreeARM_4(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMFreeARM(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMFreeARM_5(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMFreeARM_5(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMFreeARM(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMFreeARM_6(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMFreeARM_6(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMFreeARM(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMFreeARM_5(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMFreeARM(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMFreeARM_6(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMFreeARM(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMFreeARM_7(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMFreeARM(command_queue: cl_command_queue; num_svm_pointers: UInt32; svm_pointers: pointer; pfn_free_func: clEnqueueSVMFreeCallback; user_data: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMFreeARM_8(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, &event);
    
    public EnqueueSVMMemcpyARM_adr := GetProcAddress('clEnqueueSVMMemcpyARM');
    private ntv_EnqueueSVMMemcpyARM_1 := GetProcOrNil&<function(command_queue: cl_command_queue; blocking_copy: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueSVMMemcpyARM_adr);
    private ntv_EnqueueSVMMemcpyARM_2 := GetProcOrNil&<function(command_queue: cl_command_queue; blocking_copy: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueSVMMemcpyARM_adr);
    private ntv_EnqueueSVMMemcpyARM_3 := GetProcOrNil&<function(command_queue: cl_command_queue; blocking_copy: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueSVMMemcpyARM_adr);
    private ntv_EnqueueSVMMemcpyARM_4 := GetProcOrNil&<function(command_queue: cl_command_queue; blocking_copy: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueSVMMemcpyARM_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMMemcpyARM(command_queue: cl_command_queue; blocking_copy: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMMemcpyARM_1(command_queue, blocking_copy, dst_ptr, src_ptr, size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMMemcpyARM_1(command_queue, blocking_copy, dst_ptr, src_ptr, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMMemcpyARM(command_queue: cl_command_queue; blocking_copy: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMMemcpyARM_2(command_queue, blocking_copy, dst_ptr, src_ptr, size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMMemcpyARM_2(command_queue, blocking_copy, dst_ptr, src_ptr, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMMemcpyARM(command_queue: cl_command_queue; blocking_copy: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMMemcpyARM_1(command_queue, blocking_copy, dst_ptr, src_ptr, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMMemcpyARM(command_queue: cl_command_queue; blocking_copy: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMMemcpyARM_2(command_queue, blocking_copy, dst_ptr, src_ptr, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMMemcpyARM(command_queue: cl_command_queue; blocking_copy: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMMemcpyARM_3(command_queue, blocking_copy, dst_ptr, src_ptr, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMMemcpyARM(command_queue: cl_command_queue; blocking_copy: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMMemcpyARM_4(command_queue, blocking_copy, dst_ptr, src_ptr, size, num_events_in_wait_list, event_wait_list, &event);
    
    public EnqueueSVMMemFillARM_adr := GetProcAddress('clEnqueueSVMMemFillARM');
    private ntv_EnqueueSVMMemFillARM_1 := GetProcOrNil&<function(command_queue: cl_command_queue; svm_ptr: IntPtr; var pattern: Byte; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueSVMMemFillARM_adr);
    private ntv_EnqueueSVMMemFillARM_2 := GetProcOrNil&<function(command_queue: cl_command_queue; svm_ptr: IntPtr; var pattern: Byte; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueSVMMemFillARM_adr);
    private ntv_EnqueueSVMMemFillARM_3 := GetProcOrNil&<function(command_queue: cl_command_queue; svm_ptr: IntPtr; var pattern: Byte; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueSVMMemFillARM_adr);
    private ntv_EnqueueSVMMemFillARM_4 := GetProcOrNil&<function(command_queue: cl_command_queue; svm_ptr: IntPtr; var pattern: Byte; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueSVMMemFillARM_adr);
    private ntv_EnqueueSVMMemFillARM_5 := GetProcOrNil&<function(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: pointer; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueSVMMemFillARM_adr);
    private ntv_EnqueueSVMMemFillARM_6 := GetProcOrNil&<function(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: pointer; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueSVMMemFillARM_adr);
    private ntv_EnqueueSVMMemFillARM_7 := GetProcOrNil&<function(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: pointer; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueSVMMemFillARM_adr);
    private ntv_EnqueueSVMMemFillARM_8 := GetProcOrNil&<function(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: pointer; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueSVMMemFillARM_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMMemFillARM<T>(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: array of T; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode; where T: record;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueSVMMemFillARM(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueSVMMemFillARM(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMMemFillARM<T>(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: array of T; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode; where T: record;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueSVMMemFillARM(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueSVMMemFillARM(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMMemFillARM<T>(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: array of T; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode; where T: record;
    type PT = ^T;
    begin
      Result := if (pattern<>nil) and (pattern.Length<>0) then
        EnqueueSVMMemFillARM(command_queue, svm_ptr, pattern[0], pattern_size, size, num_events_in_wait_list, event_wait_list, &event) else
        EnqueueSVMMemFillARM(command_queue, svm_ptr, PT(nil)^, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMMemFillARM<T>(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: array of T; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode; where T: record;
    type PT = ^T;
    begin
      Result := if (pattern<>nil) and (pattern.Length<>0) then
        EnqueueSVMMemFillARM(command_queue, svm_ptr, pattern[0], pattern_size, size, num_events_in_wait_list, event_wait_list, &event) else
        EnqueueSVMMemFillARM(command_queue, svm_ptr, PT(nil)^, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMMemFillARM<T>(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: array of T; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode; where T: record;
    type PT = ^T;
    begin
      Result := if (pattern<>nil) and (pattern.Length<>0) then
        EnqueueSVMMemFillARM(command_queue, svm_ptr, pattern[0], pattern_size, size, num_events_in_wait_list, event_wait_list, &event) else
        EnqueueSVMMemFillARM(command_queue, svm_ptr, PT(nil)^, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMMemFillARM<T>(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: array of T; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode; where T: record;
    type PT = ^T;
    begin
      Result := if (pattern<>nil) and (pattern.Length<>0) then
        EnqueueSVMMemFillARM(command_queue, svm_ptr, pattern[0], pattern_size, size, num_events_in_wait_list, event_wait_list, &event) else
        EnqueueSVMMemFillARM(command_queue, svm_ptr, PT(nil)^, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMMemFillARM<T>(command_queue: cl_command_queue; svm_ptr: IntPtr; var pattern: T; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode; where T: record;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueSVMMemFillARM(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueSVMMemFillARM(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMMemFillARM<T>(command_queue: cl_command_queue; svm_ptr: IntPtr; var pattern: T; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode; where T: record;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueSVMMemFillARM(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueSVMMemFillARM(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMMemFillARM<T>(command_queue: cl_command_queue; svm_ptr: IntPtr; var pattern: T; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueSVMMemFillARM_1(command_queue, svm_ptr, PByte(pointer(@pattern))^, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMMemFillARM<T>(command_queue: cl_command_queue; svm_ptr: IntPtr; var pattern: T; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueSVMMemFillARM_2(command_queue, svm_ptr, PByte(pointer(@pattern))^, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMMemFillARM<T>(command_queue: cl_command_queue; svm_ptr: IntPtr; var pattern: T; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueSVMMemFillARM_3(command_queue, svm_ptr, PByte(pointer(@pattern))^, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMMemFillARM<T>(command_queue: cl_command_queue; svm_ptr: IntPtr; var pattern: T; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_EnqueueSVMMemFillARM_4(command_queue, svm_ptr, PByte(pointer(@pattern))^, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMMemFillARM(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: pointer; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMMemFillARM_5(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMMemFillARM_5(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMMemFillARM(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: pointer; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMMemFillARM_6(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMMemFillARM_6(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMMemFillARM(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: pointer; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMMemFillARM_5(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMMemFillARM(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: pointer; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMMemFillARM_6(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMMemFillARM(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: pointer; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMMemFillARM_7(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMMemFillARM(command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: pointer; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMMemFillARM_8(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    
    public EnqueueSVMMapARM_adr := GetProcAddress('clEnqueueSVMMapARM');
    private ntv_EnqueueSVMMapARM_1 := GetProcOrNil&<function(command_queue: cl_command_queue; blocking_map: clBool; flags: clMapFlags; svm_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueSVMMapARM_adr);
    private ntv_EnqueueSVMMapARM_2 := GetProcOrNil&<function(command_queue: cl_command_queue; blocking_map: clBool; flags: clMapFlags; svm_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueSVMMapARM_adr);
    private ntv_EnqueueSVMMapARM_3 := GetProcOrNil&<function(command_queue: cl_command_queue; blocking_map: clBool; flags: clMapFlags; svm_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueSVMMapARM_adr);
    private ntv_EnqueueSVMMapARM_4 := GetProcOrNil&<function(command_queue: cl_command_queue; blocking_map: clBool; flags: clMapFlags; svm_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueSVMMapARM_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMMapARM(command_queue: cl_command_queue; blocking_map: clBool; flags: clMapFlags; svm_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMMapARM_1(command_queue, blocking_map, flags, svm_ptr, size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMMapARM_1(command_queue, blocking_map, flags, svm_ptr, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMMapARM(command_queue: cl_command_queue; blocking_map: clBool; flags: clMapFlags; svm_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMMapARM_2(command_queue, blocking_map, flags, svm_ptr, size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMMapARM_2(command_queue, blocking_map, flags, svm_ptr, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMMapARM(command_queue: cl_command_queue; blocking_map: clBool; flags: clMapFlags; svm_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMMapARM_1(command_queue, blocking_map, flags, svm_ptr, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMMapARM(command_queue: cl_command_queue; blocking_map: clBool; flags: clMapFlags; svm_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMMapARM_2(command_queue, blocking_map, flags, svm_ptr, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMMapARM(command_queue: cl_command_queue; blocking_map: clBool; flags: clMapFlags; svm_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMMapARM_3(command_queue, blocking_map, flags, svm_ptr, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMMapARM(command_queue: cl_command_queue; blocking_map: clBool; flags: clMapFlags; svm_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMMapARM_4(command_queue, blocking_map, flags, svm_ptr, size, num_events_in_wait_list, event_wait_list, &event);
    
    public EnqueueSVMUnmapARM_adr := GetProcAddress('clEnqueueSVMUnmapARM');
    private ntv_EnqueueSVMUnmapARM_1 := GetProcOrNil&<function(command_queue: cl_command_queue; svm_ptr: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueSVMUnmapARM_adr);
    private ntv_EnqueueSVMUnmapARM_2 := GetProcOrNil&<function(command_queue: cl_command_queue; svm_ptr: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueSVMUnmapARM_adr);
    private ntv_EnqueueSVMUnmapARM_3 := GetProcOrNil&<function(command_queue: cl_command_queue; svm_ptr: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueSVMUnmapARM_adr);
    private ntv_EnqueueSVMUnmapARM_4 := GetProcOrNil&<function(command_queue: cl_command_queue; svm_ptr: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueSVMUnmapARM_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMUnmapARM(command_queue: cl_command_queue; svm_ptr: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMUnmapARM_1(command_queue, svm_ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMUnmapARM_1(command_queue, svm_ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMUnmapARM(command_queue: cl_command_queue; svm_ptr: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSVMUnmapARM_2(command_queue, svm_ptr, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSVMUnmapARM_2(command_queue, svm_ptr, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMUnmapARM(command_queue: cl_command_queue; svm_ptr: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMUnmapARM_1(command_queue, svm_ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMUnmapARM(command_queue: cl_command_queue; svm_ptr: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMUnmapARM_2(command_queue, svm_ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMUnmapARM(command_queue: cl_command_queue; svm_ptr: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSVMUnmapARM_3(command_queue, svm_ptr, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSVMUnmapARM(command_queue: cl_command_queue; svm_ptr: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSVMUnmapARM_4(command_queue, svm_ptr, num_events_in_wait_list, event_wait_list, &event);
    
    public SetKernelArgSVMPointerARM_adr := GetProcAddress('clSetKernelArgSVMPointerARM');
    private ntv_SetKernelArgSVMPointerARM_1 := GetProcOrNil&<function(kernel: cl_kernel; arg_index: UInt32; arg_value: IntPtr): clErrorCode>(SetKernelArgSVMPointerARM_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetKernelArgSVMPointerARM(kernel: cl_kernel; arg_index: UInt32; arg_value: IntPtr): clErrorCode :=
      ntv_SetKernelArgSVMPointerARM_1(kernel, arg_index, arg_value);
    
    public SetKernelExecInfoARM_adr := GetProcAddress('clSetKernelExecInfoARM');
    private ntv_SetKernelExecInfoARM_1 := GetProcOrNil&<function(kernel: cl_kernel; param_name: clKernelExecInfoARM; param_value_size: UIntPtr; var param_value: Byte): clErrorCode>(SetKernelExecInfoARM_adr);
    private ntv_SetKernelExecInfoARM_2 := GetProcOrNil&<function(kernel: cl_kernel; param_name: clKernelExecInfoARM; param_value_size: UIntPtr; param_value: pointer): clErrorCode>(SetKernelExecInfoARM_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetKernelExecInfoARM<TInp>(kernel: cl_kernel; param_name: clKernelExecInfoARM; param_value_size: UIntPtr; var param_value: TInp): clErrorCode; where TInp: record;
    begin
      Result := ntv_SetKernelExecInfoARM_1(kernel, param_name, param_value_size, PByte(pointer(@param_value))^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetKernelExecInfoARM_KERNEL_EXEC_INFO_SVM_PTRS_ARM(kernel: cl_kernel; param_value: array of IntPtr): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value.Length*Marshal.SizeOf&<IntPtr>);
      Result := SetKernelExecInfoARM(kernel, clKernelExecInfoARM.KERNEL_EXEC_INFO_SVM_PTRS_ARM, param_value_sz,param_value[0]);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetKernelExecInfoARM_KERNEL_EXEC_INFO_SVM_PTRS_ARM(kernel: cl_kernel; param_value_count: UInt32; var param_value: IntPtr): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<IntPtr>);
      Result := SetKernelExecInfoARM(kernel, clKernelExecInfoARM.KERNEL_EXEC_INFO_SVM_PTRS_ARM, param_value_sz,param_value);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetKernelExecInfoARM_KERNEL_EXEC_INFO_SVM_FINE_GRAIN_SYSTEM_ARM(kernel: cl_kernel; param_value: clBool): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      Result := SetKernelExecInfoARM(kernel, clKernelExecInfoARM.KERNEL_EXEC_INFO_SVM_FINE_GRAIN_SYSTEM_ARM, param_value_sz,param_value);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetKernelExecInfoARM(kernel: cl_kernel; param_name: clKernelExecInfoARM; param_value_size: UIntPtr; param_value: pointer): clErrorCode :=
      ntv_SetKernelExecInfoARM_2(kernel, param_name, param_value_size, param_value);
    
  end;
  
  ///
  clCxxForOpenclEXT = static class
    public const ExtensionString = 'cl_ext_cxx_for_opencl';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clDeviceFissionEXT = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clDeviceFissionEXT(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_ext_device_fission';
    
    public ReleaseDeviceEXT_adr := GetProcAddress('clReleaseDeviceEXT');
    private ntv_ReleaseDeviceEXT_1 := GetProcOrNil&<function(device: cl_device_id): clErrorCode>(ReleaseDeviceEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseDeviceEXT(device: cl_device_id): clErrorCode :=
      ntv_ReleaseDeviceEXT_1(device);
    
    public RetainDeviceEXT_adr := GetProcAddress('clRetainDeviceEXT');
    private ntv_RetainDeviceEXT_1 := GetProcOrNil&<function(device: cl_device_id): clErrorCode>(RetainDeviceEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function RetainDeviceEXT(device: cl_device_id): clErrorCode :=
      ntv_RetainDeviceEXT_1(device);
    
    public CreateSubDevicesEXT_adr := GetProcAddress('clCreateSubDevicesEXT');
    private ntv_CreateSubDevicesEXT_1 := GetProcOrNil&<function(in_device: cl_device_id; var properties: clDevicePartitionPropertyEXT; num_entries: UInt32; var out_devices: cl_device_id; var num_devices: UInt32): clErrorCode>(CreateSubDevicesEXT_adr);
    private ntv_CreateSubDevicesEXT_2 := GetProcOrNil&<function(in_device: cl_device_id; var properties: clDevicePartitionPropertyEXT; num_entries: UInt32; out_devices: IntPtr; var num_devices: UInt32): clErrorCode>(CreateSubDevicesEXT_adr);
    private ntv_CreateSubDevicesEXT_3 := GetProcOrNil&<function(in_device: cl_device_id; var properties: clDevicePartitionPropertyEXT; num_entries: UInt32; var out_devices: cl_device_id; num_devices: IntPtr): clErrorCode>(CreateSubDevicesEXT_adr);
    private ntv_CreateSubDevicesEXT_4 := GetProcOrNil&<function(in_device: cl_device_id; var properties: clDevicePartitionPropertyEXT; num_entries: UInt32; out_devices: IntPtr; num_devices: IntPtr): clErrorCode>(CreateSubDevicesEXT_adr);
    private ntv_CreateSubDevicesEXT_5 := GetProcOrNil&<function(in_device: cl_device_id; properties: IntPtr; num_entries: UInt32; var out_devices: cl_device_id; var num_devices: UInt32): clErrorCode>(CreateSubDevicesEXT_adr);
    private ntv_CreateSubDevicesEXT_6 := GetProcOrNil&<function(in_device: cl_device_id; properties: IntPtr; num_entries: UInt32; var out_devices: cl_device_id; num_devices: IntPtr): clErrorCode>(CreateSubDevicesEXT_adr);
    private ntv_CreateSubDevicesEXT_7 := GetProcOrNil&<function(in_device: cl_device_id; properties: IntPtr; num_entries: UInt32; out_devices: IntPtr; var num_devices: UInt32): clErrorCode>(CreateSubDevicesEXT_adr);
    private ntv_CreateSubDevicesEXT_8 := GetProcOrNil&<function(in_device: cl_device_id; properties: IntPtr; num_entries: UInt32; out_devices: IntPtr; num_devices: IntPtr): clErrorCode>(CreateSubDevicesEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSubDevicesEXT(in_device: cl_device_id; properties: array of clDevicePartitionPropertyEXT; num_entries: UInt32; var out_devices: cl_device_id; num_devices: array of UInt32): clErrorCode;
    type PClDevicePartitionPropertyEXT = ^clDevicePartitionPropertyEXT;
    type PUInt32 = ^UInt32;
    begin
      Result := if (num_devices<>nil) and (num_devices.Length<>0) then
        if (properties<>nil) and (properties.Length<>0) then
          ntv_CreateSubDevicesEXT_1(in_device, properties[0], num_entries, out_devices, num_devices[0]) else
          ntv_CreateSubDevicesEXT_1(in_device, PClDevicePartitionPropertyEXT(nil)^, num_entries, out_devices, num_devices[0]) else
        if (properties<>nil) and (properties.Length<>0) then
          ntv_CreateSubDevicesEXT_1(in_device, properties[0], num_entries, out_devices, PUInt32(nil)^) else
          ntv_CreateSubDevicesEXT_1(in_device, PClDevicePartitionPropertyEXT(nil)^, num_entries, out_devices, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSubDevicesEXT(in_device: cl_device_id; properties: array of clDevicePartitionPropertyEXT; num_entries: UInt32; out_devices: IntPtr; num_devices: array of UInt32): clErrorCode;
    type PClDevicePartitionPropertyEXT = ^clDevicePartitionPropertyEXT;
    type PUInt32 = ^UInt32;
    begin
      Result := if (num_devices<>nil) and (num_devices.Length<>0) then
        if (properties<>nil) and (properties.Length<>0) then
          ntv_CreateSubDevicesEXT_2(in_device, properties[0], num_entries, out_devices, num_devices[0]) else
          ntv_CreateSubDevicesEXT_2(in_device, PClDevicePartitionPropertyEXT(nil)^, num_entries, out_devices, num_devices[0]) else
        if (properties<>nil) and (properties.Length<>0) then
          ntv_CreateSubDevicesEXT_2(in_device, properties[0], num_entries, out_devices, PUInt32(nil)^) else
          ntv_CreateSubDevicesEXT_2(in_device, PClDevicePartitionPropertyEXT(nil)^, num_entries, out_devices, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSubDevicesEXT(in_device: cl_device_id; var properties: clDevicePartitionPropertyEXT; num_entries: UInt32; var out_devices: cl_device_id; var num_devices: UInt32): clErrorCode :=
      ntv_CreateSubDevicesEXT_1(in_device, properties, num_entries, out_devices, num_devices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSubDevicesEXT(in_device: cl_device_id; var properties: clDevicePartitionPropertyEXT; num_entries: UInt32; var out_devices: cl_device_id; num_devices: IntPtr): clErrorCode :=
      ntv_CreateSubDevicesEXT_3(in_device, properties, num_entries, out_devices, num_devices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSubDevicesEXT(in_device: cl_device_id; var properties: clDevicePartitionPropertyEXT; num_entries: UInt32; out_devices: IntPtr; var num_devices: UInt32): clErrorCode :=
      ntv_CreateSubDevicesEXT_2(in_device, properties, num_entries, out_devices, num_devices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSubDevicesEXT(in_device: cl_device_id; var properties: clDevicePartitionPropertyEXT; num_entries: UInt32; out_devices: IntPtr; num_devices: IntPtr): clErrorCode :=
      ntv_CreateSubDevicesEXT_4(in_device, properties, num_entries, out_devices, num_devices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSubDevicesEXT(in_device: cl_device_id; properties: IntPtr; num_entries: UInt32; var out_devices: cl_device_id; var num_devices: UInt32): clErrorCode :=
      ntv_CreateSubDevicesEXT_5(in_device, properties, num_entries, out_devices, num_devices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSubDevicesEXT(in_device: cl_device_id; properties: IntPtr; num_entries: UInt32; var out_devices: cl_device_id; num_devices: IntPtr): clErrorCode :=
      ntv_CreateSubDevicesEXT_6(in_device, properties, num_entries, out_devices, num_devices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSubDevicesEXT(in_device: cl_device_id; properties: IntPtr; num_entries: UInt32; out_devices: IntPtr; var num_devices: UInt32): clErrorCode :=
      ntv_CreateSubDevicesEXT_7(in_device, properties, num_entries, out_devices, num_devices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSubDevicesEXT(in_device: cl_device_id; properties: IntPtr; num_entries: UInt32; out_devices: IntPtr; num_devices: IntPtr): clErrorCode :=
      ntv_CreateSubDevicesEXT_8(in_device, properties, num_entries, out_devices, num_devices);
    
  end;
  
  ///
  clFloatAtomicsEXT = static class
    public const ExtensionString = 'cl_ext_float_atomics';
  end;
  
  ///
  clImageFromBufferEXT = static class
    public const ExtensionString = 'cl_ext_image_from_buffer';
  end;
  
  ///
  clImageRaw10Raw12EXT = static class
    public const ExtensionString = 'cl_ext_image_raw10_raw12';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clImageRequirementsInfoEXT = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clImageRequirementsInfoEXT(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_ext_image_requirements_info';
    
    public GetImageRequirementsInfoEXT_adr := GetProcAddress('clGetImageRequirementsInfoEXT');
    private ntv_GetImageRequirementsInfoEXT_1 := GetProcOrNil&<function(context: cl_context; var properties: clMemProperties; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; param_name: clImageRequirementsInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode>(GetImageRequirementsInfoEXT_adr);
    private ntv_GetImageRequirementsInfoEXT_2 := GetProcOrNil&<function(context: cl_context; var properties: clMemProperties; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; param_name: clImageRequirementsInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode>(GetImageRequirementsInfoEXT_adr);
    private ntv_GetImageRequirementsInfoEXT_3 := GetProcOrNil&<function(context: cl_context; var properties: clMemProperties; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; param_name: clImageRequirementsInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode>(GetImageRequirementsInfoEXT_adr);
    private ntv_GetImageRequirementsInfoEXT_4 := GetProcOrNil&<function(context: cl_context; var properties: clMemProperties; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; param_name: clImageRequirementsInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode>(GetImageRequirementsInfoEXT_adr);
    private ntv_GetImageRequirementsInfoEXT_5 := GetProcOrNil&<function(context: cl_context; properties: IntPtr; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; param_name: clImageRequirementsInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode>(GetImageRequirementsInfoEXT_adr);
    private ntv_GetImageRequirementsInfoEXT_6 := GetProcOrNil&<function(context: cl_context; properties: IntPtr; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; param_name: clImageRequirementsInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode>(GetImageRequirementsInfoEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetImageRequirementsInfoEXT<T>(context: cl_context; var properties: clMemProperties; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; param_name: clImageRequirementsInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetImageRequirementsInfoEXT_1(context, properties, flags, image_format, image_desc, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetImageRequirementsInfoEXT<T>(context: cl_context; var properties: clMemProperties; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; param_name: clImageRequirementsInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetImageRequirementsInfoEXT_2(context, properties, flags, image_format, image_desc, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetImageRequirementsInfoEXT_IMAGE_REQUIREMENTS_ROW_PITCH_ALIGNMENT(context: cl_context; var properties: clMemProperties; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageRequirementsInfoEXT(context, properties, flags, image_format, image_desc, clImageRequirementsInfo.IMAGE_REQUIREMENTS_ROW_PITCH_ALIGNMENT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetImageRequirementsInfoEXT_IMAGE_REQUIREMENTS_SLICE_PITCH_ALIGNMENT(context: cl_context; var properties: clMemProperties; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageRequirementsInfoEXT(context, properties, flags, image_format, image_desc, clImageRequirementsInfo.IMAGE_REQUIREMENTS_SLICE_PITCH_ALIGNMENT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetImageRequirementsInfoEXT_IMAGE_REQUIREMENTS_BASE_ADDRESS_ALIGNMENT(context: cl_context; var properties: clMemProperties; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageRequirementsInfoEXT(context, properties, flags, image_format, image_desc, clImageRequirementsInfo.IMAGE_REQUIREMENTS_BASE_ADDRESS_ALIGNMENT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetImageRequirementsInfoEXT_IMAGE_REQUIREMENTS_SIZE(context: cl_context; var properties: clMemProperties; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageRequirementsInfoEXT(context, properties, flags, image_format, image_desc, clImageRequirementsInfo.IMAGE_REQUIREMENTS_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetImageRequirementsInfoEXT_IMAGE_REQUIREMENTS_MAX_WIDTH(context: cl_context; var properties: clMemProperties; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageRequirementsInfoEXT(context, properties, flags, image_format, image_desc, clImageRequirementsInfo.IMAGE_REQUIREMENTS_MAX_WIDTH, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetImageRequirementsInfoEXT_IMAGE_REQUIREMENTS_MAX_HEIGHT(context: cl_context; var properties: clMemProperties; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageRequirementsInfoEXT(context, properties, flags, image_format, image_desc, clImageRequirementsInfo.IMAGE_REQUIREMENTS_MAX_HEIGHT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetImageRequirementsInfoEXT_IMAGE_REQUIREMENTS_MAX_DEPTH(context: cl_context; var properties: clMemProperties; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageRequirementsInfoEXT(context, properties, flags, image_format, image_desc, clImageRequirementsInfo.IMAGE_REQUIREMENTS_MAX_DEPTH, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetImageRequirementsInfoEXT_IMAGE_REQUIREMENTS_MAX_ARRAY_SIZE(context: cl_context; var properties: clMemProperties; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetImageRequirementsInfoEXT(context, properties, flags, image_format, image_desc, clImageRequirementsInfo.IMAGE_REQUIREMENTS_MAX_ARRAY_SIZE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetImageRequirementsInfoEXT(context: cl_context; properties: array of clMemProperties; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; param_name: clImageRequirementsInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode;
    type PClMemProperties = ^clMemProperties;
    begin
      Result := if (properties<>nil) and (properties.Length<>0) then
        ntv_GetImageRequirementsInfoEXT_3(context, properties[0], flags, image_format, image_desc, param_name, param_value_size, param_value, param_value_size_ret) else
        ntv_GetImageRequirementsInfoEXT_3(context, PClMemProperties(nil)^, flags, image_format, image_desc, param_name, param_value_size, param_value, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetImageRequirementsInfoEXT(context: cl_context; properties: array of clMemProperties; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; param_name: clImageRequirementsInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode;
    type PClMemProperties = ^clMemProperties;
    begin
      Result := if (properties<>nil) and (properties.Length<>0) then
        ntv_GetImageRequirementsInfoEXT_4(context, properties[0], flags, image_format, image_desc, param_name, param_value_size, param_value, param_value_size_ret) else
        ntv_GetImageRequirementsInfoEXT_4(context, PClMemProperties(nil)^, flags, image_format, image_desc, param_name, param_value_size, param_value, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetImageRequirementsInfoEXT(context: cl_context; var properties: clMemProperties; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; param_name: clImageRequirementsInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetImageRequirementsInfoEXT_3(context, properties, flags, image_format, image_desc, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetImageRequirementsInfoEXT(context: cl_context; var properties: clMemProperties; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; param_name: clImageRequirementsInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetImageRequirementsInfoEXT_4(context, properties, flags, image_format, image_desc, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetImageRequirementsInfoEXT(context: cl_context; properties: IntPtr; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; param_name: clImageRequirementsInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetImageRequirementsInfoEXT_5(context, properties, flags, image_format, image_desc, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetImageRequirementsInfoEXT(context: cl_context; properties: IntPtr; flags: clMemFlags; var image_format: cl_image_format; var image_desc: cl_image_desc; param_name: clImageRequirementsInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetImageRequirementsInfoEXT_6(context, properties, flags, image_format, image_desc, param_name, param_value_size, param_value, param_value_size_ret);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clMigrateMemobjectEXT = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clMigrateMemobjectEXT(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_ext_migrate_memobject';
    
    public EnqueueMigrateMemObjectEXT_adr := GetProcAddress('clEnqueueMigrateMemObjectEXT');
    private ntv_EnqueueMigrateMemObjectEXT_1 := GetProcOrNil&<function(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueMigrateMemObjectEXT_adr);
    private ntv_EnqueueMigrateMemObjectEXT_2 := GetProcOrNil&<function(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueMigrateMemObjectEXT_adr);
    private ntv_EnqueueMigrateMemObjectEXT_3 := GetProcOrNil&<function(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueMigrateMemObjectEXT_adr);
    private ntv_EnqueueMigrateMemObjectEXT_4 := GetProcOrNil&<function(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueMigrateMemObjectEXT_adr);
    private ntv_EnqueueMigrateMemObjectEXT_5 := GetProcOrNil&<function(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueMigrateMemObjectEXT_adr);
    private ntv_EnqueueMigrateMemObjectEXT_6 := GetProcOrNil&<function(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueMigrateMemObjectEXT_adr);
    private ntv_EnqueueMigrateMemObjectEXT_7 := GetProcOrNil&<function(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueMigrateMemObjectEXT_adr);
    private ntv_EnqueueMigrateMemObjectEXT_8 := GetProcOrNil&<function(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueMigrateMemObjectEXT_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMigrateMemObjectEXT(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: array of cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueMigrateMemObjectEXT(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueMigrateMemObjectEXT(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMigrateMemObjectEXT(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: array of cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueMigrateMemObjectEXT(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueMigrateMemObjectEXT(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMigrateMemObjectEXT(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: array of cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueMigrateMemObjectEXT_1(command_queue, num_mem_objects, mem_objects[0], flags, num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueMigrateMemObjectEXT_1(command_queue, num_mem_objects, PCl_mem(nil)^, flags, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMigrateMemObjectEXT(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: array of cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueMigrateMemObjectEXT_2(command_queue, num_mem_objects, mem_objects[0], flags, num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueMigrateMemObjectEXT_2(command_queue, num_mem_objects, PCl_mem(nil)^, flags, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMigrateMemObjectEXT(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: array of cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueMigrateMemObjectEXT_3(command_queue, num_mem_objects, mem_objects[0], flags, num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueMigrateMemObjectEXT_3(command_queue, num_mem_objects, PCl_mem(nil)^, flags, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMigrateMemObjectEXT(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: array of cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueMigrateMemObjectEXT_4(command_queue, num_mem_objects, mem_objects[0], flags, num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueMigrateMemObjectEXT_4(command_queue, num_mem_objects, PCl_mem(nil)^, flags, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMigrateMemObjectEXT(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueMigrateMemObjectEXT_1(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueMigrateMemObjectEXT_1(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMigrateMemObjectEXT(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueMigrateMemObjectEXT_2(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueMigrateMemObjectEXT_2(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMigrateMemObjectEXT(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueMigrateMemObjectEXT_1(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMigrateMemObjectEXT(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueMigrateMemObjectEXT_2(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMigrateMemObjectEXT(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueMigrateMemObjectEXT_3(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMigrateMemObjectEXT(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueMigrateMemObjectEXT_4(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMigrateMemObjectEXT(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueMigrateMemObjectEXT_5(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueMigrateMemObjectEXT_5(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMigrateMemObjectEXT(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueMigrateMemObjectEXT_6(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueMigrateMemObjectEXT_6(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMigrateMemObjectEXT(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueMigrateMemObjectEXT_5(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMigrateMemObjectEXT(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueMigrateMemObjectEXT_6(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMigrateMemObjectEXT(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueMigrateMemObjectEXT_7(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMigrateMemObjectEXT(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueMigrateMemObjectEXT_8(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list, &event);
    
  end;
  
  ///
  clCachedAllocationsIMG = static class
    public const ExtensionString = 'cl_img_cached_allocations';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clGenerateMipmapIMG = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clGenerateMipmapIMG(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_img_generate_mipmap';
    
    public EnqueueGenerateMipmapIMG_adr := GetProcAddress('clEnqueueGenerateMipmapIMG');
    private ntv_EnqueueGenerateMipmapIMG_1 := GetProcOrNil&<function(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; var array_region: UIntPtr; var mip_region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueGenerateMipmapIMG_adr);
    private ntv_EnqueueGenerateMipmapIMG_2 := GetProcOrNil&<function(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; var array_region: UIntPtr; var mip_region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueGenerateMipmapIMG_adr);
    private ntv_EnqueueGenerateMipmapIMG_3 := GetProcOrNil&<function(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; var array_region: UIntPtr; var mip_region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueGenerateMipmapIMG_adr);
    private ntv_EnqueueGenerateMipmapIMG_4 := GetProcOrNil&<function(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; var array_region: UIntPtr; var mip_region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueGenerateMipmapIMG_adr);
    private ntv_EnqueueGenerateMipmapIMG_5 := GetProcOrNil&<function(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; var array_region: UIntPtr; mip_region: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueGenerateMipmapIMG_adr);
    private ntv_EnqueueGenerateMipmapIMG_6 := GetProcOrNil&<function(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; var array_region: UIntPtr; mip_region: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueGenerateMipmapIMG_adr);
    private ntv_EnqueueGenerateMipmapIMG_7 := GetProcOrNil&<function(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; var array_region: UIntPtr; mip_region: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueGenerateMipmapIMG_adr);
    private ntv_EnqueueGenerateMipmapIMG_8 := GetProcOrNil&<function(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; var array_region: UIntPtr; mip_region: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueGenerateMipmapIMG_adr);
    private ntv_EnqueueGenerateMipmapIMG_9 := GetProcOrNil&<function(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; array_region: IntPtr; var mip_region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueGenerateMipmapIMG_adr);
    private ntv_EnqueueGenerateMipmapIMG_10 := GetProcOrNil&<function(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; array_region: IntPtr; var mip_region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueGenerateMipmapIMG_adr);
    private ntv_EnqueueGenerateMipmapIMG_11 := GetProcOrNil&<function(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; array_region: IntPtr; var mip_region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueGenerateMipmapIMG_adr);
    private ntv_EnqueueGenerateMipmapIMG_12 := GetProcOrNil&<function(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; array_region: IntPtr; var mip_region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueGenerateMipmapIMG_adr);
    private ntv_EnqueueGenerateMipmapIMG_13 := GetProcOrNil&<function(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; array_region: IntPtr; mip_region: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueGenerateMipmapIMG_adr);
    private ntv_EnqueueGenerateMipmapIMG_14 := GetProcOrNil&<function(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; array_region: IntPtr; mip_region: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueGenerateMipmapIMG_adr);
    private ntv_EnqueueGenerateMipmapIMG_15 := GetProcOrNil&<function(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; array_region: IntPtr; mip_region: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueGenerateMipmapIMG_adr);
    private ntv_EnqueueGenerateMipmapIMG_16 := GetProcOrNil&<function(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; array_region: IntPtr; mip_region: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueGenerateMipmapIMG_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueGenerateMipmapIMG(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; array_region: array of UIntPtr; mip_region: array of UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueGenerateMipmapIMG(command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueGenerateMipmapIMG(command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueGenerateMipmapIMG(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; array_region: array of UIntPtr; mip_region: array of UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueGenerateMipmapIMG(command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueGenerateMipmapIMG(command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueGenerateMipmapIMG(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; array_region: array of UIntPtr; mip_region: array of UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    type PUIntPtr = ^UIntPtr;
    begin
      Result := if (mip_region<>nil) and (mip_region.Length<>0) then
        if (array_region<>nil) and (array_region.Length<>0) then
          ntv_EnqueueGenerateMipmapIMG_1(command_queue, src_image, dst_image, mipmap_filter_mode, array_region[0], mip_region[0], num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueGenerateMipmapIMG_1(command_queue, src_image, dst_image, mipmap_filter_mode, PUIntPtr(nil)^, mip_region[0], num_events_in_wait_list, event_wait_list, &event) else
        if (array_region<>nil) and (array_region.Length<>0) then
          ntv_EnqueueGenerateMipmapIMG_1(command_queue, src_image, dst_image, mipmap_filter_mode, array_region[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueGenerateMipmapIMG_1(command_queue, src_image, dst_image, mipmap_filter_mode, PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueGenerateMipmapIMG(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; array_region: array of UIntPtr; mip_region: array of UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    type PUIntPtr = ^UIntPtr;
    begin
      Result := if (mip_region<>nil) and (mip_region.Length<>0) then
        if (array_region<>nil) and (array_region.Length<>0) then
          ntv_EnqueueGenerateMipmapIMG_2(command_queue, src_image, dst_image, mipmap_filter_mode, array_region[0], mip_region[0], num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueGenerateMipmapIMG_2(command_queue, src_image, dst_image, mipmap_filter_mode, PUIntPtr(nil)^, mip_region[0], num_events_in_wait_list, event_wait_list, &event) else
        if (array_region<>nil) and (array_region.Length<>0) then
          ntv_EnqueueGenerateMipmapIMG_2(command_queue, src_image, dst_image, mipmap_filter_mode, array_region[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueGenerateMipmapIMG_2(command_queue, src_image, dst_image, mipmap_filter_mode, PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueGenerateMipmapIMG(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; array_region: array of UIntPtr; mip_region: array of UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    type PUIntPtr = ^UIntPtr;
    begin
      Result := if (mip_region<>nil) and (mip_region.Length<>0) then
        if (array_region<>nil) and (array_region.Length<>0) then
          ntv_EnqueueGenerateMipmapIMG_3(command_queue, src_image, dst_image, mipmap_filter_mode, array_region[0], mip_region[0], num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueGenerateMipmapIMG_3(command_queue, src_image, dst_image, mipmap_filter_mode, PUIntPtr(nil)^, mip_region[0], num_events_in_wait_list, event_wait_list, &event) else
        if (array_region<>nil) and (array_region.Length<>0) then
          ntv_EnqueueGenerateMipmapIMG_3(command_queue, src_image, dst_image, mipmap_filter_mode, array_region[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueGenerateMipmapIMG_3(command_queue, src_image, dst_image, mipmap_filter_mode, PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueGenerateMipmapIMG(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; array_region: array of UIntPtr; mip_region: array of UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    type PUIntPtr = ^UIntPtr;
    begin
      Result := if (mip_region<>nil) and (mip_region.Length<>0) then
        if (array_region<>nil) and (array_region.Length<>0) then
          ntv_EnqueueGenerateMipmapIMG_4(command_queue, src_image, dst_image, mipmap_filter_mode, array_region[0], mip_region[0], num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueGenerateMipmapIMG_4(command_queue, src_image, dst_image, mipmap_filter_mode, PUIntPtr(nil)^, mip_region[0], num_events_in_wait_list, event_wait_list, &event) else
        if (array_region<>nil) and (array_region.Length<>0) then
          ntv_EnqueueGenerateMipmapIMG_4(command_queue, src_image, dst_image, mipmap_filter_mode, array_region[0], PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueGenerateMipmapIMG_4(command_queue, src_image, dst_image, mipmap_filter_mode, PUIntPtr(nil)^, PUIntPtr(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueGenerateMipmapIMG(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; var array_region: UIntPtr; var mip_region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueGenerateMipmapIMG_1(command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueGenerateMipmapIMG_1(command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueGenerateMipmapIMG(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; var array_region: UIntPtr; var mip_region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueGenerateMipmapIMG_2(command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueGenerateMipmapIMG_2(command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueGenerateMipmapIMG(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; var array_region: UIntPtr; var mip_region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueGenerateMipmapIMG_1(command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueGenerateMipmapIMG(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; var array_region: UIntPtr; var mip_region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueGenerateMipmapIMG_2(command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueGenerateMipmapIMG(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; var array_region: UIntPtr; var mip_region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueGenerateMipmapIMG_3(command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueGenerateMipmapIMG(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; var array_region: UIntPtr; var mip_region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueGenerateMipmapIMG_4(command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueGenerateMipmapIMG(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; var array_region: UIntPtr; mip_region: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueGenerateMipmapIMG_5(command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueGenerateMipmapIMG_5(command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueGenerateMipmapIMG(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; var array_region: UIntPtr; mip_region: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueGenerateMipmapIMG_6(command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueGenerateMipmapIMG_6(command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueGenerateMipmapIMG(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; var array_region: UIntPtr; mip_region: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueGenerateMipmapIMG_5(command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueGenerateMipmapIMG(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; var array_region: UIntPtr; mip_region: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueGenerateMipmapIMG_6(command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueGenerateMipmapIMG(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; var array_region: UIntPtr; mip_region: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueGenerateMipmapIMG_7(command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueGenerateMipmapIMG(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; var array_region: UIntPtr; mip_region: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueGenerateMipmapIMG_8(command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueGenerateMipmapIMG(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; array_region: IntPtr; var mip_region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueGenerateMipmapIMG_9(command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueGenerateMipmapIMG_9(command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueGenerateMipmapIMG(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; array_region: IntPtr; var mip_region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueGenerateMipmapIMG_10(command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueGenerateMipmapIMG_10(command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueGenerateMipmapIMG(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; array_region: IntPtr; var mip_region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueGenerateMipmapIMG_9(command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueGenerateMipmapIMG(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; array_region: IntPtr; var mip_region: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueGenerateMipmapIMG_10(command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueGenerateMipmapIMG(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; array_region: IntPtr; var mip_region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueGenerateMipmapIMG_11(command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueGenerateMipmapIMG(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; array_region: IntPtr; var mip_region: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueGenerateMipmapIMG_12(command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueGenerateMipmapIMG(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; array_region: IntPtr; mip_region: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueGenerateMipmapIMG_13(command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueGenerateMipmapIMG_13(command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueGenerateMipmapIMG(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; array_region: IntPtr; mip_region: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueGenerateMipmapIMG_14(command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueGenerateMipmapIMG_14(command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueGenerateMipmapIMG(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; array_region: IntPtr; mip_region: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueGenerateMipmapIMG_13(command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueGenerateMipmapIMG(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; array_region: IntPtr; mip_region: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueGenerateMipmapIMG_14(command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueGenerateMipmapIMG(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; array_region: IntPtr; mip_region: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueGenerateMipmapIMG_15(command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueGenerateMipmapIMG(command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; mipmap_filter_mode: clMipmapFilterMode; array_region: IntPtr; mip_region: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueGenerateMipmapIMG_16(command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, event_wait_list, &event);
    
  end;
  
  ///
  clMemPropertiesIMG = static class
    public const ExtensionString = 'cl_img_mem_properties';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clUseGrallocPtrIMG = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clUseGrallocPtrIMG(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_img_use_gralloc_ptr';
    
    public EnqueueAcquireGrallocObjectsIMG_adr := GetProcAddress('clEnqueueAcquireGrallocObjectsIMG');
    private ntv_EnqueueAcquireGrallocObjectsIMG_1 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueAcquireGrallocObjectsIMG_adr);
    private ntv_EnqueueAcquireGrallocObjectsIMG_2 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueAcquireGrallocObjectsIMG_adr);
    private ntv_EnqueueAcquireGrallocObjectsIMG_3 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueAcquireGrallocObjectsIMG_adr);
    private ntv_EnqueueAcquireGrallocObjectsIMG_4 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueAcquireGrallocObjectsIMG_adr);
    private ntv_EnqueueAcquireGrallocObjectsIMG_5 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueAcquireGrallocObjectsIMG_adr);
    private ntv_EnqueueAcquireGrallocObjectsIMG_6 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueAcquireGrallocObjectsIMG_adr);
    private ntv_EnqueueAcquireGrallocObjectsIMG_7 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueAcquireGrallocObjectsIMG_adr);
    private ntv_EnqueueAcquireGrallocObjectsIMG_8 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueAcquireGrallocObjectsIMG_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireGrallocObjectsIMG(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueAcquireGrallocObjectsIMG(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueAcquireGrallocObjectsIMG(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireGrallocObjectsIMG(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueAcquireGrallocObjectsIMG(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueAcquireGrallocObjectsIMG(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireGrallocObjectsIMG(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueAcquireGrallocObjectsIMG_1(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueAcquireGrallocObjectsIMG_1(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireGrallocObjectsIMG(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueAcquireGrallocObjectsIMG_2(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueAcquireGrallocObjectsIMG_2(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireGrallocObjectsIMG(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueAcquireGrallocObjectsIMG_3(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueAcquireGrallocObjectsIMG_3(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireGrallocObjectsIMG(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueAcquireGrallocObjectsIMG_4(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueAcquireGrallocObjectsIMG_4(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireGrallocObjectsIMG(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueAcquireGrallocObjectsIMG_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueAcquireGrallocObjectsIMG_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireGrallocObjectsIMG(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueAcquireGrallocObjectsIMG_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueAcquireGrallocObjectsIMG_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireGrallocObjectsIMG(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueAcquireGrallocObjectsIMG_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireGrallocObjectsIMG(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueAcquireGrallocObjectsIMG_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireGrallocObjectsIMG(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueAcquireGrallocObjectsIMG_3(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireGrallocObjectsIMG(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueAcquireGrallocObjectsIMG_4(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireGrallocObjectsIMG(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueAcquireGrallocObjectsIMG_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueAcquireGrallocObjectsIMG_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireGrallocObjectsIMG(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueAcquireGrallocObjectsIMG_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueAcquireGrallocObjectsIMG_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireGrallocObjectsIMG(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueAcquireGrallocObjectsIMG_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireGrallocObjectsIMG(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueAcquireGrallocObjectsIMG_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireGrallocObjectsIMG(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueAcquireGrallocObjectsIMG_7(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireGrallocObjectsIMG(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueAcquireGrallocObjectsIMG_8(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    
    public EnqueueReleaseGrallocObjectsIMG_adr := GetProcAddress('clEnqueueReleaseGrallocObjectsIMG');
    private ntv_EnqueueReleaseGrallocObjectsIMG_1 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueReleaseGrallocObjectsIMG_adr);
    private ntv_EnqueueReleaseGrallocObjectsIMG_2 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueReleaseGrallocObjectsIMG_adr);
    private ntv_EnqueueReleaseGrallocObjectsIMG_3 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueReleaseGrallocObjectsIMG_adr);
    private ntv_EnqueueReleaseGrallocObjectsIMG_4 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueReleaseGrallocObjectsIMG_adr);
    private ntv_EnqueueReleaseGrallocObjectsIMG_5 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueReleaseGrallocObjectsIMG_adr);
    private ntv_EnqueueReleaseGrallocObjectsIMG_6 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueReleaseGrallocObjectsIMG_adr);
    private ntv_EnqueueReleaseGrallocObjectsIMG_7 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueReleaseGrallocObjectsIMG_adr);
    private ntv_EnqueueReleaseGrallocObjectsIMG_8 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueReleaseGrallocObjectsIMG_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseGrallocObjectsIMG(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueReleaseGrallocObjectsIMG(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueReleaseGrallocObjectsIMG(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseGrallocObjectsIMG(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueReleaseGrallocObjectsIMG(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueReleaseGrallocObjectsIMG(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseGrallocObjectsIMG(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueReleaseGrallocObjectsIMG_1(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueReleaseGrallocObjectsIMG_1(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseGrallocObjectsIMG(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueReleaseGrallocObjectsIMG_2(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueReleaseGrallocObjectsIMG_2(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseGrallocObjectsIMG(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueReleaseGrallocObjectsIMG_3(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueReleaseGrallocObjectsIMG_3(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseGrallocObjectsIMG(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueReleaseGrallocObjectsIMG_4(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueReleaseGrallocObjectsIMG_4(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseGrallocObjectsIMG(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReleaseGrallocObjectsIMG_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReleaseGrallocObjectsIMG_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseGrallocObjectsIMG(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReleaseGrallocObjectsIMG_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReleaseGrallocObjectsIMG_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseGrallocObjectsIMG(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReleaseGrallocObjectsIMG_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseGrallocObjectsIMG(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReleaseGrallocObjectsIMG_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseGrallocObjectsIMG(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReleaseGrallocObjectsIMG_3(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseGrallocObjectsIMG(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReleaseGrallocObjectsIMG_4(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseGrallocObjectsIMG(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReleaseGrallocObjectsIMG_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReleaseGrallocObjectsIMG_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseGrallocObjectsIMG(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReleaseGrallocObjectsIMG_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReleaseGrallocObjectsIMG_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseGrallocObjectsIMG(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReleaseGrallocObjectsIMG_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseGrallocObjectsIMG(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReleaseGrallocObjectsIMG_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseGrallocObjectsIMG(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReleaseGrallocObjectsIMG_7(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseGrallocObjectsIMG(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReleaseGrallocObjectsIMG_8(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    
  end;
  
  ///
  clYuvImageIMG = static class
    public const ExtensionString = 'cl_img_yuv_image';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clAcceleratorINTEL = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clAcceleratorINTEL(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_intel_accelerator';
    
    public CreateAcceleratorINTEL_adr := GetProcAddress('clCreateAcceleratorINTEL');
    private ntv_CreateAcceleratorINTEL_1 := GetProcOrNil&<function(context: cl_context; accelerator_type: clAcceleratorType; descriptor_size: UIntPtr; var descriptor: cl_motion_estimation_desc; var errcode_ret: clErrorCode): cl_accelerator>(CreateAcceleratorINTEL_adr);
    private ntv_CreateAcceleratorINTEL_2 := GetProcOrNil&<function(context: cl_context; accelerator_type: clAcceleratorType; descriptor_size: UIntPtr; descriptor: IntPtr; var errcode_ret: clErrorCode): cl_accelerator>(CreateAcceleratorINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAcceleratorINTEL(context: cl_context; accelerator_type: clAcceleratorType; descriptor_size: UIntPtr; var descriptor: cl_motion_estimation_desc; var errcode_ret: clErrorCode): cl_accelerator :=
      ntv_CreateAcceleratorINTEL_1(context, accelerator_type, descriptor_size, descriptor, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAcceleratorINTEL(context: cl_context; accelerator_type: clAcceleratorType; descriptor_size: UIntPtr; descriptor: IntPtr; var errcode_ret: clErrorCode): cl_accelerator :=
      ntv_CreateAcceleratorINTEL_2(context, accelerator_type, descriptor_size, descriptor, errcode_ret);
    
    public GetAcceleratorInfoINTEL_adr := GetProcAddress('clGetAcceleratorInfoINTEL');
    private ntv_GetAcceleratorInfoINTEL_1 := GetProcOrNil&<function(accelerator: cl_accelerator; param_name: clAcceleratorInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode>(GetAcceleratorInfoINTEL_adr);
    private ntv_GetAcceleratorInfoINTEL_2 := GetProcOrNil&<function(accelerator: cl_accelerator; param_name: clAcceleratorInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode>(GetAcceleratorInfoINTEL_adr);
    private ntv_GetAcceleratorInfoINTEL_3 := GetProcOrNil&<function(accelerator: cl_accelerator; param_name: clAcceleratorInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode>(GetAcceleratorInfoINTEL_adr);
    private ntv_GetAcceleratorInfoINTEL_4 := GetProcOrNil&<function(accelerator: cl_accelerator; param_name: clAcceleratorInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode>(GetAcceleratorInfoINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetAcceleratorInfoINTEL<T>(accelerator: cl_accelerator; param_name: clAcceleratorInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetAcceleratorInfoINTEL_1(accelerator, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetAcceleratorInfoINTEL<T>(accelerator: cl_accelerator; param_name: clAcceleratorInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetAcceleratorInfoINTEL_2(accelerator, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetAcceleratorInfoINTEL_ACCELERATOR_REFERENCE_COUNT(accelerator: cl_accelerator; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetAcceleratorInfoINTEL(accelerator, clAcceleratorInfo.ACCELERATOR_REFERENCE_COUNT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetAcceleratorInfoINTEL_ACCELERATOR_CONTEXT(accelerator: cl_accelerator; var param_value: cl_context; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_context>);
      var param_value_ret_size: UIntPtr;
      Result := GetAcceleratorInfoINTEL(accelerator, clAcceleratorInfo.ACCELERATOR_CONTEXT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetAcceleratorInfoINTEL_ACCELERATOR_TYPE(accelerator: cl_accelerator; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetAcceleratorInfoINTEL(accelerator, clAcceleratorInfo.ACCELERATOR_TYPE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetAcceleratorInfoINTEL(accelerator: cl_accelerator; param_name: clAcceleratorInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetAcceleratorInfoINTEL_3(accelerator, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetAcceleratorInfoINTEL(accelerator: cl_accelerator; param_name: clAcceleratorInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetAcceleratorInfoINTEL_4(accelerator, param_name, param_value_size, param_value, param_value_size_ret);
    
    public RetainAcceleratorINTEL_adr := GetProcAddress('clRetainAcceleratorINTEL');
    private ntv_RetainAcceleratorINTEL_1 := GetProcOrNil&<function(accelerator: cl_accelerator): clErrorCode>(RetainAcceleratorINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function RetainAcceleratorINTEL(accelerator: cl_accelerator): clErrorCode :=
      ntv_RetainAcceleratorINTEL_1(accelerator);
    
    public ReleaseAcceleratorINTEL_adr := GetProcAddress('clReleaseAcceleratorINTEL');
    private ntv_ReleaseAcceleratorINTEL_1 := GetProcOrNil&<function(accelerator: cl_accelerator): clErrorCode>(ReleaseAcceleratorINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseAcceleratorINTEL(accelerator: cl_accelerator): clErrorCode :=
      ntv_ReleaseAcceleratorINTEL_1(accelerator);
    
  end;
  
  ///
  clAdvancedMotionEstimationINTEL = static class
    public const ExtensionString = 'cl_intel_advanced_motion_estimation';
  end;
  
  ///
  clCommandQueueFamiliesINTEL = static class
    public const ExtensionString = 'cl_intel_command_queue_families';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clCreateBufferWithPropertiesINTEL = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clCreateBufferWithPropertiesINTEL(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_intel_create_buffer_with_properties';
    
    public CreateBufferWithPropertiesINTEL_adr := GetProcAddress('clCreateBufferWithPropertiesINTEL');
    private ntv_CreateBufferWithPropertiesINTEL_1 := GetProcOrNil&<function(context: cl_context; var properties: clMemPropertiesINTEL; flags: clMemFlags; size: UIntPtr; host_ptr: IntPtr; var errcode_ret: clErrorCode): cl_mem>(CreateBufferWithPropertiesINTEL_adr);
    private ntv_CreateBufferWithPropertiesINTEL_2 := GetProcOrNil&<function(context: cl_context; properties: IntPtr; flags: clMemFlags; size: UIntPtr; host_ptr: IntPtr; var errcode_ret: clErrorCode): cl_mem>(CreateBufferWithPropertiesINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateBufferWithPropertiesINTEL(context: cl_context; properties: array of clMemPropertiesINTEL; flags: clMemFlags; size: UIntPtr; host_ptr: IntPtr; var errcode_ret: clErrorCode): cl_mem;
    type PClMemPropertiesINTEL = ^clMemPropertiesINTEL;
    begin
      Result := if (properties<>nil) and (properties.Length<>0) then
        ntv_CreateBufferWithPropertiesINTEL_1(context, properties[0], flags, size, host_ptr, errcode_ret) else
        ntv_CreateBufferWithPropertiesINTEL_1(context, PClMemPropertiesINTEL(nil)^, flags, size, host_ptr, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateBufferWithPropertiesINTEL(context: cl_context; var properties: clMemPropertiesINTEL; flags: clMemFlags; size: UIntPtr; host_ptr: IntPtr; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateBufferWithPropertiesINTEL_1(context, properties, flags, size, host_ptr, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateBufferWithPropertiesINTEL(context: cl_context; properties: IntPtr; flags: clMemFlags; size: UIntPtr; host_ptr: IntPtr; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateBufferWithPropertiesINTEL_2(context, properties, flags, size, host_ptr, errcode_ret);
    
  end;
  
  ///
  clCreateMemObjectPropertiesINTEL = static class
    public const ExtensionString = 'cl_intel_create_mem_object_properties';
  end;
  
  ///
  clDeviceAttributeQueryINTEL = static class
    public const ExtensionString = 'cl_intel_device_attribute_query';
  end;
  
  ///
  clDevicePartitionByNamesINTEL = static class
    public const ExtensionString = 'cl_intel_device_partition_by_names';
  end;
  
  ///
  clDeviceSideAvcMotionEstimationINTEL = static class
    public const ExtensionString = 'cl_intel_device_side_avc_motion_estimation';
  end;
  
  ///
  clDriverDiagnosticsINTEL = static class
    public const ExtensionString = 'cl_intel_driver_diagnostics';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clDx9MediaSharingINTEL = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clDx9MediaSharingINTEL(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_intel_dx9_media_sharing';
    
    public GetDeviceIDsFromDX9INTEL_adr := GetProcAddress('clGetDeviceIDsFromDX9INTEL');
    private ntv_GetDeviceIDsFromDX9INTEL_1 := GetProcOrNil&<function(platform: cl_platform_id; dx9_device_source: clDx9DeviceSource; dx9_object: IntPtr; dx9_device_set: clDx9DeviceSet; num_entries: UInt32; var devices: cl_device_id; var num_devices: UInt32): clErrorCode>(GetDeviceIDsFromDX9INTEL_adr);
    private ntv_GetDeviceIDsFromDX9INTEL_2 := GetProcOrNil&<function(platform: cl_platform_id; dx9_device_source: clDx9DeviceSource; dx9_object: IntPtr; dx9_device_set: clDx9DeviceSet; num_entries: UInt32; var devices: cl_device_id; num_devices: IntPtr): clErrorCode>(GetDeviceIDsFromDX9INTEL_adr);
    private ntv_GetDeviceIDsFromDX9INTEL_3 := GetProcOrNil&<function(platform: cl_platform_id; dx9_device_source: clDx9DeviceSource; dx9_object: IntPtr; dx9_device_set: clDx9DeviceSet; num_entries: UInt32; devices: IntPtr; var num_devices: UInt32): clErrorCode>(GetDeviceIDsFromDX9INTEL_adr);
    private ntv_GetDeviceIDsFromDX9INTEL_4 := GetProcOrNil&<function(platform: cl_platform_id; dx9_device_source: clDx9DeviceSource; dx9_object: IntPtr; dx9_device_set: clDx9DeviceSet; num_entries: UInt32; devices: IntPtr; num_devices: IntPtr): clErrorCode>(GetDeviceIDsFromDX9INTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDeviceIDsFromDX9INTEL(platform: cl_platform_id; dx9_device_source: clDx9DeviceSource; dx9_object: IntPtr; dx9_device_set: clDx9DeviceSet; num_entries: UInt32; var devices: cl_device_id; var num_devices: UInt32): clErrorCode :=
      ntv_GetDeviceIDsFromDX9INTEL_1(platform, dx9_device_source, dx9_object, dx9_device_set, num_entries, devices, num_devices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDeviceIDsFromDX9INTEL(platform: cl_platform_id; dx9_device_source: clDx9DeviceSource; dx9_object: IntPtr; dx9_device_set: clDx9DeviceSet; num_entries: UInt32; var devices: cl_device_id; num_devices: IntPtr): clErrorCode :=
      ntv_GetDeviceIDsFromDX9INTEL_2(platform, dx9_device_source, dx9_object, dx9_device_set, num_entries, devices, num_devices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDeviceIDsFromDX9INTEL(platform: cl_platform_id; dx9_device_source: clDx9DeviceSource; dx9_object: IntPtr; dx9_device_set: clDx9DeviceSet; num_entries: UInt32; devices: IntPtr; var num_devices: UInt32): clErrorCode :=
      ntv_GetDeviceIDsFromDX9INTEL_3(platform, dx9_device_source, dx9_object, dx9_device_set, num_entries, devices, num_devices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDeviceIDsFromDX9INTEL(platform: cl_platform_id; dx9_device_source: clDx9DeviceSource; dx9_object: IntPtr; dx9_device_set: clDx9DeviceSet; num_entries: UInt32; devices: IntPtr; num_devices: IntPtr): clErrorCode :=
      ntv_GetDeviceIDsFromDX9INTEL_4(platform, dx9_device_source, dx9_object, dx9_device_set, num_entries, devices, num_devices);
    
    public CreateFromDX9MediaSurfaceINTEL_adr := GetProcAddress('clCreateFromDX9MediaSurfaceINTEL');
    private ntv_CreateFromDX9MediaSurfaceINTEL_1 := GetProcOrNil&<function(context: cl_context; flags: clMemFlags; resource: d3d_surface9; sharedHandle: IntPtr; plane: UInt32; var errcode_ret: clErrorCode): cl_mem>(CreateFromDX9MediaSurfaceINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateFromDX9MediaSurfaceINTEL(context: cl_context; flags: clMemFlags; resource: d3d_surface9; sharedHandle: IntPtr; plane: UInt32; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateFromDX9MediaSurfaceINTEL_1(context, flags, resource, sharedHandle, plane, errcode_ret);
    
    public EnqueueAcquireDX9ObjectsINTEL_adr := GetProcAddress('clEnqueueAcquireDX9ObjectsINTEL');
    private ntv_EnqueueAcquireDX9ObjectsINTEL_1 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueAcquireDX9ObjectsINTEL_adr);
    private ntv_EnqueueAcquireDX9ObjectsINTEL_2 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueAcquireDX9ObjectsINTEL_adr);
    private ntv_EnqueueAcquireDX9ObjectsINTEL_3 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueAcquireDX9ObjectsINTEL_adr);
    private ntv_EnqueueAcquireDX9ObjectsINTEL_4 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueAcquireDX9ObjectsINTEL_adr);
    private ntv_EnqueueAcquireDX9ObjectsINTEL_5 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueAcquireDX9ObjectsINTEL_adr);
    private ntv_EnqueueAcquireDX9ObjectsINTEL_6 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueAcquireDX9ObjectsINTEL_adr);
    private ntv_EnqueueAcquireDX9ObjectsINTEL_7 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueAcquireDX9ObjectsINTEL_adr);
    private ntv_EnqueueAcquireDX9ObjectsINTEL_8 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueAcquireDX9ObjectsINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireDX9ObjectsINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueAcquireDX9ObjectsINTEL(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueAcquireDX9ObjectsINTEL(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireDX9ObjectsINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueAcquireDX9ObjectsINTEL(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueAcquireDX9ObjectsINTEL(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireDX9ObjectsINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueAcquireDX9ObjectsINTEL_1(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueAcquireDX9ObjectsINTEL_1(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireDX9ObjectsINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueAcquireDX9ObjectsINTEL_2(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueAcquireDX9ObjectsINTEL_2(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireDX9ObjectsINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueAcquireDX9ObjectsINTEL_3(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueAcquireDX9ObjectsINTEL_3(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireDX9ObjectsINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueAcquireDX9ObjectsINTEL_4(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueAcquireDX9ObjectsINTEL_4(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireDX9ObjectsINTEL(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueAcquireDX9ObjectsINTEL_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueAcquireDX9ObjectsINTEL_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireDX9ObjectsINTEL(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueAcquireDX9ObjectsINTEL_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueAcquireDX9ObjectsINTEL_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireDX9ObjectsINTEL(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueAcquireDX9ObjectsINTEL_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireDX9ObjectsINTEL(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueAcquireDX9ObjectsINTEL_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireDX9ObjectsINTEL(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueAcquireDX9ObjectsINTEL_3(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireDX9ObjectsINTEL(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueAcquireDX9ObjectsINTEL_4(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireDX9ObjectsINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueAcquireDX9ObjectsINTEL_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueAcquireDX9ObjectsINTEL_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireDX9ObjectsINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueAcquireDX9ObjectsINTEL_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueAcquireDX9ObjectsINTEL_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireDX9ObjectsINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueAcquireDX9ObjectsINTEL_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireDX9ObjectsINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueAcquireDX9ObjectsINTEL_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireDX9ObjectsINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueAcquireDX9ObjectsINTEL_7(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireDX9ObjectsINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueAcquireDX9ObjectsINTEL_8(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    
    public EnqueueReleaseDX9ObjectsINTEL_adr := GetProcAddress('clEnqueueReleaseDX9ObjectsINTEL');
    private ntv_EnqueueReleaseDX9ObjectsINTEL_1 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueReleaseDX9ObjectsINTEL_adr);
    private ntv_EnqueueReleaseDX9ObjectsINTEL_2 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueReleaseDX9ObjectsINTEL_adr);
    private ntv_EnqueueReleaseDX9ObjectsINTEL_3 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueReleaseDX9ObjectsINTEL_adr);
    private ntv_EnqueueReleaseDX9ObjectsINTEL_4 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueReleaseDX9ObjectsINTEL_adr);
    private ntv_EnqueueReleaseDX9ObjectsINTEL_5 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueReleaseDX9ObjectsINTEL_adr);
    private ntv_EnqueueReleaseDX9ObjectsINTEL_6 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueReleaseDX9ObjectsINTEL_adr);
    private ntv_EnqueueReleaseDX9ObjectsINTEL_7 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueReleaseDX9ObjectsINTEL_adr);
    private ntv_EnqueueReleaseDX9ObjectsINTEL_8 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueReleaseDX9ObjectsINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseDX9ObjectsINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueReleaseDX9ObjectsINTEL(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueReleaseDX9ObjectsINTEL(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseDX9ObjectsINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueReleaseDX9ObjectsINTEL(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueReleaseDX9ObjectsINTEL(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseDX9ObjectsINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueReleaseDX9ObjectsINTEL_1(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueReleaseDX9ObjectsINTEL_1(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseDX9ObjectsINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueReleaseDX9ObjectsINTEL_2(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueReleaseDX9ObjectsINTEL_2(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseDX9ObjectsINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueReleaseDX9ObjectsINTEL_3(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueReleaseDX9ObjectsINTEL_3(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseDX9ObjectsINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueReleaseDX9ObjectsINTEL_4(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueReleaseDX9ObjectsINTEL_4(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseDX9ObjectsINTEL(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReleaseDX9ObjectsINTEL_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReleaseDX9ObjectsINTEL_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseDX9ObjectsINTEL(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReleaseDX9ObjectsINTEL_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReleaseDX9ObjectsINTEL_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseDX9ObjectsINTEL(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReleaseDX9ObjectsINTEL_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseDX9ObjectsINTEL(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReleaseDX9ObjectsINTEL_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseDX9ObjectsINTEL(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReleaseDX9ObjectsINTEL_3(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseDX9ObjectsINTEL(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReleaseDX9ObjectsINTEL_4(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseDX9ObjectsINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReleaseDX9ObjectsINTEL_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReleaseDX9ObjectsINTEL_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseDX9ObjectsINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReleaseDX9ObjectsINTEL_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReleaseDX9ObjectsINTEL_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseDX9ObjectsINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReleaseDX9ObjectsINTEL_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseDX9ObjectsINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReleaseDX9ObjectsINTEL_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseDX9ObjectsINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReleaseDX9ObjectsINTEL_7(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseDX9ObjectsINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReleaseDX9ObjectsINTEL_8(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    
  end;
  
  ///
  clEglImageYuvINTEL = static class
    public const ExtensionString = 'cl_intel_egl_image_yuv';
  end;
  
  ///
  clExecByLocalThreadINTEL = static class
    public const ExtensionString = 'cl_intel_exec_by_local_thread';
  end;
  
  ///
  clMemAllocBufferLocationINTEL = static class
    public const ExtensionString = 'cl_intel_mem_alloc_buffer_location';
  end;
  
  ///
  clMemChannelPropertyINTEL = static class
    public const ExtensionString = 'cl_intel_mem_channel_property';
  end;
  
  ///
  clMemForceHostMemoryINTEL = static class
    public const ExtensionString = 'cl_intel_mem_force_host_memory';
  end;
  
  ///
  clMotionEstimationINTEL = static class
    public const ExtensionString = 'cl_intel_motion_estimation';
  end;
  
  ///
  clPackedYuvINTEL = static class
    public const ExtensionString = 'cl_intel_packed_yuv';
  end;
  
  ///
  clPlanarYuvINTEL = static class
    public const ExtensionString = 'cl_intel_planar_yuv';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clProgramScopeHostPipeINTEL = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clProgramScopeHostPipeINTEL(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_intel_program_scope_host_pipe';
    
    public EnqueueReadHostPipeINTEL_adr := GetProcAddress('clEnqueueReadHostPipeINTEL');
    private ntv_EnqueueReadHostPipeINTEL_1 := GetProcOrNil&<function(command_queue: cl_command_queue; &program: cl_program; pipe_symbol: IntPtr; blocking_read: clBool; ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueReadHostPipeINTEL_adr);
    private ntv_EnqueueReadHostPipeINTEL_2 := GetProcOrNil&<function(command_queue: cl_command_queue; &program: cl_program; pipe_symbol: IntPtr; blocking_read: clBool; ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueReadHostPipeINTEL_adr);
    private ntv_EnqueueReadHostPipeINTEL_3 := GetProcOrNil&<function(command_queue: cl_command_queue; &program: cl_program; pipe_symbol: IntPtr; blocking_read: clBool; ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueReadHostPipeINTEL_adr);
    private ntv_EnqueueReadHostPipeINTEL_4 := GetProcOrNil&<function(command_queue: cl_command_queue; &program: cl_program; pipe_symbol: IntPtr; blocking_read: clBool; ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueReadHostPipeINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReadHostPipeINTEL(command_queue: cl_command_queue; &program: cl_program; pipe_symbol: string; blocking_read: clBool; ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueReadHostPipeINTEL(command_queue, &program, pipe_symbol, blocking_read, ptr, size, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueReadHostPipeINTEL(command_queue, &program, pipe_symbol, blocking_read, ptr, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReadHostPipeINTEL(command_queue: cl_command_queue; &program: cl_program; pipe_symbol: string; blocking_read: clBool; ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueReadHostPipeINTEL(command_queue, &program, pipe_symbol, blocking_read, ptr, size, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueReadHostPipeINTEL(command_queue, &program, pipe_symbol, blocking_read, ptr, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReadHostPipeINTEL(command_queue: cl_command_queue; &program: cl_program; pipe_symbol: string; blocking_read: clBool; ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    begin
      var pipe_symbol_str_ptr := Marshal.StringToHGlobalAnsi(pipe_symbol);
      try
        Result := ntv_EnqueueReadHostPipeINTEL_1(command_queue, &program, pipe_symbol_str_ptr, blocking_read, ptr, size, num_events_in_wait_list, event_wait_list, &event);
      finally
        Marshal.FreeHGlobal(pipe_symbol_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReadHostPipeINTEL(command_queue: cl_command_queue; &program: cl_program; pipe_symbol: string; blocking_read: clBool; ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    begin
      var pipe_symbol_str_ptr := Marshal.StringToHGlobalAnsi(pipe_symbol);
      try
        Result := ntv_EnqueueReadHostPipeINTEL_2(command_queue, &program, pipe_symbol_str_ptr, blocking_read, ptr, size, num_events_in_wait_list, event_wait_list, &event);
      finally
        Marshal.FreeHGlobal(pipe_symbol_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReadHostPipeINTEL(command_queue: cl_command_queue; &program: cl_program; pipe_symbol: string; blocking_read: clBool; ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    begin
      var pipe_symbol_str_ptr := Marshal.StringToHGlobalAnsi(pipe_symbol);
      try
        Result := ntv_EnqueueReadHostPipeINTEL_3(command_queue, &program, pipe_symbol_str_ptr, blocking_read, ptr, size, num_events_in_wait_list, event_wait_list, &event);
      finally
        Marshal.FreeHGlobal(pipe_symbol_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReadHostPipeINTEL(command_queue: cl_command_queue; &program: cl_program; pipe_symbol: string; blocking_read: clBool; ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    begin
      var pipe_symbol_str_ptr := Marshal.StringToHGlobalAnsi(pipe_symbol);
      try
        Result := ntv_EnqueueReadHostPipeINTEL_4(command_queue, &program, pipe_symbol_str_ptr, blocking_read, ptr, size, num_events_in_wait_list, event_wait_list, &event);
      finally
        Marshal.FreeHGlobal(pipe_symbol_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReadHostPipeINTEL(command_queue: cl_command_queue; &program: cl_program; pipe_symbol: IntPtr; blocking_read: clBool; ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReadHostPipeINTEL_1(command_queue, &program, pipe_symbol, blocking_read, ptr, size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReadHostPipeINTEL_1(command_queue, &program, pipe_symbol, blocking_read, ptr, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReadHostPipeINTEL(command_queue: cl_command_queue; &program: cl_program; pipe_symbol: IntPtr; blocking_read: clBool; ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReadHostPipeINTEL_2(command_queue, &program, pipe_symbol, blocking_read, ptr, size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReadHostPipeINTEL_2(command_queue, &program, pipe_symbol, blocking_read, ptr, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReadHostPipeINTEL(command_queue: cl_command_queue; &program: cl_program; pipe_symbol: IntPtr; blocking_read: clBool; ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReadHostPipeINTEL_1(command_queue, &program, pipe_symbol, blocking_read, ptr, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReadHostPipeINTEL(command_queue: cl_command_queue; &program: cl_program; pipe_symbol: IntPtr; blocking_read: clBool; ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReadHostPipeINTEL_2(command_queue, &program, pipe_symbol, blocking_read, ptr, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReadHostPipeINTEL(command_queue: cl_command_queue; &program: cl_program; pipe_symbol: IntPtr; blocking_read: clBool; ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReadHostPipeINTEL_3(command_queue, &program, pipe_symbol, blocking_read, ptr, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReadHostPipeINTEL(command_queue: cl_command_queue; &program: cl_program; pipe_symbol: IntPtr; blocking_read: clBool; ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReadHostPipeINTEL_4(command_queue, &program, pipe_symbol, blocking_read, ptr, size, num_events_in_wait_list, event_wait_list, &event);
    
    public EnqueueWriteHostPipeINTEL_adr := GetProcAddress('clEnqueueWriteHostPipeINTEL');
    private ntv_EnqueueWriteHostPipeINTEL_1 := GetProcOrNil&<function(command_queue: cl_command_queue; &program: cl_program; pipe_symbol: IntPtr; blocking_write: clBool; ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueWriteHostPipeINTEL_adr);
    private ntv_EnqueueWriteHostPipeINTEL_2 := GetProcOrNil&<function(command_queue: cl_command_queue; &program: cl_program; pipe_symbol: IntPtr; blocking_write: clBool; ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueWriteHostPipeINTEL_adr);
    private ntv_EnqueueWriteHostPipeINTEL_3 := GetProcOrNil&<function(command_queue: cl_command_queue; &program: cl_program; pipe_symbol: IntPtr; blocking_write: clBool; ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueWriteHostPipeINTEL_adr);
    private ntv_EnqueueWriteHostPipeINTEL_4 := GetProcOrNil&<function(command_queue: cl_command_queue; &program: cl_program; pipe_symbol: IntPtr; blocking_write: clBool; ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueWriteHostPipeINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWriteHostPipeINTEL(command_queue: cl_command_queue; &program: cl_program; pipe_symbol: string; blocking_write: clBool; ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueWriteHostPipeINTEL(command_queue, &program, pipe_symbol, blocking_write, ptr, size, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueWriteHostPipeINTEL(command_queue, &program, pipe_symbol, blocking_write, ptr, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWriteHostPipeINTEL(command_queue: cl_command_queue; &program: cl_program; pipe_symbol: string; blocking_write: clBool; ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueWriteHostPipeINTEL(command_queue, &program, pipe_symbol, blocking_write, ptr, size, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueWriteHostPipeINTEL(command_queue, &program, pipe_symbol, blocking_write, ptr, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWriteHostPipeINTEL(command_queue: cl_command_queue; &program: cl_program; pipe_symbol: string; blocking_write: clBool; ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    begin
      var pipe_symbol_str_ptr := Marshal.StringToHGlobalAnsi(pipe_symbol);
      try
        Result := ntv_EnqueueWriteHostPipeINTEL_1(command_queue, &program, pipe_symbol_str_ptr, blocking_write, ptr, size, num_events_in_wait_list, event_wait_list, &event);
      finally
        Marshal.FreeHGlobal(pipe_symbol_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWriteHostPipeINTEL(command_queue: cl_command_queue; &program: cl_program; pipe_symbol: string; blocking_write: clBool; ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    begin
      var pipe_symbol_str_ptr := Marshal.StringToHGlobalAnsi(pipe_symbol);
      try
        Result := ntv_EnqueueWriteHostPipeINTEL_2(command_queue, &program, pipe_symbol_str_ptr, blocking_write, ptr, size, num_events_in_wait_list, event_wait_list, &event);
      finally
        Marshal.FreeHGlobal(pipe_symbol_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWriteHostPipeINTEL(command_queue: cl_command_queue; &program: cl_program; pipe_symbol: string; blocking_write: clBool; ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    begin
      var pipe_symbol_str_ptr := Marshal.StringToHGlobalAnsi(pipe_symbol);
      try
        Result := ntv_EnqueueWriteHostPipeINTEL_3(command_queue, &program, pipe_symbol_str_ptr, blocking_write, ptr, size, num_events_in_wait_list, event_wait_list, &event);
      finally
        Marshal.FreeHGlobal(pipe_symbol_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWriteHostPipeINTEL(command_queue: cl_command_queue; &program: cl_program; pipe_symbol: string; blocking_write: clBool; ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    begin
      var pipe_symbol_str_ptr := Marshal.StringToHGlobalAnsi(pipe_symbol);
      try
        Result := ntv_EnqueueWriteHostPipeINTEL_4(command_queue, &program, pipe_symbol_str_ptr, blocking_write, ptr, size, num_events_in_wait_list, event_wait_list, &event);
      finally
        Marshal.FreeHGlobal(pipe_symbol_str_ptr);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWriteHostPipeINTEL(command_queue: cl_command_queue; &program: cl_program; pipe_symbol: IntPtr; blocking_write: clBool; ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueWriteHostPipeINTEL_1(command_queue, &program, pipe_symbol, blocking_write, ptr, size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueWriteHostPipeINTEL_1(command_queue, &program, pipe_symbol, blocking_write, ptr, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWriteHostPipeINTEL(command_queue: cl_command_queue; &program: cl_program; pipe_symbol: IntPtr; blocking_write: clBool; ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueWriteHostPipeINTEL_2(command_queue, &program, pipe_symbol, blocking_write, ptr, size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueWriteHostPipeINTEL_2(command_queue, &program, pipe_symbol, blocking_write, ptr, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWriteHostPipeINTEL(command_queue: cl_command_queue; &program: cl_program; pipe_symbol: IntPtr; blocking_write: clBool; ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueWriteHostPipeINTEL_1(command_queue, &program, pipe_symbol, blocking_write, ptr, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWriteHostPipeINTEL(command_queue: cl_command_queue; &program: cl_program; pipe_symbol: IntPtr; blocking_write: clBool; ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueWriteHostPipeINTEL_2(command_queue, &program, pipe_symbol, blocking_write, ptr, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWriteHostPipeINTEL(command_queue: cl_command_queue; &program: cl_program; pipe_symbol: IntPtr; blocking_write: clBool; ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueWriteHostPipeINTEL_3(command_queue, &program, pipe_symbol, blocking_write, ptr, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWriteHostPipeINTEL(command_queue: cl_command_queue; &program: cl_program; pipe_symbol: IntPtr; blocking_write: clBool; ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueWriteHostPipeINTEL_4(command_queue, &program, pipe_symbol, blocking_write, ptr, size, num_events_in_wait_list, event_wait_list, &event);
    
  end;
  
  ///
  clQueueNoSyncOperationsINTEL = static class
    public const ExtensionString = 'cl_intel_queue_no_sync_operations';
  end;
  
  ///
  clRequiredSubgroupSizeINTEL = static class
    public const ExtensionString = 'cl_intel_required_subgroup_size';
  end;
  
  ///
  clSharingFormatQueryINTEL = static class
    public const ExtensionString = 'cl_intel_sharing_format_query';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clSharingFormatQueryD3d10INTEL = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clSharingFormatQueryD3d10INTEL(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_intel_sharing_format_query_d3d10';
    
    public GetSupportedD3D10TextureFormatsINTEL_adr := GetProcAddress('clGetSupportedD3D10TextureFormatsINTEL');
    private ntv_GetSupportedD3D10TextureFormatsINTEL_1 := GetProcOrNil&<function(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; num_entries: UInt32; var d3d10_formats: d3d_pixel_format; var num_texture_formats: UInt32): clErrorCode>(GetSupportedD3D10TextureFormatsINTEL_adr);
    private ntv_GetSupportedD3D10TextureFormatsINTEL_2 := GetProcOrNil&<function(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; num_entries: UInt32; var d3d10_formats: d3d_pixel_format; num_texture_formats: IntPtr): clErrorCode>(GetSupportedD3D10TextureFormatsINTEL_adr);
    private ntv_GetSupportedD3D10TextureFormatsINTEL_3 := GetProcOrNil&<function(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; num_entries: UInt32; d3d10_formats: IntPtr; var num_texture_formats: UInt32): clErrorCode>(GetSupportedD3D10TextureFormatsINTEL_adr);
    private ntv_GetSupportedD3D10TextureFormatsINTEL_4 := GetProcOrNil&<function(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; num_entries: UInt32; d3d10_formats: IntPtr; num_texture_formats: IntPtr): clErrorCode>(GetSupportedD3D10TextureFormatsINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSupportedD3D10TextureFormatsINTEL(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; num_entries: UInt32; var d3d10_formats: d3d_pixel_format; var num_texture_formats: UInt32): clErrorCode :=
      ntv_GetSupportedD3D10TextureFormatsINTEL_1(context, flags, image_type, num_entries, d3d10_formats, num_texture_formats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSupportedD3D10TextureFormatsINTEL(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; num_entries: UInt32; var d3d10_formats: d3d_pixel_format; num_texture_formats: IntPtr): clErrorCode :=
      ntv_GetSupportedD3D10TextureFormatsINTEL_2(context, flags, image_type, num_entries, d3d10_formats, num_texture_formats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSupportedD3D10TextureFormatsINTEL(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; num_entries: UInt32; d3d10_formats: IntPtr; var num_texture_formats: UInt32): clErrorCode :=
      ntv_GetSupportedD3D10TextureFormatsINTEL_3(context, flags, image_type, num_entries, d3d10_formats, num_texture_formats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSupportedD3D10TextureFormatsINTEL(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; num_entries: UInt32; d3d10_formats: IntPtr; num_texture_formats: IntPtr): clErrorCode :=
      ntv_GetSupportedD3D10TextureFormatsINTEL_4(context, flags, image_type, num_entries, d3d10_formats, num_texture_formats);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clSharingFormatQueryD3d11INTEL = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clSharingFormatQueryD3d11INTEL(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_intel_sharing_format_query_d3d11';
    
    public GetSupportedD3D11TextureFormatsINTEL_adr := GetProcAddress('clGetSupportedD3D11TextureFormatsINTEL');
    private ntv_GetSupportedD3D11TextureFormatsINTEL_1 := GetProcOrNil&<function(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; plane: UInt32; num_entries: UInt32; var d3d11_formats: d3d_pixel_format; var num_texture_formats: UInt32): clErrorCode>(GetSupportedD3D11TextureFormatsINTEL_adr);
    private ntv_GetSupportedD3D11TextureFormatsINTEL_2 := GetProcOrNil&<function(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; plane: UInt32; num_entries: UInt32; var d3d11_formats: d3d_pixel_format; num_texture_formats: IntPtr): clErrorCode>(GetSupportedD3D11TextureFormatsINTEL_adr);
    private ntv_GetSupportedD3D11TextureFormatsINTEL_3 := GetProcOrNil&<function(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; plane: UInt32; num_entries: UInt32; d3d11_formats: IntPtr; var num_texture_formats: UInt32): clErrorCode>(GetSupportedD3D11TextureFormatsINTEL_adr);
    private ntv_GetSupportedD3D11TextureFormatsINTEL_4 := GetProcOrNil&<function(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; plane: UInt32; num_entries: UInt32; d3d11_formats: IntPtr; num_texture_formats: IntPtr): clErrorCode>(GetSupportedD3D11TextureFormatsINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSupportedD3D11TextureFormatsINTEL(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; plane: UInt32; num_entries: UInt32; var d3d11_formats: d3d_pixel_format; var num_texture_formats: UInt32): clErrorCode :=
      ntv_GetSupportedD3D11TextureFormatsINTEL_1(context, flags, image_type, plane, num_entries, d3d11_formats, num_texture_formats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSupportedD3D11TextureFormatsINTEL(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; plane: UInt32; num_entries: UInt32; var d3d11_formats: d3d_pixel_format; num_texture_formats: IntPtr): clErrorCode :=
      ntv_GetSupportedD3D11TextureFormatsINTEL_2(context, flags, image_type, plane, num_entries, d3d11_formats, num_texture_formats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSupportedD3D11TextureFormatsINTEL(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; plane: UInt32; num_entries: UInt32; d3d11_formats: IntPtr; var num_texture_formats: UInt32): clErrorCode :=
      ntv_GetSupportedD3D11TextureFormatsINTEL_3(context, flags, image_type, plane, num_entries, d3d11_formats, num_texture_formats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSupportedD3D11TextureFormatsINTEL(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; plane: UInt32; num_entries: UInt32; d3d11_formats: IntPtr; num_texture_formats: IntPtr): clErrorCode :=
      ntv_GetSupportedD3D11TextureFormatsINTEL_4(context, flags, image_type, plane, num_entries, d3d11_formats, num_texture_formats);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clSharingFormatQueryDx9INTEL = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clSharingFormatQueryDx9INTEL(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_intel_sharing_format_query_dx9';
    
    public GetSupportedDX9MediaSurfaceFormatsINTEL_adr := GetProcAddress('clGetSupportedDX9MediaSurfaceFormatsINTEL');
    private ntv_GetSupportedDX9MediaSurfaceFormatsINTEL_1 := GetProcOrNil&<function(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; plane: UInt32; num_entries: UInt32; var dx9_formats: d3d_pixel_format; var num_surface_formats: UInt32): clErrorCode>(GetSupportedDX9MediaSurfaceFormatsINTEL_adr);
    private ntv_GetSupportedDX9MediaSurfaceFormatsINTEL_2 := GetProcOrNil&<function(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; plane: UInt32; num_entries: UInt32; var dx9_formats: d3d_pixel_format; num_surface_formats: IntPtr): clErrorCode>(GetSupportedDX9MediaSurfaceFormatsINTEL_adr);
    private ntv_GetSupportedDX9MediaSurfaceFormatsINTEL_3 := GetProcOrNil&<function(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; plane: UInt32; num_entries: UInt32; dx9_formats: IntPtr; var num_surface_formats: UInt32): clErrorCode>(GetSupportedDX9MediaSurfaceFormatsINTEL_adr);
    private ntv_GetSupportedDX9MediaSurfaceFormatsINTEL_4 := GetProcOrNil&<function(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; plane: UInt32; num_entries: UInt32; dx9_formats: IntPtr; num_surface_formats: IntPtr): clErrorCode>(GetSupportedDX9MediaSurfaceFormatsINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSupportedDX9MediaSurfaceFormatsINTEL(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; plane: UInt32; num_entries: UInt32; var dx9_formats: d3d_pixel_format; var num_surface_formats: UInt32): clErrorCode :=
      ntv_GetSupportedDX9MediaSurfaceFormatsINTEL_1(context, flags, image_type, plane, num_entries, dx9_formats, num_surface_formats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSupportedDX9MediaSurfaceFormatsINTEL(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; plane: UInt32; num_entries: UInt32; var dx9_formats: d3d_pixel_format; num_surface_formats: IntPtr): clErrorCode :=
      ntv_GetSupportedDX9MediaSurfaceFormatsINTEL_2(context, flags, image_type, plane, num_entries, dx9_formats, num_surface_formats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSupportedDX9MediaSurfaceFormatsINTEL(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; plane: UInt32; num_entries: UInt32; dx9_formats: IntPtr; var num_surface_formats: UInt32): clErrorCode :=
      ntv_GetSupportedDX9MediaSurfaceFormatsINTEL_3(context, flags, image_type, plane, num_entries, dx9_formats, num_surface_formats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSupportedDX9MediaSurfaceFormatsINTEL(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; plane: UInt32; num_entries: UInt32; dx9_formats: IntPtr; num_surface_formats: IntPtr): clErrorCode :=
      ntv_GetSupportedDX9MediaSurfaceFormatsINTEL_4(context, flags, image_type, plane, num_entries, dx9_formats, num_surface_formats);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clSharingFormatQueryGlINTEL = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clSharingFormatQueryGlINTEL(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_intel_sharing_format_query_gl';
    
    public GetSupportedGLTextureFormatsINTEL_adr := GetProcAddress('clGetSupportedGLTextureFormatsINTEL');
    private ntv_GetSupportedGLTextureFormatsINTEL_1 := GetProcOrNil&<function(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; num_entries: UInt32; var gl_formats: UInt32; var num_texture_formats: UInt32): clErrorCode>(GetSupportedGLTextureFormatsINTEL_adr);
    private ntv_GetSupportedGLTextureFormatsINTEL_2 := GetProcOrNil&<function(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; num_entries: UInt32; var gl_formats: UInt32; num_texture_formats: IntPtr): clErrorCode>(GetSupportedGLTextureFormatsINTEL_adr);
    private ntv_GetSupportedGLTextureFormatsINTEL_3 := GetProcOrNil&<function(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; num_entries: UInt32; gl_formats: IntPtr; var num_texture_formats: UInt32): clErrorCode>(GetSupportedGLTextureFormatsINTEL_adr);
    private ntv_GetSupportedGLTextureFormatsINTEL_4 := GetProcOrNil&<function(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; num_entries: UInt32; gl_formats: IntPtr; num_texture_formats: IntPtr): clErrorCode>(GetSupportedGLTextureFormatsINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSupportedGLTextureFormatsINTEL(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; num_entries: UInt32; var gl_formats: UInt32; var num_texture_formats: UInt32): clErrorCode :=
      ntv_GetSupportedGLTextureFormatsINTEL_1(context, flags, image_type, num_entries, gl_formats, num_texture_formats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSupportedGLTextureFormatsINTEL(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; num_entries: UInt32; var gl_formats: UInt32; num_texture_formats: IntPtr): clErrorCode :=
      ntv_GetSupportedGLTextureFormatsINTEL_2(context, flags, image_type, num_entries, gl_formats, num_texture_formats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSupportedGLTextureFormatsINTEL(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; num_entries: UInt32; gl_formats: IntPtr; var num_texture_formats: UInt32): clErrorCode :=
      ntv_GetSupportedGLTextureFormatsINTEL_3(context, flags, image_type, num_entries, gl_formats, num_texture_formats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSupportedGLTextureFormatsINTEL(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; num_entries: UInt32; gl_formats: IntPtr; num_texture_formats: IntPtr): clErrorCode :=
      ntv_GetSupportedGLTextureFormatsINTEL_4(context, flags, image_type, num_entries, gl_formats, num_texture_formats);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clSharingFormatQueryVaApiINTEL = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clSharingFormatQueryVaApiINTEL(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_intel_sharing_format_query_va_api';
    
    public GetSupportedVA_APIMediaSurfaceFormatsINTEL_adr := GetProcAddress('clGetSupportedVA_APIMediaSurfaceFormatsINTEL');
    private ntv_GetSupportedVA_APIMediaSurfaceFormatsINTEL_1 := GetProcOrNil&<function(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; plane: UInt32; num_entries: UInt32; var va_api_formats: va_image_format; var num_surface_formats: UInt32): clErrorCode>(GetSupportedVA_APIMediaSurfaceFormatsINTEL_adr);
    private ntv_GetSupportedVA_APIMediaSurfaceFormatsINTEL_2 := GetProcOrNil&<function(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; plane: UInt32; num_entries: UInt32; var va_api_formats: va_image_format; num_surface_formats: IntPtr): clErrorCode>(GetSupportedVA_APIMediaSurfaceFormatsINTEL_adr);
    private ntv_GetSupportedVA_APIMediaSurfaceFormatsINTEL_3 := GetProcOrNil&<function(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; plane: UInt32; num_entries: UInt32; va_api_formats: IntPtr; var num_surface_formats: UInt32): clErrorCode>(GetSupportedVA_APIMediaSurfaceFormatsINTEL_adr);
    private ntv_GetSupportedVA_APIMediaSurfaceFormatsINTEL_4 := GetProcOrNil&<function(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; plane: UInt32; num_entries: UInt32; va_api_formats: IntPtr; num_surface_formats: IntPtr): clErrorCode>(GetSupportedVA_APIMediaSurfaceFormatsINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSupportedVA_APIMediaSurfaceFormatsINTEL(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; plane: UInt32; num_entries: UInt32; var va_api_formats: va_image_format; var num_surface_formats: UInt32): clErrorCode :=
      ntv_GetSupportedVA_APIMediaSurfaceFormatsINTEL_1(context, flags, image_type, plane, num_entries, va_api_formats, num_surface_formats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSupportedVA_APIMediaSurfaceFormatsINTEL(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; plane: UInt32; num_entries: UInt32; var va_api_formats: va_image_format; num_surface_formats: IntPtr): clErrorCode :=
      ntv_GetSupportedVA_APIMediaSurfaceFormatsINTEL_2(context, flags, image_type, plane, num_entries, va_api_formats, num_surface_formats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSupportedVA_APIMediaSurfaceFormatsINTEL(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; plane: UInt32; num_entries: UInt32; va_api_formats: IntPtr; var num_surface_formats: UInt32): clErrorCode :=
      ntv_GetSupportedVA_APIMediaSurfaceFormatsINTEL_3(context, flags, image_type, plane, num_entries, va_api_formats, num_surface_formats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSupportedVA_APIMediaSurfaceFormatsINTEL(context: cl_context; flags: clMemFlags; image_type: clMemObjectType; plane: UInt32; num_entries: UInt32; va_api_formats: IntPtr; num_surface_formats: IntPtr): clErrorCode :=
      ntv_GetSupportedVA_APIMediaSurfaceFormatsINTEL_4(context, flags, image_type, plane, num_entries, va_api_formats, num_surface_formats);
    
  end;
  
  ///
  clSimultaneousSharingINTEL = static class
    public const ExtensionString = 'cl_intel_simultaneous_sharing';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clUnifiedSharedMemoryINTEL = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clUnifiedSharedMemoryINTEL(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_intel_unified_shared_memory';
    
    public HostMemAllocINTEL_adr := GetProcAddress('clHostMemAllocINTEL');
    private ntv_HostMemAllocINTEL_1 := GetProcOrNil&<function(context: cl_context; var properties: clMemPropertiesINTEL; size: UIntPtr; alignment: UInt32; var errcode_ret: clErrorCode): IntPtr>(HostMemAllocINTEL_adr);
    private ntv_HostMemAllocINTEL_2 := GetProcOrNil&<function(context: cl_context; properties: IntPtr; size: UIntPtr; alignment: UInt32; var errcode_ret: clErrorCode): IntPtr>(HostMemAllocINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function HostMemAllocINTEL(context: cl_context; properties: array of clMemPropertiesINTEL; size: UIntPtr; alignment: UInt32; var errcode_ret: clErrorCode): IntPtr;
    type PClMemPropertiesINTEL = ^clMemPropertiesINTEL;
    begin
      Result := if (properties<>nil) and (properties.Length<>0) then
        ntv_HostMemAllocINTEL_1(context, properties[0], size, alignment, errcode_ret) else
        ntv_HostMemAllocINTEL_1(context, PClMemPropertiesINTEL(nil)^, size, alignment, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function HostMemAllocINTEL(context: cl_context; var properties: clMemPropertiesINTEL; size: UIntPtr; alignment: UInt32; var errcode_ret: clErrorCode): IntPtr :=
      ntv_HostMemAllocINTEL_1(context, properties, size, alignment, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function HostMemAllocINTEL(context: cl_context; properties: IntPtr; size: UIntPtr; alignment: UInt32; var errcode_ret: clErrorCode): IntPtr :=
      ntv_HostMemAllocINTEL_2(context, properties, size, alignment, errcode_ret);
    
    public DeviceMemAllocINTEL_adr := GetProcAddress('clDeviceMemAllocINTEL');
    private ntv_DeviceMemAllocINTEL_1 := GetProcOrNil&<function(context: cl_context; device: cl_device_id; var properties: clMemPropertiesINTEL; size: UIntPtr; alignment: UInt32; var errcode_ret: clErrorCode): IntPtr>(DeviceMemAllocINTEL_adr);
    private ntv_DeviceMemAllocINTEL_2 := GetProcOrNil&<function(context: cl_context; device: cl_device_id; properties: IntPtr; size: UIntPtr; alignment: UInt32; var errcode_ret: clErrorCode): IntPtr>(DeviceMemAllocINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DeviceMemAllocINTEL(context: cl_context; device: cl_device_id; properties: array of clMemPropertiesINTEL; size: UIntPtr; alignment: UInt32; var errcode_ret: clErrorCode): IntPtr;
    type PClMemPropertiesINTEL = ^clMemPropertiesINTEL;
    begin
      Result := if (properties<>nil) and (properties.Length<>0) then
        ntv_DeviceMemAllocINTEL_1(context, device, properties[0], size, alignment, errcode_ret) else
        ntv_DeviceMemAllocINTEL_1(context, device, PClMemPropertiesINTEL(nil)^, size, alignment, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DeviceMemAllocINTEL(context: cl_context; device: cl_device_id; var properties: clMemPropertiesINTEL; size: UIntPtr; alignment: UInt32; var errcode_ret: clErrorCode): IntPtr :=
      ntv_DeviceMemAllocINTEL_1(context, device, properties, size, alignment, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DeviceMemAllocINTEL(context: cl_context; device: cl_device_id; properties: IntPtr; size: UIntPtr; alignment: UInt32; var errcode_ret: clErrorCode): IntPtr :=
      ntv_DeviceMemAllocINTEL_2(context, device, properties, size, alignment, errcode_ret);
    
    public SharedMemAllocINTEL_adr := GetProcAddress('clSharedMemAllocINTEL');
    private ntv_SharedMemAllocINTEL_1 := GetProcOrNil&<function(context: cl_context; device: cl_device_id; var properties: clMemPropertiesINTEL; size: UIntPtr; alignment: UInt32; var errcode_ret: clErrorCode): IntPtr>(SharedMemAllocINTEL_adr);
    private ntv_SharedMemAllocINTEL_2 := GetProcOrNil&<function(context: cl_context; device: cl_device_id; properties: IntPtr; size: UIntPtr; alignment: UInt32; var errcode_ret: clErrorCode): IntPtr>(SharedMemAllocINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SharedMemAllocINTEL(context: cl_context; device: cl_device_id; properties: array of clMemPropertiesINTEL; size: UIntPtr; alignment: UInt32; var errcode_ret: clErrorCode): IntPtr;
    type PClMemPropertiesINTEL = ^clMemPropertiesINTEL;
    begin
      Result := if (properties<>nil) and (properties.Length<>0) then
        ntv_SharedMemAllocINTEL_1(context, device, properties[0], size, alignment, errcode_ret) else
        ntv_SharedMemAllocINTEL_1(context, device, PClMemPropertiesINTEL(nil)^, size, alignment, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SharedMemAllocINTEL(context: cl_context; device: cl_device_id; var properties: clMemPropertiesINTEL; size: UIntPtr; alignment: UInt32; var errcode_ret: clErrorCode): IntPtr :=
      ntv_SharedMemAllocINTEL_1(context, device, properties, size, alignment, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SharedMemAllocINTEL(context: cl_context; device: cl_device_id; properties: IntPtr; size: UIntPtr; alignment: UInt32; var errcode_ret: clErrorCode): IntPtr :=
      ntv_SharedMemAllocINTEL_2(context, device, properties, size, alignment, errcode_ret);
    
    public MemFreeINTEL_adr := GetProcAddress('clMemFreeINTEL');
    private ntv_MemFreeINTEL_1 := GetProcOrNil&<function(context: cl_context; ptr: IntPtr): clErrorCode>(MemFreeINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MemFreeINTEL(context: cl_context; ptr: IntPtr): clErrorCode :=
      ntv_MemFreeINTEL_1(context, ptr);
    
    public MemBlockingFreeINTEL_adr := GetProcAddress('clMemBlockingFreeINTEL');
    private ntv_MemBlockingFreeINTEL_1 := GetProcOrNil&<function(context: cl_context; ptr: IntPtr): clErrorCode>(MemBlockingFreeINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MemBlockingFreeINTEL(context: cl_context; ptr: IntPtr): clErrorCode :=
      ntv_MemBlockingFreeINTEL_1(context, ptr);
    
    public GetMemAllocInfoINTEL_adr := GetProcAddress('clGetMemAllocInfoINTEL');
    private ntv_GetMemAllocInfoINTEL_1 := GetProcOrNil&<function(context: cl_context; ptr: IntPtr; param_name: clMemInfoINTEL; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode>(GetMemAllocInfoINTEL_adr);
    private ntv_GetMemAllocInfoINTEL_2 := GetProcOrNil&<function(context: cl_context; ptr: IntPtr; param_name: clMemInfoINTEL; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode>(GetMemAllocInfoINTEL_adr);
    private ntv_GetMemAllocInfoINTEL_3 := GetProcOrNil&<function(context: cl_context; ptr: IntPtr; param_name: clMemInfoINTEL; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode>(GetMemAllocInfoINTEL_adr);
    private ntv_GetMemAllocInfoINTEL_4 := GetProcOrNil&<function(context: cl_context; ptr: IntPtr; param_name: clMemInfoINTEL; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode>(GetMemAllocInfoINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMemAllocInfoINTEL<T>(context: cl_context; ptr: IntPtr; param_name: clMemInfoINTEL; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetMemAllocInfoINTEL_1(context, ptr, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMemAllocInfoINTEL<T>(context: cl_context; ptr: IntPtr; param_name: clMemInfoINTEL; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetMemAllocInfoINTEL_2(context, ptr, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMemAllocInfoINTEL_MEM_ALLOC_BUFFER_LOCATION(context: cl_context; ptr: IntPtr; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetMemAllocInfoINTEL(context, ptr, clMemInfoINTEL.MEM_ALLOC_BUFFER_LOCATION, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMemAllocInfoINTEL(context: cl_context; ptr: IntPtr; param_name: clMemInfoINTEL; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetMemAllocInfoINTEL_3(context, ptr, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMemAllocInfoINTEL(context: cl_context; ptr: IntPtr; param_name: clMemInfoINTEL; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetMemAllocInfoINTEL_4(context, ptr, param_name, param_value_size, param_value, param_value_size_ret);
    
    public SetKernelArgMemPointerINTEL_adr := GetProcAddress('clSetKernelArgMemPointerINTEL');
    private ntv_SetKernelArgMemPointerINTEL_1 := GetProcOrNil&<function(kernel: cl_kernel; arg_index: UInt32; arg_value: IntPtr): clErrorCode>(SetKernelArgMemPointerINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetKernelArgMemPointerINTEL(kernel: cl_kernel; arg_index: UInt32; arg_value: IntPtr): clErrorCode :=
      ntv_SetKernelArgMemPointerINTEL_1(kernel, arg_index, arg_value);
    
    public EnqueueMemFillINTEL_adr := GetProcAddress('clEnqueueMemFillINTEL');
    private ntv_EnqueueMemFillINTEL_1 := GetProcOrNil&<function(command_queue: cl_command_queue; dst_ptr: IntPtr; pattern: IntPtr; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueMemFillINTEL_adr);
    private ntv_EnqueueMemFillINTEL_2 := GetProcOrNil&<function(command_queue: cl_command_queue; dst_ptr: IntPtr; pattern: IntPtr; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueMemFillINTEL_adr);
    private ntv_EnqueueMemFillINTEL_3 := GetProcOrNil&<function(command_queue: cl_command_queue; dst_ptr: IntPtr; pattern: IntPtr; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueMemFillINTEL_adr);
    private ntv_EnqueueMemFillINTEL_4 := GetProcOrNil&<function(command_queue: cl_command_queue; dst_ptr: IntPtr; pattern: IntPtr; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueMemFillINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMemFillINTEL(command_queue: cl_command_queue; dst_ptr: IntPtr; pattern: IntPtr; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueMemFillINTEL_1(command_queue, dst_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueMemFillINTEL_1(command_queue, dst_ptr, pattern, pattern_size, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMemFillINTEL(command_queue: cl_command_queue; dst_ptr: IntPtr; pattern: IntPtr; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueMemFillINTEL_2(command_queue, dst_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueMemFillINTEL_2(command_queue, dst_ptr, pattern, pattern_size, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMemFillINTEL(command_queue: cl_command_queue; dst_ptr: IntPtr; pattern: IntPtr; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueMemFillINTEL_1(command_queue, dst_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMemFillINTEL(command_queue: cl_command_queue; dst_ptr: IntPtr; pattern: IntPtr; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueMemFillINTEL_2(command_queue, dst_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMemFillINTEL(command_queue: cl_command_queue; dst_ptr: IntPtr; pattern: IntPtr; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueMemFillINTEL_3(command_queue, dst_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMemFillINTEL(command_queue: cl_command_queue; dst_ptr: IntPtr; pattern: IntPtr; pattern_size: UIntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueMemFillINTEL_4(command_queue, dst_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list, &event);
    
    public EnqueueMemcpyINTEL_adr := GetProcAddress('clEnqueueMemcpyINTEL');
    private ntv_EnqueueMemcpyINTEL_1 := GetProcOrNil&<function(command_queue: cl_command_queue; blocking: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueMemcpyINTEL_adr);
    private ntv_EnqueueMemcpyINTEL_2 := GetProcOrNil&<function(command_queue: cl_command_queue; blocking: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueMemcpyINTEL_adr);
    private ntv_EnqueueMemcpyINTEL_3 := GetProcOrNil&<function(command_queue: cl_command_queue; blocking: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueMemcpyINTEL_adr);
    private ntv_EnqueueMemcpyINTEL_4 := GetProcOrNil&<function(command_queue: cl_command_queue; blocking: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueMemcpyINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMemcpyINTEL(command_queue: cl_command_queue; blocking: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueMemcpyINTEL_1(command_queue, blocking, dst_ptr, src_ptr, size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueMemcpyINTEL_1(command_queue, blocking, dst_ptr, src_ptr, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMemcpyINTEL(command_queue: cl_command_queue; blocking: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueMemcpyINTEL_2(command_queue, blocking, dst_ptr, src_ptr, size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueMemcpyINTEL_2(command_queue, blocking, dst_ptr, src_ptr, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMemcpyINTEL(command_queue: cl_command_queue; blocking: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueMemcpyINTEL_1(command_queue, blocking, dst_ptr, src_ptr, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMemcpyINTEL(command_queue: cl_command_queue; blocking: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueMemcpyINTEL_2(command_queue, blocking, dst_ptr, src_ptr, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMemcpyINTEL(command_queue: cl_command_queue; blocking: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueMemcpyINTEL_3(command_queue, blocking, dst_ptr, src_ptr, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMemcpyINTEL(command_queue: cl_command_queue; blocking: clBool; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueMemcpyINTEL_4(command_queue, blocking, dst_ptr, src_ptr, size, num_events_in_wait_list, event_wait_list, &event);
    
    public EnqueueMemAdviseINTEL_adr := GetProcAddress('clEnqueueMemAdviseINTEL');
    private ntv_EnqueueMemAdviseINTEL_1 := GetProcOrNil&<function(command_queue: cl_command_queue; ptr: IntPtr; size: UIntPtr; advice: UInt32; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueMemAdviseINTEL_adr);
    private ntv_EnqueueMemAdviseINTEL_2 := GetProcOrNil&<function(command_queue: cl_command_queue; ptr: IntPtr; size: UIntPtr; advice: UInt32; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueMemAdviseINTEL_adr);
    private ntv_EnqueueMemAdviseINTEL_3 := GetProcOrNil&<function(command_queue: cl_command_queue; ptr: IntPtr; size: UIntPtr; advice: UInt32; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueMemAdviseINTEL_adr);
    private ntv_EnqueueMemAdviseINTEL_4 := GetProcOrNil&<function(command_queue: cl_command_queue; ptr: IntPtr; size: UIntPtr; advice: UInt32; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueMemAdviseINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMemAdviseINTEL(command_queue: cl_command_queue; ptr: IntPtr; size: UIntPtr; advice: UInt32; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueMemAdviseINTEL_1(command_queue, ptr, size, advice, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueMemAdviseINTEL_1(command_queue, ptr, size, advice, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMemAdviseINTEL(command_queue: cl_command_queue; ptr: IntPtr; size: UIntPtr; advice: UInt32; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueMemAdviseINTEL_2(command_queue, ptr, size, advice, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueMemAdviseINTEL_2(command_queue, ptr, size, advice, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMemAdviseINTEL(command_queue: cl_command_queue; ptr: IntPtr; size: UIntPtr; advice: UInt32; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueMemAdviseINTEL_1(command_queue, ptr, size, advice, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMemAdviseINTEL(command_queue: cl_command_queue; ptr: IntPtr; size: UIntPtr; advice: UInt32; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueMemAdviseINTEL_2(command_queue, ptr, size, advice, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMemAdviseINTEL(command_queue: cl_command_queue; ptr: IntPtr; size: UIntPtr; advice: UInt32; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueMemAdviseINTEL_3(command_queue, ptr, size, advice, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMemAdviseINTEL(command_queue: cl_command_queue; ptr: IntPtr; size: UIntPtr; advice: UInt32; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueMemAdviseINTEL_4(command_queue, ptr, size, advice, num_events_in_wait_list, event_wait_list, &event);
    
    public EnqueueMigrateMemINTEL_adr := GetProcAddress('clEnqueueMigrateMemINTEL');
    private ntv_EnqueueMigrateMemINTEL_1 := GetProcOrNil&<function(command_queue: cl_command_queue; ptr: IntPtr; size: UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueMigrateMemINTEL_adr);
    private ntv_EnqueueMigrateMemINTEL_2 := GetProcOrNil&<function(command_queue: cl_command_queue; ptr: IntPtr; size: UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueMigrateMemINTEL_adr);
    private ntv_EnqueueMigrateMemINTEL_3 := GetProcOrNil&<function(command_queue: cl_command_queue; ptr: IntPtr; size: UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueMigrateMemINTEL_adr);
    private ntv_EnqueueMigrateMemINTEL_4 := GetProcOrNil&<function(command_queue: cl_command_queue; ptr: IntPtr; size: UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueMigrateMemINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMigrateMemINTEL(command_queue: cl_command_queue; ptr: IntPtr; size: UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueMigrateMemINTEL_1(command_queue, ptr, size, flags, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueMigrateMemINTEL_1(command_queue, ptr, size, flags, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMigrateMemINTEL(command_queue: cl_command_queue; ptr: IntPtr; size: UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueMigrateMemINTEL_2(command_queue, ptr, size, flags, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueMigrateMemINTEL_2(command_queue, ptr, size, flags, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMigrateMemINTEL(command_queue: cl_command_queue; ptr: IntPtr; size: UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueMigrateMemINTEL_1(command_queue, ptr, size, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMigrateMemINTEL(command_queue: cl_command_queue; ptr: IntPtr; size: UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueMigrateMemINTEL_2(command_queue, ptr, size, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMigrateMemINTEL(command_queue: cl_command_queue; ptr: IntPtr; size: UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueMigrateMemINTEL_3(command_queue, ptr, size, flags, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMigrateMemINTEL(command_queue: cl_command_queue; ptr: IntPtr; size: UIntPtr; flags: clMemMigrationFlags; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueMigrateMemINTEL_4(command_queue, ptr, size, flags, num_events_in_wait_list, event_wait_list, &event);
    
    public EnqueueMemsetINTEL_adr := GetProcAddress('clEnqueueMemsetINTEL');
    private ntv_EnqueueMemsetINTEL_1 := GetProcOrNil&<function(command_queue: cl_command_queue; dst_ptr: IntPtr; value: Int32; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueMemsetINTEL_adr);
    private ntv_EnqueueMemsetINTEL_2 := GetProcOrNil&<function(command_queue: cl_command_queue; dst_ptr: IntPtr; value: Int32; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueMemsetINTEL_adr);
    private ntv_EnqueueMemsetINTEL_3 := GetProcOrNil&<function(command_queue: cl_command_queue; dst_ptr: IntPtr; value: Int32; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueMemsetINTEL_adr);
    private ntv_EnqueueMemsetINTEL_4 := GetProcOrNil&<function(command_queue: cl_command_queue; dst_ptr: IntPtr; value: Int32; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueMemsetINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMemsetINTEL(command_queue: cl_command_queue; dst_ptr: IntPtr; value: Int32; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueMemsetINTEL_1(command_queue, dst_ptr, value, size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueMemsetINTEL_1(command_queue, dst_ptr, value, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMemsetINTEL(command_queue: cl_command_queue; dst_ptr: IntPtr; value: Int32; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueMemsetINTEL_2(command_queue, dst_ptr, value, size, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueMemsetINTEL_2(command_queue, dst_ptr, value, size, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMemsetINTEL(command_queue: cl_command_queue; dst_ptr: IntPtr; value: Int32; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueMemsetINTEL_1(command_queue, dst_ptr, value, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMemsetINTEL(command_queue: cl_command_queue; dst_ptr: IntPtr; value: Int32; size: UIntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueMemsetINTEL_2(command_queue, dst_ptr, value, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMemsetINTEL(command_queue: cl_command_queue; dst_ptr: IntPtr; value: Int32; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueMemsetINTEL_3(command_queue, dst_ptr, value, size, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueMemsetINTEL(command_queue: cl_command_queue; dst_ptr: IntPtr; value: Int32; size: UIntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueMemsetINTEL_4(command_queue, dst_ptr, value, size, num_events_in_wait_list, event_wait_list, &event);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clVaApiMediaSharingINTEL = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clVaApiMediaSharingINTEL(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_intel_va_api_media_sharing';
    
    public GetDeviceIDsFromVA_APIMediaAdapterINTEL_adr := GetProcAddress('clGetDeviceIDsFromVA_APIMediaAdapterINTEL');
    private ntv_GetDeviceIDsFromVA_APIMediaAdapterINTEL_1 := GetProcOrNil&<function(platform: cl_platform_id; media_adapter_type: clVaApiDeviceSource; media_adapter: IntPtr; media_adapter_set: clVaApiDeviceSet; num_entries: UInt32; var devices: cl_device_id; var num_devices: UInt32): clErrorCode>(GetDeviceIDsFromVA_APIMediaAdapterINTEL_adr);
    private ntv_GetDeviceIDsFromVA_APIMediaAdapterINTEL_2 := GetProcOrNil&<function(platform: cl_platform_id; media_adapter_type: clVaApiDeviceSource; media_adapter: IntPtr; media_adapter_set: clVaApiDeviceSet; num_entries: UInt32; var devices: cl_device_id; num_devices: IntPtr): clErrorCode>(GetDeviceIDsFromVA_APIMediaAdapterINTEL_adr);
    private ntv_GetDeviceIDsFromVA_APIMediaAdapterINTEL_3 := GetProcOrNil&<function(platform: cl_platform_id; media_adapter_type: clVaApiDeviceSource; media_adapter: IntPtr; media_adapter_set: clVaApiDeviceSet; num_entries: UInt32; devices: IntPtr; var num_devices: UInt32): clErrorCode>(GetDeviceIDsFromVA_APIMediaAdapterINTEL_adr);
    private ntv_GetDeviceIDsFromVA_APIMediaAdapterINTEL_4 := GetProcOrNil&<function(platform: cl_platform_id; media_adapter_type: clVaApiDeviceSource; media_adapter: IntPtr; media_adapter_set: clVaApiDeviceSet; num_entries: UInt32; devices: IntPtr; num_devices: IntPtr): clErrorCode>(GetDeviceIDsFromVA_APIMediaAdapterINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDeviceIDsFromVA_APIMediaAdapterINTEL(platform: cl_platform_id; media_adapter_type: clVaApiDeviceSource; media_adapter: IntPtr; media_adapter_set: clVaApiDeviceSet; num_entries: UInt32; var devices: cl_device_id; var num_devices: UInt32): clErrorCode :=
      ntv_GetDeviceIDsFromVA_APIMediaAdapterINTEL_1(platform, media_adapter_type, media_adapter, media_adapter_set, num_entries, devices, num_devices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDeviceIDsFromVA_APIMediaAdapterINTEL(platform: cl_platform_id; media_adapter_type: clVaApiDeviceSource; media_adapter: IntPtr; media_adapter_set: clVaApiDeviceSet; num_entries: UInt32; var devices: cl_device_id; num_devices: IntPtr): clErrorCode :=
      ntv_GetDeviceIDsFromVA_APIMediaAdapterINTEL_2(platform, media_adapter_type, media_adapter, media_adapter_set, num_entries, devices, num_devices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDeviceIDsFromVA_APIMediaAdapterINTEL(platform: cl_platform_id; media_adapter_type: clVaApiDeviceSource; media_adapter: IntPtr; media_adapter_set: clVaApiDeviceSet; num_entries: UInt32; devices: IntPtr; var num_devices: UInt32): clErrorCode :=
      ntv_GetDeviceIDsFromVA_APIMediaAdapterINTEL_3(platform, media_adapter_type, media_adapter, media_adapter_set, num_entries, devices, num_devices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDeviceIDsFromVA_APIMediaAdapterINTEL(platform: cl_platform_id; media_adapter_type: clVaApiDeviceSource; media_adapter: IntPtr; media_adapter_set: clVaApiDeviceSet; num_entries: UInt32; devices: IntPtr; num_devices: IntPtr): clErrorCode :=
      ntv_GetDeviceIDsFromVA_APIMediaAdapterINTEL_4(platform, media_adapter_type, media_adapter, media_adapter_set, num_entries, devices, num_devices);
    
    public CreateFromVA_APIMediaSurfaceINTEL_adr := GetProcAddress('clCreateFromVA_APIMediaSurfaceINTEL');
    private ntv_CreateFromVA_APIMediaSurfaceINTEL_1 := GetProcOrNil&<function(context: cl_context; flags: clMemFlags; surface: va_surface_id; plane: UInt32; var errcode_ret: clErrorCode): cl_mem>(CreateFromVA_APIMediaSurfaceINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateFromVA_APIMediaSurfaceINTEL(context: cl_context; flags: clMemFlags; surface: va_surface_id; plane: UInt32; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateFromVA_APIMediaSurfaceINTEL_1(context, flags, surface, plane, errcode_ret);
    
    public EnqueueAcquireVA_APIMediaSurfacesINTEL_adr := GetProcAddress('clEnqueueAcquireVA_APIMediaSurfacesINTEL');
    private ntv_EnqueueAcquireVA_APIMediaSurfacesINTEL_1 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueAcquireVA_APIMediaSurfacesINTEL_adr);
    private ntv_EnqueueAcquireVA_APIMediaSurfacesINTEL_2 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueAcquireVA_APIMediaSurfacesINTEL_adr);
    private ntv_EnqueueAcquireVA_APIMediaSurfacesINTEL_3 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueAcquireVA_APIMediaSurfacesINTEL_adr);
    private ntv_EnqueueAcquireVA_APIMediaSurfacesINTEL_4 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueAcquireVA_APIMediaSurfacesINTEL_adr);
    private ntv_EnqueueAcquireVA_APIMediaSurfacesINTEL_5 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueAcquireVA_APIMediaSurfacesINTEL_adr);
    private ntv_EnqueueAcquireVA_APIMediaSurfacesINTEL_6 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueAcquireVA_APIMediaSurfacesINTEL_adr);
    private ntv_EnqueueAcquireVA_APIMediaSurfacesINTEL_7 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueAcquireVA_APIMediaSurfacesINTEL_adr);
    private ntv_EnqueueAcquireVA_APIMediaSurfacesINTEL_8 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueAcquireVA_APIMediaSurfacesINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireVA_APIMediaSurfacesINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueAcquireVA_APIMediaSurfacesINTEL(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueAcquireVA_APIMediaSurfacesINTEL(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireVA_APIMediaSurfacesINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueAcquireVA_APIMediaSurfacesINTEL(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueAcquireVA_APIMediaSurfacesINTEL(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireVA_APIMediaSurfacesINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueAcquireVA_APIMediaSurfacesINTEL_1(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueAcquireVA_APIMediaSurfacesINTEL_1(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireVA_APIMediaSurfacesINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueAcquireVA_APIMediaSurfacesINTEL_2(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueAcquireVA_APIMediaSurfacesINTEL_2(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireVA_APIMediaSurfacesINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueAcquireVA_APIMediaSurfacesINTEL_3(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueAcquireVA_APIMediaSurfacesINTEL_3(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireVA_APIMediaSurfacesINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueAcquireVA_APIMediaSurfacesINTEL_4(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueAcquireVA_APIMediaSurfacesINTEL_4(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireVA_APIMediaSurfacesINTEL(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueAcquireVA_APIMediaSurfacesINTEL_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueAcquireVA_APIMediaSurfacesINTEL_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireVA_APIMediaSurfacesINTEL(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueAcquireVA_APIMediaSurfacesINTEL_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueAcquireVA_APIMediaSurfacesINTEL_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireVA_APIMediaSurfacesINTEL(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueAcquireVA_APIMediaSurfacesINTEL_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireVA_APIMediaSurfacesINTEL(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueAcquireVA_APIMediaSurfacesINTEL_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireVA_APIMediaSurfacesINTEL(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueAcquireVA_APIMediaSurfacesINTEL_3(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireVA_APIMediaSurfacesINTEL(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueAcquireVA_APIMediaSurfacesINTEL_4(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireVA_APIMediaSurfacesINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueAcquireVA_APIMediaSurfacesINTEL_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueAcquireVA_APIMediaSurfacesINTEL_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireVA_APIMediaSurfacesINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueAcquireVA_APIMediaSurfacesINTEL_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueAcquireVA_APIMediaSurfacesINTEL_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireVA_APIMediaSurfacesINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueAcquireVA_APIMediaSurfacesINTEL_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireVA_APIMediaSurfacesINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueAcquireVA_APIMediaSurfacesINTEL_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireVA_APIMediaSurfacesINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueAcquireVA_APIMediaSurfacesINTEL_7(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireVA_APIMediaSurfacesINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueAcquireVA_APIMediaSurfacesINTEL_8(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    
    public EnqueueReleaseVA_APIMediaSurfacesINTEL_adr := GetProcAddress('clEnqueueReleaseVA_APIMediaSurfacesINTEL');
    private ntv_EnqueueReleaseVA_APIMediaSurfacesINTEL_1 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueReleaseVA_APIMediaSurfacesINTEL_adr);
    private ntv_EnqueueReleaseVA_APIMediaSurfacesINTEL_2 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueReleaseVA_APIMediaSurfacesINTEL_adr);
    private ntv_EnqueueReleaseVA_APIMediaSurfacesINTEL_3 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueReleaseVA_APIMediaSurfacesINTEL_adr);
    private ntv_EnqueueReleaseVA_APIMediaSurfacesINTEL_4 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueReleaseVA_APIMediaSurfacesINTEL_adr);
    private ntv_EnqueueReleaseVA_APIMediaSurfacesINTEL_5 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueReleaseVA_APIMediaSurfacesINTEL_adr);
    private ntv_EnqueueReleaseVA_APIMediaSurfacesINTEL_6 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueReleaseVA_APIMediaSurfacesINTEL_adr);
    private ntv_EnqueueReleaseVA_APIMediaSurfacesINTEL_7 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueReleaseVA_APIMediaSurfacesINTEL_adr);
    private ntv_EnqueueReleaseVA_APIMediaSurfacesINTEL_8 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueReleaseVA_APIMediaSurfacesINTEL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseVA_APIMediaSurfacesINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueReleaseVA_APIMediaSurfacesINTEL(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueReleaseVA_APIMediaSurfacesINTEL(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseVA_APIMediaSurfacesINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueReleaseVA_APIMediaSurfacesINTEL(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueReleaseVA_APIMediaSurfacesINTEL(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseVA_APIMediaSurfacesINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueReleaseVA_APIMediaSurfacesINTEL_1(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueReleaseVA_APIMediaSurfacesINTEL_1(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseVA_APIMediaSurfacesINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueReleaseVA_APIMediaSurfacesINTEL_2(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueReleaseVA_APIMediaSurfacesINTEL_2(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseVA_APIMediaSurfacesINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueReleaseVA_APIMediaSurfacesINTEL_3(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueReleaseVA_APIMediaSurfacesINTEL_3(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseVA_APIMediaSurfacesINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueReleaseVA_APIMediaSurfacesINTEL_4(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueReleaseVA_APIMediaSurfacesINTEL_4(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseVA_APIMediaSurfacesINTEL(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReleaseVA_APIMediaSurfacesINTEL_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReleaseVA_APIMediaSurfacesINTEL_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseVA_APIMediaSurfacesINTEL(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReleaseVA_APIMediaSurfacesINTEL_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReleaseVA_APIMediaSurfacesINTEL_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseVA_APIMediaSurfacesINTEL(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReleaseVA_APIMediaSurfacesINTEL_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseVA_APIMediaSurfacesINTEL(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReleaseVA_APIMediaSurfacesINTEL_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseVA_APIMediaSurfacesINTEL(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReleaseVA_APIMediaSurfacesINTEL_3(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseVA_APIMediaSurfacesINTEL(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReleaseVA_APIMediaSurfacesINTEL_4(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseVA_APIMediaSurfacesINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReleaseVA_APIMediaSurfacesINTEL_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReleaseVA_APIMediaSurfacesINTEL_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseVA_APIMediaSurfacesINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReleaseVA_APIMediaSurfacesINTEL_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReleaseVA_APIMediaSurfacesINTEL_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseVA_APIMediaSurfacesINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReleaseVA_APIMediaSurfacesINTEL_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseVA_APIMediaSurfacesINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReleaseVA_APIMediaSurfacesINTEL_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseVA_APIMediaSurfacesINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReleaseVA_APIMediaSurfacesINTEL_7(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseVA_APIMediaSurfacesINTEL(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReleaseVA_APIMediaSurfacesINTEL_8(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clCommandBufferKHR = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clCommandBufferKHR(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_khr_command_buffer';
    
    public CreateCommandBufferKHR_adr := GetProcAddress('clCreateCommandBufferKHR');
    private ntv_CreateCommandBufferKHR_1 := GetProcOrNil&<function(num_queues: UInt32; var queues: cl_command_queue; var properties: clCommandBufferProperties; var errcode_ret: clErrorCode): cl_command_buffer>(CreateCommandBufferKHR_adr);
    private ntv_CreateCommandBufferKHR_2 := GetProcOrNil&<function(num_queues: UInt32; var queues: cl_command_queue; properties: IntPtr; var errcode_ret: clErrorCode): cl_command_buffer>(CreateCommandBufferKHR_adr);
    private ntv_CreateCommandBufferKHR_3 := GetProcOrNil&<function(num_queues: UInt32; queues: IntPtr; var properties: clCommandBufferProperties; var errcode_ret: clErrorCode): cl_command_buffer>(CreateCommandBufferKHR_adr);
    private ntv_CreateCommandBufferKHR_4 := GetProcOrNil&<function(num_queues: UInt32; queues: IntPtr; properties: IntPtr; var errcode_ret: clErrorCode): cl_command_buffer>(CreateCommandBufferKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateCommandBufferKHR(num_queues: UInt32; queues: array of cl_command_queue; properties: array of clCommandBufferProperties; var errcode_ret: clErrorCode): cl_command_buffer;
    type PCl_command_queue = ^cl_command_queue;
    type PClCommandBufferProperties = ^clCommandBufferProperties;
    begin
      Result := if (queues<>nil) and (queues.Length<>0) then
        if (properties<>nil) and (properties.Length<>0) then
          ntv_CreateCommandBufferKHR_1(num_queues, queues[0], properties[0], errcode_ret) else
          ntv_CreateCommandBufferKHR_1(num_queues, queues[0], PClCommandBufferProperties(nil)^, errcode_ret) else
        if (properties<>nil) and (properties.Length<>0) then
          ntv_CreateCommandBufferKHR_1(num_queues, PCl_command_queue(nil)^, properties[0], errcode_ret) else
          ntv_CreateCommandBufferKHR_1(num_queues, PCl_command_queue(nil)^, PClCommandBufferProperties(nil)^, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateCommandBufferKHR(num_queues: UInt32; var queues: cl_command_queue; var properties: clCommandBufferProperties; var errcode_ret: clErrorCode): cl_command_buffer :=
      ntv_CreateCommandBufferKHR_1(num_queues, queues, properties, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateCommandBufferKHR(num_queues: UInt32; var queues: cl_command_queue; properties: IntPtr; var errcode_ret: clErrorCode): cl_command_buffer :=
      ntv_CreateCommandBufferKHR_2(num_queues, queues, properties, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateCommandBufferKHR(num_queues: UInt32; queues: IntPtr; var properties: clCommandBufferProperties; var errcode_ret: clErrorCode): cl_command_buffer :=
      ntv_CreateCommandBufferKHR_3(num_queues, queues, properties, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateCommandBufferKHR(num_queues: UInt32; queues: IntPtr; properties: IntPtr; var errcode_ret: clErrorCode): cl_command_buffer :=
      ntv_CreateCommandBufferKHR_4(num_queues, queues, properties, errcode_ret);
    
    public FinalizeCommandBufferKHR_adr := GetProcAddress('clFinalizeCommandBufferKHR');
    private ntv_FinalizeCommandBufferKHR_1 := GetProcOrNil&<function(command_buffer: cl_command_buffer): clErrorCode>(FinalizeCommandBufferKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function FinalizeCommandBufferKHR(command_buffer: cl_command_buffer): clErrorCode :=
      ntv_FinalizeCommandBufferKHR_1(command_buffer);
    
    public RetainCommandBufferKHR_adr := GetProcAddress('clRetainCommandBufferKHR');
    private ntv_RetainCommandBufferKHR_1 := GetProcOrNil&<function(command_buffer: cl_command_buffer): clErrorCode>(RetainCommandBufferKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function RetainCommandBufferKHR(command_buffer: cl_command_buffer): clErrorCode :=
      ntv_RetainCommandBufferKHR_1(command_buffer);
    
    public ReleaseCommandBufferKHR_adr := GetProcAddress('clReleaseCommandBufferKHR');
    private ntv_ReleaseCommandBufferKHR_1 := GetProcOrNil&<function(command_buffer: cl_command_buffer): clErrorCode>(ReleaseCommandBufferKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseCommandBufferKHR(command_buffer: cl_command_buffer): clErrorCode :=
      ntv_ReleaseCommandBufferKHR_1(command_buffer);
    
    public EnqueueCommandBufferKHR_adr := GetProcAddress('clEnqueueCommandBufferKHR');
    private ntv_EnqueueCommandBufferKHR_1 := GetProcOrNil&<function(num_queues: UInt32; var queues: cl_command_queue; command_buffer: cl_command_buffer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueCommandBufferKHR_adr);
    private ntv_EnqueueCommandBufferKHR_2 := GetProcOrNil&<function(num_queues: UInt32; var queues: cl_command_queue; command_buffer: cl_command_buffer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueCommandBufferKHR_adr);
    private ntv_EnqueueCommandBufferKHR_3 := GetProcOrNil&<function(num_queues: UInt32; var queues: cl_command_queue; command_buffer: cl_command_buffer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueCommandBufferKHR_adr);
    private ntv_EnqueueCommandBufferKHR_4 := GetProcOrNil&<function(num_queues: UInt32; var queues: cl_command_queue; command_buffer: cl_command_buffer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueCommandBufferKHR_adr);
    private ntv_EnqueueCommandBufferKHR_5 := GetProcOrNil&<function(num_queues: UInt32; queues: IntPtr; command_buffer: cl_command_buffer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueCommandBufferKHR_adr);
    private ntv_EnqueueCommandBufferKHR_6 := GetProcOrNil&<function(num_queues: UInt32; queues: IntPtr; command_buffer: cl_command_buffer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueCommandBufferKHR_adr);
    private ntv_EnqueueCommandBufferKHR_7 := GetProcOrNil&<function(num_queues: UInt32; queues: IntPtr; command_buffer: cl_command_buffer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueCommandBufferKHR_adr);
    private ntv_EnqueueCommandBufferKHR_8 := GetProcOrNil&<function(num_queues: UInt32; queues: IntPtr; command_buffer: cl_command_buffer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueCommandBufferKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueCommandBufferKHR(num_queues: UInt32; queues: array of cl_command_queue; command_buffer: cl_command_buffer; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueCommandBufferKHR(num_queues, queues, command_buffer, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueCommandBufferKHR(num_queues, queues, command_buffer, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueCommandBufferKHR(num_queues: UInt32; queues: array of cl_command_queue; command_buffer: cl_command_buffer; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueCommandBufferKHR(num_queues, queues, command_buffer, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueCommandBufferKHR(num_queues, queues, command_buffer, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueCommandBufferKHR(num_queues: UInt32; queues: array of cl_command_queue; command_buffer: cl_command_buffer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    type PCl_command_queue = ^cl_command_queue;
    begin
      Result := if (queues<>nil) and (queues.Length<>0) then
        ntv_EnqueueCommandBufferKHR_1(num_queues, queues[0], command_buffer, num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueCommandBufferKHR_1(num_queues, PCl_command_queue(nil)^, command_buffer, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueCommandBufferKHR(num_queues: UInt32; queues: array of cl_command_queue; command_buffer: cl_command_buffer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    type PCl_command_queue = ^cl_command_queue;
    begin
      Result := if (queues<>nil) and (queues.Length<>0) then
        ntv_EnqueueCommandBufferKHR_2(num_queues, queues[0], command_buffer, num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueCommandBufferKHR_2(num_queues, PCl_command_queue(nil)^, command_buffer, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueCommandBufferKHR(num_queues: UInt32; queues: array of cl_command_queue; command_buffer: cl_command_buffer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    type PCl_command_queue = ^cl_command_queue;
    begin
      Result := if (queues<>nil) and (queues.Length<>0) then
        ntv_EnqueueCommandBufferKHR_3(num_queues, queues[0], command_buffer, num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueCommandBufferKHR_3(num_queues, PCl_command_queue(nil)^, command_buffer, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueCommandBufferKHR(num_queues: UInt32; queues: array of cl_command_queue; command_buffer: cl_command_buffer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    type PCl_command_queue = ^cl_command_queue;
    begin
      Result := if (queues<>nil) and (queues.Length<>0) then
        ntv_EnqueueCommandBufferKHR_4(num_queues, queues[0], command_buffer, num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueCommandBufferKHR_4(num_queues, PCl_command_queue(nil)^, command_buffer, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueCommandBufferKHR(num_queues: UInt32; var queues: cl_command_queue; command_buffer: cl_command_buffer; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueCommandBufferKHR_1(num_queues, queues, command_buffer, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueCommandBufferKHR_1(num_queues, queues, command_buffer, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueCommandBufferKHR(num_queues: UInt32; var queues: cl_command_queue; command_buffer: cl_command_buffer; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueCommandBufferKHR_2(num_queues, queues, command_buffer, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueCommandBufferKHR_2(num_queues, queues, command_buffer, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueCommandBufferKHR(num_queues: UInt32; var queues: cl_command_queue; command_buffer: cl_command_buffer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueCommandBufferKHR_1(num_queues, queues, command_buffer, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueCommandBufferKHR(num_queues: UInt32; var queues: cl_command_queue; command_buffer: cl_command_buffer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueCommandBufferKHR_2(num_queues, queues, command_buffer, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueCommandBufferKHR(num_queues: UInt32; var queues: cl_command_queue; command_buffer: cl_command_buffer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueCommandBufferKHR_3(num_queues, queues, command_buffer, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueCommandBufferKHR(num_queues: UInt32; var queues: cl_command_queue; command_buffer: cl_command_buffer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueCommandBufferKHR_4(num_queues, queues, command_buffer, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueCommandBufferKHR(num_queues: UInt32; queues: IntPtr; command_buffer: cl_command_buffer; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueCommandBufferKHR_5(num_queues, queues, command_buffer, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueCommandBufferKHR_5(num_queues, queues, command_buffer, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueCommandBufferKHR(num_queues: UInt32; queues: IntPtr; command_buffer: cl_command_buffer; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueCommandBufferKHR_6(num_queues, queues, command_buffer, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueCommandBufferKHR_6(num_queues, queues, command_buffer, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueCommandBufferKHR(num_queues: UInt32; queues: IntPtr; command_buffer: cl_command_buffer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueCommandBufferKHR_5(num_queues, queues, command_buffer, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueCommandBufferKHR(num_queues: UInt32; queues: IntPtr; command_buffer: cl_command_buffer; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueCommandBufferKHR_6(num_queues, queues, command_buffer, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueCommandBufferKHR(num_queues: UInt32; queues: IntPtr; command_buffer: cl_command_buffer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueCommandBufferKHR_7(num_queues, queues, command_buffer, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueCommandBufferKHR(num_queues: UInt32; queues: IntPtr; command_buffer: cl_command_buffer; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueCommandBufferKHR_8(num_queues, queues, command_buffer, num_events_in_wait_list, event_wait_list, &event);
    
    public CommandBarrierWithWaitListKHR_adr := GetProcAddress('clCommandBarrierWithWaitListKHR');
    private ntv_CommandBarrierWithWaitListKHR_1 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode>(CommandBarrierWithWaitListKHR_adr);
    private ntv_CommandBarrierWithWaitListKHR_2 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode>(CommandBarrierWithWaitListKHR_adr);
    private ntv_CommandBarrierWithWaitListKHR_3 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; sync_point: IntPtr; var mutable_handle: cl_mutable_command): clErrorCode>(CommandBarrierWithWaitListKHR_adr);
    private ntv_CommandBarrierWithWaitListKHR_4 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; sync_point: IntPtr; mutable_handle: IntPtr): clErrorCode>(CommandBarrierWithWaitListKHR_adr);
    private ntv_CommandBarrierWithWaitListKHR_5 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode>(CommandBarrierWithWaitListKHR_adr);
    private ntv_CommandBarrierWithWaitListKHR_6 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode>(CommandBarrierWithWaitListKHR_adr);
    private ntv_CommandBarrierWithWaitListKHR_7 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; sync_point: IntPtr; var mutable_handle: cl_mutable_command): clErrorCode>(CommandBarrierWithWaitListKHR_adr);
    private ntv_CommandBarrierWithWaitListKHR_8 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; sync_point: IntPtr; mutable_handle: IntPtr): clErrorCode>(CommandBarrierWithWaitListKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandBarrierWithWaitListKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: array of UInt32; sync_point: array of UInt32; mutable_handle: array of cl_mutable_command): clErrorCode;
    type PUInt32 = ^UInt32;
    type PCl_mutable_command = ^cl_mutable_command;
    begin
      Result := if (mutable_handle<>nil) and (mutable_handle.Length<>0) then
        if (sync_point_wait_list<>nil) and (sync_point_wait_list.Length<>0) then
          if (sync_point<>nil) and (sync_point.Length<>0) then
            ntv_CommandBarrierWithWaitListKHR_1(command_buffer, command_queue, num_sync_points_in_wait_list, sync_point_wait_list[0], sync_point[0], mutable_handle[0]) else
            ntv_CommandBarrierWithWaitListKHR_1(command_buffer, command_queue, num_sync_points_in_wait_list, sync_point_wait_list[0], PUInt32(nil)^, mutable_handle[0]) else
          if (sync_point<>nil) and (sync_point.Length<>0) then
            ntv_CommandBarrierWithWaitListKHR_1(command_buffer, command_queue, num_sync_points_in_wait_list, PUInt32(nil)^, sync_point[0], mutable_handle[0]) else
            ntv_CommandBarrierWithWaitListKHR_1(command_buffer, command_queue, num_sync_points_in_wait_list, PUInt32(nil)^, PUInt32(nil)^, mutable_handle[0]) else
        if (sync_point_wait_list<>nil) and (sync_point_wait_list.Length<>0) then
          if (sync_point<>nil) and (sync_point.Length<>0) then
            ntv_CommandBarrierWithWaitListKHR_1(command_buffer, command_queue, num_sync_points_in_wait_list, sync_point_wait_list[0], sync_point[0], PCl_mutable_command(nil)^) else
            ntv_CommandBarrierWithWaitListKHR_1(command_buffer, command_queue, num_sync_points_in_wait_list, sync_point_wait_list[0], PUInt32(nil)^, PCl_mutable_command(nil)^) else
          if (sync_point<>nil) and (sync_point.Length<>0) then
            ntv_CommandBarrierWithWaitListKHR_1(command_buffer, command_queue, num_sync_points_in_wait_list, PUInt32(nil)^, sync_point[0], PCl_mutable_command(nil)^) else
            ntv_CommandBarrierWithWaitListKHR_1(command_buffer, command_queue, num_sync_points_in_wait_list, PUInt32(nil)^, PUInt32(nil)^, PCl_mutable_command(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandBarrierWithWaitListKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandBarrierWithWaitListKHR_1(command_buffer, command_queue, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandBarrierWithWaitListKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandBarrierWithWaitListKHR_2(command_buffer, command_queue, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandBarrierWithWaitListKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; sync_point: IntPtr; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandBarrierWithWaitListKHR_3(command_buffer, command_queue, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandBarrierWithWaitListKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; sync_point: IntPtr; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandBarrierWithWaitListKHR_4(command_buffer, command_queue, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandBarrierWithWaitListKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandBarrierWithWaitListKHR_5(command_buffer, command_queue, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandBarrierWithWaitListKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandBarrierWithWaitListKHR_6(command_buffer, command_queue, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandBarrierWithWaitListKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; sync_point: IntPtr; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandBarrierWithWaitListKHR_7(command_buffer, command_queue, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandBarrierWithWaitListKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; sync_point: IntPtr; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandBarrierWithWaitListKHR_8(command_buffer, command_queue, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    
    public CommandCopyBufferKHR_adr := GetProcAddress('clCommandCopyBufferKHR');
    private ntv_CommandCopyBufferKHR_1 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_offset: UIntPtr; dst_offset: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode>(CommandCopyBufferKHR_adr);
    private ntv_CommandCopyBufferKHR_2 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_offset: UIntPtr; dst_offset: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode>(CommandCopyBufferKHR_adr);
    private ntv_CommandCopyBufferKHR_3 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_offset: UIntPtr; dst_offset: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; sync_point: IntPtr; var mutable_handle: cl_mutable_command): clErrorCode>(CommandCopyBufferKHR_adr);
    private ntv_CommandCopyBufferKHR_4 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_offset: UIntPtr; dst_offset: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; sync_point: IntPtr; mutable_handle: IntPtr): clErrorCode>(CommandCopyBufferKHR_adr);
    private ntv_CommandCopyBufferKHR_5 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_offset: UIntPtr; dst_offset: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode>(CommandCopyBufferKHR_adr);
    private ntv_CommandCopyBufferKHR_6 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_offset: UIntPtr; dst_offset: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode>(CommandCopyBufferKHR_adr);
    private ntv_CommandCopyBufferKHR_7 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_offset: UIntPtr; dst_offset: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; sync_point: IntPtr; var mutable_handle: cl_mutable_command): clErrorCode>(CommandCopyBufferKHR_adr);
    private ntv_CommandCopyBufferKHR_8 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_offset: UIntPtr; dst_offset: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; sync_point: IntPtr; mutable_handle: IntPtr): clErrorCode>(CommandCopyBufferKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyBufferKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_offset: UIntPtr; dst_offset: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: array of UInt32; sync_point: array of UInt32; mutable_handle: array of cl_mutable_command): clErrorCode;
    type PUInt32 = ^UInt32;
    type PCl_mutable_command = ^cl_mutable_command;
    begin
      Result := if (mutable_handle<>nil) and (mutable_handle.Length<>0) then
        if (sync_point_wait_list<>nil) and (sync_point_wait_list.Length<>0) then
          if (sync_point<>nil) and (sync_point.Length<>0) then
            ntv_CommandCopyBufferKHR_1(command_buffer, command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_sync_points_in_wait_list, sync_point_wait_list[0], sync_point[0], mutable_handle[0]) else
            ntv_CommandCopyBufferKHR_1(command_buffer, command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_sync_points_in_wait_list, sync_point_wait_list[0], PUInt32(nil)^, mutable_handle[0]) else
          if (sync_point<>nil) and (sync_point.Length<>0) then
            ntv_CommandCopyBufferKHR_1(command_buffer, command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_sync_points_in_wait_list, PUInt32(nil)^, sync_point[0], mutable_handle[0]) else
            ntv_CommandCopyBufferKHR_1(command_buffer, command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_sync_points_in_wait_list, PUInt32(nil)^, PUInt32(nil)^, mutable_handle[0]) else
        if (sync_point_wait_list<>nil) and (sync_point_wait_list.Length<>0) then
          if (sync_point<>nil) and (sync_point.Length<>0) then
            ntv_CommandCopyBufferKHR_1(command_buffer, command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_sync_points_in_wait_list, sync_point_wait_list[0], sync_point[0], PCl_mutable_command(nil)^) else
            ntv_CommandCopyBufferKHR_1(command_buffer, command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_sync_points_in_wait_list, sync_point_wait_list[0], PUInt32(nil)^, PCl_mutable_command(nil)^) else
          if (sync_point<>nil) and (sync_point.Length<>0) then
            ntv_CommandCopyBufferKHR_1(command_buffer, command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_sync_points_in_wait_list, PUInt32(nil)^, sync_point[0], PCl_mutable_command(nil)^) else
            ntv_CommandCopyBufferKHR_1(command_buffer, command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_sync_points_in_wait_list, PUInt32(nil)^, PUInt32(nil)^, PCl_mutable_command(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyBufferKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_offset: UIntPtr; dst_offset: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandCopyBufferKHR_1(command_buffer, command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyBufferKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_offset: UIntPtr; dst_offset: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandCopyBufferKHR_2(command_buffer, command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyBufferKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_offset: UIntPtr; dst_offset: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; sync_point: IntPtr; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandCopyBufferKHR_3(command_buffer, command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyBufferKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_offset: UIntPtr; dst_offset: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; sync_point: IntPtr; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandCopyBufferKHR_4(command_buffer, command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyBufferKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_offset: UIntPtr; dst_offset: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandCopyBufferKHR_5(command_buffer, command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyBufferKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_offset: UIntPtr; dst_offset: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandCopyBufferKHR_6(command_buffer, command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyBufferKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_offset: UIntPtr; dst_offset: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; sync_point: IntPtr; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandCopyBufferKHR_7(command_buffer, command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyBufferKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_offset: UIntPtr; dst_offset: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; sync_point: IntPtr; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandCopyBufferKHR_8(command_buffer, command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    
    public CommandCopyBufferRectKHR_adr := GetProcAddress('clCommandCopyBufferRectKHR');
    private ntv_CommandCopyBufferRectKHR_1 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode>(CommandCopyBufferRectKHR_adr);
    private ntv_CommandCopyBufferRectKHR_2 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode>(CommandCopyBufferRectKHR_adr);
    private ntv_CommandCopyBufferRectKHR_3 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode>(CommandCopyBufferRectKHR_adr);
    private ntv_CommandCopyBufferRectKHR_4 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode>(CommandCopyBufferRectKHR_adr);
    private ntv_CommandCopyBufferRectKHR_5 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_origin: IntPtr; dst_origin: IntPtr; region: IntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode>(CommandCopyBufferRectKHR_adr);
    private ntv_CommandCopyBufferRectKHR_6 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_origin: IntPtr; dst_origin: IntPtr; region: IntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode>(CommandCopyBufferRectKHR_adr);
    private ntv_CommandCopyBufferRectKHR_7 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_origin: IntPtr; dst_origin: IntPtr; region: IntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode>(CommandCopyBufferRectKHR_adr);
    private ntv_CommandCopyBufferRectKHR_8 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_origin: IntPtr; dst_origin: IntPtr; region: IntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode>(CommandCopyBufferRectKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyBufferRectKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandCopyBufferRectKHR_1(command_buffer, command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyBufferRectKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandCopyBufferRectKHR_2(command_buffer, command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyBufferRectKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandCopyBufferRectKHR_3(command_buffer, command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyBufferRectKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandCopyBufferRectKHR_4(command_buffer, command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyBufferRectKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_origin: IntPtr; dst_origin: IntPtr; region: IntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandCopyBufferRectKHR_5(command_buffer, command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyBufferRectKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_origin: IntPtr; dst_origin: IntPtr; region: IntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandCopyBufferRectKHR_6(command_buffer, command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyBufferRectKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_origin: IntPtr; dst_origin: IntPtr; region: IntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandCopyBufferRectKHR_7(command_buffer, command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyBufferRectKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_buffer: cl_mem; src_origin: IntPtr; dst_origin: IntPtr; region: IntPtr; src_row_pitch: UIntPtr; src_slice_pitch: UIntPtr; dst_row_pitch: UIntPtr; dst_slice_pitch: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandCopyBufferRectKHR_8(command_buffer, command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    
    public CommandCopyBufferToImageKHR_adr := GetProcAddress('clCommandCopyBufferToImageKHR');
    private ntv_CommandCopyBufferToImageKHR_1 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode>(CommandCopyBufferToImageKHR_adr);
    private ntv_CommandCopyBufferToImageKHR_2 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode>(CommandCopyBufferToImageKHR_adr);
    private ntv_CommandCopyBufferToImageKHR_3 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode>(CommandCopyBufferToImageKHR_adr);
    private ntv_CommandCopyBufferToImageKHR_4 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode>(CommandCopyBufferToImageKHR_adr);
    private ntv_CommandCopyBufferToImageKHR_5 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; dst_origin: IntPtr; region: IntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode>(CommandCopyBufferToImageKHR_adr);
    private ntv_CommandCopyBufferToImageKHR_6 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; dst_origin: IntPtr; region: IntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode>(CommandCopyBufferToImageKHR_adr);
    private ntv_CommandCopyBufferToImageKHR_7 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; dst_origin: IntPtr; region: IntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode>(CommandCopyBufferToImageKHR_adr);
    private ntv_CommandCopyBufferToImageKHR_8 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; dst_origin: IntPtr; region: IntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode>(CommandCopyBufferToImageKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyBufferToImageKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandCopyBufferToImageKHR_1(command_buffer, command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyBufferToImageKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandCopyBufferToImageKHR_2(command_buffer, command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyBufferToImageKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandCopyBufferToImageKHR_3(command_buffer, command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyBufferToImageKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandCopyBufferToImageKHR_4(command_buffer, command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyBufferToImageKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; dst_origin: IntPtr; region: IntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandCopyBufferToImageKHR_5(command_buffer, command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyBufferToImageKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; dst_origin: IntPtr; region: IntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandCopyBufferToImageKHR_6(command_buffer, command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyBufferToImageKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; dst_origin: IntPtr; region: IntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandCopyBufferToImageKHR_7(command_buffer, command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyBufferToImageKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_buffer: cl_mem; dst_image: cl_mem; src_offset: UIntPtr; dst_origin: IntPtr; region: IntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandCopyBufferToImageKHR_8(command_buffer, command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    
    public CommandCopyImageKHR_adr := GetProcAddress('clCommandCopyImageKHR');
    private ntv_CommandCopyImageKHR_1 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode>(CommandCopyImageKHR_adr);
    private ntv_CommandCopyImageKHR_2 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode>(CommandCopyImageKHR_adr);
    private ntv_CommandCopyImageKHR_3 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode>(CommandCopyImageKHR_adr);
    private ntv_CommandCopyImageKHR_4 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode>(CommandCopyImageKHR_adr);
    private ntv_CommandCopyImageKHR_5 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; src_origin: IntPtr; dst_origin: IntPtr; region: IntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode>(CommandCopyImageKHR_adr);
    private ntv_CommandCopyImageKHR_6 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; src_origin: IntPtr; dst_origin: IntPtr; region: IntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode>(CommandCopyImageKHR_adr);
    private ntv_CommandCopyImageKHR_7 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; src_origin: IntPtr; dst_origin: IntPtr; region: IntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode>(CommandCopyImageKHR_adr);
    private ntv_CommandCopyImageKHR_8 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; src_origin: IntPtr; dst_origin: IntPtr; region: IntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode>(CommandCopyImageKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyImageKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandCopyImageKHR_1(command_buffer, command_queue, src_image, dst_image, src_origin, dst_origin, region, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyImageKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandCopyImageKHR_2(command_buffer, command_queue, src_image, dst_image, src_origin, dst_origin, region, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyImageKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandCopyImageKHR_3(command_buffer, command_queue, src_image, dst_image, src_origin, dst_origin, region, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyImageKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; var src_origin: UIntPtr; var dst_origin: UIntPtr; var region: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandCopyImageKHR_4(command_buffer, command_queue, src_image, dst_image, src_origin, dst_origin, region, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyImageKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; src_origin: IntPtr; dst_origin: IntPtr; region: IntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandCopyImageKHR_5(command_buffer, command_queue, src_image, dst_image, src_origin, dst_origin, region, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyImageKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; src_origin: IntPtr; dst_origin: IntPtr; region: IntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandCopyImageKHR_6(command_buffer, command_queue, src_image, dst_image, src_origin, dst_origin, region, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyImageKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; src_origin: IntPtr; dst_origin: IntPtr; region: IntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandCopyImageKHR_7(command_buffer, command_queue, src_image, dst_image, src_origin, dst_origin, region, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyImageKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_image: cl_mem; dst_image: cl_mem; src_origin: IntPtr; dst_origin: IntPtr; region: IntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandCopyImageKHR_8(command_buffer, command_queue, src_image, dst_image, src_origin, dst_origin, region, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    
    public CommandCopyImageToBufferKHR_adr := GetProcAddress('clCommandCopyImageToBufferKHR');
    private ntv_CommandCopyImageToBufferKHR_1 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var region: UIntPtr; dst_offset: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode>(CommandCopyImageToBufferKHR_adr);
    private ntv_CommandCopyImageToBufferKHR_2 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var region: UIntPtr; dst_offset: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode>(CommandCopyImageToBufferKHR_adr);
    private ntv_CommandCopyImageToBufferKHR_3 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var region: UIntPtr; dst_offset: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode>(CommandCopyImageToBufferKHR_adr);
    private ntv_CommandCopyImageToBufferKHR_4 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var region: UIntPtr; dst_offset: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode>(CommandCopyImageToBufferKHR_adr);
    private ntv_CommandCopyImageToBufferKHR_5 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; src_origin: IntPtr; region: IntPtr; dst_offset: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode>(CommandCopyImageToBufferKHR_adr);
    private ntv_CommandCopyImageToBufferKHR_6 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; src_origin: IntPtr; region: IntPtr; dst_offset: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode>(CommandCopyImageToBufferKHR_adr);
    private ntv_CommandCopyImageToBufferKHR_7 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; src_origin: IntPtr; region: IntPtr; dst_offset: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode>(CommandCopyImageToBufferKHR_adr);
    private ntv_CommandCopyImageToBufferKHR_8 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; src_origin: IntPtr; region: IntPtr; dst_offset: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode>(CommandCopyImageToBufferKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyImageToBufferKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var region: UIntPtr; dst_offset: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandCopyImageToBufferKHR_1(command_buffer, command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyImageToBufferKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var region: UIntPtr; dst_offset: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandCopyImageToBufferKHR_2(command_buffer, command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyImageToBufferKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var region: UIntPtr; dst_offset: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandCopyImageToBufferKHR_3(command_buffer, command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyImageToBufferKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; var src_origin: UIntPtr; var region: UIntPtr; dst_offset: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandCopyImageToBufferKHR_4(command_buffer, command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyImageToBufferKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; src_origin: IntPtr; region: IntPtr; dst_offset: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandCopyImageToBufferKHR_5(command_buffer, command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyImageToBufferKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; src_origin: IntPtr; region: IntPtr; dst_offset: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandCopyImageToBufferKHR_6(command_buffer, command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyImageToBufferKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; src_origin: IntPtr; region: IntPtr; dst_offset: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandCopyImageToBufferKHR_7(command_buffer, command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandCopyImageToBufferKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; src_image: cl_mem; dst_buffer: cl_mem; src_origin: IntPtr; region: IntPtr; dst_offset: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandCopyImageToBufferKHR_8(command_buffer, command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    
    public CommandFillBufferKHR_adr := GetProcAddress('clCommandFillBufferKHR');
    private ntv_CommandFillBufferKHR_1 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; buffer: cl_mem; pattern: IntPtr; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode>(CommandFillBufferKHR_adr);
    private ntv_CommandFillBufferKHR_2 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; buffer: cl_mem; pattern: IntPtr; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode>(CommandFillBufferKHR_adr);
    private ntv_CommandFillBufferKHR_3 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; buffer: cl_mem; pattern: IntPtr; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; sync_point: IntPtr; var mutable_handle: cl_mutable_command): clErrorCode>(CommandFillBufferKHR_adr);
    private ntv_CommandFillBufferKHR_4 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; buffer: cl_mem; pattern: IntPtr; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; sync_point: IntPtr; mutable_handle: IntPtr): clErrorCode>(CommandFillBufferKHR_adr);
    private ntv_CommandFillBufferKHR_5 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; buffer: cl_mem; pattern: IntPtr; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode>(CommandFillBufferKHR_adr);
    private ntv_CommandFillBufferKHR_6 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; buffer: cl_mem; pattern: IntPtr; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode>(CommandFillBufferKHR_adr);
    private ntv_CommandFillBufferKHR_7 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; buffer: cl_mem; pattern: IntPtr; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; sync_point: IntPtr; var mutable_handle: cl_mutable_command): clErrorCode>(CommandFillBufferKHR_adr);
    private ntv_CommandFillBufferKHR_8 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; buffer: cl_mem; pattern: IntPtr; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; sync_point: IntPtr; mutable_handle: IntPtr): clErrorCode>(CommandFillBufferKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandFillBufferKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; buffer: cl_mem; pattern: IntPtr; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: array of UInt32; sync_point: array of UInt32; mutable_handle: array of cl_mutable_command): clErrorCode;
    type PUInt32 = ^UInt32;
    type PCl_mutable_command = ^cl_mutable_command;
    begin
      Result := if (mutable_handle<>nil) and (mutable_handle.Length<>0) then
        if (sync_point_wait_list<>nil) and (sync_point_wait_list.Length<>0) then
          if (sync_point<>nil) and (sync_point.Length<>0) then
            ntv_CommandFillBufferKHR_1(command_buffer, command_queue, buffer, pattern, pattern_size, offset, size, num_sync_points_in_wait_list, sync_point_wait_list[0], sync_point[0], mutable_handle[0]) else
            ntv_CommandFillBufferKHR_1(command_buffer, command_queue, buffer, pattern, pattern_size, offset, size, num_sync_points_in_wait_list, sync_point_wait_list[0], PUInt32(nil)^, mutable_handle[0]) else
          if (sync_point<>nil) and (sync_point.Length<>0) then
            ntv_CommandFillBufferKHR_1(command_buffer, command_queue, buffer, pattern, pattern_size, offset, size, num_sync_points_in_wait_list, PUInt32(nil)^, sync_point[0], mutable_handle[0]) else
            ntv_CommandFillBufferKHR_1(command_buffer, command_queue, buffer, pattern, pattern_size, offset, size, num_sync_points_in_wait_list, PUInt32(nil)^, PUInt32(nil)^, mutable_handle[0]) else
        if (sync_point_wait_list<>nil) and (sync_point_wait_list.Length<>0) then
          if (sync_point<>nil) and (sync_point.Length<>0) then
            ntv_CommandFillBufferKHR_1(command_buffer, command_queue, buffer, pattern, pattern_size, offset, size, num_sync_points_in_wait_list, sync_point_wait_list[0], sync_point[0], PCl_mutable_command(nil)^) else
            ntv_CommandFillBufferKHR_1(command_buffer, command_queue, buffer, pattern, pattern_size, offset, size, num_sync_points_in_wait_list, sync_point_wait_list[0], PUInt32(nil)^, PCl_mutable_command(nil)^) else
          if (sync_point<>nil) and (sync_point.Length<>0) then
            ntv_CommandFillBufferKHR_1(command_buffer, command_queue, buffer, pattern, pattern_size, offset, size, num_sync_points_in_wait_list, PUInt32(nil)^, sync_point[0], PCl_mutable_command(nil)^) else
            ntv_CommandFillBufferKHR_1(command_buffer, command_queue, buffer, pattern, pattern_size, offset, size, num_sync_points_in_wait_list, PUInt32(nil)^, PUInt32(nil)^, PCl_mutable_command(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandFillBufferKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; buffer: cl_mem; pattern: IntPtr; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandFillBufferKHR_1(command_buffer, command_queue, buffer, pattern, pattern_size, offset, size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandFillBufferKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; buffer: cl_mem; pattern: IntPtr; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandFillBufferKHR_2(command_buffer, command_queue, buffer, pattern, pattern_size, offset, size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandFillBufferKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; buffer: cl_mem; pattern: IntPtr; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; sync_point: IntPtr; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandFillBufferKHR_3(command_buffer, command_queue, buffer, pattern, pattern_size, offset, size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandFillBufferKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; buffer: cl_mem; pattern: IntPtr; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; sync_point: IntPtr; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandFillBufferKHR_4(command_buffer, command_queue, buffer, pattern, pattern_size, offset, size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandFillBufferKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; buffer: cl_mem; pattern: IntPtr; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandFillBufferKHR_5(command_buffer, command_queue, buffer, pattern, pattern_size, offset, size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandFillBufferKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; buffer: cl_mem; pattern: IntPtr; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandFillBufferKHR_6(command_buffer, command_queue, buffer, pattern, pattern_size, offset, size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandFillBufferKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; buffer: cl_mem; pattern: IntPtr; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; sync_point: IntPtr; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandFillBufferKHR_7(command_buffer, command_queue, buffer, pattern, pattern_size, offset, size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandFillBufferKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; buffer: cl_mem; pattern: IntPtr; pattern_size: UIntPtr; offset: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; sync_point: IntPtr; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandFillBufferKHR_8(command_buffer, command_queue, buffer, pattern, pattern_size, offset, size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    
    public CommandFillImageKHR_adr := GetProcAddress('clCommandFillImageKHR');
    private ntv_CommandFillImageKHR_1 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; image: cl_mem; var fill_color: Byte; var origin: UIntPtr; var region: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode>(CommandFillImageKHR_adr);
    private ntv_CommandFillImageKHR_2 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; image: cl_mem; var fill_color: Byte; var origin: UIntPtr; var region: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode>(CommandFillImageKHR_adr);
    private ntv_CommandFillImageKHR_3 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; image: cl_mem; var fill_color: Byte; var origin: UIntPtr; var region: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode>(CommandFillImageKHR_adr);
    private ntv_CommandFillImageKHR_4 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; image: cl_mem; var fill_color: Byte; var origin: UIntPtr; var region: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode>(CommandFillImageKHR_adr);
    private ntv_CommandFillImageKHR_5 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; image: cl_mem; fill_color: pointer; var origin: UIntPtr; var region: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode>(CommandFillImageKHR_adr);
    private ntv_CommandFillImageKHR_6 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; image: cl_mem; fill_color: pointer; var origin: UIntPtr; var region: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode>(CommandFillImageKHR_adr);
    private ntv_CommandFillImageKHR_7 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; image: cl_mem; fill_color: pointer; var origin: UIntPtr; var region: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode>(CommandFillImageKHR_adr);
    private ntv_CommandFillImageKHR_8 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; image: cl_mem; fill_color: pointer; var origin: UIntPtr; var region: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode>(CommandFillImageKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandFillImageKHR<T>(command_buffer: cl_command_buffer; command_queue: cl_command_queue; image: cl_mem; var fill_color: T; var origin: UIntPtr; var region: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode; where T: record;
    begin
      Result := ntv_CommandFillImageKHR_1(command_buffer, command_queue, image, PByte(pointer(@fill_color))^, origin, region, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandFillImageKHR<T>(command_buffer: cl_command_buffer; command_queue: cl_command_queue; image: cl_mem; var fill_color: T; var origin: UIntPtr; var region: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_CommandFillImageKHR_2(command_buffer, command_queue, image, PByte(pointer(@fill_color))^, origin, region, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandFillImageKHR<T>(command_buffer: cl_command_buffer; command_queue: cl_command_queue; image: cl_mem; var fill_color: T; var origin: UIntPtr; var region: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode; where T: record;
    begin
      Result := ntv_CommandFillImageKHR_3(command_buffer, command_queue, image, PByte(pointer(@fill_color))^, origin, region, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandFillImageKHR<T>(command_buffer: cl_command_buffer; command_queue: cl_command_queue; image: cl_mem; var fill_color: T; var origin: UIntPtr; var region: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_CommandFillImageKHR_4(command_buffer, command_queue, image, PByte(pointer(@fill_color))^, origin, region, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandFillImageKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; image: cl_mem; fill_color: pointer; var origin: UIntPtr; var region: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandFillImageKHR_5(command_buffer, command_queue, image, fill_color, origin, region, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandFillImageKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; image: cl_mem; fill_color: pointer; var origin: UIntPtr; var region: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandFillImageKHR_6(command_buffer, command_queue, image, fill_color, origin, region, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandFillImageKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; image: cl_mem; fill_color: pointer; var origin: UIntPtr; var region: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandFillImageKHR_7(command_buffer, command_queue, image, fill_color, origin, region, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandFillImageKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; image: cl_mem; fill_color: pointer; var origin: UIntPtr; var region: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandFillImageKHR_8(command_buffer, command_queue, image, fill_color, origin, region, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    
    public CommandNDRangeKernelKHR_adr := GetProcAddress('clCommandNDRangeKernelKHR');
    private ntv_CommandNDRangeKernelKHR_1 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; var properties: clNDRangeKernelCommandProperties; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode>(CommandNDRangeKernelKHR_adr);
    private ntv_CommandNDRangeKernelKHR_2 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; var properties: clNDRangeKernelCommandProperties; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode>(CommandNDRangeKernelKHR_adr);
    private ntv_CommandNDRangeKernelKHR_3 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; var properties: clNDRangeKernelCommandProperties; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode>(CommandNDRangeKernelKHR_adr);
    private ntv_CommandNDRangeKernelKHR_4 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; var properties: clNDRangeKernelCommandProperties; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode>(CommandNDRangeKernelKHR_adr);
    private ntv_CommandNDRangeKernelKHR_5 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; properties: IntPtr; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; global_work_size: IntPtr; local_work_size: IntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode>(CommandNDRangeKernelKHR_adr);
    private ntv_CommandNDRangeKernelKHR_6 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; properties: IntPtr; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; global_work_size: IntPtr; local_work_size: IntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode>(CommandNDRangeKernelKHR_adr);
    private ntv_CommandNDRangeKernelKHR_7 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; properties: IntPtr; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; global_work_size: IntPtr; local_work_size: IntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode>(CommandNDRangeKernelKHR_adr);
    private ntv_CommandNDRangeKernelKHR_8 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; properties: IntPtr; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; global_work_size: IntPtr; local_work_size: IntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode>(CommandNDRangeKernelKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandNDRangeKernelKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; var properties: clNDRangeKernelCommandProperties; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandNDRangeKernelKHR_1(command_buffer, command_queue, properties, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandNDRangeKernelKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; var properties: clNDRangeKernelCommandProperties; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandNDRangeKernelKHR_2(command_buffer, command_queue, properties, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandNDRangeKernelKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; var properties: clNDRangeKernelCommandProperties; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandNDRangeKernelKHR_3(command_buffer, command_queue, properties, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandNDRangeKernelKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; var properties: clNDRangeKernelCommandProperties; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; var local_work_size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandNDRangeKernelKHR_4(command_buffer, command_queue, properties, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandNDRangeKernelKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; properties: IntPtr; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; global_work_size: IntPtr; local_work_size: IntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandNDRangeKernelKHR_5(command_buffer, command_queue, properties, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandNDRangeKernelKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; properties: IntPtr; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; global_work_size: IntPtr; local_work_size: IntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandNDRangeKernelKHR_6(command_buffer, command_queue, properties, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandNDRangeKernelKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; properties: IntPtr; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; global_work_size: IntPtr; local_work_size: IntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandNDRangeKernelKHR_7(command_buffer, command_queue, properties, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandNDRangeKernelKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; properties: IntPtr; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; global_work_size: IntPtr; local_work_size: IntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandNDRangeKernelKHR_8(command_buffer, command_queue, properties, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    
    public CommandSVMMemcpyKHR_adr := GetProcAddress('clCommandSVMMemcpyKHR');
    private ntv_CommandSVMMemcpyKHR_1 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode>(CommandSVMMemcpyKHR_adr);
    private ntv_CommandSVMMemcpyKHR_2 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode>(CommandSVMMemcpyKHR_adr);
    private ntv_CommandSVMMemcpyKHR_3 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; sync_point: IntPtr; var mutable_handle: cl_mutable_command): clErrorCode>(CommandSVMMemcpyKHR_adr);
    private ntv_CommandSVMMemcpyKHR_4 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; sync_point: IntPtr; mutable_handle: IntPtr): clErrorCode>(CommandSVMMemcpyKHR_adr);
    private ntv_CommandSVMMemcpyKHR_5 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode>(CommandSVMMemcpyKHR_adr);
    private ntv_CommandSVMMemcpyKHR_6 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode>(CommandSVMMemcpyKHR_adr);
    private ntv_CommandSVMMemcpyKHR_7 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; sync_point: IntPtr; var mutable_handle: cl_mutable_command): clErrorCode>(CommandSVMMemcpyKHR_adr);
    private ntv_CommandSVMMemcpyKHR_8 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; sync_point: IntPtr; mutable_handle: IntPtr): clErrorCode>(CommandSVMMemcpyKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandSVMMemcpyKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: array of UInt32; sync_point: array of UInt32; mutable_handle: array of cl_mutable_command): clErrorCode;
    type PUInt32 = ^UInt32;
    type PCl_mutable_command = ^cl_mutable_command;
    begin
      Result := if (mutable_handle<>nil) and (mutable_handle.Length<>0) then
        if (sync_point_wait_list<>nil) and (sync_point_wait_list.Length<>0) then
          if (sync_point<>nil) and (sync_point.Length<>0) then
            ntv_CommandSVMMemcpyKHR_1(command_buffer, command_queue, dst_ptr, src_ptr, size, num_sync_points_in_wait_list, sync_point_wait_list[0], sync_point[0], mutable_handle[0]) else
            ntv_CommandSVMMemcpyKHR_1(command_buffer, command_queue, dst_ptr, src_ptr, size, num_sync_points_in_wait_list, sync_point_wait_list[0], PUInt32(nil)^, mutable_handle[0]) else
          if (sync_point<>nil) and (sync_point.Length<>0) then
            ntv_CommandSVMMemcpyKHR_1(command_buffer, command_queue, dst_ptr, src_ptr, size, num_sync_points_in_wait_list, PUInt32(nil)^, sync_point[0], mutable_handle[0]) else
            ntv_CommandSVMMemcpyKHR_1(command_buffer, command_queue, dst_ptr, src_ptr, size, num_sync_points_in_wait_list, PUInt32(nil)^, PUInt32(nil)^, mutable_handle[0]) else
        if (sync_point_wait_list<>nil) and (sync_point_wait_list.Length<>0) then
          if (sync_point<>nil) and (sync_point.Length<>0) then
            ntv_CommandSVMMemcpyKHR_1(command_buffer, command_queue, dst_ptr, src_ptr, size, num_sync_points_in_wait_list, sync_point_wait_list[0], sync_point[0], PCl_mutable_command(nil)^) else
            ntv_CommandSVMMemcpyKHR_1(command_buffer, command_queue, dst_ptr, src_ptr, size, num_sync_points_in_wait_list, sync_point_wait_list[0], PUInt32(nil)^, PCl_mutable_command(nil)^) else
          if (sync_point<>nil) and (sync_point.Length<>0) then
            ntv_CommandSVMMemcpyKHR_1(command_buffer, command_queue, dst_ptr, src_ptr, size, num_sync_points_in_wait_list, PUInt32(nil)^, sync_point[0], PCl_mutable_command(nil)^) else
            ntv_CommandSVMMemcpyKHR_1(command_buffer, command_queue, dst_ptr, src_ptr, size, num_sync_points_in_wait_list, PUInt32(nil)^, PUInt32(nil)^, PCl_mutable_command(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandSVMMemcpyKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandSVMMemcpyKHR_1(command_buffer, command_queue, dst_ptr, src_ptr, size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandSVMMemcpyKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandSVMMemcpyKHR_2(command_buffer, command_queue, dst_ptr, src_ptr, size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandSVMMemcpyKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; sync_point: IntPtr; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandSVMMemcpyKHR_3(command_buffer, command_queue, dst_ptr, src_ptr, size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandSVMMemcpyKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; sync_point: IntPtr; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandSVMMemcpyKHR_4(command_buffer, command_queue, dst_ptr, src_ptr, size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandSVMMemcpyKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandSVMMemcpyKHR_5(command_buffer, command_queue, dst_ptr, src_ptr, size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandSVMMemcpyKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandSVMMemcpyKHR_6(command_buffer, command_queue, dst_ptr, src_ptr, size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandSVMMemcpyKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; sync_point: IntPtr; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandSVMMemcpyKHR_7(command_buffer, command_queue, dst_ptr, src_ptr, size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandSVMMemcpyKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; dst_ptr: IntPtr; src_ptr: IntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; sync_point: IntPtr; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandSVMMemcpyKHR_8(command_buffer, command_queue, dst_ptr, src_ptr, size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    
    public CommandSVMMemFillKHR_adr := GetProcAddress('clCommandSVMMemFillKHR');
    private ntv_CommandSVMMemFillKHR_1 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: IntPtr; pattern_size: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode>(CommandSVMMemFillKHR_adr);
    private ntv_CommandSVMMemFillKHR_2 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: IntPtr; pattern_size: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode>(CommandSVMMemFillKHR_adr);
    private ntv_CommandSVMMemFillKHR_3 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: IntPtr; pattern_size: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; sync_point: IntPtr; var mutable_handle: cl_mutable_command): clErrorCode>(CommandSVMMemFillKHR_adr);
    private ntv_CommandSVMMemFillKHR_4 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: IntPtr; pattern_size: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; sync_point: IntPtr; mutable_handle: IntPtr): clErrorCode>(CommandSVMMemFillKHR_adr);
    private ntv_CommandSVMMemFillKHR_5 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: IntPtr; pattern_size: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode>(CommandSVMMemFillKHR_adr);
    private ntv_CommandSVMMemFillKHR_6 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: IntPtr; pattern_size: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode>(CommandSVMMemFillKHR_adr);
    private ntv_CommandSVMMemFillKHR_7 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: IntPtr; pattern_size: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; sync_point: IntPtr; var mutable_handle: cl_mutable_command): clErrorCode>(CommandSVMMemFillKHR_adr);
    private ntv_CommandSVMMemFillKHR_8 := GetProcOrNil&<function(command_buffer: cl_command_buffer; command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: IntPtr; pattern_size: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; sync_point: IntPtr; mutable_handle: IntPtr): clErrorCode>(CommandSVMMemFillKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandSVMMemFillKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: IntPtr; pattern_size: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: array of UInt32; sync_point: array of UInt32; mutable_handle: array of cl_mutable_command): clErrorCode;
    type PUInt32 = ^UInt32;
    type PCl_mutable_command = ^cl_mutable_command;
    begin
      Result := if (mutable_handle<>nil) and (mutable_handle.Length<>0) then
        if (sync_point_wait_list<>nil) and (sync_point_wait_list.Length<>0) then
          if (sync_point<>nil) and (sync_point.Length<>0) then
            ntv_CommandSVMMemFillKHR_1(command_buffer, command_queue, svm_ptr, pattern, pattern_size, size, num_sync_points_in_wait_list, sync_point_wait_list[0], sync_point[0], mutable_handle[0]) else
            ntv_CommandSVMMemFillKHR_1(command_buffer, command_queue, svm_ptr, pattern, pattern_size, size, num_sync_points_in_wait_list, sync_point_wait_list[0], PUInt32(nil)^, mutable_handle[0]) else
          if (sync_point<>nil) and (sync_point.Length<>0) then
            ntv_CommandSVMMemFillKHR_1(command_buffer, command_queue, svm_ptr, pattern, pattern_size, size, num_sync_points_in_wait_list, PUInt32(nil)^, sync_point[0], mutable_handle[0]) else
            ntv_CommandSVMMemFillKHR_1(command_buffer, command_queue, svm_ptr, pattern, pattern_size, size, num_sync_points_in_wait_list, PUInt32(nil)^, PUInt32(nil)^, mutable_handle[0]) else
        if (sync_point_wait_list<>nil) and (sync_point_wait_list.Length<>0) then
          if (sync_point<>nil) and (sync_point.Length<>0) then
            ntv_CommandSVMMemFillKHR_1(command_buffer, command_queue, svm_ptr, pattern, pattern_size, size, num_sync_points_in_wait_list, sync_point_wait_list[0], sync_point[0], PCl_mutable_command(nil)^) else
            ntv_CommandSVMMemFillKHR_1(command_buffer, command_queue, svm_ptr, pattern, pattern_size, size, num_sync_points_in_wait_list, sync_point_wait_list[0], PUInt32(nil)^, PCl_mutable_command(nil)^) else
          if (sync_point<>nil) and (sync_point.Length<>0) then
            ntv_CommandSVMMemFillKHR_1(command_buffer, command_queue, svm_ptr, pattern, pattern_size, size, num_sync_points_in_wait_list, PUInt32(nil)^, sync_point[0], PCl_mutable_command(nil)^) else
            ntv_CommandSVMMemFillKHR_1(command_buffer, command_queue, svm_ptr, pattern, pattern_size, size, num_sync_points_in_wait_list, PUInt32(nil)^, PUInt32(nil)^, PCl_mutable_command(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandSVMMemFillKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: IntPtr; pattern_size: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandSVMMemFillKHR_1(command_buffer, command_queue, svm_ptr, pattern, pattern_size, size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandSVMMemFillKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: IntPtr; pattern_size: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandSVMMemFillKHR_2(command_buffer, command_queue, svm_ptr, pattern, pattern_size, size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandSVMMemFillKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: IntPtr; pattern_size: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; sync_point: IntPtr; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandSVMMemFillKHR_3(command_buffer, command_queue, svm_ptr, pattern, pattern_size, size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandSVMMemFillKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: IntPtr; pattern_size: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; var sync_point_wait_list: UInt32; sync_point: IntPtr; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandSVMMemFillKHR_4(command_buffer, command_queue, svm_ptr, pattern, pattern_size, size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandSVMMemFillKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: IntPtr; pattern_size: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandSVMMemFillKHR_5(command_buffer, command_queue, svm_ptr, pattern, pattern_size, size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandSVMMemFillKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: IntPtr; pattern_size: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; var sync_point: UInt32; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandSVMMemFillKHR_6(command_buffer, command_queue, svm_ptr, pattern, pattern_size, size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandSVMMemFillKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: IntPtr; pattern_size: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; sync_point: IntPtr; var mutable_handle: cl_mutable_command): clErrorCode :=
      ntv_CommandSVMMemFillKHR_7(command_buffer, command_queue, svm_ptr, pattern, pattern_size, size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CommandSVMMemFillKHR(command_buffer: cl_command_buffer; command_queue: cl_command_queue; svm_ptr: IntPtr; pattern: IntPtr; pattern_size: UIntPtr; size: UIntPtr; num_sync_points_in_wait_list: UInt32; sync_point_wait_list: IntPtr; sync_point: IntPtr; mutable_handle: IntPtr): clErrorCode :=
      ntv_CommandSVMMemFillKHR_8(command_buffer, command_queue, svm_ptr, pattern, pattern_size, size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
    
    public GetCommandBufferInfoKHR_adr := GetProcAddress('clGetCommandBufferInfoKHR');
    private ntv_GetCommandBufferInfoKHR_1 := GetProcOrNil&<function(command_buffer: cl_command_buffer; param_name: clCommandBufferInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode>(GetCommandBufferInfoKHR_adr);
    private ntv_GetCommandBufferInfoKHR_2 := GetProcOrNil&<function(command_buffer: cl_command_buffer; param_name: clCommandBufferInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode>(GetCommandBufferInfoKHR_adr);
    private ntv_GetCommandBufferInfoKHR_3 := GetProcOrNil&<function(command_buffer: cl_command_buffer; param_name: clCommandBufferInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode>(GetCommandBufferInfoKHR_adr);
    private ntv_GetCommandBufferInfoKHR_4 := GetProcOrNil&<function(command_buffer: cl_command_buffer; param_name: clCommandBufferInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode>(GetCommandBufferInfoKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCommandBufferInfoKHR<T>(command_buffer: cl_command_buffer; param_name: clCommandBufferInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetCommandBufferInfoKHR_1(command_buffer, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCommandBufferInfoKHR<T>(command_buffer: cl_command_buffer; param_name: clCommandBufferInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetCommandBufferInfoKHR_2(command_buffer, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCommandBufferInfoKHR(command_buffer: cl_command_buffer; param_name: clCommandBufferInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetCommandBufferInfoKHR_3(command_buffer, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCommandBufferInfoKHR(command_buffer: cl_command_buffer; param_name: clCommandBufferInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetCommandBufferInfoKHR_4(command_buffer, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCommandBufferInfoKHR_COMMAND_BUFFER_QUEUES(command_buffer: cl_command_buffer; var param_value: array of cl_command_queue): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetCommandBufferInfoKHR_3(command_buffer, clCommandBufferInfo.COMMAND_BUFFER_QUEUES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new cl_command_queue[param_value_sz.ToUInt64 div Marshal.SizeOf&<cl_command_queue>];
      Result := GetCommandBufferInfoKHR(command_buffer, clCommandBufferInfo.COMMAND_BUFFER_QUEUES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCommandBufferInfoKHR_COMMAND_BUFFER_QUEUES(command_buffer: cl_command_buffer; param_value_count: UInt32; var param_value: cl_command_queue): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<cl_command_queue>);
      Result := GetCommandBufferInfoKHR(command_buffer, clCommandBufferInfo.COMMAND_BUFFER_QUEUES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCommandBufferInfoKHR_COMMAND_BUFFER_NUM_QUEUES(command_buffer: cl_command_buffer; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetCommandBufferInfoKHR(command_buffer, clCommandBufferInfo.COMMAND_BUFFER_NUM_QUEUES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCommandBufferInfoKHR_COMMAND_BUFFER_REFERENCE_COUNT(command_buffer: cl_command_buffer; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetCommandBufferInfoKHR(command_buffer, clCommandBufferInfo.COMMAND_BUFFER_REFERENCE_COUNT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCommandBufferInfoKHR_COMMAND_BUFFER_STATE(command_buffer: cl_command_buffer; var param_value: clCommandBufferState; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clCommandBufferState>);
      var param_value_ret_size: UIntPtr;
      Result := GetCommandBufferInfoKHR(command_buffer, clCommandBufferInfo.COMMAND_BUFFER_STATE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCommandBufferInfoKHR_COMMAND_BUFFER_PROPERTIES_ARRAY(command_buffer: cl_command_buffer; var param_value: array of clCommandBufferProperties): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetCommandBufferInfoKHR_3(command_buffer, clCommandBufferInfo.COMMAND_BUFFER_PROPERTIES_ARRAY, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new clCommandBufferProperties[param_value_sz.ToUInt64 div Marshal.SizeOf&<clCommandBufferProperties>];
      Result := GetCommandBufferInfoKHR(command_buffer, clCommandBufferInfo.COMMAND_BUFFER_PROPERTIES_ARRAY, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCommandBufferInfoKHR_COMMAND_BUFFER_PROPERTIES_ARRAY(command_buffer: cl_command_buffer; param_value_count: UInt32; var param_value: clCommandBufferProperties): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<clCommandBufferProperties>);
      Result := GetCommandBufferInfoKHR(command_buffer, clCommandBufferInfo.COMMAND_BUFFER_PROPERTIES_ARRAY, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCommandBufferInfoKHR_COMMAND_BUFFER_CONTEXT(command_buffer: cl_command_buffer; var param_value: cl_context; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_context>);
      var param_value_ret_size: UIntPtr;
      Result := GetCommandBufferInfoKHR(command_buffer, clCommandBufferInfo.COMMAND_BUFFER_CONTEXT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clCommandBufferMultiDeviceKHR = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clCommandBufferMultiDeviceKHR(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_khr_command_buffer_multi_device';
    
    public RemapCommandBufferKHR_adr := GetProcAddress('clRemapCommandBufferKHR');
    private ntv_RemapCommandBufferKHR_1 := GetProcOrNil&<function(command_buffer: cl_command_buffer; automatic: clBool; num_queues: UInt32; var queues: cl_command_queue; num_handles: UInt32; var handles: cl_mutable_command; var handles_ret: cl_mutable_command; var errcode_ret: clErrorCode): cl_command_buffer>(RemapCommandBufferKHR_adr);
    private ntv_RemapCommandBufferKHR_2 := GetProcOrNil&<function(command_buffer: cl_command_buffer; automatic: clBool; num_queues: UInt32; var queues: cl_command_queue; num_handles: UInt32; var handles: cl_mutable_command; handles_ret: IntPtr; var errcode_ret: clErrorCode): cl_command_buffer>(RemapCommandBufferKHR_adr);
    private ntv_RemapCommandBufferKHR_3 := GetProcOrNil&<function(command_buffer: cl_command_buffer; automatic: clBool; num_queues: UInt32; var queues: cl_command_queue; num_handles: UInt32; handles: IntPtr; var handles_ret: cl_mutable_command; var errcode_ret: clErrorCode): cl_command_buffer>(RemapCommandBufferKHR_adr);
    private ntv_RemapCommandBufferKHR_4 := GetProcOrNil&<function(command_buffer: cl_command_buffer; automatic: clBool; num_queues: UInt32; var queues: cl_command_queue; num_handles: UInt32; handles: IntPtr; handles_ret: IntPtr; var errcode_ret: clErrorCode): cl_command_buffer>(RemapCommandBufferKHR_adr);
    private ntv_RemapCommandBufferKHR_5 := GetProcOrNil&<function(command_buffer: cl_command_buffer; automatic: clBool; num_queues: UInt32; queues: IntPtr; num_handles: UInt32; var handles: cl_mutable_command; var handles_ret: cl_mutable_command; var errcode_ret: clErrorCode): cl_command_buffer>(RemapCommandBufferKHR_adr);
    private ntv_RemapCommandBufferKHR_6 := GetProcOrNil&<function(command_buffer: cl_command_buffer; automatic: clBool; num_queues: UInt32; queues: IntPtr; num_handles: UInt32; var handles: cl_mutable_command; handles_ret: IntPtr; var errcode_ret: clErrorCode): cl_command_buffer>(RemapCommandBufferKHR_adr);
    private ntv_RemapCommandBufferKHR_7 := GetProcOrNil&<function(command_buffer: cl_command_buffer; automatic: clBool; num_queues: UInt32; queues: IntPtr; num_handles: UInt32; handles: IntPtr; var handles_ret: cl_mutable_command; var errcode_ret: clErrorCode): cl_command_buffer>(RemapCommandBufferKHR_adr);
    private ntv_RemapCommandBufferKHR_8 := GetProcOrNil&<function(command_buffer: cl_command_buffer; automatic: clBool; num_queues: UInt32; queues: IntPtr; num_handles: UInt32; handles: IntPtr; handles_ret: IntPtr; var errcode_ret: clErrorCode): cl_command_buffer>(RemapCommandBufferKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function RemapCommandBufferKHR(command_buffer: cl_command_buffer; automatic: clBool; num_queues: UInt32; queues: array of cl_command_queue; num_handles: UInt32; handles: array of cl_mutable_command; var handles_ret: cl_mutable_command; var errcode_ret: clErrorCode): cl_command_buffer;
    type PCl_command_queue = ^cl_command_queue;
    type PCl_mutable_command = ^cl_mutable_command;
    begin
      Result := if (queues<>nil) and (queues.Length<>0) then
        if (handles<>nil) and (handles.Length<>0) then
          ntv_RemapCommandBufferKHR_1(command_buffer, automatic, num_queues, queues[0], num_handles, handles[0], handles_ret, errcode_ret) else
          ntv_RemapCommandBufferKHR_1(command_buffer, automatic, num_queues, queues[0], num_handles, PCl_mutable_command(nil)^, handles_ret, errcode_ret) else
        if (handles<>nil) and (handles.Length<>0) then
          ntv_RemapCommandBufferKHR_1(command_buffer, automatic, num_queues, PCl_command_queue(nil)^, num_handles, handles[0], handles_ret, errcode_ret) else
          ntv_RemapCommandBufferKHR_1(command_buffer, automatic, num_queues, PCl_command_queue(nil)^, num_handles, PCl_mutable_command(nil)^, handles_ret, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function RemapCommandBufferKHR(command_buffer: cl_command_buffer; automatic: clBool; num_queues: UInt32; queues: array of cl_command_queue; num_handles: UInt32; handles: array of cl_mutable_command; handles_ret: IntPtr; var errcode_ret: clErrorCode): cl_command_buffer;
    type PCl_command_queue = ^cl_command_queue;
    type PCl_mutable_command = ^cl_mutable_command;
    begin
      Result := if (queues<>nil) and (queues.Length<>0) then
        if (handles<>nil) and (handles.Length<>0) then
          ntv_RemapCommandBufferKHR_2(command_buffer, automatic, num_queues, queues[0], num_handles, handles[0], handles_ret, errcode_ret) else
          ntv_RemapCommandBufferKHR_2(command_buffer, automatic, num_queues, queues[0], num_handles, PCl_mutable_command(nil)^, handles_ret, errcode_ret) else
        if (handles<>nil) and (handles.Length<>0) then
          ntv_RemapCommandBufferKHR_2(command_buffer, automatic, num_queues, PCl_command_queue(nil)^, num_handles, handles[0], handles_ret, errcode_ret) else
          ntv_RemapCommandBufferKHR_2(command_buffer, automatic, num_queues, PCl_command_queue(nil)^, num_handles, PCl_mutable_command(nil)^, handles_ret, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function RemapCommandBufferKHR(command_buffer: cl_command_buffer; automatic: clBool; num_queues: UInt32; var queues: cl_command_queue; num_handles: UInt32; var handles: cl_mutable_command; var handles_ret: cl_mutable_command; var errcode_ret: clErrorCode): cl_command_buffer :=
      ntv_RemapCommandBufferKHR_1(command_buffer, automatic, num_queues, queues, num_handles, handles, handles_ret, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function RemapCommandBufferKHR(command_buffer: cl_command_buffer; automatic: clBool; num_queues: UInt32; var queues: cl_command_queue; num_handles: UInt32; var handles: cl_mutable_command; handles_ret: IntPtr; var errcode_ret: clErrorCode): cl_command_buffer :=
      ntv_RemapCommandBufferKHR_2(command_buffer, automatic, num_queues, queues, num_handles, handles, handles_ret, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function RemapCommandBufferKHR(command_buffer: cl_command_buffer; automatic: clBool; num_queues: UInt32; var queues: cl_command_queue; num_handles: UInt32; handles: IntPtr; var handles_ret: cl_mutable_command; var errcode_ret: clErrorCode): cl_command_buffer :=
      ntv_RemapCommandBufferKHR_3(command_buffer, automatic, num_queues, queues, num_handles, handles, handles_ret, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function RemapCommandBufferKHR(command_buffer: cl_command_buffer; automatic: clBool; num_queues: UInt32; var queues: cl_command_queue; num_handles: UInt32; handles: IntPtr; handles_ret: IntPtr; var errcode_ret: clErrorCode): cl_command_buffer :=
      ntv_RemapCommandBufferKHR_4(command_buffer, automatic, num_queues, queues, num_handles, handles, handles_ret, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function RemapCommandBufferKHR(command_buffer: cl_command_buffer; automatic: clBool; num_queues: UInt32; queues: IntPtr; num_handles: UInt32; var handles: cl_mutable_command; var handles_ret: cl_mutable_command; var errcode_ret: clErrorCode): cl_command_buffer :=
      ntv_RemapCommandBufferKHR_5(command_buffer, automatic, num_queues, queues, num_handles, handles, handles_ret, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function RemapCommandBufferKHR(command_buffer: cl_command_buffer; automatic: clBool; num_queues: UInt32; queues: IntPtr; num_handles: UInt32; var handles: cl_mutable_command; handles_ret: IntPtr; var errcode_ret: clErrorCode): cl_command_buffer :=
      ntv_RemapCommandBufferKHR_6(command_buffer, automatic, num_queues, queues, num_handles, handles, handles_ret, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function RemapCommandBufferKHR(command_buffer: cl_command_buffer; automatic: clBool; num_queues: UInt32; queues: IntPtr; num_handles: UInt32; handles: IntPtr; var handles_ret: cl_mutable_command; var errcode_ret: clErrorCode): cl_command_buffer :=
      ntv_RemapCommandBufferKHR_7(command_buffer, automatic, num_queues, queues, num_handles, handles, handles_ret, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function RemapCommandBufferKHR(command_buffer: cl_command_buffer; automatic: clBool; num_queues: UInt32; queues: IntPtr; num_handles: UInt32; handles: IntPtr; handles_ret: IntPtr; var errcode_ret: clErrorCode): cl_command_buffer :=
      ntv_RemapCommandBufferKHR_8(command_buffer, automatic, num_queues, queues, num_handles, handles, handles_ret, errcode_ret);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clCommandBufferMutableDispatchKHR = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clCommandBufferMutableDispatchKHR(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_khr_command_buffer_mutable_dispatch';
    
    public UpdateMutableCommandsKHR_adr := GetProcAddress('clUpdateMutableCommandsKHR');
    private ntv_UpdateMutableCommandsKHR_1 := GetProcOrNil&<function(command_buffer: cl_command_buffer; var mutable_config: cl_mutable_base_config): clErrorCode>(UpdateMutableCommandsKHR_adr);
    private ntv_UpdateMutableCommandsKHR_2 := GetProcOrNil&<function(command_buffer: cl_command_buffer; mutable_config: IntPtr): clErrorCode>(UpdateMutableCommandsKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function UpdateMutableCommandsKHR(command_buffer: cl_command_buffer; mutable_config: array of cl_mutable_base_config): clErrorCode;
    type PCl_mutable_base_config = ^cl_mutable_base_config;
    begin
      Result := if (mutable_config<>nil) and (mutable_config.Length<>0) then
        ntv_UpdateMutableCommandsKHR_1(command_buffer, mutable_config[0]) else
        ntv_UpdateMutableCommandsKHR_1(command_buffer, PCl_mutable_base_config(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function UpdateMutableCommandsKHR(command_buffer: cl_command_buffer; var mutable_config: cl_mutable_base_config): clErrorCode :=
      ntv_UpdateMutableCommandsKHR_1(command_buffer, mutable_config);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function UpdateMutableCommandsKHR(command_buffer: cl_command_buffer; mutable_config: IntPtr): clErrorCode :=
      ntv_UpdateMutableCommandsKHR_2(command_buffer, mutable_config);
    
    public GetMutableCommandInfoKHR_adr := GetProcAddress('clGetMutableCommandInfoKHR');
    private ntv_GetMutableCommandInfoKHR_1 := GetProcOrNil&<function(command: cl_mutable_command; param_name: clMutableCommandInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode>(GetMutableCommandInfoKHR_adr);
    private ntv_GetMutableCommandInfoKHR_2 := GetProcOrNil&<function(command: cl_mutable_command; param_name: clMutableCommandInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode>(GetMutableCommandInfoKHR_adr);
    private ntv_GetMutableCommandInfoKHR_3 := GetProcOrNil&<function(command: cl_mutable_command; param_name: clMutableCommandInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode>(GetMutableCommandInfoKHR_adr);
    private ntv_GetMutableCommandInfoKHR_4 := GetProcOrNil&<function(command: cl_mutable_command; param_name: clMutableCommandInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode>(GetMutableCommandInfoKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMutableCommandInfoKHR<T>(command: cl_mutable_command; param_name: clMutableCommandInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetMutableCommandInfoKHR_1(command, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMutableCommandInfoKHR<T>(command: cl_mutable_command; param_name: clMutableCommandInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetMutableCommandInfoKHR_2(command, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMutableCommandInfoKHR(command: cl_mutable_command; param_name: clMutableCommandInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetMutableCommandInfoKHR_3(command, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMutableCommandInfoKHR(command: cl_mutable_command; param_name: clMutableCommandInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetMutableCommandInfoKHR_4(command, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMutableCommandInfoKHR_MUTABLE_COMMAND_COMMAND_QUEUE(command: cl_mutable_command; var param_value: cl_command_queue; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_command_queue>);
      var param_value_ret_size: UIntPtr;
      Result := GetMutableCommandInfoKHR(command, clMutableCommandInfo.MUTABLE_COMMAND_COMMAND_QUEUE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMutableCommandInfoKHR_MUTABLE_COMMAND_COMMAND_BUFFER(command: cl_mutable_command; var param_value: cl_command_buffer; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_command_buffer>);
      var param_value_ret_size: UIntPtr;
      Result := GetMutableCommandInfoKHR(command, clMutableCommandInfo.MUTABLE_COMMAND_COMMAND_BUFFER, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMutableCommandInfoKHR_MUTABLE_DISPATCH_PROPERTIES_ARRAY(command: cl_mutable_command; var param_value: array of clNDRangeKernelCommandProperties): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetMutableCommandInfoKHR_3(command, clMutableCommandInfo.MUTABLE_DISPATCH_PROPERTIES_ARRAY, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new clNDRangeKernelCommandProperties[param_value_sz.ToUInt64 div Marshal.SizeOf&<clNDRangeKernelCommandProperties>];
      Result := GetMutableCommandInfoKHR(command, clMutableCommandInfo.MUTABLE_DISPATCH_PROPERTIES_ARRAY, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMutableCommandInfoKHR_MUTABLE_DISPATCH_PROPERTIES_ARRAY(command: cl_mutable_command; param_value_count: UInt32; var param_value: clNDRangeKernelCommandProperties): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<clNDRangeKernelCommandProperties>);
      Result := GetMutableCommandInfoKHR(command, clMutableCommandInfo.MUTABLE_DISPATCH_PROPERTIES_ARRAY, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMutableCommandInfoKHR_MUTABLE_DISPATCH_KERNEL(command: cl_mutable_command; var param_value: cl_kernel; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_kernel>);
      var param_value_ret_size: UIntPtr;
      Result := GetMutableCommandInfoKHR(command, clMutableCommandInfo.MUTABLE_DISPATCH_KERNEL, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMutableCommandInfoKHR_MUTABLE_DISPATCH_DIMENSIONS(command: cl_mutable_command; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetMutableCommandInfoKHR(command, clMutableCommandInfo.MUTABLE_DISPATCH_DIMENSIONS, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMutableCommandInfoKHR_MUTABLE_DISPATCH_GLOBAL_WORK_OFFSET(command: cl_mutable_command; var param_value: array of UIntPtr): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetMutableCommandInfoKHR_3(command, clMutableCommandInfo.MUTABLE_DISPATCH_GLOBAL_WORK_OFFSET, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new UIntPtr[param_value_sz.ToUInt64 div Marshal.SizeOf&<UIntPtr>];
      Result := GetMutableCommandInfoKHR(command, clMutableCommandInfo.MUTABLE_DISPATCH_GLOBAL_WORK_OFFSET, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMutableCommandInfoKHR_MUTABLE_DISPATCH_GLOBAL_WORK_OFFSET(command: cl_mutable_command; param_value_count: UInt32; var param_value: UIntPtr): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<UIntPtr>);
      Result := GetMutableCommandInfoKHR(command, clMutableCommandInfo.MUTABLE_DISPATCH_GLOBAL_WORK_OFFSET, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMutableCommandInfoKHR_MUTABLE_DISPATCH_GLOBAL_WORK_SIZE(command: cl_mutable_command; var param_value: array of UIntPtr): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetMutableCommandInfoKHR_3(command, clMutableCommandInfo.MUTABLE_DISPATCH_GLOBAL_WORK_SIZE, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new UIntPtr[param_value_sz.ToUInt64 div Marshal.SizeOf&<UIntPtr>];
      Result := GetMutableCommandInfoKHR(command, clMutableCommandInfo.MUTABLE_DISPATCH_GLOBAL_WORK_SIZE, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMutableCommandInfoKHR_MUTABLE_DISPATCH_GLOBAL_WORK_SIZE(command: cl_mutable_command; param_value_count: UInt32; var param_value: UIntPtr): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<UIntPtr>);
      Result := GetMutableCommandInfoKHR(command, clMutableCommandInfo.MUTABLE_DISPATCH_GLOBAL_WORK_SIZE, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMutableCommandInfoKHR_MUTABLE_DISPATCH_LOCAL_WORK_SIZE(command: cl_mutable_command; var param_value: array of UIntPtr): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetMutableCommandInfoKHR_3(command, clMutableCommandInfo.MUTABLE_DISPATCH_LOCAL_WORK_SIZE, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new UIntPtr[param_value_sz.ToUInt64 div Marshal.SizeOf&<UIntPtr>];
      Result := GetMutableCommandInfoKHR(command, clMutableCommandInfo.MUTABLE_DISPATCH_LOCAL_WORK_SIZE, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMutableCommandInfoKHR_MUTABLE_DISPATCH_LOCAL_WORK_SIZE(command: cl_mutable_command; param_value_count: UInt32; var param_value: UIntPtr): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<UIntPtr>);
      Result := GetMutableCommandInfoKHR(command, clMutableCommandInfo.MUTABLE_DISPATCH_LOCAL_WORK_SIZE, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMutableCommandInfoKHR_MUTABLE_COMMAND_COMMAND_TYPE(command: cl_mutable_command; var param_value: clCommandType; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clCommandType>);
      var param_value_ret_size: UIntPtr;
      Result := GetMutableCommandInfoKHR(command, clMutableCommandInfo.MUTABLE_COMMAND_COMMAND_TYPE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clCreateCommandQueueKHR = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clCreateCommandQueueKHR(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_khr_create_command_queue';
    
    public CreateCommandQueueWithPropertiesKHR_adr := GetProcAddress('clCreateCommandQueueWithPropertiesKHR');
    private ntv_CreateCommandQueueWithPropertiesKHR_1 := GetProcOrNil&<function(context: cl_context; device: cl_device_id; var properties: UInt64; var errcode_ret: clErrorCode): cl_command_queue>(CreateCommandQueueWithPropertiesKHR_adr);
    private ntv_CreateCommandQueueWithPropertiesKHR_2 := GetProcOrNil&<function(context: cl_context; device: cl_device_id; properties: IntPtr; var errcode_ret: clErrorCode): cl_command_queue>(CreateCommandQueueWithPropertiesKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateCommandQueueWithPropertiesKHR(context: cl_context; device: cl_device_id; properties: array of UInt64; var errcode_ret: clErrorCode): cl_command_queue;
    type PUInt64 = ^UInt64;
    begin
      Result := if (properties<>nil) and (properties.Length<>0) then
        ntv_CreateCommandQueueWithPropertiesKHR_1(context, device, properties[0], errcode_ret) else
        ntv_CreateCommandQueueWithPropertiesKHR_1(context, device, PUInt64(nil)^, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateCommandQueueWithPropertiesKHR(context: cl_context; device: cl_device_id; var properties: UInt64; var errcode_ret: clErrorCode): cl_command_queue :=
      ntv_CreateCommandQueueWithPropertiesKHR_1(context, device, properties, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateCommandQueueWithPropertiesKHR(context: cl_context; device: cl_device_id; properties: IntPtr; var errcode_ret: clErrorCode): cl_command_queue :=
      ntv_CreateCommandQueueWithPropertiesKHR_2(context, device, properties, errcode_ret);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clD3d10SharingKHR = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clD3d10SharingKHR(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_khr_d3d10_sharing';
    
    public GetDeviceIDsFromD3D10KHR_adr := GetProcAddress('clGetDeviceIDsFromD3D10KHR');
    private ntv_GetDeviceIDsFromD3D10KHR_1 := GetProcOrNil&<function(platform: cl_platform_id; d3d_device_source: clD3D10DeviceSource; d3d_object: IntPtr; d3d_device_set: clD3D10DeviceSet; num_entries: UInt32; var devices: cl_device_id; var num_devices: UInt32): clErrorCode>(GetDeviceIDsFromD3D10KHR_adr);
    private ntv_GetDeviceIDsFromD3D10KHR_2 := GetProcOrNil&<function(platform: cl_platform_id; d3d_device_source: clD3D10DeviceSource; d3d_object: IntPtr; d3d_device_set: clD3D10DeviceSet; num_entries: UInt32; var devices: cl_device_id; num_devices: IntPtr): clErrorCode>(GetDeviceIDsFromD3D10KHR_adr);
    private ntv_GetDeviceIDsFromD3D10KHR_3 := GetProcOrNil&<function(platform: cl_platform_id; d3d_device_source: clD3D10DeviceSource; d3d_object: IntPtr; d3d_device_set: clD3D10DeviceSet; num_entries: UInt32; devices: IntPtr; var num_devices: UInt32): clErrorCode>(GetDeviceIDsFromD3D10KHR_adr);
    private ntv_GetDeviceIDsFromD3D10KHR_4 := GetProcOrNil&<function(platform: cl_platform_id; d3d_device_source: clD3D10DeviceSource; d3d_object: IntPtr; d3d_device_set: clD3D10DeviceSet; num_entries: UInt32; devices: IntPtr; num_devices: IntPtr): clErrorCode>(GetDeviceIDsFromD3D10KHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDeviceIDsFromD3D10KHR(platform: cl_platform_id; d3d_device_source: clD3D10DeviceSource; d3d_object: IntPtr; d3d_device_set: clD3D10DeviceSet; num_entries: UInt32; var devices: cl_device_id; var num_devices: UInt32): clErrorCode :=
      ntv_GetDeviceIDsFromD3D10KHR_1(platform, d3d_device_source, d3d_object, d3d_device_set, num_entries, devices, num_devices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDeviceIDsFromD3D10KHR(platform: cl_platform_id; d3d_device_source: clD3D10DeviceSource; d3d_object: IntPtr; d3d_device_set: clD3D10DeviceSet; num_entries: UInt32; var devices: cl_device_id; num_devices: IntPtr): clErrorCode :=
      ntv_GetDeviceIDsFromD3D10KHR_2(platform, d3d_device_source, d3d_object, d3d_device_set, num_entries, devices, num_devices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDeviceIDsFromD3D10KHR(platform: cl_platform_id; d3d_device_source: clD3D10DeviceSource; d3d_object: IntPtr; d3d_device_set: clD3D10DeviceSet; num_entries: UInt32; devices: IntPtr; var num_devices: UInt32): clErrorCode :=
      ntv_GetDeviceIDsFromD3D10KHR_3(platform, d3d_device_source, d3d_object, d3d_device_set, num_entries, devices, num_devices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDeviceIDsFromD3D10KHR(platform: cl_platform_id; d3d_device_source: clD3D10DeviceSource; d3d_object: IntPtr; d3d_device_set: clD3D10DeviceSet; num_entries: UInt32; devices: IntPtr; num_devices: IntPtr): clErrorCode :=
      ntv_GetDeviceIDsFromD3D10KHR_4(platform, d3d_device_source, d3d_object, d3d_device_set, num_entries, devices, num_devices);
    
    public CreateFromD3D10BufferKHR_adr := GetProcAddress('clCreateFromD3D10BufferKHR');
    private ntv_CreateFromD3D10BufferKHR_1 := GetProcOrNil&<function(context: cl_context; flags: clMemFlags; resource: d3d10_buffer; var errcode_ret: clErrorCode): cl_mem>(CreateFromD3D10BufferKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateFromD3D10BufferKHR(context: cl_context; flags: clMemFlags; resource: d3d10_buffer; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateFromD3D10BufferKHR_1(context, flags, resource, errcode_ret);
    
    public CreateFromD3D10Texture2DKHR_adr := GetProcAddress('clCreateFromD3D10Texture2DKHR');
    private ntv_CreateFromD3D10Texture2DKHR_1 := GetProcOrNil&<function(context: cl_context; flags: clMemFlags; resource: d3d10_texture_2d; subresource: UInt32; var errcode_ret: clErrorCode): cl_mem>(CreateFromD3D10Texture2DKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateFromD3D10Texture2DKHR(context: cl_context; flags: clMemFlags; resource: d3d10_texture_2d; subresource: UInt32; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateFromD3D10Texture2DKHR_1(context, flags, resource, subresource, errcode_ret);
    
    public CreateFromD3D10Texture3DKHR_adr := GetProcAddress('clCreateFromD3D10Texture3DKHR');
    private ntv_CreateFromD3D10Texture3DKHR_1 := GetProcOrNil&<function(context: cl_context; flags: clMemFlags; resource: d3d10_texture_3d; subresource: UInt32; var errcode_ret: clErrorCode): cl_mem>(CreateFromD3D10Texture3DKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateFromD3D10Texture3DKHR(context: cl_context; flags: clMemFlags; resource: d3d10_texture_3d; subresource: UInt32; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateFromD3D10Texture3DKHR_1(context, flags, resource, subresource, errcode_ret);
    
    public EnqueueAcquireD3D10ObjectsKHR_adr := GetProcAddress('clEnqueueAcquireD3D10ObjectsKHR');
    private ntv_EnqueueAcquireD3D10ObjectsKHR_1 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueAcquireD3D10ObjectsKHR_adr);
    private ntv_EnqueueAcquireD3D10ObjectsKHR_2 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueAcquireD3D10ObjectsKHR_adr);
    private ntv_EnqueueAcquireD3D10ObjectsKHR_3 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueAcquireD3D10ObjectsKHR_adr);
    private ntv_EnqueueAcquireD3D10ObjectsKHR_4 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueAcquireD3D10ObjectsKHR_adr);
    private ntv_EnqueueAcquireD3D10ObjectsKHR_5 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueAcquireD3D10ObjectsKHR_adr);
    private ntv_EnqueueAcquireD3D10ObjectsKHR_6 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueAcquireD3D10ObjectsKHR_adr);
    private ntv_EnqueueAcquireD3D10ObjectsKHR_7 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueAcquireD3D10ObjectsKHR_adr);
    private ntv_EnqueueAcquireD3D10ObjectsKHR_8 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueAcquireD3D10ObjectsKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireD3D10ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueAcquireD3D10ObjectsKHR(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueAcquireD3D10ObjectsKHR(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireD3D10ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueAcquireD3D10ObjectsKHR(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueAcquireD3D10ObjectsKHR(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireD3D10ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueAcquireD3D10ObjectsKHR_1(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueAcquireD3D10ObjectsKHR_1(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireD3D10ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueAcquireD3D10ObjectsKHR_2(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueAcquireD3D10ObjectsKHR_2(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireD3D10ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueAcquireD3D10ObjectsKHR_3(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueAcquireD3D10ObjectsKHR_3(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireD3D10ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueAcquireD3D10ObjectsKHR_4(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueAcquireD3D10ObjectsKHR_4(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireD3D10ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueAcquireD3D10ObjectsKHR_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueAcquireD3D10ObjectsKHR_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireD3D10ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueAcquireD3D10ObjectsKHR_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueAcquireD3D10ObjectsKHR_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireD3D10ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueAcquireD3D10ObjectsKHR_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireD3D10ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueAcquireD3D10ObjectsKHR_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireD3D10ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueAcquireD3D10ObjectsKHR_3(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireD3D10ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueAcquireD3D10ObjectsKHR_4(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireD3D10ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueAcquireD3D10ObjectsKHR_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueAcquireD3D10ObjectsKHR_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireD3D10ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueAcquireD3D10ObjectsKHR_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueAcquireD3D10ObjectsKHR_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireD3D10ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueAcquireD3D10ObjectsKHR_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireD3D10ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueAcquireD3D10ObjectsKHR_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireD3D10ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueAcquireD3D10ObjectsKHR_7(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireD3D10ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueAcquireD3D10ObjectsKHR_8(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    
    public EnqueueReleaseD3D10ObjectsKHR_adr := GetProcAddress('clEnqueueReleaseD3D10ObjectsKHR');
    private ntv_EnqueueReleaseD3D10ObjectsKHR_1 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueReleaseD3D10ObjectsKHR_adr);
    private ntv_EnqueueReleaseD3D10ObjectsKHR_2 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueReleaseD3D10ObjectsKHR_adr);
    private ntv_EnqueueReleaseD3D10ObjectsKHR_3 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueReleaseD3D10ObjectsKHR_adr);
    private ntv_EnqueueReleaseD3D10ObjectsKHR_4 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueReleaseD3D10ObjectsKHR_adr);
    private ntv_EnqueueReleaseD3D10ObjectsKHR_5 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueReleaseD3D10ObjectsKHR_adr);
    private ntv_EnqueueReleaseD3D10ObjectsKHR_6 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueReleaseD3D10ObjectsKHR_adr);
    private ntv_EnqueueReleaseD3D10ObjectsKHR_7 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueReleaseD3D10ObjectsKHR_adr);
    private ntv_EnqueueReleaseD3D10ObjectsKHR_8 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueReleaseD3D10ObjectsKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseD3D10ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueReleaseD3D10ObjectsKHR(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueReleaseD3D10ObjectsKHR(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseD3D10ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueReleaseD3D10ObjectsKHR(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueReleaseD3D10ObjectsKHR(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseD3D10ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueReleaseD3D10ObjectsKHR_1(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueReleaseD3D10ObjectsKHR_1(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseD3D10ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueReleaseD3D10ObjectsKHR_2(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueReleaseD3D10ObjectsKHR_2(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseD3D10ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueReleaseD3D10ObjectsKHR_3(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueReleaseD3D10ObjectsKHR_3(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseD3D10ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueReleaseD3D10ObjectsKHR_4(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueReleaseD3D10ObjectsKHR_4(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseD3D10ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReleaseD3D10ObjectsKHR_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReleaseD3D10ObjectsKHR_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseD3D10ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReleaseD3D10ObjectsKHR_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReleaseD3D10ObjectsKHR_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseD3D10ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReleaseD3D10ObjectsKHR_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseD3D10ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReleaseD3D10ObjectsKHR_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseD3D10ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReleaseD3D10ObjectsKHR_3(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseD3D10ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReleaseD3D10ObjectsKHR_4(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseD3D10ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReleaseD3D10ObjectsKHR_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReleaseD3D10ObjectsKHR_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseD3D10ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReleaseD3D10ObjectsKHR_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReleaseD3D10ObjectsKHR_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseD3D10ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReleaseD3D10ObjectsKHR_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseD3D10ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReleaseD3D10ObjectsKHR_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseD3D10ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReleaseD3D10ObjectsKHR_7(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseD3D10ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReleaseD3D10ObjectsKHR_8(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clD3d11SharingKHR = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clD3d11SharingKHR(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_khr_d3d11_sharing';
    
    public GetDeviceIDsFromD3D11KHR_adr := GetProcAddress('clGetDeviceIDsFromD3D11KHR');
    private ntv_GetDeviceIDsFromD3D11KHR_1 := GetProcOrNil&<function(platform: cl_platform_id; d3d_device_source: clD3D11DeviceSource; d3d_object: IntPtr; d3d_device_set: clD3D11DeviceSet; num_entries: UInt32; var devices: cl_device_id; var num_devices: UInt32): clErrorCode>(GetDeviceIDsFromD3D11KHR_adr);
    private ntv_GetDeviceIDsFromD3D11KHR_2 := GetProcOrNil&<function(platform: cl_platform_id; d3d_device_source: clD3D11DeviceSource; d3d_object: IntPtr; d3d_device_set: clD3D11DeviceSet; num_entries: UInt32; var devices: cl_device_id; num_devices: IntPtr): clErrorCode>(GetDeviceIDsFromD3D11KHR_adr);
    private ntv_GetDeviceIDsFromD3D11KHR_3 := GetProcOrNil&<function(platform: cl_platform_id; d3d_device_source: clD3D11DeviceSource; d3d_object: IntPtr; d3d_device_set: clD3D11DeviceSet; num_entries: UInt32; devices: IntPtr; var num_devices: UInt32): clErrorCode>(GetDeviceIDsFromD3D11KHR_adr);
    private ntv_GetDeviceIDsFromD3D11KHR_4 := GetProcOrNil&<function(platform: cl_platform_id; d3d_device_source: clD3D11DeviceSource; d3d_object: IntPtr; d3d_device_set: clD3D11DeviceSet; num_entries: UInt32; devices: IntPtr; num_devices: IntPtr): clErrorCode>(GetDeviceIDsFromD3D11KHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDeviceIDsFromD3D11KHR(platform: cl_platform_id; d3d_device_source: clD3D11DeviceSource; d3d_object: IntPtr; d3d_device_set: clD3D11DeviceSet; num_entries: UInt32; var devices: cl_device_id; var num_devices: UInt32): clErrorCode :=
      ntv_GetDeviceIDsFromD3D11KHR_1(platform, d3d_device_source, d3d_object, d3d_device_set, num_entries, devices, num_devices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDeviceIDsFromD3D11KHR(platform: cl_platform_id; d3d_device_source: clD3D11DeviceSource; d3d_object: IntPtr; d3d_device_set: clD3D11DeviceSet; num_entries: UInt32; var devices: cl_device_id; num_devices: IntPtr): clErrorCode :=
      ntv_GetDeviceIDsFromD3D11KHR_2(platform, d3d_device_source, d3d_object, d3d_device_set, num_entries, devices, num_devices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDeviceIDsFromD3D11KHR(platform: cl_platform_id; d3d_device_source: clD3D11DeviceSource; d3d_object: IntPtr; d3d_device_set: clD3D11DeviceSet; num_entries: UInt32; devices: IntPtr; var num_devices: UInt32): clErrorCode :=
      ntv_GetDeviceIDsFromD3D11KHR_3(platform, d3d_device_source, d3d_object, d3d_device_set, num_entries, devices, num_devices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDeviceIDsFromD3D11KHR(platform: cl_platform_id; d3d_device_source: clD3D11DeviceSource; d3d_object: IntPtr; d3d_device_set: clD3D11DeviceSet; num_entries: UInt32; devices: IntPtr; num_devices: IntPtr): clErrorCode :=
      ntv_GetDeviceIDsFromD3D11KHR_4(platform, d3d_device_source, d3d_object, d3d_device_set, num_entries, devices, num_devices);
    
    public CreateFromD3D11BufferKHR_adr := GetProcAddress('clCreateFromD3D11BufferKHR');
    private ntv_CreateFromD3D11BufferKHR_1 := GetProcOrNil&<function(context: cl_context; flags: clMemFlags; resource: d3d11_buffer; var errcode_ret: clErrorCode): cl_mem>(CreateFromD3D11BufferKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateFromD3D11BufferKHR(context: cl_context; flags: clMemFlags; resource: d3d11_buffer; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateFromD3D11BufferKHR_1(context, flags, resource, errcode_ret);
    
    public CreateFromD3D11Texture2DKHR_adr := GetProcAddress('clCreateFromD3D11Texture2DKHR');
    private ntv_CreateFromD3D11Texture2DKHR_1 := GetProcOrNil&<function(context: cl_context; flags: clMemFlags; resource: d3d11_texture_2d; subresource: UInt32; var errcode_ret: clErrorCode): cl_mem>(CreateFromD3D11Texture2DKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateFromD3D11Texture2DKHR(context: cl_context; flags: clMemFlags; resource: d3d11_texture_2d; subresource: UInt32; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateFromD3D11Texture2DKHR_1(context, flags, resource, subresource, errcode_ret);
    
    public CreateFromD3D11Texture3DKHR_adr := GetProcAddress('clCreateFromD3D11Texture3DKHR');
    private ntv_CreateFromD3D11Texture3DKHR_1 := GetProcOrNil&<function(context: cl_context; flags: clMemFlags; resource: d3d11_texture_3d; subresource: UInt32; var errcode_ret: clErrorCode): cl_mem>(CreateFromD3D11Texture3DKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateFromD3D11Texture3DKHR(context: cl_context; flags: clMemFlags; resource: d3d11_texture_3d; subresource: UInt32; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateFromD3D11Texture3DKHR_1(context, flags, resource, subresource, errcode_ret);
    
    public EnqueueAcquireD3D11ObjectsKHR_adr := GetProcAddress('clEnqueueAcquireD3D11ObjectsKHR');
    private ntv_EnqueueAcquireD3D11ObjectsKHR_1 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueAcquireD3D11ObjectsKHR_adr);
    private ntv_EnqueueAcquireD3D11ObjectsKHR_2 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueAcquireD3D11ObjectsKHR_adr);
    private ntv_EnqueueAcquireD3D11ObjectsKHR_3 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueAcquireD3D11ObjectsKHR_adr);
    private ntv_EnqueueAcquireD3D11ObjectsKHR_4 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueAcquireD3D11ObjectsKHR_adr);
    private ntv_EnqueueAcquireD3D11ObjectsKHR_5 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueAcquireD3D11ObjectsKHR_adr);
    private ntv_EnqueueAcquireD3D11ObjectsKHR_6 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueAcquireD3D11ObjectsKHR_adr);
    private ntv_EnqueueAcquireD3D11ObjectsKHR_7 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueAcquireD3D11ObjectsKHR_adr);
    private ntv_EnqueueAcquireD3D11ObjectsKHR_8 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueAcquireD3D11ObjectsKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireD3D11ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueAcquireD3D11ObjectsKHR(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueAcquireD3D11ObjectsKHR(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireD3D11ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueAcquireD3D11ObjectsKHR(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueAcquireD3D11ObjectsKHR(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireD3D11ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueAcquireD3D11ObjectsKHR_1(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueAcquireD3D11ObjectsKHR_1(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireD3D11ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueAcquireD3D11ObjectsKHR_2(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueAcquireD3D11ObjectsKHR_2(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireD3D11ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueAcquireD3D11ObjectsKHR_3(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueAcquireD3D11ObjectsKHR_3(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireD3D11ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueAcquireD3D11ObjectsKHR_4(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueAcquireD3D11ObjectsKHR_4(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireD3D11ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueAcquireD3D11ObjectsKHR_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueAcquireD3D11ObjectsKHR_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireD3D11ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueAcquireD3D11ObjectsKHR_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueAcquireD3D11ObjectsKHR_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireD3D11ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueAcquireD3D11ObjectsKHR_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireD3D11ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueAcquireD3D11ObjectsKHR_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireD3D11ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueAcquireD3D11ObjectsKHR_3(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireD3D11ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueAcquireD3D11ObjectsKHR_4(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireD3D11ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueAcquireD3D11ObjectsKHR_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueAcquireD3D11ObjectsKHR_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireD3D11ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueAcquireD3D11ObjectsKHR_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueAcquireD3D11ObjectsKHR_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireD3D11ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueAcquireD3D11ObjectsKHR_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireD3D11ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueAcquireD3D11ObjectsKHR_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireD3D11ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueAcquireD3D11ObjectsKHR_7(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireD3D11ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueAcquireD3D11ObjectsKHR_8(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    
    public EnqueueReleaseD3D11ObjectsKHR_adr := GetProcAddress('clEnqueueReleaseD3D11ObjectsKHR');
    private ntv_EnqueueReleaseD3D11ObjectsKHR_1 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueReleaseD3D11ObjectsKHR_adr);
    private ntv_EnqueueReleaseD3D11ObjectsKHR_2 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueReleaseD3D11ObjectsKHR_adr);
    private ntv_EnqueueReleaseD3D11ObjectsKHR_3 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueReleaseD3D11ObjectsKHR_adr);
    private ntv_EnqueueReleaseD3D11ObjectsKHR_4 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueReleaseD3D11ObjectsKHR_adr);
    private ntv_EnqueueReleaseD3D11ObjectsKHR_5 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueReleaseD3D11ObjectsKHR_adr);
    private ntv_EnqueueReleaseD3D11ObjectsKHR_6 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueReleaseD3D11ObjectsKHR_adr);
    private ntv_EnqueueReleaseD3D11ObjectsKHR_7 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueReleaseD3D11ObjectsKHR_adr);
    private ntv_EnqueueReleaseD3D11ObjectsKHR_8 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueReleaseD3D11ObjectsKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseD3D11ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueReleaseD3D11ObjectsKHR(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueReleaseD3D11ObjectsKHR(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseD3D11ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueReleaseD3D11ObjectsKHR(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueReleaseD3D11ObjectsKHR(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseD3D11ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueReleaseD3D11ObjectsKHR_1(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueReleaseD3D11ObjectsKHR_1(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseD3D11ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueReleaseD3D11ObjectsKHR_2(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueReleaseD3D11ObjectsKHR_2(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseD3D11ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueReleaseD3D11ObjectsKHR_3(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueReleaseD3D11ObjectsKHR_3(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseD3D11ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueReleaseD3D11ObjectsKHR_4(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueReleaseD3D11ObjectsKHR_4(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseD3D11ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReleaseD3D11ObjectsKHR_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReleaseD3D11ObjectsKHR_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseD3D11ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReleaseD3D11ObjectsKHR_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReleaseD3D11ObjectsKHR_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseD3D11ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReleaseD3D11ObjectsKHR_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseD3D11ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReleaseD3D11ObjectsKHR_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseD3D11ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReleaseD3D11ObjectsKHR_3(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseD3D11ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReleaseD3D11ObjectsKHR_4(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseD3D11ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReleaseD3D11ObjectsKHR_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReleaseD3D11ObjectsKHR_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseD3D11ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReleaseD3D11ObjectsKHR_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReleaseD3D11ObjectsKHR_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseD3D11ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReleaseD3D11ObjectsKHR_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseD3D11ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReleaseD3D11ObjectsKHR_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseD3D11ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReleaseD3D11ObjectsKHR_7(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseD3D11ObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReleaseD3D11ObjectsKHR_8(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    
  end;
  
  ///
  clDepthImagesKHR = static class
    public const ExtensionString = 'cl_khr_depth_images';
  end;
  
  ///
  clDeviceUuidKHR = static class
    public const ExtensionString = 'cl_khr_device_uuid';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clDx9MediaSharingKHR = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clDx9MediaSharingKHR(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_khr_dx9_media_sharing';
    
    public GetDeviceIDsFromDX9MediaAdapterKHR_adr := GetProcAddress('clGetDeviceIDsFromDX9MediaAdapterKHR');
    private ntv_GetDeviceIDsFromDX9MediaAdapterKHR_1 := GetProcOrNil&<function(platform: cl_platform_id; num_media_adapters: UInt32; var media_adapter_type: clDx9MediaAdapterType; media_adapters: IntPtr; media_adapter_set: clDx9MediaAdapterSet; num_entries: UInt32; var devices: cl_device_id; var num_devices: UInt32): clErrorCode>(GetDeviceIDsFromDX9MediaAdapterKHR_adr);
    private ntv_GetDeviceIDsFromDX9MediaAdapterKHR_2 := GetProcOrNil&<function(platform: cl_platform_id; num_media_adapters: UInt32; var media_adapter_type: clDx9MediaAdapterType; media_adapters: IntPtr; media_adapter_set: clDx9MediaAdapterSet; num_entries: UInt32; var devices: cl_device_id; num_devices: IntPtr): clErrorCode>(GetDeviceIDsFromDX9MediaAdapterKHR_adr);
    private ntv_GetDeviceIDsFromDX9MediaAdapterKHR_3 := GetProcOrNil&<function(platform: cl_platform_id; num_media_adapters: UInt32; var media_adapter_type: clDx9MediaAdapterType; media_adapters: IntPtr; media_adapter_set: clDx9MediaAdapterSet; num_entries: UInt32; devices: IntPtr; var num_devices: UInt32): clErrorCode>(GetDeviceIDsFromDX9MediaAdapterKHR_adr);
    private ntv_GetDeviceIDsFromDX9MediaAdapterKHR_4 := GetProcOrNil&<function(platform: cl_platform_id; num_media_adapters: UInt32; var media_adapter_type: clDx9MediaAdapterType; media_adapters: IntPtr; media_adapter_set: clDx9MediaAdapterSet; num_entries: UInt32; devices: IntPtr; num_devices: IntPtr): clErrorCode>(GetDeviceIDsFromDX9MediaAdapterKHR_adr);
    private ntv_GetDeviceIDsFromDX9MediaAdapterKHR_5 := GetProcOrNil&<function(platform: cl_platform_id; num_media_adapters: UInt32; media_adapter_type: IntPtr; media_adapters: IntPtr; media_adapter_set: clDx9MediaAdapterSet; num_entries: UInt32; var devices: cl_device_id; var num_devices: UInt32): clErrorCode>(GetDeviceIDsFromDX9MediaAdapterKHR_adr);
    private ntv_GetDeviceIDsFromDX9MediaAdapterKHR_6 := GetProcOrNil&<function(platform: cl_platform_id; num_media_adapters: UInt32; media_adapter_type: IntPtr; media_adapters: IntPtr; media_adapter_set: clDx9MediaAdapterSet; num_entries: UInt32; var devices: cl_device_id; num_devices: IntPtr): clErrorCode>(GetDeviceIDsFromDX9MediaAdapterKHR_adr);
    private ntv_GetDeviceIDsFromDX9MediaAdapterKHR_7 := GetProcOrNil&<function(platform: cl_platform_id; num_media_adapters: UInt32; media_adapter_type: IntPtr; media_adapters: IntPtr; media_adapter_set: clDx9MediaAdapterSet; num_entries: UInt32; devices: IntPtr; var num_devices: UInt32): clErrorCode>(GetDeviceIDsFromDX9MediaAdapterKHR_adr);
    private ntv_GetDeviceIDsFromDX9MediaAdapterKHR_8 := GetProcOrNil&<function(platform: cl_platform_id; num_media_adapters: UInt32; media_adapter_type: IntPtr; media_adapters: IntPtr; media_adapter_set: clDx9MediaAdapterSet; num_entries: UInt32; devices: IntPtr; num_devices: IntPtr): clErrorCode>(GetDeviceIDsFromDX9MediaAdapterKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDeviceIDsFromDX9MediaAdapterKHR(platform: cl_platform_id; num_media_adapters: UInt32; var media_adapter_type: clDx9MediaAdapterType; media_adapters: IntPtr; media_adapter_set: clDx9MediaAdapterSet; num_entries: UInt32; var devices: cl_device_id; var num_devices: UInt32): clErrorCode :=
      ntv_GetDeviceIDsFromDX9MediaAdapterKHR_1(platform, num_media_adapters, media_adapter_type, media_adapters, media_adapter_set, num_entries, devices, num_devices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDeviceIDsFromDX9MediaAdapterKHR(platform: cl_platform_id; num_media_adapters: UInt32; var media_adapter_type: clDx9MediaAdapterType; media_adapters: IntPtr; media_adapter_set: clDx9MediaAdapterSet; num_entries: UInt32; var devices: cl_device_id; num_devices: IntPtr): clErrorCode :=
      ntv_GetDeviceIDsFromDX9MediaAdapterKHR_2(platform, num_media_adapters, media_adapter_type, media_adapters, media_adapter_set, num_entries, devices, num_devices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDeviceIDsFromDX9MediaAdapterKHR(platform: cl_platform_id; num_media_adapters: UInt32; var media_adapter_type: clDx9MediaAdapterType; media_adapters: IntPtr; media_adapter_set: clDx9MediaAdapterSet; num_entries: UInt32; devices: IntPtr; var num_devices: UInt32): clErrorCode :=
      ntv_GetDeviceIDsFromDX9MediaAdapterKHR_3(platform, num_media_adapters, media_adapter_type, media_adapters, media_adapter_set, num_entries, devices, num_devices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDeviceIDsFromDX9MediaAdapterKHR(platform: cl_platform_id; num_media_adapters: UInt32; var media_adapter_type: clDx9MediaAdapterType; media_adapters: IntPtr; media_adapter_set: clDx9MediaAdapterSet; num_entries: UInt32; devices: IntPtr; num_devices: IntPtr): clErrorCode :=
      ntv_GetDeviceIDsFromDX9MediaAdapterKHR_4(platform, num_media_adapters, media_adapter_type, media_adapters, media_adapter_set, num_entries, devices, num_devices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDeviceIDsFromDX9MediaAdapterKHR(platform: cl_platform_id; num_media_adapters: UInt32; media_adapter_type: IntPtr; media_adapters: IntPtr; media_adapter_set: clDx9MediaAdapterSet; num_entries: UInt32; var devices: cl_device_id; var num_devices: UInt32): clErrorCode :=
      ntv_GetDeviceIDsFromDX9MediaAdapterKHR_5(platform, num_media_adapters, media_adapter_type, media_adapters, media_adapter_set, num_entries, devices, num_devices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDeviceIDsFromDX9MediaAdapterKHR(platform: cl_platform_id; num_media_adapters: UInt32; media_adapter_type: IntPtr; media_adapters: IntPtr; media_adapter_set: clDx9MediaAdapterSet; num_entries: UInt32; var devices: cl_device_id; num_devices: IntPtr): clErrorCode :=
      ntv_GetDeviceIDsFromDX9MediaAdapterKHR_6(platform, num_media_adapters, media_adapter_type, media_adapters, media_adapter_set, num_entries, devices, num_devices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDeviceIDsFromDX9MediaAdapterKHR(platform: cl_platform_id; num_media_adapters: UInt32; media_adapter_type: IntPtr; media_adapters: IntPtr; media_adapter_set: clDx9MediaAdapterSet; num_entries: UInt32; devices: IntPtr; var num_devices: UInt32): clErrorCode :=
      ntv_GetDeviceIDsFromDX9MediaAdapterKHR_7(platform, num_media_adapters, media_adapter_type, media_adapters, media_adapter_set, num_entries, devices, num_devices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDeviceIDsFromDX9MediaAdapterKHR(platform: cl_platform_id; num_media_adapters: UInt32; media_adapter_type: IntPtr; media_adapters: IntPtr; media_adapter_set: clDx9MediaAdapterSet; num_entries: UInt32; devices: IntPtr; num_devices: IntPtr): clErrorCode :=
      ntv_GetDeviceIDsFromDX9MediaAdapterKHR_8(platform, num_media_adapters, media_adapter_type, media_adapters, media_adapter_set, num_entries, devices, num_devices);
    
    public CreateFromDX9MediaSurfaceKHR_adr := GetProcAddress('clCreateFromDX9MediaSurfaceKHR');
    private ntv_CreateFromDX9MediaSurfaceKHR_1 := GetProcOrNil&<function(context: cl_context; flags: clMemFlags; adapter_type: clDx9MediaAdapterType; surface_info: IntPtr; plane: UInt32; var errcode_ret: clErrorCode): cl_mem>(CreateFromDX9MediaSurfaceKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateFromDX9MediaSurfaceKHR(context: cl_context; flags: clMemFlags; adapter_type: clDx9MediaAdapterType; surface_info: IntPtr; plane: UInt32; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateFromDX9MediaSurfaceKHR_1(context, flags, adapter_type, surface_info, plane, errcode_ret);
    
    public EnqueueAcquireDX9MediaSurfacesKHR_adr := GetProcAddress('clEnqueueAcquireDX9MediaSurfacesKHR');
    private ntv_EnqueueAcquireDX9MediaSurfacesKHR_1 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueAcquireDX9MediaSurfacesKHR_adr);
    private ntv_EnqueueAcquireDX9MediaSurfacesKHR_2 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueAcquireDX9MediaSurfacesKHR_adr);
    private ntv_EnqueueAcquireDX9MediaSurfacesKHR_3 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueAcquireDX9MediaSurfacesKHR_adr);
    private ntv_EnqueueAcquireDX9MediaSurfacesKHR_4 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueAcquireDX9MediaSurfacesKHR_adr);
    private ntv_EnqueueAcquireDX9MediaSurfacesKHR_5 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueAcquireDX9MediaSurfacesKHR_adr);
    private ntv_EnqueueAcquireDX9MediaSurfacesKHR_6 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueAcquireDX9MediaSurfacesKHR_adr);
    private ntv_EnqueueAcquireDX9MediaSurfacesKHR_7 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueAcquireDX9MediaSurfacesKHR_adr);
    private ntv_EnqueueAcquireDX9MediaSurfacesKHR_8 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueAcquireDX9MediaSurfacesKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireDX9MediaSurfacesKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueAcquireDX9MediaSurfacesKHR(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueAcquireDX9MediaSurfacesKHR(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireDX9MediaSurfacesKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueAcquireDX9MediaSurfacesKHR(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueAcquireDX9MediaSurfacesKHR(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireDX9MediaSurfacesKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueAcquireDX9MediaSurfacesKHR_1(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueAcquireDX9MediaSurfacesKHR_1(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireDX9MediaSurfacesKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueAcquireDX9MediaSurfacesKHR_2(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueAcquireDX9MediaSurfacesKHR_2(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireDX9MediaSurfacesKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueAcquireDX9MediaSurfacesKHR_3(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueAcquireDX9MediaSurfacesKHR_3(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireDX9MediaSurfacesKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueAcquireDX9MediaSurfacesKHR_4(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueAcquireDX9MediaSurfacesKHR_4(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireDX9MediaSurfacesKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueAcquireDX9MediaSurfacesKHR_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueAcquireDX9MediaSurfacesKHR_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireDX9MediaSurfacesKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueAcquireDX9MediaSurfacesKHR_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueAcquireDX9MediaSurfacesKHR_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireDX9MediaSurfacesKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueAcquireDX9MediaSurfacesKHR_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireDX9MediaSurfacesKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueAcquireDX9MediaSurfacesKHR_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireDX9MediaSurfacesKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueAcquireDX9MediaSurfacesKHR_3(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireDX9MediaSurfacesKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueAcquireDX9MediaSurfacesKHR_4(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireDX9MediaSurfacesKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueAcquireDX9MediaSurfacesKHR_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueAcquireDX9MediaSurfacesKHR_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireDX9MediaSurfacesKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueAcquireDX9MediaSurfacesKHR_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueAcquireDX9MediaSurfacesKHR_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireDX9MediaSurfacesKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueAcquireDX9MediaSurfacesKHR_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireDX9MediaSurfacesKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueAcquireDX9MediaSurfacesKHR_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireDX9MediaSurfacesKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueAcquireDX9MediaSurfacesKHR_7(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireDX9MediaSurfacesKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueAcquireDX9MediaSurfacesKHR_8(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    
    public EnqueueReleaseDX9MediaSurfacesKHR_adr := GetProcAddress('clEnqueueReleaseDX9MediaSurfacesKHR');
    private ntv_EnqueueReleaseDX9MediaSurfacesKHR_1 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueReleaseDX9MediaSurfacesKHR_adr);
    private ntv_EnqueueReleaseDX9MediaSurfacesKHR_2 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueReleaseDX9MediaSurfacesKHR_adr);
    private ntv_EnqueueReleaseDX9MediaSurfacesKHR_3 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueReleaseDX9MediaSurfacesKHR_adr);
    private ntv_EnqueueReleaseDX9MediaSurfacesKHR_4 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueReleaseDX9MediaSurfacesKHR_adr);
    private ntv_EnqueueReleaseDX9MediaSurfacesKHR_5 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueReleaseDX9MediaSurfacesKHR_adr);
    private ntv_EnqueueReleaseDX9MediaSurfacesKHR_6 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueReleaseDX9MediaSurfacesKHR_adr);
    private ntv_EnqueueReleaseDX9MediaSurfacesKHR_7 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueReleaseDX9MediaSurfacesKHR_adr);
    private ntv_EnqueueReleaseDX9MediaSurfacesKHR_8 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueReleaseDX9MediaSurfacesKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseDX9MediaSurfacesKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueReleaseDX9MediaSurfacesKHR(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueReleaseDX9MediaSurfacesKHR(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseDX9MediaSurfacesKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueReleaseDX9MediaSurfacesKHR(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueReleaseDX9MediaSurfacesKHR(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseDX9MediaSurfacesKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueReleaseDX9MediaSurfacesKHR_1(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueReleaseDX9MediaSurfacesKHR_1(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseDX9MediaSurfacesKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueReleaseDX9MediaSurfacesKHR_2(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueReleaseDX9MediaSurfacesKHR_2(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseDX9MediaSurfacesKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueReleaseDX9MediaSurfacesKHR_3(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueReleaseDX9MediaSurfacesKHR_3(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseDX9MediaSurfacesKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueReleaseDX9MediaSurfacesKHR_4(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueReleaseDX9MediaSurfacesKHR_4(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseDX9MediaSurfacesKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReleaseDX9MediaSurfacesKHR_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReleaseDX9MediaSurfacesKHR_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseDX9MediaSurfacesKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReleaseDX9MediaSurfacesKHR_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReleaseDX9MediaSurfacesKHR_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseDX9MediaSurfacesKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReleaseDX9MediaSurfacesKHR_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseDX9MediaSurfacesKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReleaseDX9MediaSurfacesKHR_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseDX9MediaSurfacesKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReleaseDX9MediaSurfacesKHR_3(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseDX9MediaSurfacesKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReleaseDX9MediaSurfacesKHR_4(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseDX9MediaSurfacesKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReleaseDX9MediaSurfacesKHR_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReleaseDX9MediaSurfacesKHR_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseDX9MediaSurfacesKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReleaseDX9MediaSurfacesKHR_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReleaseDX9MediaSurfacesKHR_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseDX9MediaSurfacesKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReleaseDX9MediaSurfacesKHR_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseDX9MediaSurfacesKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReleaseDX9MediaSurfacesKHR_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseDX9MediaSurfacesKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReleaseDX9MediaSurfacesKHR_7(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseDX9MediaSurfacesKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReleaseDX9MediaSurfacesKHR_8(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clEglEventKHR = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clEglEventKHR(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_khr_egl_event';
    
    public CreateEventFromEGLSyncKHR_adr := GetProcAddress('clCreateEventFromEGLSyncKHR');
    private ntv_CreateEventFromEGLSyncKHR_1 := GetProcOrNil&<function(context: cl_context; sync: cl_eglSync; display: cl_eglDisplay; var errcode_ret: clErrorCode): cl_event>(CreateEventFromEGLSyncKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateEventFromEGLSyncKHR(context: cl_context; sync: cl_eglSync; display: cl_eglDisplay; var errcode_ret: clErrorCode): cl_event :=
      ntv_CreateEventFromEGLSyncKHR_1(context, sync, display, errcode_ret);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clEglImageKHR = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clEglImageKHR(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_khr_egl_image';
    
    public CreateFromEGLImageKHR_adr := GetProcAddress('clCreateFromEGLImageKHR');
    private ntv_CreateFromEGLImageKHR_1 := GetProcOrNil&<function(context: cl_context; egldisplay: cl_eglDisplay; eglimage: cl_eglImage; flags: clMemFlags; var properties: clEglImageProperties; var errcode_ret: clErrorCode): cl_mem>(CreateFromEGLImageKHR_adr);
    private ntv_CreateFromEGLImageKHR_2 := GetProcOrNil&<function(context: cl_context; egldisplay: cl_eglDisplay; eglimage: cl_eglImage; flags: clMemFlags; properties: IntPtr; var errcode_ret: clErrorCode): cl_mem>(CreateFromEGLImageKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateFromEGLImageKHR(context: cl_context; egldisplay: cl_eglDisplay; eglimage: cl_eglImage; flags: clMemFlags; properties: array of clEglImageProperties; var errcode_ret: clErrorCode): cl_mem;
    type PClEglImageProperties = ^clEglImageProperties;
    begin
      Result := if (properties<>nil) and (properties.Length<>0) then
        ntv_CreateFromEGLImageKHR_1(context, egldisplay, eglimage, flags, properties[0], errcode_ret) else
        ntv_CreateFromEGLImageKHR_1(context, egldisplay, eglimage, flags, PClEglImageProperties(nil)^, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateFromEGLImageKHR(context: cl_context; egldisplay: cl_eglDisplay; eglimage: cl_eglImage; flags: clMemFlags; var properties: clEglImageProperties; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateFromEGLImageKHR_1(context, egldisplay, eglimage, flags, properties, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateFromEGLImageKHR(context: cl_context; egldisplay: cl_eglDisplay; eglimage: cl_eglImage; flags: clMemFlags; properties: IntPtr; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateFromEGLImageKHR_2(context, egldisplay, eglimage, flags, properties, errcode_ret);
    
    public EnqueueAcquireEGLObjectsKHR_adr := GetProcAddress('clEnqueueAcquireEGLObjectsKHR');
    private ntv_EnqueueAcquireEGLObjectsKHR_1 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueAcquireEGLObjectsKHR_adr);
    private ntv_EnqueueAcquireEGLObjectsKHR_2 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueAcquireEGLObjectsKHR_adr);
    private ntv_EnqueueAcquireEGLObjectsKHR_3 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueAcquireEGLObjectsKHR_adr);
    private ntv_EnqueueAcquireEGLObjectsKHR_4 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueAcquireEGLObjectsKHR_adr);
    private ntv_EnqueueAcquireEGLObjectsKHR_5 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueAcquireEGLObjectsKHR_adr);
    private ntv_EnqueueAcquireEGLObjectsKHR_6 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueAcquireEGLObjectsKHR_adr);
    private ntv_EnqueueAcquireEGLObjectsKHR_7 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueAcquireEGLObjectsKHR_adr);
    private ntv_EnqueueAcquireEGLObjectsKHR_8 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueAcquireEGLObjectsKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireEGLObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueAcquireEGLObjectsKHR(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueAcquireEGLObjectsKHR(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireEGLObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueAcquireEGLObjectsKHR(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueAcquireEGLObjectsKHR(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireEGLObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueAcquireEGLObjectsKHR_1(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueAcquireEGLObjectsKHR_1(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireEGLObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueAcquireEGLObjectsKHR_2(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueAcquireEGLObjectsKHR_2(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireEGLObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueAcquireEGLObjectsKHR_3(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueAcquireEGLObjectsKHR_3(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireEGLObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueAcquireEGLObjectsKHR_4(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueAcquireEGLObjectsKHR_4(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireEGLObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueAcquireEGLObjectsKHR_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueAcquireEGLObjectsKHR_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireEGLObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueAcquireEGLObjectsKHR_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueAcquireEGLObjectsKHR_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireEGLObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueAcquireEGLObjectsKHR_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireEGLObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueAcquireEGLObjectsKHR_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireEGLObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueAcquireEGLObjectsKHR_3(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireEGLObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueAcquireEGLObjectsKHR_4(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireEGLObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueAcquireEGLObjectsKHR_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueAcquireEGLObjectsKHR_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireEGLObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueAcquireEGLObjectsKHR_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueAcquireEGLObjectsKHR_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireEGLObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueAcquireEGLObjectsKHR_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireEGLObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueAcquireEGLObjectsKHR_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireEGLObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueAcquireEGLObjectsKHR_7(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireEGLObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueAcquireEGLObjectsKHR_8(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    
    public EnqueueReleaseEGLObjectsKHR_adr := GetProcAddress('clEnqueueReleaseEGLObjectsKHR');
    private ntv_EnqueueReleaseEGLObjectsKHR_1 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueReleaseEGLObjectsKHR_adr);
    private ntv_EnqueueReleaseEGLObjectsKHR_2 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueReleaseEGLObjectsKHR_adr);
    private ntv_EnqueueReleaseEGLObjectsKHR_3 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueReleaseEGLObjectsKHR_adr);
    private ntv_EnqueueReleaseEGLObjectsKHR_4 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueReleaseEGLObjectsKHR_adr);
    private ntv_EnqueueReleaseEGLObjectsKHR_5 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueReleaseEGLObjectsKHR_adr);
    private ntv_EnqueueReleaseEGLObjectsKHR_6 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueReleaseEGLObjectsKHR_adr);
    private ntv_EnqueueReleaseEGLObjectsKHR_7 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueReleaseEGLObjectsKHR_adr);
    private ntv_EnqueueReleaseEGLObjectsKHR_8 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueReleaseEGLObjectsKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseEGLObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueReleaseEGLObjectsKHR(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueReleaseEGLObjectsKHR(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseEGLObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueReleaseEGLObjectsKHR(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueReleaseEGLObjectsKHR(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseEGLObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueReleaseEGLObjectsKHR_1(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueReleaseEGLObjectsKHR_1(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseEGLObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueReleaseEGLObjectsKHR_2(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueReleaseEGLObjectsKHR_2(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseEGLObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueReleaseEGLObjectsKHR_3(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueReleaseEGLObjectsKHR_3(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseEGLObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueReleaseEGLObjectsKHR_4(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueReleaseEGLObjectsKHR_4(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseEGLObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReleaseEGLObjectsKHR_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReleaseEGLObjectsKHR_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseEGLObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReleaseEGLObjectsKHR_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReleaseEGLObjectsKHR_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseEGLObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReleaseEGLObjectsKHR_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseEGLObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReleaseEGLObjectsKHR_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseEGLObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReleaseEGLObjectsKHR_3(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseEGLObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReleaseEGLObjectsKHR_4(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseEGLObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReleaseEGLObjectsKHR_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReleaseEGLObjectsKHR_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseEGLObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReleaseEGLObjectsKHR_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReleaseEGLObjectsKHR_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseEGLObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReleaseEGLObjectsKHR_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseEGLObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReleaseEGLObjectsKHR_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseEGLObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReleaseEGLObjectsKHR_7(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseEGLObjectsKHR(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReleaseEGLObjectsKHR_8(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    
  end;
  
  ///
  clExtendedVersioningKHR = static class
    public const ExtensionString = 'cl_khr_extended_versioning';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clExternalMemoryKHR = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clExternalMemoryKHR(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_khr_external_memory';
    
    public EnqueueAcquireExternalMemObjectsKHR_adr := GetProcAddress('clEnqueueAcquireExternalMemObjectsKHR');
    private ntv_EnqueueAcquireExternalMemObjectsKHR_1 := GetProcOrNil&<function(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueAcquireExternalMemObjectsKHR_adr);
    private ntv_EnqueueAcquireExternalMemObjectsKHR_2 := GetProcOrNil&<function(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueAcquireExternalMemObjectsKHR_adr);
    private ntv_EnqueueAcquireExternalMemObjectsKHR_3 := GetProcOrNil&<function(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueAcquireExternalMemObjectsKHR_adr);
    private ntv_EnqueueAcquireExternalMemObjectsKHR_4 := GetProcOrNil&<function(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueAcquireExternalMemObjectsKHR_adr);
    private ntv_EnqueueAcquireExternalMemObjectsKHR_5 := GetProcOrNil&<function(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueAcquireExternalMemObjectsKHR_adr);
    private ntv_EnqueueAcquireExternalMemObjectsKHR_6 := GetProcOrNil&<function(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueAcquireExternalMemObjectsKHR_adr);
    private ntv_EnqueueAcquireExternalMemObjectsKHR_7 := GetProcOrNil&<function(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueAcquireExternalMemObjectsKHR_adr);
    private ntv_EnqueueAcquireExternalMemObjectsKHR_8 := GetProcOrNil&<function(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueAcquireExternalMemObjectsKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireExternalMemObjectsKHR(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueAcquireExternalMemObjectsKHR(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueAcquireExternalMemObjectsKHR(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireExternalMemObjectsKHR(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueAcquireExternalMemObjectsKHR(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueAcquireExternalMemObjectsKHR(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireExternalMemObjectsKHR(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueAcquireExternalMemObjectsKHR_1(command_queue, num_mem_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueAcquireExternalMemObjectsKHR_1(command_queue, num_mem_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireExternalMemObjectsKHR(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueAcquireExternalMemObjectsKHR_2(command_queue, num_mem_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueAcquireExternalMemObjectsKHR_2(command_queue, num_mem_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireExternalMemObjectsKHR(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueAcquireExternalMemObjectsKHR_3(command_queue, num_mem_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueAcquireExternalMemObjectsKHR_3(command_queue, num_mem_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireExternalMemObjectsKHR(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueAcquireExternalMemObjectsKHR_4(command_queue, num_mem_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueAcquireExternalMemObjectsKHR_4(command_queue, num_mem_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireExternalMemObjectsKHR(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueAcquireExternalMemObjectsKHR_1(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueAcquireExternalMemObjectsKHR_1(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireExternalMemObjectsKHR(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueAcquireExternalMemObjectsKHR_2(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueAcquireExternalMemObjectsKHR_2(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireExternalMemObjectsKHR(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueAcquireExternalMemObjectsKHR_1(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireExternalMemObjectsKHR(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueAcquireExternalMemObjectsKHR_2(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireExternalMemObjectsKHR(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueAcquireExternalMemObjectsKHR_3(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireExternalMemObjectsKHR(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueAcquireExternalMemObjectsKHR_4(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireExternalMemObjectsKHR(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueAcquireExternalMemObjectsKHR_5(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueAcquireExternalMemObjectsKHR_5(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireExternalMemObjectsKHR(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueAcquireExternalMemObjectsKHR_6(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueAcquireExternalMemObjectsKHR_6(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireExternalMemObjectsKHR(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueAcquireExternalMemObjectsKHR_5(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireExternalMemObjectsKHR(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueAcquireExternalMemObjectsKHR_6(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireExternalMemObjectsKHR(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueAcquireExternalMemObjectsKHR_7(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireExternalMemObjectsKHR(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueAcquireExternalMemObjectsKHR_8(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    
    public EnqueueReleaseExternalMemObjectsKHR_adr := GetProcAddress('clEnqueueReleaseExternalMemObjectsKHR');
    private ntv_EnqueueReleaseExternalMemObjectsKHR_1 := GetProcOrNil&<function(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueReleaseExternalMemObjectsKHR_adr);
    private ntv_EnqueueReleaseExternalMemObjectsKHR_2 := GetProcOrNil&<function(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueReleaseExternalMemObjectsKHR_adr);
    private ntv_EnqueueReleaseExternalMemObjectsKHR_3 := GetProcOrNil&<function(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueReleaseExternalMemObjectsKHR_adr);
    private ntv_EnqueueReleaseExternalMemObjectsKHR_4 := GetProcOrNil&<function(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueReleaseExternalMemObjectsKHR_adr);
    private ntv_EnqueueReleaseExternalMemObjectsKHR_5 := GetProcOrNil&<function(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueReleaseExternalMemObjectsKHR_adr);
    private ntv_EnqueueReleaseExternalMemObjectsKHR_6 := GetProcOrNil&<function(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueReleaseExternalMemObjectsKHR_adr);
    private ntv_EnqueueReleaseExternalMemObjectsKHR_7 := GetProcOrNil&<function(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueReleaseExternalMemObjectsKHR_adr);
    private ntv_EnqueueReleaseExternalMemObjectsKHR_8 := GetProcOrNil&<function(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueReleaseExternalMemObjectsKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseExternalMemObjectsKHR(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueReleaseExternalMemObjectsKHR(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueReleaseExternalMemObjectsKHR(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseExternalMemObjectsKHR(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueReleaseExternalMemObjectsKHR(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueReleaseExternalMemObjectsKHR(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseExternalMemObjectsKHR(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueReleaseExternalMemObjectsKHR_1(command_queue, num_mem_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueReleaseExternalMemObjectsKHR_1(command_queue, num_mem_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseExternalMemObjectsKHR(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueReleaseExternalMemObjectsKHR_2(command_queue, num_mem_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueReleaseExternalMemObjectsKHR_2(command_queue, num_mem_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseExternalMemObjectsKHR(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueReleaseExternalMemObjectsKHR_3(command_queue, num_mem_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueReleaseExternalMemObjectsKHR_3(command_queue, num_mem_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseExternalMemObjectsKHR(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueReleaseExternalMemObjectsKHR_4(command_queue, num_mem_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueReleaseExternalMemObjectsKHR_4(command_queue, num_mem_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseExternalMemObjectsKHR(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReleaseExternalMemObjectsKHR_1(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReleaseExternalMemObjectsKHR_1(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseExternalMemObjectsKHR(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReleaseExternalMemObjectsKHR_2(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReleaseExternalMemObjectsKHR_2(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseExternalMemObjectsKHR(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReleaseExternalMemObjectsKHR_1(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseExternalMemObjectsKHR(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReleaseExternalMemObjectsKHR_2(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseExternalMemObjectsKHR(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReleaseExternalMemObjectsKHR_3(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseExternalMemObjectsKHR(command_queue: cl_command_queue; num_mem_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReleaseExternalMemObjectsKHR_4(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseExternalMemObjectsKHR(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReleaseExternalMemObjectsKHR_5(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReleaseExternalMemObjectsKHR_5(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseExternalMemObjectsKHR(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReleaseExternalMemObjectsKHR_6(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReleaseExternalMemObjectsKHR_6(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseExternalMemObjectsKHR(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReleaseExternalMemObjectsKHR_5(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseExternalMemObjectsKHR(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReleaseExternalMemObjectsKHR_6(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseExternalMemObjectsKHR(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReleaseExternalMemObjectsKHR_7(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseExternalMemObjectsKHR(command_queue: cl_command_queue; num_mem_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReleaseExternalMemObjectsKHR_8(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    
  end;
  
  ///
  clExternalMemoryDmaBufKHR = static class
    public const ExtensionString = 'cl_khr_external_memory_dma_buf';
  end;
  
  ///
  clExternalMemoryDxKHR = static class
    public const ExtensionString = 'cl_khr_external_memory_dx';
  end;
  
  ///
  clExternalMemoryOpaqueFdKHR = static class
    public const ExtensionString = 'cl_khr_external_memory_opaque_fd';
  end;
  
  ///
  clExternalMemoryWin32KHR = static class
    public const ExtensionString = 'cl_khr_external_memory_win32';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clExternalSemaphoreKHR = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clExternalSemaphoreKHR(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_khr_external_semaphore';
    
    public GetSemaphoreHandleForTypeKHR_adr := GetProcAddress('clGetSemaphoreHandleForTypeKHR');
    private ntv_GetSemaphoreHandleForTypeKHR_1 := GetProcOrNil&<function(sema_object: cl_semaphore; device: cl_device_id; handle_type: clExternalSemaphoreHandleType; handle_size: UIntPtr; handle_ptr: IntPtr; var handle_size_ret: UIntPtr): clErrorCode>(GetSemaphoreHandleForTypeKHR_adr);
    private ntv_GetSemaphoreHandleForTypeKHR_2 := GetProcOrNil&<function(sema_object: cl_semaphore; device: cl_device_id; handle_type: clExternalSemaphoreHandleType; handle_size: UIntPtr; handle_ptr: IntPtr; handle_size_ret: IntPtr): clErrorCode>(GetSemaphoreHandleForTypeKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSemaphoreHandleForTypeKHR(sema_object: cl_semaphore; device: cl_device_id; handle_type: clExternalSemaphoreHandleType; handle_size: UIntPtr; handle_ptr: IntPtr; var handle_size_ret: UIntPtr): clErrorCode :=
      ntv_GetSemaphoreHandleForTypeKHR_1(sema_object, device, handle_type, handle_size, handle_ptr, handle_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSemaphoreHandleForTypeKHR(sema_object: cl_semaphore; device: cl_device_id; handle_type: clExternalSemaphoreHandleType; handle_size: UIntPtr; handle_ptr: IntPtr; handle_size_ret: IntPtr): clErrorCode :=
      ntv_GetSemaphoreHandleForTypeKHR_2(sema_object, device, handle_type, handle_size, handle_ptr, handle_size_ret);
    
  end;
  
  ///
  clExternalSemaphoreDxFenceKHR = static class
    public const ExtensionString = 'cl_khr_external_semaphore_dx_fence';
  end;
  
  ///
  clExternalSemaphoreOpaqueFdKHR = static class
    public const ExtensionString = 'cl_khr_external_semaphore_opaque_fd';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clExternalSemaphoreSyncFdKHR = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clExternalSemaphoreSyncFdKHR(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_khr_external_semaphore_sync_fd';
    
    public ReImportSemaphoreSyncFdKHR_adr := GetProcAddress('clReImportSemaphoreSyncFdKHR');
    private ntv_ReImportSemaphoreSyncFdKHR_1 := GetProcOrNil&<function(sema_object: cl_semaphore; var reimport_props: UInt64; fd: Int32): clErrorCode>(ReImportSemaphoreSyncFdKHR_adr);
    private ntv_ReImportSemaphoreSyncFdKHR_2 := GetProcOrNil&<function(sema_object: cl_semaphore; reimport_props: IntPtr; fd: Int32): clErrorCode>(ReImportSemaphoreSyncFdKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReImportSemaphoreSyncFdKHR(sema_object: cl_semaphore; reimport_props: array of UInt64; fd: Int32): clErrorCode;
    type PUInt64 = ^UInt64;
    begin
      Result := if (reimport_props<>nil) and (reimport_props.Length<>0) then
        ntv_ReImportSemaphoreSyncFdKHR_1(sema_object, reimport_props[0], fd) else
        ntv_ReImportSemaphoreSyncFdKHR_1(sema_object, PUInt64(nil)^, fd);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReImportSemaphoreSyncFdKHR(sema_object: cl_semaphore; var reimport_props: UInt64; fd: Int32): clErrorCode :=
      ntv_ReImportSemaphoreSyncFdKHR_1(sema_object, reimport_props, fd);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReImportSemaphoreSyncFdKHR(sema_object: cl_semaphore; reimport_props: IntPtr; fd: Int32): clErrorCode :=
      ntv_ReImportSemaphoreSyncFdKHR_2(sema_object, reimport_props, fd);
    
  end;
  
  ///
  clExternalSemaphoreWin32KHR = static class
    public const ExtensionString = 'cl_khr_external_semaphore_win32';
  end;
  
  ///
  clFp16KHR = static class
    public const ExtensionString = 'cl_khr_fp16';
  end;
  
  ///
  clFp64KHR = static class
    public const ExtensionString = 'cl_khr_fp64';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clGLSharingKHR = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clGLSharingKHR(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_khr_gl_sharing';
    
    public GetGLContextInfoKHR_adr := GetProcAddress('clGetGLContextInfoKHR');
    private ntv_GetGLContextInfoKHR_1 := GetProcOrNil&<function(var properties: clContextProperties; param_name: clGlContextInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode>(GetGLContextInfoKHR_adr);
    private ntv_GetGLContextInfoKHR_2 := GetProcOrNil&<function(var properties: clContextProperties; param_name: clGlContextInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode>(GetGLContextInfoKHR_adr);
    private ntv_GetGLContextInfoKHR_3 := GetProcOrNil&<function(var properties: clContextProperties; param_name: clGlContextInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode>(GetGLContextInfoKHR_adr);
    private ntv_GetGLContextInfoKHR_4 := GetProcOrNil&<function(var properties: clContextProperties; param_name: clGlContextInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode>(GetGLContextInfoKHR_adr);
    private ntv_GetGLContextInfoKHR_5 := GetProcOrNil&<function(properties: IntPtr; param_name: clGlContextInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode>(GetGLContextInfoKHR_adr);
    private ntv_GetGLContextInfoKHR_6 := GetProcOrNil&<function(properties: IntPtr; param_name: clGlContextInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode>(GetGLContextInfoKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGLContextInfoKHR<T>(var properties: clContextProperties; param_name: clGlContextInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetGLContextInfoKHR_1(properties, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGLContextInfoKHR<T>(var properties: clContextProperties; param_name: clGlContextInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetGLContextInfoKHR_2(properties, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGLContextInfoKHR(var properties: clContextProperties; param_name: clGlContextInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetGLContextInfoKHR_3(properties, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGLContextInfoKHR(var properties: clContextProperties; param_name: clGlContextInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetGLContextInfoKHR_4(properties, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGLContextInfoKHR_CURRENT_DEVICE_FOR_GL_CONTEXT(var properties: clContextProperties; var param_value: cl_device_id; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_device_id>);
      var param_value_ret_size: UIntPtr;
      Result := GetGLContextInfoKHR(properties, clGlContextInfo.CURRENT_DEVICE_FOR_GL_CONTEXT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGLContextInfoKHR_DEVICES_FOR_GL_CONTEXT(var properties: clContextProperties; var param_value: array of cl_device_id): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetGLContextInfoKHR_3(properties, clGlContextInfo.DEVICES_FOR_GL_CONTEXT, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new cl_device_id[param_value_sz.ToUInt64 div Marshal.SizeOf&<cl_device_id>];
      Result := GetGLContextInfoKHR(properties, clGlContextInfo.DEVICES_FOR_GL_CONTEXT, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGLContextInfoKHR_DEVICES_FOR_GL_CONTEXT(var properties: clContextProperties; param_value_count: UInt32; var param_value: cl_device_id): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<cl_device_id>);
      Result := GetGLContextInfoKHR(properties, clGlContextInfo.DEVICES_FOR_GL_CONTEXT, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGLContextInfoKHR(properties: array of clContextProperties; param_name: clGlContextInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode;
    type PClContextProperties = ^clContextProperties;
    begin
      Result := if (properties<>nil) and (properties.Length<>0) then
        ntv_GetGLContextInfoKHR_3(properties[0], param_name, param_value_size, param_value, param_value_size_ret) else
        ntv_GetGLContextInfoKHR_3(PClContextProperties(nil)^, param_name, param_value_size, param_value, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGLContextInfoKHR(properties: array of clContextProperties; param_name: clGlContextInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode;
    type PClContextProperties = ^clContextProperties;
    begin
      Result := if (properties<>nil) and (properties.Length<>0) then
        ntv_GetGLContextInfoKHR_4(properties[0], param_name, param_value_size, param_value, param_value_size_ret) else
        ntv_GetGLContextInfoKHR_4(PClContextProperties(nil)^, param_name, param_value_size, param_value, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGLContextInfoKHR(properties: IntPtr; param_name: clGlContextInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetGLContextInfoKHR_5(properties, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGLContextInfoKHR(properties: IntPtr; param_name: clGlContextInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetGLContextInfoKHR_6(properties, param_name, param_value_size, param_value, param_value_size_ret);
    
    public CreateFromGLBuffer_adr := GetProcAddress('clCreateFromGLBuffer');
    private ntv_CreateFromGLBuffer_1 := GetProcOrNil&<function(context: cl_context; flags: clMemFlags; bufobj: UInt32; var errcode_ret: clErrorCode): cl_mem>(CreateFromGLBuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateFromGLBuffer(context: cl_context; flags: clMemFlags; bufobj: UInt32; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateFromGLBuffer_1(context, flags, bufobj, errcode_ret);
    
    public CreateFromGLTexture_adr := GetProcAddress('clCreateFromGLTexture');
    private ntv_CreateFromGLTexture_1 := GetProcOrNil&<function(context: cl_context; flags: clMemFlags; target: UInt32; miplevel: Int32; texture: UInt32; var errcode_ret: clErrorCode): cl_mem>(CreateFromGLTexture_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateFromGLTexture(context: cl_context; flags: clMemFlags; target: UInt32; miplevel: Int32; texture: UInt32; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateFromGLTexture_1(context, flags, target, miplevel, texture, errcode_ret);
    
    public CreateFromGLRenderbuffer_adr := GetProcAddress('clCreateFromGLRenderbuffer');
    private ntv_CreateFromGLRenderbuffer_1 := GetProcOrNil&<function(context: cl_context; flags: clMemFlags; renderbuffer: UInt32; var errcode_ret: clErrorCode): cl_mem>(CreateFromGLRenderbuffer_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateFromGLRenderbuffer(context: cl_context; flags: clMemFlags; renderbuffer: UInt32; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateFromGLRenderbuffer_1(context, flags, renderbuffer, errcode_ret);
    
    public GetGLObjectInfo_adr := GetProcAddress('clGetGLObjectInfo');
    private ntv_GetGLObjectInfo_1 := GetProcOrNil&<function(memobj: cl_mem; var gl_object_type: clGlObjectType; var gl_object_name: UInt32): clErrorCode>(GetGLObjectInfo_adr);
    private ntv_GetGLObjectInfo_2 := GetProcOrNil&<function(memobj: cl_mem; var gl_object_type: clGlObjectType; gl_object_name: IntPtr): clErrorCode>(GetGLObjectInfo_adr);
    private ntv_GetGLObjectInfo_3 := GetProcOrNil&<function(memobj: cl_mem; gl_object_type: IntPtr; var gl_object_name: UInt32): clErrorCode>(GetGLObjectInfo_adr);
    private ntv_GetGLObjectInfo_4 := GetProcOrNil&<function(memobj: cl_mem; gl_object_type: IntPtr; gl_object_name: IntPtr): clErrorCode>(GetGLObjectInfo_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGLObjectInfo(memobj: cl_mem; var gl_object_type: clGlObjectType; var gl_object_name: UInt32): clErrorCode :=
      ntv_GetGLObjectInfo_1(memobj, gl_object_type, gl_object_name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGLObjectInfo(memobj: cl_mem; var gl_object_type: clGlObjectType; gl_object_name: IntPtr): clErrorCode :=
      ntv_GetGLObjectInfo_2(memobj, gl_object_type, gl_object_name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGLObjectInfo(memobj: cl_mem; gl_object_type: IntPtr; var gl_object_name: UInt32): clErrorCode :=
      ntv_GetGLObjectInfo_3(memobj, gl_object_type, gl_object_name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGLObjectInfo(memobj: cl_mem; gl_object_type: IntPtr; gl_object_name: IntPtr): clErrorCode :=
      ntv_GetGLObjectInfo_4(memobj, gl_object_type, gl_object_name);
    
    public GetGLTextureInfo_adr := GetProcAddress('clGetGLTextureInfo');
    private ntv_GetGLTextureInfo_1 := GetProcOrNil&<function(memobj: cl_mem; param_name: clGlTextureInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode>(GetGLTextureInfo_adr);
    private ntv_GetGLTextureInfo_2 := GetProcOrNil&<function(memobj: cl_mem; param_name: clGlTextureInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode>(GetGLTextureInfo_adr);
    private ntv_GetGLTextureInfo_3 := GetProcOrNil&<function(memobj: cl_mem; param_name: clGlTextureInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode>(GetGLTextureInfo_adr);
    private ntv_GetGLTextureInfo_4 := GetProcOrNil&<function(memobj: cl_mem; param_name: clGlTextureInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode>(GetGLTextureInfo_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGLTextureInfo<T>(memobj: cl_mem; param_name: clGlTextureInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetGLTextureInfo_1(memobj, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGLTextureInfo<T>(memobj: cl_mem; param_name: clGlTextureInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetGLTextureInfo_2(memobj, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGLTextureInfo_GL_TEXTURE_TARGET(memobj: cl_mem; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetGLTextureInfo(memobj, clGlTextureInfo.GL_TEXTURE_TARGET, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGLTextureInfo_GL_MIPMAP_LEVEL(memobj: cl_mem; var param_value: Int32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<Int32>);
      var param_value_ret_size: UIntPtr;
      Result := GetGLTextureInfo(memobj, clGlTextureInfo.GL_MIPMAP_LEVEL, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGLTextureInfo_GL_NUM_SAMPLES(memobj: cl_mem; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetGLTextureInfo(memobj, clGlTextureInfo.GL_NUM_SAMPLES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGLTextureInfo(memobj: cl_mem; param_name: clGlTextureInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetGLTextureInfo_3(memobj, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGLTextureInfo(memobj: cl_mem; param_name: clGlTextureInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetGLTextureInfo_4(memobj, param_name, param_value_size, param_value, param_value_size_ret);
    
    public EnqueueAcquireGLObjects_adr := GetProcAddress('clEnqueueAcquireGLObjects');
    private ntv_EnqueueAcquireGLObjects_1 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueAcquireGLObjects_adr);
    private ntv_EnqueueAcquireGLObjects_2 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueAcquireGLObjects_adr);
    private ntv_EnqueueAcquireGLObjects_3 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueAcquireGLObjects_adr);
    private ntv_EnqueueAcquireGLObjects_4 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueAcquireGLObjects_adr);
    private ntv_EnqueueAcquireGLObjects_5 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueAcquireGLObjects_adr);
    private ntv_EnqueueAcquireGLObjects_6 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueAcquireGLObjects_adr);
    private ntv_EnqueueAcquireGLObjects_7 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueAcquireGLObjects_adr);
    private ntv_EnqueueAcquireGLObjects_8 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueAcquireGLObjects_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireGLObjects(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueAcquireGLObjects(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueAcquireGLObjects(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireGLObjects(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueAcquireGLObjects(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueAcquireGLObjects(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireGLObjects(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueAcquireGLObjects_1(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueAcquireGLObjects_1(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireGLObjects(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueAcquireGLObjects_2(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueAcquireGLObjects_2(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireGLObjects(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueAcquireGLObjects_3(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueAcquireGLObjects_3(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireGLObjects(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueAcquireGLObjects_4(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueAcquireGLObjects_4(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireGLObjects(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueAcquireGLObjects_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueAcquireGLObjects_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireGLObjects(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueAcquireGLObjects_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueAcquireGLObjects_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireGLObjects(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueAcquireGLObjects_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireGLObjects(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueAcquireGLObjects_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireGLObjects(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueAcquireGLObjects_3(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireGLObjects(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueAcquireGLObjects_4(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireGLObjects(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueAcquireGLObjects_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueAcquireGLObjects_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireGLObjects(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueAcquireGLObjects_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueAcquireGLObjects_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireGLObjects(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueAcquireGLObjects_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireGLObjects(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueAcquireGLObjects_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireGLObjects(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueAcquireGLObjects_7(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueAcquireGLObjects(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueAcquireGLObjects_8(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    
    public EnqueueReleaseGLObjects_adr := GetProcAddress('clEnqueueReleaseGLObjects');
    private ntv_EnqueueReleaseGLObjects_1 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueReleaseGLObjects_adr);
    private ntv_EnqueueReleaseGLObjects_2 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueReleaseGLObjects_adr);
    private ntv_EnqueueReleaseGLObjects_3 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueReleaseGLObjects_adr);
    private ntv_EnqueueReleaseGLObjects_4 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueReleaseGLObjects_adr);
    private ntv_EnqueueReleaseGLObjects_5 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueReleaseGLObjects_adr);
    private ntv_EnqueueReleaseGLObjects_6 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueReleaseGLObjects_adr);
    private ntv_EnqueueReleaseGLObjects_7 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueReleaseGLObjects_adr);
    private ntv_EnqueueReleaseGLObjects_8 := GetProcOrNil&<function(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueReleaseGLObjects_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseGLObjects(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueReleaseGLObjects(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueReleaseGLObjects(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseGLObjects(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueReleaseGLObjects(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueReleaseGLObjects(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseGLObjects(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueReleaseGLObjects_1(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueReleaseGLObjects_1(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseGLObjects(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueReleaseGLObjects_2(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueReleaseGLObjects_2(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseGLObjects(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueReleaseGLObjects_3(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueReleaseGLObjects_3(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseGLObjects(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: array of cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    type PCl_mem = ^cl_mem;
    begin
      Result := if (mem_objects<>nil) and (mem_objects.Length<>0) then
        ntv_EnqueueReleaseGLObjects_4(command_queue, num_objects, mem_objects[0], num_events_in_wait_list, event_wait_list, &event) else
        ntv_EnqueueReleaseGLObjects_4(command_queue, num_objects, PCl_mem(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseGLObjects(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReleaseGLObjects_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReleaseGLObjects_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseGLObjects(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReleaseGLObjects_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReleaseGLObjects_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseGLObjects(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReleaseGLObjects_1(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseGLObjects(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReleaseGLObjects_2(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseGLObjects(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReleaseGLObjects_3(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseGLObjects(command_queue: cl_command_queue; num_objects: UInt32; var mem_objects: cl_mem; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReleaseGLObjects_4(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseGLObjects(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReleaseGLObjects_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReleaseGLObjects_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseGLObjects(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueReleaseGLObjects_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueReleaseGLObjects_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseGLObjects(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReleaseGLObjects_5(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseGLObjects(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReleaseGLObjects_6(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseGLObjects(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueReleaseGLObjects_7(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueReleaseGLObjects(command_queue: cl_command_queue; num_objects: UInt32; mem_objects: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueReleaseGLObjects_8(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, &event);
    
    public CreateFromGLTexture2D_adr := GetProcAddress('clCreateFromGLTexture2D');
    private ntv_CreateFromGLTexture2D_1 := GetProcOrNil&<function(context: cl_context; flags: clMemFlags; target: UInt32; miplevel: Int32; texture: UInt32; var errcode_ret: clErrorCode): cl_mem>(CreateFromGLTexture2D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateFromGLTexture2D(context: cl_context; flags: clMemFlags; target: UInt32; miplevel: Int32; texture: UInt32; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateFromGLTexture2D_1(context, flags, target, miplevel, texture, errcode_ret);
    
    public CreateFromGLTexture3D_adr := GetProcAddress('clCreateFromGLTexture3D');
    private ntv_CreateFromGLTexture3D_1 := GetProcOrNil&<function(context: cl_context; flags: clMemFlags; target: UInt32; miplevel: Int32; texture: UInt32; var errcode_ret: clErrorCode): cl_mem>(CreateFromGLTexture3D_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateFromGLTexture3D(context: cl_context; flags: clMemFlags; target: UInt32; miplevel: Int32; texture: UInt32; var errcode_ret: clErrorCode): cl_mem :=
      ntv_CreateFromGLTexture3D_1(context, flags, target, miplevel, texture, errcode_ret);
    
  end;
  
  ///
  clGLDepthImagesKHR = static class
    public const ExtensionString = 'cl_khr_gl_depth_images';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clGLEventKHR = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clGLEventKHR(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_khr_gl_event';
    
    public CreateEventFromGLsyncKHR_adr := GetProcAddress('clCreateEventFromGLsyncKHR');
    private ntv_CreateEventFromGLsyncKHR_1 := GetProcOrNil&<function(context: cl_context; sync: cl_GLsync; var errcode_ret: clErrorCode): cl_event>(CreateEventFromGLsyncKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateEventFromGLsyncKHR(context: cl_context; sync: cl_GLsync; var errcode_ret: clErrorCode): cl_event :=
      ntv_CreateEventFromGLsyncKHR_1(context, sync, errcode_ret);
    
  end;
  
  ///
  clGlMsaaSharingKHR = static class
    public const ExtensionString = 'cl_khr_gl_msaa_sharing';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clIcdKHR = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clIcdKHR(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_khr_icd';
    
    public IcdGetPlatformIDsKHR_adr := GetProcAddress('clIcdGetPlatformIDsKHR');
    private ntv_IcdGetPlatformIDsKHR_1 := GetProcOrNil&<function(num_entries: UInt32; var platforms: cl_platform_id; var num_platforms: UInt32): clErrorCode>(IcdGetPlatformIDsKHR_adr);
    private ntv_IcdGetPlatformIDsKHR_2 := GetProcOrNil&<function(num_entries: UInt32; var platforms: cl_platform_id; num_platforms: IntPtr): clErrorCode>(IcdGetPlatformIDsKHR_adr);
    private ntv_IcdGetPlatformIDsKHR_3 := GetProcOrNil&<function(num_entries: UInt32; platforms: IntPtr; var num_platforms: UInt32): clErrorCode>(IcdGetPlatformIDsKHR_adr);
    private ntv_IcdGetPlatformIDsKHR_4 := GetProcOrNil&<function(num_entries: UInt32; platforms: IntPtr; num_platforms: IntPtr): clErrorCode>(IcdGetPlatformIDsKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IcdGetPlatformIDsKHR(num_entries: UInt32; platforms: array of cl_platform_id; num_platforms: array of UInt32): clErrorCode;
    type PCl_platform_id = ^cl_platform_id;
    type PUInt32 = ^UInt32;
    begin
      Result := if (num_platforms<>nil) and (num_platforms.Length<>0) then
        if (platforms<>nil) and (platforms.Length<>0) then
          ntv_IcdGetPlatformIDsKHR_1(num_entries, platforms[0], num_platforms[0]) else
          ntv_IcdGetPlatformIDsKHR_1(num_entries, PCl_platform_id(nil)^, num_platforms[0]) else
        if (platforms<>nil) and (platforms.Length<>0) then
          ntv_IcdGetPlatformIDsKHR_1(num_entries, platforms[0], PUInt32(nil)^) else
          ntv_IcdGetPlatformIDsKHR_1(num_entries, PCl_platform_id(nil)^, PUInt32(nil)^);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IcdGetPlatformIDsKHR(num_entries: UInt32; var platforms: cl_platform_id; var num_platforms: UInt32): clErrorCode :=
      ntv_IcdGetPlatformIDsKHR_1(num_entries, platforms, num_platforms);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IcdGetPlatformIDsKHR(num_entries: UInt32; var platforms: cl_platform_id; num_platforms: IntPtr): clErrorCode :=
      ntv_IcdGetPlatformIDsKHR_2(num_entries, platforms, num_platforms);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IcdGetPlatformIDsKHR(num_entries: UInt32; platforms: IntPtr; var num_platforms: UInt32): clErrorCode :=
      ntv_IcdGetPlatformIDsKHR_3(num_entries, platforms, num_platforms);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IcdGetPlatformIDsKHR(num_entries: UInt32; platforms: IntPtr; num_platforms: IntPtr): clErrorCode :=
      ntv_IcdGetPlatformIDsKHR_4(num_entries, platforms, num_platforms);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clIlProgramKHR = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clIlProgramKHR(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_khr_il_program';
    
    public CreateProgramWithILKHR_adr := GetProcAddress('clCreateProgramWithILKHR');
    private ntv_CreateProgramWithILKHR_1 := GetProcOrNil&<function(context: cl_context; var il: Byte; length: UIntPtr; var errcode_ret: clErrorCode): cl_program>(CreateProgramWithILKHR_adr);
    private ntv_CreateProgramWithILKHR_2 := GetProcOrNil&<function(context: cl_context; il: IntPtr; length: UIntPtr; var errcode_ret: clErrorCode): cl_program>(CreateProgramWithILKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateProgramWithILKHR(context: cl_context; il: array of Byte; length: UIntPtr; var errcode_ret: clErrorCode): cl_program;
    type PByte = ^Byte;
    begin
      Result := if (il<>nil) and (il.Length<>0) then
        ntv_CreateProgramWithILKHR_1(context, il[0], length, errcode_ret) else
        ntv_CreateProgramWithILKHR_1(context, PByte(nil)^, length, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateProgramWithILKHR(context: cl_context; var il: Byte; length: UIntPtr; var errcode_ret: clErrorCode): cl_program :=
      ntv_CreateProgramWithILKHR_1(context, il, length, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateProgramWithILKHR(context: cl_context; il: IntPtr; length: UIntPtr; var errcode_ret: clErrorCode): cl_program :=
      ntv_CreateProgramWithILKHR_2(context, il, length, errcode_ret);
    
  end;
  
  ///
  clImage2dFromBufferKHR = static class
    public const ExtensionString = 'cl_khr_image2d_from_buffer';
  end;
  
  ///
  clInitializeMemoryKHR = static class
    public const ExtensionString = 'cl_khr_initialize_memory';
  end;
  
  ///
  clIntegerDotProductKHR = static class
    public const ExtensionString = 'cl_khr_integer_dot_product';
  end;
  
  ///
  clMipmapImageKHR = static class
    public const ExtensionString = 'cl_khr_mipmap_image';
  end;
  
  ///
  clPciBusInfoKHR = static class
    public const ExtensionString = 'cl_khr_pci_bus_info';
  end;
  
  ///
  clPriorityHintsKHR = static class
    public const ExtensionString = 'cl_khr_priority_hints';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clSemaphoreKHR = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clSemaphoreKHR(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_khr_semaphore';
    
    public CreateSemaphoreWithPropertiesKHR_adr := GetProcAddress('clCreateSemaphoreWithPropertiesKHR');
    private ntv_CreateSemaphoreWithPropertiesKHR_1 := GetProcOrNil&<function(context: cl_context; var sema_props: clSemaphoreProperties; var errcode_ret: clErrorCode): cl_semaphore>(CreateSemaphoreWithPropertiesKHR_adr);
    private ntv_CreateSemaphoreWithPropertiesKHR_2 := GetProcOrNil&<function(context: cl_context; sema_props: IntPtr; var errcode_ret: clErrorCode): cl_semaphore>(CreateSemaphoreWithPropertiesKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSemaphoreWithPropertiesKHR(context: cl_context; sema_props: array of clSemaphoreProperties; var errcode_ret: clErrorCode): cl_semaphore;
    type PClSemaphoreProperties = ^clSemaphoreProperties;
    begin
      Result := if (sema_props<>nil) and (sema_props.Length<>0) then
        ntv_CreateSemaphoreWithPropertiesKHR_1(context, sema_props[0], errcode_ret) else
        ntv_CreateSemaphoreWithPropertiesKHR_1(context, PClSemaphoreProperties(nil)^, errcode_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSemaphoreWithPropertiesKHR(context: cl_context; var sema_props: clSemaphoreProperties; var errcode_ret: clErrorCode): cl_semaphore :=
      ntv_CreateSemaphoreWithPropertiesKHR_1(context, sema_props, errcode_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSemaphoreWithPropertiesKHR(context: cl_context; sema_props: IntPtr; var errcode_ret: clErrorCode): cl_semaphore :=
      ntv_CreateSemaphoreWithPropertiesKHR_2(context, sema_props, errcode_ret);
    
    public EnqueueWaitSemaphoresKHR_adr := GetProcAddress('clEnqueueWaitSemaphoresKHR');
    private ntv_EnqueueWaitSemaphoresKHR_1 := GetProcOrNil&<function(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueWaitSemaphoresKHR_adr);
    private ntv_EnqueueWaitSemaphoresKHR_2 := GetProcOrNil&<function(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueWaitSemaphoresKHR_adr);
    private ntv_EnqueueWaitSemaphoresKHR_3 := GetProcOrNil&<function(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueWaitSemaphoresKHR_adr);
    private ntv_EnqueueWaitSemaphoresKHR_4 := GetProcOrNil&<function(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueWaitSemaphoresKHR_adr);
    private ntv_EnqueueWaitSemaphoresKHR_5 := GetProcOrNil&<function(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueWaitSemaphoresKHR_adr);
    private ntv_EnqueueWaitSemaphoresKHR_6 := GetProcOrNil&<function(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueWaitSemaphoresKHR_adr);
    private ntv_EnqueueWaitSemaphoresKHR_7 := GetProcOrNil&<function(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueWaitSemaphoresKHR_adr);
    private ntv_EnqueueWaitSemaphoresKHR_8 := GetProcOrNil&<function(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueWaitSemaphoresKHR_adr);
    private ntv_EnqueueWaitSemaphoresKHR_9 := GetProcOrNil&<function(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueWaitSemaphoresKHR_adr);
    private ntv_EnqueueWaitSemaphoresKHR_10 := GetProcOrNil&<function(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueWaitSemaphoresKHR_adr);
    private ntv_EnqueueWaitSemaphoresKHR_11 := GetProcOrNil&<function(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueWaitSemaphoresKHR_adr);
    private ntv_EnqueueWaitSemaphoresKHR_12 := GetProcOrNil&<function(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueWaitSemaphoresKHR_adr);
    private ntv_EnqueueWaitSemaphoresKHR_13 := GetProcOrNil&<function(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueWaitSemaphoresKHR_adr);
    private ntv_EnqueueWaitSemaphoresKHR_14 := GetProcOrNil&<function(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueWaitSemaphoresKHR_adr);
    private ntv_EnqueueWaitSemaphoresKHR_15 := GetProcOrNil&<function(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueWaitSemaphoresKHR_adr);
    private ntv_EnqueueWaitSemaphoresKHR_16 := GetProcOrNil&<function(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueWaitSemaphoresKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWaitSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: array of cl_semaphore; sema_payload_list: array of UInt64; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueWaitSemaphoresKHR(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueWaitSemaphoresKHR(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWaitSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: array of cl_semaphore; sema_payload_list: array of UInt64; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueWaitSemaphoresKHR(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueWaitSemaphoresKHR(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWaitSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: array of cl_semaphore; sema_payload_list: array of UInt64; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    type PCl_semaphore = ^cl_semaphore;
    type PUInt64 = ^UInt64;
    begin
      Result := if (sema_payload_list<>nil) and (sema_payload_list.Length<>0) then
        if (sema_objects<>nil) and (sema_objects.Length<>0) then
          ntv_EnqueueWaitSemaphoresKHR_1(command_queue, num_sema_objects, sema_objects[0], sema_payload_list[0], num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueWaitSemaphoresKHR_1(command_queue, num_sema_objects, PCl_semaphore(nil)^, sema_payload_list[0], num_events_in_wait_list, event_wait_list, &event) else
        if (sema_objects<>nil) and (sema_objects.Length<>0) then
          ntv_EnqueueWaitSemaphoresKHR_1(command_queue, num_sema_objects, sema_objects[0], PUInt64(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueWaitSemaphoresKHR_1(command_queue, num_sema_objects, PCl_semaphore(nil)^, PUInt64(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWaitSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: array of cl_semaphore; sema_payload_list: array of UInt64; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    type PCl_semaphore = ^cl_semaphore;
    type PUInt64 = ^UInt64;
    begin
      Result := if (sema_payload_list<>nil) and (sema_payload_list.Length<>0) then
        if (sema_objects<>nil) and (sema_objects.Length<>0) then
          ntv_EnqueueWaitSemaphoresKHR_2(command_queue, num_sema_objects, sema_objects[0], sema_payload_list[0], num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueWaitSemaphoresKHR_2(command_queue, num_sema_objects, PCl_semaphore(nil)^, sema_payload_list[0], num_events_in_wait_list, event_wait_list, &event) else
        if (sema_objects<>nil) and (sema_objects.Length<>0) then
          ntv_EnqueueWaitSemaphoresKHR_2(command_queue, num_sema_objects, sema_objects[0], PUInt64(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueWaitSemaphoresKHR_2(command_queue, num_sema_objects, PCl_semaphore(nil)^, PUInt64(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWaitSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: array of cl_semaphore; sema_payload_list: array of UInt64; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    type PCl_semaphore = ^cl_semaphore;
    type PUInt64 = ^UInt64;
    begin
      Result := if (sema_payload_list<>nil) and (sema_payload_list.Length<>0) then
        if (sema_objects<>nil) and (sema_objects.Length<>0) then
          ntv_EnqueueWaitSemaphoresKHR_3(command_queue, num_sema_objects, sema_objects[0], sema_payload_list[0], num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueWaitSemaphoresKHR_3(command_queue, num_sema_objects, PCl_semaphore(nil)^, sema_payload_list[0], num_events_in_wait_list, event_wait_list, &event) else
        if (sema_objects<>nil) and (sema_objects.Length<>0) then
          ntv_EnqueueWaitSemaphoresKHR_3(command_queue, num_sema_objects, sema_objects[0], PUInt64(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueWaitSemaphoresKHR_3(command_queue, num_sema_objects, PCl_semaphore(nil)^, PUInt64(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWaitSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: array of cl_semaphore; sema_payload_list: array of UInt64; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    type PCl_semaphore = ^cl_semaphore;
    type PUInt64 = ^UInt64;
    begin
      Result := if (sema_payload_list<>nil) and (sema_payload_list.Length<>0) then
        if (sema_objects<>nil) and (sema_objects.Length<>0) then
          ntv_EnqueueWaitSemaphoresKHR_4(command_queue, num_sema_objects, sema_objects[0], sema_payload_list[0], num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueWaitSemaphoresKHR_4(command_queue, num_sema_objects, PCl_semaphore(nil)^, sema_payload_list[0], num_events_in_wait_list, event_wait_list, &event) else
        if (sema_objects<>nil) and (sema_objects.Length<>0) then
          ntv_EnqueueWaitSemaphoresKHR_4(command_queue, num_sema_objects, sema_objects[0], PUInt64(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueWaitSemaphoresKHR_4(command_queue, num_sema_objects, PCl_semaphore(nil)^, PUInt64(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWaitSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueWaitSemaphoresKHR_1(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueWaitSemaphoresKHR_1(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWaitSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueWaitSemaphoresKHR_2(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueWaitSemaphoresKHR_2(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWaitSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueWaitSemaphoresKHR_1(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWaitSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueWaitSemaphoresKHR_2(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWaitSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueWaitSemaphoresKHR_3(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWaitSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueWaitSemaphoresKHR_4(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWaitSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueWaitSemaphoresKHR_5(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueWaitSemaphoresKHR_5(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWaitSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueWaitSemaphoresKHR_6(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueWaitSemaphoresKHR_6(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWaitSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueWaitSemaphoresKHR_5(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWaitSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueWaitSemaphoresKHR_6(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWaitSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueWaitSemaphoresKHR_7(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWaitSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueWaitSemaphoresKHR_8(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWaitSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueWaitSemaphoresKHR_9(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueWaitSemaphoresKHR_9(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWaitSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueWaitSemaphoresKHR_10(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueWaitSemaphoresKHR_10(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWaitSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueWaitSemaphoresKHR_9(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWaitSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueWaitSemaphoresKHR_10(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWaitSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueWaitSemaphoresKHR_11(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWaitSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueWaitSemaphoresKHR_12(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWaitSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueWaitSemaphoresKHR_13(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueWaitSemaphoresKHR_13(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWaitSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueWaitSemaphoresKHR_14(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueWaitSemaphoresKHR_14(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWaitSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueWaitSemaphoresKHR_13(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWaitSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueWaitSemaphoresKHR_14(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWaitSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueWaitSemaphoresKHR_15(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueWaitSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueWaitSemaphoresKHR_16(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list, &event);
    
    public EnqueueSignalSemaphoresKHR_adr := GetProcAddress('clEnqueueSignalSemaphoresKHR');
    private ntv_EnqueueSignalSemaphoresKHR_1 := GetProcOrNil&<function(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueSignalSemaphoresKHR_adr);
    private ntv_EnqueueSignalSemaphoresKHR_2 := GetProcOrNil&<function(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueSignalSemaphoresKHR_adr);
    private ntv_EnqueueSignalSemaphoresKHR_3 := GetProcOrNil&<function(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueSignalSemaphoresKHR_adr);
    private ntv_EnqueueSignalSemaphoresKHR_4 := GetProcOrNil&<function(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueSignalSemaphoresKHR_adr);
    private ntv_EnqueueSignalSemaphoresKHR_5 := GetProcOrNil&<function(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueSignalSemaphoresKHR_adr);
    private ntv_EnqueueSignalSemaphoresKHR_6 := GetProcOrNil&<function(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueSignalSemaphoresKHR_adr);
    private ntv_EnqueueSignalSemaphoresKHR_7 := GetProcOrNil&<function(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueSignalSemaphoresKHR_adr);
    private ntv_EnqueueSignalSemaphoresKHR_8 := GetProcOrNil&<function(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueSignalSemaphoresKHR_adr);
    private ntv_EnqueueSignalSemaphoresKHR_9 := GetProcOrNil&<function(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueSignalSemaphoresKHR_adr);
    private ntv_EnqueueSignalSemaphoresKHR_10 := GetProcOrNil&<function(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueSignalSemaphoresKHR_adr);
    private ntv_EnqueueSignalSemaphoresKHR_11 := GetProcOrNil&<function(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueSignalSemaphoresKHR_adr);
    private ntv_EnqueueSignalSemaphoresKHR_12 := GetProcOrNil&<function(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueSignalSemaphoresKHR_adr);
    private ntv_EnqueueSignalSemaphoresKHR_13 := GetProcOrNil&<function(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode>(EnqueueSignalSemaphoresKHR_adr);
    private ntv_EnqueueSignalSemaphoresKHR_14 := GetProcOrNil&<function(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode>(EnqueueSignalSemaphoresKHR_adr);
    private ntv_EnqueueSignalSemaphoresKHR_15 := GetProcOrNil&<function(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode>(EnqueueSignalSemaphoresKHR_adr);
    private ntv_EnqueueSignalSemaphoresKHR_16 := GetProcOrNil&<function(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode>(EnqueueSignalSemaphoresKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSignalSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: array of cl_semaphore; sema_payload_list: array of UInt64; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueSignalSemaphoresKHR(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueSignalSemaphoresKHR(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSignalSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: array of cl_semaphore; sema_payload_list: array of UInt64; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        EnqueueSignalSemaphoresKHR(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list[0], &event) else
        EnqueueSignalSemaphoresKHR(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSignalSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: array of cl_semaphore; sema_payload_list: array of UInt64; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode;
    type PCl_semaphore = ^cl_semaphore;
    type PUInt64 = ^UInt64;
    begin
      Result := if (sema_payload_list<>nil) and (sema_payload_list.Length<>0) then
        if (sema_objects<>nil) and (sema_objects.Length<>0) then
          ntv_EnqueueSignalSemaphoresKHR_1(command_queue, num_sema_objects, sema_objects[0], sema_payload_list[0], num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueSignalSemaphoresKHR_1(command_queue, num_sema_objects, PCl_semaphore(nil)^, sema_payload_list[0], num_events_in_wait_list, event_wait_list, &event) else
        if (sema_objects<>nil) and (sema_objects.Length<>0) then
          ntv_EnqueueSignalSemaphoresKHR_1(command_queue, num_sema_objects, sema_objects[0], PUInt64(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueSignalSemaphoresKHR_1(command_queue, num_sema_objects, PCl_semaphore(nil)^, PUInt64(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSignalSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: array of cl_semaphore; sema_payload_list: array of UInt64; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode;
    type PCl_semaphore = ^cl_semaphore;
    type PUInt64 = ^UInt64;
    begin
      Result := if (sema_payload_list<>nil) and (sema_payload_list.Length<>0) then
        if (sema_objects<>nil) and (sema_objects.Length<>0) then
          ntv_EnqueueSignalSemaphoresKHR_2(command_queue, num_sema_objects, sema_objects[0], sema_payload_list[0], num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueSignalSemaphoresKHR_2(command_queue, num_sema_objects, PCl_semaphore(nil)^, sema_payload_list[0], num_events_in_wait_list, event_wait_list, &event) else
        if (sema_objects<>nil) and (sema_objects.Length<>0) then
          ntv_EnqueueSignalSemaphoresKHR_2(command_queue, num_sema_objects, sema_objects[0], PUInt64(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueSignalSemaphoresKHR_2(command_queue, num_sema_objects, PCl_semaphore(nil)^, PUInt64(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSignalSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: array of cl_semaphore; sema_payload_list: array of UInt64; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode;
    type PCl_semaphore = ^cl_semaphore;
    type PUInt64 = ^UInt64;
    begin
      Result := if (sema_payload_list<>nil) and (sema_payload_list.Length<>0) then
        if (sema_objects<>nil) and (sema_objects.Length<>0) then
          ntv_EnqueueSignalSemaphoresKHR_3(command_queue, num_sema_objects, sema_objects[0], sema_payload_list[0], num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueSignalSemaphoresKHR_3(command_queue, num_sema_objects, PCl_semaphore(nil)^, sema_payload_list[0], num_events_in_wait_list, event_wait_list, &event) else
        if (sema_objects<>nil) and (sema_objects.Length<>0) then
          ntv_EnqueueSignalSemaphoresKHR_3(command_queue, num_sema_objects, sema_objects[0], PUInt64(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueSignalSemaphoresKHR_3(command_queue, num_sema_objects, PCl_semaphore(nil)^, PUInt64(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSignalSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: array of cl_semaphore; sema_payload_list: array of UInt64; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode;
    type PCl_semaphore = ^cl_semaphore;
    type PUInt64 = ^UInt64;
    begin
      Result := if (sema_payload_list<>nil) and (sema_payload_list.Length<>0) then
        if (sema_objects<>nil) and (sema_objects.Length<>0) then
          ntv_EnqueueSignalSemaphoresKHR_4(command_queue, num_sema_objects, sema_objects[0], sema_payload_list[0], num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueSignalSemaphoresKHR_4(command_queue, num_sema_objects, PCl_semaphore(nil)^, sema_payload_list[0], num_events_in_wait_list, event_wait_list, &event) else
        if (sema_objects<>nil) and (sema_objects.Length<>0) then
          ntv_EnqueueSignalSemaphoresKHR_4(command_queue, num_sema_objects, sema_objects[0], PUInt64(nil)^, num_events_in_wait_list, event_wait_list, &event) else
          ntv_EnqueueSignalSemaphoresKHR_4(command_queue, num_sema_objects, PCl_semaphore(nil)^, PUInt64(nil)^, num_events_in_wait_list, event_wait_list, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSignalSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSignalSemaphoresKHR_1(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSignalSemaphoresKHR_1(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSignalSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSignalSemaphoresKHR_2(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSignalSemaphoresKHR_2(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSignalSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSignalSemaphoresKHR_1(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSignalSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSignalSemaphoresKHR_2(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSignalSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSignalSemaphoresKHR_3(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSignalSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSignalSemaphoresKHR_4(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSignalSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSignalSemaphoresKHR_5(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSignalSemaphoresKHR_5(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSignalSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSignalSemaphoresKHR_6(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSignalSemaphoresKHR_6(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSignalSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSignalSemaphoresKHR_5(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSignalSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSignalSemaphoresKHR_6(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSignalSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSignalSemaphoresKHR_7(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSignalSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; var sema_objects: cl_semaphore; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSignalSemaphoresKHR_8(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSignalSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSignalSemaphoresKHR_9(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSignalSemaphoresKHR_9(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSignalSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSignalSemaphoresKHR_10(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSignalSemaphoresKHR_10(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSignalSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSignalSemaphoresKHR_9(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSignalSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSignalSemaphoresKHR_10(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSignalSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSignalSemaphoresKHR_11(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSignalSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; var sema_payload_list: UInt64; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSignalSemaphoresKHR_12(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSignalSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; var &event: cl_event): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSignalSemaphoresKHR_13(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSignalSemaphoresKHR_13(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSignalSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: array of cl_event; &event: IntPtr): clErrorCode;
    type PCl_event = ^cl_event;
    begin
      Result := if (event_wait_list<>nil) and (event_wait_list.Length<>0) then
        ntv_EnqueueSignalSemaphoresKHR_14(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list[0], &event) else
        ntv_EnqueueSignalSemaphoresKHR_14(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, PCl_event(nil)^, &event);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSignalSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSignalSemaphoresKHR_13(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSignalSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; var event_wait_list: cl_event; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSignalSemaphoresKHR_14(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSignalSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; var &event: cl_event): clErrorCode :=
      ntv_EnqueueSignalSemaphoresKHR_15(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list, &event);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnqueueSignalSemaphoresKHR(command_queue: cl_command_queue; num_sema_objects: UInt32; sema_objects: IntPtr; sema_payload_list: IntPtr; num_events_in_wait_list: UInt32; event_wait_list: IntPtr; &event: IntPtr): clErrorCode :=
      ntv_EnqueueSignalSemaphoresKHR_16(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list, &event);
    
    public GetSemaphoreInfoKHR_adr := GetProcAddress('clGetSemaphoreInfoKHR');
    private ntv_GetSemaphoreInfoKHR_1 := GetProcOrNil&<function(sema_object: cl_semaphore; param_name: clSemaphoreInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode>(GetSemaphoreInfoKHR_adr);
    private ntv_GetSemaphoreInfoKHR_2 := GetProcOrNil&<function(sema_object: cl_semaphore; param_name: clSemaphoreInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode>(GetSemaphoreInfoKHR_adr);
    private ntv_GetSemaphoreInfoKHR_3 := GetProcOrNil&<function(sema_object: cl_semaphore; param_name: clSemaphoreInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode>(GetSemaphoreInfoKHR_adr);
    private ntv_GetSemaphoreInfoKHR_4 := GetProcOrNil&<function(sema_object: cl_semaphore; param_name: clSemaphoreInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode>(GetSemaphoreInfoKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSemaphoreInfoKHR<T>(sema_object: cl_semaphore; param_name: clSemaphoreInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetSemaphoreInfoKHR_1(sema_object, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSemaphoreInfoKHR<T>(sema_object: cl_semaphore; param_name: clSemaphoreInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetSemaphoreInfoKHR_2(sema_object, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSemaphoreInfoKHR(sema_object: cl_semaphore; param_name: clSemaphoreInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetSemaphoreInfoKHR_3(sema_object, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSemaphoreInfoKHR(sema_object: cl_semaphore; param_name: clSemaphoreInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetSemaphoreInfoKHR_4(sema_object, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSemaphoreInfoKHR_SEMAPHORE_CONTEXT(sema_object: cl_semaphore; var param_value: cl_context; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<cl_context>);
      var param_value_ret_size: UIntPtr;
      Result := GetSemaphoreInfoKHR(sema_object, clSemaphoreInfo.SEMAPHORE_CONTEXT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSemaphoreInfoKHR_SEMAPHORE_REFERENCE_COUNT(sema_object: cl_semaphore; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetSemaphoreInfoKHR(sema_object, clSemaphoreInfo.SEMAPHORE_REFERENCE_COUNT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSemaphoreInfoKHR_SEMAPHORE_PROPERTIES(sema_object: cl_semaphore; var param_value: clSemaphoreProperties; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clSemaphoreProperties>);
      var param_value_ret_size: UIntPtr;
      Result := GetSemaphoreInfoKHR(sema_object, clSemaphoreInfo.SEMAPHORE_PROPERTIES, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSemaphoreInfoKHR_SEMAPHORE_PAYLOAD(sema_object: cl_semaphore; var param_value: UInt64; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt64>);
      var param_value_ret_size: UIntPtr;
      Result := GetSemaphoreInfoKHR(sema_object, clSemaphoreInfo.SEMAPHORE_PAYLOAD, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSemaphoreInfoKHR_SEMAPHORE_TYPE(sema_object: cl_semaphore; var param_value: clSemaphoreType; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clSemaphoreType>);
      var param_value_ret_size: UIntPtr;
      Result := GetSemaphoreInfoKHR(sema_object, clSemaphoreInfo.SEMAPHORE_TYPE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSemaphoreInfoKHR_SEMAPHORE_EXPORT_HANDLE_TYPES(sema_object: cl_semaphore; var param_value: array of clExternalSemaphoreHandleType): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetSemaphoreInfoKHR_3(sema_object, clSemaphoreInfo.SEMAPHORE_EXPORT_HANDLE_TYPES, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new clExternalSemaphoreHandleType[param_value_sz.ToUInt64 div Marshal.SizeOf&<clExternalSemaphoreHandleType>];
      Result := GetSemaphoreInfoKHR(sema_object, clSemaphoreInfo.SEMAPHORE_EXPORT_HANDLE_TYPES, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSemaphoreInfoKHR_SEMAPHORE_EXPORT_HANDLE_TYPES(sema_object: cl_semaphore; param_value_count: UInt32; var param_value: clExternalSemaphoreHandleType): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<clExternalSemaphoreHandleType>);
      Result := GetSemaphoreInfoKHR(sema_object, clSemaphoreInfo.SEMAPHORE_EXPORT_HANDLE_TYPES, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSemaphoreInfoKHR_SEMAPHORE_DEVICE_HANDLE_LIST(sema_object: cl_semaphore; var param_value: array of cl_device_id): clErrorCode;
    begin
      var param_value_sz: UIntPtr;
      Result := ntv_GetSemaphoreInfoKHR_3(sema_object, clSemaphoreInfo.SEMAPHORE_DEVICE_HANDLE_LIST, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new cl_device_id[param_value_sz.ToUInt64 div Marshal.SizeOf&<cl_device_id>];
      Result := GetSemaphoreInfoKHR(sema_object, clSemaphoreInfo.SEMAPHORE_DEVICE_HANDLE_LIST, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSemaphoreInfoKHR_SEMAPHORE_DEVICE_HANDLE_LIST(sema_object: cl_semaphore; param_value_count: UInt32; var param_value: cl_device_id): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<cl_device_id>);
      Result := GetSemaphoreInfoKHR(sema_object, clSemaphoreInfo.SEMAPHORE_DEVICE_HANDLE_LIST, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSemaphoreInfoKHR_SEMAPHORE_EXPORTABLE(sema_object: cl_semaphore; var param_value: clBool; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<clBool>);
      var param_value_ret_size: UIntPtr;
      Result := GetSemaphoreInfoKHR(sema_object, clSemaphoreInfo.SEMAPHORE_EXPORTABLE, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    
    public ReleaseSemaphoreKHR_adr := GetProcAddress('clReleaseSemaphoreKHR');
    private ntv_ReleaseSemaphoreKHR_1 := GetProcOrNil&<function(sema_object: cl_semaphore): clErrorCode>(ReleaseSemaphoreKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseSemaphoreKHR(sema_object: cl_semaphore): clErrorCode :=
      ntv_ReleaseSemaphoreKHR_1(sema_object);
    
    public RetainSemaphoreKHR_adr := GetProcAddress('clRetainSemaphoreKHR');
    private ntv_RetainSemaphoreKHR_1 := GetProcOrNil&<function(sema_object: cl_semaphore): clErrorCode>(RetainSemaphoreKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function RetainSemaphoreKHR(sema_object: cl_semaphore): clErrorCode :=
      ntv_RetainSemaphoreKHR_1(sema_object);
    
  end;
  
  ///
  clSpirKHR = static class
    public const ExtensionString = 'cl_khr_spir';
  end;
  
  ///
  clSubgroupNamedBarrierKHR = static class
    public const ExtensionString = 'cl_khr_subgroup_named_barrier';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clSubgroupsKHR = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clSubgroupsKHR(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_khr_subgroups';
    
    public GetKernelSubGroupInfoKHR_adr := GetProcAddress('clGetKernelSubGroupInfoKHR');
    private ntv_GetKernelSubGroupInfoKHR_1 := GetProcOrNil&<function(in_kernel: cl_kernel; in_device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; var input_value: Byte; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode>(GetKernelSubGroupInfoKHR_adr);
    private ntv_GetKernelSubGroupInfoKHR_2 := GetProcOrNil&<function(in_kernel: cl_kernel; in_device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; var input_value: Byte; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode>(GetKernelSubGroupInfoKHR_adr);
    private ntv_GetKernelSubGroupInfoKHR_3 := GetProcOrNil&<function(in_kernel: cl_kernel; in_device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; var input_value: Byte; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode>(GetKernelSubGroupInfoKHR_adr);
    private ntv_GetKernelSubGroupInfoKHR_4 := GetProcOrNil&<function(in_kernel: cl_kernel; in_device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; var input_value: Byte; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode>(GetKernelSubGroupInfoKHR_adr);
    private ntv_GetKernelSubGroupInfoKHR_5 := GetProcOrNil&<function(in_kernel: cl_kernel; in_device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; input_value: pointer; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode>(GetKernelSubGroupInfoKHR_adr);
    private ntv_GetKernelSubGroupInfoKHR_6 := GetProcOrNil&<function(in_kernel: cl_kernel; in_device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; input_value: pointer; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode>(GetKernelSubGroupInfoKHR_adr);
    private ntv_GetKernelSubGroupInfoKHR_7 := GetProcOrNil&<function(in_kernel: cl_kernel; in_device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; input_value: pointer; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode>(GetKernelSubGroupInfoKHR_adr);
    private ntv_GetKernelSubGroupInfoKHR_8 := GetProcOrNil&<function(in_kernel: cl_kernel; in_device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; input_value: pointer; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode>(GetKernelSubGroupInfoKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetKernelSubGroupInfoKHR<TInp,T>(in_kernel: cl_kernel; in_device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; var input_value: TInp; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where TInp, T: record;
    begin
      Result := ntv_GetKernelSubGroupInfoKHR_1(in_kernel, in_device, param_name, input_value_size, PByte(pointer(@input_value))^, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetKernelSubGroupInfoKHR<TInp,T>(in_kernel: cl_kernel; in_device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; var input_value: TInp; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where TInp, T: record;
    begin
      Result := ntv_GetKernelSubGroupInfoKHR_2(in_kernel, in_device, param_name, input_value_size, PByte(pointer(@input_value))^, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetKernelSubGroupInfoKHR<TInp>(in_kernel: cl_kernel; in_device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; var input_value: TInp; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode; where TInp: record;
    begin
      Result := ntv_GetKernelSubGroupInfoKHR_3(in_kernel, in_device, param_name, input_value_size, PByte(pointer(@input_value))^, param_value_size, param_value, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetKernelSubGroupInfoKHR<TInp>(in_kernel: cl_kernel; in_device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; var input_value: TInp; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode; where TInp: record;
    begin
      Result := ntv_GetKernelSubGroupInfoKHR_4(in_kernel, in_device, param_name, input_value_size, PByte(pointer(@input_value))^, param_value_size, param_value, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetKernelSubGroupInfoKHR<T>(in_kernel: cl_kernel; in_device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; input_value: pointer; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetKernelSubGroupInfoKHR_5(in_kernel, in_device, param_name, input_value_size, input_value, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetKernelSubGroupInfoKHR<T>(in_kernel: cl_kernel; in_device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; input_value: pointer; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetKernelSubGroupInfoKHR_6(in_kernel, in_device, param_name, input_value_size, input_value, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetKernelSubGroupInfoKHR(in_kernel: cl_kernel; in_device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; input_value: pointer; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetKernelSubGroupInfoKHR_7(in_kernel, in_device, param_name, input_value_size, input_value, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetKernelSubGroupInfoKHR(in_kernel: cl_kernel; in_device: cl_device_id; param_name: clKernelSubGroupInfo; input_value_size: UIntPtr; input_value: pointer; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetKernelSubGroupInfoKHR_8(in_kernel, in_device, param_name, input_value_size, input_value, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetKernelSubGroupInfoKHR_KERNEL_LOCAL_SIZE_FOR_SUB_GROUP_COUNT(in_kernel: cl_kernel; in_device: cl_device_id; input_value: UIntPtr; var param_value: array of UIntPtr): clErrorCode;
    begin
      var input_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_sz: UIntPtr;
      Result := GetKernelSubGroupInfoKHR(in_kernel, in_device, clKernelSubGroupInfo.KERNEL_LOCAL_SIZE_FOR_SUB_GROUP_COUNT, input_value_sz,input_value, UIntPtr.Zero,nil,param_value_sz);
      if Result.IS_ERROR then exit;
      if param_value_sz = UIntPtr.Zero then
      begin
        param_value := nil;
        exit;
      end;
      var param_value_temp_res := new UIntPtr[param_value_sz.ToUInt64 div Marshal.SizeOf&<UIntPtr>];
      Result := GetKernelSubGroupInfoKHR(in_kernel, in_device, clKernelSubGroupInfo.KERNEL_LOCAL_SIZE_FOR_SUB_GROUP_COUNT, input_value_sz,input_value, param_value_sz,param_value_temp_res[0],IntPtr.Zero);
      param_value := param_value_temp_res;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetKernelSubGroupInfoKHR_KERNEL_LOCAL_SIZE_FOR_SUB_GROUP_COUNT(in_kernel: cl_kernel; in_device: cl_device_id; input_value: UIntPtr; param_value_count: UInt32; var param_value: UIntPtr): clErrorCode;
    begin
      var input_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_sz := new UIntPtr(param_value_count*Marshal.SizeOf&<UIntPtr>);
      Result := GetKernelSubGroupInfoKHR(in_kernel, in_device, clKernelSubGroupInfo.KERNEL_LOCAL_SIZE_FOR_SUB_GROUP_COUNT, input_value_sz,input_value, param_value_sz,param_value,IntPtr.Zero);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetKernelSubGroupInfoKHR_KERNEL_MAX_NUM_SUB_GROUPS(in_kernel: cl_kernel; in_device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelSubGroupInfoKHR(in_kernel, in_device, clKernelSubGroupInfo.KERNEL_MAX_NUM_SUB_GROUPS, UIntPtr.Zero,nil, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetKernelSubGroupInfoKHR_KERNEL_COMPILE_NUM_SUB_GROUPS(in_kernel: cl_kernel; in_device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelSubGroupInfoKHR(in_kernel, in_device, clKernelSubGroupInfo.KERNEL_COMPILE_NUM_SUB_GROUPS, UIntPtr.Zero,nil, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetKernelSubGroupInfoKHR_KERNEL_MAX_SUB_GROUP_SIZE_FOR_NDRANGE(in_kernel: cl_kernel; in_device: cl_device_id; input_value: array of UIntPtr; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var input_value_sz := new UIntPtr(input_value.Length*Marshal.SizeOf&<UIntPtr>);
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelSubGroupInfoKHR(in_kernel, in_device, clKernelSubGroupInfo.KERNEL_MAX_SUB_GROUP_SIZE_FOR_NDRANGE, input_value_sz,input_value[0], param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetKernelSubGroupInfoKHR_KERNEL_MAX_SUB_GROUP_SIZE_FOR_NDRANGE(in_kernel: cl_kernel; in_device: cl_device_id; input_value_count: UInt32; var input_value: UIntPtr; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var input_value_sz := new UIntPtr(input_value_count*Marshal.SizeOf&<UIntPtr>);
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelSubGroupInfoKHR(in_kernel, in_device, clKernelSubGroupInfo.KERNEL_MAX_SUB_GROUP_SIZE_FOR_NDRANGE, input_value_sz,input_value, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetKernelSubGroupInfoKHR_KERNEL_SUB_GROUP_COUNT_FOR_NDRANGE(in_kernel: cl_kernel; in_device: cl_device_id; input_value: array of UIntPtr; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var input_value_sz := new UIntPtr(input_value.Length*Marshal.SizeOf&<UIntPtr>);
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelSubGroupInfoKHR(in_kernel, in_device, clKernelSubGroupInfo.KERNEL_SUB_GROUP_COUNT_FOR_NDRANGE, input_value_sz,input_value[0], param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetKernelSubGroupInfoKHR_KERNEL_SUB_GROUP_COUNT_FOR_NDRANGE(in_kernel: cl_kernel; in_device: cl_device_id; input_value_count: UInt32; var input_value: UIntPtr; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var input_value_sz := new UIntPtr(input_value_count*Marshal.SizeOf&<UIntPtr>);
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelSubGroupInfoKHR(in_kernel, in_device, clKernelSubGroupInfo.KERNEL_SUB_GROUP_COUNT_FOR_NDRANGE, input_value_sz,input_value, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetKernelSubGroupInfoKHR_KERNEL_COMPILE_SUB_GROUP_SIZE(in_kernel: cl_kernel; in_device: cl_device_id; var param_value: UIntPtr; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UIntPtr>);
      var param_value_ret_size: UIntPtr;
      Result := GetKernelSubGroupInfoKHR(in_kernel, in_device, clKernelSubGroupInfo.KERNEL_COMPILE_SUB_GROUP_SIZE, UIntPtr.Zero,nil, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clSuggestedLocalWorkSizeKHR = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clSuggestedLocalWorkSizeKHR(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_khr_suggested_local_work_size';
    
    public GetKernelSuggestedLocalWorkSizeKHR_adr := GetProcAddress('clGetKernelSuggestedLocalWorkSizeKHR');
    private ntv_GetKernelSuggestedLocalWorkSizeKHR_1 := GetProcOrNil&<function(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; var suggested_local_work_size: UIntPtr): clErrorCode>(GetKernelSuggestedLocalWorkSizeKHR_adr);
    private ntv_GetKernelSuggestedLocalWorkSizeKHR_2 := GetProcOrNil&<function(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; suggested_local_work_size: IntPtr): clErrorCode>(GetKernelSuggestedLocalWorkSizeKHR_adr);
    private ntv_GetKernelSuggestedLocalWorkSizeKHR_3 := GetProcOrNil&<function(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; global_work_size: IntPtr; var suggested_local_work_size: UIntPtr): clErrorCode>(GetKernelSuggestedLocalWorkSizeKHR_adr);
    private ntv_GetKernelSuggestedLocalWorkSizeKHR_4 := GetProcOrNil&<function(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; global_work_size: IntPtr; suggested_local_work_size: IntPtr): clErrorCode>(GetKernelSuggestedLocalWorkSizeKHR_adr);
    private ntv_GetKernelSuggestedLocalWorkSizeKHR_5 := GetProcOrNil&<function(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; var suggested_local_work_size: UIntPtr): clErrorCode>(GetKernelSuggestedLocalWorkSizeKHR_adr);
    private ntv_GetKernelSuggestedLocalWorkSizeKHR_6 := GetProcOrNil&<function(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; suggested_local_work_size: IntPtr): clErrorCode>(GetKernelSuggestedLocalWorkSizeKHR_adr);
    private ntv_GetKernelSuggestedLocalWorkSizeKHR_7 := GetProcOrNil&<function(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; global_work_size: IntPtr; var suggested_local_work_size: UIntPtr): clErrorCode>(GetKernelSuggestedLocalWorkSizeKHR_adr);
    private ntv_GetKernelSuggestedLocalWorkSizeKHR_8 := GetProcOrNil&<function(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; global_work_size: IntPtr; suggested_local_work_size: IntPtr): clErrorCode>(GetKernelSuggestedLocalWorkSizeKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetKernelSuggestedLocalWorkSizeKHR(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: array of UIntPtr; global_work_size: array of UIntPtr; var suggested_local_work_size: UIntPtr): clErrorCode;
    type PUIntPtr = ^UIntPtr;
    begin
      Result := if (global_work_offset<>nil) and (global_work_offset.Length<>0) then
        if (global_work_size<>nil) and (global_work_size.Length<>0) then
          ntv_GetKernelSuggestedLocalWorkSizeKHR_1(command_queue, kernel, work_dim, global_work_offset[0], global_work_size[0], suggested_local_work_size) else
          ntv_GetKernelSuggestedLocalWorkSizeKHR_1(command_queue, kernel, work_dim, global_work_offset[0], PUIntPtr(nil)^, suggested_local_work_size) else
        if (global_work_size<>nil) and (global_work_size.Length<>0) then
          ntv_GetKernelSuggestedLocalWorkSizeKHR_1(command_queue, kernel, work_dim, PUIntPtr(nil)^, global_work_size[0], suggested_local_work_size) else
          ntv_GetKernelSuggestedLocalWorkSizeKHR_1(command_queue, kernel, work_dim, PUIntPtr(nil)^, PUIntPtr(nil)^, suggested_local_work_size);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetKernelSuggestedLocalWorkSizeKHR(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: array of UIntPtr; global_work_size: array of UIntPtr; suggested_local_work_size: IntPtr): clErrorCode;
    type PUIntPtr = ^UIntPtr;
    begin
      Result := if (global_work_offset<>nil) and (global_work_offset.Length<>0) then
        if (global_work_size<>nil) and (global_work_size.Length<>0) then
          ntv_GetKernelSuggestedLocalWorkSizeKHR_2(command_queue, kernel, work_dim, global_work_offset[0], global_work_size[0], suggested_local_work_size) else
          ntv_GetKernelSuggestedLocalWorkSizeKHR_2(command_queue, kernel, work_dim, global_work_offset[0], PUIntPtr(nil)^, suggested_local_work_size) else
        if (global_work_size<>nil) and (global_work_size.Length<>0) then
          ntv_GetKernelSuggestedLocalWorkSizeKHR_2(command_queue, kernel, work_dim, PUIntPtr(nil)^, global_work_size[0], suggested_local_work_size) else
          ntv_GetKernelSuggestedLocalWorkSizeKHR_2(command_queue, kernel, work_dim, PUIntPtr(nil)^, PUIntPtr(nil)^, suggested_local_work_size);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetKernelSuggestedLocalWorkSizeKHR(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; var suggested_local_work_size: UIntPtr): clErrorCode :=
      ntv_GetKernelSuggestedLocalWorkSizeKHR_1(command_queue, kernel, work_dim, global_work_offset, global_work_size, suggested_local_work_size);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetKernelSuggestedLocalWorkSizeKHR(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; var global_work_size: UIntPtr; suggested_local_work_size: IntPtr): clErrorCode :=
      ntv_GetKernelSuggestedLocalWorkSizeKHR_2(command_queue, kernel, work_dim, global_work_offset, global_work_size, suggested_local_work_size);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetKernelSuggestedLocalWorkSizeKHR(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; global_work_size: IntPtr; var suggested_local_work_size: UIntPtr): clErrorCode :=
      ntv_GetKernelSuggestedLocalWorkSizeKHR_3(command_queue, kernel, work_dim, global_work_offset, global_work_size, suggested_local_work_size);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetKernelSuggestedLocalWorkSizeKHR(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; var global_work_offset: UIntPtr; global_work_size: IntPtr; suggested_local_work_size: IntPtr): clErrorCode :=
      ntv_GetKernelSuggestedLocalWorkSizeKHR_4(command_queue, kernel, work_dim, global_work_offset, global_work_size, suggested_local_work_size);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetKernelSuggestedLocalWorkSizeKHR(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; var suggested_local_work_size: UIntPtr): clErrorCode :=
      ntv_GetKernelSuggestedLocalWorkSizeKHR_5(command_queue, kernel, work_dim, global_work_offset, global_work_size, suggested_local_work_size);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetKernelSuggestedLocalWorkSizeKHR(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; var global_work_size: UIntPtr; suggested_local_work_size: IntPtr): clErrorCode :=
      ntv_GetKernelSuggestedLocalWorkSizeKHR_6(command_queue, kernel, work_dim, global_work_offset, global_work_size, suggested_local_work_size);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetKernelSuggestedLocalWorkSizeKHR(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; global_work_size: IntPtr; var suggested_local_work_size: UIntPtr): clErrorCode :=
      ntv_GetKernelSuggestedLocalWorkSizeKHR_7(command_queue, kernel, work_dim, global_work_offset, global_work_size, suggested_local_work_size);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetKernelSuggestedLocalWorkSizeKHR(command_queue: cl_command_queue; kernel: cl_kernel; work_dim: UInt32; global_work_offset: IntPtr; global_work_size: IntPtr; suggested_local_work_size: IntPtr): clErrorCode :=
      ntv_GetKernelSuggestedLocalWorkSizeKHR_8(command_queue, kernel, work_dim, global_work_offset, global_work_size, suggested_local_work_size);
    
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clTerminateContextKHR = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clTerminateContextKHR(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_khr_terminate_context';
    
    public TerminateContextKHR_adr := GetProcAddress('clTerminateContextKHR');
    private ntv_TerminateContextKHR_1 := GetProcOrNil&<function(context: cl_context): clErrorCode>(TerminateContextKHR_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function TerminateContextKHR(context: cl_context): clErrorCode :=
      ntv_TerminateContextKHR_1(context);
    
  end;
  
  ///
  clThrottleHintsKHR = static class
    public const ExtensionString = 'cl_khr_throttle_hints';
  end;
  
  ///
  clDeviceAttributeQueryNV = static class
    public const ExtensionString = 'cl_nv_device_attribute_query';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clContentSizePOCL = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clContentSizePOCL(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_pocl_content_size';
    
    public SetContentSizeBufferPOCL_adr := GetProcAddress('clSetContentSizeBufferPoCL');
    private ntv_SetContentSizeBufferPOCL_1 := GetProcOrNil&<function(buffer: cl_mem; content_size_buffer: cl_mem): clErrorCode>(SetContentSizeBufferPOCL_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetContentSizeBufferPOCL(buffer: cl_mem; content_size_buffer: cl_mem): clErrorCode :=
      ntv_SetContentSizeBufferPOCL_1(buffer, content_size_buffer);
    
  end;
  
  ///
  clAndroidNativeBufferHostPtrQCOM = static class
    public const ExtensionString = 'cl_qcom_android_native_buffer_host_ptr';
  end;
  
  [PCUNotRestore]
  [System.Security.SuppressUnmanagedCodeSecurity]
  ///
  clExtHostPtrQCOM = sealed partial class
    public constructor(pl: cl_platform_id);
    private constructor := raise new System.NotSupportedException;
    public static PlatformLess := new clExtHostPtrQCOM(default(cl_platform_id));
    private function GetProcAddress(name: string): IntPtr;
    private static function GetProcOrNil<T>(fadr: IntPtr) :=
      fadr=IntPtr.Zero ? default(T) :
        Marshal.GetDelegateForFunctionPointer&<T>(fadr);
    public const ExtensionString = 'cl_qcom_ext_host_ptr';
    
    public GetDeviceImageInfoQCOM_adr := GetProcAddress('clGetDeviceImageInfoQCOM');
    private ntv_GetDeviceImageInfoQCOM_1 := GetProcOrNil&<function(device: cl_device_id; image_width: UIntPtr; image_height: UIntPtr; var image_format: cl_image_format; param_name: clImagePitchInfo; param_value_size: UIntPtr; var param_value: Byte; var param_value_size_ret: UIntPtr): clErrorCode>(GetDeviceImageInfoQCOM_adr);
    private ntv_GetDeviceImageInfoQCOM_2 := GetProcOrNil&<function(device: cl_device_id; image_width: UIntPtr; image_height: UIntPtr; var image_format: cl_image_format; param_name: clImagePitchInfo; param_value_size: UIntPtr; var param_value: Byte; param_value_size_ret: IntPtr): clErrorCode>(GetDeviceImageInfoQCOM_adr);
    private ntv_GetDeviceImageInfoQCOM_3 := GetProcOrNil&<function(device: cl_device_id; image_width: UIntPtr; image_height: UIntPtr; var image_format: cl_image_format; param_name: clImagePitchInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode>(GetDeviceImageInfoQCOM_adr);
    private ntv_GetDeviceImageInfoQCOM_4 := GetProcOrNil&<function(device: cl_device_id; image_width: UIntPtr; image_height: UIntPtr; var image_format: cl_image_format; param_name: clImagePitchInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode>(GetDeviceImageInfoQCOM_adr);
    private ntv_GetDeviceImageInfoQCOM_5 := GetProcOrNil&<function(device: cl_device_id; image_width: UIntPtr; image_height: UIntPtr; image_format: IntPtr; param_name: clImagePitchInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode>(GetDeviceImageInfoQCOM_adr);
    private ntv_GetDeviceImageInfoQCOM_6 := GetProcOrNil&<function(device: cl_device_id; image_width: UIntPtr; image_height: UIntPtr; image_format: IntPtr; param_name: clImagePitchInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode>(GetDeviceImageInfoQCOM_adr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDeviceImageInfoQCOM<T>(device: cl_device_id; image_width: UIntPtr; image_height: UIntPtr; var image_format: cl_image_format; param_name: clImagePitchInfo; param_value_size: UIntPtr; var param_value: T; var param_value_size_ret: UIntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetDeviceImageInfoQCOM_1(device, image_width, image_height, image_format, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDeviceImageInfoQCOM<T>(device: cl_device_id; image_width: UIntPtr; image_height: UIntPtr; var image_format: cl_image_format; param_name: clImagePitchInfo; param_value_size: UIntPtr; var param_value: T; param_value_size_ret: IntPtr): clErrorCode; where T: record;
    begin
      Result := ntv_GetDeviceImageInfoQCOM_2(device, image_width, image_height, image_format, param_name, param_value_size, PByte(pointer(@param_value))^, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDeviceImageInfoQCOM_IMAGE_ROW_PITCH(device: cl_device_id; image_width: UIntPtr; image_height: UIntPtr; var image_format: cl_image_format; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceImageInfoQCOM(device, image_width, image_height, image_format, clImagePitchInfo.IMAGE_ROW_PITCH, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDeviceImageInfoQCOM_IMAGE_SLICE_PITCH(device: cl_device_id; image_width: UIntPtr; image_height: UIntPtr; var image_format: cl_image_format; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceImageInfoQCOM(device, image_width, image_height, image_format, clImagePitchInfo.IMAGE_SLICE_PITCH, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDeviceImageInfoQCOM_IMAGE_ROW_ALIGNMENT(device: cl_device_id; image_width: UIntPtr; image_height: UIntPtr; var image_format: cl_image_format; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceImageInfoQCOM(device, image_width, image_height, image_format, clImagePitchInfo.IMAGE_ROW_ALIGNMENT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDeviceImageInfoQCOM_IMAGE_SLICE_ALIGNMENT(device: cl_device_id; image_width: UIntPtr; image_height: UIntPtr; var image_format: cl_image_format; var param_value: UInt32; param_value_validate_size: boolean := false): clErrorCode;
    begin
      var param_value_sz := new UIntPtr(Marshal.SizeOf&<UInt32>);
      var param_value_ret_size: UIntPtr;
      Result := GetDeviceImageInfoQCOM(device, image_width, image_height, image_format, clImagePitchInfo.IMAGE_SLICE_ALIGNMENT, param_value_sz,param_value,param_value_ret_size);
      if param_value_validate_size and (param_value_ret_size<>param_value_sz) then
        raise new InvalidOperationException($'Implementation returned a size of {param_value_ret_size} instead of {param_value_sz}');
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDeviceImageInfoQCOM(device: cl_device_id; image_width: UIntPtr; image_height: UIntPtr; image_format: array of cl_image_format; param_name: clImagePitchInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode;
    type PCl_image_format = ^cl_image_format;
    begin
      Result := if (image_format<>nil) and (image_format.Length<>0) then
        ntv_GetDeviceImageInfoQCOM_3(device, image_width, image_height, image_format[0], param_name, param_value_size, param_value, param_value_size_ret) else
        ntv_GetDeviceImageInfoQCOM_3(device, image_width, image_height, PCl_image_format(nil)^, param_name, param_value_size, param_value, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDeviceImageInfoQCOM(device: cl_device_id; image_width: UIntPtr; image_height: UIntPtr; image_format: array of cl_image_format; param_name: clImagePitchInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode;
    type PCl_image_format = ^cl_image_format;
    begin
      Result := if (image_format<>nil) and (image_format.Length<>0) then
        ntv_GetDeviceImageInfoQCOM_4(device, image_width, image_height, image_format[0], param_name, param_value_size, param_value, param_value_size_ret) else
        ntv_GetDeviceImageInfoQCOM_4(device, image_width, image_height, PCl_image_format(nil)^, param_name, param_value_size, param_value, param_value_size_ret);
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDeviceImageInfoQCOM(device: cl_device_id; image_width: UIntPtr; image_height: UIntPtr; var image_format: cl_image_format; param_name: clImagePitchInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetDeviceImageInfoQCOM_3(device, image_width, image_height, image_format, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDeviceImageInfoQCOM(device: cl_device_id; image_width: UIntPtr; image_height: UIntPtr; var image_format: cl_image_format; param_name: clImagePitchInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetDeviceImageInfoQCOM_4(device, image_width, image_height, image_format, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDeviceImageInfoQCOM(device: cl_device_id; image_width: UIntPtr; image_height: UIntPtr; image_format: IntPtr; param_name: clImagePitchInfo; param_value_size: UIntPtr; param_value: pointer; var param_value_size_ret: UIntPtr): clErrorCode :=
      ntv_GetDeviceImageInfoQCOM_5(device, image_width, image_height, image_format, param_name, param_value_size, param_value, param_value_size_ret);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDeviceImageInfoQCOM(device: cl_device_id; image_width: UIntPtr; image_height: UIntPtr; image_format: IntPtr; param_name: clImagePitchInfo; param_value_size: UIntPtr; param_value: pointer; param_value_size_ret: IntPtr): clErrorCode :=
      ntv_GetDeviceImageInfoQCOM_6(device, image_width, image_height, image_format, param_name, param_value_size, param_value, param_value_size_ret);
    
  end;
  
  ///
  clExtHostPtrIocoherentQCOM = static class
    public const ExtensionString = 'cl_qcom_ext_host_ptr_iocoherent';
  end;
  
  ///
  clIonHostPtrQCOM = static class
    public const ExtensionString = 'cl_qcom_ion_host_ptr';
  end;
  
  {$endregion Подпрограммы расширений}
  
implementation

{$region Особые типы}

type
  platform_id = cl_platform_id;
  loadable_platform = record
    private id: platform_id;
    
    private static function clGetExtensionFunctionAddressForPlatform(pl: platform_id; name: string): IntPtr; external 'OpenCL';
    public function GetProcAddress(name: string) := clGetExtensionFunctionAddressForPlatform(self.id, name);
    
  end;
  cl_extension_base = abstract class
    public pl: loadable_platform;
    
    public constructor(pl: platform_id) := self.pl.id := pl;
    
  end;
  
procedure clErrorCode.RaiseIfError :=
  if IS_ERROR then raise new OpenCLException(self);

{$endregion Особые типы}

{$region Инициализаторы расширений}

type clLoaderInfo = sealed partial class(cl_extension_base) end;
constructor clLoaderInfo.Create(pl: cl_platform_id) := inherited Create(pl);
function clLoaderInfo.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clLoaderLayers = sealed partial class(cl_extension_base) end;
constructor clLoaderLayers.Create(pl: cl_platform_id) := inherited Create(pl);
function clLoaderLayers.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clContextLoggingFunctionsAPPLE = sealed partial class(cl_extension_base) end;
constructor clContextLoggingFunctionsAPPLE.Create(pl: cl_platform_id) := inherited Create(pl);
function clContextLoggingFunctionsAPPLE.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clSetMemObjectDestructorAPPLE = sealed partial class(cl_extension_base) end;
constructor clSetMemObjectDestructorAPPLE.Create(pl: cl_platform_id) := inherited Create(pl);
function clSetMemObjectDestructorAPPLE.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clImportMemoryARM = sealed partial class(cl_extension_base) end;
constructor clImportMemoryARM.Create(pl: cl_platform_id) := inherited Create(pl);
function clImportMemoryARM.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clSharedVirtualMemoryARM = sealed partial class(cl_extension_base) end;
constructor clSharedVirtualMemoryARM.Create(pl: cl_platform_id) := inherited Create(pl);
function clSharedVirtualMemoryARM.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clDeviceFissionEXT = sealed partial class(cl_extension_base) end;
constructor clDeviceFissionEXT.Create(pl: cl_platform_id) := inherited Create(pl);
function clDeviceFissionEXT.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clImageRequirementsInfoEXT = sealed partial class(cl_extension_base) end;
constructor clImageRequirementsInfoEXT.Create(pl: cl_platform_id) := inherited Create(pl);
function clImageRequirementsInfoEXT.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clMigrateMemobjectEXT = sealed partial class(cl_extension_base) end;
constructor clMigrateMemobjectEXT.Create(pl: cl_platform_id) := inherited Create(pl);
function clMigrateMemobjectEXT.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clGenerateMipmapIMG = sealed partial class(cl_extension_base) end;
constructor clGenerateMipmapIMG.Create(pl: cl_platform_id) := inherited Create(pl);
function clGenerateMipmapIMG.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clUseGrallocPtrIMG = sealed partial class(cl_extension_base) end;
constructor clUseGrallocPtrIMG.Create(pl: cl_platform_id) := inherited Create(pl);
function clUseGrallocPtrIMG.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clAcceleratorINTEL = sealed partial class(cl_extension_base) end;
constructor clAcceleratorINTEL.Create(pl: cl_platform_id) := inherited Create(pl);
function clAcceleratorINTEL.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clCreateBufferWithPropertiesINTEL = sealed partial class(cl_extension_base) end;
constructor clCreateBufferWithPropertiesINTEL.Create(pl: cl_platform_id) := inherited Create(pl);
function clCreateBufferWithPropertiesINTEL.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clDx9MediaSharingINTEL = sealed partial class(cl_extension_base) end;
constructor clDx9MediaSharingINTEL.Create(pl: cl_platform_id) := inherited Create(pl);
function clDx9MediaSharingINTEL.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clProgramScopeHostPipeINTEL = sealed partial class(cl_extension_base) end;
constructor clProgramScopeHostPipeINTEL.Create(pl: cl_platform_id) := inherited Create(pl);
function clProgramScopeHostPipeINTEL.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clSharingFormatQueryD3d10INTEL = sealed partial class(cl_extension_base) end;
constructor clSharingFormatQueryD3d10INTEL.Create(pl: cl_platform_id) := inherited Create(pl);
function clSharingFormatQueryD3d10INTEL.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clSharingFormatQueryD3d11INTEL = sealed partial class(cl_extension_base) end;
constructor clSharingFormatQueryD3d11INTEL.Create(pl: cl_platform_id) := inherited Create(pl);
function clSharingFormatQueryD3d11INTEL.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clSharingFormatQueryDx9INTEL = sealed partial class(cl_extension_base) end;
constructor clSharingFormatQueryDx9INTEL.Create(pl: cl_platform_id) := inherited Create(pl);
function clSharingFormatQueryDx9INTEL.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clSharingFormatQueryGlINTEL = sealed partial class(cl_extension_base) end;
constructor clSharingFormatQueryGlINTEL.Create(pl: cl_platform_id) := inherited Create(pl);
function clSharingFormatQueryGlINTEL.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clSharingFormatQueryVaApiINTEL = sealed partial class(cl_extension_base) end;
constructor clSharingFormatQueryVaApiINTEL.Create(pl: cl_platform_id) := inherited Create(pl);
function clSharingFormatQueryVaApiINTEL.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clUnifiedSharedMemoryINTEL = sealed partial class(cl_extension_base) end;
constructor clUnifiedSharedMemoryINTEL.Create(pl: cl_platform_id) := inherited Create(pl);
function clUnifiedSharedMemoryINTEL.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clVaApiMediaSharingINTEL = sealed partial class(cl_extension_base) end;
constructor clVaApiMediaSharingINTEL.Create(pl: cl_platform_id) := inherited Create(pl);
function clVaApiMediaSharingINTEL.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clCommandBufferKHR = sealed partial class(cl_extension_base) end;
constructor clCommandBufferKHR.Create(pl: cl_platform_id) := inherited Create(pl);
function clCommandBufferKHR.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clCommandBufferMultiDeviceKHR = sealed partial class(cl_extension_base) end;
constructor clCommandBufferMultiDeviceKHR.Create(pl: cl_platform_id) := inherited Create(pl);
function clCommandBufferMultiDeviceKHR.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clCommandBufferMutableDispatchKHR = sealed partial class(cl_extension_base) end;
constructor clCommandBufferMutableDispatchKHR.Create(pl: cl_platform_id) := inherited Create(pl);
function clCommandBufferMutableDispatchKHR.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clCreateCommandQueueKHR = sealed partial class(cl_extension_base) end;
constructor clCreateCommandQueueKHR.Create(pl: cl_platform_id) := inherited Create(pl);
function clCreateCommandQueueKHR.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clD3d10SharingKHR = sealed partial class(cl_extension_base) end;
constructor clD3d10SharingKHR.Create(pl: cl_platform_id) := inherited Create(pl);
function clD3d10SharingKHR.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clD3d11SharingKHR = sealed partial class(cl_extension_base) end;
constructor clD3d11SharingKHR.Create(pl: cl_platform_id) := inherited Create(pl);
function clD3d11SharingKHR.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clDx9MediaSharingKHR = sealed partial class(cl_extension_base) end;
constructor clDx9MediaSharingKHR.Create(pl: cl_platform_id) := inherited Create(pl);
function clDx9MediaSharingKHR.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clEglEventKHR = sealed partial class(cl_extension_base) end;
constructor clEglEventKHR.Create(pl: cl_platform_id) := inherited Create(pl);
function clEglEventKHR.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clEglImageKHR = sealed partial class(cl_extension_base) end;
constructor clEglImageKHR.Create(pl: cl_platform_id) := inherited Create(pl);
function clEglImageKHR.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clExternalMemoryKHR = sealed partial class(cl_extension_base) end;
constructor clExternalMemoryKHR.Create(pl: cl_platform_id) := inherited Create(pl);
function clExternalMemoryKHR.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clExternalSemaphoreKHR = sealed partial class(cl_extension_base) end;
constructor clExternalSemaphoreKHR.Create(pl: cl_platform_id) := inherited Create(pl);
function clExternalSemaphoreKHR.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clExternalSemaphoreSyncFdKHR = sealed partial class(cl_extension_base) end;
constructor clExternalSemaphoreSyncFdKHR.Create(pl: cl_platform_id) := inherited Create(pl);
function clExternalSemaphoreSyncFdKHR.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clGLSharingKHR = sealed partial class(cl_extension_base) end;
constructor clGLSharingKHR.Create(pl: cl_platform_id) := inherited Create(pl);
function clGLSharingKHR.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clGLEventKHR = sealed partial class(cl_extension_base) end;
constructor clGLEventKHR.Create(pl: cl_platform_id) := inherited Create(pl);
function clGLEventKHR.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clIcdKHR = sealed partial class(cl_extension_base) end;
constructor clIcdKHR.Create(pl: cl_platform_id) := inherited Create(pl);
function clIcdKHR.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clIlProgramKHR = sealed partial class(cl_extension_base) end;
constructor clIlProgramKHR.Create(pl: cl_platform_id) := inherited Create(pl);
function clIlProgramKHR.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clSemaphoreKHR = sealed partial class(cl_extension_base) end;
constructor clSemaphoreKHR.Create(pl: cl_platform_id) := inherited Create(pl);
function clSemaphoreKHR.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clSubgroupsKHR = sealed partial class(cl_extension_base) end;
constructor clSubgroupsKHR.Create(pl: cl_platform_id) := inherited Create(pl);
function clSubgroupsKHR.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clSuggestedLocalWorkSizeKHR = sealed partial class(cl_extension_base) end;
constructor clSuggestedLocalWorkSizeKHR.Create(pl: cl_platform_id) := inherited Create(pl);
function clSuggestedLocalWorkSizeKHR.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clTerminateContextKHR = sealed partial class(cl_extension_base) end;
constructor clTerminateContextKHR.Create(pl: cl_platform_id) := inherited Create(pl);
function clTerminateContextKHR.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clContentSizePOCL = sealed partial class(cl_extension_base) end;
constructor clContentSizePOCL.Create(pl: cl_platform_id) := inherited Create(pl);
function clContentSizePOCL.GetProcAddress(name: string) := pl.GetProcAddress(name);

type clExtHostPtrQCOM = sealed partial class(cl_extension_base) end;
constructor clExtHostPtrQCOM.Create(pl: cl_platform_id) := inherited Create(pl);
function clExtHostPtrQCOM.GetProcAddress(name: string) := pl.GetProcAddress(name);

{$endregion Инициализаторы расширений}

end.