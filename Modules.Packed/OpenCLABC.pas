
//*****************************************************************************************************\\
// Copyright (©) Sergey Latchenko ( github.com/SunSerega | forum.mmcs.sfedu.ru/u/sun_serega )
// This code is distributed under the Unlicense
// For details see LICENSE file or this:
// https://github.com/SunSerega/POCGL/blob/master/LICENSE
//*****************************************************************************************************\\
// Copyright (©) Сергей Латченко ( github.com/SunSerega | forum.mmcs.sfedu.ru/u/sun_serega )
// Данный код распространяется с лицензией Unlicense
// Подробнее в файле LICENSE или тут:
// https://github.com/SunSerega/POCGL/blob/master/LICENSE
//*****************************************************************************************************\\

///
///Высокоуровневая оболочка модуля OpenCL
///   OpenCL и OpenCLABC можно использовать одновременно
///   Но контактировать они практически не будут
///
///Если не хватает типа/метода или найдена ошибка - писать сюда:
///   https://github.com/SunSerega/POCGL/issues
///
///Справка данного модуля находится в папке примеров
///   По-умолчанию, её можно найти в "C:\PABCWork.NET\Samples\OpenGL и OpenCL"
///
unit OpenCLABC;

{$region DEBUG}{$ifdef DEBUG}

// Регистрация всех cl.RetainEvent и cl.ReleaseEvent
{ $define EventDebug}

// Регистрация использований cl_command_queue
{ $define QueueDebug}

// Регистрация активаций/деактиваций всех WaitHandler-ов
{ $define WaitDebug}

// Регистрация попыток .Exec команд кешировать свой CLKernel
{ $define ExecDebug}

// Регистрация всех уровней ловли ошибок выполнения очередей
{ $define ErrHandlerDebug}

{ $define ForceMaxDebug}
{$ifdef ForceMaxDebug}
  {$define EventDebug}
  {$define QueueDebug}
  {$define WaitDebug}
  {$define ExecDebug}
  {$define ErrHandlerDebug}
{$endif ForceMaxDebug}

{$endif DEBUG}{$endregion DEBUG}

{$region TODO}

//===================================
// Обязательно сделать до следующей стабильной версии:

//TODO Сеттеры параметров не всегда известно, нужны ли
// - Добавить параметр "unuse_is_error := true"

//TODO При создании CLArray и т.п. указывается map_use, но влияет он и на .ReadArray и т.п.
// - Перетестить и переименовать... host_use?

//TODO Если кинуло AggEx, возвращать из тестов его внутренний массив исключений
// - TestExecutor сейчас возвращает исключение текстом... Ужас
//TODO Устечка памяти в виде ивентов после исключения в очереди
// - Поидее стоит тестировать состояние ивентов в тесте и после ошибки
// - Вызывать рефлекцией в try-finally метод Check каждого класса FinalDebugChecks
// - Нет, стоп, это затрёт предыдущие ошибки. Надо и в Main и в Check ловить отдельно

//TODO Как я сейчас реализовал memory_report:
// - M := CLMemory(CLValue<byte>(M))
// - Оригинальный M тут удалит и скажет что память освобождена
// - Но при этом эта память останется использована новым M
// - Поидее надо метод .MoveOwnership(ICLMemory) всем типам, реализующим ICLMemory

//TODO cl_mem и т.п. должны реализовывать .GetHashCode и т.п.

//TODO CLKernelCommandExec и т.п. хранят 2 поля args (в базовом типе и в себе)

//TODO EndMaybeError($'.AccessErrors[{self.GetHashCode}]');
// - А .AddMaybeError для него где???

//TODO Временно созданные ICLMemory стоит освобождать в конце очереди. Но что если очередь что-то возвращает?
// - Получается надо "Q_ResultMU + Q_Dispose + Q_ResultMU"
// - Поидее можно добавить метод чтобы обойтись без MU
// - Сейчас приходится костылить MU в CLContext.TestSanity
// - Вообще, это сразу надо и в finally
// - Тогда может .FinallyKeepResult
// - Или CQUsing
//TODO Сейчас эта же необходимость просвечивается в CCQ
// - Тоже приходится использовать костылировать MU

//TODO CQ.SyncInvoke
//TODO CQ.BeginInvoke
// - В виде методов, чтобы избавится от скобок и чтобы действия были в том же порядке что их описание в программе

//TODO .DiscardResult не показывает в анализаторе кода для CCQ

//TODO Всё же сделать чтобы .SyncInvoke работало без создания потока, когда возможно

//TODO Добавлять информацию о расширении в константы энумов и ett перегрузки
// - Сам только вспоткнулся: "cl.GetMemObjectInfo_MEM_ALLOC_DEVICE" работает только с расширением для общей памяти RAM+OpenCL

//TODO Документация ICLMemory

//TODO CQAcquireGL и CQReleaseGL
// - Документация
// - Тесты (это надо создавать спрятанное окно)
// - Мож привести к более однородному виду
// - Есть смысл разрешать CQ<ICLMemory> вместо ICLMemory?

//TODO Написать в справке про clGLSharingKHR.PlatformLess
// - И сразу про wglSwapControlEXT.Instance

//TODO Кодогенераторы всё ещё много где делают старое форматирование, где содержимое 1-строчной функции имеет ту же идентацию что и заголовок
// - Пройтись сначала по этому файлу, а потом уже по Modules.Packed

//TODO MathDenormsAreZero не заставляет а разрешает делать (flush to) денормы нулями после операций
// - Проверить остальные опции так же...

//TODO CombineSyncQueue(array of CCQ) не работает - не хватает перегрузки
// - Поидее для массива классов достаточно "as array of CQ<>"

//TODO .WithParameter(p: ParameterQueue<T>; val: T)
// - Q := Q0.WithParameter(p, 1) * Q0.WithParameter(p, 2);
// - Не всегда можно отложить применение параметра до .BeginInvoke
// - А без этого метода, чтобы достичь такого же результата - надо создать 2 разные Q0

//TODO CLProgramCode: Свойства, возвращающие контекст и под-множество устройств на которых уже откомпилировано
// - При чём компилировать можно именно на под-множестве устройств... Как то учитывать это

//TODO Использовать StringPattern в тестере

//TODO Аргументы Kernel'ов вроде как могут удаляться до выполнения Enqueue
// - Проверить, как это у меня обрабатывается

//TODO Улучшить систему описаний:
// - Описание для unit
// - Описания для extensionmethod
// - Читабельность
// - Проверки адекватности шаблонов
//TODO Какой-то графический интерфейс для редактирования описаний?
// - Упрощённое дерево файлов
// - Читать .missing и т.п. файлы при обновлении чтобы показывать маркеры
// - Автоматический запуск упаковки с изменениями
// - Групировка шаблонов с кнопкой [+]
// - Ctrl-тык на ссылки в описаниях
// --- Кнопки назад/вперёд

//TODO После cl.Enqueue нужно в любом случае UserEvent
// - Следующие команды игнорирует ошибку в ивенте на 2/3 реализациях, если она не в UserEvent
// - А в колбеке ивента команды надо сначала проверять ошибки prev_ev, потому что их может скопировать в ивент команды
// - Хотя должно быть достаточно .HadError перед проверкой
// - Или нет, если в одном ивенте ошибка, а другой всё ещё ждёт
// - Вообще это более общая проблема... В общем надо колбек делать для (prev_ev+enq_ev), чтобы дальше не продолжать пока всё не сработает

//TODO Вместо g.GetCQ(need_async_inv) лучше хранить ивент, после которого можно будет вызывать cl.Enqueue
// - Но порядок ивент-колбеков неопределён, поэтому надо сделать какую то магию с Interlocked
// - Или ConcurrentQueue?
//TODO А что если ещё один need_async_inv, пока предыдущий список ещё не выполнился
//TODO Сейчас GetCQ вызывается перед проверкой на ошибки от ev_l1
// - В случае need_async_inv - не знаю как это исправить без этой ConcurrentQueue

//TODO Пора бы почистить TODO в кодогенераторах - куча давно закрытых issue

//TODO Получается, HFQ(()->A).MakeCCQ.DiscardResult не выполняет HFQ?
// - (уже исправил)
// - Проверки в CLTask, если очередь инициализировалась но не выполнилась?

//TODO .MU в CCQ это костыль
// - Выполняется куча всего лишнего
// - Результат хранится в CLTask, хотя используется только в 1 выполнении CCQ
// --- То же самое в .MultiuseFor

//TODO Что будет если из g.ParallelInvoke выполнить что то НЕ инвокером
// - В любом случае добавить специальные проверки адекватности на время дебага

//TODO Теория: Все проверки "is ConstQueue<" заведомо костыльны
// - К примеру в try/finally надо проверять на наличие под-очередей, выполяющих код на CPU (НЕ wait)
//TODO С другой стороны в QueueCommand нужна проверка на полную сокращённость?

//TODO Может переименовать в Host[Proc/Func]Queue?

//TODO Каким, всё же, считает generic KernelArg: Global или Constant?

//TODO IEnumerable<T>.Lazy[Sync,Async]ForeachQueue(CQ<T> -> CQBase)
// - Без этого нельзя реализовать вызов очереди для каждого элемента списка с изменяющейся длиной
// - Нет, лучше сделать CombineQueue, но принимающий "sequence of T" и "CQ<T> -> CQBase"
//TODO Может тогда и extensionmethod, которому копируется описание?
//TODO CLList: Как массив, но с изменяемой длиной
//TODO Очень часто в OpenCL нужны двойные буферы: Предыдущее и новое состояние
// - Я сейчас использую HFQ(()->state1) и HFQ(()->state2), но это очень криво
//
//TODO .Cycle(integer)
//TODO .Cycle // бесконечность циклов
//TODO .CycleWhile(***->boolean)
// - Однако всё ещё остаётся вопрос - как сделать ветвление?
//TODO А может Cycle(CycleInfo: record Q_continue, Q_break: CQNil; end -> CQ)
// - Но для них всё равно нужен .ThenIf
// - И адекватную диагностику для недостижимого кода будет сложно вывести
//
//TODO И если уже делать ветвление - то сразу и:
// - .ThenIf(CQ<bool>, TQ, TQ): TQ
// - Проверить чтобы все комбинации Base/Nil/<T> работали
//TODO Или лучше сразу сделать аналог case, для нескольких типов:
// - .ThenCase(val: integer; cases: array of TQ; range_start := 0; default_last := false): TQ
// - .ThenCase(val: boolean; if_true, if_false: TQ): TQ
// - .ThenCase(val: T; choises: IDictionary<T, TQ>): TQ
//
//TODO Кеш не использованных веток, чтобы в .Cycle выполнять меньше .Invoke'ов
// - ConcurrentDictionary<CQBase, UserEvent>
// - Анализ где последнее использование у каждой ветки
//
//TODO .DelayInit, чтобы ветки .ThenIf можно было НЕ инициализировать заранее
// - Тогда .ThenIf на много проще реализовать - через особый err_handler, который говорит что ошибки были, без собственно ошибок
//TODO CCQ.ThenIf(cond, command, nil)
// - Подумать как можно сделать это красивее, чем через MU

//TODO CLContext.BeingInvoke выполняется чаще, чем создание новой очереди
// - Поэтому стоит хранить в очереди кеш некоторых вещей, которые сейчас вычисляются заново в .BeingInvoke
// - Сохранять очереди, требующие инициализации, в виде списка вместо дерева
// - MU очереди:
// --- Количество MU очередей (capacity для inited_mu)
// --- Количество .Invoke каждой MU очереди
// --- Нужен ли их результат (можно ли q.InvokeToNil)
// - Написать в справке что первый проход для разогрева

//TODO Если уже реализовывать поддержку "CQ<T> -> TQ"... Это сразу и альтернатива .MU?
// - Доп переменные не нужны. Т.е. очередь можно в 1 строчку расписать:
// --- "q.ThenMultiuse(q->q+q)"
// - Это будет интуитивнее:
// --- НЕ работать между CLContext.BeginInvoke
// --- Порядок выполнения: q выполняет уже не при запуске очереди
//TODO ErrHandlerThiefRepeater.FillErrLstWithPrev не берёт ошибки mu, если пришла ошибка с prev_ev
// - По моему это плохо, потому что mu всегда выполняется как в finally
// - Подумать как относится к .ThenMU, сделать тесты
//TODO Защита от дурака, чтобы q-параметр нельзя было использовать вне .ThenMultiuse
// - Поидее это уже примерно то, как работают очереди-параметры
//TODO .Multiuseable всё же оставить, у них применения в разных структурах кода
//TODO Очень важно оптимизировать такие случаи, в зависимости от того, сколько раз используется q-параметр (0, 1, else)
// - Это же должно оптимищироваться для более общего .Multiuseable
// - Тогда единственное различие - защита от дурака для q вне .ThenMultiuse
//TODO A.ThenMultiuse(A->(B+A)*(C+A)): Должно ли ожидать окончания A перед стартом B и C?
// - Нет, так нельзя, потому что тогда нельзя получить тот же порядок что с .MU
// - Но тогда надо назвать как-то по другому, не "Then"
// - .MultiuseAs? In? До "as" проще дотянуться

//TODO NativeMemoryArea в отдельный модуль
// - При этом сделать его кросс-платформенным

//TODO .GetArray(0) даёт ошибку
// - Надо сделать параметр-условие, который кодогенерируется в:
// --- if (len is ConstQueue) and (c_len.Value=0) then
// --- if len=0 then
// - И при этом настроить логику отмены cl.Enqueue, если второе условие не пройдёт

//TODO Использовать cl.EnqueueMapBuffer
// - В виде .ThenMapMemory([AutoSize?], Направление, while_mapped: CQ<Native*Area>->CQBase)
// - Лучше сделать так же как для CLKernelArgGlobal
// - В справку
// --- В том числе то, что Map быстрее Read, который быстрее Get
// --- (собсна протестить)
//TODO operator implicit для NativeValue=>CLKernelArg[Global] не генерируются?
// - Правда теперь не релевантно, потому что:
//TODO CLKernelArgGlobal (и Constant) из адреса RAM не обязан копировать данные с кеша GPU назад в RAM после выполнения kernel'а
// - Для этого случая (+оптимизации чтения/записи) и используется MapBuffer
// - В справку
//TODO При чём это в обе стороны (не-)работает
//  var v1 := new NativeValue<integer>(1);
//  var v2 := new CLValue<integer>(1);
//  var Q_Copy := k.MakeCCQ.ThenExec1(1,CLKernelArg.FromNativeValue(v1),v2)+v2.MakeCCQ.ThenGetValue;
//  
//  v1.Value := 3;
//  CLContext.Default.SyncInvoke(Q_Copy).Println; // тут происходит копирование из v1 в кеш
//  v1.Value := 5;
//  CLContext.Default.SyncInvoke(Q_Copy).Println; // тут всё ещё старое значение
//TODO Нет смысла в Global/Constant KernlArg'е хранящем NativeValue[Area]
// - CLMemory.FromHostMemory(copy: boolean? := nil)
// --- Создаёт или Memory(если copy), или его наследник, хранящий ещё "host_hnd: GCHandle" или "host_obj_ref: object"
// --- Если nil то используется Contex.MainDevice.CLPreferHostCLMemoryCopy := Type=GPU
// - А в обычном конструкторе добавить параметр prealloc_map_mem и убрать передачу существующей памяти
// --- MEM_ALLOC_HOST_PTR
// - В справку:
// --- FromHostMemory(copy=false) полезно для существующих объектов, но использовать вне .MapCLMemory их всё равно нельзя
// --- Кроме того, плотно упаковывать элементы плохо
// --- К примеру принимать float3* нельзя, надо принимать и передавать float4*
// --- Или, можно ещё принимать void*, но тогда на стороне OpenCL-C необходимы vload/vstore функции:
// --- https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_C.html#alignment-of-types

//TODO Тесты:
//
// - Отмена enq до и после cl.Enqueue
// --- "V.WriteValue(HQFQ(raise))"
// --- "V.WriteValue(HTFQ(raise))"
//
// - Ивент от MU должно добавить только 1 раз
// --- MU + HQPQ + MU + HQPQ + MU
// - Ивент от MU не добавляется второй раз
// --- (HQPQ(raise)+MU).Handle[ + MU]
// --- Поидее его добавляет первый раз, даже если ошибка
//
// - Должно быть HPQ+CQ в обоих случаях
// --- CQ().ThenUse[.Cast]
//
// - Выполнялось как "HTPQ >= CCQ"
// --- "HTPQ(raise) + CCQ"
//
// - need_own_thread и can_pre_calc
// --- (HTPQ+Par).ThenQuickUse.ThenConstConvert

//TODO Справка:
// - "Q1 -= Q2" вместо Q1 := Q2+Q1;
// - "Q1 /= Q2" вместо Q1 := Q2*Q1;
// - Wait[All/Any] => CombineWait[All/Any]
// - CQ<>.MakeCCQ
// - CLKernelArg
// - NativeArray
// - CLValue
// - !CL!Memory[SubSegment]
// - Из заголовка папки простых обёрток сделать прямую ссылку в под-папку папки CLKernelArg для CL- типов
// - CLMemoryUsage
// - CQ<byte>.Cast<byte?>
// - Properties.ToString
// - need_own_thread и can_pre_calc
// --- (HTPQ+Par).ThenQuickUse.ThenConstConvert
// - new CLValue<byte>(new CLMemorySubSegment(cl_a))
// --- CLArray и CLValue неявно конвертируются в CLMemory
// --- И их можно создать назад конструктором
// - Описать и в процессе перепродумать логику, почему CommandQueue<CommandQueue<>> не только не эффективно, но и не может понадобится
//TODO Разделить .html справку и гайд по OpenCLABC
// - Исправить ссылку на справку в описании заголовка модуля
//TODO github.io
// - Разобраться почему .css не работало до 0.css, но только на github.io
// - Добавить index.html в справки, состоящий из всего 1 страницы
// - Гитхаб-экшн, авто-обновляющий ветку справок

//===================================
// Запланированное:

//TODO Папка с расширениями OpenCLABC, что то типа:
// - uses 'OpenCLABC/GL';     // Связь с OpenGLABC
// - uses 'OpenCLABC/Custom'; // Пользовательские очереди
// - uses 'OpenCLABC/Ext';    // Расширения OpenCL

//TODO Потоко-безопастность CCQ.AddCommand

//TODO Комментарии "Использовано в" энумам н.у. модулей
//TODO OpenCL: Объединить SamplePattern

//TODO WaitNothing - аналог CQNil, в первую очередь для WaitAll([])

//TODO Константные очереди с функцией-инициализатором
// - Как параметры, которым каждый раз дают новое значение
// - Полезно, к примеру, чтобы выделять новый массив-буфер на каждое выполнение
// - Или лучше какую-то кешированную очередь, выделяющий новые объекты только при накладывающихся выполнениях CLTask?
// - Если делать .ThenMap - использования получаются довольно ограничены...

//TODO [In] и [Out] в кодогенераторах
// - [Out] строки без [In] заменять на StringBuilder
// - Полезно, к примеру, в cl.GetProgramBuildInfo
// - А в cl.GetProgramInfo надо принимать [Out] "array of array of Byte" вместо "var IntPtr"

//TODO Деприкация в OpenCL?
// - К примеру clCreateImage2D не должна использоваться после 1.2

//TODO .ToString для простых обёрток лучше пусть возвращает hex представление ntv
// - Реализовано в ветке с новыми TypeName

//TODO Переделать кодогенераторы под что то типа .cshtml

//TODO Пользовательские очереди?
// - Всё же я не всё могу предугадать, поэтому
// - для окончательной версии модуля такая вещь необходима
// - Но чтобы это сделать... придётся типы-утилиты перенести в отдельный модуль,
// - чтобы они были доступны, но не на виду

//TODO Интегрировать профайлинг очередей
// - И в том числе профайлинг отдельных ивентов

//TODO Пройтись по интерфейсу, порасставлять кидание исключений
//TODO Проверки и кидания исключений перед всеми cl.*, чтобы выводить норм сообщения об ошибках
//TODO Попробовать получать информацию о параметрах CLKernel'а и выдавать адекватные ошибки, если передают что-то не то
// - clGetKernelInfo:NUM_ARGS
// - clGetKernelArgInfo
//TODO clGetKernelInfo:ATTRIBUTES?
//
//TODO Возможность выводить где именно в очереди возникла ошибка?

//TODO Порядок Wait очередей в Wait группах
// - Проверить сочетание с каждой другой фичей
// - В комбинации с .Cycle вообще возможно добиться детерминированности?

//TODO .pcu с неправильной позицией зависимости, или не теми настройками - должен игнорироваться
// - Иначе сейчас модули в примерах ссылаются на .pcu, который существует только во время работы Tester, ломая компилятор

//TODO Несколько TODO в:
// - Queue converter's >> Wait

//TODO Исправить перегрузки CLKernel.Exec
// - Но сначала придумать что исправлять
// - Перегрузки с UIntPtr перед перегрузками integer?

//TODO Фичи версий OpenCL:
// - 2.0
// --- SVM
// - 3.0
// --- CL_DEVICE_ILS_WITH_VERSION
// --- CL_DEVICE_BUILT_IN_KERNELS_WITH_VERSION
// --- CL_DEVICE_NUMERIC_VERSION
// --- CL_DEVICE_OPENCL_C_ALL_VERSIONS
// --- CL_DEVICE_OPENCL_C_FEATURES
// --- CL_DEVICE_EXTENSIONS_WITH_VERSION
// --- CL_DEVICE_ATOMIC_MEMORY_CAPABILITIES
// --- CL_DEVICE_ATOMIC_FENCE_CAPABILITIES
// --- CL_DEVICE_NON_UNIFORM_WORK_GROUP_SUPPORT
// --- CL_DEVICE_WORK_GROUP_COLLECTIVE_FUNCTIONS_SUPPORT
// --- CL_DEVICE_GENERIC_ADDRESS_SPACE_SUPPORT
// --- CL_DEVICE_DEVICE_ENQUEUE_CAPABILITIES
// --- CL_DEVICE_PIPE_SUPPORT
// --- CL_DEVICE_PREFERRED_WORK_GROUP_SIZE_MULTIPLE
// --- CL_DEVICE_LATEST_CONFORMANCE_VERSION_PASSED
//
// - ???
// --- clEnqueueMigrateMemObjects

//===================================
// Сделать когда-нибуть:

//TODO Пройтись по всем функциям OpenCL, посмотреть функционал каких не доступен из OpenCLABC
// - clGetCLKernelWorkGroupInfo - свойства кернела на определённом устройстве
// - clCreateContext: CL_CONTEXT_INTEROP_USER_SYNC
// - clCreateProgramWithIL
// - Асинхронные cl_command_queue
// - Другие типы cl_mem (сейчас используется только буфер)
// - clEnqueueNativeKernel
// --- CL_DEVICE_BUILT_IN_KERNELS
// - Расширения
// --- cl_khr_command_buffer
// --- cl_khr_semaphore

//===================================

{$endregion TODO}

{$region Upstream bugs}

//TODO Issue компилятора:
//TODO https://github.com/pascalabcnet/pascalabcnet/issues/{id}
// - #2221
// - #2550
// - #2589
// - #2604
// - #2607
// - #2610

//TODO Issue mono:
//TODO https://github.com/mono/mono/issues/{id}
// - #11034

{$endregion Upstream bugs}

interface

uses System;
uses System.Threading;
uses System.Runtime.InteropServices;
uses System.Runtime.CompilerServices;
uses System.Collections.ObjectModel;
uses System.Collections.Concurrent;

uses OpenCL;

{$ifdef ForceMaxDebug}
var gen_debug_otp: System.IO.TextWriter := Console.Out;
{$endif ForceMaxDebug}
{$ifdef ErrHandlerDebug}
var eh_debug_otp: System.IO.TextWriter := Console.Out;
{$endif ErrHandlerDebug}

type
  
  {$region TODO MOVE}
  //TODO Сделать общим для OpenCLABC, OpenGLABC и т.п.
  
  {$region NativeArea}
  
  {$region NativeMemoryArea}
  
  ///Описывает неуправляемою область памяти
  NativeMemoryArea = record
    public ptr: IntPtr;
    public sz: UIntPtr;
    
    {$region constructor's}
    
    ///Создаёт описание указанной области памяти
    public constructor(ptr: IntPtr; sz: UIntPtr);
    begin
      self.ptr := ptr;
      self.sz := sz;
    end;
    public constructor(sz: UIntPtr);
    begin
      self.sz := sz;
      Alloc;
    end;
    public constructor;
    begin
      self.ptr := IntPtr.Zero;
      self.sz := UIntPtr.Zero;
    end;
    
    {$endregion constructor's}
    
    {$region Method's}
    
    {$region Fill}
    
    private static procedure RtlZeroMemory(dst: IntPtr; length: UIntPtr);
    external 'kernel32.dll';
    private static procedure RtlFillMemory(dst: IntPtr; length: UIntPtr; fill: byte);
    external 'kernel32.dll';
    
    ///Заполняет всю область памяти нулевыми байтами
    public procedure FillZero := RtlZeroMemory(ptr, sz);
    ///Заполняет всю область памяти указанными байтами
    public procedure Fill(val: byte) := RtlFillMemory(ptr, sz, val);
    
    {$endregion Fill}
    
    {$region Copy}
    
    private static procedure RtlCopyMemory(dst: IntPtr; source: IntPtr; length: UIntPtr);
    external 'kernel32.dll';
    private static procedure RtlCopyMemory(var dst: byte; source: IntPtr; length: UIntPtr);
    external 'kernel32.dll';
    private static procedure RtlCopyMemory(dst: IntPtr; var source: byte; length: UIntPtr);
    external 'kernel32.dll';
    
    ///Копирует данные из данной области памяти в указанную
    ///Области памяти не должны пересекаться. Иначе поведение неопределено
    ///Если пересечение возможно, используйте соответствующий .CopyOverlapped* метод
    ///Кол-во копируемых байт берётся из данной области памяти, даже если указанная область памяти имеет меньший размер
    ///Если надо скопировать минимум размеров данной и указанной области памяти используйте статический метод NativeMemoryArea.CopyMinSize
    public procedure CopyTo(area: NativeMemoryArea) := RtlCopyMemory(area.ptr, self.ptr, self.sz);
    ///Копирует данные из указанной области памяти в данную
    ///Области памяти не должны пересекаться. Иначе поведение неопределено
    ///Если пересечение возможно, используйте соответствующий .CopyOverlapped* метод
    ///Кол-во копируемых байт берётся из данной области памяти, даже если указанная область памяти имеет меньший размер
    ///Если надо скопировать минимум размеров данной и указанной области памяти используйте статический метод NativeMemoryArea.CopyMinSize
    public procedure CopyFrom(area: NativeMemoryArea) := RtlCopyMemory(self.ptr, area.ptr, self.sz);
    ///Копирует данные между указанными областями памяти
    ///Области памяти не должны пересекаться. Иначе поведение неопределено
    ///Если пересечение возможно, используйте соответствующий .CopyOverlapped* метод
    ///Количество копируемых байт равняется минимальному размеру указанных областей памяти
    public static procedure CopyMinSize(source, dest: NativeMemoryArea);
    begin
      var min_sz := if source.sz.ToUInt64<dest.sz.ToUInt64 then source.sz else dest.sz;
      RtlCopyMemory(dest.ptr, source.ptr, min_sz);
    end;
    
    ///Копирует данные из данной области памяти в указанную
    ///Области памяти не должны пересекаться. Иначе поведение неопределено
    ///Если пересечение возможно, используйте соответствующий .CopyOverlapped* метод
    ///Кол-во копируемых байт берётся из данной области памяти, даже если указанная область памяти имеет меньший размер
    public procedure CopyTo<T>(var el: T) := RtlCopyMemory(PByte(pointer(@el))^, self.ptr, self.sz);
    ///Копирует данные из данной области памяти в указанную
    ///Области памяти не должны пересекаться. Иначе поведение неопределено
    ///Если пересечение возможно, используйте соответствующий .CopyOverlapped* метод
    ///Кол-во копируемых байт берётся из данной области памяти, даже если указанная область памяти имеет меньший размер
    public procedure CopyTo<T>(a: array of T) := CopyTo(a[0]);
    
    ///Копирует данные из указанной области памяти в данную
    ///Области памяти не должны пересекаться. Иначе поведение неопределено
    ///Если пересечение возможно, используйте соответствующий .CopyOverlapped* метод
    ///Кол-во копируемых байт берётся из данной области памяти, даже если указанная область памяти имеет меньший размер
    public procedure CopyFrom<T>(var el: T) := RtlCopyMemory(self.ptr, PByte(pointer(@el))^, self.sz);
    ///Копирует данные из указанной области памяти в данную
    ///Области памяти не должны пересекаться. Иначе поведение неопределено
    ///Если пересечение возможно, используйте соответствующий .CopyOverlapped* метод
    ///Кол-во копируемых байт берётся из данной области памяти, даже если указанная область памяти имеет меньший размер
    public procedure CopyFrom<T>(a: array of T) := CopyFrom(a[0]);
    
    {$endregion Copy}
    
    {$region CopyOverlapped}
    
    private static procedure RtlMoveMemory(dst: IntPtr; source: IntPtr; length: UIntPtr);
    external 'kernel32.dll';
    private static procedure RtlMoveMemory(var dst: byte; source: IntPtr; length: UIntPtr);
    external 'kernel32.dll';
    private static procedure RtlMoveMemory(dst: IntPtr; var source: byte; length: UIntPtr);
    external 'kernel32.dll';
    
    ///Копирует данные из данной области памяти в указанную
    ///Области памяти могут пересекаться, но взамен данный метод немного медленнее соответствующего метода без Overlapped в названии
    ///Кол-во копируемых байт берётся из данной области памяти, даже если указанная область памяти имеет меньший размер
    ///Если надо скопировать минимум размеров данной и указанной области памяти используйте статический метод NativeMemoryArea.CopyOverlappedMinSize
    public procedure CopyOverlappedTo(area: NativeMemoryArea) := RtlMoveMemory(area.ptr, self.ptr, self.sz);
    ///Копирует данные из указанной области памяти в данную
    ///Области памяти могут пересекаться, но взамен данный метод немного медленнее соответствующего метода без Overlapped в названии
    ///Кол-во копируемых байт берётся из данной области памяти, даже если указанная область памяти имеет меньший размер
    ///Если надо скопировать минимум размеров данной и указанной области памяти используйте статический метод NativeMemoryArea.CopyOverlappedMinSize
    public procedure CopyOverlappedFrom(area: NativeMemoryArea) := RtlMoveMemory(self.ptr, area.ptr, self.sz);
    ///Копирует данные между указанными областями памяти
    ///Области памяти могут пересекаться, но взамен данный метод немного медленнее соответствующего метода без Overlapped в названии
    ///Количество копируемых байт равняется минимальному размеру указанных областей памяти
    public static procedure CopyOverlappedMinSize(source, dest: NativeMemoryArea);
    begin
      var min_sz := if source.sz.ToUInt64<dest.sz.ToUInt64 then source.sz else dest.sz;
      RtlMoveMemory(dest.ptr, source.ptr, min_sz);
    end;
    
    ///Копирует данные из данной области памяти в указанную
    ///Области памяти могут пересекаться, но взамен данный метод немного медленнее соответствующего метода без Overlapped в названии
    ///Кол-во копируемых байт берётся из данной области памяти, даже если указанная область памяти имеет меньший размер
    public procedure CopyOverlappedTo<T>(var el: T) := RtlMoveMemory(PByte(pointer(@el))^, self.ptr, self.sz);
    ///Копирует данные из данной области памяти в указанную
    ///Области памяти могут пересекаться, но взамен данный метод немного медленнее соответствующего метода без Overlapped в названии
    ///Кол-во копируемых байт берётся из данной области памяти, даже если указанная область памяти имеет меньший размер
    public procedure CopyOverlappedTo<T>(a: array of T) := CopyTo(a[0]);
    
    ///Копирует данные из указанной области памяти в данную
    ///Области памяти могут пересекаться, но взамен данный метод немного медленнее соответствующего метода без Overlapped в названии
    ///Кол-во копируемых байт берётся из данной области памяти, даже если указанная область памяти имеет меньший размер
    public procedure CopyOverlappedFrom<T>(var el: T) := RtlMoveMemory(self.ptr, PByte(pointer(@el))^, self.sz);
    ///Копирует данные из указанной области памяти в данную
    ///Области памяти могут пересекаться, но взамен данный метод немного медленнее соответствующего метода без Overlapped в названии
    ///Кол-во копируемых байт берётся из данной области памяти, даже если указанная область памяти имеет меньший размер
    public procedure CopyOverlappedFrom<T>(a: array of T) := CopyTo(a[0]);
    
    {$endregion CopyOverlapped}
    
    {$endregion Method's}
    
    {$region Alloc/Release}
    
    public property IsAllocated: boolean read self.ptr<>IntPtr.Zero;
    
    public procedure Alloc;
    begin
      self.ptr := Marshal.AllocHGlobal(IntPtr(self.sz.ToPointer));
      GC.AddMemoryPressure(self.sz.ToUInt64);
    end;
    public procedure Release;
    begin
      GC.RemoveMemoryPressure(self.sz.ToUInt64);
      Marshal.FreeHGlobal(self.ptr);
      self.ptr := IntPtr.Zero;
    end;
    public function TryRelease: boolean;
    begin
      Result := false;
      var temp := new NativeMemoryArea(
        Interlocked.Exchange(self.ptr, IntPtr.Zero),
        self.sz
      );
      if not temp.IsAllocated then exit;
      temp.Release;
      self.ptr := temp.ptr;
      Result := true;
    end;
    
    {$endregion Alloc/Release}
    
    ///Возвращает строку с основными данными о данном объекте
    public function ToString: string; override :=
    $'{TypeName(self)}:${ptr.ToString(''X'')}[{sz}]';
    
  end;
  
  {$endregion NativeMemoryArea}
  
  {$region NativeValueArea}
  
  NativeValueArea<T> = record
  where T: record;
    public ptr: IntPtr;
    
    {$region constructor's}
    
    static constructor;
    
    public constructor(ptr: IntPtr) := self.ptr := ptr;
    public constructor(alloc: boolean := false) :=
    if alloc then self.Alloc else
    self.ptr := IntPtr.Zero;
    
    public static function operator implicit(p: ^T): NativeValueArea<T> := new NativeValueArea<T>(new IntPtr(p));
    public static function operator implicit(area: NativeValueArea<T>): ^T := area.Pointer;
    public static function operator implicit(area: NativeValueArea<T>): NativeMemoryArea := area.UntypedArea;
    
    {$endregion constructor's}
    
    {$region property's}
    
    public static property ValueSize: integer read Marshal.SizeOf(default(T));
    public property ByteSize: UIntPtr read new UIntPtr(ValueSize);
    
    //TODO #????
    private function PointerUntyped := pointer(ptr);
    public property Pointer: ^T read PointerUntyped();
    public property Value: T read Pointer^ write Pointer^ := value;
    
    public property UntypedArea: NativeMemoryArea read new NativeMemoryArea(self.ptr, self.ByteSize);
    
    {$endregion property's}
    
    {$region Alloc/Release}
    
    public property IsAllocated: boolean read self.ptr<>IntPtr.Zero;
    
    public procedure Alloc;
    begin
      var temp := self.UntypedArea;
      temp.Alloc;
      self.ptr := temp.ptr;
    end;
    public procedure Release;
    begin
      var temp := self.UntypedArea;
      temp.Release;
      self.ptr := temp.ptr;
    end;
    public function TryRelease: boolean;
    begin
      Result := false;
      var temp := self.UntypedArea;
      temp.ptr := Interlocked.Exchange(self.ptr, IntPtr.Zero);
      if not temp.IsAllocated then exit;
      temp.Release;
      self.ptr := temp.ptr;
      Result := true;
    end;
    
    {$endregion Alloc/Release}
    
    public function ToString: string; override :=
    $'{TypeName(self)}:${ptr.ToString(''X'')}';
    
  end;
  
  {$endregion NativeValueArea}
  
  {$region NativeArrayArea}
  
  NativeArrayArea<T> = record
  where T: record;
    public first_ptr: IntPtr;
    public item_count: UInt32;
    
    {$region constructor's}
    
    static constructor;
    
    public constructor(first_ptr: IntPtr; item_count: UInt32);
    begin
      self.first_ptr  := first_ptr;
      self.item_count := item_count;
    end;
    public constructor(item_count: UInt32);
    begin
      self.item_count := item_count;
      Alloc;
    end;
    public constructor;
    begin
      self.first_ptr  := IntPtr.Zero;
      self.item_count := 0;
    end;
    
    public static function operator implicit(area: NativeArrayArea<T>): NativeMemoryArea := area.UntypedArea;
    
    {$endregion constructor's}
    
    {$region property's}
    
    public static property ItemSize: integer read Marshal.SizeOf(default(T));
    public property ByteSize: UIntPtr read new UIntPtr( item_count*uint64(ItemSize) );
    
    public property Length: cardinal read self.item_count;
    
    public property ItemAreaUnchecked[i: integer]: NativeValueArea<T> read new NativeValueArea<T>(self.first_ptr + i*ItemSize);
    
    private function GetAndCheckItemArea(i: integer): NativeValueArea<T>;
    begin
      if cardinal(i)>=self.item_count then raise new IndexOutOfRangeException;
      Result := ItemAreaUnchecked[i];
    end;
    public property ItemArea[i: integer]: NativeValueArea<T> read GetAndCheckItemArea;
    public property Item[i: integer]: T read ItemArea[i].Value write ItemArea[i].Value := value; default;
    
    public property SliceUnchecked[r: IntRange]: NativeArrayArea<T> read
    new NativeArrayArea<T>( ItemAreaUnchecked[r.Low].ptr, r.High-r.Low+1 );
    private function GetSliceAndCheck(r: IntRange): NativeArrayArea<T>;
    begin
      if r.Low<0 then raise new IndexOutOfRangeException('r.Low');
      if cardinal(r.High)>=self.item_count then raise new IndexOutOfRangeException('r.High');
      Result := SliceUnchecked[r];
      if integer(Result.item_count)<0 then raise new ArgumentOutOfRangeException('r.Count');
    end;
    public property Slice[r: IntRange]: NativeArrayArea<T> read GetSliceAndCheck;
    
    private function GetManagedCopy: array of T;
    begin
      Result := new T[self.item_count];
      self.UntypedArea.CopyTo(Result);
    end;
    public property ManagedCopy: array of T read GetManagedCopy write
    begin
      if value.Length<>self.item_count then raise new ArgumentException($'%Err:NativeArrayArea:ManagedCopy:WriteSize%');
      self.UntypedArea.CopyFrom(value);
    end;
    
    public property UntypedArea: NativeMemoryArea read new NativeMemoryArea(self.first_ptr, self.ByteSize);
    
    {$endregion property's}
    
    {$region Alloc/Release}
    
    public property IsAllocated: boolean read self.first_ptr<>IntPtr.Zero;
    
    public procedure Alloc;
    begin
      var temp := self.UntypedArea;
      temp.Alloc;
      self.first_ptr := temp.ptr;
    end;
    public procedure Release;
    begin
      var temp := self.UntypedArea;
      temp.Release;
      self.first_ptr := temp.ptr;
    end;
    public function TryRelease: boolean;
    begin
      Result := false;
      var temp := self.UntypedArea;
      temp.ptr := Interlocked.Exchange(self.first_ptr, IntPtr.Zero);
      if not temp.IsAllocated then exit;
      temp.Release;
      self.first_ptr := temp.ptr;
      Result := true;
    end;
    
    {$endregion Alloc/Release}
    
    public function ToString: string; override :=
    $'{TypeName(self)}:${first_ptr.ToString(''X'')}[{item_count}]';
    
  end;
  
  {$endregion NativeArrayArea}
  
  {$endregion NativeArea}
  
  {$region Native}
  
  {$region NativeMemory}
  
  NativeMemory = partial class(IDisposable)
    private _area: NativeMemoryArea;
    
    {$region constructor's}
    
    public constructor(sz: UIntPtr);
    begin
      self._area.sz := sz;
      self._area.Alloc;
    end;
    private constructor := raise new InvalidOperationException;
    
    {$endregion constructor's}
    
    {$region property's}
    
    public property Area: NativeMemoryArea read _area;
    
    {$endregion property's}
    
    {$region IDisposable}
    
    public procedure Dispose :=
    if Area.TryRelease then GC.SuppressFinalize(self);
    protected procedure Finalize; override := Dispose;
    
    {$endregion IDisposable}
    
    public function ToString: string; override :=
    $'{TypeName(self)}:${Area.ptr.ToString(''X'')}[{Area.sz}]';
    
  end;
  
  {$endregion NativeMemory}
  
  {$region NativeValue}
  
  ///Представляет запись, значение которой хранится в неуправляемой области памяти
  NativeValue<T> = partial class(IDisposable)
  where T: record;
    private _area := new NativeValueArea<T>(true);
    
    {$region constructor's}
    
    ///Выделяет и обнуляет область неуправляемой памяти
    public constructor := self.AreaUntyped.FillZero;
    ///Выделяет область неуправляемой памяти и сохраняет в него указанное значение
    public constructor(o: T) := self.Value := o;
    public static function operator implicit(o: T): NativeValue<T> := new NativeValue<T>(o);
    
    {$endregion constructor's}
    
    {$region property's}
    
    ///Возвращает размер значения, в байтах
    public static property ValueSize: integer read NativeValueArea&<T>.ValueSize;
    
    public property Area: NativeValueArea<T> read _area;
    public property AreaUntyped: NativeMemoryArea read Area.UntypedArea;
    
    ///Возвращает указатель на значение, сохранённое неуправляемой памяти
    public property Pointer: ^T read Area.Pointer;
    ///Возвращает или задаёт значение, сохранённое неуправляемой памяти
    public property Value: T read Area.Value write Area.Value := value;
    
    {$endregion property's}
    
    {$region IDisposable}
    
    ///Освобождает значение, сохранённое неуправляемой памяти
    ///Ничего не делает, если значение уже освобождено
    ///Данный метод вызывается автоматически во время сборки мусора, если объект ещё не удалён
    public procedure Dispose :=
    if Area.TryRelease then GC.SuppressFinalize(self);
    ///Вызывает Dispose. Данный метод вызывается автоматически во время сборки мусора
    ///Данный метод не должен вызываться из пользовательского кода. Он виден только на случай если вы хотите переопределить его в своём классе-наследнике
    protected procedure Finalize; override := Dispose;
    
    {$endregion IDisposable}
    
    ///Возвращает строку с основными данными о данном объекте
    public function ToString: string; override :=
    $'{TypeName(self)}{{ {_ObjectToString(Value)} }}';
    
  end;
  
  {$endregion NativeValue}
  
  {$region NativeArray}
  
  ///Представляет массив, содержимое которого хранится в неуправляемой области памяти
  NativeArray<T> = partial class
  where T: record;
    private _area: NativeArrayArea<T>;
    
    {$region constructor's}
    
    private procedure AllocArea(length: UInt32) :=
      self._area := new NativeArrayArea<T>(length);
    public constructor(length: UInt32);
    begin
      AllocArea(length);
      self.AreaUntyped.FillZero;
    end;
    ///Выделяет неуправляемую память и сохраняет в неё копию указанных данных
    public constructor(a: array of T);
    begin
      AllocArea(a.Length);
      self.AreaUntyped.CopyFrom(a);
    end;
    
    private constructor := raise new InvalidOperationException;
    
    {$endregion constructor's}
    
    {$region Method's}
    
    ///Возвращает индекс по которому находится указанный элемент
    ///Если элемент таковой найден - возвращает nil
    public function IndexOf(item: T): integer?;
    begin
      Result := nil;
      for var i := 0 to Length-1 do
        if self.Item[i]=item then
        begin
          Result := i;
          break;
        end;
    end;
    
    {$endregion Method's}
    
    {$region property's}
    
    ///Возвращает размер одного элемента массива, в байтах
    public static property ItemSize: integer read NativeArrayArea&<T>.ItemSize;
    
    public property Area: NativeArrayArea<T> read self._area;
    public property AreaUntyped: NativeMemoryArea read Area.UntypedArea;
    
    public property Length: cardinal read self.Area.item_count;
    
    public property ItemAreaUnchecked[i: integer]: NativeValueArea<T> read Area.ItemAreaUnchecked[i];
    public property ItemArea[i: integer]: NativeValueArea<T> read Area.ItemArea[i];
    ///Возвращает или задаёт элемент массива по указанному индексу
    ///Данное свойство проверяет правильность переданных индексов
    public property Item[i: integer]: T read Area[i] write Area[i] := value; default;
    
    ///Возвращает описание области памяти для указанного среза элементов
    ///Данное свойство не проверяет правильность переданных индексов
    public property SliceAreaUnchecked[r: IntRange]: NativeArrayArea<T> read Area.SliceUnchecked[r];
    ///Возвращает описание области памяти для указанного среза элементов
    ///Данное свойство проверяет правильность переданных индексов
    public property SliceArea[r: IntRange]: NativeArrayArea<T> read Area.Slice[r];
    
    {$endregion property's}
    
  end;
  
  ///Представляет перечислитель для типа NativeArray<>
  NativeArrayEnumerator<T> = record(IEnumerator<T>)
  where T: record;
    private a: NativeArray<T>;
    private i: integer;
    
    ///Создаёт перечислитель для указанного массива
    public constructor(a: NativeArray<T>);
    begin
      self.a := a;
      self.Reset;
    end;
    ///--
    public constructor := exit;
    
    ///Переходит к следующему элементу массива
    ///Возвращаемое значение указывает можно ли читать данные из свойства Current
    public function MoveNext: boolean;
    begin
      i += 1;
      Result := i < a.Length;
    end;
    ///Сбрасывает перечислитель в его исходное положение
    public procedure Reset := self.i := -1;
    
    ///Возвращает элемент массива на который указывает данный перечислитель
    ///Данное свойство проверяет правильность переданных индексов
    public property Current: T read a[i];
    public property System.Collections.IEnumerator.Current: object read a[i];
    
    ///Обнуляет ссылку перечислителя на массив
    public procedure Dispose := a := nil;
    
  end;
  ///Представляет массив, содержимое которого хранится в неуправляемой области памяти
  NativeArray<T> = partial class(IList<T>, IDisposable)
    
    {$region IList}
    
    public function System.Collections.Generic.IList<T>.IndexOf(item: T): integer := (self.IndexOf(item) ?? -1).Value;
    
    public procedure System.Collections.Generic.IList<T>.Insert(index: integer; item: T) := raise new NotSupportedException;
    public procedure System.Collections.Generic.IList<T>.RemoveAt(index: integer) := raise new NotSupportedException;
    
    {$endregion IList}
    
    {$region ICollection}
    
    //TODO #????
    ///--
    public property {System.Collections.Generic.ICollection<T>.}Count: integer read self.Length;
    public property System.Collections.Generic.ICollection<T>.IsReadOnly: boolean read boolean(true);
    
    public procedure System.Collections.Generic.ICollection<T>.Add(item: T) := raise new NotSupportedException;
    public function System.Collections.Generic.ICollection<T>.Remove(item: T): boolean;
    begin
      Result := false;
      raise new NotSupportedException;
    end;
    public procedure System.Collections.Generic.ICollection<T>.Clear := raise new NotSupportedException;
    
    ///Определяет содержится ли элемент в массиве
    public function Contains(item: T) := self.IndexOf(item) <> nil;
    
    ///Копирует всё содержимое данного массива в указанный
    ///Данное свойство проверяет правильность переданных индексов
    public procedure CopyTo(&array: array of T; arrayIndex: integer);
    begin
      if arrayIndex+self.Length > &array.Length then raise new IndexOutOfRangeException;
      self.AreaUntyped.CopyTo(&array[arrayIndex]);
    end;
    
    {$endregion ICollection}
    
    {$region IEnumerable}
    
    ///Возвращает перечислитель данного массива
    public function GetEnumerator: System.Collections.Generic.IEnumerator<T> := new NativeArrayEnumerator<T>(self);
    public function System.Collections.IEnumerable.GetEnumerator: System.Collections.IEnumerator := new NativeArrayEnumerator<T>(self);
    
    {$endregion IEnumerable}
    
    {$region IDisposable}
    
    ///Освобождает неуправляемую память из по данного массива
    ///Этот метод потоко-безопасен
    ///Данный метод вызывается автоматически во время сборки мусора, если объект ещё не удалён
    public procedure Dispose :=
    if Area.TryRelease then GC.SuppressFinalize(self);
    ///Вызывает Dispose. Данный метод вызывается автоматически во время сборки мусора
    ///Данный метод не должен вызываться из пользовательского кода. Он виден только на случай если вы хотите переопределить его в своём классе-наследнике
    protected procedure Finalize; override := Dispose;
    
    {$endregion IDisposable}
    
    ///Возвращает строку с основными данными о данном объекте
    public function ToString: string; override;
    begin
      var sb := new StringBuilder;
      sb += TypeName(self);
      sb += '{';
      if self.Length<>0 then
      begin
        sb += ' ';
        //TODO #????: as
        foreach var x in self as IList<T> do
        begin
          sb += _ObjectToString(x);
          sb += ', ';
        end;
        sb.Length -= ', '.Length;
        sb += ' ';
      end;
      sb += '}';
      Result := sb.ToString;
    end;
    
  end;
  
  {$endregion NativeArray}
  
  {$endregion Native}
  
  {$region MemoryObserver}
  
  //TODO NativeMemoryObserver?
  MemoryObserver = abstract class
    
    public procedure AddMemoryUse(size: int64; mem_obj: object); abstract;
    
    public procedure RemoveMemoryUse(size: int64; mem_obj: object); abstract;
    
    public property CurrentlyUsedAmount: int64 read; abstract;
    
  end;
  
  SimpleMemoryObserver = sealed class(MemoryObserver)
    private total_size: int64;
    
    public procedure AddMemoryUse(size: int64; mem_obj: object); override;
    begin
      Interlocked.Add(total_size, +size);
    end;
    
    public procedure RemoveMemoryUse(size: int64; mem_obj: object); override;
    begin
      Interlocked.Add(total_size, -size);
    end;
    
    public property CurrentlyUsedAmount: int64 read total_size; override;
    
  end;
  
  TrackingMemoryObserver = sealed class(MemoryObserver)
    private mem_uses := new ConcurrentDictionary<object, int64>;
    private total_size: int64;
    
    public procedure AddMemoryUse(size: int64; mem_obj: object); override;
    begin
      if size<0 then raise new ArgumentOutOfRangeException;
      if not mem_uses.TryAdd(mem_obj, size) then
        raise new InvalidOperationException;
      Interlocked.Add(total_size, size);
    end;
    
    public procedure RemoveMemoryUse(size: int64; mem_obj: object); override;
    begin
      var old_size: int64;
      if not mem_uses.TryRemove(mem_obj, old_size) then
        raise new InvalidOperationException($'{_ObjectToString(mem_obj)} is not one of {_ObjectToString(mem_uses.Keys)}');
      Interlocked.Add(total_size, -old_size);
      if old_size <> size then
        raise new InvalidOperationException($'Expected {_ObjectToString(mem_obj)} to have a size of {old_size}, got {size}');
    end;
    
    public property CurrentlyUsedAmount: int64 read total_size; override;
    
  end;
  
  EmptyMemoryObserver = sealed class(MemoryObserver)
    {$ifdef DEBUG}
    private impl := new TrackingMemoryObserver;
    {$endif DEBUG}
    
    public procedure AddMemoryUse(size: int64; mem_obj: object); override;
    begin
      {$ifdef DEBUG}
      impl.AddMemoryUse(size, mem_obj);
      {$endif DEBUG}
    end;
    
    public procedure RemoveMemoryUse(size: int64; mem_obj: object); override;
    begin
      {$ifdef DEBUG}
      impl.RemoveMemoryUse(size, mem_obj);
      {$endif DEBUG}
    end;
    
    private static function raise_int64: int64;
    begin
      Result := 0;
      raise new NotImplementedException;
    end;
    public property CurrentlyUsedAmount: int64 read raise_int64; override;
    
  end;
  
  {$endregion MemoryObserver}
  
  {$endregion TODO MOVE}
  
  {$region Re-definition's}
  
  clDeviceType              = OpenCL.clDeviceType;
  clDeviceAffinityDomain    = OpenCL.clDeviceAffinityDomain;
  
  {$endregion Re-definition's}
  
  {$region OpenCLABCInternalException}
  
  ///Исключение, кидаемое при неожиданном поведении внутренностей OpenCLABC
  ///Если это исключение было кинуто - пишите в issue
  OpenCLABCInternalException = sealed class(Exception)
    
    private constructor(message: string) :=
      inherited Create(message);
    private constructor(ec: clErrorCode) :=
      inherited Create(OpenCLException.Create(ec).Message);
    private constructor :=
      inherited Create($'Был вызван не_применимый конструктор без параметров... Обратитесь к разработчику OpenCLABC');
    
    private const RelayErrorCode = integer.MinValue;
    private static procedure RaiseIfError(ec: clErrorCode) :=
      if ec.IS_ERROR and (ec.val<>RelayErrorCode) then raise new OpenCLABCInternalException(ec);
    
  end;
  
  {$endregion OpenCLABCInternalException}
  
  {$region DEBUG}
  
  {$region EventDebug}{$ifdef EventDebug}
  
  ///
  EventRetainReleaseData = record
    private is_release: boolean;
    private reason: string;
    
    private static debug_time_counter := Stopwatch.StartNew;
    private time := debug_time_counter.Elapsed;
    
    public constructor(is_release: boolean; reason: string);
    begin
      self.is_release := is_release;
      self.reason := reason;
    end;
    //TODO Реализация yield вызывает этот конструктор
//    public constructor := raise new OpenCLABCInternalException;
    
    private function GetActStr := is_release ? 'Released' : 'Retained';
    public function ToString: string; override :=
    $'{time} | {GetActStr} when: {reason}';
    
  end;
  //TODO #2680
  ///
  TimeNString = auto class
    t: TimeSpan;
    s: string;
  end;
  ///
  EventUseLog = sealed class
    private log_lines := new List<EventRetainReleaseData>;
    private ref_c := 0;
    
    private procedure Retain(reason: string) :=
    lock self do
    begin
      log_lines += new EventRetainReleaseData(false, reason);
      ref_c += 1;
    end;
    
    private procedure Release(reason: string) :=
    lock self do
    begin
      log_lines += new EventRetainReleaseData(true, reason);
      ref_c -= 1;
    end;
    
    private function MakeReports: sequence of array of TimeNString;
    begin
      var res := new List<TimeNString>;
      var c := 0;
      foreach var act in log_lines do
      begin
        c += if act.is_release then -1 else +1;
        res += new TimeNString(act.time, $'{c,3} | {act}');
        if c=0 then
        begin
          yield res.ToArray;
          res.Clear;
        end;
      end;
      if res.Count=0 then exit;
      yield res.ToArray;
    end;
    
  end;
  ///
  EventDebug = static class
    
    private static Logs := new ConcurrentDictionary<cl_event, EventUseLog>;
    private static function LogFor(ev: cl_event) := Logs.GetOrAdd(ev, ev->new EventUseLog);
    
    {$region Log lines}
    
    public static procedure RegisterEventRetain(ev: cl_event; reason: string) :=
    if ev=cl_event.Zero then raise new OpenCLABCInternalException($'Zero event retain') else
    LogFor(ev).Retain(reason);
    
    public static procedure RegisterEventRelease(ev: cl_event; reason: string) :=
    begin
      VerifyExists(ev, reason);
      LogFor(ev).Release(reason);
    end;
    
    {$endregion Log lines}
    
    public static procedure ReportEventLogs(otp: System.IO.TextWriter := Console.Out) :=
    lock otp do
    begin
      otp.WriteLine(System.Environment.StackTrace);
      
      var newest_report := TimeSpan.Zero;
      foreach var (r,ev) in Logs.SelectMany(kvp->
        kvp.Value.MakeReports.Tabulate(r->kvp.Key)
      ).OrderBy(\(r,ev)->r[0].t) do
      begin
        if r[0].t>newest_report then
          otp.WriteLine;
        otp.WriteLine($'Logging state change of {ev}:');
        foreach var l in r do
          otp.WriteLine(l.s);
        newest_report := |newest_report, r[^1].t|.Max;
        otp.WriteLine('-'*30);
      end;
      
      otp.WriteLine('='*40);
      otp.Flush;
    end;
    
    private static procedure ReportProblem(reason: string) := lock output do
    begin
      ReportEventLogs(Console.Error);
      Sleep(1000);
      raise new OpenCLABCInternalException(reason);
    end;
    
    public static procedure VerifyExists(ev: cl_event; reason: string) :=
    if LogFor(ev).ref_c<=0 then ReportProblem($'Event {ev} was released before last use ({reason})');
    
    public static procedure FinallyReport;
    begin
      if Logs.Count=0 then exit;
      foreach var ev in Logs.Keys do
        if LogFor(ev).ref_c<>0 then ReportProblem($'Event {ev} was not released');
      
      var total_ev_count := Logs.Values.Sum(l->l.log_lines.Select(act->act.is_release ? -1 : +1).PartialSum.CountOf(0));
      gen_debug_otp.WriteLine($'[EventDebug]: {total_ev_count} event''s created');
    end;
    
  end;
  
  {$endif EventDebug}{$endregion EventDebug}
  
  {$region QueueDebug}{$ifdef QueueDebug}
  
  ///
  QueueDebug = static class
    
    private static QueueUses := new ConcurrentDictionary<cl_command_queue, ConcurrentQueue<string>>;
    private static function QueueUsesFor(cq: cl_command_queue) := QueueUses.GetOrAdd(cq, cq->new ConcurrentQueue<string>);
    private static procedure Add(cq: cl_command_queue; use: string) := QueueUsesFor(cq).Enqueue(use);
    
    public static procedure ReportQueueUses(otp: System.IO.TextWriter := Console.Out) :=
    lock otp do
    begin
      otp.WriteLine(System.Environment.StackTrace);
      
      foreach var kvp in QueueUses do
      begin
        otp.WriteLine($'Logging uses of {kvp.Key}:');
        foreach var use in kvp.Value do
          otp.WriteLine(use);
        otp.WriteLine('-'*30);
      end;
      
      otp.WriteLine('='*40);
      otp.Flush;
    end;
    
    public static procedure FinallyReport :=
    if QueueUses.Count<>0 then
    begin
      var total_q_count := QueueUses.Keys.Sum(q->
      begin
        Result := 0;
        var last_return := false;
        foreach var use in QueueUses[q] do
        begin
          last_return := ('- return -' in use) or ('- last q -' in use);
          Result += ord(last_return);
        end;
        if last_return then exit;
        ReportQueueUses(Console.Error);
        Sleep(1000);
        raise new OpenCLABCInternalException(q.ToString);
      end);
      gen_debug_otp.WriteLine($'[QueueDebug]: {total_q_count} queue''s created');
    end;
    
  end;
  
  {$endif QueueDebug}{$endregion QueueDebug}
  
  {$region WaitDebug}{$ifdef WaitDebug}
  
  ///
  WaitDebug = static class
    
    private static WaitActions := new ConcurrentDictionary<object, ConcurrentQueue<string>>;
    
    private static procedure RegisterAction(handler: object; act: string) :=
    WaitActions.GetOrAdd(handler, hc->new ConcurrentQueue<string>).Enqueue(act);
    
    public static procedure ReportWaitActions(otp: System.IO.TextWriter := Console.Out) :=
    lock otp do
    begin
      otp.WriteLine(System.Environment.StackTrace);
      
      foreach var kvp in WaitActions do
      begin
        otp.WriteLine($'Logging actions of handler[{kvp.Key.GetHashCode}]:');
        foreach var act in kvp.Value do
          otp.WriteLine(act);
        otp.WriteLine('-'*30);
      end;
      
      otp.WriteLine('='*40);
      otp.Flush;
    end;
    
    public static procedure FinallyReport := if WaitActions.Count<>0 then
      gen_debug_otp.WriteLine($'[WaitDebug]: {WaitActions.Count} wait handler''s created');
    
  end;
  
  {$endif WaitDebug}{$endregion WaitDebug}
  
  {$region ExecDebug}{$ifdef ExecDebug}
  
  ///
  ExecDebug = static class
    
    private static ExecCacheTries := new ConcurrentDictionary<string, ConcurrentQueue<(boolean,string)>>;
    
    private static count_of_type := new ConcurrentDictionary<System.Type, integer>;
    private static prev_names := new ConcurrentDictionary<(System.Type,integer), string>;
    private static function MakeName(command: object) :=
    prev_names.GetOrAdd((command.GetType,command.GetHashCode), t->
    begin
      var n := count_of_type.AddOrUpdate(t[0], 1, (t,n)->n+1);
      Result := $'{TypeToTypeName(t[0])}#{n}';
    end);
    
    private static procedure RegisterExecCacheTry(command: object; is_new: boolean; descr: string) :=
    ExecCacheTries.GetOrAdd(MakeName(command), name->new ConcurrentQueue<(boolean,string)>).Enqueue((is_new,descr));
    
    private static procedure DisposeAllCommands;
    public static procedure ReportExecCache(otp: System.IO.TextWriter := Console.Out) :=
    lock otp do
    begin
      DisposeAllCommands;
      
      otp.WriteLine(System.Environment.StackTrace);
      
      foreach var kvp in ExecCacheTries.OrderBy(kvp->kvp.Key) do
      begin
        otp.WriteLine($'Logging caching tries of {kvp.key}:');
        foreach var (is_new, descr) in kvp.Value do
          otp.WriteLine(descr);
        otp.WriteLine('-'*30);
      end;
      
      otp.WriteLine('='*40);
      otp.Flush;
    end;
    
    public static procedure FinallyReport := if ExecCacheTries.Count<>0 then
      gen_debug_otp.WriteLine($'[ExecDebug]: {ExecCacheTries.Values.Sum(q->q.Count(t->t[0]))} cache entries created');
    
  end;
  
  {$endif ExecDebug}{$endregion ExecDebug}
  
  {$endregion DEBUG}
  
  {$region CLMemoryObserver}
  
  CLMemoryObserver = static class
    
    public static auto property Current: MemoryObserver := new EmptyMemoryObserver;
    
    private static procedure ReportFree(ntv: cl_mem{$ifdef DEBUG}; mem_obj: object{$endif});
    begin
      var sz: UIntPtr;
      OpenCLABCInternalException.RaiseIfError(
        cl.GetMemObjectInfo_MEM_SIZE(ntv, sz)
      );
      Current.RemoveMemoryUse(sz.ToUInt64, {$ifdef DEBUG}mem_obj{$else}ntv{$endif});
    end;
    
  end;
  
  {$ifdef DEBUG}
  CLMemoryAlloc = sealed auto class(IEquatable<CLMemoryAlloc>)
    public abc_mem: object;
    public ntv_mem: cl_mem;
    
    public function Equals(other: CLMemoryAlloc) := self.ntv_mem = other.ntv_mem;
    public function Equals(o: object): boolean; override :=
      (o is CLMemoryAlloc(var other)) and Equals(other);
    public function GetHashCode: integer; override := ntv_mem.GetHashCode;
    
    public function ToString: string; override :=
      $'{abc_mem} (org={ntv_mem})';
    
  end;
  {$endif DEBUG}
  
  {$endregion CLMemoryObserver}
  
  {$region WrapperProperties}
  
  {$region CLPlatform}
  
  ///
  CLPlatformProperties = class
    private ntv: cl_platform_id;
    
    public constructor(ntv: cl_platform_id) := self.ntv := ntv;
    private constructor := raise new OpenCLABCInternalException;
    
    private function GetProfile: string;
    begin
      cl.GetPlatformInfo_PLATFORM_PROFILE(self.ntv, Result).RaiseIfError;
    end;
    private function GetVersion: string;
    begin
      cl.GetPlatformInfo_PLATFORM_VERSION(self.ntv, Result).RaiseIfError;
    end;
    private function GetName: string;
    begin
      cl.GetPlatformInfo_PLATFORM_NAME(self.ntv, Result).RaiseIfError;
    end;
    private function GetVendor: string;
    begin
      cl.GetPlatformInfo_PLATFORM_VENDOR(self.ntv, Result).RaiseIfError;
    end;
    private function GetExtensions: string;
    begin
      cl.GetPlatformInfo_PLATFORM_EXTENSIONS(self.ntv, Result).RaiseIfError;
    end;
    private function GetHostTimerResolution: UInt64;
    begin
      cl.GetPlatformInfo_PLATFORM_HOST_TIMER_RESOLUTION(self.ntv, Result).RaiseIfError;
    end;
    private function GetNumericVersion: UInt32;
    begin
      cl.GetPlatformInfo_PLATFORM_NUMERIC_VERSION(self.ntv, Result).RaiseIfError;
    end;
    private function GetExtensionsWithVersion: array of cl_name_version;
    begin
      cl.GetPlatformInfo_PLATFORM_EXTENSIONS_WITH_VERSION(self.ntv, Result).RaiseIfError;
    end;
    private function GetCommandBufferCapabilities: clPlatformCommandBufferCapabilities;
    begin
      cl.GetPlatformInfo_PLATFORM_COMMAND_BUFFER_CAPABILITIES(self.ntv, Result).RaiseIfError;
    end;
    private function GetIcdSuffix: string;
    begin
      cl.GetPlatformInfo_PLATFORM_ICD_SUFFIX(self.ntv, Result).RaiseIfError;
    end;
    private function GetSemaphoreTypes: array of clSemaphoreType;
    begin
      cl.GetPlatformInfo_PLATFORM_SEMAPHORE_TYPES(self.ntv, Result).RaiseIfError;
    end;
    private function GetSemaphoreImportHandleTypes: array of clExternalSemaphoreHandleType;
    begin
      cl.GetPlatformInfo_PLATFORM_SEMAPHORE_IMPORT_HANDLE_TYPES(self.ntv, Result).RaiseIfError;
    end;
    private function GetSemaphoreExportHandleTypes: array of clExternalSemaphoreHandleType;
    begin
      cl.GetPlatformInfo_PLATFORM_SEMAPHORE_EXPORT_HANDLE_TYPES(self.ntv, Result).RaiseIfError;
    end;
    private function GetExternalMemoryImportHandleTypes: array of clExternalMemoryHandleType;
    begin
      cl.GetPlatformInfo_PLATFORM_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES(self.ntv, Result).RaiseIfError;
    end;
    
    public property Profile:                         string                                 read GetProfile;
    public property Version:                         string                                 read GetVersion;
    public property Name:                            string                                 read GetName;
    public property Vendor:                          string                                 read GetVendor;
    public property Extensions:                      string                                 read GetExtensions;
    public property HostTimerResolution:             UInt64                                 read GetHostTimerResolution;
    public property NumericVersion:                  UInt32                                 read GetNumericVersion;
    public property ExtensionsWithVersion:           array of cl_name_version               read GetExtensionsWithVersion;
    public property CommandBufferCapabilities:       clPlatformCommandBufferCapabilities    read GetCommandBufferCapabilities;
    public property IcdSuffix:                       string                                 read GetIcdSuffix;
    public property SemaphoreTypes:                  array of clSemaphoreType               read GetSemaphoreTypes;
    public property SemaphoreImportHandleTypes:      array of clExternalSemaphoreHandleType read GetSemaphoreImportHandleTypes;
    public property SemaphoreExportHandleTypes:      array of clExternalSemaphoreHandleType read GetSemaphoreExportHandleTypes;
    public property ExternalMemoryImportHandleTypes: array of clExternalMemoryHandleType    read GetExternalMemoryImportHandleTypes;
    
    private static procedure AddProp<T>(res: StringBuilder; get_prop: ()->T) :=
      try
        res += _ObjectToString(get_prop());
      except
        on e: OpenCLException do
          res += e.Code.ToString;
      end;
    public procedure ToString(res: StringBuilder); virtual;
    begin
      res += 'Profile                         = '; AddProp(res, GetProfile                        ); res += #10;
      res += 'Version                         = '; AddProp(res, GetVersion                        ); res += #10;
      res += 'Name                            = '; AddProp(res, GetName                           ); res += #10;
      res += 'Vendor                          = '; AddProp(res, GetVendor                         ); res += #10;
      res += 'Extensions                      = '; AddProp(res, GetExtensions                     ); res += #10;
      res += 'HostTimerResolution             = '; AddProp(res, GetHostTimerResolution            ); res += #10;
      res += 'NumericVersion                  = '; AddProp(res, GetNumericVersion                 ); res += #10;
      res += 'ExtensionsWithVersion           = '; AddProp(res, GetExtensionsWithVersion          ); res += #10;
      res += 'CommandBufferCapabilities       = '; AddProp(res, GetCommandBufferCapabilities      ); res += #10;
      res += 'IcdSuffix                       = '; AddProp(res, GetIcdSuffix                      ); res += #10;
      res += 'SemaphoreTypes                  = '; AddProp(res, GetSemaphoreTypes                 ); res += #10;
      res += 'SemaphoreImportHandleTypes      = '; AddProp(res, GetSemaphoreImportHandleTypes     ); res += #10;
      res += 'SemaphoreExportHandleTypes      = '; AddProp(res, GetSemaphoreExportHandleTypes     ); res += #10;
      res += 'ExternalMemoryImportHandleTypes = '; AddProp(res, GetExternalMemoryImportHandleTypes);
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      ToString(res);
      Result := res.ToString;
    end;
    
  end;
  
  {$endregion CLPlatform}
  
  {$region CLDevice}
  
  ///
  CLDeviceProperties = class
    private ntv: cl_device_id;
    
    public constructor(ntv: cl_device_id) := self.ntv := ntv;
    private constructor := raise new OpenCLABCInternalException;
    
    private function GetType: clDeviceType;
    begin
      cl.GetDeviceInfo_DEVICE_TYPE(self.ntv, Result).RaiseIfError;
    end;
    private function GetVendorId: clKhronosVendorId;
    begin
      cl.GetDeviceInfo_DEVICE_VENDOR_ID(self.ntv, Result).RaiseIfError;
    end;
    private function GetMaxComputeUnits: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_MAX_COMPUTE_UNITS(self.ntv, Result).RaiseIfError;
    end;
    private function GetMaxWorkItemDimensions: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_MAX_WORK_ITEM_DIMENSIONS(self.ntv, Result).RaiseIfError;
    end;
    private function GetMaxWorkGroupSize: UIntPtr;
    begin
      cl.GetDeviceInfo_DEVICE_MAX_WORK_GROUP_SIZE(self.ntv, Result).RaiseIfError;
    end;
    private function GetMaxWorkItemSizes: array of UIntPtr;
    begin
      cl.GetDeviceInfo_DEVICE_MAX_WORK_ITEM_SIZES(self.ntv, Result).RaiseIfError;
    end;
    private function GetPreferredVectorWidthChar: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_PREFERRED_VECTOR_WIDTH_CHAR(self.ntv, Result).RaiseIfError;
    end;
    private function GetPreferredVectorWidthShort: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_PREFERRED_VECTOR_WIDTH_SHORT(self.ntv, Result).RaiseIfError;
    end;
    private function GetPreferredVectorWidthInt: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_PREFERRED_VECTOR_WIDTH_INT(self.ntv, Result).RaiseIfError;
    end;
    private function GetPreferredVectorWidthLong: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_PREFERRED_VECTOR_WIDTH_LONG(self.ntv, Result).RaiseIfError;
    end;
    private function GetPreferredVectorWidthFloat: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT(self.ntv, Result).RaiseIfError;
    end;
    private function GetPreferredVectorWidthDouble: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE(self.ntv, Result).RaiseIfError;
    end;
    private function GetMaxClockFrequency: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_MAX_CLOCK_FREQUENCY(self.ntv, Result).RaiseIfError;
    end;
    private function GetAddressBits: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_ADDRESS_BITS(self.ntv, Result).RaiseIfError;
    end;
    private function GetMaxReadImageArgs: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_MAX_READ_IMAGE_ARGS(self.ntv, Result).RaiseIfError;
    end;
    private function GetMaxWriteImageArgs: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_MAX_WRITE_IMAGE_ARGS(self.ntv, Result).RaiseIfError;
    end;
    private function GetMaxMemAllocSize: UInt64;
    begin
      cl.GetDeviceInfo_DEVICE_MAX_MEM_ALLOC_SIZE(self.ntv, Result).RaiseIfError;
    end;
    private function GetImage2dMaxWidth: UIntPtr;
    begin
      cl.GetDeviceInfo_DEVICE_IMAGE2D_MAX_WIDTH(self.ntv, Result).RaiseIfError;
    end;
    private function GetImage2dMaxHeight: UIntPtr;
    begin
      cl.GetDeviceInfo_DEVICE_IMAGE2D_MAX_HEIGHT(self.ntv, Result).RaiseIfError;
    end;
    private function GetImage3dMaxWidth: UIntPtr;
    begin
      cl.GetDeviceInfo_DEVICE_IMAGE3D_MAX_WIDTH(self.ntv, Result).RaiseIfError;
    end;
    private function GetImage3dMaxHeight: UIntPtr;
    begin
      cl.GetDeviceInfo_DEVICE_IMAGE3D_MAX_HEIGHT(self.ntv, Result).RaiseIfError;
    end;
    private function GetImage3dMaxDepth: UIntPtr;
    begin
      cl.GetDeviceInfo_DEVICE_IMAGE3D_MAX_DEPTH(self.ntv, Result).RaiseIfError;
    end;
    private function GetImageSupport: clBool;
    begin
      cl.GetDeviceInfo_DEVICE_IMAGE_SUPPORT(self.ntv, Result).RaiseIfError;
    end;
    private function GetMaxParameterSize: UIntPtr;
    begin
      cl.GetDeviceInfo_DEVICE_MAX_PARAMETER_SIZE(self.ntv, Result).RaiseIfError;
    end;
    private function GetMaxSamplers: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_MAX_SAMPLERS(self.ntv, Result).RaiseIfError;
    end;
    private function GetMemBaseAddrAlign: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_MEM_BASE_ADDR_ALIGN(self.ntv, Result).RaiseIfError;
    end;
    private function GetMinDataTypeAlignSize: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_MIN_DATA_TYPE_ALIGN_SIZE(self.ntv, Result).RaiseIfError;
    end;
    private function GetSingleFpConfig: clDeviceFPConfig;
    begin
      cl.GetDeviceInfo_DEVICE_SINGLE_FP_CONFIG(self.ntv, Result).RaiseIfError;
    end;
    private function GetGlobalMemCacheType: clDeviceMemCacheType;
    begin
      cl.GetDeviceInfo_DEVICE_GLOBAL_MEM_CACHE_TYPE(self.ntv, Result).RaiseIfError;
    end;
    private function GetGlobalMemCachelineSize: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_GLOBAL_MEM_CACHELINE_SIZE(self.ntv, Result).RaiseIfError;
    end;
    private function GetGlobalMemCacheSize: UInt64;
    begin
      cl.GetDeviceInfo_DEVICE_GLOBAL_MEM_CACHE_SIZE(self.ntv, Result).RaiseIfError;
    end;
    private function GetGlobalMemSize: UInt64;
    begin
      cl.GetDeviceInfo_DEVICE_GLOBAL_MEM_SIZE(self.ntv, Result).RaiseIfError;
    end;
    private function GetMaxConstantBufferSize: UInt64;
    begin
      cl.GetDeviceInfo_DEVICE_MAX_CONSTANT_BUFFER_SIZE(self.ntv, Result).RaiseIfError;
    end;
    private function GetMaxConstantArgs: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_MAX_CONSTANT_ARGS(self.ntv, Result).RaiseIfError;
    end;
    private function GetLocalMemType: clDeviceLocalMemType;
    begin
      cl.GetDeviceInfo_DEVICE_LOCAL_MEM_TYPE(self.ntv, Result).RaiseIfError;
    end;
    private function GetLocalMemSize: UInt64;
    begin
      cl.GetDeviceInfo_DEVICE_LOCAL_MEM_SIZE(self.ntv, Result).RaiseIfError;
    end;
    private function GetErrorCorrectionSupport: clBool;
    begin
      cl.GetDeviceInfo_DEVICE_ERROR_CORRECTION_SUPPORT(self.ntv, Result).RaiseIfError;
    end;
    private function GetProfilingTimerResolution: UIntPtr;
    begin
      cl.GetDeviceInfo_DEVICE_PROFILING_TIMER_RESOLUTION(self.ntv, Result).RaiseIfError;
    end;
    private function GetEndianLittle: clBool;
    begin
      cl.GetDeviceInfo_DEVICE_ENDIAN_LITTLE(self.ntv, Result).RaiseIfError;
    end;
    private function GetAvailable: clBool;
    begin
      cl.GetDeviceInfo_DEVICE_AVAILABLE(self.ntv, Result).RaiseIfError;
    end;
    private function GetCompilerAvailable: clBool;
    begin
      cl.GetDeviceInfo_DEVICE_COMPILER_AVAILABLE(self.ntv, Result).RaiseIfError;
    end;
    private function GetExecutionCapabilities: clDeviceExecCapabilities;
    begin
      cl.GetDeviceInfo_DEVICE_EXECUTION_CAPABILITIES(self.ntv, Result).RaiseIfError;
    end;
    private function GetQueueProperties: clCommandQueueProperties;
    begin
      cl.GetDeviceInfo_DEVICE_QUEUE_PROPERTIES(self.ntv, Result).RaiseIfError;
    end;
    private function GetQueueOnHostProperties: clCommandQueueProperties;
    begin
      cl.GetDeviceInfo_DEVICE_QUEUE_ON_HOST_PROPERTIES(self.ntv, Result).RaiseIfError;
    end;
    private function GetName: string;
    begin
      cl.GetDeviceInfo_DEVICE_NAME(self.ntv, Result).RaiseIfError;
    end;
    private function GetVendor: string;
    begin
      cl.GetDeviceInfo_DEVICE_VENDOR(self.ntv, Result).RaiseIfError;
    end;
    private function GetDriverVersion: string;
    begin
      cl.GetDeviceInfo_DRIVER_VERSION(self.ntv, Result).RaiseIfError;
    end;
    private function GetProfile: string;
    begin
      cl.GetDeviceInfo_DEVICE_PROFILE(self.ntv, Result).RaiseIfError;
    end;
    private function GetVersion: string;
    begin
      cl.GetDeviceInfo_DEVICE_VERSION(self.ntv, Result).RaiseIfError;
    end;
    private function GetExtensions: string;
    begin
      cl.GetDeviceInfo_DEVICE_EXTENSIONS(self.ntv, Result).RaiseIfError;
    end;
    private function GetDoubleFpConfig: clDeviceFPConfig;
    begin
      cl.GetDeviceInfo_DEVICE_DOUBLE_FP_CONFIG(self.ntv, Result).RaiseIfError;
    end;
    private function GetHalfFpConfig: clDeviceFPConfig;
    begin
      cl.GetDeviceInfo_DEVICE_HALF_FP_CONFIG(self.ntv, Result).RaiseIfError;
    end;
    private function GetPreferredVectorWidthHalf: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_PREFERRED_VECTOR_WIDTH_HALF(self.ntv, Result).RaiseIfError;
    end;
    private function GetHostUnifiedMemory: clBool;
    begin
      cl.GetDeviceInfo_DEVICE_HOST_UNIFIED_MEMORY(self.ntv, Result).RaiseIfError;
    end;
    private function GetNativeVectorWidthChar: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_NATIVE_VECTOR_WIDTH_CHAR(self.ntv, Result).RaiseIfError;
    end;
    private function GetNativeVectorWidthShort: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_NATIVE_VECTOR_WIDTH_SHORT(self.ntv, Result).RaiseIfError;
    end;
    private function GetNativeVectorWidthInt: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_NATIVE_VECTOR_WIDTH_INT(self.ntv, Result).RaiseIfError;
    end;
    private function GetNativeVectorWidthLong: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_NATIVE_VECTOR_WIDTH_LONG(self.ntv, Result).RaiseIfError;
    end;
    private function GetNativeVectorWidthFloat: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_NATIVE_VECTOR_WIDTH_FLOAT(self.ntv, Result).RaiseIfError;
    end;
    private function GetNativeVectorWidthDouble: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE(self.ntv, Result).RaiseIfError;
    end;
    private function GetNativeVectorWidthHalf: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_NATIVE_VECTOR_WIDTH_HALF(self.ntv, Result).RaiseIfError;
    end;
    private function GetOpenclCVersion: string;
    begin
      cl.GetDeviceInfo_DEVICE_OPENCL_C_VERSION(self.ntv, Result).RaiseIfError;
    end;
    private function GetLinkerAvailable: clBool;
    begin
      cl.GetDeviceInfo_DEVICE_LINKER_AVAILABLE(self.ntv, Result).RaiseIfError;
    end;
    private function GetBuiltInKernels: string;
    begin
      cl.GetDeviceInfo_DEVICE_BUILT_IN_KERNELS(self.ntv, Result).RaiseIfError;
    end;
    private function GetImageMaxBufferSize: UIntPtr;
    begin
      cl.GetDeviceInfo_DEVICE_IMAGE_MAX_BUFFER_SIZE(self.ntv, Result).RaiseIfError;
    end;
    private function GetImageMaxArraySize: UIntPtr;
    begin
      cl.GetDeviceInfo_DEVICE_IMAGE_MAX_ARRAY_SIZE(self.ntv, Result).RaiseIfError;
    end;
    private function GetParentDevice: cl_device_id;
    begin
      cl.GetDeviceInfo_DEVICE_PARENT_DEVICE(self.ntv, Result).RaiseIfError;
    end;
    private function GetPartitionMaxSubDevices: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_PARTITION_MAX_SUB_DEVICES(self.ntv, Result).RaiseIfError;
    end;
    private function GetPartitionProperties: array of clDevicePartitionProperty;
    begin
      cl.GetDeviceInfo_DEVICE_PARTITION_PROPERTIES(self.ntv, Result).RaiseIfError;
    end;
    private function GetPartitionAffinityDomain: clDeviceAffinityDomain;
    begin
      cl.GetDeviceInfo_DEVICE_PARTITION_AFFINITY_DOMAIN(self.ntv, Result).RaiseIfError;
    end;
    private function GetPartitionType: array of clDevicePartitionProperty;
    begin
      cl.GetDeviceInfo_DEVICE_PARTITION_TYPE(self.ntv, Result).RaiseIfError;
    end;
    private function GetReferenceCount: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_REFERENCE_COUNT(self.ntv, Result).RaiseIfError;
    end;
    private function GetPreferredInteropUserSync: clBool;
    begin
      cl.GetDeviceInfo_DEVICE_PREFERRED_INTEROP_USER_SYNC(self.ntv, Result).RaiseIfError;
    end;
    private function GetPrintfBufferSize: UIntPtr;
    begin
      cl.GetDeviceInfo_DEVICE_PRINTF_BUFFER_SIZE(self.ntv, Result).RaiseIfError;
    end;
    private function GetImagePitchAlignment: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_IMAGE_PITCH_ALIGNMENT(self.ntv, Result).RaiseIfError;
    end;
    private function GetImageBaseAddressAlignment: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_IMAGE_BASE_ADDRESS_ALIGNMENT(self.ntv, Result).RaiseIfError;
    end;
    private function GetMaxReadWriteImageArgs: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_MAX_READ_WRITE_IMAGE_ARGS(self.ntv, Result).RaiseIfError;
    end;
    private function GetMaxGlobalVariableSize: UIntPtr;
    begin
      cl.GetDeviceInfo_DEVICE_MAX_GLOBAL_VARIABLE_SIZE(self.ntv, Result).RaiseIfError;
    end;
    private function GetQueueOnDeviceProperties: clCommandQueueProperties;
    begin
      cl.GetDeviceInfo_DEVICE_QUEUE_ON_DEVICE_PROPERTIES(self.ntv, Result).RaiseIfError;
    end;
    private function GetQueueOnDevicePreferredSize: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_QUEUE_ON_DEVICE_PREFERRED_SIZE(self.ntv, Result).RaiseIfError;
    end;
    private function GetQueueOnDeviceMaxSize: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_QUEUE_ON_DEVICE_MAX_SIZE(self.ntv, Result).RaiseIfError;
    end;
    private function GetMaxOnDeviceQueues: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_MAX_ON_DEVICE_QUEUES(self.ntv, Result).RaiseIfError;
    end;
    private function GetMaxOnDeviceEvents: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_MAX_ON_DEVICE_EVENTS(self.ntv, Result).RaiseIfError;
    end;
    private function GetSvmCapabilities: clDeviceSVMCapabilities;
    begin
      cl.GetDeviceInfo_DEVICE_SVM_CAPABILITIES(self.ntv, Result).RaiseIfError;
    end;
    private function GetGlobalVariablePreferredTotalSize: UIntPtr;
    begin
      cl.GetDeviceInfo_DEVICE_GLOBAL_VARIABLE_PREFERRED_TOTAL_SIZE(self.ntv, Result).RaiseIfError;
    end;
    private function GetMaxPipeArgs: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_MAX_PIPE_ARGS(self.ntv, Result).RaiseIfError;
    end;
    private function GetPipeMaxActiveReservations: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_PIPE_MAX_ACTIVE_RESERVATIONS(self.ntv, Result).RaiseIfError;
    end;
    private function GetPipeMaxPacketSize: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_PIPE_MAX_PACKET_SIZE(self.ntv, Result).RaiseIfError;
    end;
    private function GetPreferredPlatformAtomicAlignment: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_PREFERRED_PLATFORM_ATOMIC_ALIGNMENT(self.ntv, Result).RaiseIfError;
    end;
    private function GetPreferredGlobalAtomicAlignment: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_PREFERRED_GLOBAL_ATOMIC_ALIGNMENT(self.ntv, Result).RaiseIfError;
    end;
    private function GetPreferredLocalAtomicAlignment: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_PREFERRED_LOCAL_ATOMIC_ALIGNMENT(self.ntv, Result).RaiseIfError;
    end;
    private function GetIlVersion: string;
    begin
      cl.GetDeviceInfo_DEVICE_IL_VERSION(self.ntv, Result).RaiseIfError;
    end;
    private function GetMaxNumSubGroups: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_MAX_NUM_SUB_GROUPS(self.ntv, Result).RaiseIfError;
    end;
    private function GetSubGroupIndependentForwardProgress: clBool;
    begin
      cl.GetDeviceInfo_DEVICE_SUB_GROUP_INDEPENDENT_FORWARD_PROGRESS(self.ntv, Result).RaiseIfError;
    end;
    private function GetNumericVersion: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_NUMERIC_VERSION(self.ntv, Result).RaiseIfError;
    end;
    private function GetOpenclCNumericVersion: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_OPENCL_C_NUMERIC_VERSION(self.ntv, Result).RaiseIfError;
    end;
    private function GetExtensionsWithVersion: array of cl_name_version;
    begin
      cl.GetDeviceInfo_DEVICE_EXTENSIONS_WITH_VERSION(self.ntv, Result).RaiseIfError;
    end;
    private function GetIlsWithVersion: array of cl_name_version;
    begin
      cl.GetDeviceInfo_DEVICE_ILS_WITH_VERSION(self.ntv, Result).RaiseIfError;
    end;
    private function GetBuiltInKernelsWithVersion: array of cl_name_version;
    begin
      cl.GetDeviceInfo_DEVICE_BUILT_IN_KERNELS_WITH_VERSION(self.ntv, Result).RaiseIfError;
    end;
    private function GetAtomicMemoryCapabilities: clDeviceAtomicCapabilities;
    begin
      cl.GetDeviceInfo_DEVICE_ATOMIC_MEMORY_CAPABILITIES(self.ntv, Result).RaiseIfError;
    end;
    private function GetAtomicFenceCapabilities: clDeviceAtomicCapabilities;
    begin
      cl.GetDeviceInfo_DEVICE_ATOMIC_FENCE_CAPABILITIES(self.ntv, Result).RaiseIfError;
    end;
    private function GetNonUniformWorkGroupSupport: clBool;
    begin
      cl.GetDeviceInfo_DEVICE_NON_UNIFORM_WORK_GROUP_SUPPORT(self.ntv, Result).RaiseIfError;
    end;
    private function GetOpenclCAllVersions: array of cl_name_version;
    begin
      cl.GetDeviceInfo_DEVICE_OPENCL_C_ALL_VERSIONS(self.ntv, Result).RaiseIfError;
    end;
    private function GetPreferredWorkGroupSizeMultiple: UIntPtr;
    begin
      cl.GetDeviceInfo_DEVICE_PREFERRED_WORK_GROUP_SIZE_MULTIPLE(self.ntv, Result).RaiseIfError;
    end;
    private function GetWorkGroupCollectiveFunctionsSupport: clBool;
    begin
      cl.GetDeviceInfo_DEVICE_WORK_GROUP_COLLECTIVE_FUNCTIONS_SUPPORT(self.ntv, Result).RaiseIfError;
    end;
    private function GetGenericAddressSpaceSupport: clBool;
    begin
      cl.GetDeviceInfo_DEVICE_GENERIC_ADDRESS_SPACE_SUPPORT(self.ntv, Result).RaiseIfError;
    end;
    private function GetUuid: array of Byte;
    begin
      cl.GetDeviceInfo_DEVICE_UUID(self.ntv, Result).RaiseIfError;
    end;
    private function GetDriverUuid: array of Byte;
    begin
      cl.GetDeviceInfo_DRIVER_UUID(self.ntv, Result).RaiseIfError;
    end;
    private function GetLuidValid: clBool;
    begin
      cl.GetDeviceInfo_DEVICE_LUID_VALID(self.ntv, Result).RaiseIfError;
    end;
    private function GetLuid: array of Byte;
    begin
      cl.GetDeviceInfo_DEVICE_LUID(self.ntv, Result).RaiseIfError;
    end;
    private function GetNodeMask: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_NODE_MASK(self.ntv, Result).RaiseIfError;
    end;
    private function GetOpenclCFeatures: array of cl_name_version;
    begin
      cl.GetDeviceInfo_DEVICE_OPENCL_C_FEATURES(self.ntv, Result).RaiseIfError;
    end;
    private function GetDeviceEnqueueCapabilities: clDeviceOnDeviceEnqueueCapabilities;
    begin
      cl.GetDeviceInfo_DEVICE_DEVICE_ENQUEUE_CAPABILITIES(self.ntv, Result).RaiseIfError;
    end;
    private function GetPipeSupport: clBool;
    begin
      cl.GetDeviceInfo_DEVICE_PIPE_SUPPORT(self.ntv, Result).RaiseIfError;
    end;
    private function GetLatestConformanceVersionPassed: string;
    begin
      cl.GetDeviceInfo_DEVICE_LATEST_CONFORMANCE_VERSION_PASSED(self.ntv, Result).RaiseIfError;
    end;
    private function GetIntegerDotProductCapabilities: clDeviceIntegerDotProductCapabilities;
    begin
      cl.GetDeviceInfo_DEVICE_INTEGER_DOT_PRODUCT_CAPABILITIES(self.ntv, Result).RaiseIfError;
    end;
    private function GetIntegerDotProductAccelerationProperties8bit: cl_device_integer_dot_product_acceleration_properties;
    begin
      cl.GetDeviceInfo_DEVICE_INTEGER_DOT_PRODUCT_ACCELERATION_PROPERTIES_8BIT(self.ntv, Result).RaiseIfError;
    end;
    private function GetIntegerDotProductAccelerationProperties4x8bitPacked: cl_device_integer_dot_product_acceleration_properties;
    begin
      cl.GetDeviceInfo_DEVICE_INTEGER_DOT_PRODUCT_ACCELERATION_PROPERTIES_4x8BIT_PACKED(self.ntv, Result).RaiseIfError;
    end;
    private function GetCommandBufferCapabilities: clDeviceCommandBufferCapabilities;
    begin
      cl.GetDeviceInfo_DEVICE_COMMAND_BUFFER_CAPABILITIES(self.ntv, Result).RaiseIfError;
    end;
    private function GetCommandBufferRequiredQueueProperties: clCommandQueueProperties;
    begin
      cl.GetDeviceInfo_DEVICE_COMMAND_BUFFER_REQUIRED_QUEUE_PROPERTIES(self.ntv, Result).RaiseIfError;
    end;
    private function GetCommandBufferNumSyncDevices: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_COMMAND_BUFFER_NUM_SYNC_DEVICES(self.ntv, Result).RaiseIfError;
    end;
    private function GetCommandBufferSyncDevices: array of cl_device_id;
    begin
      cl.GetDeviceInfo_DEVICE_COMMAND_BUFFER_SYNC_DEVICES(self.ntv, Result).RaiseIfError;
    end;
    private function GetMutableDispatchCapabilities: clMutableDispatchFields;
    begin
      cl.GetDeviceInfo_DEVICE_MUTABLE_DISPATCH_CAPABILITIES(self.ntv, Result).RaiseIfError;
    end;
    private function GetTerminateCapability: clDeviceTerminateCapability;
    begin
      cl.GetDeviceInfo_DEVICE_TERMINATE_CAPABILITY(self.ntv, Result).RaiseIfError;
    end;
    private function GetMaxNamedBarrierCount: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_MAX_NAMED_BARRIER_COUNT(self.ntv, Result).RaiseIfError;
    end;
    private function GetSemaphoreTypes: array of clSemaphoreType;
    begin
      cl.GetDeviceInfo_DEVICE_SEMAPHORE_TYPES(self.ntv, Result).RaiseIfError;
    end;
    private function GetSemaphoreImportHandleTypes: array of clExternalSemaphoreHandleType;
    begin
      cl.GetDeviceInfo_DEVICE_SEMAPHORE_IMPORT_HANDLE_TYPES(self.ntv, Result).RaiseIfError;
    end;
    private function GetSemaphoreExportHandleTypes: array of clExternalSemaphoreHandleType;
    begin
      cl.GetDeviceInfo_DEVICE_SEMAPHORE_EXPORT_HANDLE_TYPES(self.ntv, Result).RaiseIfError;
    end;
    private function GetExternalMemoryImportHandleTypes: array of clExternalMemoryHandleType;
    begin
      cl.GetDeviceInfo_DEVICE_EXTERNAL_MEMORY_IMPORT_HANDLE_TYPES(self.ntv, Result).RaiseIfError;
    end;
    private function GetExternalMemoryImportAssumeLinearImagesHandleTypes: array of clExternalMemoryHandleType;
    begin
      cl.GetDeviceInfo_DEVICE_EXTERNAL_MEMORY_IMPORT_ASSUME_LINEAR_IMAGES_HANDLE_TYPES(self.ntv, Result).RaiseIfError;
    end;
    private function GetComputeCapabilityMajor: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_COMPUTE_CAPABILITY_MAJOR(self.ntv, Result).RaiseIfError;
    end;
    private function GetComputeCapabilityMinor: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_COMPUTE_CAPABILITY_MINOR(self.ntv, Result).RaiseIfError;
    end;
    private function GetRegistersPerBlock: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_REGISTERS_PER_BLOCK(self.ntv, Result).RaiseIfError;
    end;
    private function GetWarpSize: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_WARP_SIZE(self.ntv, Result).RaiseIfError;
    end;
    private function GetGpuOverlap: clBool;
    begin
      cl.GetDeviceInfo_DEVICE_GPU_OVERLAP(self.ntv, Result).RaiseIfError;
    end;
    private function GetKernelExecTimeout: clBool;
    begin
      cl.GetDeviceInfo_DEVICE_KERNEL_EXEC_TIMEOUT(self.ntv, Result).RaiseIfError;
    end;
    private function GetIntegratedMemory: clBool;
    begin
      cl.GetDeviceInfo_DEVICE_INTEGRATED_MEMORY(self.ntv, Result).RaiseIfError;
    end;
    private function GetParentDeviceExt: cl_device_id;
    begin
      cl.GetDeviceInfo_DEVICE_PARENT_DEVICE_EXT(self.ntv, Result).RaiseIfError;
    end;
    private function GetPartitionTypes: array of clDevicePartitionProperty;
    begin
      cl.GetDeviceInfo_DEVICE_PARTITION_TYPES(self.ntv, Result).RaiseIfError;
    end;
    private function GetAffinityDomains: clDeviceAffinityDomain;
    begin
      cl.GetDeviceInfo_DEVICE_AFFINITY_DOMAINS(self.ntv, Result).RaiseIfError;
    end;
    private function GetReferenceCountExt: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_REFERENCE_COUNT_EXT(self.ntv, Result).RaiseIfError;
    end;
    private function GetPartitionStyle: clDevicePartitionProperty;
    begin
      cl.GetDeviceInfo_DEVICE_PARTITION_STYLE(self.ntv, Result).RaiseIfError;
    end;
    private function GetMeVersion: clDeviceMeVersion;
    begin
      cl.GetDeviceInfo_DEVICE_ME_VERSION(self.ntv, Result).RaiseIfError;
    end;
    private function GetSvmCapabilitiesArm: clDeviceSVMCapabilities;
    begin
      cl.GetDeviceInfo_DEVICE_SVM_CAPABILITIES_ARM(self.ntv, Result).RaiseIfError;
    end;
    private function GetComputeUnitsBitfield: UInt64;
    begin
      cl.GetDeviceInfo_DEVICE_COMPUTE_UNITS_BITFIELD(self.ntv, Result).RaiseIfError;
    end;
    private function GetSpirVersions: string;
    begin
      cl.GetDeviceInfo_DEVICE_SPIR_VERSIONS(self.ntv, Result).RaiseIfError;
    end;
    private function GetSimultaneousInterops: array of UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_SIMULTANEOUS_INTEROPS(self.ntv, Result).RaiseIfError;
    end;
    private function GetNumSimultaneousInterops: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_NUM_SIMULTANEOUS_INTEROPS(self.ntv, Result).RaiseIfError;
    end;
    private function GetSubGroupSizes: array of UIntPtr;
    begin
      cl.GetDeviceInfo_DEVICE_SUB_GROUP_SIZES(self.ntv, Result).RaiseIfError;
    end;
    private function GetAvcMeVersion: clDeviceAvcMeVersion;
    begin
      cl.GetDeviceInfo_DEVICE_AVC_ME_VERSION(self.ntv, Result).RaiseIfError;
    end;
    private function GetAvcMeSupportsTextureSamplerUse: clBool;
    begin
      cl.GetDeviceInfo_DEVICE_AVC_ME_SUPPORTS_TEXTURE_SAMPLER_USE(self.ntv, Result).RaiseIfError;
    end;
    private function GetAvcMeSupportsPreemption: clBool;
    begin
      cl.GetDeviceInfo_DEVICE_AVC_ME_SUPPORTS_PREEMPTION(self.ntv, Result).RaiseIfError;
    end;
    private function GetPciBusInfo: cl_device_pci_bus_info;
    begin
      cl.GetDeviceInfo_DEVICE_PCI_BUS_INFO(self.ntv, Result).RaiseIfError;
    end;
    private function GetPlanarYuvMaxWidth: UIntPtr;
    begin
      cl.GetDeviceInfo_DEVICE_PLANAR_YUV_MAX_WIDTH(self.ntv, Result).RaiseIfError;
    end;
    private function GetPlanarYuvMaxHeight: UIntPtr;
    begin
      cl.GetDeviceInfo_DEVICE_PLANAR_YUV_MAX_HEIGHT(self.ntv, Result).RaiseIfError;
    end;
    private function GetQueueFamilyProperties: array of cl_queue_family_properties;
    begin
      cl.GetDeviceInfo_DEVICE_QUEUE_FAMILY_PROPERTIES(self.ntv, Result).RaiseIfError;
    end;
    private function GetHostMemCapabilities: clDeviceUnifiedSharedMemoryCapabilities;
    begin
      cl.GetDeviceInfo_DEVICE_HOST_MEM_CAPABILITIES(self.ntv, Result).RaiseIfError;
    end;
    private function GetDeviceMemCapabilities: clDeviceUnifiedSharedMemoryCapabilities;
    begin
      cl.GetDeviceInfo_DEVICE_DEVICE_MEM_CAPABILITIES(self.ntv, Result).RaiseIfError;
    end;
    private function GetSingleDeviceSharedMemCapabilities: clDeviceUnifiedSharedMemoryCapabilities;
    begin
      cl.GetDeviceInfo_DEVICE_SINGLE_DEVICE_SHARED_MEM_CAPABILITIES(self.ntv, Result).RaiseIfError;
    end;
    private function GetCrossDeviceSharedMemCapabilities: clDeviceUnifiedSharedMemoryCapabilities;
    begin
      cl.GetDeviceInfo_DEVICE_CROSS_DEVICE_SHARED_MEM_CAPABILITIES(self.ntv, Result).RaiseIfError;
    end;
    private function GetSharedSystemMemCapabilities: clDeviceUnifiedSharedMemoryCapabilities;
    begin
      cl.GetDeviceInfo_DEVICE_SHARED_SYSTEM_MEM_CAPABILITIES(self.ntv, Result).RaiseIfError;
    end;
    private function GetJobSlots: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_JOB_SLOTS(self.ntv, Result).RaiseIfError;
    end;
    private function GetSchedulingControlsCapabilities: clDeviceSchedulingControlsCapabilities;
    begin
      cl.GetDeviceInfo_DEVICE_SCHEDULING_CONTROLS_CAPABILITIES(self.ntv, Result).RaiseIfError;
    end;
    private function GetMaxWarpCount: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_MAX_WARP_COUNT(self.ntv, Result).RaiseIfError;
    end;
    private function GetSupportedRegisterAllocations: array of Int32;
    begin
      cl.GetDeviceInfo_DEVICE_SUPPORTED_REGISTER_ALLOCATIONS(self.ntv, Result).RaiseIfError;
    end;
    private function GetControlledTerminationCapabilities: clDeviceControlledTerminationCapabilities;
    begin
      cl.GetDeviceInfo_DEVICE_CONTROLLED_TERMINATION_CAPABILITIES(self.ntv, Result).RaiseIfError;
    end;
    private function GetCxxForOpenclNumericVersion: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_CXX_FOR_OPENCL_NUMERIC_VERSION(self.ntv, Result).RaiseIfError;
    end;
    private function GetSingleFpAtomicCapabilities: clDeviceFpAtomicCapabilities;
    begin
      cl.GetDeviceInfo_DEVICE_SINGLE_FP_ATOMIC_CAPABILITIES(self.ntv, Result).RaiseIfError;
    end;
    private function GetDoubleFpAtomicCapabilities: clDeviceFpAtomicCapabilities;
    begin
      cl.GetDeviceInfo_DEVICE_DOUBLE_FP_ATOMIC_CAPABILITIES(self.ntv, Result).RaiseIfError;
    end;
    private function GetHalfFpAtomicCapabilities: clDeviceFpAtomicCapabilities;
    begin
      cl.GetDeviceInfo_DEVICE_HALF_FP_ATOMIC_CAPABILITIES(self.ntv, Result).RaiseIfError;
    end;
    private function GetIpVersion: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_IP_VERSION(self.ntv, Result).RaiseIfError;
    end;
    private function GetId: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_ID(self.ntv, Result).RaiseIfError;
    end;
    private function GetNumSlices: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_NUM_SLICES(self.ntv, Result).RaiseIfError;
    end;
    private function GetNumSubSlicesPerSlice: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_NUM_SUB_SLICES_PER_SLICE(self.ntv, Result).RaiseIfError;
    end;
    private function GetNumEusPerSubSlice: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_NUM_EUS_PER_SUB_SLICE(self.ntv, Result).RaiseIfError;
    end;
    private function GetNumThreadsPerEu: UInt32;
    begin
      cl.GetDeviceInfo_DEVICE_NUM_THREADS_PER_EU(self.ntv, Result).RaiseIfError;
    end;
    private function GetFeatureCapabilities: clDeviceFeatureCapabilities;
    begin
      cl.GetDeviceInfo_DEVICE_FEATURE_CAPABILITIES(self.ntv, Result).RaiseIfError;
    end;
    private function GetMemoryCapabilities: clMemAllocFlagsIMG;
    begin
      cl.GetDeviceInfo_DEVICE_MEMORY_CAPABILITIES(self.ntv, Result).RaiseIfError;
    end;
    
    public property &Type:                                               clDeviceType                                          read GetType;
    public property VendorId:                                            clKhronosVendorId                                     read GetVendorId;
    public property MaxComputeUnits:                                     UInt32                                                read GetMaxComputeUnits;
    public property MaxWorkItemDimensions:                               UInt32                                                read GetMaxWorkItemDimensions;
    public property MaxWorkGroupSize:                                    UIntPtr                                               read GetMaxWorkGroupSize;
    public property MaxWorkItemSizes:                                    array of UIntPtr                                      read GetMaxWorkItemSizes;
    public property PreferredVectorWidthChar:                            UInt32                                                read GetPreferredVectorWidthChar;
    public property PreferredVectorWidthShort:                           UInt32                                                read GetPreferredVectorWidthShort;
    public property PreferredVectorWidthInt:                             UInt32                                                read GetPreferredVectorWidthInt;
    public property PreferredVectorWidthLong:                            UInt32                                                read GetPreferredVectorWidthLong;
    public property PreferredVectorWidthFloat:                           UInt32                                                read GetPreferredVectorWidthFloat;
    public property PreferredVectorWidthDouble:                          UInt32                                                read GetPreferredVectorWidthDouble;
    public property MaxClockFrequency:                                   UInt32                                                read GetMaxClockFrequency;
    public property AddressBits:                                         UInt32                                                read GetAddressBits;
    public property MaxReadImageArgs:                                    UInt32                                                read GetMaxReadImageArgs;
    public property MaxWriteImageArgs:                                   UInt32                                                read GetMaxWriteImageArgs;
    public property MaxMemAllocSize:                                     UInt64                                                read GetMaxMemAllocSize;
    public property Image2dMaxWidth:                                     UIntPtr                                               read GetImage2dMaxWidth;
    public property Image2dMaxHeight:                                    UIntPtr                                               read GetImage2dMaxHeight;
    public property Image3dMaxWidth:                                     UIntPtr                                               read GetImage3dMaxWidth;
    public property Image3dMaxHeight:                                    UIntPtr                                               read GetImage3dMaxHeight;
    public property Image3dMaxDepth:                                     UIntPtr                                               read GetImage3dMaxDepth;
    public property ImageSupport:                                        clBool                                                read GetImageSupport;
    public property MaxParameterSize:                                    UIntPtr                                               read GetMaxParameterSize;
    public property MaxSamplers:                                         UInt32                                                read GetMaxSamplers;
    public property MemBaseAddrAlign:                                    UInt32                                                read GetMemBaseAddrAlign;
    public property MinDataTypeAlignSize:                                UInt32                                                read GetMinDataTypeAlignSize;
    public property SingleFpConfig:                                      clDeviceFPConfig                                      read GetSingleFpConfig;
    public property GlobalMemCacheType:                                  clDeviceMemCacheType                                  read GetGlobalMemCacheType;
    public property GlobalMemCachelineSize:                              UInt32                                                read GetGlobalMemCachelineSize;
    public property GlobalMemCacheSize:                                  UInt64                                                read GetGlobalMemCacheSize;
    public property GlobalMemSize:                                       UInt64                                                read GetGlobalMemSize;
    public property MaxConstantBufferSize:                               UInt64                                                read GetMaxConstantBufferSize;
    public property MaxConstantArgs:                                     UInt32                                                read GetMaxConstantArgs;
    public property LocalMemType:                                        clDeviceLocalMemType                                  read GetLocalMemType;
    public property LocalMemSize:                                        UInt64                                                read GetLocalMemSize;
    public property ErrorCorrectionSupport:                              clBool                                                read GetErrorCorrectionSupport;
    public property ProfilingTimerResolution:                            UIntPtr                                               read GetProfilingTimerResolution;
    public property EndianLittle:                                        clBool                                                read GetEndianLittle;
    public property Available:                                           clBool                                                read GetAvailable;
    public property CompilerAvailable:                                   clBool                                                read GetCompilerAvailable;
    public property ExecutionCapabilities:                               clDeviceExecCapabilities                              read GetExecutionCapabilities;
    public property QueueProperties:                                     clCommandQueueProperties                              read GetQueueProperties;
    public property QueueOnHostProperties:                               clCommandQueueProperties                              read GetQueueOnHostProperties;
    public property Name:                                                string                                                read GetName;
    public property Vendor:                                              string                                                read GetVendor;
    public property DriverVersion:                                       string                                                read GetDriverVersion;
    public property Profile:                                             string                                                read GetProfile;
    public property Version:                                             string                                                read GetVersion;
    public property Extensions:                                          string                                                read GetExtensions;
    public property DoubleFpConfig:                                      clDeviceFPConfig                                      read GetDoubleFpConfig;
    public property HalfFpConfig:                                        clDeviceFPConfig                                      read GetHalfFpConfig;
    public property PreferredVectorWidthHalf:                            UInt32                                                read GetPreferredVectorWidthHalf;
    public property HostUnifiedMemory:                                   clBool                                                read GetHostUnifiedMemory;
    public property NativeVectorWidthChar:                               UInt32                                                read GetNativeVectorWidthChar;
    public property NativeVectorWidthShort:                              UInt32                                                read GetNativeVectorWidthShort;
    public property NativeVectorWidthInt:                                UInt32                                                read GetNativeVectorWidthInt;
    public property NativeVectorWidthLong:                               UInt32                                                read GetNativeVectorWidthLong;
    public property NativeVectorWidthFloat:                              UInt32                                                read GetNativeVectorWidthFloat;
    public property NativeVectorWidthDouble:                             UInt32                                                read GetNativeVectorWidthDouble;
    public property NativeVectorWidthHalf:                               UInt32                                                read GetNativeVectorWidthHalf;
    public property OpenclCVersion:                                      string                                                read GetOpenclCVersion;
    public property LinkerAvailable:                                     clBool                                                read GetLinkerAvailable;
    public property BuiltInKernels:                                      string                                                read GetBuiltInKernels;
    public property ImageMaxBufferSize:                                  UIntPtr                                               read GetImageMaxBufferSize;
    public property ImageMaxArraySize:                                   UIntPtr                                               read GetImageMaxArraySize;
    public property ParentDevice:                                        cl_device_id                                          read GetParentDevice;
    public property PartitionMaxSubDevices:                              UInt32                                                read GetPartitionMaxSubDevices;
    public property PartitionProperties:                                 array of clDevicePartitionProperty                    read GetPartitionProperties;
    public property PartitionAffinityDomain:                             clDeviceAffinityDomain                                read GetPartitionAffinityDomain;
    public property PartitionType:                                       array of clDevicePartitionProperty                    read GetPartitionType;
    public property ReferenceCount:                                      UInt32                                                read GetReferenceCount;
    public property PreferredInteropUserSync:                            clBool                                                read GetPreferredInteropUserSync;
    public property PrintfBufferSize:                                    UIntPtr                                               read GetPrintfBufferSize;
    public property ImagePitchAlignment:                                 UInt32                                                read GetImagePitchAlignment;
    public property ImageBaseAddressAlignment:                           UInt32                                                read GetImageBaseAddressAlignment;
    public property MaxReadWriteImageArgs:                               UInt32                                                read GetMaxReadWriteImageArgs;
    public property MaxGlobalVariableSize:                               UIntPtr                                               read GetMaxGlobalVariableSize;
    public property QueueOnDeviceProperties:                             clCommandQueueProperties                              read GetQueueOnDeviceProperties;
    public property QueueOnDevicePreferredSize:                          UInt32                                                read GetQueueOnDevicePreferredSize;
    public property QueueOnDeviceMaxSize:                                UInt32                                                read GetQueueOnDeviceMaxSize;
    public property MaxOnDeviceQueues:                                   UInt32                                                read GetMaxOnDeviceQueues;
    public property MaxOnDeviceEvents:                                   UInt32                                                read GetMaxOnDeviceEvents;
    public property SvmCapabilities:                                     clDeviceSVMCapabilities                               read GetSvmCapabilities;
    public property GlobalVariablePreferredTotalSize:                    UIntPtr                                               read GetGlobalVariablePreferredTotalSize;
    public property MaxPipeArgs:                                         UInt32                                                read GetMaxPipeArgs;
    public property PipeMaxActiveReservations:                           UInt32                                                read GetPipeMaxActiveReservations;
    public property PipeMaxPacketSize:                                   UInt32                                                read GetPipeMaxPacketSize;
    public property PreferredPlatformAtomicAlignment:                    UInt32                                                read GetPreferredPlatformAtomicAlignment;
    public property PreferredGlobalAtomicAlignment:                      UInt32                                                read GetPreferredGlobalAtomicAlignment;
    public property PreferredLocalAtomicAlignment:                       UInt32                                                read GetPreferredLocalAtomicAlignment;
    public property IlVersion:                                           string                                                read GetIlVersion;
    public property MaxNumSubGroups:                                     UInt32                                                read GetMaxNumSubGroups;
    public property SubGroupIndependentForwardProgress:                  clBool                                                read GetSubGroupIndependentForwardProgress;
    public property NumericVersion:                                      UInt32                                                read GetNumericVersion;
    public property OpenclCNumericVersion:                               UInt32                                                read GetOpenclCNumericVersion;
    public property ExtensionsWithVersion:                               array of cl_name_version                              read GetExtensionsWithVersion;
    public property IlsWithVersion:                                      array of cl_name_version                              read GetIlsWithVersion;
    public property BuiltInKernelsWithVersion:                           array of cl_name_version                              read GetBuiltInKernelsWithVersion;
    public property AtomicMemoryCapabilities:                            clDeviceAtomicCapabilities                            read GetAtomicMemoryCapabilities;
    public property AtomicFenceCapabilities:                             clDeviceAtomicCapabilities                            read GetAtomicFenceCapabilities;
    public property NonUniformWorkGroupSupport:                          clBool                                                read GetNonUniformWorkGroupSupport;
    public property OpenclCAllVersions:                                  array of cl_name_version                              read GetOpenclCAllVersions;
    public property PreferredWorkGroupSizeMultiple:                      UIntPtr                                               read GetPreferredWorkGroupSizeMultiple;
    public property WorkGroupCollectiveFunctionsSupport:                 clBool                                                read GetWorkGroupCollectiveFunctionsSupport;
    public property GenericAddressSpaceSupport:                          clBool                                                read GetGenericAddressSpaceSupport;
    public property Uuid:                                                array of Byte                                         read GetUuid;
    public property DriverUuid:                                          array of Byte                                         read GetDriverUuid;
    public property LuidValid:                                           clBool                                                read GetLuidValid;
    public property Luid:                                                array of Byte                                         read GetLuid;
    public property NodeMask:                                            UInt32                                                read GetNodeMask;
    public property OpenclCFeatures:                                     array of cl_name_version                              read GetOpenclCFeatures;
    public property DeviceEnqueueCapabilities:                           clDeviceOnDeviceEnqueueCapabilities                   read GetDeviceEnqueueCapabilities;
    public property PipeSupport:                                         clBool                                                read GetPipeSupport;
    public property LatestConformanceVersionPassed:                      string                                                read GetLatestConformanceVersionPassed;
    public property IntegerDotProductCapabilities:                       clDeviceIntegerDotProductCapabilities                 read GetIntegerDotProductCapabilities;
    public property IntegerDotProductAccelerationProperties8bit:         cl_device_integer_dot_product_acceleration_properties read GetIntegerDotProductAccelerationProperties8bit;
    public property IntegerDotProductAccelerationProperties4x8bitPacked: cl_device_integer_dot_product_acceleration_properties read GetIntegerDotProductAccelerationProperties4x8bitPacked;
    public property CommandBufferCapabilities:                           clDeviceCommandBufferCapabilities                     read GetCommandBufferCapabilities;
    public property CommandBufferRequiredQueueProperties:                clCommandQueueProperties                              read GetCommandBufferRequiredQueueProperties;
    public property CommandBufferNumSyncDevices:                         UInt32                                                read GetCommandBufferNumSyncDevices;
    public property CommandBufferSyncDevices:                            array of cl_device_id                                 read GetCommandBufferSyncDevices;
    public property MutableDispatchCapabilities:                         clMutableDispatchFields                               read GetMutableDispatchCapabilities;
    public property TerminateCapability:                                 clDeviceTerminateCapability                           read GetTerminateCapability;
    public property MaxNamedBarrierCount:                                UInt32                                                read GetMaxNamedBarrierCount;
    public property SemaphoreTypes:                                      array of clSemaphoreType                              read GetSemaphoreTypes;
    public property SemaphoreImportHandleTypes:                          array of clExternalSemaphoreHandleType                read GetSemaphoreImportHandleTypes;
    public property SemaphoreExportHandleTypes:                          array of clExternalSemaphoreHandleType                read GetSemaphoreExportHandleTypes;
    public property ExternalMemoryImportHandleTypes:                     array of clExternalMemoryHandleType                   read GetExternalMemoryImportHandleTypes;
    public property ExternalMemoryImportAssumeLinearImagesHandleTypes:   array of clExternalMemoryHandleType                   read GetExternalMemoryImportAssumeLinearImagesHandleTypes;
    public property ComputeCapabilityMajor:                              UInt32                                                read GetComputeCapabilityMajor;
    public property ComputeCapabilityMinor:                              UInt32                                                read GetComputeCapabilityMinor;
    public property RegistersPerBlock:                                   UInt32                                                read GetRegistersPerBlock;
    public property WarpSize:                                            UInt32                                                read GetWarpSize;
    public property GpuOverlap:                                          clBool                                                read GetGpuOverlap;
    public property KernelExecTimeout:                                   clBool                                                read GetKernelExecTimeout;
    public property IntegratedMemory:                                    clBool                                                read GetIntegratedMemory;
    public property ParentDeviceExt:                                     cl_device_id                                          read GetParentDeviceExt;
    public property PartitionTypes:                                      array of clDevicePartitionProperty                    read GetPartitionTypes;
    public property AffinityDomains:                                     clDeviceAffinityDomain                                read GetAffinityDomains;
    public property ReferenceCountExt:                                   UInt32                                                read GetReferenceCountExt;
    public property PartitionStyle:                                      clDevicePartitionProperty                             read GetPartitionStyle;
    public property MeVersion:                                           clDeviceMeVersion                                     read GetMeVersion;
    public property SvmCapabilitiesArm:                                  clDeviceSVMCapabilities                               read GetSvmCapabilitiesArm;
    public property ComputeUnitsBitfield:                                UInt64                                                read GetComputeUnitsBitfield;
    public property SpirVersions:                                        string                                                read GetSpirVersions;
    public property SimultaneousInterops:                                array of UInt32                                       read GetSimultaneousInterops;
    public property NumSimultaneousInterops:                             UInt32                                                read GetNumSimultaneousInterops;
    public property SubGroupSizes:                                       array of UIntPtr                                      read GetSubGroupSizes;
    public property AvcMeVersion:                                        clDeviceAvcMeVersion                                  read GetAvcMeVersion;
    public property AvcMeSupportsTextureSamplerUse:                      clBool                                                read GetAvcMeSupportsTextureSamplerUse;
    public property AvcMeSupportsPreemption:                             clBool                                                read GetAvcMeSupportsPreemption;
    public property PciBusInfo:                                          cl_device_pci_bus_info                                read GetPciBusInfo;
    public property PlanarYuvMaxWidth:                                   UIntPtr                                               read GetPlanarYuvMaxWidth;
    public property PlanarYuvMaxHeight:                                  UIntPtr                                               read GetPlanarYuvMaxHeight;
    public property QueueFamilyProperties:                               array of cl_queue_family_properties                   read GetQueueFamilyProperties;
    public property HostMemCapabilities:                                 clDeviceUnifiedSharedMemoryCapabilities               read GetHostMemCapabilities;
    public property DeviceMemCapabilities:                               clDeviceUnifiedSharedMemoryCapabilities               read GetDeviceMemCapabilities;
    public property SingleDeviceSharedMemCapabilities:                   clDeviceUnifiedSharedMemoryCapabilities               read GetSingleDeviceSharedMemCapabilities;
    public property CrossDeviceSharedMemCapabilities:                    clDeviceUnifiedSharedMemoryCapabilities               read GetCrossDeviceSharedMemCapabilities;
    public property SharedSystemMemCapabilities:                         clDeviceUnifiedSharedMemoryCapabilities               read GetSharedSystemMemCapabilities;
    public property JobSlots:                                            UInt32                                                read GetJobSlots;
    public property SchedulingControlsCapabilities:                      clDeviceSchedulingControlsCapabilities                read GetSchedulingControlsCapabilities;
    public property MaxWarpCount:                                        UInt32                                                read GetMaxWarpCount;
    public property SupportedRegisterAllocations:                        array of Int32                                        read GetSupportedRegisterAllocations;
    public property ControlledTerminationCapabilities:                   clDeviceControlledTerminationCapabilities             read GetControlledTerminationCapabilities;
    public property CxxForOpenclNumericVersion:                          UInt32                                                read GetCxxForOpenclNumericVersion;
    public property SingleFpAtomicCapabilities:                          clDeviceFpAtomicCapabilities                          read GetSingleFpAtomicCapabilities;
    public property DoubleFpAtomicCapabilities:                          clDeviceFpAtomicCapabilities                          read GetDoubleFpAtomicCapabilities;
    public property HalfFpAtomicCapabilities:                            clDeviceFpAtomicCapabilities                          read GetHalfFpAtomicCapabilities;
    public property IpVersion:                                           UInt32                                                read GetIpVersion;
    public property Id:                                                  UInt32                                                read GetId;
    public property NumSlices:                                           UInt32                                                read GetNumSlices;
    public property NumSubSlicesPerSlice:                                UInt32                                                read GetNumSubSlicesPerSlice;
    public property NumEusPerSubSlice:                                   UInt32                                                read GetNumEusPerSubSlice;
    public property NumThreadsPerEu:                                     UInt32                                                read GetNumThreadsPerEu;
    public property FeatureCapabilities:                                 clDeviceFeatureCapabilities                           read GetFeatureCapabilities;
    public property MemoryCapabilities:                                  clMemAllocFlagsIMG                                    read GetMemoryCapabilities;
    
    private static procedure AddProp<T>(res: StringBuilder; get_prop: ()->T) :=
      try
        res += _ObjectToString(get_prop());
      except
        on e: OpenCLException do
          res += e.Code.ToString;
      end;
    public procedure ToString(res: StringBuilder); virtual;
    begin
      res += 'Type                                                = '; AddProp(res, GetType                                              ); res += #10;
      res += 'VendorId                                            = '; AddProp(res, GetVendorId                                           ); res += #10;
      res += 'MaxComputeUnits                                     = '; AddProp(res, GetMaxComputeUnits                                    ); res += #10;
      res += 'MaxWorkItemDimensions                               = '; AddProp(res, GetMaxWorkItemDimensions                              ); res += #10;
      res += 'MaxWorkGroupSize                                    = '; AddProp(res, GetMaxWorkGroupSize                                   ); res += #10;
      res += 'MaxWorkItemSizes                                    = '; AddProp(res, GetMaxWorkItemSizes                                   ); res += #10;
      res += 'PreferredVectorWidthChar                            = '; AddProp(res, GetPreferredVectorWidthChar                           ); res += #10;
      res += 'PreferredVectorWidthShort                           = '; AddProp(res, GetPreferredVectorWidthShort                          ); res += #10;
      res += 'PreferredVectorWidthInt                             = '; AddProp(res, GetPreferredVectorWidthInt                            ); res += #10;
      res += 'PreferredVectorWidthLong                            = '; AddProp(res, GetPreferredVectorWidthLong                           ); res += #10;
      res += 'PreferredVectorWidthFloat                           = '; AddProp(res, GetPreferredVectorWidthFloat                          ); res += #10;
      res += 'PreferredVectorWidthDouble                          = '; AddProp(res, GetPreferredVectorWidthDouble                         ); res += #10;
      res += 'MaxClockFrequency                                   = '; AddProp(res, GetMaxClockFrequency                                  ); res += #10;
      res += 'AddressBits                                         = '; AddProp(res, GetAddressBits                                        ); res += #10;
      res += 'MaxReadImageArgs                                    = '; AddProp(res, GetMaxReadImageArgs                                   ); res += #10;
      res += 'MaxWriteImageArgs                                   = '; AddProp(res, GetMaxWriteImageArgs                                  ); res += #10;
      res += 'MaxMemAllocSize                                     = '; AddProp(res, GetMaxMemAllocSize                                    ); res += #10;
      res += 'Image2dMaxWidth                                     = '; AddProp(res, GetImage2dMaxWidth                                    ); res += #10;
      res += 'Image2dMaxHeight                                    = '; AddProp(res, GetImage2dMaxHeight                                   ); res += #10;
      res += 'Image3dMaxWidth                                     = '; AddProp(res, GetImage3dMaxWidth                                    ); res += #10;
      res += 'Image3dMaxHeight                                    = '; AddProp(res, GetImage3dMaxHeight                                   ); res += #10;
      res += 'Image3dMaxDepth                                     = '; AddProp(res, GetImage3dMaxDepth                                    ); res += #10;
      res += 'ImageSupport                                        = '; AddProp(res, GetImageSupport                                       ); res += #10;
      res += 'MaxParameterSize                                    = '; AddProp(res, GetMaxParameterSize                                   ); res += #10;
      res += 'MaxSamplers                                         = '; AddProp(res, GetMaxSamplers                                        ); res += #10;
      res += 'MemBaseAddrAlign                                    = '; AddProp(res, GetMemBaseAddrAlign                                   ); res += #10;
      res += 'MinDataTypeAlignSize                                = '; AddProp(res, GetMinDataTypeAlignSize                               ); res += #10;
      res += 'SingleFpConfig                                      = '; AddProp(res, GetSingleFpConfig                                     ); res += #10;
      res += 'GlobalMemCacheType                                  = '; AddProp(res, GetGlobalMemCacheType                                 ); res += #10;
      res += 'GlobalMemCachelineSize                              = '; AddProp(res, GetGlobalMemCachelineSize                             ); res += #10;
      res += 'GlobalMemCacheSize                                  = '; AddProp(res, GetGlobalMemCacheSize                                 ); res += #10;
      res += 'GlobalMemSize                                       = '; AddProp(res, GetGlobalMemSize                                      ); res += #10;
      res += 'MaxConstantBufferSize                               = '; AddProp(res, GetMaxConstantBufferSize                              ); res += #10;
      res += 'MaxConstantArgs                                     = '; AddProp(res, GetMaxConstantArgs                                    ); res += #10;
      res += 'LocalMemType                                        = '; AddProp(res, GetLocalMemType                                       ); res += #10;
      res += 'LocalMemSize                                        = '; AddProp(res, GetLocalMemSize                                       ); res += #10;
      res += 'ErrorCorrectionSupport                              = '; AddProp(res, GetErrorCorrectionSupport                             ); res += #10;
      res += 'ProfilingTimerResolution                            = '; AddProp(res, GetProfilingTimerResolution                           ); res += #10;
      res += 'EndianLittle                                        = '; AddProp(res, GetEndianLittle                                       ); res += #10;
      res += 'Available                                           = '; AddProp(res, GetAvailable                                          ); res += #10;
      res += 'CompilerAvailable                                   = '; AddProp(res, GetCompilerAvailable                                  ); res += #10;
      res += 'ExecutionCapabilities                               = '; AddProp(res, GetExecutionCapabilities                              ); res += #10;
      res += 'QueueProperties                                     = '; AddProp(res, GetQueueProperties                                    ); res += #10;
      res += 'QueueOnHostProperties                               = '; AddProp(res, GetQueueOnHostProperties                              ); res += #10;
      res += 'Name                                                = '; AddProp(res, GetName                                               ); res += #10;
      res += 'Vendor                                              = '; AddProp(res, GetVendor                                             ); res += #10;
      res += 'DriverVersion                                       = '; AddProp(res, GetDriverVersion                                      ); res += #10;
      res += 'Profile                                             = '; AddProp(res, GetProfile                                            ); res += #10;
      res += 'Version                                             = '; AddProp(res, GetVersion                                            ); res += #10;
      res += 'Extensions                                          = '; AddProp(res, GetExtensions                                         ); res += #10;
      res += 'DoubleFpConfig                                      = '; AddProp(res, GetDoubleFpConfig                                     ); res += #10;
      res += 'HalfFpConfig                                        = '; AddProp(res, GetHalfFpConfig                                       ); res += #10;
      res += 'PreferredVectorWidthHalf                            = '; AddProp(res, GetPreferredVectorWidthHalf                           ); res += #10;
      res += 'HostUnifiedMemory                                   = '; AddProp(res, GetHostUnifiedMemory                                  ); res += #10;
      res += 'NativeVectorWidthChar                               = '; AddProp(res, GetNativeVectorWidthChar                              ); res += #10;
      res += 'NativeVectorWidthShort                              = '; AddProp(res, GetNativeVectorWidthShort                             ); res += #10;
      res += 'NativeVectorWidthInt                                = '; AddProp(res, GetNativeVectorWidthInt                               ); res += #10;
      res += 'NativeVectorWidthLong                               = '; AddProp(res, GetNativeVectorWidthLong                              ); res += #10;
      res += 'NativeVectorWidthFloat                              = '; AddProp(res, GetNativeVectorWidthFloat                             ); res += #10;
      res += 'NativeVectorWidthDouble                             = '; AddProp(res, GetNativeVectorWidthDouble                            ); res += #10;
      res += 'NativeVectorWidthHalf                               = '; AddProp(res, GetNativeVectorWidthHalf                              ); res += #10;
      res += 'OpenclCVersion                                      = '; AddProp(res, GetOpenclCVersion                                     ); res += #10;
      res += 'LinkerAvailable                                     = '; AddProp(res, GetLinkerAvailable                                    ); res += #10;
      res += 'BuiltInKernels                                      = '; AddProp(res, GetBuiltInKernels                                     ); res += #10;
      res += 'ImageMaxBufferSize                                  = '; AddProp(res, GetImageMaxBufferSize                                 ); res += #10;
      res += 'ImageMaxArraySize                                   = '; AddProp(res, GetImageMaxArraySize                                  ); res += #10;
      res += 'ParentDevice                                        = '; AddProp(res, GetParentDevice                                       ); res += #10;
      res += 'PartitionMaxSubDevices                              = '; AddProp(res, GetPartitionMaxSubDevices                             ); res += #10;
      res += 'PartitionProperties                                 = '; AddProp(res, GetPartitionProperties                                ); res += #10;
      res += 'PartitionAffinityDomain                             = '; AddProp(res, GetPartitionAffinityDomain                            ); res += #10;
      res += 'PartitionType                                       = '; AddProp(res, GetPartitionType                                      ); res += #10;
      res += 'ReferenceCount                                      = '; AddProp(res, GetReferenceCount                                     ); res += #10;
      res += 'PreferredInteropUserSync                            = '; AddProp(res, GetPreferredInteropUserSync                           ); res += #10;
      res += 'PrintfBufferSize                                    = '; AddProp(res, GetPrintfBufferSize                                   ); res += #10;
      res += 'ImagePitchAlignment                                 = '; AddProp(res, GetImagePitchAlignment                                ); res += #10;
      res += 'ImageBaseAddressAlignment                           = '; AddProp(res, GetImageBaseAddressAlignment                          ); res += #10;
      res += 'MaxReadWriteImageArgs                               = '; AddProp(res, GetMaxReadWriteImageArgs                              ); res += #10;
      res += 'MaxGlobalVariableSize                               = '; AddProp(res, GetMaxGlobalVariableSize                              ); res += #10;
      res += 'QueueOnDeviceProperties                             = '; AddProp(res, GetQueueOnDeviceProperties                            ); res += #10;
      res += 'QueueOnDevicePreferredSize                          = '; AddProp(res, GetQueueOnDevicePreferredSize                         ); res += #10;
      res += 'QueueOnDeviceMaxSize                                = '; AddProp(res, GetQueueOnDeviceMaxSize                               ); res += #10;
      res += 'MaxOnDeviceQueues                                   = '; AddProp(res, GetMaxOnDeviceQueues                                  ); res += #10;
      res += 'MaxOnDeviceEvents                                   = '; AddProp(res, GetMaxOnDeviceEvents                                  ); res += #10;
      res += 'SvmCapabilities                                     = '; AddProp(res, GetSvmCapabilities                                    ); res += #10;
      res += 'GlobalVariablePreferredTotalSize                    = '; AddProp(res, GetGlobalVariablePreferredTotalSize                   ); res += #10;
      res += 'MaxPipeArgs                                         = '; AddProp(res, GetMaxPipeArgs                                        ); res += #10;
      res += 'PipeMaxActiveReservations                           = '; AddProp(res, GetPipeMaxActiveReservations                          ); res += #10;
      res += 'PipeMaxPacketSize                                   = '; AddProp(res, GetPipeMaxPacketSize                                  ); res += #10;
      res += 'PreferredPlatformAtomicAlignment                    = '; AddProp(res, GetPreferredPlatformAtomicAlignment                   ); res += #10;
      res += 'PreferredGlobalAtomicAlignment                      = '; AddProp(res, GetPreferredGlobalAtomicAlignment                     ); res += #10;
      res += 'PreferredLocalAtomicAlignment                       = '; AddProp(res, GetPreferredLocalAtomicAlignment                      ); res += #10;
      res += 'IlVersion                                           = '; AddProp(res, GetIlVersion                                          ); res += #10;
      res += 'MaxNumSubGroups                                     = '; AddProp(res, GetMaxNumSubGroups                                    ); res += #10;
      res += 'SubGroupIndependentForwardProgress                  = '; AddProp(res, GetSubGroupIndependentForwardProgress                 ); res += #10;
      res += 'NumericVersion                                      = '; AddProp(res, GetNumericVersion                                     ); res += #10;
      res += 'OpenclCNumericVersion                               = '; AddProp(res, GetOpenclCNumericVersion                              ); res += #10;
      res += 'ExtensionsWithVersion                               = '; AddProp(res, GetExtensionsWithVersion                              ); res += #10;
      res += 'IlsWithVersion                                      = '; AddProp(res, GetIlsWithVersion                                     ); res += #10;
      res += 'BuiltInKernelsWithVersion                           = '; AddProp(res, GetBuiltInKernelsWithVersion                          ); res += #10;
      res += 'AtomicMemoryCapabilities                            = '; AddProp(res, GetAtomicMemoryCapabilities                           ); res += #10;
      res += 'AtomicFenceCapabilities                             = '; AddProp(res, GetAtomicFenceCapabilities                            ); res += #10;
      res += 'NonUniformWorkGroupSupport                          = '; AddProp(res, GetNonUniformWorkGroupSupport                         ); res += #10;
      res += 'OpenclCAllVersions                                  = '; AddProp(res, GetOpenclCAllVersions                                 ); res += #10;
      res += 'PreferredWorkGroupSizeMultiple                      = '; AddProp(res, GetPreferredWorkGroupSizeMultiple                     ); res += #10;
      res += 'WorkGroupCollectiveFunctionsSupport                 = '; AddProp(res, GetWorkGroupCollectiveFunctionsSupport                ); res += #10;
      res += 'GenericAddressSpaceSupport                          = '; AddProp(res, GetGenericAddressSpaceSupport                         ); res += #10;
      res += 'Uuid                                                = '; AddProp(res, GetUuid                                               ); res += #10;
      res += 'DriverUuid                                          = '; AddProp(res, GetDriverUuid                                         ); res += #10;
      res += 'LuidValid                                           = '; AddProp(res, GetLuidValid                                          ); res += #10;
      res += 'Luid                                                = '; AddProp(res, GetLuid                                               ); res += #10;
      res += 'NodeMask                                            = '; AddProp(res, GetNodeMask                                           ); res += #10;
      res += 'OpenclCFeatures                                     = '; AddProp(res, GetOpenclCFeatures                                    ); res += #10;
      res += 'DeviceEnqueueCapabilities                           = '; AddProp(res, GetDeviceEnqueueCapabilities                          ); res += #10;
      res += 'PipeSupport                                         = '; AddProp(res, GetPipeSupport                                        ); res += #10;
      res += 'LatestConformanceVersionPassed                      = '; AddProp(res, GetLatestConformanceVersionPassed                     ); res += #10;
      res += 'IntegerDotProductCapabilities                       = '; AddProp(res, GetIntegerDotProductCapabilities                      ); res += #10;
      res += 'IntegerDotProductAccelerationProperties8bit         = '; AddProp(res, GetIntegerDotProductAccelerationProperties8bit        ); res += #10;
      res += 'IntegerDotProductAccelerationProperties4x8bitPacked = '; AddProp(res, GetIntegerDotProductAccelerationProperties4x8bitPacked); res += #10;
      res += 'CommandBufferCapabilities                           = '; AddProp(res, GetCommandBufferCapabilities                          ); res += #10;
      res += 'CommandBufferRequiredQueueProperties                = '; AddProp(res, GetCommandBufferRequiredQueueProperties               ); res += #10;
      res += 'CommandBufferNumSyncDevices                         = '; AddProp(res, GetCommandBufferNumSyncDevices                        ); res += #10;
      res += 'CommandBufferSyncDevices                            = '; AddProp(res, GetCommandBufferSyncDevices                           ); res += #10;
      res += 'MutableDispatchCapabilities                         = '; AddProp(res, GetMutableDispatchCapabilities                        ); res += #10;
      res += 'TerminateCapability                                 = '; AddProp(res, GetTerminateCapability                                ); res += #10;
      res += 'MaxNamedBarrierCount                                = '; AddProp(res, GetMaxNamedBarrierCount                               ); res += #10;
      res += 'SemaphoreTypes                                      = '; AddProp(res, GetSemaphoreTypes                                     ); res += #10;
      res += 'SemaphoreImportHandleTypes                          = '; AddProp(res, GetSemaphoreImportHandleTypes                         ); res += #10;
      res += 'SemaphoreExportHandleTypes                          = '; AddProp(res, GetSemaphoreExportHandleTypes                         ); res += #10;
      res += 'ExternalMemoryImportHandleTypes                     = '; AddProp(res, GetExternalMemoryImportHandleTypes                    ); res += #10;
      res += 'ExternalMemoryImportAssumeLinearImagesHandleTypes   = '; AddProp(res, GetExternalMemoryImportAssumeLinearImagesHandleTypes  ); res += #10;
      res += 'ComputeCapabilityMajor                              = '; AddProp(res, GetComputeCapabilityMajor                             ); res += #10;
      res += 'ComputeCapabilityMinor                              = '; AddProp(res, GetComputeCapabilityMinor                             ); res += #10;
      res += 'RegistersPerBlock                                   = '; AddProp(res, GetRegistersPerBlock                                  ); res += #10;
      res += 'WarpSize                                            = '; AddProp(res, GetWarpSize                                           ); res += #10;
      res += 'GpuOverlap                                          = '; AddProp(res, GetGpuOverlap                                         ); res += #10;
      res += 'KernelExecTimeout                                   = '; AddProp(res, GetKernelExecTimeout                                  ); res += #10;
      res += 'IntegratedMemory                                    = '; AddProp(res, GetIntegratedMemory                                   ); res += #10;
      res += 'ParentDeviceExt                                     = '; AddProp(res, GetParentDeviceExt                                    ); res += #10;
      res += 'PartitionTypes                                      = '; AddProp(res, GetPartitionTypes                                     ); res += #10;
      res += 'AffinityDomains                                     = '; AddProp(res, GetAffinityDomains                                    ); res += #10;
      res += 'ReferenceCountExt                                   = '; AddProp(res, GetReferenceCountExt                                  ); res += #10;
      res += 'PartitionStyle                                      = '; AddProp(res, GetPartitionStyle                                     ); res += #10;
      res += 'MeVersion                                           = '; AddProp(res, GetMeVersion                                          ); res += #10;
      res += 'SvmCapabilitiesArm                                  = '; AddProp(res, GetSvmCapabilitiesArm                                 ); res += #10;
      res += 'ComputeUnitsBitfield                                = '; AddProp(res, GetComputeUnitsBitfield                               ); res += #10;
      res += 'SpirVersions                                        = '; AddProp(res, GetSpirVersions                                       ); res += #10;
      res += 'SimultaneousInterops                                = '; AddProp(res, GetSimultaneousInterops                               ); res += #10;
      res += 'NumSimultaneousInterops                             = '; AddProp(res, GetNumSimultaneousInterops                            ); res += #10;
      res += 'SubGroupSizes                                       = '; AddProp(res, GetSubGroupSizes                                      ); res += #10;
      res += 'AvcMeVersion                                        = '; AddProp(res, GetAvcMeVersion                                       ); res += #10;
      res += 'AvcMeSupportsTextureSamplerUse                      = '; AddProp(res, GetAvcMeSupportsTextureSamplerUse                     ); res += #10;
      res += 'AvcMeSupportsPreemption                             = '; AddProp(res, GetAvcMeSupportsPreemption                            ); res += #10;
      res += 'PciBusInfo                                          = '; AddProp(res, GetPciBusInfo                                         ); res += #10;
      res += 'PlanarYuvMaxWidth                                   = '; AddProp(res, GetPlanarYuvMaxWidth                                  ); res += #10;
      res += 'PlanarYuvMaxHeight                                  = '; AddProp(res, GetPlanarYuvMaxHeight                                 ); res += #10;
      res += 'QueueFamilyProperties                               = '; AddProp(res, GetQueueFamilyProperties                              ); res += #10;
      res += 'HostMemCapabilities                                 = '; AddProp(res, GetHostMemCapabilities                                ); res += #10;
      res += 'DeviceMemCapabilities                               = '; AddProp(res, GetDeviceMemCapabilities                              ); res += #10;
      res += 'SingleDeviceSharedMemCapabilities                   = '; AddProp(res, GetSingleDeviceSharedMemCapabilities                  ); res += #10;
      res += 'CrossDeviceSharedMemCapabilities                    = '; AddProp(res, GetCrossDeviceSharedMemCapabilities                   ); res += #10;
      res += 'SharedSystemMemCapabilities                         = '; AddProp(res, GetSharedSystemMemCapabilities                        ); res += #10;
      res += 'JobSlots                                            = '; AddProp(res, GetJobSlots                                           ); res += #10;
      res += 'SchedulingControlsCapabilities                      = '; AddProp(res, GetSchedulingControlsCapabilities                     ); res += #10;
      res += 'MaxWarpCount                                        = '; AddProp(res, GetMaxWarpCount                                       ); res += #10;
      res += 'SupportedRegisterAllocations                        = '; AddProp(res, GetSupportedRegisterAllocations                       ); res += #10;
      res += 'ControlledTerminationCapabilities                   = '; AddProp(res, GetControlledTerminationCapabilities                  ); res += #10;
      res += 'CxxForOpenclNumericVersion                          = '; AddProp(res, GetCxxForOpenclNumericVersion                         ); res += #10;
      res += 'SingleFpAtomicCapabilities                          = '; AddProp(res, GetSingleFpAtomicCapabilities                         ); res += #10;
      res += 'DoubleFpAtomicCapabilities                          = '; AddProp(res, GetDoubleFpAtomicCapabilities                         ); res += #10;
      res += 'HalfFpAtomicCapabilities                            = '; AddProp(res, GetHalfFpAtomicCapabilities                           ); res += #10;
      res += 'IpVersion                                           = '; AddProp(res, GetIpVersion                                          ); res += #10;
      res += 'Id                                                  = '; AddProp(res, GetId                                                 ); res += #10;
      res += 'NumSlices                                           = '; AddProp(res, GetNumSlices                                          ); res += #10;
      res += 'NumSubSlicesPerSlice                                = '; AddProp(res, GetNumSubSlicesPerSlice                               ); res += #10;
      res += 'NumEusPerSubSlice                                   = '; AddProp(res, GetNumEusPerSubSlice                                  ); res += #10;
      res += 'NumThreadsPerEu                                     = '; AddProp(res, GetNumThreadsPerEu                                    ); res += #10;
      res += 'FeatureCapabilities                                 = '; AddProp(res, GetFeatureCapabilities                                ); res += #10;
      res += 'MemoryCapabilities                                  = '; AddProp(res, GetMemoryCapabilities                                 );
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      ToString(res);
      Result := res.ToString;
    end;
    
  end;
  
  {$endregion CLDevice}
  
  {$region CLSubDevice}
  
  ///
  CLSubDeviceProperties = CLDeviceProperties;
  
  {$endregion CLSubDevice}
  
  {$region CLContext}
  
  ///
  CLContextProperties = class
    private ntv: cl_context;
    
    public constructor(ntv: cl_context) := self.ntv := ntv;
    private constructor := raise new OpenCLABCInternalException;
    
    private function GetProperties: OpenCL.clContextProperties;
    begin
      cl.GetContextInfo_CONTEXT_PROPERTIES(self.ntv, Result).RaiseIfError;
    end;
    private function GetD3d10PreferSharedResources: clBool;
    begin
      cl.GetContextInfo_CONTEXT_D3D10_PREFER_SHARED_RESOURCES(self.ntv, Result).RaiseIfError;
    end;
    private function GetD3d11PreferSharedResources: clBool;
    begin
      cl.GetContextInfo_CONTEXT_D3D11_PREFER_SHARED_RESOURCES(self.ntv, Result).RaiseIfError;
    end;
    private function GetVaApiDisplay: IntPtr;
    begin
      cl.GetContextInfo_CONTEXT_VA_API_DISPLAY(self.ntv, Result).RaiseIfError;
    end;
    
    public property Properties:                 OpenCL.clContextProperties read GetProperties;
    public property D3d10PreferSharedResources: clBool                     read GetD3d10PreferSharedResources;
    public property D3d11PreferSharedResources: clBool                     read GetD3d11PreferSharedResources;
    public property VaApiDisplay:               IntPtr                     read GetVaApiDisplay;
    
    private static procedure AddProp<T>(res: StringBuilder; get_prop: ()->T) :=
      try
        res += _ObjectToString(get_prop());
      except
        on e: OpenCLException do
          res += e.Code.ToString;
      end;
    public procedure ToString(res: StringBuilder); virtual;
    begin
      res += 'Properties                 = '; AddProp(res, GetProperties                ); res += #10;
      res += 'D3d10PreferSharedResources = '; AddProp(res, GetD3d10PreferSharedResources); res += #10;
      res += 'D3d11PreferSharedResources = '; AddProp(res, GetD3d11PreferSharedResources); res += #10;
      res += 'VaApiDisplay               = '; AddProp(res, GetVaApiDisplay              );
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      ToString(res);
      Result := res.ToString;
    end;
    
  end;
  
  {$endregion CLContext}
  
  {$region CLMemory}
  
  ///
  CLMemoryProperties = class
    private ntv: cl_mem;
    
    public constructor(ntv: cl_mem) := self.ntv := ntv;
    private constructor := raise new OpenCLABCInternalException;
    
    private function GetFlags: clMemFlags;
    begin
      cl.GetMemObjectInfo_MEM_FLAGS(self.ntv, Result).RaiseIfError;
    end;
    private function GetHostPtr: IntPtr;
    begin
      cl.GetMemObjectInfo_MEM_HOST_PTR(self.ntv, Result).RaiseIfError;
    end;
    private function GetUsesSvmPointer: clBool;
    begin
      cl.GetMemObjectInfo_MEM_USES_SVM_POINTER(self.ntv, Result).RaiseIfError;
    end;
    private function GetProperties: array of clMemProperties;
    begin
      cl.GetMemObjectInfo_MEM_PROPERTIES(self.ntv, Result).RaiseIfError;
    end;
    private function GetDx9MediaAdapterType: clDx9MediaAdapterType;
    begin
      cl.GetMemObjectInfo_MEM_DX9_MEDIA_ADAPTER_TYPE(self.ntv, Result).RaiseIfError;
    end;
    private function GetDx9MediaSurfaceInfo: cl_dx9_surface_info;
    begin
      cl.GetMemObjectInfo_MEM_DX9_MEDIA_SURFACE_INFO(self.ntv, Result).RaiseIfError;
    end;
    private function GetD3d10Resource: IntPtr;
    begin
      cl.GetMemObjectInfo_MEM_D3D10_RESOURCE(self.ntv, Result).RaiseIfError;
    end;
    private function GetD3d11Resource: IntPtr;
    begin
      cl.GetMemObjectInfo_MEM_D3D11_RESOURCE(self.ntv, Result).RaiseIfError;
    end;
    private function GetDx9Resource: IntPtr;
    begin
      cl.GetMemObjectInfo_MEM_DX9_RESOURCE(self.ntv, Result).RaiseIfError;
    end;
    private function GetDx9SharedHandle: IntPtr;
    begin
      cl.GetMemObjectInfo_MEM_DX9_SHARED_HANDLE(self.ntv, Result).RaiseIfError;
    end;
    private function GetVaApiMediaSurface: IntPtr;
    begin
      cl.GetMemObjectInfo_MEM_VA_API_MEDIA_SURFACE(self.ntv, Result).RaiseIfError;
    end;
    private function GetUsesSvmPointerArm: clBool;
    begin
      cl.GetMemObjectInfo_MEM_USES_SVM_POINTER_ARM(self.ntv, Result).RaiseIfError;
    end;
    private function GetAllocFlagsIntel: clMemAllocFlagsINTEL;
    begin
      cl.GetMemObjectInfo_MEM_ALLOC_FLAGS_INTEL(self.ntv, Result).RaiseIfError;
    end;
    private function GetAllocType: clUnifiedSharedMemoryType;
    begin
      cl.GetMemObjectInfo_MEM_ALLOC_TYPE(self.ntv, Result).RaiseIfError;
    end;
    private function GetAllocBasePtr: IntPtr;
    begin
      cl.GetMemObjectInfo_MEM_ALLOC_BASE_PTR(self.ntv, Result).RaiseIfError;
    end;
    private function GetAllocSize: UIntPtr;
    begin
      cl.GetMemObjectInfo_MEM_ALLOC_SIZE(self.ntv, Result).RaiseIfError;
    end;
    private function GetAllocDevice: cl_device_id;
    begin
      cl.GetMemObjectInfo_MEM_ALLOC_DEVICE(self.ntv, Result).RaiseIfError;
    end;
    
    public property Flags:               clMemFlags                read GetFlags;
    public property HostPtr:             IntPtr                    read GetHostPtr;
    public property UsesSvmPointer:      clBool                    read GetUsesSvmPointer;
    public property Properties:          array of clMemProperties  read GetProperties;
    public property Dx9MediaAdapterType: clDx9MediaAdapterType     read GetDx9MediaAdapterType;
    public property Dx9MediaSurfaceInfo: cl_dx9_surface_info       read GetDx9MediaSurfaceInfo;
    public property D3d10Resource:       IntPtr                    read GetD3d10Resource;
    public property D3d11Resource:       IntPtr                    read GetD3d11Resource;
    public property Dx9Resource:         IntPtr                    read GetDx9Resource;
    public property Dx9SharedHandle:     IntPtr                    read GetDx9SharedHandle;
    public property VaApiMediaSurface:   IntPtr                    read GetVaApiMediaSurface;
    public property UsesSvmPointerArm:   clBool                    read GetUsesSvmPointerArm;
    public property AllocFlagsIntel:     clMemAllocFlagsINTEL      read GetAllocFlagsIntel;
    public property AllocType:           clUnifiedSharedMemoryType read GetAllocType;
    public property AllocBasePtr:        IntPtr                    read GetAllocBasePtr;
    public property AllocSize:           UIntPtr                   read GetAllocSize;
    public property AllocDevice:         cl_device_id              read GetAllocDevice;
    
    private static procedure AddProp<T>(res: StringBuilder; get_prop: ()->T) :=
      try
        res += _ObjectToString(get_prop());
      except
        on e: OpenCLException do
          res += e.Code.ToString;
      end;
    public procedure ToString(res: StringBuilder); virtual;
    begin
      res += 'Flags               = '; AddProp(res, GetFlags              ); res += #10;
      res += 'HostPtr             = '; AddProp(res, GetHostPtr            ); res += #10;
      res += 'UsesSvmPointer      = '; AddProp(res, GetUsesSvmPointer     ); res += #10;
      res += 'Properties          = '; AddProp(res, GetProperties         ); res += #10;
      res += 'Dx9MediaAdapterType = '; AddProp(res, GetDx9MediaAdapterType); res += #10;
      res += 'Dx9MediaSurfaceInfo = '; AddProp(res, GetDx9MediaSurfaceInfo); res += #10;
      res += 'D3d10Resource       = '; AddProp(res, GetD3d10Resource      ); res += #10;
      res += 'D3d11Resource       = '; AddProp(res, GetD3d11Resource      ); res += #10;
      res += 'Dx9Resource         = '; AddProp(res, GetDx9Resource        ); res += #10;
      res += 'Dx9SharedHandle     = '; AddProp(res, GetDx9SharedHandle    ); res += #10;
      res += 'VaApiMediaSurface   = '; AddProp(res, GetVaApiMediaSurface  ); res += #10;
      res += 'UsesSvmPointerArm   = '; AddProp(res, GetUsesSvmPointerArm  ); res += #10;
      res += 'AllocFlagsIntel     = '; AddProp(res, GetAllocFlagsIntel    ); res += #10;
      res += 'AllocType           = '; AddProp(res, GetAllocType          ); res += #10;
      res += 'AllocBasePtr        = '; AddProp(res, GetAllocBasePtr       ); res += #10;
      res += 'AllocSize           = '; AddProp(res, GetAllocSize          ); res += #10;
      res += 'AllocDevice         = '; AddProp(res, GetAllocDevice        );
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      ToString(res);
      Result := res.ToString;
    end;
    
  end;
  
  {$endregion CLMemory}
  
  {$region CLMemorySubSegment}
  
  ///
  CLMemorySubSegmentProperties = class(CLMemoryProperties)
    
    private function GetOffset: UIntPtr;
    begin
      cl.GetMemObjectInfo_MEM_OFFSET(self.ntv, Result).RaiseIfError;
    end;
    
    public property Offset: UIntPtr read GetOffset;
    
    public procedure ToString(res: StringBuilder); override;
    begin
      inherited; res += #10;
      res += 'Offset = '; AddProp(res, GetOffset);
    end;
    
  end;
  
  {$endregion CLMemorySubSegment}
  
  {$region CLValue}
  
  ///
  CLValueProperties = class
    private ntv: cl_mem;
    
    public constructor(ntv: cl_mem) := self.ntv := ntv;
    private constructor := raise new OpenCLABCInternalException;
    
    private function GetFlags: clMemFlags;
    begin
      cl.GetMemObjectInfo_MEM_FLAGS(self.ntv, Result).RaiseIfError;
    end;
    private function GetHostPtr: IntPtr;
    begin
      cl.GetMemObjectInfo_MEM_HOST_PTR(self.ntv, Result).RaiseIfError;
    end;
    private function GetUsesSvmPointer: clBool;
    begin
      cl.GetMemObjectInfo_MEM_USES_SVM_POINTER(self.ntv, Result).RaiseIfError;
    end;
    private function GetProperties: array of clMemProperties;
    begin
      cl.GetMemObjectInfo_MEM_PROPERTIES(self.ntv, Result).RaiseIfError;
    end;
    private function GetDx9MediaAdapterType: clDx9MediaAdapterType;
    begin
      cl.GetMemObjectInfo_MEM_DX9_MEDIA_ADAPTER_TYPE(self.ntv, Result).RaiseIfError;
    end;
    private function GetDx9MediaSurfaceInfo: cl_dx9_surface_info;
    begin
      cl.GetMemObjectInfo_MEM_DX9_MEDIA_SURFACE_INFO(self.ntv, Result).RaiseIfError;
    end;
    private function GetD3d10Resource: IntPtr;
    begin
      cl.GetMemObjectInfo_MEM_D3D10_RESOURCE(self.ntv, Result).RaiseIfError;
    end;
    private function GetD3d11Resource: IntPtr;
    begin
      cl.GetMemObjectInfo_MEM_D3D11_RESOURCE(self.ntv, Result).RaiseIfError;
    end;
    private function GetDx9Resource: IntPtr;
    begin
      cl.GetMemObjectInfo_MEM_DX9_RESOURCE(self.ntv, Result).RaiseIfError;
    end;
    private function GetDx9SharedHandle: IntPtr;
    begin
      cl.GetMemObjectInfo_MEM_DX9_SHARED_HANDLE(self.ntv, Result).RaiseIfError;
    end;
    private function GetVaApiMediaSurface: IntPtr;
    begin
      cl.GetMemObjectInfo_MEM_VA_API_MEDIA_SURFACE(self.ntv, Result).RaiseIfError;
    end;
    private function GetUsesSvmPointerArm: clBool;
    begin
      cl.GetMemObjectInfo_MEM_USES_SVM_POINTER_ARM(self.ntv, Result).RaiseIfError;
    end;
    private function GetAllocFlagsIntel: clMemAllocFlagsINTEL;
    begin
      cl.GetMemObjectInfo_MEM_ALLOC_FLAGS_INTEL(self.ntv, Result).RaiseIfError;
    end;
    private function GetAllocType: clUnifiedSharedMemoryType;
    begin
      cl.GetMemObjectInfo_MEM_ALLOC_TYPE(self.ntv, Result).RaiseIfError;
    end;
    private function GetAllocBasePtr: IntPtr;
    begin
      cl.GetMemObjectInfo_MEM_ALLOC_BASE_PTR(self.ntv, Result).RaiseIfError;
    end;
    private function GetAllocSize: UIntPtr;
    begin
      cl.GetMemObjectInfo_MEM_ALLOC_SIZE(self.ntv, Result).RaiseIfError;
    end;
    private function GetAllocDevice: cl_device_id;
    begin
      cl.GetMemObjectInfo_MEM_ALLOC_DEVICE(self.ntv, Result).RaiseIfError;
    end;
    private function GetAssociatedMemobject: cl_mem;
    begin
      cl.GetMemObjectInfo_MEM_ASSOCIATED_MEMOBJECT(self.ntv, Result).RaiseIfError;
    end;
    private function GetOffset: UIntPtr;
    begin
      cl.GetMemObjectInfo_MEM_OFFSET(self.ntv, Result).RaiseIfError;
    end;
    
    public property Flags:               clMemFlags                read GetFlags;
    public property HostPtr:             IntPtr                    read GetHostPtr;
    public property UsesSvmPointer:      clBool                    read GetUsesSvmPointer;
    public property Properties:          array of clMemProperties  read GetProperties;
    public property Dx9MediaAdapterType: clDx9MediaAdapterType     read GetDx9MediaAdapterType;
    public property Dx9MediaSurfaceInfo: cl_dx9_surface_info       read GetDx9MediaSurfaceInfo;
    public property D3d10Resource:       IntPtr                    read GetD3d10Resource;
    public property D3d11Resource:       IntPtr                    read GetD3d11Resource;
    public property Dx9Resource:         IntPtr                    read GetDx9Resource;
    public property Dx9SharedHandle:     IntPtr                    read GetDx9SharedHandle;
    public property VaApiMediaSurface:   IntPtr                    read GetVaApiMediaSurface;
    public property UsesSvmPointerArm:   clBool                    read GetUsesSvmPointerArm;
    public property AllocFlagsIntel:     clMemAllocFlagsINTEL      read GetAllocFlagsIntel;
    public property AllocType:           clUnifiedSharedMemoryType read GetAllocType;
    public property AllocBasePtr:        IntPtr                    read GetAllocBasePtr;
    public property AllocSize:           UIntPtr                   read GetAllocSize;
    public property AllocDevice:         cl_device_id              read GetAllocDevice;
    public property AssociatedMemobject: cl_mem                    read GetAssociatedMemobject;
    public property Offset:              UIntPtr                   read GetOffset;
    
    private static procedure AddProp<T>(res: StringBuilder; get_prop: ()->T) :=
      try
        res += _ObjectToString(get_prop());
      except
        on e: OpenCLException do
          res += e.Code.ToString;
      end;
    public procedure ToString(res: StringBuilder); virtual;
    begin
      res += 'Flags               = '; AddProp(res, GetFlags              ); res += #10;
      res += 'HostPtr             = '; AddProp(res, GetHostPtr            ); res += #10;
      res += 'UsesSvmPointer      = '; AddProp(res, GetUsesSvmPointer     ); res += #10;
      res += 'Properties          = '; AddProp(res, GetProperties         ); res += #10;
      res += 'Dx9MediaAdapterType = '; AddProp(res, GetDx9MediaAdapterType); res += #10;
      res += 'Dx9MediaSurfaceInfo = '; AddProp(res, GetDx9MediaSurfaceInfo); res += #10;
      res += 'D3d10Resource       = '; AddProp(res, GetD3d10Resource      ); res += #10;
      res += 'D3d11Resource       = '; AddProp(res, GetD3d11Resource      ); res += #10;
      res += 'Dx9Resource         = '; AddProp(res, GetDx9Resource        ); res += #10;
      res += 'Dx9SharedHandle     = '; AddProp(res, GetDx9SharedHandle    ); res += #10;
      res += 'VaApiMediaSurface   = '; AddProp(res, GetVaApiMediaSurface  ); res += #10;
      res += 'UsesSvmPointerArm   = '; AddProp(res, GetUsesSvmPointerArm  ); res += #10;
      res += 'AllocFlagsIntel     = '; AddProp(res, GetAllocFlagsIntel    ); res += #10;
      res += 'AllocType           = '; AddProp(res, GetAllocType          ); res += #10;
      res += 'AllocBasePtr        = '; AddProp(res, GetAllocBasePtr       ); res += #10;
      res += 'AllocSize           = '; AddProp(res, GetAllocSize          ); res += #10;
      res += 'AllocDevice         = '; AddProp(res, GetAllocDevice        ); res += #10;
      res += 'AssociatedMemobject = '; AddProp(res, GetAssociatedMemobject); res += #10;
      res += 'Offset              = '; AddProp(res, GetOffset             );
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      ToString(res);
      Result := res.ToString;
    end;
    
  end;
  
  {$endregion CLValue}
  
  {$region CLArray}
  
  ///
  CLArrayProperties = class
    private ntv: cl_mem;
    
    public constructor(ntv: cl_mem) := self.ntv := ntv;
    private constructor := raise new OpenCLABCInternalException;
    
    private function GetFlags: clMemFlags;
    begin
      cl.GetMemObjectInfo_MEM_FLAGS(self.ntv, Result).RaiseIfError;
    end;
    private function GetHostPtr: IntPtr;
    begin
      cl.GetMemObjectInfo_MEM_HOST_PTR(self.ntv, Result).RaiseIfError;
    end;
    private function GetUsesSvmPointer: clBool;
    begin
      cl.GetMemObjectInfo_MEM_USES_SVM_POINTER(self.ntv, Result).RaiseIfError;
    end;
    private function GetProperties: array of clMemProperties;
    begin
      cl.GetMemObjectInfo_MEM_PROPERTIES(self.ntv, Result).RaiseIfError;
    end;
    private function GetDx9MediaAdapterType: clDx9MediaAdapterType;
    begin
      cl.GetMemObjectInfo_MEM_DX9_MEDIA_ADAPTER_TYPE(self.ntv, Result).RaiseIfError;
    end;
    private function GetDx9MediaSurfaceInfo: cl_dx9_surface_info;
    begin
      cl.GetMemObjectInfo_MEM_DX9_MEDIA_SURFACE_INFO(self.ntv, Result).RaiseIfError;
    end;
    private function GetD3d10Resource: IntPtr;
    begin
      cl.GetMemObjectInfo_MEM_D3D10_RESOURCE(self.ntv, Result).RaiseIfError;
    end;
    private function GetD3d11Resource: IntPtr;
    begin
      cl.GetMemObjectInfo_MEM_D3D11_RESOURCE(self.ntv, Result).RaiseIfError;
    end;
    private function GetDx9Resource: IntPtr;
    begin
      cl.GetMemObjectInfo_MEM_DX9_RESOURCE(self.ntv, Result).RaiseIfError;
    end;
    private function GetDx9SharedHandle: IntPtr;
    begin
      cl.GetMemObjectInfo_MEM_DX9_SHARED_HANDLE(self.ntv, Result).RaiseIfError;
    end;
    private function GetVaApiMediaSurface: IntPtr;
    begin
      cl.GetMemObjectInfo_MEM_VA_API_MEDIA_SURFACE(self.ntv, Result).RaiseIfError;
    end;
    private function GetUsesSvmPointerArm: clBool;
    begin
      cl.GetMemObjectInfo_MEM_USES_SVM_POINTER_ARM(self.ntv, Result).RaiseIfError;
    end;
    private function GetAllocFlagsIntel: clMemAllocFlagsINTEL;
    begin
      cl.GetMemObjectInfo_MEM_ALLOC_FLAGS_INTEL(self.ntv, Result).RaiseIfError;
    end;
    private function GetAllocType: clUnifiedSharedMemoryType;
    begin
      cl.GetMemObjectInfo_MEM_ALLOC_TYPE(self.ntv, Result).RaiseIfError;
    end;
    private function GetAllocBasePtr: IntPtr;
    begin
      cl.GetMemObjectInfo_MEM_ALLOC_BASE_PTR(self.ntv, Result).RaiseIfError;
    end;
    private function GetAllocSize: UIntPtr;
    begin
      cl.GetMemObjectInfo_MEM_ALLOC_SIZE(self.ntv, Result).RaiseIfError;
    end;
    private function GetAllocDevice: cl_device_id;
    begin
      cl.GetMemObjectInfo_MEM_ALLOC_DEVICE(self.ntv, Result).RaiseIfError;
    end;
    private function GetAssociatedMemobject: cl_mem;
    begin
      cl.GetMemObjectInfo_MEM_ASSOCIATED_MEMOBJECT(self.ntv, Result).RaiseIfError;
    end;
    private function GetOffset: UIntPtr;
    begin
      cl.GetMemObjectInfo_MEM_OFFSET(self.ntv, Result).RaiseIfError;
    end;
    
    public property Flags:               clMemFlags                read GetFlags;
    public property HostPtr:             IntPtr                    read GetHostPtr;
    public property UsesSvmPointer:      clBool                    read GetUsesSvmPointer;
    public property Properties:          array of clMemProperties  read GetProperties;
    public property Dx9MediaAdapterType: clDx9MediaAdapterType     read GetDx9MediaAdapterType;
    public property Dx9MediaSurfaceInfo: cl_dx9_surface_info       read GetDx9MediaSurfaceInfo;
    public property D3d10Resource:       IntPtr                    read GetD3d10Resource;
    public property D3d11Resource:       IntPtr                    read GetD3d11Resource;
    public property Dx9Resource:         IntPtr                    read GetDx9Resource;
    public property Dx9SharedHandle:     IntPtr                    read GetDx9SharedHandle;
    public property VaApiMediaSurface:   IntPtr                    read GetVaApiMediaSurface;
    public property UsesSvmPointerArm:   clBool                    read GetUsesSvmPointerArm;
    public property AllocFlagsIntel:     clMemAllocFlagsINTEL      read GetAllocFlagsIntel;
    public property AllocType:           clUnifiedSharedMemoryType read GetAllocType;
    public property AllocBasePtr:        IntPtr                    read GetAllocBasePtr;
    public property AllocSize:           UIntPtr                   read GetAllocSize;
    public property AllocDevice:         cl_device_id              read GetAllocDevice;
    public property AssociatedMemobject: cl_mem                    read GetAssociatedMemobject;
    public property Offset:              UIntPtr                   read GetOffset;
    
    private static procedure AddProp<T>(res: StringBuilder; get_prop: ()->T) :=
      try
        res += _ObjectToString(get_prop());
      except
        on e: OpenCLException do
          res += e.Code.ToString;
      end;
    public procedure ToString(res: StringBuilder); virtual;
    begin
      res += 'Flags               = '; AddProp(res, GetFlags              ); res += #10;
      res += 'HostPtr             = '; AddProp(res, GetHostPtr            ); res += #10;
      res += 'UsesSvmPointer      = '; AddProp(res, GetUsesSvmPointer     ); res += #10;
      res += 'Properties          = '; AddProp(res, GetProperties         ); res += #10;
      res += 'Dx9MediaAdapterType = '; AddProp(res, GetDx9MediaAdapterType); res += #10;
      res += 'Dx9MediaSurfaceInfo = '; AddProp(res, GetDx9MediaSurfaceInfo); res += #10;
      res += 'D3d10Resource       = '; AddProp(res, GetD3d10Resource      ); res += #10;
      res += 'D3d11Resource       = '; AddProp(res, GetD3d11Resource      ); res += #10;
      res += 'Dx9Resource         = '; AddProp(res, GetDx9Resource        ); res += #10;
      res += 'Dx9SharedHandle     = '; AddProp(res, GetDx9SharedHandle    ); res += #10;
      res += 'VaApiMediaSurface   = '; AddProp(res, GetVaApiMediaSurface  ); res += #10;
      res += 'UsesSvmPointerArm   = '; AddProp(res, GetUsesSvmPointerArm  ); res += #10;
      res += 'AllocFlagsIntel     = '; AddProp(res, GetAllocFlagsIntel    ); res += #10;
      res += 'AllocType           = '; AddProp(res, GetAllocType          ); res += #10;
      res += 'AllocBasePtr        = '; AddProp(res, GetAllocBasePtr       ); res += #10;
      res += 'AllocSize           = '; AddProp(res, GetAllocSize          ); res += #10;
      res += 'AllocDevice         = '; AddProp(res, GetAllocDevice        ); res += #10;
      res += 'AssociatedMemobject = '; AddProp(res, GetAssociatedMemobject); res += #10;
      res += 'Offset              = '; AddProp(res, GetOffset             );
    end;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      ToString(res);
      Result := res.ToString;
    end;
    
  end;
  
  {$endregion CLArray}
  
  {$endregion WrapperProperties}
  
  {$region Wrappers}
  // For parameters of CCQ-involved methods
  ///Представляет очередь команд, в основном выполняемых на GPU
  ///Такая очередь всегда возвращает значение типа T
  CommandQueue<T> = abstract partial class end;
  CLKernelArg = abstract partial class end;
  
  {$region CLContext data}
  
  {$region CLPlatform}
  
  CLPlatform = partial class
    private ntv: cl_platform_id;
    
    public constructor(ntv: cl_platform_id) := self.ntv := ntv;
    private constructor := raise new OpenCLABCInternalException;
    
    private static all_need_init := true;
    private static _all: IList<CLPlatform>;
    private static function MakeAll: IList<CLPlatform>;
    begin
      Result := nil;
      
      var c: UInt32;
      begin
        var ec := cl.GetPlatformIDs(0, IntPtr.Zero, c);
        if ec=clErrorCode.PLATFORM_NOT_FOUND then exit;
        OpenCLABCInternalException.RaiseIfError(ec);
      end;
      if c=0 then exit;
      
      var all_arr := new cl_platform_id[c];
      OpenCLABCInternalException.RaiseIfError(
        cl.GetPlatformIDs(c, all_arr[0], IntPtr.Zero)
      );
      
      Result := new ReadOnlyCollection<CLPlatform>(all_arr.ConvertAll(pl->new CLPlatform(pl)));
    end;
    private static function GetAll: IList<CLPlatform>;
    begin
      if all_need_init then
      begin
        _all := MakeAll;
        all_need_init := false;
      end;
      Result := _all;
    end;
    public static property All: IList<CLPlatform> read GetAll;
    
  end;
  
  {$endregion CLPlatform}
  
  {$region CLDevice}
  
  CLDevice = partial class
    private ntv: cl_device_id;
    
    private constructor(ntv: cl_device_id) := self.ntv := ntv;
    public static function FromNative(ntv: cl_device_id): CLDevice;
    
    private constructor := raise new OpenCLABCInternalException;
    
    private function GetBaseCLPlatform: CLPlatform;
    begin
      var pl: cl_platform_id;
      OpenCLABCInternalException.RaiseIfError(
        cl.GetDeviceInfo_DEVICE_PLATFORM(self.ntv, pl, false)
      );
      Result := new CLPlatform(pl);
    end;
    public property BaseCLPlatform: CLPlatform read GetBaseCLPlatform;
    
    public static function GetAllFor(pl: CLPlatform; t: clDeviceType): array of CLDevice;
    begin
      
      var c: UInt32;
      var ec := cl.GetDeviceIDs(pl.ntv, t, 0, IntPtr.Zero, c);
      if ec=clErrorCode.DEVICE_NOT_FOUND then exit;
      OpenCLABCInternalException.RaiseIfError(ec);
      
      var all := new cl_device_id[c];
      OpenCLABCInternalException.RaiseIfError(
        cl.GetDeviceIDs(pl.ntv, t, c, all[0], IntPtr.Zero)
      );
      
      Result := all.ConvertAll(dvc->new CLDevice(dvc));
    end;
    public static function GetAllFor(pl: CLPlatform) := GetAllFor(pl, clDeviceType.DEVICE_TYPE_GPU);
    
  end;
  
  {$endregion CLDevice}
  
  {$region CLSubDevice}
  
  CLSubDevice = partial class(CLDevice)
    private _parent: cl_device_id;
    public property Parent: CLDevice read CLDevice.FromNative(_parent);
    
    private constructor(parent, ntv: cl_device_id);
    begin
      inherited Create(ntv);
      self._parent := parent;
    end;
    private constructor := inherited;
    
    protected procedure Finalize; override :=
    OpenCLABCInternalException.RaiseIfError(cl.ReleaseDevice(ntv));
    
  end;
  
  {$endregion CLSubDevice}
  
  {$region CLContext}
  
  CLContext = partial class
    private ntv: cl_context;
    
    private dvcs: IList<CLDevice>;
    public property AllDevices: IList<CLDevice> read dvcs;
    
    private main_dvc: CLDevice;
    public property MainDevice: CLDevice read main_dvc;
    
    private function GetAllNtvDevices: array of cl_device_id;
    begin
      Result := new cl_device_id[dvcs.Count];
      for var i := 0 to Result.Length-1 do
        Result[i] := dvcs[i].ntv;
    end;
    
    {$region Default}
    
    private static default_was_inited := 0;
    private static _default: CLContext;
    
    private static function GetDefault: CLContext;
    begin
      if default_was_inited=0 then
      begin
        var c :=
          {$ifdef ForceMaxDebug}
          //TODO #????: Лишние ()
          LoadTestContext() ??
          {$endif ForceMaxDebug}
          MakeNewDefaultContext;
        // Extra checks, in case .Default was explicitly set while generating new context
        if Interlocked.CompareExchange(default_was_inited, 1, 0)=0 then
          Interlocked.CompareExchange(_default, c, nil);
      end;
      Result := _default;
    end;
    private static procedure SetDefault(new_default: CLContext);
    begin
      default_was_inited := 1;
      _default := new_default;
    end;
    public static property &Default: CLContext read GetDefault write SetDefault;
    
    protected static function MakeNewDefaultContext: CLContext;
    begin
      Result := nil;
      
      var pls := CLPlatform.All;
      if pls=nil then exit;
      
      foreach var pl in pls do
      begin
        var dvcs := CLDevice.GetAllFor(pl);
        if dvcs=nil then continue;
        Result := new CLContext(dvcs);
        exit;
      end;
      
      foreach var pl in pls do
      begin
        var dvcs := CLDevice.GetAllFor(pl, clDeviceType.DEVICE_TYPE_ALL);
        if dvcs=nil then continue;
        Result := new CLContext(dvcs);
        exit;
      end;
      
    end;
    
    public function TestSanity(test_size: integer := 1024*24): TimeSpan?;
    
    public static function GenerateAndCheckAllPossible(test_size: integer := 1024*24; test_max_seconds: real := 5): List<ValueTuple<CLContext,TimeSpan>>;
    
    private static function LoadTestContext: CLContext;
    
    {$endregion Default}
    
    {$region constructor's}
    
    private static procedure CheckMainDevice(main_dvc: CLDevice; dvc_lst: IList<CLDevice>) :=
      if main_dvc not in dvc_lst then raise new ArgumentException($'%Err:CLContext:WrongMainDvc%');
    
    public constructor(dvcs: IList<CLDevice>; main_dvc: CLDevice);
    begin
      CheckMainDevice(main_dvc, dvcs);
      
      self.dvcs := if dvcs.IsReadOnly then dvcs else new ReadOnlyCollection<CLDevice>(dvcs.ToArray);
      var ntv_dvcs := GetAllNtvDevices;
      
      var ec: clErrorCode;
      self.ntv := cl.CreateContext(nil, ntv_dvcs.Count, ntv_dvcs, nil, IntPtr.Zero, ec);
      OpenCLABCInternalException.RaiseIfError(ec);
      
      self.main_dvc := main_dvc;
    end;
    public constructor(params dvcs: array of CLDevice) := Create(dvcs, dvcs[0]);
    
    protected static function GetContextDevices(ntv: cl_context): array of CLDevice;
    begin
      var res: array of cl_device_id;
      OpenCLABCInternalException.RaiseIfError(
        cl.GetContextInfo_CONTEXT_DEVICES(ntv, res)
      );
      Result := res.ConvertAll(dvc->new CLDevice(dvc));
    end;
    private procedure InitFromNtv(ntv: cl_context; dvcs: IList<CLDevice>; main_dvc: CLDevice; need_retain: boolean);
    begin
      CheckMainDevice(main_dvc, dvcs);
      if need_retain then OpenCLABCInternalException.RaiseIfError( cl.RetainContext(ntv) );
      self.ntv := ntv;
      // Копирование должно происходить в вызывающих методах
      self.dvcs := if dvcs.IsReadOnly then dvcs else new ReadOnlyCollection<CLDevice>(dvcs);
      self.main_dvc := main_dvc;
    end;
    public constructor(ntv: cl_context; main_dvc: CLDevice; need_retain: boolean) :=
      InitFromNtv(ntv, GetContextDevices(ntv), main_dvc, need_retain);
    
    public constructor(ntv: cl_context; need_retain: boolean);
    begin
      var dvcs := GetContextDevices(ntv);
      InitFromNtv(ntv, dvcs, dvcs[0], need_retain);
    end;
    
    private constructor(c: CLContext; main_dvc: CLDevice) :=
      InitFromNtv(c.ntv, c.dvcs, main_dvc, true);
    public function MakeSibling(new_main_dvc: CLDevice) := new CLContext(self, new_main_dvc);
    
    private constructor := raise new OpenCLABCInternalException;
    
    public procedure Dispose;
    begin
      var prev_ntv := new cl_context(Interlocked.Exchange(self.ntv.val, IntPtr.Zero));
      if prev_ntv=cl_context.Zero then exit;
      OpenCLABCInternalException.RaiseIfError(
        cl.ReleaseContext(prev_ntv)
      );
    end;
    protected procedure Finalize; override := Dispose;
    
    {$endregion constructor's}
    
  end;
  
  {$endregion CLContext}
  
  {$endregion CLContext data}
  
  {$region CLKernel data}
  
  {$region CLCodeOptions}
  
  CLCodeOptions = abstract class
    
    public constructor(c: CLContext) := self.BuildContext := c;
    public constructor := Create(CLContext.Default);
    
    public auto property BuildContext: CLContext;
    
    public auto property KeepLog: boolean := true;
    
    protected procedure ToString(res: StringBuilder); abstract;
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      ToString(res);
      Result := res.ToString;
    end;
    
  end;
  
  CLCodeLibOptions = class(CLCodeOptions)
    
    public static function operator implicit(c: CLContext): CLCodeLibOptions := new CLCodeLibOptions(c);
    
    public auto property ForceAcceptProgramLinkOptions: boolean := false;
    
    protected procedure ToString(res: StringBuilder); override;
    begin
//      inherited; // abstract
      
      res += '-create-library ';
      
      if ForceAcceptProgramLinkOptions then
        res += '-enable-link-options ';
      
    end;
    
  end;
  
  CLProgramOptions = abstract class(CLCodeOptions)
    
    public auto property MathDenormsAreZero: boolean := false;
    
    public auto property OptSignedZero: boolean := false;
    
    public property OptUnsafeMath: boolean
    read MathDenormsAreZero and not OptSignedZero
    write
    begin
      MathDenormsAreZero  := value;
      OptSignedZero       := not value;
    end; virtual;
    
    public auto property OptNoDenorms: boolean := false;
    
    public property OptFastMath: boolean
    read OptUnsafeMath and OptNoDenorms
    write
    begin
      OptUnsafeMath := value;
      OptNoDenorms  := value;
    end;
    
    public auto property OptRequireIFP: boolean := true;
    
    protected procedure ToString(res: StringBuilder); override;
    begin
//      inherited; // abstract
      
      if OptFastMath then
        res += '-cl-fast-relaxed-math ' else
      begin
        
        if OptUnsafeMath then
          res += '-cl-unsafe-math-optimizations ' else
        begin
          
          if MathDenormsAreZero then
            res += '-cl-denorms-are-zero ';
          
          // Only for ProgramComp
//          if OptCanUseMAD then
//            res += '-cl-mad-enable ';
          
          if not OptSignedZero then
            res += '-cl-no-signed-zeros ';
          
        end;
        
        if OptNoDenorms then
          res += '-cl-finite-math-only ';
        
      end;
      
      if not OptRequireIFP then
        res += '-cl-no-subgroup-ifp ';
      
    end;
    
  end;
  
  CLCodeDefines = Dictionary<string, string>;
  CLProgramCompOptions = class(CLProgramOptions)
    
    public static function operator implicit(c: CLContext): CLProgramCompOptions := new CLProgramCompOptions(c);
    
    public auto property Defines: CLCodeDefines := new CLCodeDefines;
    
    public auto property MathSinglePrecisionConstant: boolean := false;
    
    public auto property MathFP32CorrectlyRoundedDivideSqrt: boolean := false;
    
    public auto property Optimize: boolean := true;
    
    public auto property OptOnlyUniformWorkGroups: boolean := false;
    
    public auto property OptCanUseMAD: boolean := false;
    
    public property OptUnsafeMath: boolean
    read MathDenormsAreZero and OptCanUseMAD and not OptSignedZero
    write
    begin
      MathDenormsAreZero  := value;
      OptCanUseMAD        := value;
      OptSignedZero       := not value;
    end; override;
    
    public auto property WarningLevel: (
      WL_Ignore,
      WL_Warn,
      WL_Error
    ) := WL_Warn;
    
    public auto property Version: (integer, integer) := nil;
    public procedure LowerVersionToSupported;
    
    public auto property CLKernelArgInfo: boolean := true;
    
    public auto property LiveEnqueueDebug: boolean := false;
    
    protected procedure ToString(res: StringBuilder); override;
    begin
      inherited;
      
      foreach var kvp in Defines do
      begin
        res += '-D ';
        res += kvp.Key;
        if kvp.Value<>nil then
        begin
          res += '=';
          res += kvp.Value;
        end;
        res += ' ';
      end;
      
      if MathSinglePrecisionConstant then
        res += '-cl-single-precision-constant ';
      
      if MathFP32CorrectlyRoundedDivideSqrt then
        res += '-cl-fp32-correctly-rounded-divide-sqrt ';
      
      if not Optimize then
        res += '-cl-opt-disable ';
      
      if OptOnlyUniformWorkGroups then
        res += '-cl-uniform-work-group-size ';
      
      if not OptUnsafeMath and OptCanUseMAD then
        res += '-cl-mad-enable ';
      
      case WarningLevel of
        WL_Ignore:  res += '-w ';
        WL_Warn:    ;
        WL_Error:   res += '-Werror ';
        else raise new System.ArgumentException($'%Err:ProgramOptions:WarningLevel:Invalid%');
      end;
      
      if Version<>nil then
      begin
        res += '-cl-std=CL';
        res.Append(Version[0]);
        res += '.';
        res.Append(Version[1]);
        res += ' ';
      end;
      
      if CLKernelArgInfo then
        res += '-cl-kernel-arg-info ';
      
      if LiveEnqueueDebug then
        res += '-g ';
      
    end;
    
  end;
  
  CLProgramLinkOptions = class(CLProgramOptions)
    
    public static function operator implicit(c: CLContext): CLProgramLinkOptions := new CLProgramLinkOptions(c);
    
//    protected procedure ToString(res: StringBuilder); override;
//    begin
//      inherited;
//      
//    end;
    
  end;
  
  {$endregion CLCodeOptions}
  
  {$region CLCode}
  
  {$region CLCode}
  
  //TODO Компилятор сейчас не даёт сделать этот делегат анонимным
  _GetPropValueFunc<T> = function(ntv: cl_program; var data: T): clErrorCode;
  CLCode = abstract partial class
    private ntv: cl_program;
    
    protected constructor(code_text: string; c: CLContext);
    begin
      
      var ec: clErrorCode;
      self.ntv := cl.CreateProgramWithSource(c.ntv, 1,|code_text|,nil, ec);
      OpenCLABCInternalException.RaiseIfError(ec);
      
    end;
    
    protected constructor(ntv: cl_program; need_retain: boolean);
    begin
      if need_retain then
        OpenCLABCInternalException.RaiseIfError(
          cl.RetainProgram(ntv)
        );
      self.ntv := ntv;
    end;
    
    private constructor := raise new OpenCLABCInternalException;
    
    private function GetPropValue<T>(prop_f: _GetPropValueFunc<T>): T;
    begin
      OpenCLABCInternalException.RaiseIfError(
        prop_f(self.ntv, Result)
      );
    end;
    
    //TODO #2899
    private function GetPropValue2(prop_f: _GetPropValueFunc<array of byte>) := GetPropValue(prop_f);
    
    //TODO #634
    private function GetPropValue3(prop_f: function(ntv: cl_program; var data: clBool; validate: boolean): clErrorCode): clBool;
    begin
      OpenCLABCInternalException.RaiseIfError(
        prop_f(self.ntv, Result, false)
      );
    end;
    
    public property SourceCode:     string          read GetPropValue (cl.GetProgramInfo_PROGRAM_SOURCE);
    public property SourceIL:       array of byte   read GetPropValue2(cl.GetProgramInfo_PROGRAM_IL);
    public property HasGlobalInit:  clBool          read GetPropValue3(cl.GetProgramInfo_PROGRAM_SCOPE_GLOBAL_CTORS_PRESENT);
    public property HasGlobalFnlz:  clBool          read GetPropValue3(cl.GetProgramInfo_PROGRAM_SCOPE_GLOBAL_DTORS_PRESENT);
    //TODO #2461
    public function HostPipeNames: array of string :=    GetPropValue (cl.GetProgramInfo_PROGRAM_HOST_PIPE_NAMES)?.Split(':');
    
    public procedure Dispose;
    begin
      var prev_ntv := new cl_program( Interlocked.Exchange(self.ntv.val, IntPtr.Zero) );
      if prev_ntv=cl_program.Zero then exit;
      OpenCLABCInternalException.RaiseIfError( cl.ReleaseProgram(prev_ntv) );
    end;
    protected procedure Finalize; override := Dispose;
    
  end;
  
  {$endregion CLCode}
  
  {$region CLHeaderCode}
  
  CLHeaderCode = partial class(CLCode)
    
    public constructor(code_text: string; c: CLContext := nil) := inherited Create(code_text, c??CLContext.Default);
    public constructor(ntv: cl_program; need_retain: boolean := true) := inherited Create(ntv, need_retain);
    
    private constructor := raise new OpenCLABCInternalException;
    
  end;
  
  {$endregion CLHeaderCode}
  
  {$region BinCLCode}
  
  BinCLCode = abstract partial class(CLCode)
    
    {$region Utils}
    
    protected static function GetLastLog(ntv: cl_program; d: cl_device_id): string;
    begin
      OpenCLABCInternalException.RaiseIfError(
        cl.GetProgramBuildInfo_PROGRAM_BUILD_LOG(ntv, d, Result)
      );
    end;
    
    protected static procedure CheckBuildFail(ntv: cl_program; ec, fail_code: clErrorCode; fail_descr: string; dvcs: sequence of CLDevice);
    begin
      
      // It is common OpenCL impl misstake, to return BUILD_PROGRAM_FAILURE, instead of more specific error
      if (ec=fail_code) or (ec=clErrorCode.BUILD_PROGRAM_FAILURE) then
//      if ec<>clErrorCode.SUCCESS then
      begin
        var sb := new StringBuilder(fail_descr);
        
        foreach var dvc in dvcs do
        begin
          sb += #10#10;
          sb += dvc.ToString;
          sb += ':'#10;
          sb += GetLastLog(ntv, dvc.ntv);
        end;
        
        raise new InvalidOperationException(sb.ToString);
      end else
        OpenCLABCInternalException.RaiseIfError(ec);
      
    end;
    
    {$endregion Utils}
    
    {$region Logs}
    
    private logs := new Dictionary<cl_device_id, string>;
    public property BuildLog[d: CLDevice]: string read logs[d.ntv];
    
    protected procedure SaveLogsFor(dvcs: sequence of CLDevice);
    begin
      {$ifdef DEBUG}
      if logs.Count<>0 then raise new OpenCLABCInternalException($'Multiple calls to SaveLogsFor from {TypeName(self)}');
      {$endif DEBUG}
//      logs.Clear;
      foreach var d in dvcs do logs[d.ntv] := GetLastLog(self.ntv, d.ntv);
    end;
    
    {$endregion Logs}
    
    {$region Serialize}
    
    public function Serialize: array of array of byte;
    begin
      
      var szs: array of UIntPtr;
      OpenCLABCInternalException.RaiseIfError(
        cl.GetProgramInfo_PROGRAM_BINARY_SIZES(ntv, szs)
      );
      
      var res := szs.ConvertAll(sz->new NativeArray<byte>(sz.ToUInt32));
      OpenCLABCInternalException.RaiseIfError(
        cl.GetProgramInfo_PROGRAM_BINARIES(ntv, res.Length, res.ConvertAll(a->a.Area.first_ptr)[0])
      );
      
      Result := res.ConvertAll(a->a.Area.ManagedCopy);
      GC.KeepAlive(res);
    end;
    
    public procedure SerializeTo(bw: System.IO.BinaryWriter);
    begin
      var bin := Serialize;
      
      bw.Write(bin.Length);
      foreach var a in bin do
      begin
        bw.Write(a.Length);
        bw.Write(a);
      end;
      
    end;
    public procedure SerializeTo(str: System.IO.Stream) :=
      SerializeTo(new System.IO.BinaryWriter(str));
    
    {$endregion Serialize}
    
    {$region Deserialize}
    
    protected static function DeserializeNative(c: CLContext; bin: array of array of byte): cl_program;
    begin
      var ec: clErrorCode;
      
      var dvcs := c.GetAllNtvDevices;
      //TODO Отдельные коды ошибок?
      Result := cl.CreateProgramWithBinary(
        c.ntv, dvcs.Length, dvcs,
        bin.ConvertAll(a->new UIntPtr(a.Length)), bin,
        nil,ec
      );
      
      OpenCLABCInternalException.RaiseIfError(ec);
    end;
    
    protected static function LoadBins(br: System.IO.BinaryReader) :=
    ArrGen(br.ReadInt32, i->
    begin
      var len := br.ReadInt32;
      Result := br.ReadBytes(len);
      if Result.Length<>len then raise new System.IO.EndOfStreamException;
    end);
    
    {$endregion}
    
  end;
  
  {$endregion BinCLCode}
  
  {$region LinkableCLCode}
  
  LinkableCLCode = abstract partial class(BinCLCode)
    
  end;
  
  BinCLCode = abstract partial class(CLCode)
    
    private static function link_ntv(bins: IList<LinkableCLCode>; opt: CLCodeOptions): cl_program;
    begin
      var bin_ntvs := new cl_program[bins.Count];
      for var i := 0 to bin_ntvs.Length-1 do
        bin_ntvs[i] := bins[i].ntv;
      
      var ec: clErrorCode;
      Result := cl.LinkProgram(opt.BuildContext.ntv, 0,nil, opt.ToString, bin_ntvs.Length,bin_ntvs, nil,IntPtr.Zero, ec);
      
      if Result=cl_program.Zero then
        //TODO В этом случае нельзя получить лог???
        OpenCLABCInternalException.RaiseIfError(ec) else
        CheckBuildFail(Result,
          ec, clErrorCode.LINK_PROGRAM_FAILURE,
          $'%Err:CLCode:BuildFail:Link%', opt.BuildContext.AllDevices
        );
      
    end;
    public constructor(bins: IList<LinkableCLCode>; opt: CLCodeOptions);
    begin
      inherited Create(link_ntv(bins, opt), false);
      if opt.KeepLog then self.SaveLogsFor(opt.BuildContext.AllDevices);
    end;
    
  end;
  
  {$endregion LinkableCLCode}
  
  {$region CLCompCode}
  
  CLCompCode = partial class(LinkableCLCode)
    
    {$region constructor's}
    
    public constructor(code_text: string; headers: Dictionary<string, CLHeaderCode> := nil; opt: CLProgramCompOptions := nil);
    begin
      inherited Create(code_text, (opt??new CLProgramCompOptions).BuildContext);
      opt := opt??new CLProgramCompOptions;
      
      var ec: clErrorCode;
      if headers=nil then
        ec := cl.CompileProgram(self.ntv, 0,nil, opt.ToString, 0,nil,nil, nil,IntPtr.Zero) else
      begin
        var hs := new cl_program[headers.Count];
        var hns := new string[headers.Count];
        foreach var kvp in headers index i do
        begin
          hs[i] := kvp.Value.ntv;
          hns[i] := kvp.Key;
        end;
        
        ec := cl.CompileProgram(self.ntv, 0,nil, opt.ToString, hs.Length,hs,hns, nil,IntPtr.Zero);
      end;
      
      CheckBuildFail(self.ntv,
        ec, clErrorCode.COMPILE_PROGRAM_FAILURE,
        $'%Err:CLCode:BuildFail:Compile%', opt.BuildContext.AllDevices
      );
      
      if opt.KeepLog then SaveLogsFor(opt.BuildContext.AllDevices);
    end;
    
    public constructor(ntv: cl_program; need_retain: boolean := true) := inherited Create(ntv, need_retain);
    
    private constructor := raise new OpenCLABCInternalException;
    
    {$endregion constructor's}
    
    {$region Deserialize}
    
    public static function Deserialize(bin: array of array of byte; c: CLContext := nil) :=
    new CLCompCode(DeserializeNative(c, bin), false);
    public static function DeserializeFrom(br: System.IO.BinaryReader; c: CLContext := nil) :=
    Deserialize(LoadBins(br), c);
    public static function DeserializeFrom(str: System.IO.Stream; c: CLContext := nil) :=
    DeserializeFrom(new System.IO.BinaryReader(str), c);
    
    {$endregion Deserialize}
    
  end;
  
  {$endregion CLCompCode}
  
  {$region CLCodeLib}
  
  CLCodeLib = partial class(LinkableCLCode)
    
    {$region constructor's}
    
    public constructor(bins: IList<LinkableCLCode>; opt: CLCodeLibOptions := nil) := inherited Create(bins, opt??new CLCodeLibOptions);
    public constructor(params bins: array of LinkableCLCode) := Create(bins as IList<LinkableCLCode>);
    
    public constructor(ntv: cl_program; need_retain: boolean := true) := inherited Create(ntv, need_retain);
    
    private constructor := raise new OpenCLABCInternalException;
    
    {$endregion constructor's}
    
    {$region Deserialize}
    
    public static function Deserialize(bin: array of array of byte; c: CLContext := nil) :=
    new CLCodeLib(DeserializeNative(c, bin), false);
    public static function DeserializeFrom(br: System.IO.BinaryReader; c: CLContext := nil) :=
    Deserialize(LoadBins(br), c);
    public static function DeserializeFrom(str: System.IO.Stream; c: CLContext := nil) :=
    DeserializeFrom(new System.IO.BinaryReader(str), c);
    
    {$endregion Deserialize}
    
  end;
  
  {$endregion CLCodeLib}
  
  {$region CLProgramCode}
  
  CLProgramCode = partial class(BinCLCode)
    
    {$region constructor's}
    
    public constructor(bins: IList<LinkableCLCode>; opt: CLProgramLinkOptions := nil) := inherited Create(bins, opt??new CLProgramLinkOptions);
    public constructor(params bins: array of LinkableCLCode) := Create(bins as IList<LinkableCLCode>);
    
    private procedure Build(opt: CLProgramCompOptions);
    begin
      var ec := cl.BuildProgram(self.ntv, 0,nil, opt.ToString, nil,IntPtr.Zero);
      
      CheckBuildFail(self.ntv,
        ec, clErrorCode.BUILD_PROGRAM_FAILURE,
        $'%Err:CLCode:BuildFail:Compile%', opt.BuildContext.AllDevices
      );
      
      if opt.KeepLog then SaveLogsFor(opt.BuildContext.AllDevices);
    end;
    public constructor(code_text: string; opt: CLProgramCompOptions := nil);
    begin
      inherited Create(code_text, if opt=nil then CLContext.Default else opt.BuildContext);
      self.Build(opt ?? new CLProgramCompOptions);
    end;
    
    public constructor(ntv: cl_program; need_retain: boolean := true) := inherited Create(ntv, need_retain);
    
    private constructor := raise new OpenCLABCInternalException;
    
    {$endregion constructor's}
    
    {$region Deserialize}
    
    public static function Deserialize(bin: array of array of byte; opt: CLProgramCompOptions := nil): CLProgramCode;
    begin
      if opt=nil then opt := new CLProgramCompOptions;
      
      Result := new CLProgramCode(
        DeserializeNative(opt.BuildContext, bin), false
      );
      
      Result.Build(opt);
    end;
    
    public static function DeserializeFrom(br: System.IO.BinaryReader; opt: CLProgramCompOptions := nil) :=
    Deserialize(LoadBins(br), opt);
    public static function DeserializeFrom(str: System.IO.Stream; opt: CLProgramCompOptions := nil) :=
    DeserializeFrom(new System.IO.BinaryReader(str), opt);
    
    {$endregion Deserialize}
    
    //TODO #2668
    public static function operator=(p1,p2: CLProgramCode) := p1.Equals(p2);
    
  end;
  
  {$endregion CLProgramCode}
  
  {$region BinCLCode.Deserialize}
  
  BinCLCode = abstract partial class(CLCode)
    
    public static function Deserialize(bin: array of array of byte; opt: CLProgramCompOptions := nil): BinCLCode;
    begin
      if opt=nil then opt := new CLProgramCompOptions;
      
      var ntv := DeserializeNative(opt.BuildContext, bin);
      
      var general_pt := clProgramBinaryType.PROGRAM_BINARY_TYPE_NONE;
      foreach var d in opt.BuildContext.AllDevices do
      begin
        var pt: clProgramBinaryType;
        OpenCLABCInternalException.RaiseIfError(
          cl.GetProgramBuildInfo_PROGRAM_BINARY_TYPE(ntv,d.ntv, pt,false)
        );
        
        if pt=clProgramBinaryType.PROGRAM_BINARY_TYPE_NONE then
          continue else
        if general_pt=clProgramBinaryType.PROGRAM_BINARY_TYPE_NONE then
          general_pt := pt else
        if general_pt<>pt then
          raise new NotSupportedException($'%BinCLCode:Deserialize:ProgramBinaryType:Different%');
        
      end;
      
      if general_pt = clProgramBinaryType.PROGRAM_BINARY_TYPE_NONE then
        raise new NotSupportedException($'%BinCLCode:Deserialize:ProgramBinaryType:Missing%') else
      if general_pt = clProgramBinaryType.PROGRAM_BINARY_TYPE_COMPILED_OBJECT then
        Result := new CLCompCode(ntv,false) else
      if general_pt = clProgramBinaryType.PROGRAM_BINARY_TYPE_LIBRARY then
        Result := new CLCodeLib(ntv,false) else
      if general_pt = clProgramBinaryType.PROGRAM_BINARY_TYPE_EXECUTABLE then
      begin
        var res := new CLProgramCode(ntv,false);
        res.Build(opt);
        Result := res;
      end else
        //TODO Ещё есть PROGRAM_BINARY_TYPE_INTERMEDIATE из cl_khr_spir
        raise new NotImplementedException(general_pt.ToString);
      
    end;
    
    public static function DeserializeFrom(br: System.IO.BinaryReader; opt: CLProgramCompOptions := nil) :=
      Deserialize(LoadBins(br), opt);
    public static function DeserializeFrom(str: System.IO.Stream; opt: CLProgramCompOptions := nil) :=
      DeserializeFrom(new System.IO.BinaryReader(str), opt);
    
  end;
  
  {$endregion BinCLCode.Deserialize}
  
  {$endregion CLCode}
  
  {$region CLKernel}
  
  CLKernel = partial class
    
    private code: CLProgramCode;
    public property CodeContainer: CLProgramCode read code;
    
    private k_name: string;
    public property Name: string read k_name;
    
    public function AllocNative: cl_kernel;
    public procedure ReleaseNative(ntv: cl_kernel);
    protected procedure AddExistingNative(ntv: cl_kernel);
    
    {$region constructor's}
    
    private constructor(code: CLProgramCode; k_name: string);
    begin
      self.code := code;
      self.k_name := k_name;
      
      // Create one instance, to check if everything is valid
      var ec: clErrorCode;
      var k := cl.CreateKernel(code.ntv, k_name, ec);
      
      if ec.IS_ERROR then
      begin
        if ec=clErrorCode.INVALID_KERNEL_NAME then
        begin
          var names: string;
          OpenCLABCInternalException.RaiseIfError(
            cl.GetProgramInfo_PROGRAM_KERNEL_NAMES(code.ntv, names)
          );
          raise new OpenCLABCInternalException($'Kernel [{k_name}] is not defined in {code}. Existing kernel names: {names}');
        end;
        OpenCLABCInternalException.RaiseIfError(ec);
      end;
      
      AddExistingNative(k);
    end;
    
    public constructor(ntv: cl_kernel);
    begin
      AddExistingNative(ntv);
      
      var code_ntv: cl_program;
      OpenCLABCInternalException.RaiseIfError(
        cl.GetKernelInfo_KERNEL_PROGRAM(ntv, code_ntv, false)
      );
      self.code := new CLProgramCode(code_ntv, true);
      
      OpenCLABCInternalException.RaiseIfError(
        cl.GetKernelInfo_KERNEL_FUNCTION_NAME(ntv, self.k_name)
      );
      
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    {$endregion constructor's}
    
    {$region Exec}
    
    public function Exec1(sz1: CommandQueue<integer>; params args: array of CLKernelArg): CLKernel;
    
    public function Exec2(sz1,sz2: CommandQueue<integer>; params args: array of CLKernelArg): CLKernel;
    
    public function Exec3(sz1,sz2,sz3: CommandQueue<integer>; params args: array of CLKernelArg): CLKernel;
    
    public function Exec(global_work_offset, global_work_size, local_work_size: CommandQueue<array of UIntPtr>; params args: array of CLKernelArg): CLKernel;
    
    {$endregion Exec}
    
  end;
  
  CLProgramCode = partial class
    
    public property KernelByName[kname: string]: CLKernel read new CLKernel(self, kname); default;
    
    public function GetAllKernels: array of CLKernel;
    begin
      
      var c: UInt32;
      OpenCLABCInternalException.RaiseIfError( cl.CreateKernelsInProgram(ntv, 0, IntPtr.Zero, c) );
      
      var res := new cl_kernel[c];
      OpenCLABCInternalException.RaiseIfError( cl.CreateKernelsInProgram(ntv, c, res[0], IntPtr.Zero) );
      
      Result := res.ConvertAll(k->new CLKernel(k));
    end;
    
  end;
  
  {$endregion CLKernel}
  
  {$endregion CLKernel data}
  
  {$region CLMemory}
  
  {$region ICLMemory}
  
  ICLMemory = interface(IDisposable)
    
    property Native: cl_mem read;
    
  end;
  
  {$endregion ICLMemory}
  
  {$region CLMemoryUsage}
  
  CLMemoryUsage = record
    private data: integer;
    
    private const can_read_bit = 1;
    private const can_write_bit = 2
    private const none_bits = 0;
    private const read_write_bits = can_read_bit + can_write_bit;
    
    private constructor(data: integer) := self.data := data;
    public constructor(can_read, can_write: boolean) := Create(
      integer(can_read ) * can_read_bit +
      integer(can_write) * can_write_bit
    );
    private static function operator implicit(data: integer): CLMemoryUsage := new CLMemoryUsage(data);
    
    public static property None:      CLMemoryUsage read new CLMemoryUsage(false, false);
    public static property ReadOnly:  CLMemoryUsage read new CLMemoryUsage(true,  false);
    public static property WriteOnly: CLMemoryUsage read new CLMemoryUsage(false, true);
    public static property ReadWrite: CLMemoryUsage read new CLMemoryUsage(true,  true);
    
    public property CanRead: boolean read data and can_read_bit <> 0;
    public property CanWrite: boolean read data and can_write_bit <> 0;
    
    public static function MakeCLFlags(kernel_use, map_use: CLMemoryUsage): clMemFlags;
    begin
      
      case kernel_use.data of
        none_bits:
          raise new ArgumentException($'%Err:CLMemoryUsage:NoCLKernelAccess%');
        can_read_bit:
          Result := clMemFlags.MEM_READ_ONLY;
        can_write_bit:
          Result := clMemFlags.MEM_WRITE_ONLY;
        read_write_bits:
          Result := clMemFlags.MEM_READ_WRITE;
        else
          raise new ArgumentException($'%Err:CLMemoryUsage:Invalid%');
      end;
      
      case map_use.data of
        none_bits:
          Result += clMemFlags.MEM_HOST_NO_ACCESS;
        can_read_bit:
          Result += clMemFlags.MEM_HOST_READ_ONLY;
        can_write_bit:
          Result += clMemFlags.MEM_HOST_WRITE_ONLY;
        read_write_bits:
          ;
        else
          raise new ArgumentException($'%Err:CLMemoryUsage:Invalid%');
      end;
      
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += typeof(CLMemoryUsage).Name;
      res += '[';
      if CanRead  then res += 'Read';
      if CanWrite then res += 'Write';
      res += ']';
      Result := res.ToString;
    end;
    
  end;
  
  {$endregion CLMemoryUsage}
  
  {$region CLMemory}
  
  ///Представляет область памяти устройства OpenCL (обычно GPU)
  CLMemory = partial class(IDisposable)
    private ntv: cl_mem;
    private memory_report := true;
    
    {$region constructor's}
    
    public constructor(size: UIntPtr; c: CLContext; kernel_use: CLMemoryUsage := CLMemoryUsage.read_write_bits; map_use: CLMemoryUsage := CLMemoryUsage.read_write_bits);
    begin
      
      var ec: clErrorCode;
      self.ntv := cl.CreateBuffer(c.ntv, CLMemoryUsage.MakeCLFlags(kernel_use,map_use), size, nil, ec);
      OpenCLABCInternalException.RaiseIfError(ec);
      
      CLMemoryObserver.Current.AddMemoryUse(size.ToUInt64, {$ifdef DEBUG}new CLMemoryAlloc(self, ntv){$else}ntv{$endif});
      
    end;
    public constructor(size: integer; c: CLContext; kernel_use: CLMemoryUsage := CLMemoryUsage.read_write_bits; map_use: CLMemoryUsage := CLMemoryUsage.read_write_bits) :=
    Create(new UIntPtr(size), c, kernel_use, map_use);
    public constructor(size: int64;   c: CLContext; kernel_use: CLMemoryUsage := CLMemoryUsage.read_write_bits; map_use: CLMemoryUsage := CLMemoryUsage.read_write_bits) :=
    Create(new UIntPtr(size), c, kernel_use, map_use);
    
    public constructor(size: UIntPtr; kernel_use: CLMemoryUsage := CLMemoryUsage.read_write_bits; map_use: CLMemoryUsage := CLMemoryUsage.read_write_bits) :=
    Create(size, CLContext.Default, kernel_use, map_use);
    public constructor(size: integer; kernel_use: CLMemoryUsage := CLMemoryUsage.read_write_bits; map_use: CLMemoryUsage := CLMemoryUsage.read_write_bits) :=
    Create(new UIntPtr(size), kernel_use, map_use);
    public constructor(size: int64;   kernel_use: CLMemoryUsage := CLMemoryUsage.read_write_bits; map_use: CLMemoryUsage := CLMemoryUsage.read_write_bits) :=
    Create(new UIntPtr(size), kernel_use, map_use);
    
    private constructor(ntv: cl_mem; memory_report, need_retain: boolean);
    begin
      self.ntv := ntv;
      self.memory_report := memory_report;
      if need_retain then
        cl.RetainMemObject(ntv);
    end;
    public static function FromNative(ntv: cl_mem; memory_report, need_retain: boolean): CLMemory;
    
    private constructor := raise new OpenCLABCInternalException;
    
    {$endregion constructor's}
    
    {$region property's}
    
    private static function GetSize(ntv: cl_mem): UIntPtr;
    begin
      OpenCLABCInternalException.RaiseIfError(
        cl.GetMemObjectInfo_MEM_SIZE(ntv, Result, false)
      );
    end;
    ///Возвращает размер области памяти в байтах
    public property Size: UIntPtr read GetSize(ntv);
    ///Возвращает размер области памяти в байтах
    public property Size32: UInt32 read Size.ToUInt32;
    ///Возвращает размер области памяти в байтах
    public property Size64: UInt64 read Size.ToUInt64;
    
    {$endregion property's}
    
    {$region IDisposable}
    
    public procedure ReportMemoryFree(prev_ntv: cl_mem); virtual :=
      CLMemoryObserver.ReportFree(prev_ntv{$ifdef DEBUG}, new CLMemoryAlloc(self, prev_ntv){$endif});
    ///Позволяет OpenCL удалить неуправляемый объект
    ///Данный метод вызывается автоматически во время сборки мусора, если объект ещё не удалён
    public procedure Dispose;
    begin
      var prev_ntv := new cl_mem( Interlocked.Exchange(self.ntv.val, IntPtr.Zero) );
      if prev_ntv=cl_mem.Zero then exit;
      if memory_report then ReportMemoryFree(prev_ntv);
      OpenCLABCInternalException.RaiseIfError( cl.ReleaseMemObject(prev_ntv) );
      GC.SuppressFinalize(self);
    end;
    ///Вызывает Dispose. Данный метод вызывается автоматически во время сборки мусора
    ///Данный метод не должен вызываться из пользовательского кода. Он виден только на случай если вы хотите переопределить его в своём классе-наследнике
    protected procedure Finalize; override := Dispose;
    
    {$endregion IDisposable}
    
    {$region 1#Write&Read}
    
    ///Записывает указанное значение размерного типа в начало области памяти
    public function WriteValue<TRecord>(val: TRecord): CLMemory; where TRecord: record;
    
    ///Записывает указанное значение размерного типа в начало области памяти
    public function WriteValue<TRecord>(val: CommandQueue<TRecord>): CLMemory; where TRecord: record;
    
    ///Записывает указанное значение размерного типа в область памяти
    ///mem_offset указывает отступ от начала области памяти, в байтах
    public function WriteValue<TRecord>(val: TRecord; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    ///Записывает указанное значение размерного типа в область памяти
    ///mem_offset указывает отступ от начала области памяти, в байтах
    public function WriteValue<TRecord>(val: CommandQueue<TRecord>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    ///Записывает весь массив в начало области памяти
    public function WriteArray1<TRecord>(a: array of TRecord): CLMemory; where TRecord: record;
    
    ///Записывает весь массив в начало области памяти
    public function WriteArray2<TRecord>(a: array[,] of TRecord): CLMemory; where TRecord: record;
    
    ///Записывает весь массив в начало области памяти
    public function WriteArray3<TRecord>(a: array[,,] of TRecord): CLMemory; where TRecord: record;
    
    ///Заполняет весь массив байбами из начала области памяти
    public function ReadArray1<TRecord>(a: array of TRecord): CLMemory; where TRecord: record;
    
    ///Заполняет весь массив байбами из начала области памяти
    public function ReadArray2<TRecord>(a: array[,] of TRecord): CLMemory; where TRecord: record;
    
    ///Заполняет весь массив байбами из начала области памяти
    public function ReadArray3<TRecord>(a: array[,,] of TRecord): CLMemory; where TRecord: record;
    
    ///Записывает указанный участок массива в область памяти
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///a_ind(-ы) указывают индекс первого задействованного элемента массива
    ///el_count указывает кол-во задействованных элементов массива
    public function WriteArray1<TRecord>(a: array of TRecord; a_ind, el_count, mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    ///Записывает указанный участок массива в область памяти
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///a_ind(-ы) указывают индекс первого задействованного элемента массива
    ///el_count указывает кол-во задействованных элементов массива
    ///==================================================
    ///ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
    ///Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
    ///Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку
    public function WriteArray2<TRecord>(a: array[,] of TRecord; a_ind1,a_ind2, el_count, mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    ///Записывает указанный участок массива в область памяти
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///a_ind(-ы) указывают индекс первого задействованного элемента массива
    ///el_count указывает кол-во задействованных элементов массива
    ///==================================================
    ///ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
    ///Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
    ///Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку
    public function WriteArray3<TRecord>(a: array[,,] of TRecord; a_ind1,a_ind2,a_ind3, el_count, mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    ///Читает данные из области памяти в указанный участок массива
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///a_ind(-ы) указывают индекс первого задействованного элемента массива
    ///el_count указывает кол-во задействованных элементов массива
    public function ReadArray1<TRecord>(a: array of TRecord; a_ind, el_count, mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    ///Читает данные из области памяти в указанный участок массива
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///a_ind(-ы) указывают индекс первого задействованного элемента массива
    ///el_count указывает кол-во задействованных элементов массива
    ///==================================================
    ///ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
    ///Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
    ///Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку
    public function ReadArray2<TRecord>(a: array[,] of TRecord; a_ind1,a_ind2, el_count, mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    ///Читает данные из области памяти в указанный участок массива
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///a_ind(-ы) указывают индекс первого задействованного элемента массива
    ///el_count указывает кол-во задействованных элементов массива
    ///==================================================
    ///ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
    ///Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
    ///Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку
    public function ReadArray3<TRecord>(a: array[,,] of TRecord; a_ind1,a_ind2,a_ind3, el_count, mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    ///Записывает весь массив в начало области памяти
    public function WriteArray1<TRecord>(a: CommandQueue<array of TRecord>): CLMemory; where TRecord: record;
    
    ///Записывает весь массив в начало области памяти
    public function WriteArray2<TRecord>(a: CommandQueue<array[,] of TRecord>): CLMemory; where TRecord: record;
    
    ///Записывает весь массив в начало области памяти
    public function WriteArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>): CLMemory; where TRecord: record;
    
    ///Заполняет весь массив байбами из начала области памяти
    public function ReadArray1<TRecord>(a: CommandQueue<array of TRecord>): CLMemory; where TRecord: record;
    
    ///Заполняет весь массив байбами из начала области памяти
    public function ReadArray2<TRecord>(a: CommandQueue<array[,] of TRecord>): CLMemory; where TRecord: record;
    
    ///Заполняет весь массив байбами из начала области памяти
    public function ReadArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>): CLMemory; where TRecord: record;
    
    ///Записывает указанный участок массива в область памяти
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///a_ind(-ы) указывают индекс первого задействованного элемента массива
    ///el_count указывает кол-во задействованных элементов массива
    public function WriteArray1<TRecord>(a: CommandQueue<array of TRecord>; a_ind, el_count, mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    ///Записывает указанный участок массива в область памяти
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///a_ind(-ы) указывают индекс первого задействованного элемента массива
    ///el_count указывает кол-во задействованных элементов массива
    ///==================================================
    ///ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
    ///Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
    ///Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку
    public function WriteArray2<TRecord>(a: CommandQueue<array[,] of TRecord>; a_ind1,a_ind2, el_count, mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    ///Записывает указанный участок массива в область памяти
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///a_ind(-ы) указывают индекс первого задействованного элемента массива
    ///el_count указывает кол-во задействованных элементов массива
    ///==================================================
    ///ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
    ///Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
    ///Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку
    public function WriteArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>; a_ind1,a_ind2,a_ind3, el_count, mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    ///Читает данные из области памяти в указанный участок массива
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///a_ind(-ы) указывают индекс первого задействованного элемента массива
    ///el_count указывает кол-во задействованных элементов массива
    public function ReadArray1<TRecord>(a: CommandQueue<array of TRecord>; a_ind, el_count, mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    ///Читает данные из области памяти в указанный участок массива
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///a_ind(-ы) указывают индекс первого задействованного элемента массива
    ///el_count указывает кол-во задействованных элементов массива
    ///==================================================
    ///ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
    ///Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
    ///Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку
    public function ReadArray2<TRecord>(a: CommandQueue<array[,] of TRecord>; a_ind1,a_ind2, el_count, mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    ///Читает данные из области памяти в указанный участок массива
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///a_ind(-ы) указывают индекс первого задействованного элемента массива
    ///el_count указывает кол-во задействованных элементов массива
    ///==================================================
    ///ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
    ///Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
    ///Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку
    public function ReadArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>; a_ind1,a_ind2,a_ind3, el_count, mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    ///Записывает указанный участок массива в область памяти
    ///mem_offset указывает отступ от начала области памяти, в байтах
    public function WriteArraySegment<TRecord>(a: ArraySegment<TRecord>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    ///Читает данные из области памяти в указанный участок массива
    ///mem_offset указывает отступ от начала области памяти, в байтах
    public function ReadArraySegment<TRecord>(a: ArraySegment<TRecord>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    ///Заполняет всю область памяти данными, находящимися по указанному адресу в RAM
    public function WriteData(ptr: CommandQueue<IntPtr>): CLMemory;
    
    ///Заполняет часть области памяти данными, находящимися по указанному адресу в RAM
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///len указывает кол-во задействованных в операции байт
    public function WriteData(ptr: CommandQueue<IntPtr>; mem_offset, len: CommandQueue<integer>): CLMemory;
    
    ///Читает всё содержимое области памяти в RAM, по указанному адресу
    public function ReadData(ptr: CommandQueue<IntPtr>): CLMemory;
    
    ///Читает часть содержимого области памяти в RAM, по указанному адресу
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///len указывает кол-во задействованных в операции байт
    public function ReadData(ptr: CommandQueue<IntPtr>; mem_offset, len: CommandQueue<integer>): CLMemory;
    
    ///Заполняет всю область памяти данными, находящимися по указанному адресу в RAM
    public function WriteData(ptr: pointer): CLMemory;
    
    ///Заполняет часть области памяти данными, находящимися по указанному адресу в RAM
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///len указывает кол-во задействованных в операции байт
    public function WriteData(ptr: pointer; mem_offset, len: CommandQueue<integer>): CLMemory;
    
    ///Читает всё содержимое области памяти в RAM, по указанному адресу
    public function ReadData(ptr: pointer): CLMemory;
    
    ///Читает часть содержимого области памяти в RAM, по указанному адресу
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///len указывает кол-во задействованных в операции байт
    public function ReadData(ptr: pointer; mem_offset, len: CommandQueue<integer>): CLMemory;
    
    public function WriteNativeMemoryArea(native_data: NativeMemoryArea): CLMemory;
    
    public function WriteNativeMemoryArea(native_data: NativeMemoryArea; mem_offset: CommandQueue<integer>): CLMemory;
    
    public function WriteNativeMemory(native_data: NativeMemory): CLMemory;
    
    public function WriteNativeMemory(native_data: NativeMemory; mem_offset: CommandQueue<integer>): CLMemory;
    
    public function WriteNativeValueArea<TRecord>(native_data: NativeValueArea<TRecord>): CLMemory; where TRecord: record;
    
    public function WriteNativeValueArea<TRecord>(native_data: NativeValueArea<TRecord>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    ///Записывает указанное значение размерного типа в начало области памяти
    public function WriteNativeValue<TRecord>(native_data: NativeValue<TRecord>): CLMemory; where TRecord: record;
    
    ///Записывает указанное значение размерного типа в область памяти
    ///mem_offset указывает отступ от начала области памяти, в байтах
    public function WriteNativeValue<TRecord>(native_data: NativeValue<TRecord>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    public function WriteNativeArrayArea<TRecord>(native_data: NativeArrayArea<TRecord>): CLMemory; where TRecord: record;
    
    public function WriteNativeArrayArea<TRecord>(native_data: NativeArrayArea<TRecord>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    ///Записывает весь массив в начало области памяти
    public function WriteNativeArray<TRecord>(native_data: NativeArray<TRecord>): CLMemory; where TRecord: record;
    
    public function WriteNativeArray<TRecord>(native_data: NativeArray<TRecord>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    public function ReadNativeMemoryArea(native_data: NativeMemoryArea): CLMemory;
    
    public function ReadNativeMemoryArea(native_data: NativeMemoryArea; mem_offset: CommandQueue<integer>): CLMemory;
    
    public function ReadNativeMemory(native_data: NativeMemory): CLMemory;
    
    public function ReadNativeMemory(native_data: NativeMemory; mem_offset: CommandQueue<integer>): CLMemory;
    
    public function ReadNativeValueArea<TRecord>(native_data: NativeValueArea<TRecord>): CLMemory; where TRecord: record;
    
    public function ReadNativeValueArea<TRecord>(native_data: NativeValueArea<TRecord>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    ///Читает значение размерного типа из начала области памяти в указанное значение
    public function ReadNativeValue<TRecord>(native_data: NativeValue<TRecord>): CLMemory; where TRecord: record;
    
    ///Читает значение размерного типа из области памяти в указанное значение
    ///mem_offset указывает отступ от начала области памяти, в байтах
    public function ReadNativeValue<TRecord>(native_data: NativeValue<TRecord>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    public function ReadNativeArrayArea<TRecord>(native_data: NativeArrayArea<TRecord>): CLMemory; where TRecord: record;
    
    public function ReadNativeArrayArea<TRecord>(native_data: NativeArrayArea<TRecord>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    ///Заполняет весь массив байбами из начала области памяти
    public function ReadNativeArray<TRecord>(native_data: NativeArray<TRecord>): CLMemory; where TRecord: record;
    
    public function ReadNativeArray<TRecord>(native_data: NativeArray<TRecord>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    public function WriteNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>): CLMemory;
    
    public function WriteNativeMemory(native_data: CommandQueue<NativeMemory>): CLMemory;
    
    public function WriteNativeValueArea<TRecord>(native_data: CommandQueue<NativeValueArea<TRecord>>): CLMemory; where TRecord: record;
    
    ///Записывает указанное значение размерного типа в начало области памяти
    public function WriteNativeValue<TRecord>(native_data: CommandQueue<NativeValue<TRecord>>): CLMemory; where TRecord: record;
    
    public function WriteNativeArrayArea<TRecord>(native_data: CommandQueue<NativeArrayArea<TRecord>>): CLMemory; where TRecord: record;
    
    ///Записывает весь массив в начало области памяти
    public function WriteNativeArray<TRecord>(native_data: CommandQueue<NativeArray<TRecord>>): CLMemory; where TRecord: record;
    
    public function ReadNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>): CLMemory;
    
    public function ReadNativeMemory(native_data: CommandQueue<NativeMemory>): CLMemory;
    
    public function ReadNativeValueArea<TRecord>(native_data: CommandQueue<NativeValueArea<TRecord>>): CLMemory; where TRecord: record;
    
    ///Читает значение размерного типа из начала области памяти в указанное значение
    public function ReadNativeValue<TRecord>(native_data: CommandQueue<NativeValue<TRecord>>): CLMemory; where TRecord: record;
    
    public function ReadNativeArrayArea<TRecord>(native_data: CommandQueue<NativeArrayArea<TRecord>>): CLMemory; where TRecord: record;
    
    ///Заполняет весь массив байбами из начала области памяти
    public function ReadNativeArray<TRecord>(native_data: CommandQueue<NativeArray<TRecord>>): CLMemory; where TRecord: record;
    
    public function WriteNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>; mem_offset: CommandQueue<integer>): CLMemory;
    
    public function WriteNativeMemory(native_data: CommandQueue<NativeMemory>; mem_offset: CommandQueue<integer>): CLMemory;
    
    public function WriteNativeValueArea<TRecord>(native_data: CommandQueue<NativeValueArea<TRecord>>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    ///Записывает указанное значение размерного типа в область памяти
    ///mem_offset указывает отступ от начала области памяти, в байтах
    public function WriteNativeValue<TRecord>(native_data: CommandQueue<NativeValue<TRecord>>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    public function WriteNativeArrayArea<TRecord>(native_data: CommandQueue<NativeArrayArea<TRecord>>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    public function WriteNativeArray<TRecord>(native_data: CommandQueue<NativeArray<TRecord>>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    public function ReadNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>; mem_offset: CommandQueue<integer>): CLMemory;
    
    public function ReadNativeMemory(native_data: CommandQueue<NativeMemory>; mem_offset: CommandQueue<integer>): CLMemory;
    
    public function ReadNativeValueArea<TRecord>(native_data: CommandQueue<NativeValueArea<TRecord>>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    ///Читает значение размерного типа из области памяти в указанное значение
    ///mem_offset указывает отступ от начала области памяти, в байтах
    public function ReadNativeValue<TRecord>(native_data: CommandQueue<NativeValue<TRecord>>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    public function ReadNativeArrayArea<TRecord>(native_data: CommandQueue<NativeArrayArea<TRecord>>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    public function ReadNativeArray<TRecord>(native_data: CommandQueue<NativeArray<TRecord>>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    {$endregion 1#Write&Read}
    
    {$region 2#Fill}
    
    ///Заполняет всю область памяти копиями указанного значения размерного типа
    public function FillValue<TRecord>(val: TRecord): CLMemory; where TRecord: record;
    
    ///Заполняет всю область памяти копиями указанного значения размерного типа
    public function FillValue<TRecord>(val: CommandQueue<TRecord>): CLMemory; where TRecord: record;
    
    ///Заполняет часть области памяти копиями указанного значения размерного типа
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///fill_byte_len указывает кол-во заливаемых байт
    public function FillValue<TRecord>(val: TRecord; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    ///Заполняет часть области памяти копиями указанного значения размерного типа
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///fill_byte_len указывает кол-во заливаемых байт
    public function FillValue<TRecord>(val: CommandQueue<TRecord>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    ///Заполняет область памяти копиями указанного массива
    public function FillArray1<TRecord>(a: array of TRecord): CLMemory; where TRecord: record;
    
    ///Заполняет область памяти копиями указанного массива
    public function FillArray2<TRecord>(a: array[,] of TRecord): CLMemory; where TRecord: record;
    
    ///Заполняет область памяти копиями указанного массива
    public function FillArray3<TRecord>(a: array[,,] of TRecord): CLMemory; where TRecord: record;
    
    ///Заполняет область памяти копиями указанного участка массива
    ///a_ind(-ы) указывают индекс первого задействованного элемента массива
    ///el_count указывает кол-во задействованных элементов массива
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///fill_byte_len указывает кол-во заливаемых байт
    public function FillArray1<TRecord>(a: array of TRecord; a_ind, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    ///Заполняет область памяти копиями указанного участка массива
    ///a_ind(-ы) указывают индекс первого задействованного элемента массива
    ///el_count указывает кол-во задействованных элементов массива
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///fill_byte_len указывает кол-во заливаемых байт
    ///==================================================
    ///ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
    ///Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
    ///Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку
    public function FillArray2<TRecord>(a: array[,] of TRecord; a_ind1,a_ind2, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    ///Заполняет область памяти копиями указанного участка массива
    ///a_ind(-ы) указывают индекс первого задействованного элемента массива
    ///el_count указывает кол-во задействованных элементов массива
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///fill_byte_len указывает кол-во заливаемых байт
    ///==================================================
    ///ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
    ///Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
    ///Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку
    public function FillArray3<TRecord>(a: array[,,] of TRecord; a_ind1,a_ind2,a_ind3, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    ///Заполняет область памяти копиями указанного массива
    public function FillArray1<TRecord>(a: CommandQueue<array of TRecord>): CLMemory; where TRecord: record;
    
    ///Заполняет область памяти копиями указанного участка массива
    ///a_ind(-ы) указывают индекс первого задействованного элемента массива
    ///el_count указывает кол-во задействованных элементов массива
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///fill_byte_len указывает кол-во заливаемых байт
    public function FillArray1<TRecord>(a: CommandQueue<array of TRecord>; a_ind, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    ///Заполняет область памяти копиями указанного массива
    public function FillArray2<TRecord>(a: CommandQueue<array[,] of TRecord>): CLMemory; where TRecord: record;
    
    ///Заполняет область памяти копиями указанного участка массива
    ///a_ind(-ы) указывают индекс первого задействованного элемента массива
    ///el_count указывает кол-во задействованных элементов массива
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///fill_byte_len указывает кол-во заливаемых байт
    ///==================================================
    ///ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
    ///Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
    ///Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку
    public function FillArray2<TRecord>(a: CommandQueue<array[,] of TRecord>; a_ind1,a_ind2, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    ///Заполняет область памяти копиями указанного массива
    public function FillArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>): CLMemory; where TRecord: record;
    
    ///Заполняет область памяти копиями указанного участка массива
    ///a_ind(-ы) указывают индекс первого задействованного элемента массива
    ///el_count указывает кол-во задействованных элементов массива
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///fill_byte_len указывает кол-во заливаемых байт
    ///==================================================
    ///ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
    ///Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
    ///Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку
    public function FillArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>; a_ind1,a_ind2,a_ind3, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    public function FillArraySegment<TRecord>(a: CommandQueue<ArraySegment<TRecord>>): CLMemory; where TRecord: record;
    
    public function FillArraySegment<TRecord>(a: CommandQueue<ArraySegment<TRecord>>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    ///Заполняет область памяти копиями указанного участка массива
    public function FillArraySegment<TRecord>(a: ArraySegment<TRecord>): CLMemory; where TRecord: record;
    
    ///Заполняет область памяти копиями указанного участка массива
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///fill_byte_len указывает кол-во заливаемых байт
    public function FillArraySegment<TRecord>(a: ArraySegment<TRecord>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    ///Берёт последовательность из pattern_len байт из RAM по указанному адресу и заполняет её копиями всю область памяти
    public function FillData(ptr: CommandQueue<IntPtr>; pattern_byte_len: CommandQueue<integer>): CLMemory;
    
    ///Берёт последовательность из pattern_len байт из RAM по указанному адресу и заполняет её копиями часть области памяти
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///fill_byte_len указывает кол-во заливаемых байт
    public function FillData(ptr: CommandQueue<IntPtr>; pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory;
    
    ///Берёт последовательность из pattern_len байт из RAM по указанному адресу и заполняет её копиями всю область памяти
    public function FillData(ptr: pointer; pattern_byte_len: CommandQueue<integer>): CLMemory;
    
    ///Берёт последовательность из pattern_len байт из RAM по указанному адресу и заполняет её копиями часть области памяти
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///fill_byte_len указывает кол-во заливаемых байт
    public function FillData(ptr: pointer; pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory;
    
    public function FillNativeMemoryArea(native_data: NativeMemoryArea): CLMemory;
    
    public function FillNativeMemoryArea(native_data: NativeMemoryArea; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory;
    
    public function FillNativeMemory(native_data: NativeMemory): CLMemory;
    
    public function FillNativeMemory(native_data: NativeMemory; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory;
    
    public function FillNativeValueArea<TRecord>(native_data: NativeValueArea<TRecord>): CLMemory; where TRecord: record;
    
    public function FillNativeValueArea<TRecord>(native_data: NativeValueArea<TRecord>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    ///Заполняет всю область памяти копиями указанного значения размерного типа
    public function FillNativeValue<TRecord>(native_data: NativeValue<TRecord>): CLMemory; where TRecord: record;
    
    ///Заполняет часть области памяти копиями указанного значения размерного типа
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///fill_byte_len указывает кол-во заливаемых байт
    public function FillNativeValue<TRecord>(native_data: NativeValue<TRecord>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    public function FillNativeArrayArea<TRecord>(native_data: NativeArrayArea<TRecord>): CLMemory; where TRecord: record;
    
    public function FillNativeArrayArea<TRecord>(native_data: NativeArrayArea<TRecord>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    ///Заполняет область памяти копиями указанного массива
    public function FillNativeArray<TRecord>(native_data: NativeArray<TRecord>): CLMemory; where TRecord: record;
    
    public function FillNativeArray<TRecord>(native_data: NativeArray<TRecord>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    public function FillNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>): CLMemory;
    
    public function FillNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory;
    
    public function FillNativeMemory(native_data: CommandQueue<NativeMemory>): CLMemory;
    
    public function FillNativeMemory(native_data: CommandQueue<NativeMemory>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory;
    
    public function FillNativeValueArea<TRecord>(native_data: CommandQueue<NativeValueArea<TRecord>>): CLMemory; where TRecord: record;
    
    public function FillNativeValueArea<TRecord>(native_data: CommandQueue<NativeValueArea<TRecord>>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    ///Заполняет всю область памяти копиями указанного значения размерного типа
    public function FillNativeValue<TRecord>(native_data: CommandQueue<NativeValue<TRecord>>): CLMemory; where TRecord: record;
    
    ///Заполняет часть области памяти копиями указанного значения размерного типа
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///fill_byte_len указывает кол-во заливаемых байт
    public function FillNativeValue<TRecord>(native_data: CommandQueue<NativeValue<TRecord>>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    public function FillNativeArrayArea<TRecord>(native_data: CommandQueue<NativeArrayArea<TRecord>>): CLMemory; where TRecord: record;
    
    public function FillNativeArrayArea<TRecord>(native_data: CommandQueue<NativeArrayArea<TRecord>>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    ///Заполняет область памяти копиями указанного массива
    public function FillNativeArray<TRecord>(native_data: CommandQueue<NativeArray<TRecord>>): CLMemory; where TRecord: record;
    
    public function FillNativeArray<TRecord>(native_data: CommandQueue<NativeArray<TRecord>>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory; where TRecord: record;
    
    {$endregion 2#Fill}
    
    {$region 3#Copy}
    
    ///Копирует данные из данной области памяти в mem
    ///Если области памяти имеют разный размер - в качестве объёма данных берётся размер меньшей области
    public function CopyTo(mem: CommandQueue<CLMemory>): CLMemory;
    
    ///Копирует данные из данной области памяти в mem
    ///from_offset указывает отступ в байтах от начала области памяти, из которой копируют
    ///to_offset указывает отступ в байтах от начала области памяти, в которую копируют
    ///len указывает кол-во копируемых байт
    public function CopyTo(mem: CommandQueue<CLMemory>; from_offset, to_offset, len: CommandQueue<integer>): CLMemory;
    
    ///Копирует данные из mem в данную область памяти
    ///Если области памяти имеют разный размер - в качестве объёма данных берётся размер меньшей области
    public function CopyFrom(mem: CommandQueue<CLMemory>): CLMemory;
    
    ///Копирует данные из mem в данную область памяти
    ///from_offset указывает отступ в байтах от начала области памяти, из которой копируют
    ///to_offset указывает отступ в байтах от начала области памяти, в которую копируют
    ///len указывает кол-во копируемых байт
    public function CopyFrom(mem: CommandQueue<CLMemory>; from_offset, to_offset, len: CommandQueue<integer>): CLMemory;
    
    {$endregion 3#Copy}
    
    {$region Get}
    
    ///Читает значение указанного размерного типа из начала области памяти
    public function GetValue<TRecord>: TRecord; where TRecord: record;
    
    ///Читает значение указанного размерного типа из области памяти
    ///mem_offset указывает отступ от начала области памяти, в байтах
    public function GetValue<TRecord>(mem_offset: CommandQueue<integer>): TRecord; where TRecord: record;
    
    ///Создаёт массив с максимальным возможным кол-вом элементов и заполняет его содержимым области памяти
    public function GetArray<TRecord>: array of TRecord; where TRecord: record;
    
    ///Создаёт массив с указанным кол-вом элементов и копирует в него содержимое из начала области памяти
    public function GetArray<TRecord>(len: CommandQueue<integer>): array of TRecord; where TRecord: record;
    
    ///Создаёт массив с указанным кол-вом элементов и копирует в него содержимое из начала области памяти
    public function GetArray2<TRecord>(len1,len2: CommandQueue<integer>): array[,] of TRecord; where TRecord: record;
    
    ///Создаёт массив с указанным кол-вом элементов и копирует в него содержимое из начала области памяти
    public function GetArray3<TRecord>(len1,len2,len3: CommandQueue<integer>): array[,,] of TRecord; where TRecord: record;
    
    {$endregion Get}
    
  end;
  
  {$endregion CLMemory}
  
  {$region CLMemorySubSegment}
  
  ///Представляет виртуальную область памяти, выделенную внутри CLMemory
  CLMemorySubSegment = partial class(CLMemory)
    private _parent: cl_mem;
    
    {$region constructor's}
    
    private static function MakeSubNtv(parent: cl_mem; reg: cl_buffer_region; flags: clMemFlags): cl_mem;
    begin
      var ec: clErrorCode;
      Result := cl.CreateSubBuffer(parent, flags, clBufferCreateType.BUFFER_CREATE_TYPE_REGION, reg, ec);
      OpenCLABCInternalException.RaiseIfError(ec);
    end;
    
    public constructor(parent: CLMemory; origin, size: UIntPtr; kernel_use: CLMemoryUsage := CLMemoryUsage.read_write_bits; map_use: CLMemoryUsage := CLMemoryUsage.read_write_bits);
    begin
      inherited Create( MakeSubNtv(parent.ntv, new cl_buffer_region(origin, size), CLMemoryUsage.MakeCLFlags(kernel_use, map_use)), false, false );
      self._parent := parent.ntv;
    end;
    public constructor(parent: CLMemory; origin, size: UInt32; kernel_use: CLMemoryUsage := CLMemoryUsage.read_write_bits; map_use: CLMemoryUsage := CLMemoryUsage.read_write_bits) :=
    Create(parent, new UIntPtr(origin), new UIntPtr(size), kernel_use, map_use);
    public constructor(parent: CLMemory; origin, size: UInt64; kernel_use: CLMemoryUsage := CLMemoryUsage.read_write_bits; map_use: CLMemoryUsage := CLMemoryUsage.read_write_bits) :=
    Create(parent, new UIntPtr(origin), new UIntPtr(size), kernel_use, map_use);
    
    // For the CLMemory.FromNative
    private constructor(parent, ntv: cl_mem; memory_report, need_retain: boolean);
    begin
      inherited Create(ntv, memory_report, need_retain);
      self._parent := parent;
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    {$endregion constructor's}
    
    {$region property's}
    
    ///Возвращает родительскую область памяти
    public property Parent: CLMemory read CLMemory.FromNative(_parent, false, true);
    
    {$endregion property's}
    
    public procedure ReportMemoryFree(prev_ntv: cl_mem); override := exit;
    
  end;
  
  {$endregion CLMemorySubSegment}
  
  {$region CLValue}
  
  ///Представляет запись, значение которой хранится на устройстве OpenCL (обычно GPU)
  CLValue<T> = partial class(IDisposable)
  where T: record;
    private ntv: cl_mem;
    private memory_report := true;
    
    {$region constructor's}
    
    public constructor(c: CLContext; kernel_use: CLMemoryUsage := CLMemoryUsage.read_write_bits; map_use: CLMemoryUsage := CLMemoryUsage.read_write_bits);
    begin
      
      var ec: clErrorCode;
      self.ntv := cl.CreateBuffer(c.ntv, CLMemoryUsage.MakeCLFlags(kernel_use,map_use), new UIntPtr(ValueSize), nil, ec);
      OpenCLABCInternalException.RaiseIfError(ec);
      
      CLMemoryObserver.Current.AddMemoryUse(ValueSize, {$ifdef DEBUG}new CLMemoryAlloc(self, ntv){$else}ntv{$endif});
      
    end;
    public constructor(c: CLContext; val: T; kernel_use: CLMemoryUsage := CLMemoryUsage.read_write_bits; map_use: CLMemoryUsage := CLMemoryUsage.read_write_bits);
    begin
      
      var ec: clErrorCode;
      self.ntv := cl.CreateBuffer(c.ntv, CLMemoryUsage.MakeCLFlags(kernel_use,map_use) + clMemFlags.MEM_COPY_HOST_PTR, new UIntPtr(ValueSize), val, ec);
      OpenCLABCInternalException.RaiseIfError(ec);
      
      CLMemoryObserver.Current.AddMemoryUse(ValueSize, {$ifdef DEBUG}new CLMemoryAlloc(self, ntv){$else}ntv{$endif});
      
    end;
    
    public constructor(kernel_use: CLMemoryUsage := CLMemoryUsage.read_write_bits; map_use: CLMemoryUsage := CLMemoryUsage.read_write_bits) :=
    Create(CLContext.Default, kernel_use, map_use);
    public constructor(val: T; kernel_use: CLMemoryUsage := CLMemoryUsage.read_write_bits; map_use: CLMemoryUsage := CLMemoryUsage.read_write_bits) :=
    Create(CLContext.Default, val, kernel_use, map_use);
    
    public constructor(ntv: cl_mem; memory_report, need_retain: boolean);
    begin
      self.ntv := ntv;
      self.memory_report := memory_report;
      if need_retain then
        OpenCLABCInternalException.RaiseIfError( cl.RetainMemObject(ntv) );
    end;
    
    public static function operator implicit(mem: CLValue<T>): CLMemory := new CLMemory(mem.ntv, false, true);
    public constructor(mem: CLMemory) := Create(mem.ntv, false, true);
    
    {$endregion constructor's}
    
    {$region property's}
    
    private static value_size := Marshal.SizeOf(default(T));
    ///Возвращает размер значения, в байтах
    public static property ValueSize: integer read value_size;
    
    {$endregion property's}
    
    {$region IDisposable}
    
    ///Позволяет OpenCL удалить неуправляемый объект
    ///Данный метод вызывается автоматически во время сборки мусора, если объект ещё не удалён
    public procedure Dispose;
    begin
      var prev_ntv := new cl_mem(Interlocked.Exchange(self.ntv.val, IntPtr.Zero));
      if prev_ntv=cl_mem.Zero then exit;
      if memory_report then CLMemoryObserver.ReportFree(prev_ntv{$ifdef DEBUG}, new CLMemoryAlloc(self, prev_ntv){$endif});
      OpenCLABCInternalException.RaiseIfError( cl.ReleaseMemObject(prev_ntv) );
      GC.SuppressFinalize(self);
    end;
    ///Вызывает Dispose. Данный метод вызывается автоматически во время сборки мусора
    ///Данный метод не должен вызываться из пользовательского кода. Он виден только на случай если вы хотите переопределить его в своём классе-наследнике
    protected procedure Finalize; override := Dispose;
    
    {$endregion IDisposable}
    
    {$region 1#Write&Read}
    
    ///Записывает указанное значение в данное
    public function WriteValue(val: &T): CLValue<T>;
    
    ///Записывает указанное значение в данное
    public function WriteValue(val: CommandQueue<&T>): CLValue<T>;
    
    public function WriteNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>): CLValue<T>;
    
    ///Записывает указанное значение в данное
    public function WriteNativeValue(native_data: CommandQueue<NativeValue<&T>>): CLValue<T>;
    
    public function ReadNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>): CLValue<T>;
    
    ///Читает данное значение в указанное
    public function ReadNativeValue(native_data: CommandQueue<NativeValue<&T>>): CLValue<T>;
    
    {$endregion 1#Write&Read}
    
    {$region 3#Copy}
    
    ///Копирует данные из данного значения в mem
    public function CopyTo(mem: CommandQueue<CLMemory>): CLValue<T>;
    
    ///Копирует данные из mem в данное значение
    public function CopyFrom(mem: CommandQueue<CLMemory>): CLValue<T>;
    
    ///Копирует данные из данного значения в mem
    ///mem_offset указывает отступ от начала области памяти, в байтах
    public function CopyTo(mem: CommandQueue<CLMemory>; mem_offset: CommandQueue<integer>): CLValue<T>;
    
    ///Копирует данные из mem в данное значение
    ///mem_offset указывает отступ от начала области памяти, в байтах
    public function CopyFrom(mem: CommandQueue<CLMemory>; mem_offset: CommandQueue<integer>): CLValue<T>;
    
    ///Копирует данные из данного значения в val
    public function CopyTo(val: CommandQueue<CLValue<&T>>): CLValue<T>;
    
    ///Копирует данные из val в данное значение
    public function CopyFrom(val: CommandQueue<CLValue<&T>>): CLValue<T>;
    
    {$endregion 3#Copy}
    
    {$region Get}
    
    ///Читает данное значение
    public function GetValue: &T;
    
    {$endregion Get}
    
  end;
  
  {$endregion CLValue}
  
  {$region CLArray}
  
  ///Представляет массив записей, содержимое которого хранится на устройстве OpenCL (обычно GPU)
  CLArray<T> = partial class(IDisposable)
  where T: record;
    private ntv: cl_mem;
    private memory_report := true;
    
    {$region constructor's}
    
    private procedure InitByLen(c: CLContext; kernel_use, map_use: CLMemoryUsage);
    begin
      
      var ec: clErrorCode;
      self.ntv := cl.CreateBuffer(c.ntv, CLMemoryUsage.MakeCLFlags(kernel_use,map_use), new UIntPtr(ByteSize), nil, ec);
      OpenCLABCInternalException.RaiseIfError(ec);
      
      CLMemoryObserver.Current.AddMemoryUse(ByteSize, {$ifdef DEBUG}new CLMemoryAlloc(self, ntv){$else}ntv{$endif});
      
    end;
    private procedure InitByVal(c: CLContext; var els: T; kernel_use, map_use: CLMemoryUsage);
    begin
      
      var ec: clErrorCode;
      self.ntv := cl.CreateBuffer(c.ntv, CLMemoryUsage.MakeCLFlags(kernel_use,map_use) + clMemFlags.MEM_COPY_HOST_PTR, new UIntPtr(ByteSize), els, ec);
      OpenCLABCInternalException.RaiseIfError(ec);
      
      CLMemoryObserver.Current.AddMemoryUse(ByteSize, {$ifdef DEBUG}new CLMemoryAlloc(self, ntv){$else}ntv{$endif});
      
    end;
    
    public constructor(c: CLContext; len: integer; kernel_use: CLMemoryUsage := CLMemoryUsage.read_write_bits; map_use: CLMemoryUsage := CLMemoryUsage.read_write_bits);
    begin
      self.len := len;
      InitByLen(c, kernel_use, map_use);
    end;
    public constructor(len: integer; kernel_use: CLMemoryUsage := CLMemoryUsage.read_write_bits; map_use: CLMemoryUsage := CLMemoryUsage.read_write_bits) :=
      Create(CLContext.Default, len, kernel_use, map_use);
    
    public constructor(c: CLContext; els: array of T; kernel_use: CLMemoryUsage := CLMemoryUsage.read_write_bits; map_use: CLMemoryUsage := CLMemoryUsage.read_write_bits);
    begin
      self.len := els.Length;
      InitByVal(c, els[0], kernel_use, map_use);
    end;
    public constructor(els: array of T; kernel_use: CLMemoryUsage := CLMemoryUsage.read_write_bits; map_use: CLMemoryUsage := CLMemoryUsage.read_write_bits) :=
      Create(CLContext.Default, els, kernel_use, map_use);
    
    public constructor(c: CLContext; els_from, len: integer; els: array of T; kernel_use: CLMemoryUsage := CLMemoryUsage.read_write_bits; map_use: CLMemoryUsage := CLMemoryUsage.read_write_bits);
    begin
      self.len := len;
      InitByVal(c, els[els_from], kernel_use, map_use);
    end;
    public constructor(els_from, len: integer; els: array of T; kernel_use: CLMemoryUsage := CLMemoryUsage.read_write_bits; map_use: CLMemoryUsage := CLMemoryUsage.read_write_bits) :=
      Create(CLContext.Default, els_from, len, els, kernel_use, map_use);
    
    public constructor(ntv: cl_mem; memory_report, need_retain: boolean);
    begin
      
      var byte_size: UIntPtr;
      OpenCLABCInternalException.RaiseIfError(
        cl.GetMemObjectInfo_MEM_SIZE(ntv, byte_size, false)
      );
      self.len := byte_size.ToUInt64 div item_size;
      
      if need_retain then
        OpenCLABCInternalException.RaiseIfError( cl.RetainMemObject(ntv) );
      self.ntv := ntv;
      self.memory_report := memory_report;
      
    end;
    
    public static function operator implicit(mem: CLArray<T>): CLMemory := new CLMemory(mem.ntv, false, true);
    public constructor(mem: CLMemory) := Create(mem.ntv, false, true);
    
    private constructor := raise new OpenCLABCInternalException;
    
    {$endregion constructor's}
    
    {$region property's}
    
    private static item_size := Marshal.SizeOf(default(T));
    ///Возвращает размер одного элемента массива, в байтах
    public static property ItemSize: integer read item_size;
    
    private len: integer;
    ///Возвращает длину массива
    public property Length: integer read len;
    ///Возвращает размер области памяти, занимаемой массивом, в байтах
    public property ByteSize: int64 read int64(len) * item_size;
    
    private function GetItemProp(ind: integer): T;
    private procedure SetItemProp(ind: integer; value: T);
    ///Возвращает или задаёт один элемент массива
    ///Внимание! Данные свойство использует неявные очереди при каждом обращение, поэтому может быть очень не эффективным
    public property Item[ind: integer]: T read GetItemProp write SetItemProp; default;
    
    private function GetSliceProp(range: IntRange): array of T;
    private procedure SetSliceProp(range: IntRange; value: array of T);
    ///Возвращает или задаёт элементы массива в заданном диапазоне
    ///Внимание! Данные свойство использует неявные очереди при каждом обращение, поэтому может быть очень не эффективным
    public property Slice[range: IntRange]: array of T read GetSliceProp write SetSliceProp;
    
    {$endregion property's}
    
    {$region IDisposable}
    
    ///Позволяет OpenCL удалить неуправляемый объект
    ///Данный метод вызывается автоматически во время сборки мусора, если объект ещё не удалён
    public procedure Dispose;
    begin
      var prev_ntv := new cl_mem(Interlocked.Exchange(self.ntv.val, IntPtr.Zero));
      if prev_ntv=cl_mem.Zero then exit;
      if memory_report then CLMemoryObserver.ReportFree(prev_ntv{$ifdef DEBUG}, new CLMemoryAlloc(self, prev_ntv){$endif});
      OpenCLABCInternalException.RaiseIfError( cl.ReleaseMemObject(prev_ntv) );
      GC.SuppressFinalize(self);
    end;
    ///Вызывает Dispose. Данный метод вызывается автоматически во время сборки мусора
    ///Данный метод не должен вызываться из пользовательского кода. Он виден только на случай если вы хотите переопределить его в своём классе-наследнике
    protected procedure Finalize; override := Dispose;
    
    {$endregion IDisposable}
    
    {$region 1#Write&Read}
    
    ///Записывает указанное значение в элемент данного массива с индексом ind
    public function WriteValue(val: &T; ind: CommandQueue<integer>): CLArray<T>;
    
    ///Записывает указанное значение в элемент данного массива с индексом ind
    public function WriteValue(val: CommandQueue<&T>; ind: CommandQueue<integer>): CLArray<T>;
    
    ///Записывает указанный массив RAM в начало данного массива OpenCL
    public function WriteArray(a: CommandQueue<array of &T>): CLArray<T>;
    
    ///Записывает указанный массив RAM в начало данного массива OpenCL
    public function WriteArray2(a: CommandQueue<array[,] of &T>): CLArray<T>;
    
    ///Записывает указанный массив RAM в начало данного массива OpenCL
    public function WriteArray3(a: CommandQueue<array[,,] of &T>): CLArray<T>;
    
    ///Читает начало данного массива OpenCL в указанный массив RAM
    public function ReadArray(a: CommandQueue<array of &T>): CLArray<T>;
    
    ///Читает начало данного массива OpenCL в указанный массив RAM
    public function ReadArray2(a: CommandQueue<array[,] of &T>): CLArray<T>;
    
    ///Читает начало данного массива OpenCL в указанный массив RAM
    public function ReadArray3(a: CommandQueue<array[,,] of &T>): CLArray<T>;
    
    ///Записывает len элементов из указанного массива RAM в данный массив OpenCL
    ///ind указывает индекс первого элемента данного массива OpenCL
    ///a_ind(-ы) указывают индекс первого элемента в массиве RAM
    public function WriteArray(a: CommandQueue<array of &T>; a_ind, len, ind: CommandQueue<integer>): CLArray<T>;
    
    ///Записывает len элементов из указанного массива RAM в данный массив OpenCL
    ///ind указывает индекс первого элемента данного массива OpenCL
    ///a_ind(-ы) указывают индекс первого элемента в массиве RAM
    ///==================================================
    ///ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
    ///Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
    ///Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку
    public function WriteArray2(a: CommandQueue<array[,] of &T>; a_ind1,a_ind2, len, ind: CommandQueue<integer>): CLArray<T>;
    
    ///Записывает len элементов из указанного массива RAM в данный массив OpenCL
    ///ind указывает индекс первого элемента данного массива OpenCL
    ///a_ind(-ы) указывают индекс первого элемента в массиве RAM
    ///==================================================
    ///ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
    ///Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
    ///Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку
    public function WriteArray3(a: CommandQueue<array[,,] of &T>; a_ind1,a_ind2,a_ind3, len, ind: CommandQueue<integer>): CLArray<T>;
    
    ///Читает len элементов данного массива OpenCL в указанный массив RAM
    ///ind указывает индекс первого элемента данного массива OpenCL
    ///a_ind(-ы) указывают индекс первого элемента в массиве RAM
    public function ReadArray(a: CommandQueue<array of &T>; a_ind, len, ind: CommandQueue<integer>): CLArray<T>;
    
    ///Читает len элементов данного массива OpenCL в указанный массив RAM
    ///ind указывает индекс первого элемента данного массива OpenCL
    ///a_ind(-ы) указывают индекс первого элемента в массиве RAM
    ///==================================================
    ///ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
    ///Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
    ///Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку
    public function ReadArray2(a: CommandQueue<array[,] of &T>; a_ind1,a_ind2, len, ind: CommandQueue<integer>): CLArray<T>;
    
    ///Читает len элементов данного массива OpenCL в указанный массив RAM
    ///ind указывает индекс первого элемента данного массива OpenCL
    ///a_ind(-ы) указывают индекс первого элемента в массиве RAM
    ///==================================================
    ///ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
    ///Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
    ///Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку
    public function ReadArray3(a: CommandQueue<array[,,] of &T>; a_ind1,a_ind2,a_ind3, len, ind: CommandQueue<integer>): CLArray<T>;
    
    ///Записывает указанный участок массива RAM в начало данного массива OpenCL
    public function WriteArraySegment(a: CommandQueue<ArraySegment<&T>>): CLArray<T>;
    
    ///Читает начало данного массива OpenCL в указанный участок массива RAM
    public function ReadArraySegment(a: CommandQueue<ArraySegment<&T>>): CLArray<T>;
    
    ///Записывает указанный участок массива RAM в данный массив OpenCL
    ///ind указывает индекс первого элемента данного массива OpenCL
    public function WriteArraySegment(a: CommandQueue<ArraySegment<&T>>; ind: CommandQueue<integer>): CLArray<T>;
    
    ///Читает данные данного массива OpenCL в указанный участок массива RAM
    ///ind указывает индекс первого элемента данного массива OpenCL
    public function ReadArraySegment(a: CommandQueue<ArraySegment<&T>>; ind: CommandQueue<integer>): CLArray<T>;
    
    ///Заполняет весь данный массив данными, находящимися по указанному адресу в RAM
    public function WriteData(ptr: CommandQueue<IntPtr>): CLArray<T>;
    
    ///Заполняет len элементов начиная с индекса ind данного массива данными, находящимися по указанному адресу в RAM
    public function WriteData(ptr: CommandQueue<IntPtr>; ind, len: CommandQueue<integer>): CLArray<T>;
    
    ///Читает всё содержимое из данного массива в RAM, по указанному адресу
    public function ReadData(ptr: CommandQueue<IntPtr>): CLArray<T>;
    
    ///Читает len элементов начиная с индекса ind из данного массива в RAM, по указанному адресу
    public function ReadData(ptr: CommandQueue<IntPtr>; ind, len: CommandQueue<integer>): CLArray<T>;
    
    ///Заполняет весь данный массив данными, находящимися по указанному адресу в RAM
    public function WriteData(ptr: pointer): CLArray<T>;
    
    ///Заполняет len элементов начиная с индекса ind данного массива данными, находящимися по указанному адресу в RAM
    public function WriteData(ptr: pointer; ind, len: CommandQueue<integer>): CLArray<T>;
    
    ///Читает всё содержимое из данного массива в RAM, по указанному адресу
    public function ReadData(ptr: pointer): CLArray<T>;
    
    ///Читает len элементов начиная с индекса ind из данного массива в RAM, по указанному адресу
    public function ReadData(ptr: pointer; ind, len: CommandQueue<integer>): CLArray<T>;
    
    public function WriteNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>): CLArray<T>;
    
    public function WriteNativeMemory(native_data: CommandQueue<NativeMemory>): CLArray<T>;
    
    public function WriteNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>): CLArray<T>;
    
    public function WriteNativeValue(native_data: CommandQueue<NativeValue<&T>>): CLArray<T>;
    
    public function WriteNativeArrayArea(native_data: CommandQueue<NativeArrayArea<&T>>): CLArray<T>;
    
    ///Записывает указанный массив RAM в начало данного массива OpenCL
    public function WriteNativeArray(native_data: CommandQueue<NativeArray<&T>>): CLArray<T>;
    
    public function ReadNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>): CLArray<T>;
    
    public function ReadNativeMemory(native_data: CommandQueue<NativeMemory>): CLArray<T>;
    
    public function ReadNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>): CLArray<T>;
    
    public function ReadNativeValue(native_data: CommandQueue<NativeValue<&T>>): CLArray<T>;
    
    public function ReadNativeArrayArea(native_data: CommandQueue<NativeArrayArea<&T>>): CLArray<T>;
    
    ///Читает начало данного массива OpenCL в указанный массив RAM
    public function ReadNativeArray(native_data: CommandQueue<NativeArray<&T>>): CLArray<T>;
    
    public function WriteNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>; mem_offset: CommandQueue<integer>): CLArray<T>;
    
    public function WriteNativeMemory(native_data: CommandQueue<NativeMemory>; mem_offset: CommandQueue<integer>): CLArray<T>;
    
    public function WriteNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>; mem_offset: CommandQueue<integer>): CLArray<T>;
    
    ///Записывает указанное значение в элемент данного массива с индексом ind
    public function WriteNativeValue(native_data: CommandQueue<NativeValue<&T>>; mem_offset: CommandQueue<integer>): CLArray<T>;
    
    public function WriteNativeArrayArea(native_data: CommandQueue<NativeArrayArea<&T>>; mem_offset: CommandQueue<integer>): CLArray<T>;
    
    public function WriteNativeArray(native_data: CommandQueue<NativeArray<&T>>; mem_offset: CommandQueue<integer>): CLArray<T>;
    
    public function ReadNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>; mem_offset: CommandQueue<integer>): CLArray<T>;
    
    public function ReadNativeMemory(native_data: CommandQueue<NativeMemory>; mem_offset: CommandQueue<integer>): CLArray<T>;
    
    public function ReadNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>; mem_offset: CommandQueue<integer>): CLArray<T>;
    
    ///Читает элемент данного массива с индексом ind в указанное значение
    public function ReadNativeValue(native_data: CommandQueue<NativeValue<&T>>; mem_offset: CommandQueue<integer>): CLArray<T>;
    
    public function ReadNativeArrayArea(native_data: CommandQueue<NativeArrayArea<&T>>; mem_offset: CommandQueue<integer>): CLArray<T>;
    
    public function ReadNativeArray(native_data: CommandQueue<NativeArray<&T>>; mem_offset: CommandQueue<integer>): CLArray<T>;
    
    {$endregion 1#Write&Read}
    
    {$region 2#Fill}
    
    ///Заполняет весь массив копиями указанного значения
    public function FillValue(val: &T): CLArray<T>;
    
    ///Заполняет весь массив копиями указанного значения
    public function FillValue(val: CommandQueue<&T>): CLArray<T>;
    
    ///Заполняет len элементов начиная с индекса ind копиями указанного значения
    public function FillValue(val: &T; ind, len: CommandQueue<integer>): CLArray<T>;
    
    ///Заполняет len элементов начиная с индекса ind копиями указанного значения
    public function FillValue(val: CommandQueue<&T>; ind, len: CommandQueue<integer>): CLArray<T>;
    
    ///Заполняет данный массив OpenCL копиями указанного массива RAM
    public function FillArray(a: CommandQueue<array of &T>): CLArray<T>;
    
    ///Заполняет данный массив OpenCL копиями указанного массива RAM
    public function FillArray2(a: CommandQueue<array[,] of &T>): CLArray<T>;
    
    ///Заполняет данный массив OpenCL копиями указанного массива RAM
    public function FillArray3(a: CommandQueue<array[,,] of &T>): CLArray<T>;
    
    ///Заполняет fill_len элементов данного массива OpenCL копиями участков из pattern_len элементов указанного массива
    ///ind указывает индекс первого элемента данного массива OpenCL
    ///a_ind(-ы) указывают индекс первого элемента в массиве RAM
    public function FillArray(a: CommandQueue<array of &T>; a_ind, pattern_len, ind, fill_len: CommandQueue<integer>): CLArray<T>;
    
    ///Заполняет fill_len элементов данного массива OpenCL копиями участков из pattern_len элементов указанного массива
    ///ind указывает индекс первого элемента данного массива OpenCL
    ///a_ind(-ы) указывают индекс первого элемента в массиве RAM
    ///==================================================
    ///ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
    ///Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
    ///Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку
    public function FillArray2(a: CommandQueue<array[,] of &T>; a_ind1,a_ind2, pattern_len, ind, fill_len: CommandQueue<integer>): CLArray<T>;
    
    ///Заполняет fill_len элементов данного массива OpenCL копиями участков из pattern_len элементов указанного массива
    ///ind указывает индекс первого элемента данного массива OpenCL
    ///a_ind(-ы) указывают индекс первого элемента в массиве RAM
    ///==================================================
    ///ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
    ///Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
    ///Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку
    public function FillArray3(a: CommandQueue<array[,,] of &T>; a_ind1,a_ind2,a_ind3, pattern_len, ind, fill_len: CommandQueue<integer>): CLArray<T>;
    
    ///Заполняет данный массив OpenCL копиями указанного участка массива RAM
    public function FillArraySegment(a: CommandQueue<ArraySegment<&T>>): CLArray<T>;
    
    ///Заполняет fill_len элементов данного массива OpenCL начиная с индекса ind копиями указанного участка массива RAM
    public function FillArraySegment(a: CommandQueue<ArraySegment<&T>>; ind, fill_len: CommandQueue<integer>): CLArray<T>;
    
    ///Берёт pattern_len элементов из RAM по указанному адресу и заполняет их копиями весь данный массив
    public function FillData(ptr: CommandQueue<IntPtr>; pattern_len: CommandQueue<integer>): CLArray<T>;
    
    ///Берёт pattern_len элементов из RAM по указанному адресу и заполняет их копиями len элементов начиная с индекса ind данного массива
    public function FillData(ptr: CommandQueue<IntPtr>; pattern_len, ind, fill_len: CommandQueue<integer>): CLArray<T>;
    
    ///Берёт pattern_len элементов из RAM по указанному адресу и заполняет их копиями весь данный массив
    public function FillData(ptr: pointer; pattern_len: CommandQueue<integer>): CLArray<T>;
    
    ///Берёт pattern_len элементов из RAM по указанному адресу и заполняет их копиями len элементов начиная с индекса ind данного массива
    public function FillData(ptr: pointer; pattern_len, ind, fill_len: CommandQueue<integer>): CLArray<T>;
    
    public function FillNativeMemoryArea(native_data: NativeMemoryArea): CLArray<T>;
    
    public function FillNativeMemoryArea(native_data: NativeMemoryArea; ind,fill_len: CommandQueue<integer>): CLArray<T>;
    
    public function FillNativeMemory(native_data: NativeMemory): CLArray<T>;
    
    public function FillNativeMemory(native_data: NativeMemory; ind,fill_len: CommandQueue<integer>): CLArray<T>;
    
    public function FillNativeValueArea(native_data: NativeValueArea<&T>): CLArray<T>;
    
    public function FillNativeValueArea(native_data: NativeValueArea<&T>; ind,fill_len: CommandQueue<integer>): CLArray<T>;
    
    public function FillNativeValue(native_data: NativeValue<&T>): CLArray<T>;
    
    public function FillNativeValue(native_data: NativeValue<&T>; ind,fill_len: CommandQueue<integer>): CLArray<T>;
    
    public function FillNativeArrayArea(native_data: NativeArrayArea<&T>): CLArray<T>;
    
    public function FillNativeArrayArea(native_data: NativeArrayArea<&T>; ind,fill_len: CommandQueue<integer>): CLArray<T>;
    
    public function FillNativeArray(native_data: NativeArray<&T>): CLArray<T>;
    
    public function FillNativeArray(native_data: NativeArray<&T>; ind,fill_len: CommandQueue<integer>): CLArray<T>;
    
    public function FillNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>): CLArray<T>;
    
    public function FillNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>; ind,fill_len: CommandQueue<integer>): CLArray<T>;
    
    public function FillNativeMemory(native_data: CommandQueue<NativeMemory>): CLArray<T>;
    
    public function FillNativeMemory(native_data: CommandQueue<NativeMemory>; ind,fill_len: CommandQueue<integer>): CLArray<T>;
    
    public function FillNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>): CLArray<T>;
    
    public function FillNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>; ind,fill_len: CommandQueue<integer>): CLArray<T>;
    
    ///Заполняет весь массив копиями указанного значения
    public function FillNativeValue(native_data: CommandQueue<NativeValue<&T>>): CLArray<T>;
    
    ///Заполняет len элементов начиная с индекса ind копиями указанного значения
    public function FillNativeValue(native_data: CommandQueue<NativeValue<&T>>; ind,fill_len: CommandQueue<integer>): CLArray<T>;
    
    public function FillNativeArrayArea(native_data: CommandQueue<NativeArrayArea<&T>>): CLArray<T>;
    
    public function FillNativeArrayArea(native_data: CommandQueue<NativeArrayArea<&T>>; ind,fill_len: CommandQueue<integer>): CLArray<T>;
    
    ///Заполняет данный массив OpenCL копиями указанного массива RAM
    public function FillNativeArray(native_data: CommandQueue<NativeArray<&T>>): CLArray<T>;
    
    public function FillNativeArray(native_data: CommandQueue<NativeArray<&T>>; ind,fill_len: CommandQueue<integer>): CLArray<T>;
    
    {$endregion 2#Fill}
    
    {$region 3#Copy}
    
    ///Копирует элементы из данного массива в mem
    ///Копируется максимальное кол-во байт, не выходящее за границы данного массива и mem
    public function CopyTo(mem: CommandQueue<CLMemory>): CLArray<T>;
    
    ///Копирует элементы из данного массива в mem
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///ind указывает индекс первого элемента данного массива
    ///len указывает кол-во копируемых элементов
    public function CopyTo(mem: CommandQueue<CLMemory>; mem_offset, ind, len: CommandQueue<integer>): CLArray<T>;
    
    ///Копирует элементы из mem в данный массив
    ///Копируется максимальное кол-во байт, не выходящее за границы данного массива и mem
    public function CopyFrom(mem: CommandQueue<CLMemory>): CLArray<T>;
    
    ///Копирует элементы из mem в данный массив
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///ind указывает индекс первого элемента данного массива
    ///len указывает кол-во копируемых элементов
    public function CopyFrom(mem: CommandQueue<CLMemory>; mem_offset, ind, len: CommandQueue<integer>): CLArray<T>;
    
    ///Копирует элемент с индексом ind из данного массива в val
    public function CopyTo(val: CommandQueue<CLValue<&T>>; ind: CommandQueue<integer>): CLArray<T>;
    
    ///Копирует val в элемент данного массива с индексом ind
    public function CopyFrom(val: CommandQueue<CLValue<&T>>; ind: CommandQueue<integer>): CLArray<T>;
    
    ///Копирует элементы из данного массива в a
    ///Если у массивов разный размер - копируется кол-во элементов меньшего массива
    public function CopyTo(a: CommandQueue<CLArray<&T>>): CLArray<T>;
    
    ///Копирует элементы из данного массива в a
    ///from_ind указывает индекс в массиве, из которого копируют
    ///to_ind указывает индекс в массиве, в который копируют
    ///len указывает кол-во копируемых элементов
    public function CopyTo(a: CommandQueue<CLArray<&T>>; from_ind, to_ind, len: CommandQueue<integer>): CLArray<T>;
    
    ///Копирует элементы из a в данный массив
    ///Если у массивов разный размер - копируется кол-во элементов меньшего массива
    public function CopyFrom(a: CommandQueue<CLArray<&T>>): CLArray<T>;
    
    ///Копирует элементы из a в данный массив
    ///from_ind указывает индекс в массиве, из которого копируют
    ///to_ind указывает индекс в массиве, в который копируют
    ///len указывает кол-во копируемых элементов
    public function CopyFrom(a: CommandQueue<CLArray<&T>>; from_ind, to_ind, len: CommandQueue<integer>): CLArray<T>;
    
    {$endregion 3#Copy}
    
    {$region Get}
    
    ///Читает элемент по указанному индексу
    public function GetValue(ind: CommandQueue<integer>): &T;
    
    ///Читает весь данный массив OpenCL как массив RAM
    public function GetArray: array of &T;
    
    ///Создаёт массив RAM с указанным кол-вом элементов и копирует в него данные из начала данного массива OpenCL
    public function GetArray(len: CommandQueue<integer>): array of &T;
    
    ///Создаёт массив RAM с указанным кол-вом элементов и копирует в него данные из начала данного массива OpenCL
    public function GetArray2(len1,len2: CommandQueue<integer>): array[,] of &T;
    
    ///Создаёт массив RAM с указанным кол-вом элементов и копирует в него данные из начала данного массива OpenCL
    public function GetArray3(len1,len2,len3: CommandQueue<integer>): array[,,] of &T;
    
    {$endregion Get}
    
  end;
  
  {$endregion CLArray}
  
  {$endregion CLMemory}
  
  {$region Common}
  
  CLPlatform = partial class
    
    public property Native: cl_platform_id read ntv;
    
    private prop: CLPlatformProperties;
    private function GetProperties: CLPlatformProperties;
    begin
      if prop=nil then prop := new CLPlatformProperties(ntv);
      Result := prop;
    end;
    public property Properties: CLPlatformProperties read GetProperties;
    
    public static function operator=(wr1, wr2: CLPlatform): boolean :=
    ReferenceEquals(wr1,wr2) or not ReferenceEquals(wr1,nil) and not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    public static function operator<>(wr1, wr2: CLPlatform): boolean := false=
    ReferenceEquals(wr1,wr2) or not ReferenceEquals(wr1,nil) and not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    
    public function Equals(obj: object): boolean; override :=
    (obj is CLPlatform(var wr)) and (self = wr);
    
    public function GetHashCode: integer; override :=
    ntv.val.GetHashCode;
    
    public function ToString: string; override :=
    $'{TypeName(self)}[{ntv.val}]';
    
  end;
  
  CLDevice = partial class
    
    public property Native: cl_device_id read ntv;
    
    private prop: CLDeviceProperties;
    private function GetProperties: CLDeviceProperties;
    begin
      if prop=nil then prop := new CLDeviceProperties(ntv);
      Result := prop;
    end;
    public property Properties: CLDeviceProperties read GetProperties;
    
    public static function operator=(wr1, wr2: CLDevice): boolean :=
    ReferenceEquals(wr1,wr2) or not ReferenceEquals(wr1,nil) and not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    public static function operator<>(wr1, wr2: CLDevice): boolean := false=
    ReferenceEquals(wr1,wr2) or not ReferenceEquals(wr1,nil) and not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    
    public function Equals(obj: object): boolean; override :=
    (obj is CLDevice(var wr)) and (self = wr);
    
    public function GetHashCode: integer; override :=
    ntv.val.GetHashCode;
    
    public function ToString: string; override :=
    $'{TypeName(self)}[{ntv.val}]';
    
  end;
  
  CLSubDevice = partial class(CLDevice)
    
    private prop: CLSubDeviceProperties;
    private function GetProperties: CLSubDeviceProperties;
    begin
      if prop=nil then prop := new CLSubDeviceProperties(ntv);
      Result := prop;
    end;
    public property Properties: CLSubDeviceProperties read GetProperties;
    
    public function ToString: string; override :=
    $'{inherited ToString} of {Parent}';
    
  end;
  
  CLContext = partial class
    
    public property Native: cl_context read ntv;
    
    private prop: CLContextProperties;
    private function GetProperties: CLContextProperties;
    begin
      if prop=nil then prop := new CLContextProperties(ntv);
      Result := prop;
    end;
    public property Properties: CLContextProperties read GetProperties;
    
    public static function operator=(wr1, wr2: CLContext): boolean :=
    ReferenceEquals(wr1,wr2) or not ReferenceEquals(wr1,nil) and not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    public static function operator<>(wr1, wr2: CLContext): boolean := false=
    ReferenceEquals(wr1,wr2) or not ReferenceEquals(wr1,nil) and not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    
    public function Equals(obj: object): boolean; override :=
    (obj is CLContext(var wr)) and (self = wr);
    
    public function GetHashCode: integer; override :=
    ntv.val.GetHashCode;
    
    public function ToString: string; override :=
    $'{TypeName(self)}[{ntv.val}] on devices: {AllDevices.JoinToString('', '')}; Main device: {MainDevice}';
    
  end;
  
  CLCode = abstract partial class
    
    public property Native: cl_program read ntv;
    
    public static function operator=(wr1, wr2: CLCode): boolean :=
    ReferenceEquals(wr1,wr2) or not ReferenceEquals(wr1,nil) and not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    public static function operator<>(wr1, wr2: CLCode): boolean := false=
    ReferenceEquals(wr1,wr2) or not ReferenceEquals(wr1,nil) and not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    
    public function Equals(obj: object): boolean; override :=
    (obj is CLCode(var wr)) and (self = wr);
    
    public function GetHashCode: integer; override :=
    ntv.val.GetHashCode;
    
    public function ToString: string; override :=
    $'{TypeName(self)}[{ntv.val}]';
    
  end;
  
  CLKernel = partial class
    
    public static function operator=(wr1, wr2: CLKernel): boolean :=
    ReferenceEquals(wr1,wr2) or not ReferenceEquals(wr1,nil) and not ReferenceEquals(wr2,nil) and (wr1.Name=wr2.Name) and (wr1.CodeContainer=wr2.CodeContainer);
    public static function operator<>(wr1, wr2: CLKernel): boolean := false=
    ReferenceEquals(wr1,wr2) or not ReferenceEquals(wr1,nil) and not ReferenceEquals(wr2,nil) and (wr1.Name=wr2.Name) and (wr1.CodeContainer=wr2.CodeContainer);
    
    public function Equals(obj: object): boolean; override :=
    (obj is CLKernel(var wr)) and (self = wr);
    
    public function GetHashCode: integer; override :=
    Name.GetHashCode xor CodeContainer.GetHashCode;
    
    public function ToString: string; override :=
    $'{TypeName(self)}[{Name}] from {CodeContainer}';
    
  end;
  
  ///Представляет область памяти устройства OpenCL (обычно GPU)
  CLMemory = partial class(ICLMemory)
    
    ///Возвращает имя (дескриптор) неуправляемого объекта
    public property Native: cl_mem read ntv;
    
    private prop: CLMemoryProperties;
    private function GetProperties: CLMemoryProperties;
    begin
      if prop=nil then prop := new CLMemoryProperties(ntv);
      Result := prop;
    end;
    ///Возвращает контейнер свойств неуправляемого объекта
    public property Properties: CLMemoryProperties read GetProperties;
    
    public static function operator=(wr1, wr2: CLMemory): boolean :=
    ReferenceEquals(wr1,wr2) or not ReferenceEquals(wr1,nil) and not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    public static function operator<>(wr1, wr2: CLMemory): boolean := false=
    ReferenceEquals(wr1,wr2) or not ReferenceEquals(wr1,nil) and not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    
    ///--
    public function Equals(obj: object): boolean; override :=
    (obj is CLMemory(var wr)) and (self = wr);
    
    public function GetHashCode: integer; override :=
    ntv.val.GetHashCode;
    
    ///Возвращает строку с основными данными о данном объекте
    public function ToString: string; override :=
    $'{TypeName(self)}[{ntv.val}] of size {Size}';
    
  end;
  
  ///Представляет виртуальную область памяти, выделенную внутри CLMemory
  CLMemorySubSegment = partial class(CLMemory)
    
    private prop: CLMemorySubSegmentProperties;
    private function GetProperties: CLMemorySubSegmentProperties;
    begin
      if prop=nil then prop := new CLMemorySubSegmentProperties(ntv);
      Result := prop;
    end;
    ///Возвращает контейнер свойств неуправляемого объекта
    public property Properties: CLMemorySubSegmentProperties read GetProperties;
    
    ///Возвращает строку с основными данными о данном объекте
    public function ToString: string; override :=
    $'{inherited ToString} inside {Parent}';
    
  end;
  
  ///Представляет запись, значение которой хранится на устройстве OpenCL (обычно GPU)
  CLValue<T> = partial class(ICLMemory)
    
    ///Возвращает имя (дескриптор) неуправляемого объекта
    public property Native: cl_mem read ntv;
    
    private prop: CLValueProperties;
    private function GetProperties: CLValueProperties;
    begin
      if prop=nil then prop := new CLValueProperties(ntv);
      Result := prop;
    end;
    ///Возвращает контейнер свойств неуправляемого объекта
    public property Properties: CLValueProperties read GetProperties;
    
    public static function operator=(wr1, wr2: CLValue<T>): boolean :=
    ReferenceEquals(wr1,wr2) or not ReferenceEquals(wr1,nil) and not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    public static function operator<>(wr1, wr2: CLValue<T>): boolean := false=
    ReferenceEquals(wr1,wr2) or not ReferenceEquals(wr1,nil) and not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    
    ///--
    public function Equals(obj: object): boolean; override :=
    (obj is CLValue<T>(var wr)) and (self = wr);
    
    public function GetHashCode: integer; override :=
    ntv.val.GetHashCode;
    
    ///Возвращает строку с основными данными о данном объекте
    public function ToString: string; override :=
    $'{TypeName(self)}[{ntv.val}]';
    
  end;
  
  ///Представляет массив записей, содержимое которого хранится на устройстве OpenCL (обычно GPU)
  CLArray<T> = partial class(ICLMemory)
    
    ///Возвращает имя (дескриптор) неуправляемого объекта
    public property Native: cl_mem read ntv;
    
    private prop: CLArrayProperties;
    private function GetProperties: CLArrayProperties;
    begin
      if prop=nil then prop := new CLArrayProperties(ntv);
      Result := prop;
    end;
    ///Возвращает контейнер свойств неуправляемого объекта
    public property Properties: CLArrayProperties read GetProperties;
    
    public static function operator=(wr1, wr2: CLArray<T>): boolean :=
    ReferenceEquals(wr1,wr2) or not ReferenceEquals(wr1,nil) and not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    public static function operator<>(wr1, wr2: CLArray<T>): boolean := false=
    ReferenceEquals(wr1,wr2) or not ReferenceEquals(wr1,nil) and not ReferenceEquals(wr2,nil) and (wr1.ntv = wr2.ntv);
    
    ///--
    public function Equals(obj: object): boolean; override :=
    (obj is CLArray<T>(var wr)) and (self = wr);
    
    public function GetHashCode: integer; override :=
    ntv.val.GetHashCode;
    
    ///Возвращает строку с основными данными о данном объекте
    public function ToString: string; override :=
    $'{TypeName(self)}[{ntv.val}] of length {Length}';
    
  end;
  
  {$endregion Common}
  
  {$region Misc}
  
  CLDevice = partial class
    
    private supported_split_modes: array of clDevicePartitionProperty := nil;
    private function GetSSM: array of clDevicePartitionProperty;
    begin
      if supported_split_modes=nil then
      begin
        supported_split_modes := Properties.PartitionProperties;
        if supported_split_modes.Last = new clDevicePartitionProperty(0) then
          supported_split_modes := supported_split_modes[:^1];
      end;
      Result := supported_split_modes;
    end;
    
    private function Split(params props: array of clDevicePartitionProperty): array of CLSubDevice;
    begin
      if props[0] not in GetSSM then
        raise new NotSupportedException($'%Err:CLDevice:SplitNotSupported%');
      
      var c: UInt32;
      OpenCLABCInternalException.RaiseIfError( cl.CreateSubDevices(self.ntv, props, 0, IntPtr.Zero, c) );
      
      var res := new cl_device_id[c];
      OpenCLABCInternalException.RaiseIfError( cl.CreateSubDevices(self.ntv, props, c, res[0], IntPtr.Zero) );
      
      Result := res.ConvertAll(sdvc->new CLSubDevice(self.ntv, sdvc));
    end;
    
    public property CanSplitEqually: boolean read clDevicePartitionProperty.DEVICE_PARTITION_EQUALLY in GetSSM;
    public function SplitEqually(CUCount: integer): array of CLSubDevice;
    begin
      if CUCount <= 0 then raise new ArgumentException($'%Err:CLDevice:SplitCUCount%');
      Result := Split(
        clDevicePartitionProperty.DEVICE_PARTITION_EQUALLY,
        clDevicePartitionProperty.Create(CUCount),
        clDevicePartitionProperty.Create(0)
      );
    end;
    
    public property CanSplitByCounts: boolean read clDevicePartitionProperty.DEVICE_PARTITION_BY_COUNTS in GetSSM;
    public function SplitByCounts(params CUCounts: array of integer): array of CLSubDevice;
    begin
      foreach var CUCount in CUCounts do
        if CUCount <= 0 then raise new ArgumentException($'%Err:CLDevice:SplitCUCount%');
      
      var props := new clDevicePartitionProperty[CUCounts.Length+3];
      props[0] := clDevicePartitionProperty.DEVICE_PARTITION_BY_COUNTS;
      for var i := 0 to CUCounts.Length-1 do
        props[i+1] := new clDevicePartitionProperty(CUCounts[i]);
      props[props.Length-2] := clDevicePartitionProperty.DEVICE_PARTITION_BY_COUNTS_LIST_END;
      props[props.Length-1] := clDevicePartitionProperty.Create(0);
      
      Result := Split(props);
    end;
    
    public property CanSplitByAffinityDomain: boolean read clDevicePartitionProperty.DEVICE_PARTITION_BY_AFFINITY_DOMAIN in GetSSM;
    public function SplitByAffinityDomain(affinity_domain: clDeviceAffinityDomain) :=
      Split(
        clDevicePartitionProperty.DEVICE_PARTITION_BY_AFFINITY_DOMAIN,
        clDevicePartitionProperty.Create(affinity_domain.val),
        clDevicePartitionProperty.Create(0)
      );
    
    public property CanSplitByNames: boolean read clDevicePartitionProperty.DEVICE_PARTITION_BY_NAMES in GetSSM;
    public function SplitByNames(params device_names: array of uint64): array of CLSubDevice;
    begin
      foreach var device_name in device_names do
        if device_name < 0 then raise new ArgumentException($'%Err:CLDevice:SplitNames%');
      
      var props := new clDevicePartitionProperty[device_names.Length+3];
      props[0] := clDevicePartitionProperty.DEVICE_PARTITION_BY_NAMES;
      for var i := 0 to device_names.Length-1 do
        props[i+1] := new clDevicePartitionProperty(device_names[i]);
      props[props.Length-2] := clDevicePartitionProperty.PARTITION_BY_NAMES_LIST_END;
      props[props.Length-1] := clDevicePartitionProperty.Create(0);
      
      Result := Split(props);
    end;
    
  end;
  
  {$endregion Misc}
  
  {$endregion Wrappers}
  
  {$region CommandQueue}
  
  {$region ToString}
  
  ///Представляет очередь команд, в основном выполняемых на GPU
  CommandQueueBase = abstract partial class
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); abstract;
    
    private static function GetValueRuntimeType<T>(val: T) :=
    if typeof(T).IsValueType then
      typeof(T) else
    if val = default(T) then
      nil else val.GetType;
    private static procedure ToStringRuntimeValue<T>(sb: StringBuilder; val: T);
    begin
      var rt := GetValueRuntimeType(val);
      if typeof(T) <> rt then
      begin
        if rt<>nil then sb.Append(TypeToTypeName(rt));
        sb += '{ ';
      end;
      sb += _ObjectToString(val);
      if typeof(T) <> rt then
        sb += ' }';
    end;
    
    private function ToStringHeader(sb: StringBuilder; index: Dictionary<object,integer>): boolean;
    begin
      sb += TypeName(self);
      
      var ind: integer;
      Result := not index.TryGetValue(self, ind);
      
      if Result then
      begin
        ind := index.Count;
        index[self] := ind;
      end;
      
      sb += '#';
      sb.Append(ind);
      
    end;
    private static procedure ToStringWriteDelegate(sb: StringBuilder; d: System.Delegate);
    const lambda='lambda';
    const sugar_begin='<>';
    const par_separator='; ';
    begin
      if d.Target<>nil then
      begin
        sb += _ObjectToString(d.Target);
        sb += ' => ';
      end;
      var mi := d.Method;
      var rt := mi.ReturnType;
      if rt=typeof(Void) then rt := nil;
      
      sb += if rt=nil then 'procedure' else 'function';
      sb += ' ';
      begin
        var name := mi.Name;
        if name.StartsWith(sugar_begin) then
          name := if lambda in name then
            lambda else name.Substring(sugar_begin.Length);
        sb += name;
      end;
      
      var pars := mi.GetParameters;
      if pars.Length<>0 then
      begin
        sb += '(';
        foreach var par in pars do
        begin
          var name := par.Name;
          if name.StartsWith(sugar_begin) then
            name := name.Substring(sugar_begin.Length);
          sb += name;
          sb += ': ';
          sb += TypeToTypeName(par.ParameterType);
          sb += par_separator;
        end;
        sb.Length -= par_separator.Length;
        sb += ')';
      end;
      
      if rt<>nil then
      begin
        sb += ': ';
        sb += TypeToTypeName(rt);
      end;
      
    end;
    private procedure ToString(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>; write_tabs: boolean := true);
    begin
      delayed.Remove(self);
      
      if write_tabs then sb.Append(#9, tabs);
      ToStringHeader(sb, index);
      ToStringImpl(sb, tabs+1, index, delayed);
      
      if tabs=0 then foreach var q in delayed do
      begin
        sb += #10;
        q.ToString(sb, 0, index, new HashSet<CommandQueueBase>);
      end;
      
    end;
    
    ///Возвращает строковое представление данного объекта
    ///Используйте это значение только для отладки, потому что данный метод не оптимизирован
    public function ToString: string; override;
    begin
      var sb := new StringBuilder;
      ToString(sb, 0, new Dictionary<object, integer>, new HashSet<CommandQueueBase>);
      Result := sb.ToString;
    end;
    
    ///Вызывает Write(ToString) для данного объекта и возвращает его же
    public function Print: CommandQueueBase;
    begin
      Write(self.ToString);
      Result := self;
    end;
    ///Вызывает Writeln(ToString) для данного объекта и возвращает его же
    public function Println: CommandQueueBase;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  ///Представляет очередь команд, в основном выполняемых на GPU
  ///Такая очередь всегда возвращает nil
  CommandQueueNil = abstract partial class(CommandQueueBase)
    
    ///Вызывает Write(ToString) для данного объекта и возвращает его же
    public function Print: CommandQueueNil;
    begin
      inherited Print;
      Result := self;
    end;
    ///Вызывает Writeln(ToString) для данного объекта и возвращает его же
    public function Println: CommandQueueNil;
    begin
      inherited Println;
      Result := self;
    end;
    
  end;
  ///Представляет очередь команд, в основном выполняемых на GPU
  ///Такая очередь всегда возвращает значение типа T
  CommandQueue<T> = abstract partial class(CommandQueueBase)
    
    ///Вызывает Write(ToString) для данного объекта и возвращает его же
    public function Print: CommandQueue<T>;
    begin
      inherited Print;
      Result := self;
    end;
    ///Вызывает Writeln(ToString) для данного объекта и возвращает его же
    public function Println: CommandQueue<T>;
    begin
      inherited Println;
      Result := self;
    end;
    
  end;
  
  {$endregion ToString}
  
  {$region Use/Convert Typed}
  
  ///Представляет интерфейс типа, содержащего отдельные алгоритмы обработки, очереди без- и с возвращаемым значением
  ITypedCQUser = interface
    
    ///Вызывается если у очереди нет возвращаемого значения
    procedure UseNil(cq: CommandQueueNil);
    ///Вызывается если у очереди есть возвращаемое значение
    procedure Use<T>(cq: CommandQueue<T>);
    
  end;
  ///Представляет интерфейс типа, содержащего отдельные алгоритмы обработки, очереди без- и с возвращаемым значением
  ITypedCQConverter<TRes> = interface
    
    ///Вызывается если у очереди нет возвращаемого значения
    function ConvertNil(cq: CommandQueueNil): TRes;
    ///Вызывается если у очереди есть возвращаемое значение
    function Convert<T>(cq: CommandQueue<T>): TRes;
    
  end;
  
  ///Представляет очередь команд, в основном выполняемых на GPU
  CommandQueueBase = abstract partial class
    
    ///Проверяет, какой тип результата у данной очереди
    ///Передаёт результат указанному объекту
    public procedure UseTyped(user: ITypedCQUser); abstract;
    ///Проверяет, какой тип результата у данной очереди
    ///Передаёт результат указанному объекту
    public function ConvertTyped<TRes>(converter: ITypedCQConverter<TRes>): TRes; abstract;
    
  end;
  
  ///Представляет очередь команд, в основном выполняемых на GPU
  ///Такая очередь всегда возвращает nil
  CommandQueueNil = abstract partial class(CommandQueueBase)
    
    ///--
    public procedure UseTyped(user: ITypedCQUser); override := user.UseNil(self);
    ///--
    public function ConvertTyped<TRes>(converter: ITypedCQConverter<TRes>): TRes; override := converter.ConvertNil(self);
    
  end;
  ///Представляет очередь команд, в основном выполняемых на GPU
  ///Такая очередь всегда возвращает значение типа T
  CommandQueue<T> = abstract partial class(CommandQueueBase)
    
    ///--
    public procedure UseTyped(user: ITypedCQUser); override := user.Use(self);
    ///--
    public function ConvertTyped<TRes>(converter: ITypedCQConverter<TRes>): TRes; override := converter.Convert(self);
    
  end;
  
  {$endregion Use/Convert Typed}
  
  {$region Const}
  
  ConstQueueNil = sealed partial class(CommandQueueNil)
    
    private constructor := raise new OpenCLABCInternalException;
    private constructor(b: byte) := exit;
    
    private static _instance := new ConstQueueNil(0);
    public static property Instance: ConstQueueNil read _instance;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override := sb += #10;
    
  end;
  
  ///Представляет очередь команд, в основном выполняемых на GPU
  ///Такая очередь всегда возвращает значение типа T
  CommandQueue<T> = abstract partial class(CommandQueueBase)
    private expected_const_res: T;
    private const_res_dep: array of CommandQueueBase := nil;
    
    private static function empty_dep := System.Array.Empty&<CommandQueueBase>;
    private function IsConstResDepEmpty: boolean;
    begin
      Result := self.const_res_dep = empty_dep;
      {$ifdef DEBUG}
      var robust_res := (const_res_dep<>nil) and (const_res_dep.Length=0);
      if Result <> robust_res then
        raise new OpenCLABCInternalException($'');
      {$endif DEBUG}
    end;
    
    // Empty ctor also allowed
    protected constructor(res: T; dep: array of CommandQueueBase);
    begin
      self.expected_const_res := res;
      self.const_res_dep := dep;
    end;
    
  end;
  ///Представляет константную очередь
  ///Константные очереди ничего не выполняют и возвращают заданное при создании значение
  ConstQueue<T> = sealed partial class(CommandQueue<T>)
    
    ///Создаёт новую константную очередь, возвращающую указанное значения
    public constructor(o: T) := inherited Create(o, empty_dep);
    private constructor := raise new OpenCLABCInternalException;
    
    ///Значение, которого возвращает данная константная очередь
    public property Value: T read self.expected_const_res;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += ': ';
      ToStringRuntimeValue(sb, self.expected_const_res);
      sb += #10;
    end;
    
  end;
  
  ///Представляет очередь команд, в основном выполняемых на GPU
  ///Такая очередь всегда возвращает nil
  CommandQueueNil = abstract partial class(CommandQueueBase) end;
  ///Представляет очередь команд, в основном выполняемых на GPU
  ///Такая очередь всегда возвращает значение типа T
  CommandQueue<T> = abstract partial class(CommandQueueBase)
    
    public static function operator implicit(o: T): CommandQueue<T> :=
    new ConstQueue<T>(o);
    
  end;
  
  {$endregion Const}
  
  {$region Parameter}
  
  ///Представляет установщик очереди-параметра ParameterQueue<T>, созданный методом .NewSetter
  ///Если передать этот установщик в метод запуска очереди,
  ///при выполнении параметр будет иметь указанное значение
  ParameterQueueSetter = sealed partial class
    private val: object;
    
    private constructor := raise new OpenCLABCInternalException;
    
  end;
  ///Представляет очередь-параметр
  ///Очереди-параметры ничего не выполняют, но возвращает установленное при запуске очереди значение
  ParameterQueue<T> = sealed partial class(CommandQueue<T>)
    private _name: string;
    
    ///Создаёт новую очередь-параметр
    ///name указывает имя параметра
    public constructor(name: string);
    begin
      self._name := name;
    end;
    ///Создаёт новую очередь-параметр
    ///name указывает имя параметра
    ///Указанное значение будет использоваться если при запуске очереди значение параметра небыло установлено
    public constructor(name: string; def: T);
    begin
      inherited Create(def, new CommandQueueBase[](self));
      self.name := name;
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    ///Имя параметра
    public property Name: string read _name write _name;
    ///Указывает, установлено ли значение, которое будет использоваться если при запуске очереди значение параметра небыло установлено
    public property DefaultDefined: boolean read const_res_dep<>nil;
    
    private function GetDefault: T;
    begin
      if not DefaultDefined then
        raise new InvalidOperationException($'Значение параметра {name} небыло установлено');
      Result := self.expected_const_res;
    end;
    ///Значение, которое будет использоваться если при запуске очереди значение параметра небыло установлено
    public property &Default: T read GetDefault;
    
    ///Создаёт установщик данного параметра
    ///Если передать этот установщик в метод запуска очереди,
    ///при выполнении параметр будет иметь указанное значение
    public function NewSetter(val: T): ParameterQueueSetter;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += '["';
      sb += Name;
      sb += '"]';
      if DefaultDefined then
      begin
        sb += ': Default=';
        ToStringRuntimeValue(sb, self.Default);
      end;
      sb += #10;
    end;
    
  end;
  
  {$endregion Parameter}
  
  {$region Cast}
  
  ///Представляет очередь команд, в основном выполняемых на GPU
  CommandQueueBase = abstract partial class
    
    ///Если данная очередь проходит по условию "... is CommandQueue<T>" - возвращает себя же
    ///Иначе возвращает очередь-обёртку, выполняющую "res := T(res)", где res - результат данной очереди
    public function Cast<T>: CommandQueue<T>;
    
  end;
  
  ///Представляет очередь команд, в основном выполняемых на GPU
  ///Такая очередь всегда возвращает nil
  CommandQueueNil = abstract partial class(CommandQueueBase)
    
    ///Создаёт константную очередь, выполняющую данную и возвращающую T(nil)
    ///Для этого T должен быть ссылочным
    public function Cast<T>: CommandQueue<T>; where T: class;
    
  end;
  
  ///Представляет очередь команд, в основном выполняемых на GPU
  ///Такая очередь всегда возвращает значение типа T
  CommandQueue<T> = abstract partial class(CommandQueueBase) end;
  
  {$endregion Cast}
  
  {$region DiscardResult}
  
  ///Представляет очередь команд, в основном выполняемых на GPU
  CommandQueueBase = abstract partial class
    
    private function DiscardResultBase: CommandQueueNil; abstract;
    ///Возвращает данную очередь но без результата
    public function DiscardResult := DiscardResultBase;
    
  end;
  
  ///Представляет очередь команд, в основном выполняемых на GPU
  ///Такая очередь всегда возвращает nil
  CommandQueueNil = abstract partial class(CommandQueueBase)
    
    private function DiscardResultBase: CommandQueueNil; override := DiscardResult;
    ///Возвращает данную очередь
    public function DiscardResult := self;
    
  end;
  
  ///Представляет очередь команд, в основном выполняемых на GPU
  ///Такая очередь всегда возвращает значение типа T
  CommandQueue<T> = abstract partial class(CommandQueueBase)
    
    private function DiscardResultBase: CommandQueueNil; override := DiscardResult;
    ///Возвращает данную очередь но без результата
    public function DiscardResult: CommandQueueNil;
    
  end;
  
  {$endregion DiscardResult}
  
  {$region Then[Convert,Use]}
  
  ///Представляет очередь команд, в основном выполняемых на GPU
  CommandQueueBase = abstract partial class end;
  
  ///Представляет очередь команд, в основном выполняемых на GPU
  ///Такая очередь всегда возвращает nil
  CommandQueueNil = abstract partial class(CommandQueueBase) end;
  ///Представляет очередь команд, в основном выполняемых на GPU
  ///Такая очередь всегда возвращает значение типа T
  CommandQueue<T> = abstract partial class(CommandQueueBase)
    
    {$region Convert}
    
    public function ThenConvert<TOtp>(f: T->TOtp             ; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<TOtp>;
    public function ThenConvert<TOtp>(f: (T, CLContext)->TOtp; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<TOtp>;
    
    {$endregion Convert}
    
    {$region Use}
    
    public function ThenUse(p: T->()             ; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<T>;
    public function ThenUse(p: (T, CLContext)->(); need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<T>;
    
    {$endregion Use}
    
  end;
  
  {$endregion Then[Convert,Use]}
  
  {$region Multiusable}
  
  ///Представляет очередь команд, в основном выполняемых на GPU
  CommandQueueBase = abstract partial class
    
    private function MultiusableBase: CommandQueueBase; abstract;
    ///Создаёт функцию, вызывая которую можно создать любое кол-во очередей-удлинителей для данной очереди
    ///Подробнее в справке: "Очередь>>Создание очередей>>Множественное использование очереди"
    public function Multiusable := MultiusableBase;
    
  end;
  
  ///Представляет очередь команд, в основном выполняемых на GPU
  ///Такая очередь всегда возвращает nil
  CommandQueueNil = abstract partial class(CommandQueueBase)
    
    private function MultiusableBase: CommandQueueBase; override := Multiusable;
    ///Создаёт функцию, вызывая которую можно создать любое кол-во очередей-удлинителей для данной очереди
    ///Подробнее в справке: "Очередь>>Создание очередей>>Множественное использование очереди"
    public function Multiusable: CommandQueueNil;
    
  end;
  ///Представляет очередь команд, в основном выполняемых на GPU
  ///Такая очередь всегда возвращает значение типа T
  CommandQueue<T> = abstract partial class(CommandQueueBase)
    
    private function MultiusableBase: CommandQueueBase; override := Multiusable;
    ///Создаёт функцию, вызывая которую можно создать любое кол-во очередей-удлинителей для данной очереди
    ///Подробнее в справке: "Очередь>>Создание очередей>>Множественное использование очереди"
    public function Multiusable: CommandQueue<T>;
    
  end;
  
  {$endregion Multiusable}
  
  {$region Finally+Handle}
  
  ///Представляет очередь команд, в основном выполняемых на GPU
  CommandQueueBase = abstract partial class
    
    private function ConvertErrHandler<TException>(handler: TException->boolean): Exception->boolean; where TException: Exception;
    begin Result := e->(e is TException) and handler(TException(e)) end;
    
    ///Создаёт очередь, сначала выполняющую данную, а затем обрабатывающую кинутые в ней исключения
    ///Созданная очередь возвращает nil не зависимо от исключений при выполнении данной очереди
    public function HandleWithoutRes<TException>(handler: TException->boolean): CommandQueueNil; where TException: Exception;
    begin Result := HandleWithoutRes(ConvertErrHandler(handler)) end;
    ///Создаёт очередь, сначала выполняющую данную, а затем обрабатывающую кинутые в ней исключения
    ///Созданная очередь возвращает nil не зависимо от исключений при выполнении данной очереди
    public function HandleWithoutRes(handler: Exception->boolean): CommandQueueNil;
    
  end;
  
  ///Представляет очередь команд, в основном выполняемых на GPU
  ///Такая очередь всегда возвращает nil
  CommandQueueNil = abstract partial class(CommandQueueBase)
    
  end;
  ///Представляет очередь команд, в основном выполняемых на GPU
  ///Такая очередь всегда возвращает значение типа T
  CommandQueue<T> = abstract partial class(CommandQueueBase)
    
    ///Создаёт очередь, сначала выполняющую данную, а затем обрабатывающую кинутые в ней исключения
    ///В конце выполнения созданная очередь возвращает то, что вернула данная, если исключений небыло и указанное значение если обработчик был успешно выполнен
    public function HandleDefaultRes<TException>(handler: TException->boolean; def: T): CommandQueue<T>; where TException: Exception;
    begin Result := HandleDefaultRes(ConvertErrHandler(handler), def) end;
    ///Создаёт очередь, сначала выполняющую данную, а затем обрабатывающую кинутые в ней исключения
    ///В конце выполнения созданная очередь возвращает то, что вернула данная, если исключений небыло и указанное значение если обработчик был успешно выполнен
    public function HandleDefaultRes(handler: Exception->boolean; def: T): CommandQueue<T>;
    
    ///Создаёт очередь, сначала выполняющую данную, а затем обрабатывающую кинутые в ней исключения
    ///Для того чтоб пометить исключение обработанным - его надо удалить из полученного списка
    ///Возвращаемое значение обработчика указывает на что надо заменить возвращаемое значение данной очереди, если обработчик был успешно выполнен
    public function HandleReplaceRes(handler: List<Exception> -> T): CommandQueue<T>;
    
  end;
  
  {$endregion Finally+Handle}
  
  {$region Wait}
  
  ///Представляет маркер для Wait очередей
  ///Данный тип не является очередью
  ///Но при выполнении преобразуется в очередь, выполняющую .SendSignal исходного маркера
  WaitMarker = abstract partial class
    
    ///Создаёт новый простой маркер
    public static function Create: WaitMarker;
    
    ///Посылает сигнал выполненности всем ожидающим Wait очередям
    public procedure SendSignal; abstract;
    
    public static function operator and(m1, m2: WaitMarker): WaitMarker;
    public static function operator or(m1, m2: WaitMarker): WaitMarker;
    
    private function ConvertToQBase: CommandQueueBase; abstract;
    public static function operator implicit(m: WaitMarker): CommandQueueBase := m.ConvertToQBase;
    
    {$region ToString}
    
    private function ToStringHeader(sb: StringBuilder; index: Dictionary<object,integer>): boolean;
    begin
      sb += TypeName(self);
      
      var ind: integer;
      Result := not index.TryGetValue(self, ind);
      
      if Result then
      begin
        ind := index.Count;
        index[self] := ind;
      end;
      
      sb += '#';
      sb.Append(ind);
      
    end;
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); abstract;
    
    private procedure ToString(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>; write_tabs: boolean := true);
    begin
      if write_tabs then sb.Append(#9, tabs);
      ToStringHeader(sb, index);
      ToStringImpl(sb, tabs+1, index, delayed);
      
      if tabs=0 then foreach var q in delayed do
      begin
        sb += #10;
        q.ToString(sb, 0, index, new HashSet<CommandQueueBase>);
      end;
      
    end;
    
    ///Возвращает строковое представление данного объекта
    ///Используйте это значение только для отладки, потому что данный метод не оптимизирован
    public function ToString: string; override;
    begin
      var sb := new StringBuilder;
      ToString(sb, 0, new Dictionary<object, integer>, new HashSet<CommandQueueBase>);
      Result := sb.ToString;
    end;
    
    ///Вызывает Write(ToString) для данного объекта и возвращает его же
    public function Print: WaitMarker;
    begin
      Write(self.ToString);
      Result := self;
    end;
    ///Вызывает Writeln(ToString) для данного объекта и возвращает его же
    public function Println: WaitMarker;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    {$endregion ToString}
    
  end;
  
  CommandQueueMarkedCapNil = sealed partial class
    
    private function get_signal_in_finally: boolean;
    public property SignalInFinally: boolean read get_signal_in_finally;
    
    public constructor(q: CommandQueueNil; signal_in_finally: boolean);
    private constructor := raise new OpenCLABCInternalException;
    
    public static function operator implicit(dms: CommandQueueMarkedCapNil): WaitMarker;
    
    public procedure SendSignal := WaitMarker(self).SendSignal;
    public static function operator and(m1, m2: CommandQueueMarkedCapNil) := WaitMarker(m1) and WaitMarker(m2);
    public static function operator or(m1, m2: CommandQueueMarkedCapNil) := WaitMarker(m1) or WaitMarker(m2);
    
  end;
  CommandQueueMarkedCap<T> = sealed partial class
    
    private function get_signal_in_finally: boolean;
    public property SignalInFinally: boolean read get_signal_in_finally;
    
    public constructor(q: CommandQueue<T>; signal_in_finally: boolean);
    private constructor := raise new OpenCLABCInternalException;
    
    public static function operator implicit(dms: CommandQueueMarkedCap<T>): WaitMarker;
    
    public procedure SendSignal := WaitMarker(self).SendSignal;
    public static function operator and(m1, m2: CommandQueueMarkedCap<T>) := WaitMarker(m1) and WaitMarker(m2);
    public static function operator or(m1, m2: CommandQueueMarkedCap<T>) := WaitMarker(m1) or WaitMarker(m2);
    
  end;
  
  ///Представляет очередь команд, в основном выполняемых на GPU
  CommandQueueBase = abstract partial class end;
  
  ///Представляет очередь команд, в основном выполняемых на GPU
  ///Такая очередь всегда возвращает nil
  CommandQueueNil = abstract partial class(CommandQueueBase)
    
    ///Создаёт очередь, сначала выполняющую данную, а затем вызывающую свой .SendSignal
    ///При передаче в Wait-очереди, полученная очередь превращается в маркер
    ///В конце выполнения созданная очередь возвращает то, что вернула данная
    public function ThenMarkerSignal := new CommandQueueMarkedCapNil(self, false);
    ///Создаёт очередь, сначала выполняющую данную, а затем вызывающую свой .SendSignal не зависимо от исключений при выполнении данной очереди
    ///При передаче в Wait-очереди, полученная очередь превращается в маркер
    ///В конце выполнения созданная очередь возвращает то, что вернула данная
    public function ThenFinallyMarkerSignal := new CommandQueueMarkedCapNil(self, true);
    
  end;
  ///Представляет очередь команд, в основном выполняемых на GPU
  ///Такая очередь всегда возвращает значение типа T
  CommandQueue<T> = abstract partial class(CommandQueueBase)
    
    ///Создаёт очередь, сначала выполняющую данную, а затем вызывающую свой .SendSignal
    ///При передаче в Wait-очереди, полученная очередь превращается в маркер
    ///В конце выполнения созданная очередь возвращает то, что вернула данная
    public function ThenMarkerSignal := new CommandQueueMarkedCap<T>(self, false);
    ///Создаёт очередь, сначала выполняющую данную, а затем вызывающую свой .SendSignal не зависимо от исключений при выполнении данной очереди
    ///При передаче в Wait-очереди, полученная очередь превращается в маркер
    ///В конце выполнения созданная очередь возвращает то, что вернула данная
    public function ThenFinallyMarkerSignal := new CommandQueueMarkedCap<T>(self, true);
    
    ///Создаёт очередь, сначала выполняющую данную, а затем ожидающую сигнала от указанного маркера
    ///В конце выполнения созданная очередь возвращает то, что вернула данная
    public function ThenWaitFor(marker: WaitMarker): CommandQueue<T>;
    ///Создаёт очередь, сначала выполняющую данную, а затем ожидающую сигнала от указанного маркера не зависимо от исключений при выполнении данной очереди
    ///В конце выполнения созданная очередь возвращает то, что вернула данная
    public function ThenFinallyWaitFor(marker: WaitMarker): CommandQueue<T>;
    
  end;
  
  {$endregion Wait}
  
  {$endregion CommandQueue}
  
  {$region CLTask}
  
  ///Представляет задачу выполнения очереди, создаваемую методом Context.BeginInvoke
  CLTaskBase = abstract partial class
    private org_c: CLContext;
    private wh := new ManualResetEvent(false);
    private err_lst: List<Exception>;
    
    private function OrgQueueBase: CommandQueueBase; abstract;
    ///Возвращает очередь, которую выполняет данный CLTask
    public property OrgQueue: CommandQueueBase read OrgQueueBase;
    
    public property OrgCLContext: CLContext read org_c;
    
    {$ifdef ErrHandlerDebug}
    private procedure OutputErrHandlers;
    {$endif ErrHandlerDebug}
    
    //TODO Дать пользователю это решать
    private static max_spin_wait := TimeSpan.FromMilliseconds(50);
    ///Ожидает окончания выполнения очереди (если оно ещё не завершилось)
    ///Кидает System.AggregateException, содержащие ошибки при выполнении очереди, если такие имеются
    public procedure Wait;
    begin
      var sw := Stopwatch.StartNew;
      while true do
      begin
        if wh.WaitOne(0) then break;
        if sw.Elapsed > max_spin_wait then break;
      end;
      wh.WaitOne;
      {$ifdef ErrHandlerDebug}
      self.OutputErrHandlers;
      {$endif ErrHandlerDebug}
      if err_lst.Count<>0 then
        raise new AggregateException($'При выполнении очереди было вызвано {err_lst.Count} исключений. Используйте try чтоб получить больше информации', err_lst.ToArray);
    end;
    
  end;
  
  ///Представляет задачу выполнения очереди, создаваемую методом Context.BeginInvoke
  CLTaskNil = sealed partial class(CLTaskBase)
    private q: CommandQueueNil;
    
    private constructor := raise new OpenCLABCInternalException;
    
    ///Возвращает очередь, которую выполняет данный CLTask
    public property OrgQueue: CommandQueueNil read q; reintroduce;
    private function OrgQueueBase: CommandQueueBase; override := self.OrgQueue;
    
  end;
  
  ///Представляет задачу выполнения очереди, создаваемую методом Context.BeginInvoke
  CLTask<T> = sealed partial class(CLTaskBase)
    private q: CommandQueue<T>;
    
    private constructor := raise new OpenCLABCInternalException;
    
    ///Возвращает очередь, которую выполняет данный CLTask
    public property OrgQueue: CommandQueue<T> read q; reintroduce;
    private function OrgQueueBase: CommandQueueBase; override := self.OrgQueue;
    
    ///Ожидает окончания выполнения очереди (если оно ещё не завершилось)
    ///Кидает System.AggregateException, содержащие ошибки при выполнении очереди, если такие имеются
    ///А затем возвращает результат выполнения
    public function WaitRes: T;
    
  end;
  
  CLContext = partial class
    
    public function BeginInvoke(q: CommandQueueBase; params parameters: array of ParameterQueueSetter): CLTaskBase;
    public function BeginInvoke(q: CommandQueueNil; params parameters: array of ParameterQueueSetter): CLTaskNil;
    public function BeginInvoke<T>(q: CommandQueue<T>; params parameters: array of ParameterQueueSetter): CLTask<T>;
    
    public procedure SyncInvoke(q: CommandQueueBase; params parameters: array of ParameterQueueSetter) := BeginInvoke(q, parameters).Wait;
    public procedure SyncInvoke(q: CommandQueueNil; params parameters: array of ParameterQueueSetter) := BeginInvoke(q, parameters).Wait;
    public function SyncInvoke<T>(q: CommandQueue<T>; params parameters: array of ParameterQueueSetter) := BeginInvoke(q, parameters).WaitRes;
    
  end;
  
  {$endregion CLTask}
  
  {$region CCQ's}
  
  {$region CLKernelCCQ}
  
  CLKernelCCQ = sealed partial class
    
    public constructor(q: CommandQueue<CLKernel>);
    private constructor;
    
    {$region Special .Add's}
    
    public function ThenQueue(q: CommandQueueBase): CLKernelCCQ;
    
    public function ThenProc(p: CLKernel->(); need_own_thread: boolean := true; can_pre_calc: boolean := false): CLKernelCCQ;
    public function ThenProc(p: (CLKernel, CLContext)->(); need_own_thread: boolean := true; can_pre_calc: boolean := false): CLKernelCCQ;
    
    public function ThenWait(marker: WaitMarker): CLKernelCCQ;
    
    {$endregion Special .Add's}
    
    {$region Exec}
    
    public function ThenExec1(sz1: CommandQueue<integer>; params args: array of CLKernelArg): CLKernelCCQ;
    
    public function ThenExec2(sz1,sz2: CommandQueue<integer>; params args: array of CLKernelArg): CLKernelCCQ;
    
    public function ThenExec3(sz1,sz2,sz3: CommandQueue<integer>; params args: array of CLKernelArg): CLKernelCCQ;
    
    public function ThenExec(global_work_offset, global_work_size, local_work_size: CommandQueue<array of UIntPtr>; params args: array of CLKernelArg): CLKernelCCQ;
    
    {$endregion Exec}
    
  end;
  
  CLKernel = partial class
    public function MakeCCQ := new CLKernelCCQ(self);
  end;
  
  {$endregion CLKernelCCQ}
  
  {$region CLMemorySegmentCCQ}
  
  ///Представляет очередь-контейнер для команд GPU, применяемых к объекту типа CLMemory
  CLMemoryCCQ = sealed partial class
    
    ///Создаёт контейнер команд, который будет применять команды к объекту, который вернёт указанная очередь
    ///За каждое одно выполнение контейнера - q выполнится ровно один раз
    public constructor(q: CommandQueue<CLMemory>);
    private constructor;
    
    {$region Special .Add's}
    
    ///Добавляет выполнение очереди в список обычных команд для GPU
    public function ThenQueue(q: CommandQueueBase): CLMemoryCCQ;
    
    public function ThenProc(p: CLMemory->(); need_own_thread: boolean := true; can_pre_calc: boolean := false): CLMemoryCCQ;
    public function ThenProc(p: (CLMemory, CLContext)->(); need_own_thread: boolean := true; can_pre_calc: boolean := false): CLMemoryCCQ;
    
    ///Добавляет ожидание сигнала выполненности от заданного маркера
    public function ThenWait(marker: WaitMarker): CLMemoryCCQ;
    
    {$endregion Special .Add's}
    
    {$region 1#Write&Read}
    
    ///Записывает указанное значение размерного типа в начало области памяти
    public function ThenWriteValue<TRecord>(val: TRecord): CLMemoryCCQ; where TRecord: record;
    
    ///Записывает указанное значение размерного типа в начало области памяти
    public function ThenWriteValue<TRecord>(val: CommandQueue<TRecord>): CLMemoryCCQ; where TRecord: record;
    
    ///Записывает указанное значение размерного типа в область памяти
    ///mem_offset указывает отступ от начала области памяти, в байтах
    public function ThenWriteValue<TRecord>(val: TRecord; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    ///Записывает указанное значение размерного типа в область памяти
    ///mem_offset указывает отступ от начала области памяти, в байтах
    public function ThenWriteValue<TRecord>(val: CommandQueue<TRecord>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    ///Записывает весь массив в начало области памяти
    public function ThenWriteArray1<TRecord>(a: array of TRecord): CLMemoryCCQ; where TRecord: record;
    
    ///Записывает весь массив в начало области памяти
    public function ThenWriteArray2<TRecord>(a: array[,] of TRecord): CLMemoryCCQ; where TRecord: record;
    
    ///Записывает весь массив в начало области памяти
    public function ThenWriteArray3<TRecord>(a: array[,,] of TRecord): CLMemoryCCQ; where TRecord: record;
    
    ///Заполняет весь массив байбами из начала области памяти
    public function ThenReadArray1<TRecord>(a: array of TRecord): CLMemoryCCQ; where TRecord: record;
    
    ///Заполняет весь массив байбами из начала области памяти
    public function ThenReadArray2<TRecord>(a: array[,] of TRecord): CLMemoryCCQ; where TRecord: record;
    
    ///Заполняет весь массив байбами из начала области памяти
    public function ThenReadArray3<TRecord>(a: array[,,] of TRecord): CLMemoryCCQ; where TRecord: record;
    
    ///Записывает указанный участок массива в область памяти
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///a_ind(-ы) указывают индекс первого задействованного элемента массива
    ///el_count указывает кол-во задействованных элементов массива
    public function ThenWriteArray1<TRecord>(a: array of TRecord; a_ind, el_count, mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    ///Записывает указанный участок массива в область памяти
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///a_ind(-ы) указывают индекс первого задействованного элемента массива
    ///el_count указывает кол-во задействованных элементов массива
    ///==================================================
    ///ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
    ///Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
    ///Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку
    public function ThenWriteArray2<TRecord>(a: array[,] of TRecord; a_ind1,a_ind2, el_count, mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    ///Записывает указанный участок массива в область памяти
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///a_ind(-ы) указывают индекс первого задействованного элемента массива
    ///el_count указывает кол-во задействованных элементов массива
    ///==================================================
    ///ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
    ///Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
    ///Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку
    public function ThenWriteArray3<TRecord>(a: array[,,] of TRecord; a_ind1,a_ind2,a_ind3, el_count, mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    ///Читает данные из области памяти в указанный участок массива
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///a_ind(-ы) указывают индекс первого задействованного элемента массива
    ///el_count указывает кол-во задействованных элементов массива
    public function ThenReadArray1<TRecord>(a: array of TRecord; a_ind, el_count, mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    ///Читает данные из области памяти в указанный участок массива
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///a_ind(-ы) указывают индекс первого задействованного элемента массива
    ///el_count указывает кол-во задействованных элементов массива
    ///==================================================
    ///ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
    ///Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
    ///Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку
    public function ThenReadArray2<TRecord>(a: array[,] of TRecord; a_ind1,a_ind2, el_count, mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    ///Читает данные из области памяти в указанный участок массива
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///a_ind(-ы) указывают индекс первого задействованного элемента массива
    ///el_count указывает кол-во задействованных элементов массива
    ///==================================================
    ///ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
    ///Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
    ///Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку
    public function ThenReadArray3<TRecord>(a: array[,,] of TRecord; a_ind1,a_ind2,a_ind3, el_count, mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    ///Записывает весь массив в начало области памяти
    public function ThenWriteArray1<TRecord>(a: CommandQueue<array of TRecord>): CLMemoryCCQ; where TRecord: record;
    
    ///Записывает весь массив в начало области памяти
    public function ThenWriteArray2<TRecord>(a: CommandQueue<array[,] of TRecord>): CLMemoryCCQ; where TRecord: record;
    
    ///Записывает весь массив в начало области памяти
    public function ThenWriteArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>): CLMemoryCCQ; where TRecord: record;
    
    ///Заполняет весь массив байбами из начала области памяти
    public function ThenReadArray1<TRecord>(a: CommandQueue<array of TRecord>): CLMemoryCCQ; where TRecord: record;
    
    ///Заполняет весь массив байбами из начала области памяти
    public function ThenReadArray2<TRecord>(a: CommandQueue<array[,] of TRecord>): CLMemoryCCQ; where TRecord: record;
    
    ///Заполняет весь массив байбами из начала области памяти
    public function ThenReadArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>): CLMemoryCCQ; where TRecord: record;
    
    ///Записывает указанный участок массива в область памяти
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///a_ind(-ы) указывают индекс первого задействованного элемента массива
    ///el_count указывает кол-во задействованных элементов массива
    public function ThenWriteArray1<TRecord>(a: CommandQueue<array of TRecord>; a_ind, el_count, mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    ///Записывает указанный участок массива в область памяти
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///a_ind(-ы) указывают индекс первого задействованного элемента массива
    ///el_count указывает кол-во задействованных элементов массива
    ///==================================================
    ///ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
    ///Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
    ///Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку
    public function ThenWriteArray2<TRecord>(a: CommandQueue<array[,] of TRecord>; a_ind1,a_ind2, el_count, mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    ///Записывает указанный участок массива в область памяти
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///a_ind(-ы) указывают индекс первого задействованного элемента массива
    ///el_count указывает кол-во задействованных элементов массива
    ///==================================================
    ///ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
    ///Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
    ///Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку
    public function ThenWriteArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>; a_ind1,a_ind2,a_ind3, el_count, mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    ///Читает данные из области памяти в указанный участок массива
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///a_ind(-ы) указывают индекс первого задействованного элемента массива
    ///el_count указывает кол-во задействованных элементов массива
    public function ThenReadArray1<TRecord>(a: CommandQueue<array of TRecord>; a_ind, el_count, mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    ///Читает данные из области памяти в указанный участок массива
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///a_ind(-ы) указывают индекс первого задействованного элемента массива
    ///el_count указывает кол-во задействованных элементов массива
    ///==================================================
    ///ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
    ///Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
    ///Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку
    public function ThenReadArray2<TRecord>(a: CommandQueue<array[,] of TRecord>; a_ind1,a_ind2, el_count, mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    ///Читает данные из области памяти в указанный участок массива
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///a_ind(-ы) указывают индекс первого задействованного элемента массива
    ///el_count указывает кол-во задействованных элементов массива
    ///==================================================
    ///ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
    ///Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
    ///Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку
    public function ThenReadArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>; a_ind1,a_ind2,a_ind3, el_count, mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    ///Записывает указанный участок массива в область памяти
    ///mem_offset указывает отступ от начала области памяти, в байтах
    public function ThenWriteArraySegment<TRecord>(a: ArraySegment<TRecord>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    ///Читает данные из области памяти в указанный участок массива
    ///mem_offset указывает отступ от начала области памяти, в байтах
    public function ThenReadArraySegment<TRecord>(a: ArraySegment<TRecord>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    ///Заполняет всю область памяти данными, находящимися по указанному адресу в RAM
    public function ThenWriteData(ptr: CommandQueue<IntPtr>): CLMemoryCCQ;
    
    ///Заполняет часть области памяти данными, находящимися по указанному адресу в RAM
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///len указывает кол-во задействованных в операции байт
    public function ThenWriteData(ptr: CommandQueue<IntPtr>; mem_offset, len: CommandQueue<integer>): CLMemoryCCQ;
    
    ///Читает всё содержимое области памяти в RAM, по указанному адресу
    public function ThenReadData(ptr: CommandQueue<IntPtr>): CLMemoryCCQ;
    
    ///Читает часть содержимого области памяти в RAM, по указанному адресу
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///len указывает кол-во задействованных в операции байт
    public function ThenReadData(ptr: CommandQueue<IntPtr>; mem_offset, len: CommandQueue<integer>): CLMemoryCCQ;
    
    ///Заполняет всю область памяти данными, находящимися по указанному адресу в RAM
    public function ThenWriteData(ptr: pointer): CLMemoryCCQ;
    
    ///Заполняет часть области памяти данными, находящимися по указанному адресу в RAM
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///len указывает кол-во задействованных в операции байт
    public function ThenWriteData(ptr: pointer; mem_offset, len: CommandQueue<integer>): CLMemoryCCQ;
    
    ///Читает всё содержимое области памяти в RAM, по указанному адресу
    public function ThenReadData(ptr: pointer): CLMemoryCCQ;
    
    ///Читает часть содержимого области памяти в RAM, по указанному адресу
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///len указывает кол-во задействованных в операции байт
    public function ThenReadData(ptr: pointer; mem_offset, len: CommandQueue<integer>): CLMemoryCCQ;
    
    public function ThenWriteNativeMemoryArea(native_data: NativeMemoryArea): CLMemoryCCQ;
    
    public function ThenWriteNativeMemoryArea(native_data: NativeMemoryArea; mem_offset: CommandQueue<integer>): CLMemoryCCQ;
    
    public function ThenWriteNativeMemory(native_data: NativeMemory): CLMemoryCCQ;
    
    public function ThenWriteNativeMemory(native_data: NativeMemory; mem_offset: CommandQueue<integer>): CLMemoryCCQ;
    
    public function ThenWriteNativeValueArea<TRecord>(native_data: NativeValueArea<TRecord>): CLMemoryCCQ; where TRecord: record;
    
    public function ThenWriteNativeValueArea<TRecord>(native_data: NativeValueArea<TRecord>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    ///Записывает указанное значение размерного типа в начало области памяти
    public function ThenWriteNativeValue<TRecord>(native_data: NativeValue<TRecord>): CLMemoryCCQ; where TRecord: record;
    
    ///Записывает указанное значение размерного типа в область памяти
    ///mem_offset указывает отступ от начала области памяти, в байтах
    public function ThenWriteNativeValue<TRecord>(native_data: NativeValue<TRecord>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    public function ThenWriteNativeArrayArea<TRecord>(native_data: NativeArrayArea<TRecord>): CLMemoryCCQ; where TRecord: record;
    
    public function ThenWriteNativeArrayArea<TRecord>(native_data: NativeArrayArea<TRecord>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    ///Записывает весь массив в начало области памяти
    public function ThenWriteNativeArray<TRecord>(native_data: NativeArray<TRecord>): CLMemoryCCQ; where TRecord: record;
    
    public function ThenWriteNativeArray<TRecord>(native_data: NativeArray<TRecord>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    public function ThenReadNativeMemoryArea(native_data: NativeMemoryArea): CLMemoryCCQ;
    
    public function ThenReadNativeMemoryArea(native_data: NativeMemoryArea; mem_offset: CommandQueue<integer>): CLMemoryCCQ;
    
    public function ThenReadNativeMemory(native_data: NativeMemory): CLMemoryCCQ;
    
    public function ThenReadNativeMemory(native_data: NativeMemory; mem_offset: CommandQueue<integer>): CLMemoryCCQ;
    
    public function ThenReadNativeValueArea<TRecord>(native_data: NativeValueArea<TRecord>): CLMemoryCCQ; where TRecord: record;
    
    public function ThenReadNativeValueArea<TRecord>(native_data: NativeValueArea<TRecord>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    ///Читает значение размерного типа из начала области памяти в указанное значение
    public function ThenReadNativeValue<TRecord>(native_data: NativeValue<TRecord>): CLMemoryCCQ; where TRecord: record;
    
    ///Читает значение размерного типа из области памяти в указанное значение
    ///mem_offset указывает отступ от начала области памяти, в байтах
    public function ThenReadNativeValue<TRecord>(native_data: NativeValue<TRecord>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    public function ThenReadNativeArrayArea<TRecord>(native_data: NativeArrayArea<TRecord>): CLMemoryCCQ; where TRecord: record;
    
    public function ThenReadNativeArrayArea<TRecord>(native_data: NativeArrayArea<TRecord>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    ///Заполняет весь массив байбами из начала области памяти
    public function ThenReadNativeArray<TRecord>(native_data: NativeArray<TRecord>): CLMemoryCCQ; where TRecord: record;
    
    public function ThenReadNativeArray<TRecord>(native_data: NativeArray<TRecord>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    public function ThenWriteNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>): CLMemoryCCQ;
    
    public function ThenWriteNativeMemory(native_data: CommandQueue<NativeMemory>): CLMemoryCCQ;
    
    public function ThenWriteNativeValueArea<TRecord>(native_data: CommandQueue<NativeValueArea<TRecord>>): CLMemoryCCQ; where TRecord: record;
    
    ///Записывает указанное значение размерного типа в начало области памяти
    public function ThenWriteNativeValue<TRecord>(native_data: CommandQueue<NativeValue<TRecord>>): CLMemoryCCQ; where TRecord: record;
    
    public function ThenWriteNativeArrayArea<TRecord>(native_data: CommandQueue<NativeArrayArea<TRecord>>): CLMemoryCCQ; where TRecord: record;
    
    ///Записывает весь массив в начало области памяти
    public function ThenWriteNativeArray<TRecord>(native_data: CommandQueue<NativeArray<TRecord>>): CLMemoryCCQ; where TRecord: record;
    
    public function ThenReadNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>): CLMemoryCCQ;
    
    public function ThenReadNativeMemory(native_data: CommandQueue<NativeMemory>): CLMemoryCCQ;
    
    public function ThenReadNativeValueArea<TRecord>(native_data: CommandQueue<NativeValueArea<TRecord>>): CLMemoryCCQ; where TRecord: record;
    
    ///Читает значение размерного типа из начала области памяти в указанное значение
    public function ThenReadNativeValue<TRecord>(native_data: CommandQueue<NativeValue<TRecord>>): CLMemoryCCQ; where TRecord: record;
    
    public function ThenReadNativeArrayArea<TRecord>(native_data: CommandQueue<NativeArrayArea<TRecord>>): CLMemoryCCQ; where TRecord: record;
    
    ///Заполняет весь массив байбами из начала области памяти
    public function ThenReadNativeArray<TRecord>(native_data: CommandQueue<NativeArray<TRecord>>): CLMemoryCCQ; where TRecord: record;
    
    public function ThenWriteNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>; mem_offset: CommandQueue<integer>): CLMemoryCCQ;
    
    public function ThenWriteNativeMemory(native_data: CommandQueue<NativeMemory>; mem_offset: CommandQueue<integer>): CLMemoryCCQ;
    
    public function ThenWriteNativeValueArea<TRecord>(native_data: CommandQueue<NativeValueArea<TRecord>>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    ///Записывает указанное значение размерного типа в область памяти
    ///mem_offset указывает отступ от начала области памяти, в байтах
    public function ThenWriteNativeValue<TRecord>(native_data: CommandQueue<NativeValue<TRecord>>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    public function ThenWriteNativeArrayArea<TRecord>(native_data: CommandQueue<NativeArrayArea<TRecord>>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    public function ThenWriteNativeArray<TRecord>(native_data: CommandQueue<NativeArray<TRecord>>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    public function ThenReadNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>; mem_offset: CommandQueue<integer>): CLMemoryCCQ;
    
    public function ThenReadNativeMemory(native_data: CommandQueue<NativeMemory>; mem_offset: CommandQueue<integer>): CLMemoryCCQ;
    
    public function ThenReadNativeValueArea<TRecord>(native_data: CommandQueue<NativeValueArea<TRecord>>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    ///Читает значение размерного типа из области памяти в указанное значение
    ///mem_offset указывает отступ от начала области памяти, в байтах
    public function ThenReadNativeValue<TRecord>(native_data: CommandQueue<NativeValue<TRecord>>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    public function ThenReadNativeArrayArea<TRecord>(native_data: CommandQueue<NativeArrayArea<TRecord>>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    public function ThenReadNativeArray<TRecord>(native_data: CommandQueue<NativeArray<TRecord>>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    {$endregion 1#Write&Read}
    
    {$region 2#Fill}
    
    ///Заполняет всю область памяти копиями указанного значения размерного типа
    public function ThenFillValue<TRecord>(val: TRecord): CLMemoryCCQ; where TRecord: record;
    
    ///Заполняет всю область памяти копиями указанного значения размерного типа
    public function ThenFillValue<TRecord>(val: CommandQueue<TRecord>): CLMemoryCCQ; where TRecord: record;
    
    ///Заполняет часть области памяти копиями указанного значения размерного типа
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///fill_byte_len указывает кол-во заливаемых байт
    public function ThenFillValue<TRecord>(val: TRecord; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    ///Заполняет часть области памяти копиями указанного значения размерного типа
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///fill_byte_len указывает кол-во заливаемых байт
    public function ThenFillValue<TRecord>(val: CommandQueue<TRecord>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    ///Заполняет область памяти копиями указанного массива
    public function ThenFillArray1<TRecord>(a: array of TRecord): CLMemoryCCQ; where TRecord: record;
    
    ///Заполняет область памяти копиями указанного массива
    public function ThenFillArray2<TRecord>(a: array[,] of TRecord): CLMemoryCCQ; where TRecord: record;
    
    ///Заполняет область памяти копиями указанного массива
    public function ThenFillArray3<TRecord>(a: array[,,] of TRecord): CLMemoryCCQ; where TRecord: record;
    
    ///Заполняет область памяти копиями указанного участка массива
    ///a_ind(-ы) указывают индекс первого задействованного элемента массива
    ///el_count указывает кол-во задействованных элементов массива
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///fill_byte_len указывает кол-во заливаемых байт
    public function ThenFillArray1<TRecord>(a: array of TRecord; a_ind, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    ///Заполняет область памяти копиями указанного участка массива
    ///a_ind(-ы) указывают индекс первого задействованного элемента массива
    ///el_count указывает кол-во задействованных элементов массива
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///fill_byte_len указывает кол-во заливаемых байт
    ///==================================================
    ///ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
    ///Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
    ///Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку
    public function ThenFillArray2<TRecord>(a: array[,] of TRecord; a_ind1,a_ind2, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    ///Заполняет область памяти копиями указанного участка массива
    ///a_ind(-ы) указывают индекс первого задействованного элемента массива
    ///el_count указывает кол-во задействованных элементов массива
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///fill_byte_len указывает кол-во заливаемых байт
    ///==================================================
    ///ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
    ///Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
    ///Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку
    public function ThenFillArray3<TRecord>(a: array[,,] of TRecord; a_ind1,a_ind2,a_ind3, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    ///Заполняет область памяти копиями указанного массива
    public function ThenFillArray1<TRecord>(a: CommandQueue<array of TRecord>): CLMemoryCCQ; where TRecord: record;
    
    ///Заполняет область памяти копиями указанного участка массива
    ///a_ind(-ы) указывают индекс первого задействованного элемента массива
    ///el_count указывает кол-во задействованных элементов массива
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///fill_byte_len указывает кол-во заливаемых байт
    public function ThenFillArray1<TRecord>(a: CommandQueue<array of TRecord>; a_ind, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    ///Заполняет область памяти копиями указанного массива
    public function ThenFillArray2<TRecord>(a: CommandQueue<array[,] of TRecord>): CLMemoryCCQ; where TRecord: record;
    
    ///Заполняет область памяти копиями указанного участка массива
    ///a_ind(-ы) указывают индекс первого задействованного элемента массива
    ///el_count указывает кол-во задействованных элементов массива
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///fill_byte_len указывает кол-во заливаемых байт
    ///==================================================
    ///ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
    ///Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
    ///Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку
    public function ThenFillArray2<TRecord>(a: CommandQueue<array[,] of TRecord>; a_ind1,a_ind2, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    ///Заполняет область памяти копиями указанного массива
    public function ThenFillArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>): CLMemoryCCQ; where TRecord: record;
    
    ///Заполняет область памяти копиями указанного участка массива
    ///a_ind(-ы) указывают индекс первого задействованного элемента массива
    ///el_count указывает кол-во задействованных элементов массива
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///fill_byte_len указывает кол-во заливаемых байт
    ///==================================================
    ///ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
    ///Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
    ///Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку
    public function ThenFillArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>; a_ind1,a_ind2,a_ind3, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    public function ThenFillArraySegment<TRecord>(a: CommandQueue<ArraySegment<TRecord>>): CLMemoryCCQ; where TRecord: record;
    
    public function ThenFillArraySegment<TRecord>(a: CommandQueue<ArraySegment<TRecord>>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    ///Заполняет область памяти копиями указанного участка массива
    public function ThenFillArraySegment<TRecord>(a: ArraySegment<TRecord>): CLMemoryCCQ; where TRecord: record;
    
    ///Заполняет область памяти копиями указанного участка массива
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///fill_byte_len указывает кол-во заливаемых байт
    public function ThenFillArraySegment<TRecord>(a: ArraySegment<TRecord>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    ///Берёт последовательность из pattern_len байт из RAM по указанному адресу и заполняет её копиями всю область памяти
    public function ThenFillData(ptr: CommandQueue<IntPtr>; pattern_byte_len: CommandQueue<integer>): CLMemoryCCQ;
    
    ///Берёт последовательность из pattern_len байт из RAM по указанному адресу и заполняет её копиями часть области памяти
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///fill_byte_len указывает кол-во заливаемых байт
    public function ThenFillData(ptr: CommandQueue<IntPtr>; pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ;
    
    ///Берёт последовательность из pattern_len байт из RAM по указанному адресу и заполняет её копиями всю область памяти
    public function ThenFillData(ptr: pointer; pattern_byte_len: CommandQueue<integer>): CLMemoryCCQ;
    
    ///Берёт последовательность из pattern_len байт из RAM по указанному адресу и заполняет её копиями часть области памяти
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///fill_byte_len указывает кол-во заливаемых байт
    public function ThenFillData(ptr: pointer; pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ;
    
    public function ThenFillNativeMemoryArea(native_data: NativeMemoryArea): CLMemoryCCQ;
    
    public function ThenFillNativeMemoryArea(native_data: NativeMemoryArea; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ;
    
    public function ThenFillNativeMemory(native_data: NativeMemory): CLMemoryCCQ;
    
    public function ThenFillNativeMemory(native_data: NativeMemory; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ;
    
    public function ThenFillNativeValueArea<TRecord>(native_data: NativeValueArea<TRecord>): CLMemoryCCQ; where TRecord: record;
    
    public function ThenFillNativeValueArea<TRecord>(native_data: NativeValueArea<TRecord>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    ///Заполняет всю область памяти копиями указанного значения размерного типа
    public function ThenFillNativeValue<TRecord>(native_data: NativeValue<TRecord>): CLMemoryCCQ; where TRecord: record;
    
    ///Заполняет часть области памяти копиями указанного значения размерного типа
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///fill_byte_len указывает кол-во заливаемых байт
    public function ThenFillNativeValue<TRecord>(native_data: NativeValue<TRecord>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    public function ThenFillNativeArrayArea<TRecord>(native_data: NativeArrayArea<TRecord>): CLMemoryCCQ; where TRecord: record;
    
    public function ThenFillNativeArrayArea<TRecord>(native_data: NativeArrayArea<TRecord>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    ///Заполняет область памяти копиями указанного массива
    public function ThenFillNativeArray<TRecord>(native_data: NativeArray<TRecord>): CLMemoryCCQ; where TRecord: record;
    
    public function ThenFillNativeArray<TRecord>(native_data: NativeArray<TRecord>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    public function ThenFillNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>): CLMemoryCCQ;
    
    public function ThenFillNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ;
    
    public function ThenFillNativeMemory(native_data: CommandQueue<NativeMemory>): CLMemoryCCQ;
    
    public function ThenFillNativeMemory(native_data: CommandQueue<NativeMemory>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ;
    
    public function ThenFillNativeValueArea<TRecord>(native_data: CommandQueue<NativeValueArea<TRecord>>): CLMemoryCCQ; where TRecord: record;
    
    public function ThenFillNativeValueArea<TRecord>(native_data: CommandQueue<NativeValueArea<TRecord>>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    ///Заполняет всю область памяти копиями указанного значения размерного типа
    public function ThenFillNativeValue<TRecord>(native_data: CommandQueue<NativeValue<TRecord>>): CLMemoryCCQ; where TRecord: record;
    
    ///Заполняет часть области памяти копиями указанного значения размерного типа
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///fill_byte_len указывает кол-во заливаемых байт
    public function ThenFillNativeValue<TRecord>(native_data: CommandQueue<NativeValue<TRecord>>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    public function ThenFillNativeArrayArea<TRecord>(native_data: CommandQueue<NativeArrayArea<TRecord>>): CLMemoryCCQ; where TRecord: record;
    
    public function ThenFillNativeArrayArea<TRecord>(native_data: CommandQueue<NativeArrayArea<TRecord>>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    ///Заполняет область памяти копиями указанного массива
    public function ThenFillNativeArray<TRecord>(native_data: CommandQueue<NativeArray<TRecord>>): CLMemoryCCQ; where TRecord: record;
    
    public function ThenFillNativeArray<TRecord>(native_data: CommandQueue<NativeArray<TRecord>>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
    
    {$endregion 2#Fill}
    
    {$region 3#Copy}
    
    ///Копирует данные из данной области памяти в mem
    ///Если области памяти имеют разный размер - в качестве объёма данных берётся размер меньшей области
    public function ThenCopyTo(mem: CommandQueue<CLMemory>): CLMemoryCCQ;
    
    ///Копирует данные из данной области памяти в mem
    ///from_offset указывает отступ в байтах от начала области памяти, из которой копируют
    ///to_offset указывает отступ в байтах от начала области памяти, в которую копируют
    ///len указывает кол-во копируемых байт
    public function ThenCopyTo(mem: CommandQueue<CLMemory>; from_offset, to_offset, len: CommandQueue<integer>): CLMemoryCCQ;
    
    ///Копирует данные из mem в данную область памяти
    ///Если области памяти имеют разный размер - в качестве объёма данных берётся размер меньшей области
    public function ThenCopyFrom(mem: CommandQueue<CLMemory>): CLMemoryCCQ;
    
    ///Копирует данные из mem в данную область памяти
    ///from_offset указывает отступ в байтах от начала области памяти, из которой копируют
    ///to_offset указывает отступ в байтах от начала области памяти, в которую копируют
    ///len указывает кол-во копируемых байт
    public function ThenCopyFrom(mem: CommandQueue<CLMemory>; from_offset, to_offset, len: CommandQueue<integer>): CLMemoryCCQ;
    
    {$endregion 3#Copy}
    
    {$region Get}
    
    ///Читает значение указанного размерного типа из начала области памяти
    public function ThenGetValue<TRecord>: CommandQueue<TRecord>; where TRecord: record;
    
    ///Читает значение указанного размерного типа из области памяти
    ///mem_offset указывает отступ от начала области памяти, в байтах
    public function ThenGetValue<TRecord>(mem_offset: CommandQueue<integer>): CommandQueue<TRecord>; where TRecord: record;
    
    ///Создаёт массив с максимальным возможным кол-вом элементов и заполняет его содержимым области памяти
    public function ThenGetArray<TRecord>: CommandQueue<array of TRecord>; where TRecord: record;
    
    ///Создаёт массив с указанным кол-вом элементов и копирует в него содержимое из начала области памяти
    public function ThenGetArray<TRecord>(len: CommandQueue<integer>): CommandQueue<array of TRecord>; where TRecord: record;
    
    ///Создаёт массив с указанным кол-вом элементов и копирует в него содержимое из начала области памяти
    public function ThenGetArray2<TRecord>(len1,len2: CommandQueue<integer>): CommandQueue<array[,] of TRecord>; where TRecord: record;
    
    ///Создаёт массив с указанным кол-вом элементов и копирует в него содержимое из начала области памяти
    public function ThenGetArray3<TRecord>(len1,len2,len3: CommandQueue<integer>): CommandQueue<array[,,] of TRecord>; where TRecord: record;
    
    {$endregion Get}
    
  end;
  
  ///Представляет область памяти устройства OpenCL (обычно GPU)
  CLMemory = partial class
    public function MakeCCQ := new CLMemoryCCQ(self);
  end;
  
  {$endregion CLMemorySegmentCCQ}
  
  {$region CLValueCCQ}
  
  ///Представляет очередь-контейнер для команд GPU, применяемых к объекту типа CLValue
  CLValueCCQ<T> = sealed partial class
  where T: record;
    
    ///Создаёт контейнер команд, который будет применять команды к объекту, который вернёт указанная очередь
    ///За каждое одно выполнение контейнера - q выполнится ровно один раз
    public constructor(q: CommandQueue<CLValue<T>>);
    private constructor;
    
    {$region Special .Add's}
    
    ///Добавляет выполнение очереди в список обычных команд для GPU
    public function ThenQueue(q: CommandQueueBase): CLValueCCQ<T>;
    
    public function ThenProc(p: CLValue<T>->(); need_own_thread: boolean := true; can_pre_calc: boolean := false): CLValueCCQ<T>;
    public function ThenProc(p: (CLValue<T>, CLContext)->(); need_own_thread: boolean := true; can_pre_calc: boolean := false): CLValueCCQ<T>;
    
    ///Добавляет ожидание сигнала выполненности от заданного маркера
    public function ThenWait(marker: WaitMarker): CLValueCCQ<T>;
    
    {$endregion Special .Add's}
    
    {$region 1#Write&Read}
    
    ///Записывает указанное значение в данное
    public function ThenWriteValue(val: &T): CLValueCCQ<T>;
    
    ///Записывает указанное значение в данное
    public function ThenWriteValue(val: CommandQueue<&T>): CLValueCCQ<T>;
    
    public function ThenWriteNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>): CLValueCCQ<T>;
    
    ///Записывает указанное значение в данное
    public function ThenWriteNativeValue(native_data: CommandQueue<NativeValue<&T>>): CLValueCCQ<T>;
    
    public function ThenReadNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>): CLValueCCQ<T>;
    
    ///Читает данное значение в указанное
    public function ThenReadNativeValue(native_data: CommandQueue<NativeValue<&T>>): CLValueCCQ<T>;
    
    {$endregion 1#Write&Read}
    
    {$region 3#Copy}
    
    ///Копирует данные из данного значения в mem
    public function ThenCopyTo(mem: CommandQueue<CLMemory>): CLValueCCQ<T>;
    
    ///Копирует данные из mem в данное значение
    public function ThenCopyFrom(mem: CommandQueue<CLMemory>): CLValueCCQ<T>;
    
    ///Копирует данные из данного значения в mem
    ///mem_offset указывает отступ от начала области памяти, в байтах
    public function ThenCopyTo(mem: CommandQueue<CLMemory>; mem_offset: CommandQueue<integer>): CLValueCCQ<T>;
    
    ///Копирует данные из mem в данное значение
    ///mem_offset указывает отступ от начала области памяти, в байтах
    public function ThenCopyFrom(mem: CommandQueue<CLMemory>; mem_offset: CommandQueue<integer>): CLValueCCQ<T>;
    
    ///Копирует данные из данного значения в val
    public function ThenCopyTo(val: CommandQueue<CLValue<&T>>): CLValueCCQ<T>;
    
    ///Копирует данные из val в данное значение
    public function ThenCopyFrom(val: CommandQueue<CLValue<&T>>): CLValueCCQ<T>;
    
    {$endregion 3#Copy}
    
    {$region Get}
    
    ///Читает данное значение
    public function ThenGetValue: CommandQueue<&T>;
    
    {$endregion Get}
    
  end;
  
  ///Представляет запись, значение которой хранится на устройстве OpenCL (обычно GPU)
  CLValue<T> = partial class
    public function MakeCCQ := new CLValueCCQ<T>(self);
  end;
  
  {$endregion CLValueCCQ}
  
  {$region CLArrayCCQ}
  
  ///Представляет очередь-контейнер для команд GPU, применяемых к объекту типа CLArray
  CLArrayCCQ<T> = sealed partial class
  where T: record;
    
    ///Создаёт контейнер команд, который будет применять команды к объекту, который вернёт указанная очередь
    ///За каждое одно выполнение контейнера - q выполнится ровно один раз
    public constructor(q: CommandQueue<CLArray<T>>);
    private constructor;
    
    {$region Special .Add's}
    
    ///Добавляет выполнение очереди в список обычных команд для GPU
    public function ThenQueue(q: CommandQueueBase): CLArrayCCQ<T>;
    
    public function ThenProc(p: CLArray<T>->(); need_own_thread: boolean := true; can_pre_calc: boolean := false): CLArrayCCQ<T>;
    public function ThenProc(p: (CLArray<T>, CLContext)->(); need_own_thread: boolean := true; can_pre_calc: boolean := false): CLArrayCCQ<T>;
    
    ///Добавляет ожидание сигнала выполненности от заданного маркера
    public function ThenWait(marker: WaitMarker): CLArrayCCQ<T>;
    
    {$endregion Special .Add's}
    
    {$region 1#Write&Read}
    
    ///Записывает указанное значение в элемент данного массива с индексом ind
    public function ThenWriteValue(val: &T; ind: CommandQueue<integer>): CLArrayCCQ<T>;
    
    ///Записывает указанное значение в элемент данного массива с индексом ind
    public function ThenWriteValue(val: CommandQueue<&T>; ind: CommandQueue<integer>): CLArrayCCQ<T>;
    
    ///Записывает указанный массив RAM в начало данного массива OpenCL
    public function ThenWriteArray(a: CommandQueue<array of &T>): CLArrayCCQ<T>;
    
    ///Записывает указанный массив RAM в начало данного массива OpenCL
    public function ThenWriteArray2(a: CommandQueue<array[,] of &T>): CLArrayCCQ<T>;
    
    ///Записывает указанный массив RAM в начало данного массива OpenCL
    public function ThenWriteArray3(a: CommandQueue<array[,,] of &T>): CLArrayCCQ<T>;
    
    ///Читает начало данного массива OpenCL в указанный массив RAM
    public function ThenReadArray(a: CommandQueue<array of &T>): CLArrayCCQ<T>;
    
    ///Читает начало данного массива OpenCL в указанный массив RAM
    public function ThenReadArray2(a: CommandQueue<array[,] of &T>): CLArrayCCQ<T>;
    
    ///Читает начало данного массива OpenCL в указанный массив RAM
    public function ThenReadArray3(a: CommandQueue<array[,,] of &T>): CLArrayCCQ<T>;
    
    ///Записывает len элементов из указанного массива RAM в данный массив OpenCL
    ///ind указывает индекс первого элемента данного массива OpenCL
    ///a_ind(-ы) указывают индекс первого элемента в массиве RAM
    public function ThenWriteArray(a: CommandQueue<array of &T>; a_ind, len, ind: CommandQueue<integer>): CLArrayCCQ<T>;
    
    ///Записывает len элементов из указанного массива RAM в данный массив OpenCL
    ///ind указывает индекс первого элемента данного массива OpenCL
    ///a_ind(-ы) указывают индекс первого элемента в массиве RAM
    ///==================================================
    ///ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
    ///Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
    ///Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку
    public function ThenWriteArray2(a: CommandQueue<array[,] of &T>; a_ind1,a_ind2, len, ind: CommandQueue<integer>): CLArrayCCQ<T>;
    
    ///Записывает len элементов из указанного массива RAM в данный массив OpenCL
    ///ind указывает индекс первого элемента данного массива OpenCL
    ///a_ind(-ы) указывают индекс первого элемента в массиве RAM
    ///==================================================
    ///ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
    ///Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
    ///Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку
    public function ThenWriteArray3(a: CommandQueue<array[,,] of &T>; a_ind1,a_ind2,a_ind3, len, ind: CommandQueue<integer>): CLArrayCCQ<T>;
    
    ///Читает len элементов данного массива OpenCL в указанный массив RAM
    ///ind указывает индекс первого элемента данного массива OpenCL
    ///a_ind(-ы) указывают индекс первого элемента в массиве RAM
    public function ThenReadArray(a: CommandQueue<array of &T>; a_ind, len, ind: CommandQueue<integer>): CLArrayCCQ<T>;
    
    ///Читает len элементов данного массива OpenCL в указанный массив RAM
    ///ind указывает индекс первого элемента данного массива OpenCL
    ///a_ind(-ы) указывают индекс первого элемента в массиве RAM
    ///==================================================
    ///ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
    ///Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
    ///Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку
    public function ThenReadArray2(a: CommandQueue<array[,] of &T>; a_ind1,a_ind2, len, ind: CommandQueue<integer>): CLArrayCCQ<T>;
    
    ///Читает len элементов данного массива OpenCL в указанный массив RAM
    ///ind указывает индекс первого элемента данного массива OpenCL
    ///a_ind(-ы) указывают индекс первого элемента в массиве RAM
    ///==================================================
    ///ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
    ///Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
    ///Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку
    public function ThenReadArray3(a: CommandQueue<array[,,] of &T>; a_ind1,a_ind2,a_ind3, len, ind: CommandQueue<integer>): CLArrayCCQ<T>;
    
    ///Записывает указанный участок массива RAM в начало данного массива OpenCL
    public function ThenWriteArraySegment(a: CommandQueue<ArraySegment<&T>>): CLArrayCCQ<T>;
    
    ///Читает начало данного массива OpenCL в указанный участок массива RAM
    public function ThenReadArraySegment(a: CommandQueue<ArraySegment<&T>>): CLArrayCCQ<T>;
    
    ///Записывает указанный участок массива RAM в данный массив OpenCL
    ///ind указывает индекс первого элемента данного массива OpenCL
    public function ThenWriteArraySegment(a: CommandQueue<ArraySegment<&T>>; ind: CommandQueue<integer>): CLArrayCCQ<T>;
    
    ///Читает данные данного массива OpenCL в указанный участок массива RAM
    ///ind указывает индекс первого элемента данного массива OpenCL
    public function ThenReadArraySegment(a: CommandQueue<ArraySegment<&T>>; ind: CommandQueue<integer>): CLArrayCCQ<T>;
    
    ///Заполняет весь данный массив данными, находящимися по указанному адресу в RAM
    public function ThenWriteData(ptr: CommandQueue<IntPtr>): CLArrayCCQ<T>;
    
    ///Заполняет len элементов начиная с индекса ind данного массива данными, находящимися по указанному адресу в RAM
    public function ThenWriteData(ptr: CommandQueue<IntPtr>; ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
    
    ///Читает всё содержимое из данного массива в RAM, по указанному адресу
    public function ThenReadData(ptr: CommandQueue<IntPtr>): CLArrayCCQ<T>;
    
    ///Читает len элементов начиная с индекса ind из данного массива в RAM, по указанному адресу
    public function ThenReadData(ptr: CommandQueue<IntPtr>; ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
    
    ///Заполняет весь данный массив данными, находящимися по указанному адресу в RAM
    public function ThenWriteData(ptr: pointer): CLArrayCCQ<T>;
    
    ///Заполняет len элементов начиная с индекса ind данного массива данными, находящимися по указанному адресу в RAM
    public function ThenWriteData(ptr: pointer; ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
    
    ///Читает всё содержимое из данного массива в RAM, по указанному адресу
    public function ThenReadData(ptr: pointer): CLArrayCCQ<T>;
    
    ///Читает len элементов начиная с индекса ind из данного массива в RAM, по указанному адресу
    public function ThenReadData(ptr: pointer; ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
    
    public function ThenWriteNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>): CLArrayCCQ<T>;
    
    public function ThenWriteNativeMemory(native_data: CommandQueue<NativeMemory>): CLArrayCCQ<T>;
    
    public function ThenWriteNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>): CLArrayCCQ<T>;
    
    public function ThenWriteNativeValue(native_data: CommandQueue<NativeValue<&T>>): CLArrayCCQ<T>;
    
    public function ThenWriteNativeArrayArea(native_data: CommandQueue<NativeArrayArea<&T>>): CLArrayCCQ<T>;
    
    ///Записывает указанный массив RAM в начало данного массива OpenCL
    public function ThenWriteNativeArray(native_data: CommandQueue<NativeArray<&T>>): CLArrayCCQ<T>;
    
    public function ThenReadNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>): CLArrayCCQ<T>;
    
    public function ThenReadNativeMemory(native_data: CommandQueue<NativeMemory>): CLArrayCCQ<T>;
    
    public function ThenReadNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>): CLArrayCCQ<T>;
    
    public function ThenReadNativeValue(native_data: CommandQueue<NativeValue<&T>>): CLArrayCCQ<T>;
    
    public function ThenReadNativeArrayArea(native_data: CommandQueue<NativeArrayArea<&T>>): CLArrayCCQ<T>;
    
    ///Читает начало данного массива OpenCL в указанный массив RAM
    public function ThenReadNativeArray(native_data: CommandQueue<NativeArray<&T>>): CLArrayCCQ<T>;
    
    public function ThenWriteNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>; mem_offset: CommandQueue<integer>): CLArrayCCQ<T>;
    
    public function ThenWriteNativeMemory(native_data: CommandQueue<NativeMemory>; mem_offset: CommandQueue<integer>): CLArrayCCQ<T>;
    
    public function ThenWriteNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>; mem_offset: CommandQueue<integer>): CLArrayCCQ<T>;
    
    ///Записывает указанное значение в элемент данного массива с индексом ind
    public function ThenWriteNativeValue(native_data: CommandQueue<NativeValue<&T>>; mem_offset: CommandQueue<integer>): CLArrayCCQ<T>;
    
    public function ThenWriteNativeArrayArea(native_data: CommandQueue<NativeArrayArea<&T>>; mem_offset: CommandQueue<integer>): CLArrayCCQ<T>;
    
    public function ThenWriteNativeArray(native_data: CommandQueue<NativeArray<&T>>; mem_offset: CommandQueue<integer>): CLArrayCCQ<T>;
    
    public function ThenReadNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>; mem_offset: CommandQueue<integer>): CLArrayCCQ<T>;
    
    public function ThenReadNativeMemory(native_data: CommandQueue<NativeMemory>; mem_offset: CommandQueue<integer>): CLArrayCCQ<T>;
    
    public function ThenReadNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>; mem_offset: CommandQueue<integer>): CLArrayCCQ<T>;
    
    ///Читает элемент данного массива с индексом ind в указанное значение
    public function ThenReadNativeValue(native_data: CommandQueue<NativeValue<&T>>; mem_offset: CommandQueue<integer>): CLArrayCCQ<T>;
    
    public function ThenReadNativeArrayArea(native_data: CommandQueue<NativeArrayArea<&T>>; mem_offset: CommandQueue<integer>): CLArrayCCQ<T>;
    
    public function ThenReadNativeArray(native_data: CommandQueue<NativeArray<&T>>; mem_offset: CommandQueue<integer>): CLArrayCCQ<T>;
    
    {$endregion 1#Write&Read}
    
    {$region 2#Fill}
    
    ///Заполняет весь массив копиями указанного значения
    public function ThenFillValue(val: &T): CLArrayCCQ<T>;
    
    ///Заполняет весь массив копиями указанного значения
    public function ThenFillValue(val: CommandQueue<&T>): CLArrayCCQ<T>;
    
    ///Заполняет len элементов начиная с индекса ind копиями указанного значения
    public function ThenFillValue(val: &T; ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
    
    ///Заполняет len элементов начиная с индекса ind копиями указанного значения
    public function ThenFillValue(val: CommandQueue<&T>; ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
    
    ///Заполняет данный массив OpenCL копиями указанного массива RAM
    public function ThenFillArray(a: CommandQueue<array of &T>): CLArrayCCQ<T>;
    
    ///Заполняет данный массив OpenCL копиями указанного массива RAM
    public function ThenFillArray2(a: CommandQueue<array[,] of &T>): CLArrayCCQ<T>;
    
    ///Заполняет данный массив OpenCL копиями указанного массива RAM
    public function ThenFillArray3(a: CommandQueue<array[,,] of &T>): CLArrayCCQ<T>;
    
    ///Заполняет fill_len элементов данного массива OpenCL копиями участков из pattern_len элементов указанного массива
    ///ind указывает индекс первого элемента данного массива OpenCL
    ///a_ind(-ы) указывают индекс первого элемента в массиве RAM
    public function ThenFillArray(a: CommandQueue<array of &T>; a_ind, pattern_len, ind, fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
    
    ///Заполняет fill_len элементов данного массива OpenCL копиями участков из pattern_len элементов указанного массива
    ///ind указывает индекс первого элемента данного массива OpenCL
    ///a_ind(-ы) указывают индекс первого элемента в массиве RAM
    ///==================================================
    ///ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
    ///Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
    ///Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку
    public function ThenFillArray2(a: CommandQueue<array[,] of &T>; a_ind1,a_ind2, pattern_len, ind, fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
    
    ///Заполняет fill_len элементов данного массива OpenCL копиями участков из pattern_len элементов указанного массива
    ///ind указывает индекс первого элемента данного массива OpenCL
    ///a_ind(-ы) указывают индекс первого элемента в массиве RAM
    ///==================================================
    ///ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
    ///Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
    ///Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку
    public function ThenFillArray3(a: CommandQueue<array[,,] of &T>; a_ind1,a_ind2,a_ind3, pattern_len, ind, fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
    
    ///Заполняет данный массив OpenCL копиями указанного участка массива RAM
    public function ThenFillArraySegment(a: CommandQueue<ArraySegment<&T>>): CLArrayCCQ<T>;
    
    ///Заполняет fill_len элементов данного массива OpenCL начиная с индекса ind копиями указанного участка массива RAM
    public function ThenFillArraySegment(a: CommandQueue<ArraySegment<&T>>; ind, fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
    
    ///Берёт pattern_len элементов из RAM по указанному адресу и заполняет их копиями весь данный массив
    public function ThenFillData(ptr: CommandQueue<IntPtr>; pattern_len: CommandQueue<integer>): CLArrayCCQ<T>;
    
    ///Берёт pattern_len элементов из RAM по указанному адресу и заполняет их копиями len элементов начиная с индекса ind данного массива
    public function ThenFillData(ptr: CommandQueue<IntPtr>; pattern_len, ind, fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
    
    ///Берёт pattern_len элементов из RAM по указанному адресу и заполняет их копиями весь данный массив
    public function ThenFillData(ptr: pointer; pattern_len: CommandQueue<integer>): CLArrayCCQ<T>;
    
    ///Берёт pattern_len элементов из RAM по указанному адресу и заполняет их копиями len элементов начиная с индекса ind данного массива
    public function ThenFillData(ptr: pointer; pattern_len, ind, fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
    
    public function ThenFillNativeMemoryArea(native_data: NativeMemoryArea): CLArrayCCQ<T>;
    
    public function ThenFillNativeMemoryArea(native_data: NativeMemoryArea; ind,fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
    
    public function ThenFillNativeMemory(native_data: NativeMemory): CLArrayCCQ<T>;
    
    public function ThenFillNativeMemory(native_data: NativeMemory; ind,fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
    
    public function ThenFillNativeValueArea(native_data: NativeValueArea<&T>): CLArrayCCQ<T>;
    
    public function ThenFillNativeValueArea(native_data: NativeValueArea<&T>; ind,fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
    
    public function ThenFillNativeValue(native_data: NativeValue<&T>): CLArrayCCQ<T>;
    
    public function ThenFillNativeValue(native_data: NativeValue<&T>; ind,fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
    
    public function ThenFillNativeArrayArea(native_data: NativeArrayArea<&T>): CLArrayCCQ<T>;
    
    public function ThenFillNativeArrayArea(native_data: NativeArrayArea<&T>; ind,fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
    
    public function ThenFillNativeArray(native_data: NativeArray<&T>): CLArrayCCQ<T>;
    
    public function ThenFillNativeArray(native_data: NativeArray<&T>; ind,fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
    
    public function ThenFillNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>): CLArrayCCQ<T>;
    
    public function ThenFillNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>; ind,fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
    
    public function ThenFillNativeMemory(native_data: CommandQueue<NativeMemory>): CLArrayCCQ<T>;
    
    public function ThenFillNativeMemory(native_data: CommandQueue<NativeMemory>; ind,fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
    
    public function ThenFillNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>): CLArrayCCQ<T>;
    
    public function ThenFillNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>; ind,fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
    
    ///Заполняет весь массив копиями указанного значения
    public function ThenFillNativeValue(native_data: CommandQueue<NativeValue<&T>>): CLArrayCCQ<T>;
    
    ///Заполняет len элементов начиная с индекса ind копиями указанного значения
    public function ThenFillNativeValue(native_data: CommandQueue<NativeValue<&T>>; ind,fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
    
    public function ThenFillNativeArrayArea(native_data: CommandQueue<NativeArrayArea<&T>>): CLArrayCCQ<T>;
    
    public function ThenFillNativeArrayArea(native_data: CommandQueue<NativeArrayArea<&T>>; ind,fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
    
    ///Заполняет данный массив OpenCL копиями указанного массива RAM
    public function ThenFillNativeArray(native_data: CommandQueue<NativeArray<&T>>): CLArrayCCQ<T>;
    
    public function ThenFillNativeArray(native_data: CommandQueue<NativeArray<&T>>; ind,fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
    
    {$endregion 2#Fill}
    
    {$region 3#Copy}
    
    ///Копирует элементы из данного массива в mem
    ///Копируется максимальное кол-во байт, не выходящее за границы данного массива и mem
    public function ThenCopyTo(mem: CommandQueue<CLMemory>): CLArrayCCQ<T>;
    
    ///Копирует элементы из данного массива в mem
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///ind указывает индекс первого элемента данного массива
    ///len указывает кол-во копируемых элементов
    public function ThenCopyTo(mem: CommandQueue<CLMemory>; mem_offset, ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
    
    ///Копирует элементы из mem в данный массив
    ///Копируется максимальное кол-во байт, не выходящее за границы данного массива и mem
    public function ThenCopyFrom(mem: CommandQueue<CLMemory>): CLArrayCCQ<T>;
    
    ///Копирует элементы из mem в данный массив
    ///mem_offset указывает отступ от начала области памяти, в байтах
    ///ind указывает индекс первого элемента данного массива
    ///len указывает кол-во копируемых элементов
    public function ThenCopyFrom(mem: CommandQueue<CLMemory>; mem_offset, ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
    
    ///Копирует элемент с индексом ind из данного массива в val
    public function ThenCopyTo(val: CommandQueue<CLValue<&T>>; ind: CommandQueue<integer>): CLArrayCCQ<T>;
    
    ///Копирует val в элемент данного массива с индексом ind
    public function ThenCopyFrom(val: CommandQueue<CLValue<&T>>; ind: CommandQueue<integer>): CLArrayCCQ<T>;
    
    ///Копирует элементы из данного массива в a
    ///Если у массивов разный размер - копируется кол-во элементов меньшего массива
    public function ThenCopyTo(a: CommandQueue<CLArray<&T>>): CLArrayCCQ<T>;
    
    ///Копирует элементы из данного массива в a
    ///from_ind указывает индекс в массиве, из которого копируют
    ///to_ind указывает индекс в массиве, в который копируют
    ///len указывает кол-во копируемых элементов
    public function ThenCopyTo(a: CommandQueue<CLArray<&T>>; from_ind, to_ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
    
    ///Копирует элементы из a в данный массив
    ///Если у массивов разный размер - копируется кол-во элементов меньшего массива
    public function ThenCopyFrom(a: CommandQueue<CLArray<&T>>): CLArrayCCQ<T>;
    
    ///Копирует элементы из a в данный массив
    ///from_ind указывает индекс в массиве, из которого копируют
    ///to_ind указывает индекс в массиве, в который копируют
    ///len указывает кол-во копируемых элементов
    public function ThenCopyFrom(a: CommandQueue<CLArray<&T>>; from_ind, to_ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
    
    {$endregion 3#Copy}
    
    {$region Get}
    
    ///Читает элемент по указанному индексу
    public function ThenGetValue(ind: CommandQueue<integer>): CommandQueue<&T>;
    
    ///Читает весь данный массив OpenCL как массив RAM
    public function ThenGetArray: CommandQueue<array of &T>;
    
    ///Создаёт массив RAM с указанным кол-вом элементов и копирует в него данные из начала данного массива OpenCL
    public function ThenGetArray(len: CommandQueue<integer>): CommandQueue<array of &T>;
    
    ///Создаёт массив RAM с указанным кол-вом элементов и копирует в него данные из начала данного массива OpenCL
    public function ThenGetArray2(len1,len2: CommandQueue<integer>): CommandQueue<array[,] of &T>;
    
    ///Создаёт массив RAM с указанным кол-вом элементов и копирует в него данные из начала данного массива OpenCL
    public function ThenGetArray3(len1,len2,len3: CommandQueue<integer>): CommandQueue<array[,,] of &T>;
    
    {$endregion Get}
    
  end;
  
  ///Представляет массив записей, содержимое которого хранится на устройстве OpenCL (обычно GPU)
  CLArray<T> = partial class
    public function MakeCCQ := new CLArrayCCQ<T>(self);
  end;
  
  {$endregion CLArrayCCQ}
  
  {$endregion CCQ's}
  
  {$region CLKernelArg}
  
  {$region Global}
  
  CLKernelArgGlobal = abstract partial class(CLKernelArg)
    
    {$region CL}
    
    {$region CLMemory}
    
    public static function FromCLMemory(cl_mem: CommandQueue<CLMemory>): CLKernelArgGlobal;
    public static function operator implicit(cl_mem: CLMemory): CLKernelArgGlobal;
    begin Result := FromCLMemory(cl_mem) end;
    public static function operator implicit(cl_mem: CommandQueue<CLMemory>): CLKernelArgGlobal;
    begin Result := FromCLMemory(cl_mem) end;
    public static function operator implicit(cl_mem: ConstQueue<CLMemory>): CLKernelArgGlobal;
    begin Result := FromCLMemory(cl_mem) end;
    public static function operator implicit(cl_mem: ParameterQueue<CLMemory>): CLKernelArgGlobal;
    begin Result := FromCLMemory(cl_mem) end;
    public static function operator implicit(cl_mem: CLMemoryCCQ): CLKernelArgGlobal;
    
    {$endregion CLMemory}
    
    {$region CLValue}
    
    public static function FromCLValue<T>(cl_val: CommandQueue<CLValue<T>>): CLKernelArgGlobal; where T: record;
    public static function operator implicit<T>(cl_val: CLValue<T>): CLKernelArgGlobal; where T: record;
    begin Result := FromCLValue&<T>(cl_val) end;
    public static function operator implicit<T>(cl_val: CommandQueue<CLValue<T>>): CLKernelArgGlobal; where T: record;
    begin Result := FromCLValue&<T>(cl_val) end;
    public static function operator implicit<T>(cl_val: ConstQueue<CLValue<T>>): CLKernelArgGlobal; where T: record;
    begin Result := FromCLValue&<T>(cl_val) end;
    public static function operator implicit<T>(cl_val: ParameterQueue<CLValue<T>>): CLKernelArgGlobal; where T: record;
    begin Result := FromCLValue&<T>(cl_val) end;
    public static function operator implicit<T>(cl_val: CLValueCCQ<T>): CLKernelArgGlobal; where T: record;
    
    {$endregion CLValue}
    
    {$region CLArray}
    
    public static function FromCLArray<T>(cl_arr: CommandQueue<CLArray<T>>): CLKernelArgGlobal; where T: record;
    public static function operator implicit<T>(cl_arr: CLArray<T>): CLKernelArgGlobal; where T: record;
    begin Result := FromCLArray&<T>(cl_arr) end;
    public static function operator implicit<T>(cl_arr: CommandQueue<CLArray<T>>): CLKernelArgGlobal; where T: record;
    begin Result := FromCLArray&<T>(cl_arr) end;
    public static function operator implicit<T>(cl_arr: ConstQueue<CLArray<T>>): CLKernelArgGlobal; where T: record;
    begin Result := FromCLArray&<T>(cl_arr) end;
    public static function operator implicit<T>(cl_arr: ParameterQueue<CLArray<T>>): CLKernelArgGlobal; where T: record;
    begin Result := FromCLArray&<T>(cl_arr) end;
    public static function operator implicit<T>(cl_arr: CLArrayCCQ<T>): CLKernelArgGlobal; where T: record;
    
    {$endregion CLArray}
    
    {$endregion CL}
    
  end;
  
  {$endregion Global}
  
  {$region Constant}
  
  CLKernelArgConstant = abstract partial class(CLKernelArg)
    
    {$region CL}
    
    {$region CLMemory}
    
    public static function FromCLMemory(cl_mem: CommandQueue<CLMemory>): CLKernelArgConstant;
    public static function operator implicit(cl_mem: CLMemory): CLKernelArgConstant;
    begin Result := FromCLMemory(cl_mem) end;
    public static function operator implicit(cl_mem: CommandQueue<CLMemory>): CLKernelArgConstant;
    begin Result := FromCLMemory(cl_mem) end;
    public static function operator implicit(cl_mem: ConstQueue<CLMemory>): CLKernelArgConstant;
    begin Result := FromCLMemory(cl_mem) end;
    public static function operator implicit(cl_mem: ParameterQueue<CLMemory>): CLKernelArgConstant;
    begin Result := FromCLMemory(cl_mem) end;
    public static function operator implicit(cl_mem: CLMemoryCCQ): CLKernelArgConstant;
    
    {$endregion CLMemory}
    
    {$region CLValue}
    
    public static function FromCLValue<T>(cl_val: CommandQueue<CLValue<T>>): CLKernelArgConstant; where T: record;
    public static function operator implicit<T>(cl_val: CLValue<T>): CLKernelArgConstant; where T: record;
    begin Result := FromCLValue&<T>(cl_val) end;
    public static function operator implicit<T>(cl_val: CommandQueue<CLValue<T>>): CLKernelArgConstant; where T: record;
    begin Result := FromCLValue&<T>(cl_val) end;
    public static function operator implicit<T>(cl_val: ConstQueue<CLValue<T>>): CLKernelArgConstant; where T: record;
    begin Result := FromCLValue&<T>(cl_val) end;
    public static function operator implicit<T>(cl_val: ParameterQueue<CLValue<T>>): CLKernelArgConstant; where T: record;
    begin Result := FromCLValue&<T>(cl_val) end;
    public static function operator implicit<T>(cl_val: CLValueCCQ<T>): CLKernelArgConstant; where T: record;
    
    {$endregion CLValue}
    
    {$region CLArray}
    
    public static function FromCLArray<T>(cl_arr: CommandQueue<CLArray<T>>): CLKernelArgConstant; where T: record;
    public static function operator implicit<T>(cl_arr: CLArray<T>): CLKernelArgConstant; where T: record;
    begin Result := FromCLArray&<T>(cl_arr) end;
    public static function operator implicit<T>(cl_arr: CommandQueue<CLArray<T>>): CLKernelArgConstant; where T: record;
    begin Result := FromCLArray&<T>(cl_arr) end;
    public static function operator implicit<T>(cl_arr: ConstQueue<CLArray<T>>): CLKernelArgConstant; where T: record;
    begin Result := FromCLArray&<T>(cl_arr) end;
    public static function operator implicit<T>(cl_arr: ParameterQueue<CLArray<T>>): CLKernelArgConstant; where T: record;
    begin Result := FromCLArray&<T>(cl_arr) end;
    public static function operator implicit<T>(cl_arr: CLArrayCCQ<T>): CLKernelArgConstant; where T: record;
    
    {$endregion CLArray}
    
    {$endregion CL}
    
  end;
  
  {$endregion Constant}
  
  {$region Local}
  
  CLKernelArgLocal = abstract partial class(CLKernelArg)
    
    {$region FromBytes}
    
    public static function FromBytes(bytes: CommandQueue<UIntPtr>): CLKernelArgLocal;
    public static function FromBytes(bytes: CommandQueue<UInt32>) := FromBytes(bytes.ThenConvert(bytes->new UIntPtr(bytes), false,true));
    public static function FromBytes(bytes: CommandQueue<Int32>) := FromBytes(bytes.ThenConvert(bytes->new UIntPtr(bytes), false,true));
    public static function FromBytes(bytes: CommandQueue<UInt64>) := FromBytes(bytes.ThenConvert(bytes->new UIntPtr(bytes), false,true));
    public static function FromBytes(bytes: CommandQueue<Int64>) := FromBytes(bytes.ThenConvert(bytes->new UIntPtr(bytes), false,true));
    
    {$endregion FromBytes}
    
    {$region FromItemCount}
    
    public static function FromItemCount<T>(item_count: CommandQueue<UInt32>): CLKernelArgLocal; where T: record;
    public static function FromItemCount<T>(item_count: CommandQueue<Int32>): CLKernelArgLocal; where T: record;
    
    {$endregion FromItemCount}
    
    {$region LikeArray}
    
    public static function LikeArray<T>(a: CommandQueue<array of T>): CLKernelArgLocal; where T: record;
    begin Result := FromItemCount&<T>(a.ThenConvert(a->a.Length, false,true)) end;
    public static function LikeArray<T>(a: array of T): CLKernelArgLocal; where T: record;
    begin Result := FromItemCount&<T>(a.Length) end;
    
    public static function LikeArray2<T>(a: CommandQueue<array[,] of T>): CLKernelArgLocal; where T: record;
    begin Result := FromItemCount&<T>(a.ThenConvert(a->a.Length, false,true)) end;
    public static function LikeArray2<T>(a: array[,] of T): CLKernelArgLocal; where T: record;
    begin Result := FromItemCount&<T>(a.Length) end;
    
    public static function LikeArray3<T>(a: CommandQueue<array[,,] of T>): CLKernelArgLocal; where T: record;
    begin Result := FromItemCount&<T>(a.ThenConvert(a->a.Length, false,true)) end;
    public static function LikeArray3<T>(a: array[,,] of T): CLKernelArgLocal; where T: record;
    begin Result := FromItemCount&<T>(a.Length) end;
    
    public static function LikeNativeArrayArea<T>(a: CommandQueue<NativeArrayArea<T>>): CLKernelArgLocal; where T: record;
    begin Result := FromItemCount&<T>(a.ThenConvert(a->a.Length, false,true)) end;
    public static function LikeNativeArrayArea<T>(a: NativeArrayArea<T>): CLKernelArgLocal; where T: record;
    begin Result := FromItemCount&<T>(a.Length) end;
    
    public static function LikeNativeArray<T>(a: CommandQueue<NativeArray<T>>): CLKernelArgLocal; where T: record;
    begin Result := FromItemCount&<T>(a.ThenConvert(a->a.Length, false,true)) end;
    public static function LikeNativeArray<T>(a: NativeArray<T>): CLKernelArgLocal; where T: record;
    begin Result := FromItemCount&<T>(a.Length) end;
    
    public static function LikeCLArray<T>(a: CommandQueue<CLArray<T>>): CLKernelArgLocal; where T: record;
    begin Result := FromItemCount&<T>(a.ThenConvert(a->a.Length, false,true)) end;
    public static function LikeCLArray<T>(a: CLArray<T>): CLKernelArgLocal; where T: record;
    begin Result := FromItemCount&<T>(a.Length) end;
    
    {$endregion LikeArray}
    
  end;
  
  {$endregion Local}
  
  {$region Private}
  
  CLKernelArgPrivate = abstract partial class(CLKernelArg)
    
    {$region Managed}
    
    {$region Array}
    
    public static function FromArray<T>(a: CommandQueue<array of T>): CLKernelArgPrivate; where T: record;
    public static function operator implicit<T>(a: array of T): CLKernelArgPrivate; where T: record;
    begin Result := FromArray&<T>(a) end;
    public static function operator implicit<T>(a: CommandQueue<array of T>): CLKernelArgPrivate; where T: record;
    begin Result := FromArray&<T>(a) end;
    public static function operator implicit<T>(a: ConstQueue<array of T>): CLKernelArgPrivate; where T: record;
    begin Result := FromArray&<T>(a) end;
    public static function operator implicit<T>(a: ParameterQueue<array of T>): CLKernelArgPrivate; where T: record;
    begin Result := FromArray&<T>(a) end;
    
    {$endregion Array}
    
    {$region Array2}
    
    public static function FromArray2<T>(a2: CommandQueue<array[,] of T>): CLKernelArgPrivate; where T: record;
    public static function operator implicit<T>(a2: array[,] of T): CLKernelArgPrivate; where T: record;
    begin Result := FromArray2&<T>(a2) end;
    public static function operator implicit<T>(a2: CommandQueue<array[,] of T>): CLKernelArgPrivate; where T: record;
    begin Result := FromArray2&<T>(a2) end;
    public static function operator implicit<T>(a2: ConstQueue<array[,] of T>): CLKernelArgPrivate; where T: record;
    begin Result := FromArray2&<T>(a2) end;
    public static function operator implicit<T>(a2: ParameterQueue<array[,] of T>): CLKernelArgPrivate; where T: record;
    begin Result := FromArray2&<T>(a2) end;
    
    {$endregion Array2}
    
    {$region Array3}
    
    public static function FromArray3<T>(a3: CommandQueue<array[,,] of T>): CLKernelArgPrivate; where T: record;
    public static function operator implicit<T>(a3: array[,,] of T): CLKernelArgPrivate; where T: record;
    begin Result := FromArray3&<T>(a3) end;
    public static function operator implicit<T>(a3: CommandQueue<array[,,] of T>): CLKernelArgPrivate; where T: record;
    begin Result := FromArray3&<T>(a3) end;
    public static function operator implicit<T>(a3: ConstQueue<array[,,] of T>): CLKernelArgPrivate; where T: record;
    begin Result := FromArray3&<T>(a3) end;
    public static function operator implicit<T>(a3: ParameterQueue<array[,,] of T>): CLKernelArgPrivate; where T: record;
    begin Result := FromArray3&<T>(a3) end;
    
    {$endregion Array3}
    
    {$region ArraySegment}
    
    public static function FromArraySegment<T>(seg: CommandQueue<ArraySegment<T>>): CLKernelArgPrivate; where T: record;
    public static function operator implicit<T>(seg: ArraySegment<T>): CLKernelArgPrivate; where T: record;
    begin Result := FromArraySegment&<T>(seg) end;
    public static function operator implicit<T>(seg: CommandQueue<ArraySegment<T>>): CLKernelArgPrivate; where T: record;
    begin Result := FromArraySegment&<T>(seg) end;
    public static function operator implicit<T>(seg: ConstQueue<ArraySegment<T>>): CLKernelArgPrivate; where T: record;
    begin Result := FromArraySegment&<T>(seg) end;
    public static function operator implicit<T>(seg: ParameterQueue<ArraySegment<T>>): CLKernelArgPrivate; where T: record;
    begin Result := FromArraySegment&<T>(seg) end;
    
    {$endregion ArraySegment}
    
    {$endregion Managed}
    
    {$region NativeArea}
    
    {$region NativeMemoryArea}
    
    public static function FromNativeMemoryArea(ntv_mem_area: CommandQueue<NativeMemoryArea>): CLKernelArgPrivate;
    public static function operator implicit(ntv_mem_area: NativeMemoryArea): CLKernelArgPrivate;
    begin Result := FromNativeMemoryArea(ntv_mem_area) end;
    public static function operator implicit(ntv_mem_area: CommandQueue<NativeMemoryArea>): CLKernelArgPrivate;
    begin Result := FromNativeMemoryArea(ntv_mem_area) end;
    public static function operator implicit(ntv_mem_area: ConstQueue<NativeMemoryArea>): CLKernelArgPrivate;
    begin Result := FromNativeMemoryArea(ntv_mem_area) end;
    public static function operator implicit(ntv_mem_area: ParameterQueue<NativeMemoryArea>): CLKernelArgPrivate;
    begin Result := FromNativeMemoryArea(ntv_mem_area) end;
    
    {$endregion NativeMemoryArea}
    
    {$region NativeValueArea}
    
    public static function FromNativeValueArea<T>(ntv_val_area: CommandQueue<NativeValueArea<T>>): CLKernelArgPrivate; where T: record;
    public static function operator implicit<T>(ntv_val_area: NativeValueArea<T>): CLKernelArgPrivate; where T: record;
    begin Result := FromNativeValueArea&<T>(ntv_val_area) end;
    public static function operator implicit<T>(ntv_val_area: CommandQueue<NativeValueArea<T>>): CLKernelArgPrivate; where T: record;
    begin Result := FromNativeValueArea&<T>(ntv_val_area) end;
    public static function operator implicit<T>(ntv_val_area: ConstQueue<NativeValueArea<T>>): CLKernelArgPrivate; where T: record;
    begin Result := FromNativeValueArea&<T>(ntv_val_area) end;
    public static function operator implicit<T>(ntv_val_area: ParameterQueue<NativeValueArea<T>>): CLKernelArgPrivate; where T: record;
    begin Result := FromNativeValueArea&<T>(ntv_val_area) end;
    
    {$endregion NativeValueArea}
    
    {$region NativeArrayArea}
    
    public static function FromNativeArrayArea<T>(ntv_arr_area: CommandQueue<NativeArrayArea<T>>): CLKernelArgPrivate; where T: record;
    public static function operator implicit<T>(ntv_arr_area: NativeArrayArea<T>): CLKernelArgPrivate; where T: record;
    begin Result := FromNativeArrayArea&<T>(ntv_arr_area) end;
    public static function operator implicit<T>(ntv_arr_area: CommandQueue<NativeArrayArea<T>>): CLKernelArgPrivate; where T: record;
    begin Result := FromNativeArrayArea&<T>(ntv_arr_area) end;
    public static function operator implicit<T>(ntv_arr_area: ConstQueue<NativeArrayArea<T>>): CLKernelArgPrivate; where T: record;
    begin Result := FromNativeArrayArea&<T>(ntv_arr_area) end;
    public static function operator implicit<T>(ntv_arr_area: ParameterQueue<NativeArrayArea<T>>): CLKernelArgPrivate; where T: record;
    begin Result := FromNativeArrayArea&<T>(ntv_arr_area) end;
    
    {$endregion NativeArrayArea}
    
    {$endregion NativeArea}
    
    {$region Native}
    
    {$region NativeMemory}
    
    public static function FromNativeMemory(ntv_mem: CommandQueue<NativeMemory>): CLKernelArgPrivate;
    public static function operator implicit(ntv_mem: NativeMemory): CLKernelArgPrivate;
    begin Result := FromNativeMemory(ntv_mem) end;
    public static function operator implicit(ntv_mem: CommandQueue<NativeMemory>): CLKernelArgPrivate;
    begin Result := FromNativeMemory(ntv_mem) end;
    public static function operator implicit(ntv_mem: ConstQueue<NativeMemory>): CLKernelArgPrivate;
    begin Result := FromNativeMemory(ntv_mem) end;
    public static function operator implicit(ntv_mem: ParameterQueue<NativeMemory>): CLKernelArgPrivate;
    begin Result := FromNativeMemory(ntv_mem) end;
    
    {$endregion NativeMemory}
    
    {$region NativeValue}
    
    public static function FromNativeValue<T>(ntv_val: CommandQueue<NativeValue<T>>): CLKernelArgPrivate; where T: record;
    public static function operator implicit<T>(ntv_val: NativeValue<T>): CLKernelArgPrivate; where T: record;
    begin Result := FromNativeValue&<T>(ntv_val) end;
    public static function operator implicit<T>(ntv_val: CommandQueue<NativeValue<T>>): CLKernelArgPrivate; where T: record;
    begin Result := FromNativeValue&<T>(ntv_val) end;
    public static function operator implicit<T>(ntv_val: ConstQueue<NativeValue<T>>): CLKernelArgPrivate; where T: record;
    begin Result := FromNativeValue&<T>(ntv_val) end;
    public static function operator implicit<T>(ntv_val: ParameterQueue<NativeValue<T>>): CLKernelArgPrivate; where T: record;
    begin Result := FromNativeValue&<T>(ntv_val) end;
    
    {$endregion NativeValue}
    
    {$region NativeArray}
    
    public static function FromNativeArray<T>(ntv_arr: CommandQueue<NativeArray<T>>): CLKernelArgPrivate; where T: record;
    public static function operator implicit<T>(ntv_arr: NativeArray<T>): CLKernelArgPrivate; where T: record;
    begin Result := FromNativeArray&<T>(ntv_arr) end;
    public static function operator implicit<T>(ntv_arr: CommandQueue<NativeArray<T>>): CLKernelArgPrivate; where T: record;
    begin Result := FromNativeArray&<T>(ntv_arr) end;
    public static function operator implicit<T>(ntv_arr: ConstQueue<NativeArray<T>>): CLKernelArgPrivate; where T: record;
    begin Result := FromNativeArray&<T>(ntv_arr) end;
    public static function operator implicit<T>(ntv_arr: ParameterQueue<NativeArray<T>>): CLKernelArgPrivate; where T: record;
    begin Result := FromNativeArray&<T>(ntv_arr) end;
    
    {$endregion NativeArray}
    
    {$endregion Native}
    
    {$region Value}
    
    public static function FromValue<T>(val: CommandQueue<T>): CLKernelArgPrivate; where T: record;
    public static function operator implicit<T>(val: T): CLKernelArgPrivate; where T: record;
    begin Result := FromValue&<T>(val) end;
    public static function operator implicit<T>(val: CommandQueue<T>): CLKernelArgPrivate; where T: record;
    begin Result := FromValue&<T>(val) end;
    public static function operator implicit<T>(val: ConstQueue<T>): CLKernelArgPrivate; where T: record;
    begin Result := FromValue&<T>(val) end;
    public static function operator implicit<T>(val: ParameterQueue<T>): CLKernelArgPrivate; where T: record;
    begin Result := FromValue&<T>(val) end;
    
    {$endregion Value}
    
  end;
  
  {$endregion Private}
  
  {$region Generic}
  
  CLKernelArg = abstract partial class
    
    {$region Managed}
    
    {$region Array}
    
    public static function FromArray<T>(a: CommandQueue<array of T>): CLKernelArg; where T: record;
    public static function operator implicit<T>(a: array of T): CLKernelArg; where T: record;
    begin Result := FromArray&<T>(a) end;
    public static function operator implicit<T>(a: CommandQueue<array of T>): CLKernelArg; where T: record;
    begin Result := FromArray&<T>(a) end;
    public static function operator implicit<T>(a: ConstQueue<array of T>): CLKernelArg; where T: record;
    begin Result := FromArray&<T>(a) end;
    public static function operator implicit<T>(a: ParameterQueue<array of T>): CLKernelArg; where T: record;
    begin Result := FromArray&<T>(a) end;
    
    {$endregion Array}
    
    {$region Array2}
    
    public static function FromArray2<T>(a2: CommandQueue<array[,] of T>): CLKernelArg; where T: record;
    public static function operator implicit<T>(a2: array[,] of T): CLKernelArg; where T: record;
    begin Result := FromArray2&<T>(a2) end;
    public static function operator implicit<T>(a2: CommandQueue<array[,] of T>): CLKernelArg; where T: record;
    begin Result := FromArray2&<T>(a2) end;
    public static function operator implicit<T>(a2: ConstQueue<array[,] of T>): CLKernelArg; where T: record;
    begin Result := FromArray2&<T>(a2) end;
    public static function operator implicit<T>(a2: ParameterQueue<array[,] of T>): CLKernelArg; where T: record;
    begin Result := FromArray2&<T>(a2) end;
    
    {$endregion Array2}
    
    {$region Array3}
    
    public static function FromArray3<T>(a3: CommandQueue<array[,,] of T>): CLKernelArg; where T: record;
    public static function operator implicit<T>(a3: array[,,] of T): CLKernelArg; where T: record;
    begin Result := FromArray3&<T>(a3) end;
    public static function operator implicit<T>(a3: CommandQueue<array[,,] of T>): CLKernelArg; where T: record;
    begin Result := FromArray3&<T>(a3) end;
    public static function operator implicit<T>(a3: ConstQueue<array[,,] of T>): CLKernelArg; where T: record;
    begin Result := FromArray3&<T>(a3) end;
    public static function operator implicit<T>(a3: ParameterQueue<array[,,] of T>): CLKernelArg; where T: record;
    begin Result := FromArray3&<T>(a3) end;
    
    {$endregion Array3}
    
    {$region ArraySegment}
    
    public static function FromArraySegment<T>(seg: CommandQueue<ArraySegment<T>>): CLKernelArg; where T: record;
    public static function operator implicit<T>(seg: ArraySegment<T>): CLKernelArg; where T: record;
    begin Result := FromArraySegment&<T>(seg) end;
    public static function operator implicit<T>(seg: CommandQueue<ArraySegment<T>>): CLKernelArg; where T: record;
    begin Result := FromArraySegment&<T>(seg) end;
    public static function operator implicit<T>(seg: ConstQueue<ArraySegment<T>>): CLKernelArg; where T: record;
    begin Result := FromArraySegment&<T>(seg) end;
    public static function operator implicit<T>(seg: ParameterQueue<ArraySegment<T>>): CLKernelArg; where T: record;
    begin Result := FromArraySegment&<T>(seg) end;
    
    {$endregion ArraySegment}
    
    {$endregion Managed}
    
    {$region NativeArea}
    
    {$region NativeMemoryArea}
    
    public static function FromNativeMemoryArea(ntv_mem_area: CommandQueue<NativeMemoryArea>): CLKernelArg;
    public static function operator implicit(ntv_mem_area: NativeMemoryArea): CLKernelArg;
    begin Result := FromNativeMemoryArea(ntv_mem_area) end;
    public static function operator implicit(ntv_mem_area: CommandQueue<NativeMemoryArea>): CLKernelArg;
    begin Result := FromNativeMemoryArea(ntv_mem_area) end;
    public static function operator implicit(ntv_mem_area: ConstQueue<NativeMemoryArea>): CLKernelArg;
    begin Result := FromNativeMemoryArea(ntv_mem_area) end;
    public static function operator implicit(ntv_mem_area: ParameterQueue<NativeMemoryArea>): CLKernelArg;
    begin Result := FromNativeMemoryArea(ntv_mem_area) end;
    
    {$endregion NativeMemoryArea}
    
    {$region NativeValueArea}
    
    public static function FromNativeValueArea<T>(ntv_val_area: CommandQueue<NativeValueArea<T>>): CLKernelArg; where T: record;
    public static function operator implicit<T>(ntv_val_area: NativeValueArea<T>): CLKernelArg; where T: record;
    begin Result := FromNativeValueArea&<T>(ntv_val_area) end;
    public static function operator implicit<T>(ntv_val_area: CommandQueue<NativeValueArea<T>>): CLKernelArg; where T: record;
    begin Result := FromNativeValueArea&<T>(ntv_val_area) end;
    public static function operator implicit<T>(ntv_val_area: ConstQueue<NativeValueArea<T>>): CLKernelArg; where T: record;
    begin Result := FromNativeValueArea&<T>(ntv_val_area) end;
    public static function operator implicit<T>(ntv_val_area: ParameterQueue<NativeValueArea<T>>): CLKernelArg; where T: record;
    begin Result := FromNativeValueArea&<T>(ntv_val_area) end;
    
    {$endregion NativeValueArea}
    
    {$region NativeArrayArea}
    
    public static function FromNativeArrayArea<T>(ntv_arr_area: CommandQueue<NativeArrayArea<T>>): CLKernelArg; where T: record;
    public static function operator implicit<T>(ntv_arr_area: NativeArrayArea<T>): CLKernelArg; where T: record;
    begin Result := FromNativeArrayArea&<T>(ntv_arr_area) end;
    public static function operator implicit<T>(ntv_arr_area: CommandQueue<NativeArrayArea<T>>): CLKernelArg; where T: record;
    begin Result := FromNativeArrayArea&<T>(ntv_arr_area) end;
    public static function operator implicit<T>(ntv_arr_area: ConstQueue<NativeArrayArea<T>>): CLKernelArg; where T: record;
    begin Result := FromNativeArrayArea&<T>(ntv_arr_area) end;
    public static function operator implicit<T>(ntv_arr_area: ParameterQueue<NativeArrayArea<T>>): CLKernelArg; where T: record;
    begin Result := FromNativeArrayArea&<T>(ntv_arr_area) end;
    
    {$endregion NativeArrayArea}
    
    {$endregion NativeArea}
    
    {$region Native}
    
    {$region NativeMemory}
    
    public static function FromNativeMemory(ntv_mem: CommandQueue<NativeMemory>): CLKernelArg;
    public static function operator implicit(ntv_mem: NativeMemory): CLKernelArg;
    begin Result := FromNativeMemory(ntv_mem) end;
    public static function operator implicit(ntv_mem: CommandQueue<NativeMemory>): CLKernelArg;
    begin Result := FromNativeMemory(ntv_mem) end;
    public static function operator implicit(ntv_mem: ConstQueue<NativeMemory>): CLKernelArg;
    begin Result := FromNativeMemory(ntv_mem) end;
    public static function operator implicit(ntv_mem: ParameterQueue<NativeMemory>): CLKernelArg;
    begin Result := FromNativeMemory(ntv_mem) end;
    
    {$endregion NativeMemory}
    
    {$region NativeValue}
    
    public static function FromNativeValue<T>(ntv_val: CommandQueue<NativeValue<T>>): CLKernelArg; where T: record;
    public static function operator implicit<T>(ntv_val: NativeValue<T>): CLKernelArg; where T: record;
    begin Result := FromNativeValue&<T>(ntv_val) end;
    public static function operator implicit<T>(ntv_val: CommandQueue<NativeValue<T>>): CLKernelArg; where T: record;
    begin Result := FromNativeValue&<T>(ntv_val) end;
    public static function operator implicit<T>(ntv_val: ConstQueue<NativeValue<T>>): CLKernelArg; where T: record;
    begin Result := FromNativeValue&<T>(ntv_val) end;
    public static function operator implicit<T>(ntv_val: ParameterQueue<NativeValue<T>>): CLKernelArg; where T: record;
    begin Result := FromNativeValue&<T>(ntv_val) end;
    
    {$endregion NativeValue}
    
    {$region NativeArray}
    
    public static function FromNativeArray<T>(ntv_arr: CommandQueue<NativeArray<T>>): CLKernelArg; where T: record;
    public static function operator implicit<T>(ntv_arr: NativeArray<T>): CLKernelArg; where T: record;
    begin Result := FromNativeArray&<T>(ntv_arr) end;
    public static function operator implicit<T>(ntv_arr: CommandQueue<NativeArray<T>>): CLKernelArg; where T: record;
    begin Result := FromNativeArray&<T>(ntv_arr) end;
    public static function operator implicit<T>(ntv_arr: ConstQueue<NativeArray<T>>): CLKernelArg; where T: record;
    begin Result := FromNativeArray&<T>(ntv_arr) end;
    public static function operator implicit<T>(ntv_arr: ParameterQueue<NativeArray<T>>): CLKernelArg; where T: record;
    begin Result := FromNativeArray&<T>(ntv_arr) end;
    
    {$endregion NativeArray}
    
    {$endregion Native}
    
    {$region CL}
    
    {$region CLMemory}
    
    public static function FromCLMemory(cl_mem: CommandQueue<CLMemory>): CLKernelArg;
    public static function operator implicit(cl_mem: CLMemory): CLKernelArg;
    begin Result := FromCLMemory(cl_mem) end;
    public static function operator implicit(cl_mem: CommandQueue<CLMemory>): CLKernelArg;
    begin Result := FromCLMemory(cl_mem) end;
    public static function operator implicit(cl_mem: ConstQueue<CLMemory>): CLKernelArg;
    begin Result := FromCLMemory(cl_mem) end;
    public static function operator implicit(cl_mem: ParameterQueue<CLMemory>): CLKernelArg;
    begin Result := FromCLMemory(cl_mem) end;
    public static function operator implicit(cl_mem: CLMemoryCCQ): CLKernelArg;
    
    {$endregion CLMemory}
    
    {$region CLValue}
    
    public static function FromCLValue<T>(cl_val: CommandQueue<CLValue<T>>): CLKernelArg; where T: record;
    public static function operator implicit<T>(cl_val: CLValue<T>): CLKernelArg; where T: record;
    begin Result := FromCLValue&<T>(cl_val) end;
    public static function operator implicit<T>(cl_val: CommandQueue<CLValue<T>>): CLKernelArg; where T: record;
    begin Result := FromCLValue&<T>(cl_val) end;
    public static function operator implicit<T>(cl_val: ConstQueue<CLValue<T>>): CLKernelArg; where T: record;
    begin Result := FromCLValue&<T>(cl_val) end;
    public static function operator implicit<T>(cl_val: ParameterQueue<CLValue<T>>): CLKernelArg; where T: record;
    begin Result := FromCLValue&<T>(cl_val) end;
    public static function operator implicit<T>(cl_val: CLValueCCQ<T>): CLKernelArg; where T: record;
    
    {$endregion CLValue}
    
    {$region CLArray}
    
    public static function FromCLArray<T>(cl_arr: CommandQueue<CLArray<T>>): CLKernelArg; where T: record;
    public static function operator implicit<T>(cl_arr: CLArray<T>): CLKernelArg; where T: record;
    begin Result := FromCLArray&<T>(cl_arr) end;
    public static function operator implicit<T>(cl_arr: CommandQueue<CLArray<T>>): CLKernelArg; where T: record;
    begin Result := FromCLArray&<T>(cl_arr) end;
    public static function operator implicit<T>(cl_arr: ConstQueue<CLArray<T>>): CLKernelArg; where T: record;
    begin Result := FromCLArray&<T>(cl_arr) end;
    public static function operator implicit<T>(cl_arr: ParameterQueue<CLArray<T>>): CLKernelArg; where T: record;
    begin Result := FromCLArray&<T>(cl_arr) end;
    public static function operator implicit<T>(cl_arr: CLArrayCCQ<T>): CLKernelArg; where T: record;
    
    {$endregion CLArray}
    
    {$endregion CL}
    
    {$region Value}
    
    public static function FromValue<T>(val: CommandQueue<T>): CLKernelArg; where T: record;
    public static function operator implicit<T>(val: T): CLKernelArg; where T: record;
    begin Result := FromValue&<T>(val) end;
    public static function operator implicit<T>(val: CommandQueue<T>): CLKernelArg; where T: record;
    begin Result := FromValue&<T>(val) end;
    public static function operator implicit<T>(val: ConstQueue<T>): CLKernelArg; where T: record;
    begin Result := FromValue&<T>(val) end;
    public static function operator implicit<T>(val: ParameterQueue<T>): CLKernelArg; where T: record;
    begin Result := FromValue&<T>(val) end;
    
    {$endregion Value}
    
  end;
  
  {$endregion Generic}
  
  {$region ToString}
  
  CLKernelArg = abstract partial class
    
    {$region ToString}
    
    private static procedure ToStringRuntimeValue<T>(sb: StringBuilder; val: T) := CommandQueueBase.ToStringRuntimeValue(sb, val);
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); abstract;
    
    private procedure ToString(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>; write_tabs: boolean := true);
    begin
      if write_tabs then sb.Append(#9, tabs);
      sb += TypeName(self);
      
      ToStringImpl(sb, tabs+1, index, delayed);
      
      if tabs=0 then foreach var q in delayed do
      begin
        sb += #10;
        q.ToString(sb, 0, index, new HashSet<CommandQueueBase>);
      end;
      
    end;
    
    public function ToString: string; override;
    begin
      var sb := new StringBuilder;
      ToString(sb, 0, new Dictionary<object, integer>, new HashSet<CommandQueueBase>);
      Result := sb.ToString;
    end;
    
    public function Print: CLKernelArg;
    begin
      Write(self.ToString);
      Result := self;
    end;
    public function Println: CLKernelArg;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    {$endregion ToString}
    
  end;
  
  {$endregion ToString}
  
  {$endregion CLKernelArg}
  
{$region Global subprograms}

{$region ConstQueue}

function CQNil: CommandQueueNil;
///Создаёт константную очередь с указанным результатом
function CQ<T>(o: T): CommandQueue<T>;

{$endregion ConstQueue}

{$region HPQ/HFQ}

function HPQ(p: ()->(); need_own_thread: boolean := true): CommandQueueNil;
function HPQ(p: CLContext->(); need_own_thread: boolean := true): CommandQueueNil;

function HFQ<T>(f: ()->T; need_own_thread: boolean := true): CommandQueue<T>;
function HFQ<T>(f: CLContext->T; need_own_thread: boolean := true): CommandQueue<T>;

{$endregion HPQ/HFQ}

{$region Wait}

function CombineWaitAll(params sub_markers: array of WaitMarker): WaitMarker;
function CombineWaitAll(sub_markers: sequence of WaitMarker): WaitMarker;

function CombineWaitAny(params sub_markers: array of WaitMarker): WaitMarker;
function CombineWaitAny(sub_markers: sequence of WaitMarker): WaitMarker;

///Создаёт очередь, ожидающую сигнала выполненности от заданного маркера
function WaitFor(marker: WaitMarker): CommandQueueNil;

{$endregion Wait}

{$region CombineQueue's}

{$region Sync}

{$region Simple}

function CombineSyncQueue(params qs: array of CommandQueueBase): CommandQueueBase;
function CombineSyncQueue(params qs: array of CommandQueueNil): CommandQueueNil;
///Создаёт очередь, выполняющую указанные очереди одну за другой
///И возвращающую результат последней очереди
function CombineSyncQueue<T>(params qs: array of CommandQueue<T>): CommandQueue<T>;

function CombineSyncQueue<TQ>(qs: array of TQ; last: CommandQueueBase): CommandQueueBase; where TQ: CommandQueueBase;
function CombineSyncQueue<TQ>(qs: array of TQ; last: CommandQueueNil): CommandQueueNil; where TQ: CommandQueueBase;
function CombineSyncQueue<T, TQ>(qs: array of TQ; last: CommandQueue<T>): CommandQueue<T>; where TQ: CommandQueueBase;

{$endregion Simple}

{$region Conv}

{$region NonContext}

function CombineConvSyncQueue<TInp, TRes>(conv: Func<array of TInp, TRes>; qs: array of CommandQueue<TInp>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<TRes>;

function CombineConvSyncQueueN2<TInp1,TInp2, TRes>(conv: Func<TInp1, TInp2, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<TRes>;
function CombineConvSyncQueueN3<TInp1,TInp2,TInp3, TRes>(conv: Func<TInp1, TInp2, TInp3, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<TRes>;
function CombineConvSyncQueueN4<TInp1,TInp2,TInp3,TInp4, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<TRes>;
function CombineConvSyncQueueN5<TInp1,TInp2,TInp3,TInp4,TInp5, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TInp5, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<TRes>;
function CombineConvSyncQueueN6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<TRes>;
function CombineConvSyncQueueN7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<TRes>;

{$endregion NonContext}

{$region Context}

function CombineConvSyncQueue<TInp, TRes>(conv: Func<array of TInp, CLContext, TRes>; qs: array of CommandQueue<TInp>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<TRes>;

function CombineConvSyncQueueN2<TInp1,TInp2, TRes>(conv: Func<TInp1, TInp2, CLContext, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<TRes>;
function CombineConvSyncQueueN3<TInp1,TInp2,TInp3, TRes>(conv: Func<TInp1, TInp2, TInp3, CLContext, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<TRes>;
function CombineConvSyncQueueN4<TInp1,TInp2,TInp3,TInp4, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, CLContext, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<TRes>;
function CombineConvSyncQueueN5<TInp1,TInp2,TInp3,TInp4,TInp5, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TInp5, CLContext, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<TRes>;
function CombineConvSyncQueueN6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, CLContext, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<TRes>;
function CombineConvSyncQueueN7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, CLContext, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<TRes>;

{$endregion Context}

{$endregion Conv}

{$region Use}

{$region NonContext}

function CombineUseSyncQueue<TInp>(use: Action<array of TInp>; qs: array of CommandQueue<TInp>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<array of TInp>;

function CombineUseSyncQueueN2<TInp1,TInp2>(use: Action<TInp1, TInp2>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<ValueTuple<TInp1,TInp2>>;
function CombineUseSyncQueueN3<TInp1,TInp2,TInp3>(use: Action<TInp1, TInp2, TInp3>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<ValueTuple<TInp1,TInp2,TInp3>>;
function CombineUseSyncQueueN4<TInp1,TInp2,TInp3,TInp4>(use: Action<TInp1, TInp2, TInp3, TInp4>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4>>;
function CombineUseSyncQueueN5<TInp1,TInp2,TInp3,TInp4,TInp5>(use: Action<TInp1, TInp2, TInp3, TInp4, TInp5>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5>>;
function CombineUseSyncQueueN6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>(use: Action<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>>;
function CombineUseSyncQueueN7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>(use: Action<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>>;

{$endregion NonContext}

{$region Context}

function CombineUseSyncQueue<TInp>(use: Action<array of TInp, CLContext>; qs: array of CommandQueue<TInp>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<array of TInp>;

function CombineUseSyncQueueN2<TInp1,TInp2>(use: Action<TInp1, TInp2, CLContext>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<ValueTuple<TInp1,TInp2>>;
function CombineUseSyncQueueN3<TInp1,TInp2,TInp3>(use: Action<TInp1, TInp2, TInp3, CLContext>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<ValueTuple<TInp1,TInp2,TInp3>>;
function CombineUseSyncQueueN4<TInp1,TInp2,TInp3,TInp4>(use: Action<TInp1, TInp2, TInp3, TInp4, CLContext>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4>>;
function CombineUseSyncQueueN5<TInp1,TInp2,TInp3,TInp4,TInp5>(use: Action<TInp1, TInp2, TInp3, TInp4, TInp5, CLContext>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5>>;
function CombineUseSyncQueueN6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>(use: Action<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, CLContext>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>>;
function CombineUseSyncQueueN7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>(use: Action<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, CLContext>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>>;

{$endregion Context}

{$endregion Use}

{$endregion Sync}

{$region Async}

{$region Simple}

function CombineAsyncQueue(params qs: array of CommandQueueBase): CommandQueueBase;
function CombineAsyncQueue(params qs: array of CommandQueueNil): CommandQueueNil;
///Создаёт очередь, выполняющую указанные очереди одновременно
///И возвращающую результат последней очереди
function CombineAsyncQueue<T>(params qs: array of CommandQueue<T>): CommandQueue<T>;

function CombineAsyncQueue<TQ>(qs: array of TQ; last: CommandQueueBase): CommandQueueBase; where TQ: CommandQueueBase;
function CombineAsyncQueue<TQ>(qs: array of TQ; last: CommandQueueNil): CommandQueueNil; where TQ: CommandQueueBase;
function CombineAsyncQueue<T, TQ>(qs: array of TQ; last: CommandQueue<T>): CommandQueue<T>; where TQ: CommandQueueBase;

{$endregion Simple}

{$region Conv}

{$region NonContext}

function CombineConvAsyncQueue<TInp, TRes>(conv: Func<array of TInp, TRes>; qs: array of CommandQueue<TInp>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<TRes>;

function CombineConvAsyncQueueN2<TInp1,TInp2, TRes>(conv: Func<TInp1, TInp2, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<TRes>;
function CombineConvAsyncQueueN3<TInp1,TInp2,TInp3, TRes>(conv: Func<TInp1, TInp2, TInp3, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<TRes>;
function CombineConvAsyncQueueN4<TInp1,TInp2,TInp3,TInp4, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<TRes>;
function CombineConvAsyncQueueN5<TInp1,TInp2,TInp3,TInp4,TInp5, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TInp5, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<TRes>;
function CombineConvAsyncQueueN6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<TRes>;
function CombineConvAsyncQueueN7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<TRes>;

{$endregion NonContext}

{$region Context}

function CombineConvAsyncQueue<TInp, TRes>(conv: Func<array of TInp, CLContext, TRes>; qs: array of CommandQueue<TInp>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<TRes>;

function CombineConvAsyncQueueN2<TInp1,TInp2, TRes>(conv: Func<TInp1, TInp2, CLContext, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<TRes>;
function CombineConvAsyncQueueN3<TInp1,TInp2,TInp3, TRes>(conv: Func<TInp1, TInp2, TInp3, CLContext, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<TRes>;
function CombineConvAsyncQueueN4<TInp1,TInp2,TInp3,TInp4, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, CLContext, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<TRes>;
function CombineConvAsyncQueueN5<TInp1,TInp2,TInp3,TInp4,TInp5, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TInp5, CLContext, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<TRes>;
function CombineConvAsyncQueueN6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, CLContext, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<TRes>;
function CombineConvAsyncQueueN7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, CLContext, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<TRes>;

{$endregion Context}

{$endregion Conv}

{$region Use}

{$region NonContext}

function CombineUseAsyncQueue<TInp>(use: Action<array of TInp>; qs: array of CommandQueue<TInp>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<array of TInp>;

function CombineUseAsyncQueueN2<TInp1,TInp2>(use: Action<TInp1, TInp2>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<ValueTuple<TInp1,TInp2>>;
function CombineUseAsyncQueueN3<TInp1,TInp2,TInp3>(use: Action<TInp1, TInp2, TInp3>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<ValueTuple<TInp1,TInp2,TInp3>>;
function CombineUseAsyncQueueN4<TInp1,TInp2,TInp3,TInp4>(use: Action<TInp1, TInp2, TInp3, TInp4>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4>>;
function CombineUseAsyncQueueN5<TInp1,TInp2,TInp3,TInp4,TInp5>(use: Action<TInp1, TInp2, TInp3, TInp4, TInp5>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5>>;
function CombineUseAsyncQueueN6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>(use: Action<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>>;
function CombineUseAsyncQueueN7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>(use: Action<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>>;

{$endregion NonContext}

{$region Context}

function CombineUseAsyncQueue<TInp>(use: Action<array of TInp, CLContext>; qs: array of CommandQueue<TInp>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<array of TInp>;

function CombineUseAsyncQueueN2<TInp1,TInp2>(use: Action<TInp1, TInp2, CLContext>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<ValueTuple<TInp1,TInp2>>;
function CombineUseAsyncQueueN3<TInp1,TInp2,TInp3>(use: Action<TInp1, TInp2, TInp3, CLContext>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<ValueTuple<TInp1,TInp2,TInp3>>;
function CombineUseAsyncQueueN4<TInp1,TInp2,TInp3,TInp4>(use: Action<TInp1, TInp2, TInp3, TInp4, CLContext>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4>>;
function CombineUseAsyncQueueN5<TInp1,TInp2,TInp3,TInp4,TInp5>(use: Action<TInp1, TInp2, TInp3, TInp4, TInp5, CLContext>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5>>;
function CombineUseAsyncQueueN6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>(use: Action<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, CLContext>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>>;
function CombineUseAsyncQueueN7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>(use: Action<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, CLContext>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; need_own_thread: boolean := true; can_pre_calc: boolean := false): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>>;

{$endregion Context}

{$endregion Use}

{$endregion Async}

{$endregion CombineQueue's}

{$region GLIterop}

function CQAcquireGL(params mem_objs: array of ICLMemory): CommandQueueNil;
function CQReleaseGL(params mem_objs: array of ICLMemory): CommandQueueNil;

{$endregion GLIterop}

{$endregion Global subprograms}

implementation

{$region Util type's}
// To reorder first change OpenCLABC.Utils.drawio
// Created using https://www.diagrams.net/

{$region Basic}

{$region InterlockedBoolean}

type
  InterlockedBoolean = record
    // Less then 32-bit is not hardware supported
    private val := 0;
    
    public constructor(b: boolean) :=
    self.val := integer(b);
    
    public function TrySet(b: boolean): boolean;
    begin
      var prev := integer(not b);
      var curr := integer(b);
      Result := Interlocked.CompareExchange(val, curr, prev)=prev;
    end;
    
    public static function operator implicit(b: boolean): InterlockedBoolean := new InterlockedBoolean(b);
    public static function operator implicit(b: InterlockedBoolean): boolean := Volatile.Read(b.val)<>0;
    
  end;
  
{$endregion InterlockedBoolean}

{$region Blittable}

type
  BlittableException = sealed class(Exception)
    public constructor(t, blame: System.Type; source_name: string) :=
    inherited Create(t=blame ? $'Значения типа {TypeToTypeName(t)} нельзя {source_name}' : $'Значения типа {TypeToTypeName(t)} нельзя {source_name}, потому что он содержит тип {TypeToTypeName(blame)}' );
  end;
  BlittableHelper = static class
    
    private static blittable_cache := new Dictionary<System.Type, System.Type>;
    public static function Blame(t: System.Type): System.Type;
    begin
      Result := nil;
      if t.IsPointer then exit;
      if t.IsClass then
      begin
        Result := t;
        exit;
      end;
      if blittable_cache.TryGetValue(t, Result) then exit;
      
      var o := System.Activator.CreateInstance(t);
      try
        GCHandle.Alloc(o, GCHandleType.Pinned).Free;
      except
        on System.ArgumentException do
        begin
          foreach var fld in t.GetFields(System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.Public or System.Reflection.BindingFlags.NonPublic) do
            if fld.FieldType<>t then
            begin
              Result := Blame(fld.FieldType);
              if Result<>nil then break;
            end;
          if Result=nil then Result := t;
        end;
      end;
      
      blittable_cache[t] := Result;
    end;
    
    public static procedure RaiseIfBad(t: System.Type; source_name: string);
    begin
      var blame := BlittableHelper.Blame(t);
      if blame=nil then exit;
      raise new BlittableException(t, blame, source_name);
    end;
    
  end;
  
  CLValue<T> = partial class
    static constructor :=
    BlittableHelper.RaiseIfBad(typeof(T), $'использовать как тип значения CLValue<>');
  end;
  CLArray<T> = partial class
    static constructor :=
    BlittableHelper.RaiseIfBad(typeof(T), $'использовать как элементы CLArray<>');
  end;
  
static constructor NativeValueArea<T>.Create :=
BlittableHelper.RaiseIfBad(typeof(T), $'%Err:Blittable:Source:NativeValue[Area]%');

static constructor NativeArrayArea<T>.Create :=
BlittableHelper.RaiseIfBad(typeof(T), $'%Err:Blittable:Source:NativeArray[Area]%');

{$endregion Blittable}

{$region CLTaskParameterData}

type
  IParameterQueue = interface
    
    property Name: string read;
    
  end;
  ParameterQueueSetter = sealed partial class
    par_q: IParameterQueue;
    
    public constructor(par_q: IParameterQueue; val: object);
    begin
      self.par_q := par_q;
      self.val := val;
    end;
    
    public property Name: string read par_q.Name;
    
  end;
  ParameterQueue<T> = sealed partial class(CommandQueue<T>, IParameterQueue)
    
  end;
  
//TODO #????
function ParameterQueue<T>.NewSetter(val: T) := new ParameterQueueSetter(self as object as IParameterQueue, val);

type
  CLTaskParameterData = record
    val: object;
    state: (TPS_Default, TPS_Empty, TPS_Set);
    
    public constructor :=
    self.state := TPS_Empty;
    public constructor(def: object);
    begin
      self.val := def;
      self.state := TPS_Default;
    end;
    
    public function &Set(name: string; val: object): CLTaskParameterData;
    begin
      if self.state=TPS_Set then
        raise new ArgumentException($'Значение параметра {name} установлено больше одного раза');
      Result.val := val;
      Result.state := TPS_Set;
    end;
    
    public procedure TestSet(name: string) :=
    if self.state=TPS_Empty then
      raise new ArgumentException($'Значение параметра {name} небыло установлено');
    
  end;
  
{$endregion CLTaskParameterData}

{$region CLTaskGlobalData[CORE]}

type
  CLTaskGlobalData = sealed partial class
    public c: CLContext;
    public cl_c: cl_context;
    public cl_dvc: cl_device_id;
    
    private constructor := raise new OpenCLABCInternalException;
    
    {$region par}
    
    public parameters := new Dictionary<IParameterQueue, CLTaskParameterData>;
    public procedure ApplyParameters(pars: array of ParameterQueueSetter);
    begin
      foreach var par in pars do
      begin
        if not parameters.ContainsKey(par.par_q) then
          raise new ArgumentException($'Параметр {par.Name} не используется');
        parameters[par.par_q] := parameters[par.par_q].Set(par.Name, par.val);
      end;
      foreach var kvp in self.parameters do
        kvp.Value.TestSet(kvp.Key.Name);
    end;
    
    public function CheckDeps(deps: array of CommandQueueBase): boolean;
    begin
      Result := false;
      if deps=nil then exit;
      foreach var dep in deps do
        if parameters[IParameterQueue(dep)].state<>CLTaskParameterData.TPS_Default then
          exit;
      Result := true;
    end;
    
    {$endregion par}
    
    {$region cq}
    
    private curr_inv_cq := cl_command_queue.Zero;
    private outer_cq := cl_command_queue.Zero; // In case of A + B*C, this is curr_inv_cq from A
    private free_cqs := new System.Collections.Concurrent.ConcurrentBag<cl_command_queue>;
    
    public function GetCQ(async_enqueue: boolean := false): cl_command_queue;
    begin
      Result := curr_inv_cq;
      
      if Result=cl_command_queue.Zero then
      begin
        if outer_cq<>cl_command_queue.Zero then
        begin
          Result := outer_cq;
          outer_cq := cl_command_queue.Zero;
        end else
        if free_cqs.TryTake(Result) then
          else
        begin
          var ec: clErrorCode;
          Result := cl.CreateCommandQueue(cl_c, cl_dvc, clCommandQueueProperties.NONE, ec);
          OpenCLABCInternalException.RaiseIfError(ec);
        end;
      end;
      
      curr_inv_cq := if async_enqueue then cl_command_queue.Zero else Result;
    end;
    
    public procedure ReturnCQ(cq: cl_command_queue);
    begin
      free_cqs.Add(cq);
      {$ifdef QueueDebug}
      QueueDebug.Add(cq, '----- return -----');
      {$endif QueueDebug}
    end;
    
    {$endregion cq}
    
  end;
  
{$endregion CLTaskGlobalData[CORE]}

{$region SimpleDelegateContainer's} type
  
  {$region Common}
  
  ISimpleDelegateContainer = interface
    
    procedure ToStringB(sb: StringBuilder);
    
  end;
  
  {$endregion Common}
  
  {$region NoInp}
  
  {$region Proc}
  
  ISimpleProc0Container = interface(ISimpleDelegateContainer)
    
    procedure Invoke(c: CLContext);
    
  end;
  
  SimpleProc0Container = record(ISimpleProc0Container)
    private d: ()->();
    
    public static function operator implicit(d: ()->()): SimpleProc0Container;
    begin
      Result.d := d;
    end;
    
    public procedure Invoke(c: CLContext) := d();
    
    public procedure ToStringB(sb: StringBuilder) :=
    CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  SimpleProc0ContainerC = record(ISimpleProc0Container)
    private d: CLContext->();
    
    public static function operator implicit(d: CLContext->()): SimpleProc0ContainerC;
    begin
      Result.d := d;
    end;
    
    public procedure Invoke(c: CLContext) := d(c);
    
    public procedure ToStringB(sb: StringBuilder) :=
    CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  
  {$endregion Proc}
  
  {$region Func}
  
  ISimpleFunc0Container<T> = interface(ISimpleDelegateContainer)
    
    function Invoke(c: CLContext): T;
    
  end;
  
  SimpleFunc0Container<T> = record(ISimpleFunc0Container<T>)
    private d: ()->T;
    
    public static function operator implicit(d: ()->T): SimpleFunc0Container<T>;
    begin
      Result.d := d;
    end;
    
    public function Invoke(c: CLContext) := d();
    
    public procedure ToStringB(sb: StringBuilder) :=
    CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  SimpleFunc0ContainerC<T> = record(ISimpleFunc0Container<T>)
    private d: CLContext->T;
    
    public static function operator implicit(d: CLContext->T): SimpleFunc0ContainerC<T>;
    begin
      Result.d := d;
    end;
    
    public function Invoke(c: CLContext) := d(c);
    
    public procedure ToStringB(sb: StringBuilder) :=
    CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  
  {$endregion Func}
  
  {$endregion NoInp}
  
  {$region Inp}
  
  {$region Proc}
  
  ISimpleProcContainer<TInp> = interface(ISimpleDelegateContainer)
    
    procedure Invoke(inp: TInp; c: CLContext);
    
  end;
  
  SimpleProcContainer<TInp> = record(ISimpleProcContainer<TInp>)
    private d: TInp->();
    
    public static function operator implicit(d: TInp->()): SimpleProcContainer<TInp>;
    begin
      Result.d := d;
    end;
    
    public procedure Invoke(inp: TInp; c: CLContext) := d(inp);
    
    public procedure ToStringB(sb: StringBuilder) :=
    CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  SimpleProcContainerC<TInp> = record(ISimpleProcContainer<TInp>)
    private d: (TInp, CLContext)->();
    
    public static function operator implicit(d: (TInp, CLContext)->()): SimpleProcContainerC<TInp>;
    begin
      Result.d := d;
    end;
    
    public procedure Invoke(inp: TInp; c: CLContext) := d(inp, c);
    
    public procedure ToStringB(sb: StringBuilder) :=
    CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  
  {$endregion Proc}
  
  {$region Func}
  
  ISimpleFuncContainer<TInp,TRes> = interface(ISimpleDelegateContainer)
    
    function Invoke(inp: TInp; c: CLContext): TRes;
    
  end;
  
  SimpleFuncContainer<TInp,TRes> = record(ISimpleFuncContainer<TInp,TRes>)
    private d: TInp->TRes;
    
    public static function operator implicit(d: TInp->TRes): SimpleFuncContainer<TInp,TRes>;
    begin
      Result.d := d;
    end;
    
    public function Invoke(inp: TInp; c: CLContext) := d(inp);
    
    public procedure ToStringB(sb: StringBuilder) :=
    CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  SimpleFuncContainerC<TInp,TRes> = record(ISimpleFuncContainer<TInp,TRes>)
    private d: (TInp, CLContext)->TRes;
    
    public static function operator implicit(d: (TInp, CLContext)->TRes): SimpleFuncContainerC<TInp,TRes>;
    begin
      Result.d := d;
    end;
    
    public function Invoke(inp: TInp; c: CLContext) := d(inp, c);
    
    public procedure ToStringB(sb: StringBuilder) :=
    CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  
  {$endregion Func}
  
  {$endregion Inp}
  
function PreInvoke<TInp,TRes>(self: ISimpleDelegateContainer; inp: TInp): TRes; extensionmethod;
begin
  match self with
    ISimpleFuncContainer<TInp,TRes>(var f): Result := f.Invoke(inp, nil);
    ISimpleProcContainer<TInp>(var p):
    begin
      p.Invoke(inp, nil);
      if typeof(TInp)<>typeof(TRes) then
        raise new OpenCLABCInternalException($'Proc inp [{TypeToTypeName(typeof(TInp))}] <> res [{TypeToTypeName(typeof(TRes))}]');
      Result := TRes(object(inp)); //TODO Убрать object. Пока не заменил as на TRes(...) - работало без него
    end;
    else raise new OpenCLABCInternalException($'Wrong DC type: [{TypeName(self)}] is not [{TypeToTypeName(typeof(TInp))}]=>[{TypeToTypeName(typeof(TRes))}]');
  end;
end;

{$endregion SimpleDelegateContainer's}

{$endregion Basic}

{$region Invoke result}

{$region EventList}

type
  AttachCallbackData = class
    public work: Action;
    {$ifdef EventDebug}
    public reason: string;
    {$endif EventDebug}
    
    public constructor(work: Action{$ifdef EventDebug}; reason: string{$endif});
    begin
      self.work := work;
      {$ifdef EventDebug}
      self.reason := reason;
      {$endif EventDebug}
    end;
    private constructor := raise new OpenCLABCInternalException;
    
  end;
  
  MultiAttachCallbackData = class(AttachCallbackData)
    public left_c: integer;
    {$ifdef EventDebug}
    public all_evs: sequence of cl_event;
    {$endif EventDebug}
    
    public constructor(work: Action; left_c: integer{$ifdef EventDebug}; reason: string; all_evs: sequence of cl_event{$endif});
    begin
      inherited Create(work{$ifdef EventDebug}, reason{$endif});
      self.left_c := left_c;
      {$ifdef EventDebug}
      self.all_evs := all_evs;
      {$endif EventDebug}
    end;
    private constructor := raise new OpenCLABCInternalException;
    
  end;
  
  EventList = record
    public evs: array of cl_event;
    public count := 0;
    
    {$region Misc}
    
    public property Item[i: integer]: cl_event read evs[i]; default;
    
    public static function operator=(l1, l2: EventList): boolean;
    begin
      Result := false;
      if object.ReferenceEquals(l1, l2) then
      begin
        Result := true;
        exit;
      end;
      if object.ReferenceEquals(l1, nil) then exit;
      if object.ReferenceEquals(l2, nil) then exit;
      if l1.count <> l2.count then exit;
      for var i := 0 to l1.count-1 do
        if l1[i]<>l2[i] then exit;
      Result := true;
    end;
    public static function operator<>(l1, l2: EventList): boolean := not (l1=l2);
    
    {$endregion Misc}
    
    {$region constructor's}
    
    public constructor(count: integer) :=
    self.evs := new cl_event[count];
    public constructor := raise new OpenCLABCInternalException;
    public static Empty := default(EventList);
    
    public static function operator implicit(ev: cl_event): EventList;
    begin
      if ev=cl_event.Zero then
        Result := Empty else
      begin
        Result := new EventList(1);
        Result += ev;
      end;
    end;
    
    public constructor(params evs: array of cl_event);
    begin
      self.evs := evs;
      self.count := evs.Length;
    end;
    
    {$endregion constructor's}
    
    {$region operator+}
    
    public static procedure operator+=(var l: EventList; ev: cl_event);
    begin
      l.evs[l.count] := ev;
      l.count += 1;
    end;
    
    public static procedure operator+=(var l: EventList; ev: EventList);
    begin
      for var i := 0 to ev.count-1 do
        l += ev[i];
    end;
    
    public static function operator+(l1, l2: EventList): EventList;
    begin
      Result := new EventList(l1.count+l2.count);
      Result += l1;
      Result += l2;
    end;
    
    public static function operator+(l: EventList; ev: cl_event): EventList;
    begin
      Result := new EventList(l.count+1);
      Result += l;
      Result += ev;
    end;
    
    private static function Combine<TList>(evs: TList): EventList; where TList: IList<EventList>;
    begin
      Result := EventList.Empty;
      var count := 0;
      
      //TODO #2589
      for var i := 0 to (evs as IList<EventList>).Count-1 do
        count += evs.Item[i].count;
      if count=0 then exit;
      
      Result := new EventList(count);
      //TODO #2589
      for var i := 0 to (evs as IList<EventList>).Count-1 do
        Result += evs.Item[i];
      
    end;
    
    {$endregion operator+}
    
    {$region AttachCallback}
    
    private static procedure InvokeAttachedCallback(ev: cl_event; st: clCommandExecutionStatus; data: IntPtr);
    begin
      var hnd := GCHandle(data);
      var cb_data := AttachCallbackData(hnd.Target);
      {$ifdef EventDebug}
      EventDebug.RegisterEventRelease(ev, $'released in callback, working on {cb_data.reason}');
      {$endif EventDebug}
      OpenCLABCInternalException.RaiseIfError( cl.ReleaseEvent(ev) );
      hnd.Free;
      cb_data.work();
    end;
    private static attachable_callback: clEventCallback := InvokeAttachedCallback;
    
    public static procedure AttachCallback(ev: cl_event; work: Action{$ifdef EventDebug}; reason: string{$endif});
    begin
      var cb_data := new AttachCallbackData(work{$ifdef EventDebug}, reason{$endif});
      var ec := cl.SetEventCallback(ev, clCommandExecutionStatus.COMPLETE, attachable_callback, GCHandle.ToIntPtr(GCHandle.Alloc(cb_data)));
      OpenCLABCInternalException.RaiseIfError(ec);
    end;
    
    {$endregion AttachCallback}
    
    {$region MultiAttachCallback}
    
    private static procedure InvokeMultiAttachedCallback(ev: cl_event; st: clCommandExecutionStatus; data: IntPtr);
    begin
      var hnd := GCHandle(data);
      var cb_data := MultiAttachCallbackData(hnd.Target);
      // st копирует значение переданное в cl.SetEventCallback, поэтому он не подходит
      {$ifdef EventDebug}
      EventDebug.RegisterEventRelease(ev, $'released in multi-callback, working on {cb_data.reason}, together with evs: {cb_data.all_evs.JoinToString}');
      {$endif EventDebug}
      OpenCLABCInternalException.RaiseIfError(cl.ReleaseEvent(ev));
      if Interlocked.Decrement(cb_data.left_c) <> 0 then exit;
      hnd.Free;
      cb_data.work();
    end;
    private static multi_attachable_callback: clEventCallback := InvokeMultiAttachedCallback;
    
    public procedure MultiAttachCallback(work: Action{$ifdef EventDebug}; reason: string{$endif}) :=
    case self.count of
      0: work;
      1: AttachCallback(self.evs[0], work{$ifdef EventDebug}, reason{$endif});
      else
      begin
        var cb_data := new MultiAttachCallbackData(work, self.count{$ifdef EventDebug}, reason, evs.Take(count){$endif});
        var hnd_ptr := GCHandle.ToIntPtr(GCHandle.Alloc(cb_data));
        for var i := 0 to count-1 do
        begin
          var ec := cl.SetEventCallback(evs[i], clCommandExecutionStatus.COMPLETE, multi_attachable_callback, hnd_ptr);
          OpenCLABCInternalException.RaiseIfError(ec);
        end;
      end;
    end;
    
    {$endregion MultiAttachCallback}
    
    {$region Retain/Release}
    
    public procedure Retain({$ifdef EventDebug}reason: string{$endif}) :=
    for var i := 0 to count-1 do
    begin
      {$ifdef EventDebug}
      EventDebug.RegisterEventRetain(evs[i], $'{reason}, together with evs: {evs.Take(count).JoinToString}');
      {$endif EventDebug}
      OpenCLABCInternalException.RaiseIfError( cl.RetainEvent(evs[i]) );
    end;
    
    public procedure Release({$ifdef EventDebug}reason: string{$endif}) :=
    for var i := 0 to count-1 do
    begin
      {$ifdef EventDebug}
      EventDebug.RegisterEventRelease(evs[i], $'{reason}, together with evs: {evs.Take(count).JoinToString}');
      {$endif EventDebug}
      OpenCLABCInternalException.RaiseIfError( cl.ReleaseEvent(evs[i]) );
    end;
    
    // - cl.WaitForEvents spin waits until all events fire
    // - ManualResetEventSlim only spin waits for a bit (configurable)
    //
    // - cl.WaitForEvents may cancel wait on error in on branch
    // - MultiAttachCallback fires when everything is done
    public function ToMRE({$ifdef EventDebug}reason: string{$endif}): ManualResetEventSlim;
    begin
      Result := nil;
      if self.count=0 then exit;
      Result := new ManualResetEventSlim(false);
      var mre := Result;
      self.MultiAttachCallback(mre.Set{$ifdef EventDebug}, $'setting mre for {reason}'{$endif});
    end;
    
    {$endregion Retain/Release}
    
    {$region Event status}
    
    private static function GetStatus(ev: cl_event): clCommandExecutionStatus;
    begin
      OpenCLABCInternalException.RaiseIfError(
        cl.GetEventInfo_EVENT_COMMAND_EXECUTION_STATUS(ev, Result, false)
      );
    end;
    
    {$ifdef DEBUG}
    public static function HasCompleted(ev: cl_event): boolean;
    begin
      {$ifdef EventDebug}
      EventDebug.VerifyExists(ev, $'checking event status');
      {$endif EventDebug}
      var st := GetStatus(ev);
      Result := (st=clCommandExecutionStatus.COMPLETE) or st.IS_ERROR;
    end;
    public function HasCompleted: boolean;
    begin
      Result := false;
      for var i := 0 to count-1 do
        if not HasCompleted(evs[i]) then
          exit;
      Result := true;
    end;
    {$endif DEBUG}
    
    public static function HasError(ev: cl_event) := GetStatus(ev).IS_ERROR;
    public function HasError: boolean;
    begin
      Result := true;
      for var i := 0 to count-1 do
        if HasError(evs[i]) then
          exit;
      Result := false;
    end;
    
    {$endregion Event status}
    
  end;
  
{$endregion EventList}

{$region DoubleList}

type
  DoubleList<T> = sealed class
    private items: array of T;
    private c1 := 0;
    {$ifdef DEBUG}
    private skipped_c1 := 0;
    private skipped_c2 := 0;
    {$endif DEBUG}
    private c2 := 0;
    
    public constructor(cap: integer) := items := new T[cap];
    private constructor := raise new OpenCLABCInternalException;
    
    public property Capacity: integer read items.Length;
    
    {$ifdef DEBUG}
    private procedure CheckFill(exp_done: boolean);
    begin
      var done_c := c1+skipped_c1+skipped_c2+c2;
      if (done_c=Capacity) <> exp_done then raise new OpenCLABCInternalException(
        if exp_done then
          $'Too much EnqEv capacity: {done_c}/{items.Length} used' else
          $'Not enough EnqEv capacity'
      );
    end;
    public procedure CheckSameSize<T2>(other: DoubleList<T2>);
    begin
      if (self.c1+self.skipped_c1<>other.c1+other.skipped_c1) or (self.skipped_c2+self.c2<>other.skipped_c2+other.c2) then
        raise new OpenCLABCInternalException($'{#10}{self.c1}+{self.skipped_c1}+{self.skipped_c2}+{self.c2}=>{self.items.Length} vs{#10}{other.c1}+{other.skipped_c1}+{other.skipped_c2}+{other.c2}=>{other.items.Length}');
    end;
    {$endif DEBUG}
    
    public function L1Empty := c1=0;
    
    public procedure AddL1(item: T);
    begin
      {$ifdef DEBUG}
      CheckFill(false);
      // is-var would call "new EventList()", which was disabled...
      if (item is EventList) and (EventList(item as object).count=0) then
        raise new OpenCLABCInternalException($'Empty event');
      {$endif DEBUG}
      items[c1] := item;
      c1 += 1;
    end;
    public procedure AddL2(item: T);
    begin
      {$ifdef DEBUG}
      CheckFill(false);
      // is-var would call "new EventList()", which was disabled...
      if (item is EventList) and (EventList(item as object).count=0) then
        raise new OpenCLABCInternalException($'Empty event');
      {$endif DEBUG}
      c2 += 1;
      items[items.Length-c2] := item;
    end;
    
    {$ifdef DEBUG}
    private procedure FakeAdd(to_l1: boolean);
    begin
      CheckFill(false);
      if to_l1 then
        skipped_c1 += 1 else
        skipped_c2 += 1;
    end;
    {$endif DEBUG}
    public procedure Add(item: T; to_l1: boolean) :=
      if to_l1 then
        AddL1(item) else
        AddL2(item);
    
    public function GetL1: ArraySegment<T>;
    begin
      {$ifdef DEBUG}
      CheckFill(true);
      {$endif DEBUG}
      Result := new ArraySegment<T>(items,0,c1);
    end;
    public function GetL2: ArraySegment<T>;
    begin
      {$ifdef DEBUG}
      CheckFill(true);
      {$endif DEBUG}
      Result := new ArraySegment<T>(items,items.Length-c2,c2);
    end;
    //TODO Вместо выделения .ToArray, лучше бы реализовать IList<T>...
    // - Получится избежать пере-выделений при создании ErrHandlerBranchCombinator
    public function GetAll: array of T;
    begin
      {$ifdef DEBUG}
      CheckFill(true);
      {$endif DEBUG}
      var c := c1+c2;
      Result := self.items;
      if c=Result.Length then exit;
      Result := new T[c];
      for var i := 0 to c1-1 do
        Result[i] := items[i];
      var shift := c-items.Length;
      for var i := items.Length-c2 to items.Length-1 do
        Result[i+shift] := items[i];
    end;
    
    public function L1Any(pred: T->boolean): boolean;
    begin
      {$ifdef DEBUG}
      CheckFill(true);
      {$endif DEBUG}
      Result := true;
      for var i := 0 to c1-1 do
        if pred(items[i]) then exit;
      Result := false;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Combine<TRes>(conv: ArraySegment<T>->TRes) :=
      ValueTuple.Create( conv(GetL1), conv(GetL2) );
    
  end;
  
{$endregion DoubleList}

{$region ErrHandler}

{$region Def}

type
  {$region Base}
  
  /// Contains errors for current CQ invoke stage,
  /// as well as references to handlers of prev stages
  ErrHandler = abstract class
    private local_err_lst := new List<Exception>;
    
    {$ifdef DEBUG}
    private stage_reason: string;
    public constructor(stage_reason: string) :=
      self.stage_reason := stage_reason;
    private constructor := raise new OpenCLABCInternalException;
    {$endif DEBUG}
    
    {$region AddErr}
    
    protected procedure AddErr(e: Exception{$ifdef DEBUG}; test_reason: string{$endif});
    begin
      if e is OpenCLABCInternalException then
        // Inner exceptions should not get handled
        System.Runtime.ExceptionServices.ExceptionDispatchInfo.Capture(e).Throw;
      {$ifdef DEBUG}
      VerifyDoneInPrev(new HashSet<ErrHandler>);
      if test_reason not in tests_exp then raise new OpenCLABCInternalException($'AddMaybeError was not called');
      {$endif DEBUG}
      
      // One ErrHandler object can be reused:
      // HPQ + HPQ(raise)
      had_error_cache := true;
      
      local_err_lst += e;
    end;
    
    {$endregion AddErr}
    
    {$region HadError}
    
    private had_error_cache := default(boolean?);
    protected function HadErrorInPrev: boolean; abstract;
    public function HadError: boolean;
    begin
      {$ifdef DEBUG}
      VerifyDoneInPrev(new HashSet<ErrHandler>);
      {$endif DEBUG}
      
      if had_error_cache<>nil then
      begin
        Result := had_error_cache.Value;
        exit;
      end;
      
      Result := (local_err_lst.Count<>0) or HadErrorInPrev;
      had_error_cache := Result;
    end;
    
    {$endregion HadError}
    
    {$region Error transfer}
    
    protected function TryRemoveErrorsInPrev(origin_cache: Dictionary<ErrHandler, boolean>; handler: Exception->boolean): boolean; abstract;
    protected function TryRemoveErrors(origin_cache: Dictionary<ErrHandler, boolean>; handler: Exception->boolean): boolean;
    begin
      Result := false;
      if had_error_cache=false then exit;
      
      Result := TryRemoveErrorsInPrev(origin_cache, handler);
      
      Result := (local_err_lst.RemoveAll(handler)<>0) or Result;
      if Result then had_error_cache := nil;
    end;
    public procedure TryRemoveErrors(handler: Exception->boolean) :=
    TryRemoveErrors(new Dictionary<ErrHandler, boolean>, handler);
    
    protected procedure FillErrLstWithPrev(origin_cache: HashSet<ErrHandler>; lst: List<Exception>); abstract;
    protected procedure FillErrLst(origin_cache: HashSet<ErrHandler>; lst: List<Exception>);
    begin
      {$ifdef DEBUG}
      VerifyDoneInPrev(new HashSet<ErrHandler>);
      {$else DEBUG}
      if not HadError then exit;
      {$endif DEBUG}
      
      FillErrLstWithPrev(origin_cache, lst);
      
      lst.AddRange(local_err_lst);
    end;
    public procedure FillErrLst(lst: List<Exception>) :=
    FillErrLst(new HashSet<ErrHandler>, lst);
    
    {$endregion Error transfer}
    
    {$region Done checks}{$ifdef DEBUG}
    
    private tests_exp := new List<string>;
    private tests_done := new HashSet<string>;
    private function TestsReport: string;
    begin
      var res := new StringBuilder;
      res += 'Expected: ['#10;
      lock tests_exp do foreach var t in tests_exp do
      begin
        res += #9;
        res += t;
        res += #10;
      end;
      res += ']; Done: ['#10;
      lock tests_done do foreach var t in tests_done do
      begin
        res += #9;
        res += t;
        res += #10;
      end;
      res += ']';
      Result := res.ToString;
    end;
    
    public procedure AddMaybeError(reason: string) :=
    lock tests_exp do tests_exp += reason;
    
    public procedure EndMaybeError(reason: string) :=
    lock tests_exp do
    begin
      if not tests_exp.Remove(reason) then
        raise new OpenCLABCInternalException($'Test [{reason}] was no expected; {TestsReport}');
      tests_done += reason;
    end;
    
    protected procedure VerifyDoneInPrev(origin_cache: HashSet<ErrHandler>); abstract;
    protected procedure VerifyDone(origin_cache: HashSet<ErrHandler>);
    begin
      VerifyDoneInPrev(origin_cache);
      if tests_exp.Count<>0 then
        PABCSystem.Println( new OpenCLABCInternalException($'Not all tests done for [{stage_reason}]; {TestsReport}') );
//        raise new OpenCLABCInternalException($'Not all tests done for [{stage_reason}]; {TestsReport}');
    end;
    
    public procedure SanityCheck(err_lst: List<Exception>);
    begin
      VerifyDone(new HashSet<ErrHandler>);
      
      // QErr*QErr - second cache wouldn't be calculated
//      if had_error_cache=nil then
//        raise new OpenCLABCInternalException($'SanityCheck expects all had_error_cache to exist');
      
      begin
        var had_error := self.HadError;
        if had_error <> (err_lst.Count<>0) then
          raise new OpenCLABCInternalException($'{had_error} <> {err_lst.Count}');
      end;
      
    end;
    
    {$endif DEBUG}{$endregion Done checks}
    
    {$region Println}{$ifdef ErrHandlerDebug}
    
    public procedure PrintlnPrev(tab: integer; cache: Dictionary<ErrHandler, integer>); abstract;
    public procedure Println(tab: integer; cache: Dictionary<ErrHandler, integer>; prefix: string);
    begin
      
      var need_prev := false;
      var ind: integer;
      if not cache.TryGetValue(self, ind) then
      begin
        need_prev := true;
        ind := cache.Count;
        cache.Add(self, ind);
      end;
      
      loop tab do eh_debug_otp.Write(#9);
      
      if prefix<>nil then
      begin
        eh_debug_otp.Write(prefix);
        eh_debug_otp.Write(' = ');
      end;
      
      eh_debug_otp.Write(TypeName(self));
      eh_debug_otp.Write('#');
      eh_debug_otp.Write(ind);
      eh_debug_otp.Write(': ');
      eh_debug_otp.Write(self.stage_reason);
      eh_debug_otp.WriteLine;
      
      if need_prev then PrintlnPrev(tab, cache);
    end;
    public procedure Println;
    begin
      var cache := new Dictionary<ErrHandler,integer>;
      self.Println(0, cache, 'final');
      eh_debug_otp.WriteLine($'(total {cache.Count} handlers)');
    end;
    
    {$endif ErrHandlerDebug}{$endregion Println}
    
  end;
  
  // One of the states:
  // - [Initial]: "f" with "can_skip_f=true"
  // --- Task/Branch start with NO prev handlers
  // - [Bud]: "f" with "can_skip_f=false"
  // --- Branch started with prev handlers
  // --- Next handlers would need to call "f", instead of creating own [Initial] LazyErrHandler
  // --- But the creator of [Bud] will ".ForceSkipFunc"
  // - [Value]: "v" and nothing else
  // --- De-abstracted handler, for every other case
  LazyErrHandler = record
    //TODO For a sanity check, rename to _f and _v, then back
    // - Should not be used directly, but is for now
    private f: ()->ErrHandler := nil;
    private can_skip_f: boolean
    private v: ErrHandler := nil;
    
    public static function FromFunc(can_skip_f: boolean; f: ()->ErrHandler): LazyErrHandler;
    begin
      {$ifdef DEBUG}
      if f=nil then raise nil;
      {$endif DEBUG}
      Result.can_skip_f := can_skip_f;
      Result.f := f;
    end;
    public static function FromValue(v: ErrHandler): LazyErrHandler;
    begin
      {$ifdef DEBUG}
      if v=nil then raise nil;
      {$endif DEBUG}
      Result.v := v;
    end;
    
    private static function RaiseInvalidHandler: ErrHandler;
    begin
      Result := nil;
      raise new OpenCLABCInternalException($'');
    end;
    public static InvalidFunc := FromFunc(true, RaiseInvalidHandler);
    
    // Returns de-abstracted error handler
    //
    // "expect_existing":
    // - .StartWorkThread and .AttachInvokeTo expect "f" to have already been called
    // - Then they check if an error was added or not, knowing "try" block was executed
    public function Extract({$ifdef DEBUG}expect_existing: boolean{$endif}): ErrHandler;
    begin
      {$ifdef DEBUG}
      if (f<>nil) = (v<>nil) then
        raise new OpenCLABCInternalException($'Invalid state of curr_err_handler');
      if expect_existing and (f<>nil) then
        raise new OpenCLABCInternalException($'Expected curr_err_handler to already exist');
      {$endif DEBUG}
      if f<>nil then
      begin
        v := f();
        f := nil;
      end;
      {$ifdef DEBUG}
      if v=nil then raise nil;
      {$endif DEBUG}
      Result := v;
    end;
    
    public function HasValue := v<>nil;
    public function TrySkipFunc :=
      if can_skip_f then self.v else
        self.Extract({$ifdef DEBUG}false{$endif});
    public function ForceSkipFunc({$ifdef DEBUG}origin: LazyErrHandler{$endif}): ErrHandler;
    begin
      Result := v;
      {$ifdef DEBUG}
      if (Result=nil) and (self <> origin) then
        raise new OpenCLABCInternalException($'');
      {$endif DEBUG}
    end;
    
    //TODO Is this used?
    // - Instead, it seems ForceSkipFunc always need to add itself to some list
    public procedure AddTo(l: List<ErrHandler>);
    begin
      var raw_v := self.TrySkipFunc;
      if raw_v=nil then exit;
      l += raw_v;
    end;
    
  end;
  
  {$endregion Base}
  
  {$region Initial}
  
  /// Handler with no prev stages
  ErrHandlerInitial = sealed class(ErrHandler)
    
    protected function HadErrorInPrev: boolean; override := false;
    
    protected function TryRemoveErrorsInPrev(origin_cache: Dictionary<ErrHandler, boolean>; handler: Exception->boolean): boolean; override := false;
    
    protected procedure FillErrLstWithPrev(origin_cache: HashSet<ErrHandler>; lst: List<Exception>); override := exit;
    
    {$ifdef DEBUG}
    protected procedure VerifyDoneInPrev(origin_cache: HashSet<ErrHandler>); override := exit;
    {$endif DEBUG}
    
    {$ifdef ErrHandlerDebug}
    public procedure PrintlnPrev(tab: integer; cache: Dictionary<ErrHandler, integer>); override := exit;
    {$endif ErrHandlerDebug}
    
  end;
  
  {$endregion Initial}
  
  {$region Branch}
  // These types are for error handling branches, not just invoke branches
  // A>=B (try-finally) forms 2 independant error branches
  // And so does invoke branching in case of A*B
  //
  // In case of A+B*C:
  // - Handler of A is the branching origin
  // - B and C create their own BrunchBud-s
  // - B*C creates BranchCombinator
  // - Combinator and both Bud's refer to the origin
  
  /// Initial handler for a branch that had origin
  /// Checks for errors in the origin
  /// But can only handles own errors
  ErrHandlerBranchBud = sealed class(ErrHandler)
    private origin: ErrHandler;
    
    public constructor(origin: ErrHandler{$ifdef DEBUG}; stage_reason: string{$endif});
    begin
      inherited Create({$ifdef DEBUG}stage_reason{$endif});
      self.origin := origin;
      {$ifdef DEBUG}
      if origin=nil then raise nil;
      {$endif DEBUG}
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    public static function Wrap(origin: LazyErrHandler{$ifdef DEBUG}; stage_reason: string{$endif}): LazyErrHandler;
    begin
      var origin_v := origin.TrySkipFunc;
      if origin_v=nil then
      begin
        {$ifdef DEBUG}
        if origin=LazyErrHandler.InvalidFunc then else
        if origin.f() is ErrHandlerInitial then else
          raise new OpenCLABCInternalException($'');
        {$endif DEBUG}
        Result := LazyErrHandler.FromFunc(true, ()->new ErrHandlerInitial({$ifdef DEBUG}$'(origin-less) {stage_reason}'{$endif}));
        exit;
      end;
      Result := LazyErrHandler.FromFunc(false, ()->new ErrHandlerBranchBud(origin_v{$ifdef DEBUG}, stage_reason{$endif}));
    end;
    
    protected function HadErrorInPrev: boolean; override := origin.HadError;
    
    protected function TryRemoveErrorsInPrev(origin_cache: Dictionary<ErrHandler, boolean>; handler: Exception->boolean): boolean; override;
    begin
      if origin_cache.TryGetValue(origin, Result) then exit;
    end;
    
    protected procedure FillErrLstWithPrev(origin_cache: HashSet<ErrHandler>; lst: List<Exception>); override;
    begin
      if origin in origin_cache then exit;
      origin.FillErrLst(origin_cache, lst);
    end;
    
    {$ifdef DEBUG}
    protected procedure VerifyDoneInPrev(origin_cache: HashSet<ErrHandler>); override;
    begin
      if origin in origin_cache then exit;
      origin.VerifyDone(origin_cache);
    end;
    {$endif DEBUG}
    
    {$ifdef ErrHandlerDebug}
    public procedure PrintlnPrev(tab: integer; cache: Dictionary<ErrHandler, integer>); override;
    begin
      if origin not in cache then
//        raise new OpenCLABCInternalException($'bud origin not in cache');
        PABCSystem.Println( new OpenCLABCInternalException($'bud origin not in cache') );
      origin.Println(tab, cache, 'origin');
    end;
    {$endif ErrHandlerDebug}
    
  end;
  
  /// Common handler for all branches
  /// Unifies errors and makes sure origin is only checked once
  ErrHandlerBranchCombinator = sealed class(ErrHandler)
    private origin: ErrHandler;
    private branches: array of ErrHandler;
    
    public constructor(origin: ErrHandler; branches: array of ErrHandler{$ifdef DEBUG}; stage_reason: string{$endif});
    begin
      inherited Create({$ifdef DEBUG}stage_reason{$endif});
      self.origin := origin;
      self.branches := branches;
      {$ifdef DEBUG}
      if (origin=nil) and (branches.Length<2) then raise nil;
      if branches.Any(b->b=nil) then raise nil;
      {$endif DEBUG}
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    //TODO Принимать TList:IList?
    public static function Wrap(origin: LazyErrHandler; branches: array of ErrHandler{$ifdef DEBUG}; stage_reason: string{$endif}): LazyErrHandler;
    begin
      Result := origin;
      if branches.Length=0 then exit;
      var origin_v := origin.TrySkipFunc;
      Result := LazyErrHandler.FromValue(
        if (branches.Length=1) and (origin_v=nil) then
          branches.Single else
          new ErrHandlerBranchCombinator(
            origin_v, branches
            {$ifdef DEBUG}, stage_reason{$endif}
          )
      );
    end;
    public static function Wrap(origin: LazyErrHandler; single_branch: ErrHandler{$ifdef DEBUG}; stage_reason: string{$endif}): LazyErrHandler;
    begin
      Result := origin;
      if single_branch=nil then exit;
      var origin_v := origin.TrySkipFunc;
      Result := LazyErrHandler.FromValue(
        if origin_v=nil then
          single_branch else
          new ErrHandlerBranchCombinator(
            origin_v, |single_branch|
            {$ifdef DEBUG}, stage_reason{$endif}
          )
      );
    end;
    
    protected function HadErrorInPrev: boolean; override;
    begin
      Result := (origin<>nil) and origin.HadError;
      if Result then exit;
      foreach var h in branches do
      begin
        Result := h.HadError;
        if Result then exit;
      end;
    end;
    
    protected function TryRemoveErrorsInPrev(origin_cache: Dictionary<ErrHandler, boolean>; handler: Exception->boolean): boolean; override;
    begin
      Result := false;
      if origin<>nil then
      begin
        Result := origin.TryRemoveErrors(origin_cache, handler);
        origin_cache.Add(origin, Result);
      end;
      foreach var h in branches do
        Result := h.TryRemoveErrors(origin_cache, handler) or Result;
      if (origin<>nil) and not origin_cache.Remove(origin) then
        raise new OpenCLABCInternalException($'');
    end;
    
    protected procedure FillErrLstWithPrev(origin_cache: HashSet<ErrHandler>; lst: List<Exception>); override;
    begin
      if origin<>nil then
      begin
        origin.FillErrLst(origin_cache, lst);
        origin_cache += origin;
      end;
      foreach var h in branches do
        h.FillErrLst(origin_cache, lst);
      if (origin<>nil) and not origin_cache.Remove(origin) then
        raise new OpenCLABCInternalException($'');
    end;
    
    {$ifdef DEBUG}
    protected procedure VerifyDoneInPrev(origin_cache: HashSet<ErrHandler>); override;
    begin
      if origin<>nil then
      begin
        origin.VerifyDone(origin_cache);
        origin_cache += origin;
      end;
      foreach var h in branches do
        h.VerifyDone(origin_cache);
      if (origin<>nil) and not origin_cache.Remove(origin) then
        raise new OpenCLABCInternalException($'');
    end;
    {$endif DEBUG}
    
    {$ifdef ErrHandlerDebug}
    public procedure PrintlnPrev(tab: integer; cache: Dictionary<ErrHandler, integer>); override;
    begin
      if origin<>nil then
        origin.Println(tab+1, cache, 'origin');
      foreach var branch in branches index i do
        branch.Println(tab+1, cache, $'branch#{i}/{branches.Length}');
    end;
    {$endif ErrHandlerDebug}
    
  end;
  
  {$endregion Branch}
  
  {$region Thief}
  
  /// Thief-s copy errors from their victim into their
  /// own local list during the first time they are read
  ErrHandlerThiefBase = abstract class(ErrHandler)
    protected victim: ErrHandler;
    {$ifdef ErrHandlerDebug}
    protected org_victim: ErrHandler;
    {$endif ErrHandlerDebug}
    
    public constructor(victim: ErrHandler{$ifdef DEBUG}; stage_reason: string{$endif});
    begin
      inherited Create({$ifdef DEBUG}stage_reason{$endif});
      self.victim := victim;
      {$ifdef ErrHandlerDebug}
      self.org_victim := victim;
      {$endif ErrHandlerDebug}
      {$ifdef DEBUG}
      // But will be set to nil in StealPrevErrors
      if victim=nil then raise nil;
      {$endif DEBUG}
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    protected function CanSteal: boolean; abstract;
    public procedure StealPrevErrors;
    begin
      if victim=nil then exit;
      if CanSteal then lock self do
        victim.FillErrLst(self.local_err_lst);
      victim := nil;
    end;
    
    protected function HadErrorInVictim: boolean :=
      (victim<>nil) and victim.HadError;
    
    public function AccessErrors: List<Exception>;
    begin
      {$ifdef DEBUG}
      EndMaybeError($'.AccessErrors[{self.GetHashCode}]');
      {$endif DEBUG}
      had_error_cache := nil;
      Result := local_err_lst;
    end;
    
  end;
  
  /// Allows to combine all errors from the whole tree of handlers into a single list
  /// Used for passing this list to the user function of .HandleReplaceRes
  ErrHandlerFlattener = sealed class(ErrHandlerThiefBase)
    
    public static function Wrap(victim: ErrHandler{$ifdef DEBUG}; stage_reason: string{$endif}): ErrHandlerThiefBase :=
      if victim is ErrHandlerThiefBase(var thief) then thief else
        new ErrHandlerFlattener(victim{$ifdef DEBUG}, stage_reason{$endif});
    
    protected function CanSteal: boolean; override := true;
    
    protected function HadErrorInPrev: boolean; override := HadErrorInVictim;
    
    protected function TryRemoveErrorsInPrev(origin_cache: Dictionary<ErrHandler, boolean>; handler: Exception->boolean): boolean; override;
    begin
      StealPrevErrors;
      Result := false;
    end;
    
    protected procedure FillErrLstWithPrev(origin_cache: HashSet<ErrHandler>; lst: List<Exception>); override;
    begin
      StealPrevErrors;
    end;
    
    {$ifdef DEBUG}
    protected procedure VerifyDoneInPrev(origin_cache: HashSet<ErrHandler>); override;
    begin
      if victim=nil then exit;
      victim.VerifyDone(origin_cache);
    end;
    {$endif DEBUG}
    
    {$ifdef ErrHandlerDebug}
    public procedure PrintlnPrev(tab: integer; cache: Dictionary<ErrHandler, integer>); override;
    begin
      org_victim.Println(tab, cache, 'victim');
    end;
    {$endif ErrHandlerDebug}
    
  end;
  
  /// Works like BranchCombinator, but with origin+1 branch (victim) and steals errors from that branch
  /// Used by .Multiusable to avoid walking victim handler tree multiple times
  ErrHandlerMURepeater = sealed class(ErrHandlerThiefBase)
    private origin: ErrHandler;
    
    public constructor(origin, victim: ErrHandler{$ifdef DEBUG}; stage_reason: string{$endif});
    begin
      inherited Create(victim{$ifdef DEBUG}, stage_reason{$endif});
      self.origin := origin;
      {$ifdef DEBUG}
      if origin=nil then raise nil;
      // But will be set to nil in StealPrevErrors
      if victim=nil then raise nil;
      {$endif DEBUG}
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    public static function Wrap(origin: LazyErrHandler; victim: ErrHandler{$ifdef DEBUG}; stage_reason: string{$endif}): LazyErrHandler;
    begin
      Result := origin;
      if victim=nil then exit;
      var origin_v := origin.TrySkipFunc;
      //TODO Пока что проверки оконченности падают из за этого
      // - Но это скорее вопрос настройки тех проверок
//      if (origin_v is ErrHandlerMURepeater(var thief)) and (thief.victim=victim) then exit;
      Result := LazyErrHandler.FromValue(
        if origin_v=nil then
          ErrHandlerFlattener.Wrap(victim{$ifdef DEBUG}, stage_reason{$endif}) else
          new ErrHandlerMURepeater(origin_v, victim{$ifdef DEBUG}, stage_reason{$endif})
      );
    end;
    
    protected function CanSteal: boolean; override :=
      not origin.HadError;
    
    protected function HadErrorInPrev: boolean; override :=
      // mu_handler.HadError would be called more often,
      // so it's more likely to already have cache
      HadErrorInVictim or origin.HadError;
    
    protected function TryRemoveErrorsInPrev(origin_cache: Dictionary<ErrHandler, boolean>; handler: Exception->boolean): boolean; override;
    begin
      // No need to check origin in cache
      // victim is the one being accessed multiple times from MURepeater
      Result := origin.TryRemoveErrors(origin_cache, handler);
      if CanSteal then StealPrevErrors;
    end;
    
    protected procedure FillErrLstWithPrev(origin_cache: HashSet<ErrHandler>; lst: List<Exception>); override;
    begin
      var prev_c := lst.Count;
      origin.FillErrLst(lst);
      {$ifdef DEBUG}
      if (prev_c=lst.Count) <> not origin.HadError then
        raise new OpenCLABCInternalException($'');
      {$endif DEBUG}
      if prev_c=lst.Count then StealPrevErrors;
    end;
    
    {$ifdef DEBUG}
    protected procedure VerifyDoneInPrev(origin_cache: HashSet<ErrHandler>); override;
    begin
      if victim<>nil then
        victim.VerifyDone(origin_cache);
      origin.VerifyDone(origin_cache);
    end;
    {$endif DEBUG}
    
    {$ifdef ErrHandlerDebug}
    public procedure PrintlnPrev(tab: integer; cache: Dictionary<ErrHandler, integer>); override;
    begin
      org_victim.Println(tab+1, cache, 'victim');
      origin.Println(tab, cache, 'origin');
    end;
    {$endif ErrHandlerDebug}
    
  end;
  
  {$endregion Thief}
  
{$endregion Def}

{$region Use}

type
  CLTaskGlobalData = sealed partial class
    
    // Error in insta-called HPQ/HFQ, etc.
    public had_insta_err: boolean;
    
    private static function MakeInitialErrHandler := new ErrHandlerInitial({$ifdef DEBUG}$'Initial CLTask invoke'{$endif});
    public curr_err_handler := LazyErrHandler.FromFunc(true, MakeInitialErrHandler);
    
  end;
  
procedure TODO_2036_1 := exit; //TODO #2036

[MethodImpl(MethodImplOptions.AggressiveInlining)]
procedure Invoke<TInp>(self: ISimpleProcContainer<TInp>; insta_call_g: CLTaskGlobalData; err_handler: ErrHandler{$ifdef DEBUG}; err_test_reason: string{$endif}; inp: TInp; c: CLContext); extensionmethod;
begin
  {$ifdef DEBUG}
  try
  {$endif DEBUG}
    
    if (insta_call_g<>nil) and insta_call_g.had_insta_err then exit;
    if err_handler.HadError then exit;
    
    try
      self.Invoke(inp, c);
    except
      on e: Exception do
      begin
        if insta_call_g<>nil then insta_call_g.had_insta_err := true;
        err_handler.AddErr(e{$ifdef DEBUG}, err_test_reason{$endif});
      end;
    end;
    
  {$ifdef DEBUG}
  finally
    err_handler.EndMaybeError(err_test_reason);
  end;
  {$endif DEBUG}
end;

[MethodImpl(MethodImplOptions.AggressiveInlining)]
function Invoke<TInp,TRes>(self: ISimpleFuncContainer<TInp,TRes>; insta_call_g: CLTaskGlobalData; err_handler: ErrHandler{$ifdef DEBUG}; err_test_reason: string{$endif}; inp: TInp; c: CLContext): TRes; extensionmethod;
begin
  {$ifdef DEBUG}
  try
  {$endif DEBUG}
    
    if (insta_call_g<>nil) and insta_call_g.had_insta_err then exit;
    if err_handler.HadError then exit;
    
    try
      Result := self.Invoke(inp, c);
    except
      on e: Exception do
      begin
        if insta_call_g<>nil then insta_call_g.had_insta_err := true;
        err_handler.AddErr(e{$ifdef DEBUG}, err_test_reason{$endif});
      end;
    end;
    
  {$ifdef DEBUG}
  finally
    err_handler.EndMaybeError(err_test_reason);
  end;
  {$endif DEBUG}
end;

[MethodImpl(MethodImplOptions.AggressiveInlining)]
procedure Invoke(self: ISimpleProc0Container; insta_call_g: CLTaskGlobalData; err_handler: ErrHandler{$ifdef DEBUG}; err_test_reason: string{$endif}; c: CLContext); extensionmethod;
begin
  {$ifdef DEBUG}
  try
  {$endif DEBUG}
    
    if (insta_call_g<>nil) and insta_call_g.had_insta_err then exit;
    if err_handler.HadError then exit;
    
    try
      self.Invoke(c);
    except
      on e: Exception do
      begin
        if insta_call_g<>nil then insta_call_g.had_insta_err := true;
        err_handler.AddErr(e{$ifdef DEBUG}, err_test_reason{$endif});
      end;
    end;
    
  {$ifdef DEBUG}
  finally
    err_handler.EndMaybeError(err_test_reason);
  end;
  {$endif DEBUG}
end;

[MethodImpl(MethodImplOptions.AggressiveInlining)]
function Invoke<TRes>(self: ISimpleFunc0Container<TRes>; insta_call_g: CLTaskGlobalData; err_handler: ErrHandler{$ifdef DEBUG}; err_test_reason: string{$endif}; c: CLContext): TRes; extensionmethod;
begin
  {$ifdef DEBUG}
  try
  {$endif DEBUG}
    
    if (insta_call_g<>nil) and insta_call_g.had_insta_err then exit;
    if err_handler.HadError then exit;
    
    try
      Result := self.Invoke(c);
    except
      on e: Exception do
      begin
        if insta_call_g<>nil then insta_call_g.had_insta_err := true;
        err_handler.AddErr(e{$ifdef DEBUG}, err_test_reason{$endif});
      end;
    end;
    
  {$ifdef DEBUG}
  finally
    err_handler.EndMaybeError(err_test_reason);
  end;
  {$endif DEBUG}
end;

{$endregion Use}

{$endregion ErrHandler}

{$region UserEvent}

type
  UserEvent = sealed class
    private uev: cl_event;
    private done := new InterlockedBoolean;
    
    {$region constructor's}
    
    private constructor(c: cl_context{$ifdef EventDebug}; reason: string{$endif});
    begin
      var ec: clErrorCode;
      self.uev := cl.CreateUserEvent(c, ec);
      OpenCLABCInternalException.RaiseIfError(ec);
      {$ifdef EventDebug}
      EventDebug.RegisterEventRetain(self.uev, $'Created for {reason}');
      {$endif EventDebug}
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    public static function StartWorkThread(after: EventList; work: Action; g: CLTaskGlobalData{$ifdef EventDebug}; reason: string{$endif}): UserEvent;
    begin
      var res := new UserEvent(g.cl_c
        {$ifdef EventDebug}, $'ThreadedWork, executing {reason}, after waiting on: {after.evs?.JoinToString}'{$endif}
      );
      
      var mre := after.ToMRE({$ifdef EventDebug}$'Threaded work with res_ev={res}'{$endif});
      var err_handler := g.curr_err_handler.Extract({$ifdef DEBUG}true{$endif});
      var thr := new Thread(()->
      try
        if mre<>nil then mre.Wait;
        work;
      finally
        res.SetComplete(err_handler.HadError);
      end);
      thr.IsBackground := true;
      thr.Start;
      
      Result := res;
    end;
    
    {$endregion constructor's}
    
    {$region Status}
    
    /// True если статус получилось изменить
    public function SetComplete(had_error: boolean): boolean;
    begin
      Result := done.TrySet(true);
      if not Result then exit;
      // - Old INTEL drivers break if callback invoked by SetUserEventStatus deletes own event
      //TODO Delete this retain/release pair at some point
      OpenCLABCInternalException.RaiseIfError(cl.RetainEvent(uev));
      try
        OpenCLABCInternalException.RaiseIfError(
          cl.SetUserEventStatus(uev,
            if had_error then
              clCommandExecutionStatus.Create(OpenCLABCInternalException.RelayErrorCode) else
              clCommandExecutionStatus.COMPLETE
          )
        );
      finally
        OpenCLABCInternalException.RaiseIfError(cl.ReleaseEvent(uev));
      end;
    end;
    
    {$endregion Status}
    
    {$region operator's}
    
    public static function operator implicit(ev: UserEvent): cl_event := ev.uev;
    public static function operator implicit(ev: UserEvent): EventList := ev.uev;
    
    //TODO #????
//    public static function operator+(ev1: EventList; ev2: UserEvent): EventList;
//    begin
//      Result := ev1 + ev2.uev;
//      Result.abortable := true;
//    end;
//    public static procedure operator+=(ev1: EventList; ev2: UserEvent);
//    begin
//      ev1 += ev2.uev;
//      ev1.abortable := true;
//    end;
    
    public function ToString: string; override := $'UserEvent[{uev.val}]';
    
    {$endregion operator's}
    
  end;
  
{$endregion UserEvent}

{$region QueueResAction}

type
  QueueResAction = CLContext->();
  
  [StructLayout(LayoutKind.Auto)]
  QueueResComplDelegateData = record
    private call_list: array of QueueResAction := nil;
    private count := 0;
    
    private const initial_cap = 4;
    
    public constructor := exit;
    public constructor(d: QueueResAction);
    begin
      call_list := new QueueResAction[initial_cap];
      call_list[0] := d;
      count := 1;
    end;
    
    public procedure AddAction(d: QueueResAction);
    begin
      if count=0 then
        call_list := new QueueResAction[initial_cap] else
      if count=call_list.Length then
        System.Array.Resize(call_list, call_list.Length * 4);
      call_list[count] := d;
      count += 1;
    end;
    public procedure AddActions(l: QueueResComplDelegateData);
    begin
      {$ifdef DEBUG}
      if l.count=0 then raise new OpenCLABCInternalException($'');
      {$endif DEBUG}
      if self.count=0 then
      begin
        self.call_list := l.call_list;
        self.count := l.count;
        exit;
      end;
      
      var new_cap := Max(self.call_list.Length, l.call_list.Length);
      if self.count+l.count > new_cap then
        new_cap *= 2;
      
      if l.call_list.Length=new_cap then
      begin
        System.Array.Copy(   l.call_list,0, l.call_list,self.count, l.count);
        System.Array.Copy(self.call_list,0, l.call_list,0,          self.count);
        self.call_list := l.call_list;
        self.count += l.count;
      end else
      begin
        if self.call_list.Length<>new_cap then
          System.Array.Resize(self.call_list, new_cap);
        System.Array.Copy(l.call_list,0, self.call_list,self.count, l.count);
        self.count += l.count;
      end;
      
    end;
    
    {$ifdef DEBUG}
    private last_invoke_trace := default(string);
    {$endif DEBUG}
    public procedure Invoke(c: CLContext);
    begin
      {$ifdef DEBUG}
      if last_invoke_trace<>nil then raise new System.InvalidProgramException($'{TypeName(self)}: {#10}{last_invoke_trace}{#10+''-''*30+#10}{System.Environment.StackTrace}');
      last_invoke_trace := System.Environment.StackTrace;
      {$endif DEBUG}
      for var i := 0 to count-1 do
        call_list[i](c);
    end;
    
    {$ifdef DEBUG}
    private const _taken_out_acts_c = -1;
    {$endif DEBUG}
    public function IsTakenOut: boolean;
    begin
      Result := false;
      {$ifdef DEBUG}
      Result := self.count = _taken_out_acts_c;
      {$endif DEBUG}
    end;
    public function TakeOut: QueueResComplDelegateData;
    begin
      Result := self;
      self.call_list := nil;
      {$ifdef DEBUG}
      self.count := _taken_out_acts_c;
      {$endif DEBUG}
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function AttachInvokeTo(ev: EventList; g: CLTaskGlobalData{$ifdef EventDebug}; attach_after: object{$endif}): EventList;
    begin
      var acts := self.TakeOut;
      
      if acts.count=0 then
      begin
        Result := ev;
        exit;
      end else
      {$ifdef DEBUG}
      if acts.IsTakenOut then // Check double .AttachInvokeTo call
        raise new OpenCLABCInternalException($'.AttachInvokeActions called twice') else
      if (ev.count=0) and (acts.count<>0) then
        raise new OpenCLABCInternalException($'Broken .Invoke') else
      {$endif DEBUG}
        ;
      
      var uev := new UserEvent(g.cl_c{$ifdef EventDebug}, $'res_ev for {TypeName(attach_after)}.AttachInvokeActions, after: {ev.evs?.JoinToString}'{$endif});
      var c := g.c;
      var err_handler := g.curr_err_handler.Extract({$ifdef DEBUG}true{$endif});
      ev.MultiAttachCallback(()->
      begin
        acts.Invoke(c);
        uev.SetComplete(err_handler.HadError);
      end{$ifdef EventDebug}, $'body of {TypeName(attach_after)}.AttachInvokeActions with res_ev={uev}'{$endif});
      
      Result := uev;
    end;
    
    {$ifdef DEBUG}
    public procedure AssertFinalIntegrity :=
    if (call_list<>nil) and (last_invoke_trace=nil) then
    begin
      var sb := new StringBuilder;
      sb += 'Actions were not called:'#10;
      for var i := 0 to count-1 do
      begin
        CommandQueueBase.ToStringWriteDelegate(sb, call_list[i]);
        sb += #10;
      end;
      raise new System.InvalidProgramException(sb.ToString);
    end;
    {$endif DEBUG}
    
  end;
  
{$endregion QueueResAction}

{$region CLTaskLocalData}

type
  [StructLayout(LayoutKind.Auto)]
  CLTaskLocalData = record
    public prev_delegate := default(QueueResComplDelegateData);
    public prev_ev := EventList.Empty;
    
    public constructor := exit;
    public constructor(ev: EventList) := self.prev_ev := ev;
    
    public function ShouldInstaCallAction: boolean;
    begin
      // Only const can have not events
      Result := prev_ev.count=0;
      {$ifdef DEBUG}
      if Result and (prev_delegate.count<>0) then raise new OpenCLABCInternalException($'Broken Quick.Invoke detected');
      {$endif DEBUG}
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function AttachInvokeActions(g: CLTaskGlobalData{$ifdef EventDebug}; attach_after: object{$endif}) :=
    prev_delegate.AttachInvokeTo(prev_ev, g{$ifdef EventDebug}, attach_after{$endif});
    
  end;
  
  CommandQueueInvoker<TR> = (CLTaskGlobalData, CLTaskLocalData)->TR;
  
{$endregion CLTaskLocalData}

{$region QueueRes}

{$region Base}

type
  IQueueRes = interface
    
    property ResEv: EventList read;
    
    // Whether res can be read before event completes
    property IsConst: boolean read;
    
    function ShouldInstaCallAction: boolean;
    procedure AddAction(d: QueueResAction);
    procedure AddActions(d: QueueResComplDelegateData);
    
    function AttachInvokeActions(g: CLTaskGlobalData): EventList;
    
    function MakeWrapWithImpl(new_ev: EventList): IQueueRes;
    
    procedure SetRes<TRes>(res: TRes);
    
  end;
  
  QueueRes<T> = abstract partial class end;
  IQueueResFactory<T,TR> = interface
  where TR: IQueueRes;
    
    function MakeConst(l: CLTaskLocalData; res: T): TR;
    
    function MakeDelayed(l: CLTaskLocalData; make_act: TR->QueueResAction): TR;
    function MakeDelayed(make_l: TR->CLTaskLocalData): TR;
    
    function MakeWrap(qr: QueueRes<T>; new_ev: EventList): TR;
    
  end;
  
  [StructLayout(LayoutKind.Auto)]
  QueueResData = record
    private complition_delegate  := default(QueueResComplDelegateData);
    private ev                   := EventList.Empty;
    {$ifdef DEBUG}
    private creation_trace := Environment.StackTrace;
    {$endif DEBUG}
    
    public static function operator implicit(base: QueueResData): CLTaskLocalData;
    begin
      Result := new CLTaskLocalData(base.ev);
      Result.prev_delegate := base.complition_delegate;
    end;
    
    public property ResEv: EventList read ev;
    
    public function ShouldInstaCallAction: boolean;
    begin
      {$ifdef DEBUG}
      if complition_delegate.IsTakenOut then
        raise new OpenCLABCInternalException($'ShouldInstaCallAction when action is already gone');
      {$endif DEBUG}
      Result := CLTaskLocalData(self).ShouldInstaCallAction;
    end;
    
    private procedure CheckValidAddAction;
    begin
      {$ifdef DEBUG}
      if ShouldInstaCallAction then raise new OpenCLABCInternalException($'Broken Quick.Invoke detected');
      {$endif DEBUG}
    end;
    public procedure AddAction(d: QueueResAction);
    begin
      CheckValidAddAction;
      complition_delegate.AddAction(d);
    end;
    public procedure AddActions(d: QueueResComplDelegateData);
    begin
      if d.count=0 then exit;
      CheckValidAddAction;
      complition_delegate.AddActions(d);
    end;
    
  end;
  
{$endregion Base}

{$region Nil}

type
  [StructLayout(LayoutKind.Auto)]
  QueueResNil = record(IQueueRes)
    private base := new QueueResData;
    
    {$ifdef DEBUG}
    public static created_count := 0;
    {$endif DEBUG}
    
    public constructor(l: CLTaskLocalData);
    begin
      {$ifdef DEBUG}
      Interlocked.Increment(created_count);
      {$endif DEBUG}
      base.ev := l.prev_ev;
      base.complition_delegate := l.prev_delegate;
    end;
    public constructor(ev: EventList) := Create(new CLTaskLocalData(ev));
    public constructor := raise new OpenCLABCInternalException;
    
    public property ResEv: EventList read base.ResEv;
    
    private function raise_is_const: boolean;
    begin
      Result := false;
      raise new OpenCLABCInternalException($'');
    end;
    public property IsConst: boolean read raise_is_const;
    
    public function ShouldInstaCallAction := base.ShouldInstaCallAction;
    public procedure AddAction(d: QueueResAction) := base.AddAction(d);
    public procedure AddActions(d: QueueResComplDelegateData) := base.AddActions(d);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function AttachInvokeActions(g: CLTaskGlobalData) :=
    base.complition_delegate.AttachInvokeTo(base.ResEv, g{$ifdef EventDebug}, self{$endif});
    
    public procedure InvokeActions(c: CLContext) := base.complition_delegate.Invoke(c);
    
    //TODO mono#11034
    public function {IQueueRes.}MakeWrapWithImpl(new_ev: EventList): IQueueRes := new QueueResNil(new_ev);
    
    //TODO mono#11034
    public procedure {IQueueRes.}SetRes<TRes>(res: TRes) := exit;
    
  end;
  
  QueueResNilFactory<T> = record(IQueueResFactory<T, QueueResNil>)
    
    public function MakeConst(l: CLTaskLocalData; res: T) := new QueueResNil(l);
    
    public function MakeDelayed(l: CLTaskLocalData; make_act: QueueResNil->QueueResAction): QueueResNil;
    begin
      Result := new QueueResNil(l);
      Result.AddAction(make_act(Result));
    end;
    public function MakeDelayed(make_l: QueueResNil->CLTaskLocalData) := new QueueResNil(make_l(default(QueueResNil)));
    
    public function MakeWrap(qr: QueueRes<T>; new_ev: EventList) := new QueueResNil(new_ev);
    
  end;
  QueueRes<T> = abstract partial class
    static nil_factory := new QueueResNilFactory<T>;
  end;
  
{$endregion Nil}

{$region <T>}

{$region Base}

type
  QueueResT = abstract class(IQueueRes)
    private base := new QueueResData;
    private res_const: boolean; // Whether res can be read before event completes
    
    {$ifdef DEBUG}
    public static created_count := new ConcurrentDictionary<string, integer>;
    public constructor;
    begin
      created_count.AddOrUpdate(TypeName(self), t->1, (t,c)->c+1);
    end;
    {$endif DEBUG}
    
    public property ResEv: EventList read base.ResEv;
    
    private function GetIsConst: boolean;
    begin
      Result := res_const;
      {$ifdef DEBUG}
      if not Result and not base.complition_delegate.IsTakenOut and ShouldInstaCallAction then
        raise new OpenCLABCInternalException($'Need to insta call implies const result');
      {$endif DEBUG}
    end;
    public property IsConst: boolean read GetIsConst;
    
    public function ShouldInstaCallAction := base.ShouldInstaCallAction;
    public procedure AddAction(d: QueueResAction) := base.AddAction(d);
    public procedure AddActions(d: QueueResComplDelegateData) := base.AddActions(d);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function AttachInvokeActions(g: CLTaskGlobalData) :=
    base.complition_delegate.AttachInvokeTo(base.ResEv, g{$ifdef EventDebug}, self{$endif});
    
    public function MakeWrapWithImpl(new_ev: EventList): IQueueRes; abstract;
    
    {$ifdef DEBUG}
    private status_checked := new InterlockedBoolean;
    protected procedure ExpectCheckStatus :=
    ResEv.Retain({$ifdef EventDebug}$'for status check of {TypeName(self)}[{self.GetHashCode}]'{$endif});
    protected procedure CheckStatus :=
    //TODO В каких случаях надо это проверять?
    // - И на всяк вставил в CancelStatusCheck, потому что его в конце выполнения вызывает
    // - В случае MU наверное - но это поидее правильнее как то обходить
    // - К примеру выделять несколько проверок оконченности специально для размноженной очереди
    if status_checked.TrySet(true) then
    begin
      if not IsConst and not ResEv.HasCompleted then
      begin
        var err := new StringBuilder($'Result read before {ResEv.count} events completed:');
        for var i := 0 to ResEv.count-1 do
        begin
          err += #10#9;
          err += ResEv[i].ToString;
          err += ': ';
          err += EventList.GetStatus(ResEv[i]).ToString;
        end;
        {$ifdef EventDebug}
        EventDebug.ReportEventLogs(Console.Error);
        {$endif EventDebug}
        raise new OpenCLABCInternalException(err.ToString);
      end;
      ResEv.Release({$ifdef EventDebug}$'after status check of {TypeName(self)}[{self.GetHashCode}]'{$endif});
    end;
    private procedure CancelStatusCheck(reason: string) :=
      if status_checked.TrySet(true) then
        ResEv.Release({$ifdef EventDebug}$'cancel status check of {TypeName(self)}[{self.GetHashCode}], because {reason}'{$endif});
    {$endif DEBUG}
    public function TakeBaseOut: QueueResData;
    begin
      Result := self.base;
      {$ifdef DEBUG}
      CancelStatusCheck($'base was taken out');
      {$endif DEBUG}
      self.base := default(QueueResData);
      {$ifdef DEBUG}
      base.complition_delegate.count := QueueResComplDelegateData._taken_out_acts_c;
      {$endif DEBUG}
    end;
    
    public procedure SetRes<TRes>(res: TRes); abstract;
    
  end;
  
  QueueRes<T> = abstract partial class(QueueResT)
    
    protected procedure InitConst(l: CLTaskLocalData; res: T);
    begin
      base.ev := l.prev_ev;
      base.complition_delegate := l.prev_delegate;
      SetRes(res);
      res_const := true;
      {$ifdef DEBUG}
      ExpectCheckStatus;
      {$endif DEBUG}
    end;
    
    protected procedure InitDelayed(l: CLTaskLocalData);
    begin
      base.ev := l.prev_ev;
      base.complition_delegate := l.prev_delegate;
      {$ifdef DEBUG}
      if ResEv.count=0 then raise new OpenCLABCInternalException($'Delayed QueueRes, but it is not delayed');
      ExpectCheckStatus;
      {$endif DEBUG}
    end;
    protected procedure InitDelayed(l: CLTaskLocalData; act: QueueResAction);
    begin
      InitDelayed(l);
      AddAction(act);
    end;
    
    protected procedure InitWrap(prev_qr: QueueRes<T>; new_ev: EventList);
    begin
      base.ev := new_ev;
      {$ifdef DEBUG}
      ExpectCheckStatus;
      MarkResSet;
      {$endif DEBUG}
      self.res_const := prev_qr.res_const;
    end;
    
    {$ifdef DEBUG}
    private res_last_set := default(string);
    protected procedure MarkResSet;
    begin
      if res_const then raise new OpenCLABCInternalException($'Result set on const qr');
      if res_last_set<>nil then raise new OpenCLABCInternalException($'Result set twice: {#10}{res_last_set}{#10+''-''*30+#10}{System.Environment.StackTrace}');
      res_last_set := Environment.StackTrace;
    end;
    {$endif DEBUG}
    
    public procedure SetRes<TRes>(res: TRes); override := SetRes(T(res as object));
    public procedure SetRes(res: T);
    begin
      {$ifdef DEBUG}
      MarkResSet;
      {$endif DEBUG}
      SetResImpl(res);
    end;
    protected procedure SetResImpl(res: T); abstract;
    public function GetRes(c: CLContext): T;
    begin
      base.complition_delegate.Invoke(c);
      Result := GetResDirect;
    end;
    public function GetResDirect: T;
    begin
      {$ifdef DEBUG}
      CheckStatus;
      {$endif DEBUG}
      Result := GetResImpl;
    end;
    protected function GetResImpl: T; abstract;
    
    {$ifdef DEBUG}
    protected procedure Finalize; override;
    begin
      base.complition_delegate.AssertFinalIntegrity;
      if res_last_set=nil then raise new OpenCLABCInternalException($'Result was not set for qr created at{#10}{base.creation_trace}{#10+''-''*30}');
    end;
    {$endif DEBUG}
    
  end;
  
{$endregion Base}

{$region Val}

type
  QueueResVal<T> = abstract partial class(QueueRes<T>)
    
    public function MakeWrapWithImpl(new_ev: EventList): IQueueRes; override;
    
  end;
  
  QueueResValDirect<T> = sealed class(QueueResVal<T>)
    private res: T;
    
    public constructor(l: CLTaskLocalData; res: T) := InitConst(l, res);
    
    public constructor(l: CLTaskLocalData; make_act: QueueResVal<T>->QueueResAction) := InitDelayed(l, make_act(self));
    public constructor(make_l: QueueResVal<T>->CLTaskLocalData) := InitDelayed(make_l(self));
    
    private constructor := raise new OpenCLABCInternalException;
    
    protected procedure SetResImpl(res: T); override := self.res := res;
    protected function GetResImpl: T; override := self.res;
    
  end;
  
  QueueResValWrap<T> = sealed class(QueueResVal<T>)
    private prev_qr: QueueRes<T>;
    
    public constructor(prev_qr: QueueRes<T>; new_ev: EventList);
    begin
      {$ifdef DEBUG}
      // While debuging .GetResDirect should be called on all wraps
      // Otherwise some status checks would be skipped
      {$else DEBUG}
      if prev_qr is QueueResValWrap<T>(var qrw) then prev_qr := qrw.prev_qr;
      {$endif DEBUG}
      InitWrap(prev_qr, new_ev);
      self.prev_qr := prev_qr;
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    protected procedure SetResImpl(res: T); override := raise new OpenCLABCInternalException($'QueueResValWrap is made for indirect read of QueueRes, it should not be written to');
    protected function GetResImpl: T; override := prev_qr.GetResDirect;
    
  end;
  
  QueueResValFactory<T> = sealed class(IQueueResFactory<T, QueueResVal<T>>)
    
    public function MakeConst(l: CLTaskLocalData; res: T): QueueResVal<T> :=
    new QueueResValDirect<T>(l, res);
    
    public function MakeDelayed(l: CLTaskLocalData; make_act: QueueResVal<T>->QueueResAction): QueueResVal<T> :=
    new QueueResValDirect<T>(l, make_act);
    public function MakeDelayed(make_l: QueueResVal<T>->CLTaskLocalData): QueueResVal<T> :=
    new QueueResValDirect<T>(make_l);
    
    public function MakeWrap(qr: QueueRes<T>; new_ev: EventList): QueueResVal<T> :=
    new QueueResValWrap<T>(qr, new_ev);
    
  end;
  QueueRes<T> = abstract partial class(QueueResT)
    public static function val_factory := new QueueResValFactory<T>;
  end;
  
{$endregion Val}

{$region Ptr}

type
  // LayoutKind.Auto is not compatible with GCHandle
  [StructLayout(LayoutKind.Sequential)]
  QueueResPtrData<T> = record
    public val: T;
    public ref_count: integer;
    
    public procedure Retain := Interlocked.Increment(ref_count);
    public function Release := Interlocked.Decrement(ref_count)=0;
    
  end;
  
  QueueResPtr<T> = sealed partial class(QueueRes<T>)
    private data: NativeValueArea<QueueResPtrData<T>>;
    
    static constructor := BlittableHelper.RaiseIfBad(typeof(T), $'использовать в некоторой внутренней ситуации (напишите об этом в issue)');
    
    private procedure AllocData;
    begin
      data.Alloc;
      data.Pointer^.ref_count := 1;
    end;
    
    public constructor(l: CLTaskLocalData; res: T);
    begin
      AllocData;
      InitConst(l, res);
    end;
    
    public constructor(l: CLTaskLocalData; make_act: QueueResPtr<T>->QueueResAction);
    begin
      AllocData;
      InitDelayed(l, make_act(self));
    end;
    public constructor(make_l: QueueResPtr<T>->CLTaskLocalData);
    begin
      AllocData;
      InitDelayed(make_l(self));
    end;
    
    public constructor(prev_qr: QueueResPtr<T>; new_ev: EventList);
    begin
      InitWrap(prev_qr, new_ev);
      self.data := prev_qr.data;
      self.data.Value.Retain;
    end;
    public function MakeWrapWithImpl(new_ev: EventList): IQueueRes; override := new QueueResPtr<T>(self, new_ev);
    
    private constructor := raise new OpenCLABCInternalException;
    
    private function GetResPtrImpl := @(data.Pointer^.val);
    public function GetResPtrForRead: ^T;
    begin
      {$ifdef DEBUG}
      // The whole point of QRPtr is to not wait for ev before enq
      CancelStatusCheck($'result would be read from ptr');
      {$endif DEBUG}
      Result := GetResPtrImpl;
    end;
    public function GetResPtrForWrite: ^T;
    begin
      {$ifdef DEBUG}
      MarkResSet;
      {$endif DEBUG}
      Result := GetResPtrImpl;
    end;
    
    protected procedure SetResImpl(res: T); override := GetResPtrImpl^ := res;
    protected function GetResImpl: T; override := GetResPtrImpl^;
    
    protected procedure Finalize; override;
    begin
      if data.IsAllocated and data.Value.Release then data.Release;
      inherited;
    end;
    
  end;
  
  QueueResPtrFactory<T> = sealed class(IQueueResFactory<T, QueueResPtr<T>>)
    
    public function MakeConst(l: CLTaskLocalData; res: T) := new QueueResPtr<T>(l, res);
    
    public function MakeDelayed(l: CLTaskLocalData; make_act: QueueResPtr<T>->QueueResAction) := new QueueResPtr<T>(l, make_act);
    public function MakeDelayed(make_l: QueueResPtr<T>->CLTaskLocalData) := new QueueResPtr<T>(make_l);
    
    public function MakeWrap(prev_qr: QueueRes<T>; new_ev: EventList): QueueResPtr<T>;
    begin
      {$ifdef DEBUG}
      if not prev_qr.base.complition_delegate.IsTakenOut then
        raise new OpenCLABCInternalException($'.AttachInvokeActions should be called before making a wrap qr');
      {$endif DEBUG}
      
      if prev_qr is QueueResPtr<T>(var qrp) then
        Result := new QueueResPtr<T>(qrp, new_ev) else
      begin
        var l := new CLTaskLocalData(new_ev);
        
        Result := if prev_qr.IsConst then
          new QueueResPtr<T>(l, prev_qr.GetResDirect) else
          new QueueResPtr<T>(l, qr->c->qr.SetRes(prev_qr.GetResDirect));
        
      end;
      
    end;
    
  end;
  QueueRes<T> = abstract partial class(QueueResT)
    public static function ptr_factory := new QueueResPtrFactory<T>;
  end;
  
{$endregion Ptr}

{$endregion <T>}

{$region Impl}

{$region MakeWrapWith}

function QueueResVal<T>.MakeWrapWithImpl(new_ev: EventList) := val_factory.MakeWrap(self, new_ev);

[MethodImpl(MethodImplOptions.AggressiveInlining)]
function MakeWrapWith<TR>(self: TR; new_ev: EventList): TR; extensionmethod; where TR: IQueueRes;
begin
  Result := TR( self.MakeWrapWithImpl(new_ev) );
end;

{$endregion MakeWrapWith}

{$region TransformResult}

type
  QueueRes<T> = abstract partial class(QueueResT)
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function TransformResult<T2,TR>(factory: IQueueResFactory<T2,TR>; can_pre_call: boolean; transform: T->T2): TR; where TR: IQueueRes;
    begin
      // Before .TakeBaseOut, because .IsConst checks ResEv
      var should_make_const := if can_pre_call then
        self.IsConst else self.ShouldInstaCallAction;
      var res_l := CLTaskLocalData(self.TakeBaseOut);
      
      Result := if should_make_const then
        factory.MakeConst(res_l, transform(self.GetResDirect)) else
        factory.MakeDelayed(res_l, qr->c->qr.SetRes(transform(self.GetResDirect)));
      
    end;
    
  end;
  
{$endregion TransformResult}

{$region TrySkipInvoke}

function TrySkipInvoke<T,TR>(self: IQueueResFactory<T,TR>;
  g: CLTaskGlobalData; l: CLTaskLocalData;
  q: CommandQueue<T>; sub_inv: CommandQueueInvoker<QueueResNil>;
  var qr: TR
): boolean; extensionmethod; where TR: IQueueRes;
begin
  Result := g.CheckDeps(q.const_res_dep);
  if not Result then exit;
  qr := self.MakeConst(
    sub_inv(g,l).base,
    q.expected_const_res
  );
end;

{$endregion TrySkipInvoke}

{$region AddToEvLst}

type
  QueueRes<T> = abstract partial class
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static function AddToEvLst<TR>(qr: TR; g: CLTaskGlobalData; evs: DoubleList<EventList>; to_l1: boolean): TR; where TR: QueueRes<T>;
    begin
      var ev := qr.AttachInvokeActions(g);
      if qr.IsConst then to_l1 := false;
      if ev.count=0 then
        {$ifdef DEBUG}evs.FakeAdd(to_l1){$endif} else
        evs.Add(ev, to_l1);
      Result := qr;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function AddToEvLst(g: CLTaskGlobalData; evs: DoubleList<EventList>; to_l1: boolean) := AddToEvLst(self, g, evs, to_l1);
    
  end;
  QueueResPtr<T> = sealed partial class
    
    // Another method to retain the type of self
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function AddToEvLst(g: CLTaskGlobalData; evs: DoubleList<EventList>; to_l1: boolean) := AddToEvLst(self, g, evs, to_l1);
    
  end;
  
{$endregion AddToEvLst}

{$endregion Impl}

{$endregion QueueRes}

{$endregion Invoke result}

{$region Invoke state}

{$region MultiuseableResultData}

type
  IMultiusableCommandQueue = interface
    
    {$ifdef DEBUG}
    property Victim: CommandQueueBase read;
    {$endif DEBUG}
    
  end;
  [StructLayout(LayoutKind.Auto)]
  MultiuseableResultData = record
    public qres: IQueueRes;
    public ev: EventList;
    public victim_err_handler: ErrHandler;
    public had_insta_err: boolean;
    
    public constructor(qres: IQueueRes; ev: EventList; victim_err_handler: ErrHandler; had_insta_err: boolean);
    begin
      self.qres := qres;
      self.ev := ev;
      self.victim_err_handler := victim_err_handler;
      self.had_insta_err := had_insta_err;
    end;
    
  end;
  CLTaskGlobalData = sealed partial class
    
    public mu_res := new Dictionary<IMultiusableCommandQueue, MultiuseableResultData>;
    
    public prev_mu := new HashSet<IMultiusableCommandQueue>;
    
  end;
  
{$endregion MultiuseableResultData}

{$region CLTaskBranchInvoker}

type
  CLTaskBranchInvoker = sealed class
    private g: CLTaskGlobalData;
    private prev_ev: EventList?;
    private prev_cq := cl_command_queue.Zero;
    private prev_mu: array of IMultiusableCommandQueue;
    private total_mu: HashSet<IMultiusableCommandQueue>;
    
    private prev_had_insta_err: boolean;
    private base_err_handler: LazyErrHandler;
    private branch_handlers := new List<ErrHandler>;
    
    {$ifdef DEBUG}
    private missing_handler_c: integer;
    {$endif DEBUG}
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    constructor(g: CLTaskGlobalData; prev_ev: EventList?; capacity: integer);
    begin
      self.g := g;
      self.prev_ev := prev_ev;
      {$ifdef DEBUG}
      self.missing_handler_c := capacity;
      {$endif DEBUG}
      
      if g.curr_inv_cq<>cl_command_queue.Zero then
      begin
        {$ifdef DEBUG}
        if g.outer_cq<>cl_command_queue.Zero then raise new OpenCLABCInternalException($'outer_cq should be taken when curr_inv_cq is not Zero');
        {$endif DEBUG}
        
        // Make outer only if ParallelInvoke is said to wait for event of current cq
        // Otherwise command parameters would be added to outer cq, causing them to wait anyway
        if prev_ev<>nil then
        begin
          {$ifdef DEBUG}
          if prev_ev.Value.count=0 then raise new OpenCLABCInternalException($'prev_ev should not be Zero when curr_inv_cq is not Zero');
          {$endif DEBUG}
          g.outer_cq := g.curr_inv_cq;
        end else
          self.prev_cq := g.curr_inv_cq;
        
        g.curr_inv_cq := cl_command_queue.Zero;
      end;
      
      self.prev_mu := g.prev_mu.ToArray;
      self.total_mu := g.prev_mu.ToHashSet;
      {$ifdef DEBUG}
      g.prev_mu := nil;
      {$endif DEBUG}
      
      self.prev_had_insta_err := g.had_insta_err;
      var origin_handler := g.curr_err_handler;
      {$ifdef DEBUG}
      if (prev_ev=nil) and origin_handler.HasValue then
        raise new OpenCLABCInternalException($'');
      {$endif DEBUG}
      self.base_err_handler := ErrHandlerBranchBud.Wrap(origin_handler{$ifdef DEBUG}, $'branch invoke'{$endif});
      self.branch_handlers.Capacity := capacity;
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function InvokeBranch<TR>(branch: CommandQueueInvoker<TR>; par_err_handlers: DoubleList<ErrHandler>; to_l1: boolean): TR; where TR: IQueueRes;
    begin
      g.had_insta_err := self.prev_had_insta_err;
      g.curr_err_handler := self.base_err_handler;
      
      var l := if self.prev_ev=nil then
        new CLTaskLocalData else
        new CLTaskLocalData(self.prev_ev.Value);
      
      g.prev_mu := if prev_ev<>nil then
        self.prev_mu.ToHashSet else
        new HashSet<IMultiusableCommandQueue>;
      
      Result := branch(g, l); // INVOKE
      
      if g.had_insta_err then
        self.prev_had_insta_err := true;
      
      if (par_err_handlers<>nil) and Result.IsConst then
        to_l1 := false;
      
      self.total_mu.UnionWith(g.prev_mu);
      {$ifdef DEBUG}
      g.prev_mu := nil;
      {$endif DEBUG}
      
      var cq := g.curr_inv_cq;
      if cq<>cl_command_queue.Zero then
      begin
        g.curr_inv_cq := cl_command_queue.Zero;
        if prev_cq=cl_command_queue.Zero then
          prev_cq := cq else
        begin
          OpenCLABCInternalException.RaiseIfError( cl.Flush(cq) );
          Result.AddAction(c->self.g.ReturnCQ(cq));
        end;
      end;
      
      var br_err_handler := g.curr_err_handler.ForceSkipFunc({$ifdef DEBUG}self.base_err_handler{$endif});
      if br_err_handler<>nil then
      begin
        if par_err_handlers<>nil then
          par_err_handlers.Add(br_err_handler, to_l1) else
          branch_handlers += br_err_handler;
      end else
      begin
        {$ifdef DEBUG}
        if par_err_handlers<>nil then
          par_err_handlers.FakeAdd(to_l1);
        {$endif DEBUG}
      end;
      {$ifdef DEBUG}
      missing_handler_c -= 1;
      {$endif DEBUG}
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function InvokeBranch<TR>(branch: CommandQueueInvoker<TR>): TR; where TR: IQueueRes;
    begin
      Result := InvokeBranch(branch, nil, false);
    end;
    
  end;
  
  CLTaskGlobalData = sealed partial class
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    procedure ParallelInvoke(l: CLTaskLocalData?; capacity: integer; use: CLTaskBranchInvoker->());
    begin
      var prev_ev := default(EventList?);
      // nil for GPUCommand parameters
      if l<>nil then
      begin
        var ev := l.Value.AttachInvokeActions(self{$ifdef EventDebug}, l{$endif});
        if ev.count<>0 then loop capacity-1 do
          ev.Retain({$ifdef EventDebug}$'for all async branches'{$endif});
        prev_ev := ev;
      end;
      
      var origin_err_handler := self.curr_err_handler;
      var invoker := new CLTaskBranchInvoker(self, prev_ev, capacity);
      use(invoker);
      
      {$ifdef DEBUG}
      if invoker.missing_handler_c<>0 then
        raise new OpenCLABCInternalException($'Missing {invoker.missing_handler_c} parallel branches of {capacity}');
      {$endif DEBUG}
      self.curr_err_handler := ErrHandlerBranchCombinator.Wrap(
        origin_err_handler, invoker.branch_handlers.ToArray
        {$ifdef DEBUG}, $'{TypeName(self)}.ParallelInvoke branches union'{$endif}
      );
      
      self.curr_inv_cq := invoker.prev_cq;
      if outer_cq<>cl_command_queue.Zero then self.GetCQ(false);
      
      self.prev_mu := invoker.total_mu;
      
      self.had_insta_err := invoker.prev_had_insta_err;
    end;
    
  end;
  
{$endregion CLTaskBranchInvoker}

{$region CLTaskGlobalData}

type
  CLTaskGlobalData = sealed partial class
    
    public constructor(c: CLContext);
    begin
      
      self.c := c;
      self.cl_c := c.ntv;
      self.cl_dvc := c.main_dvc.ntv;
      
    end;
    
    public procedure FinishInvoke;
    begin
      
      // mu выполняют лишний .Retain, чтобы ивент не удалился пока очередь ещё запускается
      foreach var mrd in mu_res.Values do
        mrd.ev.Release({$ifdef EventDebug}$'excessive mu ev'{$endif});
      {$ifdef DEBUG}
      {$else DEBUG}
      mu_res := nil;
      {$endif DEBUG}
      
      if curr_inv_cq<>cl_command_queue.Zero then
      begin
        OpenCLABCInternalException.RaiseIfError( cl.Flush(curr_inv_cq) );
        ReturnCQ(curr_inv_cq);
      end;
      
    end;
    
    public procedure FinishExecution(var err_lst: List<Exception>);
    begin
      
      {$ifdef DEBUG}
      foreach var mrd in mu_res.Values do
      begin
        var qr := mrd.qres as QueueResT;
        if qr=nil then continue;
        qr.CancelStatusCheck($'CQ<T>.MU result ({TypeName(qr)}) was not used');
      end;
      {$endif DEBUG}
      
      foreach var cq in free_cqs do
        OpenCLABCInternalException.RaiseIfError( cl.ReleaseCommandQueue(cq) );
      
      err_lst := new List<Exception>;
      var err_handler := self.curr_err_handler.v;
      if err_handler<>nil then
      begin
        err_handler.FillErrLst(err_lst);
        {$ifdef DEBUG}
        err_handler.SanityCheck(err_lst);
        {$endif DEBUG}
      end;
    end;
    
  end;
  
{$endregion CLTaskGlobalData}

{$endregion Invoke state}

{$endregion Util type's}

{$region CommandQueue}

{$region Base}

type
  CommandQueueBase = abstract partial class
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_mu: HashSet<IMultiusableCommandQueue>); abstract;
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil; abstract;
    
  end;
  
  CommandQueueNil = abstract partial class(CommandQueueBase)
    
  end;
  
  CommandQueue<T> = abstract partial class(CommandQueueBase)
    
    protected static function qr_nil_factory := QueueRes&<T>.nil_factory;
    protected static function qr_val_factory := QueueRes&<T>.val_factory;
    protected static function qr_ptr_factory := QueueRes&<T>.ptr_factory;
    
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes   <T>; abstract;
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<T>; abstract;
    
  end;
  
{$endregion Base}

{$region Const} type
  
  ConstQueueNil = sealed partial class(CommandQueueNil)
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_mu: HashSet<IMultiusableCommandQueue>); override := exit;
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil; override := new QueueResNil(l);
    
  end;
  
  ConstQueue<T> = sealed partial class(CommandQueue<T>)
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_mu: HashSet<IMultiusableCommandQueue>); override := exit;
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil;    override := new QueueResNil(l);
    //TODO #????: Если убрать - ошибки компиляции нет, но сборка не загружается
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes   <T>; override := qr_val_factory.MakeConst(l, self.Value);
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<T>; override := qr_ptr_factory.MakeConst(l, self.Value);
    
  end;
  
{$endregion Const}

{$region Parameter}

type
  ParameterQueue<T> = sealed partial class(CommandQueue<T>, IParameterQueue)
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_mu: HashSet<IMultiusableCommandQueue>); override;
    begin
      //TODO #????
      if g.parameters.ContainsKey(self as object as IParameterQueue) then exit;
      //TODO #????
      g.parameters[self as object as IParameterQueue] := if self.DefaultDefined then
        new CLTaskParameterData(self.Default) else
        new CLTaskParameterData;
    end;
    
    private function GetParVal(g: CLTaskGlobalData) :=
    //TODO #????
    T(g.parameters[self as object as IParameterQueue].val);
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil;    override := new QueueResNil(l);
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes   <T>; override := qr_val_factory.MakeConst(l, self.GetParVal(g));
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<T>; override := qr_ptr_factory.MakeConst(l, self.GetParVal(g));
    
  end;
  
{$endregion Parameter}

{$endregion CommandQueue}

{$region CLTask}

type
  CLTaskBase = abstract partial class
    
    {$ifdef ErrHandlerDebug}
    private g: CLTaskGlobalData;
    {$endif ErrHandlerDebug}
    
  end;
  
  CLTaskNil = sealed partial class(CLTaskBase)
    
    private constructor(q: CommandQueueNil; c: CLContext; pars: array of ParameterQueueSetter);
    begin
      self.q := q;
      self.org_c := c;
      
      var g := new CLTaskGlobalData(c);
      {$ifdef ErrHandlerDebug}
      self.g := g;
      {$endif ErrHandlerDebug}
      
      q.InitBeforeInvoke(g, new HashSet<IMultiusableCommandQueue>);
      g.ApplyParameters(pars);
      var qr := q.InvokeToNil(g, new CLTaskLocalData);
      g.FinishInvoke;
      
      var mre := qr.ResEv.ToMRE({$ifdef EventDebug}$'CLTaskNil.FinishExecution'{$endif});
      var thr := new Thread(()->
      begin
        if mre<>nil then mre.Wait;
        qr.InvokeActions(self.org_c);
        g.FinishExecution(self.err_lst);
        self.wh.Set;
      end);
      thr.IsBackground := true;
      thr.Start;
      
    end;
    
  end;
  
  CLTask<T> = sealed partial class(CLTaskBase)
    private res: T;
    
    private constructor(q: CommandQueue<T>; c: CLContext; pars: array of ParameterQueueSetter);
    begin
      self.q := q;
      self.org_c := c;
      
      var g := new CLTaskGlobalData(c);
      {$ifdef ErrHandlerDebug}
      self.g := g;
      {$endif ErrHandlerDebug}
      
      q.InitBeforeInvoke(g, new HashSet<IMultiusableCommandQueue>);
      g.ApplyParameters(pars);
      var qr := q.InvokeToAny(g, new CLTaskLocalData);
      g.FinishInvoke;
      
      var mre := qr.ResEv.ToMRE({$ifdef EventDebug}$'CLTask<{typeof(T)}>.FinishExecution'{$endif});
      var thr := new Thread(()->
      begin
        if mre<>nil then mre.Wait;
        self.res := qr.GetRes(self.org_c);
        g.FinishExecution(self.err_lst);
        self.wh.Set;
      end);
      thr.IsBackground := true;
      thr.Start;
      
    end;
    
  end;
  
  CLTaskFactory = record(ITypedCQConverter<CLTaskBase>)
    private c: CLContext;
    private pars: array of ParameterQueueSetter;
    public constructor(c: CLContext; pars: array of ParameterQueueSetter);
    begin
      self.c := c;
      self.pars := pars;
    end;
    public constructor := raise new OpenCLABCInternalException;
    
    public function ConvertNil(cq: CommandQueueNil): CLTaskBase := new CLTaskNil(cq, c, pars);
    public function Convert<T>(cq: CommandQueue<T>): CLTaskBase := new CLTask<T>(cq, c, pars);
    
  end;
  
{$ifdef ErrHandlerDebug}
procedure CLTaskBase.OutputErrHandlers;
begin
  var err_handler := self.g.curr_err_handler.TrySkipFunc;
  if err_handler=nil then exit;
  err_handler.Println;
end;
{$endif ErrHandlerDebug}

function CLContext.BeginInvoke(q: CommandQueueBase; params parameters: array of ParameterQueueSetter) := q.ConvertTyped(new CLTaskFactory(self, parameters));
function CLContext.BeginInvoke(q: CommandQueueNil; params parameters: array of ParameterQueueSetter) := new CLTaskNil(q, self, parameters);
function CLContext.BeginInvoke<T>(q: CommandQueue<T>; params parameters: array of ParameterQueueSetter) := new CLTask<T>(q, self, parameters);

function CLTask<T>.WaitRes: T;
begin
  Wait;
  Result := self.res;
end;

{$endregion CLTask}

{$region Queue converter's}

{$region +/*}

{$region Simple}

//TODO Попробовать пере-групировать
// - И затем сделать регионы
type
  SimpleQueueArrayCommon<TQ> = record
  where TQ: CommandQueueBase;
    public qs: array of CommandQueueBase;
    public last: TQ;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function GetQS: sequence of CommandQueueBase := qs.Append&<CommandQueueBase>(last);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_mu: HashSet<IMultiusableCommandQueue>);
    begin
      foreach var q in qs do q.InitBeforeInvoke(g, inited_mu);
      last.InitBeforeInvoke(g, inited_mu);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function InvokeSync<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; invoke_last: CommandQueueInvoker<TR>): TR; where TR: IQueueRes;
    begin
      for var i := 0 to qs.Length-1 do
        l := qs[i].InvokeToNil(g, l).base;
      
      Result := invoke_last(g, l);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function InvokeAsync<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; invoke_last: CommandQueueInvoker<TR>): TR; where TR: IQueueRes;
    begin
      var evs := new EventList[qs.Length+1];
      
      var res: TR;
      g.ParallelInvoke(l, qs.Length+1, invoker->
      begin
        for var i := 0 to qs.Length-1 do
          //TODO #2610
          evs[i] := invoker.InvokeBranch&<IQueueRes>(
            (g,l)->qs[i].InvokeToNil(g, l)
          ).AttachInvokeActions(g);
        var l_res := invoker.InvokeBranch(invoke_last);
        res := l_res;
        evs[qs.Length] := l_res.AttachInvokeActions(g);
      end);
      
      Result := res.MakeWrapWith(EventList.Combine(evs));
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    procedure ToString(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>);
    begin
      sb += #10;
      foreach var q in qs do
        q.ToString(sb, tabs, index, delayed);
      last.ToString(sb, tabs, index, delayed);
    end;
    
  end;
  
  ISimpleQueueArray = interface
    function GetQS: sequence of CommandQueueBase;
  end;
  ISimpleSyncQueueArray = interface(ISimpleQueueArray) end;
  ISimpleAsyncQueueArray = interface(ISimpleQueueArray) end;
  
  SimpleQueueArrayNil = abstract class(CommandQueueNil, ISimpleQueueArray)
    protected data := new SimpleQueueArrayCommon< CommandQueueNil >;
    
    public constructor(qs: array of CommandQueueBase; last: CommandQueueNil);
    begin
      data.qs := qs;
      data.last := last;
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    public function GetQS: sequence of CommandQueueBase := data.GetQS;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_mu: HashSet<IMultiusableCommandQueue>); override :=
    data.InitBeforeInvoke(g, inited_mu);
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
  SimpleSyncQueueArrayNil = sealed class(SimpleQueueArrayNil, ISimpleSyncQueueArray)
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil; override := data.InvokeSync(g, l, data.last.InvokeToNil);
    
  end;
  SimpleAsyncQueueArrayNil = sealed class(SimpleQueueArrayNil, ISimpleAsyncQueueArray)
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil; override := data.InvokeAsync(g, l, data.last.InvokeToNil);
    
  end;
  
  SimpleQueueArray<T> = abstract class(CommandQueue<T>, ISimpleQueueArray)
    protected data := new SimpleQueueArrayCommon< CommandQueue<T> >;
    
    public constructor(qs: array of CommandQueueBase; last: CommandQueue<T>);
    begin
      data.qs := qs;
      data.last := last;
      self.const_res_dep      := last.const_res_dep;
      self.expected_const_res := last.expected_const_res;
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    public function GetQS: sequence of CommandQueueBase := data.GetQS;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_mu: HashSet<IMultiusableCommandQueue>); override :=
    data.InitBeforeInvoke(g, inited_mu);
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
  SimpleSyncQueueArray<T> = sealed class(SimpleQueueArray<T>, ISimpleSyncQueueArray)
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil;    override := data.InvokeSync(g, l, data.last.InvokeToNil);
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes<T>;    override := data.InvokeSync(g, l, data.last.InvokeToAny);
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<T>; override := data.InvokeSync(g, l, data.last.InvokeToPtr);
    
  end;
  SimpleAsyncQueueArray<T> = sealed class(SimpleQueueArray<T>, ISimpleAsyncQueueArray)
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil;    override := data.InvokeAsync(g, l, data.last.InvokeToNil);
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes   <T>; override := data.InvokeAsync(g, l, data.last.InvokeToAny);
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<T>; override := data.InvokeAsync(g, l, data.last.InvokeToPtr);
    
  end;
  
{$region Utils}

type
  CastQueueBase<TRes> = abstract class(CommandQueue<TRes>)
    
    public property SourceBase: CommandQueueBase read; abstract;
    
  end;
  
  QueueArrayFlattener<TArray> = sealed class(ITypedCQUser)
  where TArray: ISimpleQueueArray;
    public qs := new List<CommandQueueBase>;
    private has_next := false;
    private last_added_nil := false;
    
    public procedure ProcessSeq(s: sequence of CommandQueueBase);
    begin
      var enmr := s.GetEnumerator;
      if not enmr.MoveNext then exit;
      
      var upper_had_next := self.has_next;
      while true do
      begin
        var curr := enmr.Current;
        var l_has_next := enmr.MoveNext;
        self.has_next := upper_had_next or l_has_next;
        curr.UseTyped(self);
        if not l_has_next then break;
      end;
      // last val was "upper_had_next or false"
//      self.has_next := upper_had_next;
      
    end;
    
    //TODO mono#11034
    public procedure {ITypedCQUser.}UseNil(cq: CommandQueueNil);
    begin
      if has_next or last_added_nil then
      begin
        if cq is ConstQueueNil then exit;
      end;
      if cq is TArray(var sqa) then
        ProcessSeq(sqa.GetQs) else
      begin
        qs.Add(cq);
        last_added_nil := true;
      end;
    end;
    //TODO mono#11034
    public procedure {ITypedCQUser.}Use<T>(cq: CommandQueue<T>);
    begin
      if has_next then
      begin
        if cq is ConstQueue<T> then exit;
        if cq is ParameterQueue<T> then exit;
        if cq is CastQueueBase<T>(var cqb) then
        begin
          cqb.SourceBase.UseTyped(self);
          exit;
        end;
      end;
      if cq is TArray(var sqa) then
        ProcessSeq(sqa.GetQs) else
      begin
        qs.Add(cq);
        last_added_nil := false;
      end;
    end;
    
  end;
  
  QueueArrayConstructorBase = abstract class
    private body: array of CommandQueueBase;
    
    public constructor(body: array of CommandQueueBase) := self.body := body;
    private constructor := raise new OpenCLABCInternalException;
    
  end;
  
  QueueArraySyncConstructor = sealed class(QueueArrayConstructorBase, ITypedCQConverter<CommandQueueBase>)
    public function ConvertNil(last: CommandQueueNil): CommandQueueBase := new SimpleSyncQueueArrayNil(body, last);
    public function Convert<T>(last: CommandQueue<T>): CommandQueueBase := new SimpleSyncQueueArray<T>(body, last);
  end;
  QueueArrayAsyncConstructor = sealed class(QueueArrayConstructorBase, ITypedCQConverter<CommandQueueBase>)
    public function ConvertNil(last: CommandQueueNil): CommandQueueBase := new SimpleAsyncQueueArrayNil(body, last);
    public function Convert<T>(last: CommandQueue<T>): CommandQueueBase := new SimpleAsyncQueueArray<T>(body, last);
  end;
  
  QueueArrayUtils = static class
    
    private static function FlattenQueueArray<T>(inp: sequence of CommandQueueBase): List<CommandQueueBase>; where T: ISimpleQueueArray;
    begin
      var res := new QueueArrayFlattener<T>;
      res.ProcessSeq(inp);
      Result := res.qs;
    end;
    private static function SeparateLast(qs: List<CommandQueueBase>): ValueTuple<List<CommandQueueBase>,CommandQueueBase>;
    begin
      var last_ind := qs.Count-1;
      var last := qs[last_ind];
      qs.RemoveAt(last_ind);
      Result := ValueTuple.Create(qs,last);
    end;
    
    private static function Construct<T,TQ>(inp: sequence of CommandQueueBase; make_constructor: Func<array of CommandQueueBase, ITypedCQConverter<CommandQueueBase>>): TQ;
    where T: ISimpleQueueArray;
    where TQ: CommandQueueBase;
    begin
      var qs := FlattenQueueArray&<T>(inp);
      case qs.Count of
        0:
        if CQNil is TQ(var res) then
          Result := res else
          raise new System.ArgumentException('%Err:QueueArrayUtils:EmptyNotAllowed%');
        1:
          Result := TQ(qs[0]);
        else
        begin
          var (body, last) := SeparateLast(qs);
          Result := TQ(last.ConvertTyped(make_constructor(body.ToArray)));
        end;
      end;
    end;
    
    public static function ConstructSync<TQ>(inp: sequence of CommandQueueBase): TQ; where TQ: CommandQueueBase;
    begin
      Result := Construct&<ISimpleSyncQueueArray,TQ>(inp, body->new QueueArraySyncConstructor(body));
    end;
    
    public static function ConstructAsync<TQ>(inp: sequence of CommandQueueBase): TQ; where TQ: CommandQueueBase;
    begin
      Result := Construct&<ISimpleAsyncQueueArray,TQ>(inp, body->new QueueArrayAsyncConstructor(body));
    end;
    
  end;
  
{$endregion Utils}

{$region CQ operator's}

function operator+(q1, q2: CommandQueueBase); extensionmethod := QueueArrayUtils.ConstructSync &<CommandQueueBase>(|q1, q2|);
function operator*(q1, q2: CommandQueueBase); extensionmethod := QueueArrayUtils.ConstructAsync&<CommandQueueBase>(|q1, q2|);

function operator+(q1: CommandQueueBase; q2: CommandQueueNil); extensionmethod := QueueArrayUtils.ConstructSync &<CommandQueueNil>(|q1, q2|);
function operator*(q1: CommandQueueBase; q2: CommandQueueNil); extensionmethod := QueueArrayUtils.ConstructAsync&<CommandQueueNil>(|q1, q2|);

function operator+<T>(q1: CommandQueueBase; q2: CommandQueue<T>); extensionmethod := QueueArrayUtils.ConstructSync &<CommandQueue<T>>(|q1, q2|);
function operator*<T>(q1: CommandQueueBase; q2: CommandQueue<T>); extensionmethod := QueueArrayUtils.ConstructAsync&<CommandQueue<T>>(|q1, q2|);



procedure operator+=(var q1: CommandQueueBase; q2: CommandQueueBase); extensionmethod := q1 := q1+q2;
procedure operator*=(var q1: CommandQueueBase; q2: CommandQueueBase); extensionmethod := q1 := q1*q2;

procedure operator+=(var q1: CommandQueueNil; q2: CommandQueueNil); extensionmethod := q1 := q1+q2;
procedure operator*=(var q1: CommandQueueNil; q2: CommandQueueNil); extensionmethod := q1 := q1*q2;

procedure operator+=<T>(var q1: CommandQueue<T>; q2: CommandQueue<T>); extensionmethod := q1 := q1+q2;
procedure operator*=<T>(var q1: CommandQueue<T>; q2: CommandQueue<T>); extensionmethod := q1 := q1*q2;



procedure operator-=(var q1: CommandQueueBase; q2: CommandQueueBase); extensionmethod := q1 := q2+q1;
procedure operator/=(var q1: CommandQueueBase; q2: CommandQueueBase); extensionmethod := q1 := q2*q1;

procedure operator-=(var q1: CommandQueueNil; q2: CommandQueueBase); extensionmethod := q1 := q2+q1;
procedure operator/=(var q1: CommandQueueNil; q2: CommandQueueBase); extensionmethod := q1 := q2*q1;

procedure operator-=<T>(var q1: CommandQueue<T>; q2: CommandQueueBase); extensionmethod := q1 := q2+q1;
procedure operator/=<T>(var q1: CommandQueue<T>; q2: CommandQueueBase); extensionmethod := q1 := q2*q1;

{$endregion CQ operator's}

{$region WaitMarker operator's}

function operator+(m1, m2: WaitMarker); extensionmethod := CommandQueueBase(m1) + m2;
function operator*(m1, m2: WaitMarker); extensionmethod := CommandQueueBase(m1) * m2;

{$endregion WaitMarker operator's}

{$endregion Simple}

{$region [Any]} type
  
  {$region Invokers}
  
  QueueArrayInvokerData<T> = record
    public all_qrs_const := true;
    public next_l: CLTaskLocalData;
    public qrs: array of QueueRes<T>;
    
    public constructor(c: integer) := qrs := new QueueRes<T>[c];
    public constructor := raise new OpenCLABCInternalException;
    
  end;
  IQueueArrayInvoker = interface
    
    function InvokeToNil<T>(qs: array of CommandQueue<T>; g: CLTaskGlobalData; l: CLTaskLocalData): CLTaskLocalData;
    function InvokeToAny<T>(qs: array of CommandQueue<T>; g: CLTaskGlobalData; l: CLTaskLocalData): QueueArrayInvokerData<T>;
    
  end;
  
  QueueArraySyncInvoker = record(IQueueArrayInvoker)
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function InvokeToNil<T>(qs: array of CommandQueue<T>; g: CLTaskGlobalData; l: CLTaskLocalData): CLTaskLocalData;
    begin
      for var i := 0 to qs.Length-1 do
        l := qs[i].InvokeToNil(g, l).base;
      Result := l;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function InvokeToAny<T>(qs: array of CommandQueue<T>; g: CLTaskGlobalData; l: CLTaskLocalData): QueueArrayInvokerData<T>;
    begin
      Result := new QueueArrayInvokerData<T>(qs.Length);
      
      for var i := 0 to qs.Length-1 do
      begin
        var qr := qs[i].InvokeToAny(g, l);
        if not qr.IsConst then
          Result.all_qrs_const := false;
        l := qr.TakeBaseOut;
        Result.qrs[i] := qr;
      end;
      
      Result.next_l := l;
    end;
    
  end;
  QueueArrayAsyncInvoker = record(IQueueArrayInvoker)
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function InvokeToNil<T>(qs: array of CommandQueue<T>; g: CLTaskGlobalData; l: CLTaskLocalData): CLTaskLocalData;
    begin
      var evs := new EventList[qs.Length];
      
      g.ParallelInvoke(l, qs.Length, invoker->
        for var i := 0 to qs.Length-1 do
          evs[i] := invoker.InvokeBranch(qs[i].InvokeToNil).AttachInvokeActions(invoker.g)
      );
      
      Result := new CLTaskLocalData(EventList.Combine(evs));
    end;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function MakeInvokeBody<T>(qs: array of CommandQueue<T>; qrs: array of QueueRes<T>): CLTaskBranchInvoker->() := invoker->
    for var i := 0 to qs.Length-1 do qrs[i] := invoker.InvokeBranch(qs[i].InvokeToAny);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function InvokeToAny<T>(qs: array of CommandQueue<T>; g: CLTaskGlobalData; l: CLTaskLocalData): QueueArrayInvokerData<T>;
    begin
      Result := new QueueArrayInvokerData<T>(qs.Length);
      
      g.ParallelInvoke(l, qs.Length, MakeInvokeBody(qs,Result.qrs));
      
      for var i := 0 to qs.Length-1 do
        if not Result.qrs[i].IsConst then
          Result.all_qrs_const := false;
      
      var evs := new EventList[qs.Length];
      for var i := 0 to qs.Length-1 do
        evs[i] := Result.qrs[i].AttachInvokeActions(g);
      Result.next_l := new CLTaskLocalData(EventList.Combine(evs));
    end;
    
  end;
  
  {$endregion Invokers}
  
  {$region Work}
  
  IQueueArrayWork<TInp,TRes, TDelegate> = interface
  where TDelegate: ISimpleDelegateContainer;
    
    function Invoke(d: TDelegate; insta_call_g: CLTaskGlobalData; err_handler: ErrHandler{$ifdef DEBUG}; err_test_reason: string{$endif}; inp: array of TInp; c: CLContext): TRes;
    
  end;
  
  QueueArrayWorkConvert<TInp,TRes, TFunc> = record(IQueueArrayWork<TInp,TRes, TFunc>)
  where TFunc: ISimpleFuncContainer<array of TInp,TRes>;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke(f: TFunc; insta_call_g: CLTaskGlobalData; err_handler: ErrHandler{$ifdef DEBUG}; err_test_reason: string{$endif}; inp: array of TInp; c: CLContext) :=
      f.Invoke(insta_call_g, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, inp, c);
    
  end;
  
  QueueArrayWorkUse<T, TProc> = record(IQueueArrayWork<T,array of T, TProc>)
  where TProc: ISimpleProcContainer<array of T>;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke(p: TProc; insta_call_g: CLTaskGlobalData; err_handler: ErrHandler{$ifdef DEBUG}; err_test_reason: string{$endif}; inp: array of T; c: CLContext): array of T; 
    begin
      p.Invoke(insta_call_g, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, inp, c);
      Result := inp;
    end;
    
  end;
  
  {$endregion Work}
  
  {$region Common}
  
  CommandQueueArrayWithWork<TInp,TRes, TInv,TDelegate> = abstract class(CommandQueue<TRes>)
  where TInv: IQueueArrayInvoker, constructor;
  where TDelegate: ISimpleDelegateContainer;
    protected qs: array of CommandQueue<TInp>;
    protected d: TDelegate;
    protected can_pre_call: boolean;
    
    public constructor(qs: array of CommandQueue<TInp>; d: TDelegate; can_pre_call: boolean);
    begin
      self.qs := qs;
      self.d := d;
      self.can_pre_call := can_pre_call;
      if can_pre_call and qs.All(q->q.const_res_dep<>nil) then
      begin
        self.expected_const_res := d.PreInvoke&<array of TInp, TRes>(
          qs.ConvertAll(q->q.expected_const_res)
        );
        
        var c := qs.Sum(q->q.const_res_dep.Length);
        {$ifdef DEBUG}
        if c=0 then raise new OpenCLABCInternalException($'0dep version is CQ/HPQ/HFQ');
        {$endif DEBUG}
        
        self.const_res_dep := new CommandQueueBase[c];
        for var i := qs.Length-1 downto 0 do
        begin
          var dep := qs[i].const_res_dep;
          c -= dep.Length;
          dep.CopyTo(self.const_res_dep, c);
        end;
        
      end;
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_mu: HashSet<IMultiusableCommandQueue>); override :=
    foreach var q in qs do q.InitBeforeInvoke(g, inited_mu);
    
    protected function TrySkipInvoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; qr_factory: IQueueResFactory<TRes,TR>; var res: TR): boolean; where TR: IQueueRes;
    begin
      Result := qr_factory.TrySkipInvoke(
        g, l,
        self,(g,l)->new QueueResNil(TInv.Create.InvokeToNil(self.qs, g,l)),
        res
      );
    end;
    
    protected static function GetAllResDirect(qrs: array of QueueRes<TInp>): array of TInp;
    begin
      Result := new TInp[qrs.Length];
      for var i := 0 to Result.Length-1 do
        Result[i] := qrs[i].GetResDirect;
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      foreach var q in qs do
        q.ToString(sb, tabs, index, delayed);
      
      sb.Append(#9, tabs);
      d.ToStringB(sb);
      sb += #10;
      
    end;
    
  end;
  
  {$endregion Common}
  
  {$region Quick}
  
  CommandQueueQuickArray<TInp,TRes, TInv, TDelegate, TWork> = sealed class(CommandQueueArrayWithWork<TInp,TRes, TInv,TDelegate>)
  where TInv: IQueueArrayInvoker, constructor;
  where TDelegate: ISimpleDelegateContainer;
  where TWork: IQueueArrayWork<TInp,TRes, TDelegate>, constructor;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; qr_factory: IQueueResFactory<TRes,TR>): TR; where TR: IQueueRes;
    begin
      if TrySkipInvoke(g,l, qr_factory, Result) then exit;
      var inv_data := TInv.Create.InvokeToAny(self.qs, g, l);
      l := inv_data.next_l;
      
      var should_make_const := if can_pre_call then
        inv_data.all_qrs_const else
        l.ShouldInstaCallAction;
      
      var qrs := inv_data.qrs;
      var err_handler := g.curr_err_handler.Extract({$ifdef DEBUG}false{$endif});
      
      {$ifdef DEBUG}
      var err_test_reason := $'[{self.GetHashCode}]:{TypeName(self)}.d.Invoke';
      err_handler.AddMaybeError(err_test_reason);
      {$endif DEBUG}
      
      if should_make_const then
        Result := qr_factory.MakeConst(l, TWork.Create.Invoke(d,
          g, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, GetAllResDirect(qrs), g.c
        )) else
        Result := qr_factory.MakeDelayed(l, qr->c->qr.SetRes(TWork.Create.Invoke(d,
          nil, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, GetAllResDirect(qrs), c
        )));
      
    end;
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil;       override := Invoke(g, l, qr_nil_factory);
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes   <TRes>; override := Invoke(g, l, qr_val_factory);
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<TRes>; override := Invoke(g, l, qr_ptr_factory);
    
  end;
  
  CommandQueueConvertQuickArray<TInp,TRes, TInv, TFunc> = CommandQueueQuickArray<TInp,TRes,    TInv, TFunc, QueueArrayWorkConvert<TInp,TRes, TFunc>>;
  CommandQueueUseQuickArray    <T,         TInv, TProc> = CommandQueueQuickArray<T,array of T, TInv, TProc, QueueArrayWorkUse    <T,         TProc>>;
  
  {$endregion Quick}
  
  {$region Threaded}
  
  //TODO #2657
  QueueResArr<T> = array of QueueRes<T>;
  
  CommandQueueThreadedArray<TInp,TRes, TInv, TDelegate, TWork> = sealed class(CommandQueueArrayWithWork<TInp,TRes, TInv,TDelegate>)
  where TInv: IQueueArrayInvoker, constructor;
  where TDelegate: ISimpleDelegateContainer;
  where TWork: IQueueArrayWork<TInp,TRes, TDelegate>, constructor;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function MakeNilBody    (acts: QueueResComplDelegateData; qrs: array of QueueRes<TInp>; err_handler: ErrHandler; c: CLContext; own_qr: QueueResNil{$ifdef DEBUG}; err_test_reason: string{$endif}): Action;
    begin
      Result := ()->
      begin
        acts.Invoke(c);
        TWork.Create.Invoke(d, nil, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, GetAllResDirect(qrs), c)
      end;
    end;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function MakeResBody<TR>(acts: QueueResComplDelegateData; qrs: array of QueueRes<TInp>; err_handler: ErrHandler; c: CLContext; own_qr: TR{$ifdef DEBUG}; err_test_reason: string{$endif}): Action; where TR: QueueRes<TRes>;
    begin
      Result := ()->
      begin
        acts.Invoke(c);
        own_qr.SetRes(
          TWork.Create.Invoke(d, nil, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, GetAllResDirect(qrs), c)
        );
      end;
    end;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; qr_factory: IQueueResFactory<TRes,TR>;
      make_body: (QueueResComplDelegateData, QueueResArr<TInp>,ErrHandler,CLContext,TR{$ifdef DEBUG},string{$endif})->Action
    ): TR; where TR: IQueueRes;
    begin
      if TrySkipInvoke(g,l, qr_factory, Result) then exit;
      var inv_data := TInv.Create.InvokeToAny(self.qs, g, l);
      l := inv_data.next_l;
      
      var qrs := inv_data.qrs;
      var err_handler := g.curr_err_handler.Extract({$ifdef DEBUG}false{$endif});
      
      {$ifdef DEBUG}
      var err_test_reason := $'[{self.GetHashCode}]:{TypeName(self)}.d.Invoke';
      err_handler.AddMaybeError(err_test_reason);
      {$endif DEBUG}
      
      if can_pre_call and inv_data.all_qrs_const then
        Result := qr_factory.MakeConst(l, TWork.Create.Invoke(d,
          g, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, GetAllResDirect(qrs), g.c)
        ) else
      begin
        var prev_ev := l.prev_ev;
        var acts := l.prev_delegate;
        Result := qr_factory.MakeDelayed(qr->new CLTaskLocalData(UserEvent.StartWorkThread(
          prev_ev, make_body(acts, qrs, err_handler, g.c, qr{$ifdef DEBUG}, err_test_reason{$endif}), g
          {$ifdef EventDebug}, $'body of {TypeName(self)}'{$endif}
        )));
      end;
      
    end;
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil;       override := Invoke(g, l, qr_nil_factory, MakeNilBody);
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes   <TRes>; override := Invoke(g, l, qr_val_factory, MakeResBody&<QueueResVal<TRes>>);
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<TRes>; override := Invoke(g, l, qr_ptr_factory, MakeResBody&<QueueResPtr<TRes>>);
    
  end;
  
  CommandQueueConvertThreadedArray<TInp,TRes, TInv, TFunc> = CommandQueueThreadedArray<TInp,TRes,    TInv, TFunc, QueueArrayWorkConvert<TInp,TRes, TFunc>>;
  CommandQueueUseThreadedArray    <T,         TInv, TProc> = CommandQueueThreadedArray<T,array of T, TInv, TProc, QueueArrayWorkUse    <T,         TProc>>;
  
  {$endregion Threaded}
  
{$endregion [Any]}

{$region [2]} type
  
  {$region Invokers}
  
  QueueArray2InvokerData<TInp1,TInp2> = record
    public all_qrs_const := true;
    public next_l: CLTaskLocalData;
    public qr1: QueueRes<TInp1>;
    public qr2: QueueRes<TInp2>;
  end;
  
  IQueueArray2Invoker = interface
    
    function InvokeToNil<TInp1,TInp2>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; g: CLTaskGlobalData; l: CLTaskLocalData): CLTaskLocalData;
    function InvokeToAny<TInp1,TInp2>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; g: CLTaskGlobalData; l: CLTaskLocalData): QueueArray2InvokerData<TInp1,TInp2>;
    
  end;
  
  QueueArray2SyncInvoker = record(IQueueArray2Invoker)
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function InvokeToNil<TInp1,TInp2>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; g: CLTaskGlobalData; l: CLTaskLocalData): CLTaskLocalData;
    begin
      l := q1.InvokeToNil(g, l).base;
      l := q2.InvokeToNil(g, l).base;
      Result := l;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function InvokeToAny<TInp1,TInp2>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; g: CLTaskGlobalData; l: CLTaskLocalData): QueueArray2InvokerData<TInp1,TInp2>;
    begin
      
      Result.qr1 := q1.InvokeToAny(g, l);
      if not Result.qr1.IsConst then Result.all_qrs_const := false;
      l := Result.qr1.TakeBaseOut;
      
      Result.qr2 := q2.InvokeToAny(g, l);
      if not Result.qr2.IsConst then Result.all_qrs_const := false;
      l := Result.qr2.TakeBaseOut;
      
      Result.next_l := l;
    end;
    
  end;
  
  QueueArray2AsyncInvoker = record(IQueueArray2Invoker)
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function InvokeToNil<TInp1,TInp2>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; g: CLTaskGlobalData; l: CLTaskLocalData): CLTaskLocalData;
    begin
      var res_ev: EventList;
      g.ParallelInvoke(l, 2, invoker->(res_ev := EventList.Combine(|
        invoker.InvokeBranch(q1.InvokeToNil).AttachInvokeActions(invoker.g),
        invoker.InvokeBranch(q2.InvokeToNil).AttachInvokeActions(invoker.g)
      |)));
      Result := new CLTaskLocalData(res_ev);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function InvokeToAny<TInp1,TInp2>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; g: CLTaskGlobalData; l: CLTaskLocalData): QueueArray2InvokerData<TInp1,TInp2>;
    begin
      
      var res: QueueArray2InvokerData<TInp1,TInp2>;
      g.ParallelInvoke(l, 2, invoker->
      begin
        res.qr1 := invoker.InvokeBranch(q1.InvokeToAny);
        res.qr2 := invoker.InvokeBranch(q2.InvokeToAny);
      end);
      Result := res;
      
      Result.all_qrs_const := Result.qr1.IsConst and Result.qr2.IsConst;
      Result.next_l := new CLTaskLocalData(EventList.Combine(|
        Result.qr1.AttachInvokeActions(g),
        Result.qr2.AttachInvokeActions(g)
      |));
    end;
    
  end;
  
  {$endregion Invokers}
  
  {$region Work}
  
  IQueueArray2Work<TInp1,TInp2,TRes, TDelegate> = interface
  where TDelegate: ISimpleDelegateContainer;
    
    function PreInvoke(d: TDelegate; inp1: TInp1; inp2: TInp2): TRes;
    
    function Invoke(d: TDelegate; err_handler: ErrHandler{$ifdef DEBUG}; err_test_reason: string{$endif}; inp1: TInp1; inp2: TInp2; c: CLContext): TRes;
    
  end;
  
  {$region Func}
  
  ISimpleFunc2Container<TInp1,TInp2,TRes> = interface(ISimpleDelegateContainer)
    
    function Invoke(inp1: TInp1; inp2: TInp2; c: CLContext): TRes;
    
  end;
  
  SimpleFunc2Container<TInp1,TInp2,TRes> = record(ISimpleFunc2Container<TInp1,TInp2,TRes>)
    private d: (TInp1,TInp2)->TRes;
    
    public static function operator implicit(d: (TInp1,TInp2)->TRes): SimpleFunc2Container<TInp1,TInp2,TRes>;
    begin
      Result.d := d;
    end;
    
    public function Invoke(inp1: TInp1; inp2: TInp2; c: CLContext) := d(inp1,inp2);
    
    public procedure ToStringB(sb: StringBuilder) :=
    CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  SimpleFunc2ContainerC<TInp1,TInp2,TRes> = record(ISimpleFunc2Container<TInp1,TInp2,TRes>)
    private d: (TInp1,TInp2, CLContext)->TRes;
    
    public static function operator implicit(d: (TInp1,TInp2, CLContext)->TRes): SimpleFunc2ContainerC<TInp1,TInp2,TRes>;
    begin
      Result.d := d;
    end;
    
    public function Invoke(inp1: TInp1; inp2: TInp2; c: CLContext) := d(inp1,inp2,c);
    
    public procedure ToStringB(sb: StringBuilder) :=
    CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  
  QueueArray2WorkConvert<TInp1,TInp2,TRes, TFunc> = record(IQueueArray2Work<TInp1,TInp2,TRes, TFunc>)
  where TFunc: ISimpleFunc2Container<TInp1,TInp2,TRes>;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function PreInvoke(f: TFunc; inp1: TInp1; inp2: TInp2) :=
    f.Invoke(inp1,inp2, nil);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke(f: TFunc; err_handler: ErrHandler{$ifdef DEBUG}; err_test_reason: string{$endif}; inp1: TInp1; inp2: TInp2; c: CLContext): TRes;
    begin
      if not err_handler.HadError then
      try
        Result := f.Invoke(inp1,inp2, c);
      except
        on e: Exception do err_handler.AddErr(e{$ifdef DEBUG}, err_test_reason{$endif})
      end;
      {$ifdef DEBUG}
      err_handler.EndMaybeError(err_test_reason);
      {$endif DEBUG}
    end;
    
  end;
  
  {$endregion Func}
  
  {$region Proc}
  
  ISimpleProc2Container<TInp1,TInp2> = interface(ISimpleDelegateContainer)
    
    procedure Invoke(inp1: TInp1; inp2: TInp2; c: CLContext);
    
  end;
  
  SimpleProc2Container<TInp1,TInp2> = record(ISimpleProc2Container<TInp1,TInp2>)
    private d: (TInp1,TInp2)->();
    
    public static function operator implicit(d: (TInp1,TInp2)->()): SimpleProc2Container<TInp1,TInp2>;
    begin
      Result.d := d;
    end;
    
    public procedure Invoke(inp1: TInp1; inp2: TInp2; c: CLContext) := d(inp1,inp2);
    
    public procedure ToStringB(sb: StringBuilder) :=
    CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  SimpleProc2ContainerC<TInp1,TInp2> = record(ISimpleProc2Container<TInp1,TInp2>)
    private d: (TInp1,TInp2, CLContext)->();
    
    public static function operator implicit(d: (TInp1,TInp2, CLContext)->()): SimpleProc2ContainerC<TInp1,TInp2>;
    begin
      Result.d := d;
    end;
    
    public procedure Invoke(inp1: TInp1; inp2: TInp2; c: CLContext) := d(inp1,inp2,c);
    
    public procedure ToStringB(sb: StringBuilder) :=
    CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  
  QueueArray2WorkUse<TInp1,TInp2, TProc> = record(IQueueArray2Work<TInp1,TInp2,ValueTuple<TInp1,TInp2>, TProc>)
  where TProc: ISimpleProc2Container<TInp1,TInp2>;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function PreInvoke(p: TProc; inp1: TInp1; inp2: TInp2): ValueTuple<TInp1,TInp2>;
    begin
      p.Invoke(inp1,inp2, nil);
      Result := ValueTuple.Create(inp1,inp2);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke(p: TProc; err_handler: ErrHandler{$ifdef DEBUG}; err_test_reason: string{$endif}; inp1: TInp1; inp2: TInp2; c: CLContext): ValueTuple<TInp1,TInp2>;
    begin
      if not err_handler.HadError then
      try
        p.Invoke(inp1,inp2, c);
        Result := ValueTuple.Create(inp1,inp2);
      except
        on e: Exception do err_handler.AddErr(e{$ifdef DEBUG}, err_test_reason{$endif})
      end;
      {$ifdef DEBUG}
      err_handler.EndMaybeError(err_test_reason);
      {$endif DEBUG}
    end;
    
  end;
  
  {$endregion Proc}
  
  {$endregion Work}
  
  {$region Common}
  
  CommandQueueArray2WithWork<TInp1,TInp2,TRes, TInv,TDelegate,TWork> = abstract class(CommandQueue<TRes>)
  where TInv: IQueueArray2Invoker, constructor;
  where TDelegate: ISimpleDelegateContainer;
  where TWork: IQueueArray2Work<TInp1,TInp2,TRes, TDelegate>, constructor;
    protected q1: CommandQueue<TInp1>;
    protected q2: CommandQueue<TInp2>;
    protected d: TDelegate;
    protected can_pre_call: boolean;
    
    public constructor(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; d: TDelegate; can_pre_call: boolean);
    begin
      self.q1 := q1;
      self.q2 := q2;
      self.d := d;
      self.can_pre_call := can_pre_call;
      if can_pre_call and (q1.const_res_dep<>nil) and (q2.const_res_dep<>nil) then
      begin
        self.expected_const_res := TWork.Create.PreInvoke(d,
          q1.expected_const_res,
          q2.expected_const_res
        );
        
        var c := q1.const_res_dep.Length + q2.const_res_dep.Length;
        {$ifdef DEBUG}
        if c=0 then raise new OpenCLABCInternalException($'0dep version is CQ/HFQ/HPQ');
        {$endif DEBUG}
        
        self.const_res_dep := new CommandQueueBase[c];
        var dep: array of CommandQueueBase;
        dep := q2.const_res_dep; c -= dep.Length; dep.CopyTo(self.const_res_dep, c);
        dep := q1.const_res_dep; c -= dep.Length; dep.CopyTo(self.const_res_dep, c);
      end;
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueue>); override :=
    begin
      q1.InitBeforeInvoke(g, inited_hubs);
      q2.InitBeforeInvoke(g, inited_hubs);
    end;
    
    protected function TrySkipInvoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; qr_factory: IQueueResFactory<TRes,TR>; var res: TR): boolean; where TR: IQueueRes;
    begin
      Result := qr_factory.TrySkipInvoke(
        g, l,
        self,(g,l)->new QueueResNil(TInv.Create.InvokeToNil(q1,q2, g,l)),
        res
      );
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      q1.ToString(sb, tabs, index, delayed);
      q2.ToString(sb, tabs, index, delayed);
      sb.Append(#9, tabs);
      d.ToStringB(sb);
      sb += #10;
    end;
    
  end;
  
  {$endregion Common}
  
  {$region Quick}
  
  CommandQueueQuickArray2<TInp1,TInp2,TRes, TInv, TDelegate, TWork> = sealed class(CommandQueueArray2WithWork<TInp1,TInp2,TRes, TInv, TDelegate, TWork>)
  where TInv: IQueueArray2Invoker, constructor;
  where TDelegate: ISimpleDelegateContainer;
  where TWork: IQueueArray2Work<TInp1,TInp2,TRes, TDelegate>, constructor;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; qr_factory: IQueueResFactory<TRes,TR>): TR; where TR: IQueueRes;
    begin
      if TrySkipInvoke(g,l, qr_factory, Result) then exit;
      var inv_data := TInv.Create.InvokeToAny(q1,q2, g, l);
      l := inv_data.next_l;
      
      var qr1 := inv_data.qr1;
      var qr2 := inv_data.qr2;
      var err_handler := g.curr_err_handler.Extract({$ifdef DEBUG}false{$endif});
      
      {$ifdef DEBUG}
      var err_test_reason := $'[{self.GetHashCode}]:{TypeName(self)}.d.Invoke';
      err_handler.AddMaybeError(err_test_reason);
      {$endif DEBUG}
      
      var should_make_const := if can_pre_call then
        inv_data.all_qrs_const else
        l.ShouldInstaCallAction;
      
      if should_make_const then
        Result := qr_factory.MakeConst(l, TWork.Create.Invoke(d,
          err_handler{$ifdef DEBUG}, err_test_reason{$endif},
          qr1.GetResDirect, qr2.GetResDirect, g.c
        )) else
        Result := qr_factory.MakeDelayed(l, qr->c->qr.SetRes(TWork.Create.Invoke(d,
          err_handler{$ifdef DEBUG}, err_test_reason{$endif},
          qr1.GetResDirect, qr2.GetResDirect, c
        )));
      
    end;
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil;       override := Invoke(g, l, qr_nil_factory);
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes   <TRes>; override := Invoke(g, l, qr_val_factory);
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<TRes>; override := Invoke(g, l, qr_ptr_factory);
    
  end;
  
  CommandQueueConvertQuickArray2<TInp1,TInp2,TRes, TInv, TFunc> = CommandQueueQuickArray2<TInp1,TInp2,TRes, TInv, TFunc, QueueArray2WorkConvert<TInp1,TInp2,TRes, TFunc>>;
  CommandQueueUseQuickArray2    <TInp1,TInp2,      TInv, TProc> = CommandQueueQuickArray2<TInp1,TInp2,ValueTuple<TInp1,TInp2>, TInv, TProc, QueueArray2WorkUse<TInp1,TInp2, TProc>>;
  
  {$endregion Quick}
  
  {$region Threaded}
  
  DCommandQueueThreadedArray2MakeBody<TInp1,TInp2, TR> = function(acts: QueueResComplDelegateData; qr1: QueueRes<TInp1>; qr2: QueueRes<TInp2>; err_handler: ErrHandler; c: CLContext; own_qr: TR{$ifdef DEBUG}; err_test_reason: string{$endif}): Action;
  CommandQueueThreadedArray2<TInp1,TInp2,TRes, TInv, TDelegate, TWork> = sealed class(CommandQueueArray2WithWork<TInp1,TInp2,TRes, TInv, TDelegate, TWork>)
  where TInv: IQueueArray2Invoker, constructor;
  where TDelegate: ISimpleDelegateContainer;
  where TWork: IQueueArray2Work<TInp1,TInp2,TRes, TDelegate>, constructor;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function MakeNilBody    (acts: QueueResComplDelegateData; qr1: QueueRes<TInp1>; qr2: QueueRes<TInp2>; err_handler: ErrHandler; c: CLContext; own_qr: QueueResNil{$ifdef DEBUG}; err_test_reason: string{$endif}): Action;
    begin
      Result := ()->
      begin
        acts.Invoke(c);
        TWork.Create.Invoke(d, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, qr1.GetResDirect, qr2.GetResDirect, c);
      end;
    end;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function MakeResBody<TR>(acts: QueueResComplDelegateData; qr1: QueueRes<TInp1>; qr2: QueueRes<TInp2>; err_handler: ErrHandler; c: CLContext; own_qr: TR{$ifdef DEBUG}; err_test_reason: string{$endif}): Action; where TR: QueueRes<TRes>;
    begin
      Result := ()->
      begin
        acts.Invoke(c);
        own_qr.SetRes(TWork.Create.Invoke(d, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, qr1.GetResDirect, qr2.GetResDirect, c));
      end;
    end;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; qr_factory: IQueueResFactory<TRes,TR>; make_body: DCommandQueueThreadedArray2MakeBody<TInp1,TInp2, TR>): TR; where TR: IQueueRes;
    begin
      if TrySkipInvoke(g,l, qr_factory, Result) then exit;
      var inv_data := TInv.Create.InvokeToAny(q1,q2, g, l);
      l := inv_data.next_l;
      
      var qr1 := inv_data.qr1;
      var qr2 := inv_data.qr2;
      var err_handler := g.curr_err_handler.Extract({$ifdef DEBUG}false{$endif});
      
      {$ifdef DEBUG}
      var err_test_reason := $'[{self.GetHashCode}]:{TypeName(self)}.d.Invoke';
      err_handler.AddMaybeError(err_test_reason);
      {$endif DEBUG}
      
      var should_make_const := if can_pre_call then
        inv_data.all_qrs_const else
        false;
      
      if should_make_const then
        Result := qr_factory.MakeConst(l, TWork.Create.Invoke(d,
          err_handler{$ifdef DEBUG}, err_test_reason{$endif},
          qr1.GetResDirect, qr2.GetResDirect, g.c
        )) else
      begin
        var prev_ev := l.prev_ev;
        var acts := l.prev_delegate;
        Result := qr_factory.MakeDelayed(qr->new CLTaskLocalData(UserEvent.StartWorkThread(
          prev_ev, make_body(acts, qr1,qr2, err_handler, g.c, qr{$ifdef DEBUG}, err_test_reason{$endif}), g
          {$ifdef EventDebug}, $'body of {TypeName(self)}'{$endif}
        )));
      end;
      
    end;
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil;       override := Invoke(g, l, qr_nil_factory, MakeNilBody);
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes   <TRes>; override := Invoke(g, l, qr_val_factory, MakeResBody&<QueueResVal<TRes>>);
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<TRes>; override := Invoke(g, l, qr_ptr_factory, MakeResBody&<QueueResPtr<TRes>>);
    
  end;
  
  CommandQueueConvertThreadedArray2<TInp1,TInp2,TRes, TInv, TFunc> = CommandQueueThreadedArray2<TInp1,TInp2,TRes, TInv, TFunc, QueueArray2WorkConvert<TInp1,TInp2,TRes, TFunc>>;
  CommandQueueUseThreadedArray2    <TInp1,TInp2,      TInv, TProc> = CommandQueueThreadedArray2<TInp1,TInp2,ValueTuple<TInp1,TInp2>, TInv, TProc, QueueArray2WorkUse<TInp1,TInp2, TProc>>;
  
  {$endregion Threaded}
  
{$endregion [2]}

{$region [3]} type
  
  {$region Invokers}
  
  QueueArray3InvokerData<TInp1,TInp2,TInp3> = record
    public all_qrs_const := true;
    public next_l: CLTaskLocalData;
    public qr1: QueueRes<TInp1>;
    public qr2: QueueRes<TInp2>;
    public qr3: QueueRes<TInp3>;
  end;
  
  IQueueArray3Invoker = interface
    
    function InvokeToNil<TInp1,TInp2,TInp3>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; g: CLTaskGlobalData; l: CLTaskLocalData): CLTaskLocalData;
    function InvokeToAny<TInp1,TInp2,TInp3>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; g: CLTaskGlobalData; l: CLTaskLocalData): QueueArray3InvokerData<TInp1,TInp2,TInp3>;
    
  end;
  
  QueueArray3SyncInvoker = record(IQueueArray3Invoker)
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function InvokeToNil<TInp1,TInp2,TInp3>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; g: CLTaskGlobalData; l: CLTaskLocalData): CLTaskLocalData;
    begin
      l := q1.InvokeToNil(g, l).base;
      l := q2.InvokeToNil(g, l).base;
      l := q3.InvokeToNil(g, l).base;
      Result := l;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function InvokeToAny<TInp1,TInp2,TInp3>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; g: CLTaskGlobalData; l: CLTaskLocalData): QueueArray3InvokerData<TInp1,TInp2,TInp3>;
    begin
      
      Result.qr1 := q1.InvokeToAny(g, l);
      if not Result.qr1.IsConst then Result.all_qrs_const := false;
      l := Result.qr1.TakeBaseOut;
      
      Result.qr2 := q2.InvokeToAny(g, l);
      if not Result.qr2.IsConst then Result.all_qrs_const := false;
      l := Result.qr2.TakeBaseOut;
      
      Result.qr3 := q3.InvokeToAny(g, l);
      if not Result.qr3.IsConst then Result.all_qrs_const := false;
      l := Result.qr3.TakeBaseOut;
      
      Result.next_l := l;
    end;
    
  end;
  
  QueueArray3AsyncInvoker = record(IQueueArray3Invoker)
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function InvokeToNil<TInp1,TInp2,TInp3>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; g: CLTaskGlobalData; l: CLTaskLocalData): CLTaskLocalData;
    begin
      var res_ev: EventList;
      g.ParallelInvoke(l, 3, invoker->(res_ev := EventList.Combine(|
        invoker.InvokeBranch(q1.InvokeToNil).AttachInvokeActions(invoker.g),
        invoker.InvokeBranch(q2.InvokeToNil).AttachInvokeActions(invoker.g),
        invoker.InvokeBranch(q3.InvokeToNil).AttachInvokeActions(invoker.g)
      |)));
      Result := new CLTaskLocalData(res_ev);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function InvokeToAny<TInp1,TInp2,TInp3>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; g: CLTaskGlobalData; l: CLTaskLocalData): QueueArray3InvokerData<TInp1,TInp2,TInp3>;
    begin
      
      var res: QueueArray3InvokerData<TInp1,TInp2,TInp3>;
      g.ParallelInvoke(l, 3, invoker->
      begin
        res.qr1 := invoker.InvokeBranch(q1.InvokeToAny);
        res.qr2 := invoker.InvokeBranch(q2.InvokeToAny);
        res.qr3 := invoker.InvokeBranch(q3.InvokeToAny);
      end);
      Result := res;
      
      Result.all_qrs_const := Result.qr1.IsConst and Result.qr2.IsConst and Result.qr3.IsConst;
      Result.next_l := new CLTaskLocalData(EventList.Combine(|
        Result.qr1.AttachInvokeActions(g),
        Result.qr2.AttachInvokeActions(g),
        Result.qr3.AttachInvokeActions(g)
      |));
    end;
    
  end;
  
  {$endregion Invokers}
  
  {$region Work}
  
  IQueueArray3Work<TInp1,TInp2,TInp3,TRes, TDelegate> = interface
  where TDelegate: ISimpleDelegateContainer;
    
    function PreInvoke(d: TDelegate; inp1: TInp1; inp2: TInp2; inp3: TInp3): TRes;
    
    function Invoke(d: TDelegate; err_handler: ErrHandler{$ifdef DEBUG}; err_test_reason: string{$endif}; inp1: TInp1; inp2: TInp2; inp3: TInp3; c: CLContext): TRes;
    
  end;
  
  {$region Func}
  
  ISimpleFunc3Container<TInp1,TInp2,TInp3,TRes> = interface(ISimpleDelegateContainer)
    
    function Invoke(inp1: TInp1; inp2: TInp2; inp3: TInp3; c: CLContext): TRes;
    
  end;
  
  SimpleFunc3Container<TInp1,TInp2,TInp3,TRes> = record(ISimpleFunc3Container<TInp1,TInp2,TInp3,TRes>)
    private d: (TInp1,TInp2,TInp3)->TRes;
    
    public static function operator implicit(d: (TInp1,TInp2,TInp3)->TRes): SimpleFunc3Container<TInp1,TInp2,TInp3,TRes>;
    begin
      Result.d := d;
    end;
    
    public function Invoke(inp1: TInp1; inp2: TInp2; inp3: TInp3; c: CLContext) := d(inp1,inp2,inp3);
    
    public procedure ToStringB(sb: StringBuilder) :=
    CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  SimpleFunc3ContainerC<TInp1,TInp2,TInp3,TRes> = record(ISimpleFunc3Container<TInp1,TInp2,TInp3,TRes>)
    private d: (TInp1,TInp2,TInp3, CLContext)->TRes;
    
    public static function operator implicit(d: (TInp1,TInp2,TInp3, CLContext)->TRes): SimpleFunc3ContainerC<TInp1,TInp2,TInp3,TRes>;
    begin
      Result.d := d;
    end;
    
    public function Invoke(inp1: TInp1; inp2: TInp2; inp3: TInp3; c: CLContext) := d(inp1,inp2,inp3,c);
    
    public procedure ToStringB(sb: StringBuilder) :=
    CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  
  QueueArray3WorkConvert<TInp1,TInp2,TInp3,TRes, TFunc> = record(IQueueArray3Work<TInp1,TInp2,TInp3,TRes, TFunc>)
  where TFunc: ISimpleFunc3Container<TInp1,TInp2,TInp3,TRes>;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function PreInvoke(f: TFunc; inp1: TInp1; inp2: TInp2; inp3: TInp3) :=
    f.Invoke(inp1,inp2,inp3, nil);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke(f: TFunc; err_handler: ErrHandler{$ifdef DEBUG}; err_test_reason: string{$endif}; inp1: TInp1; inp2: TInp2; inp3: TInp3; c: CLContext): TRes;
    begin
      if not err_handler.HadError then
      try
        Result := f.Invoke(inp1,inp2,inp3, c);
      except
        on e: Exception do err_handler.AddErr(e{$ifdef DEBUG}, err_test_reason{$endif})
      end;
      {$ifdef DEBUG}
      err_handler.EndMaybeError(err_test_reason);
      {$endif DEBUG}
    end;
    
  end;
  
  {$endregion Func}
  
  {$region Proc}
  
  ISimpleProc3Container<TInp1,TInp2,TInp3> = interface(ISimpleDelegateContainer)
    
    procedure Invoke(inp1: TInp1; inp2: TInp2; inp3: TInp3; c: CLContext);
    
  end;
  
  SimpleProc3Container<TInp1,TInp2,TInp3> = record(ISimpleProc3Container<TInp1,TInp2,TInp3>)
    private d: (TInp1,TInp2,TInp3)->();
    
    public static function operator implicit(d: (TInp1,TInp2,TInp3)->()): SimpleProc3Container<TInp1,TInp2,TInp3>;
    begin
      Result.d := d;
    end;
    
    public procedure Invoke(inp1: TInp1; inp2: TInp2; inp3: TInp3; c: CLContext) := d(inp1,inp2,inp3);
    
    public procedure ToStringB(sb: StringBuilder) :=
    CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  SimpleProc3ContainerC<TInp1,TInp2,TInp3> = record(ISimpleProc3Container<TInp1,TInp2,TInp3>)
    private d: (TInp1,TInp2,TInp3, CLContext)->();
    
    public static function operator implicit(d: (TInp1,TInp2,TInp3, CLContext)->()): SimpleProc3ContainerC<TInp1,TInp2,TInp3>;
    begin
      Result.d := d;
    end;
    
    public procedure Invoke(inp1: TInp1; inp2: TInp2; inp3: TInp3; c: CLContext) := d(inp1,inp2,inp3,c);
    
    public procedure ToStringB(sb: StringBuilder) :=
    CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  
  QueueArray3WorkUse<TInp1,TInp2,TInp3, TProc> = record(IQueueArray3Work<TInp1,TInp2,TInp3,ValueTuple<TInp1,TInp2,TInp3>, TProc>)
  where TProc: ISimpleProc3Container<TInp1,TInp2,TInp3>;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function PreInvoke(p: TProc; inp1: TInp1; inp2: TInp2; inp3: TInp3): ValueTuple<TInp1,TInp2,TInp3>;
    begin
      p.Invoke(inp1,inp2,inp3, nil);
      Result := ValueTuple.Create(inp1,inp2,inp3);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke(p: TProc; err_handler: ErrHandler{$ifdef DEBUG}; err_test_reason: string{$endif}; inp1: TInp1; inp2: TInp2; inp3: TInp3; c: CLContext): ValueTuple<TInp1,TInp2,TInp3>;
    begin
      if not err_handler.HadError then
      try
        p.Invoke(inp1,inp2,inp3, c);
        Result := ValueTuple.Create(inp1,inp2,inp3);
      except
        on e: Exception do err_handler.AddErr(e{$ifdef DEBUG}, err_test_reason{$endif})
      end;
      {$ifdef DEBUG}
      err_handler.EndMaybeError(err_test_reason);
      {$endif DEBUG}
    end;
    
  end;
  
  {$endregion Proc}
  
  {$endregion Work}
  
  {$region Common}
  
  CommandQueueArray3WithWork<TInp1,TInp2,TInp3,TRes, TInv,TDelegate,TWork> = abstract class(CommandQueue<TRes>)
  where TInv: IQueueArray3Invoker, constructor;
  where TDelegate: ISimpleDelegateContainer;
  where TWork: IQueueArray3Work<TInp1,TInp2,TInp3,TRes, TDelegate>, constructor;
    protected q1: CommandQueue<TInp1>;
    protected q2: CommandQueue<TInp2>;
    protected q3: CommandQueue<TInp3>;
    protected d: TDelegate;
    protected can_pre_call: boolean;
    
    public constructor(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; d: TDelegate; can_pre_call: boolean);
    begin
      self.q1 := q1;
      self.q2 := q2;
      self.q3 := q3;
      self.d := d;
      self.can_pre_call := can_pre_call;
      if can_pre_call and (q1.const_res_dep<>nil) and (q2.const_res_dep<>nil) and (q3.const_res_dep<>nil) then
      begin
        self.expected_const_res := TWork.Create.PreInvoke(d,
          q1.expected_const_res,
          q2.expected_const_res,
          q3.expected_const_res
        );
        
        var c := q1.const_res_dep.Length + q2.const_res_dep.Length + q3.const_res_dep.Length;
        {$ifdef DEBUG}
        if c=0 then raise new OpenCLABCInternalException($'0dep version is CQ/HFQ/HPQ');
        {$endif DEBUG}
        
        self.const_res_dep := new CommandQueueBase[c];
        var dep: array of CommandQueueBase;
        dep := q3.const_res_dep; c -= dep.Length; dep.CopyTo(self.const_res_dep, c);
        dep := q2.const_res_dep; c -= dep.Length; dep.CopyTo(self.const_res_dep, c);
        dep := q1.const_res_dep; c -= dep.Length; dep.CopyTo(self.const_res_dep, c);
      end;
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueue>); override :=
    begin
      q1.InitBeforeInvoke(g, inited_hubs);
      q2.InitBeforeInvoke(g, inited_hubs);
      q3.InitBeforeInvoke(g, inited_hubs);
    end;
    
    protected function TrySkipInvoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; qr_factory: IQueueResFactory<TRes,TR>; var res: TR): boolean; where TR: IQueueRes;
    begin
      Result := qr_factory.TrySkipInvoke(
        g, l,
        self,(g,l)->new QueueResNil(TInv.Create.InvokeToNil(q1,q2,q3, g,l)),
        res
      );
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      q1.ToString(sb, tabs, index, delayed);
      q2.ToString(sb, tabs, index, delayed);
      q3.ToString(sb, tabs, index, delayed);
      sb.Append(#9, tabs);
      d.ToStringB(sb);
      sb += #10;
    end;
    
  end;
  
  {$endregion Common}
  
  {$region Quick}
  
  CommandQueueQuickArray3<TInp1,TInp2,TInp3,TRes, TInv, TDelegate, TWork> = sealed class(CommandQueueArray3WithWork<TInp1,TInp2,TInp3,TRes, TInv, TDelegate, TWork>)
  where TInv: IQueueArray3Invoker, constructor;
  where TDelegate: ISimpleDelegateContainer;
  where TWork: IQueueArray3Work<TInp1,TInp2,TInp3,TRes, TDelegate>, constructor;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; qr_factory: IQueueResFactory<TRes,TR>): TR; where TR: IQueueRes;
    begin
      if TrySkipInvoke(g,l, qr_factory, Result) then exit;
      var inv_data := TInv.Create.InvokeToAny(q1,q2,q3, g, l);
      l := inv_data.next_l;
      
      var qr1 := inv_data.qr1;
      var qr2 := inv_data.qr2;
      var qr3 := inv_data.qr3;
      var err_handler := g.curr_err_handler.Extract({$ifdef DEBUG}false{$endif});
      
      {$ifdef DEBUG}
      var err_test_reason := $'[{self.GetHashCode}]:{TypeName(self)}.d.Invoke';
      err_handler.AddMaybeError(err_test_reason);
      {$endif DEBUG}
      
      var should_make_const := if can_pre_call then
        inv_data.all_qrs_const else
        l.ShouldInstaCallAction;
      
      if should_make_const then
        Result := qr_factory.MakeConst(l, TWork.Create.Invoke(d,
          err_handler{$ifdef DEBUG}, err_test_reason{$endif},
          qr1.GetResDirect, qr2.GetResDirect, qr3.GetResDirect, g.c
        )) else
        Result := qr_factory.MakeDelayed(l, qr->c->qr.SetRes(TWork.Create.Invoke(d,
          err_handler{$ifdef DEBUG}, err_test_reason{$endif},
          qr1.GetResDirect, qr2.GetResDirect, qr3.GetResDirect, c
        )));
      
    end;
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil;       override := Invoke(g, l, qr_nil_factory);
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes   <TRes>; override := Invoke(g, l, qr_val_factory);
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<TRes>; override := Invoke(g, l, qr_ptr_factory);
    
  end;
  
  CommandQueueConvertQuickArray3<TInp1,TInp2,TInp3,TRes, TInv, TFunc> = CommandQueueQuickArray3<TInp1,TInp2,TInp3,TRes, TInv, TFunc, QueueArray3WorkConvert<TInp1,TInp2,TInp3,TRes, TFunc>>;
  CommandQueueUseQuickArray3    <TInp1,TInp2,TInp3,      TInv, TProc> = CommandQueueQuickArray3<TInp1,TInp2,TInp3,ValueTuple<TInp1,TInp2,TInp3>, TInv, TProc, QueueArray3WorkUse<TInp1,TInp2,TInp3, TProc>>;
  
  {$endregion Quick}
  
  {$region Threaded}
  
  DCommandQueueThreadedArray3MakeBody<TInp1,TInp2,TInp3, TR> = function(acts: QueueResComplDelegateData; qr1: QueueRes<TInp1>; qr2: QueueRes<TInp2>; qr3: QueueRes<TInp3>; err_handler: ErrHandler; c: CLContext; own_qr: TR{$ifdef DEBUG}; err_test_reason: string{$endif}): Action;
  CommandQueueThreadedArray3<TInp1,TInp2,TInp3,TRes, TInv, TDelegate, TWork> = sealed class(CommandQueueArray3WithWork<TInp1,TInp2,TInp3,TRes, TInv, TDelegate, TWork>)
  where TInv: IQueueArray3Invoker, constructor;
  where TDelegate: ISimpleDelegateContainer;
  where TWork: IQueueArray3Work<TInp1,TInp2,TInp3,TRes, TDelegate>, constructor;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function MakeNilBody    (acts: QueueResComplDelegateData; qr1: QueueRes<TInp1>; qr2: QueueRes<TInp2>; qr3: QueueRes<TInp3>; err_handler: ErrHandler; c: CLContext; own_qr: QueueResNil{$ifdef DEBUG}; err_test_reason: string{$endif}): Action;
    begin
      Result := ()->
      begin
        acts.Invoke(c);
        TWork.Create.Invoke(d, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, qr1.GetResDirect, qr2.GetResDirect, qr3.GetResDirect, c);
      end;
    end;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function MakeResBody<TR>(acts: QueueResComplDelegateData; qr1: QueueRes<TInp1>; qr2: QueueRes<TInp2>; qr3: QueueRes<TInp3>; err_handler: ErrHandler; c: CLContext; own_qr: TR{$ifdef DEBUG}; err_test_reason: string{$endif}): Action; where TR: QueueRes<TRes>;
    begin
      Result := ()->
      begin
        acts.Invoke(c);
        own_qr.SetRes(TWork.Create.Invoke(d, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, qr1.GetResDirect, qr2.GetResDirect, qr3.GetResDirect, c));
      end;
    end;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; qr_factory: IQueueResFactory<TRes,TR>; make_body: DCommandQueueThreadedArray3MakeBody<TInp1,TInp2,TInp3, TR>): TR; where TR: IQueueRes;
    begin
      if TrySkipInvoke(g,l, qr_factory, Result) then exit;
      var inv_data := TInv.Create.InvokeToAny(q1,q2,q3, g, l);
      l := inv_data.next_l;
      
      var qr1 := inv_data.qr1;
      var qr2 := inv_data.qr2;
      var qr3 := inv_data.qr3;
      var err_handler := g.curr_err_handler.Extract({$ifdef DEBUG}false{$endif});
      
      {$ifdef DEBUG}
      var err_test_reason := $'[{self.GetHashCode}]:{TypeName(self)}.d.Invoke';
      err_handler.AddMaybeError(err_test_reason);
      {$endif DEBUG}
      
      var should_make_const := if can_pre_call then
        inv_data.all_qrs_const else
        false;
      
      if should_make_const then
        Result := qr_factory.MakeConst(l, TWork.Create.Invoke(d,
          err_handler{$ifdef DEBUG}, err_test_reason{$endif},
          qr1.GetResDirect, qr2.GetResDirect, qr3.GetResDirect, g.c
        )) else
      begin
        var prev_ev := l.prev_ev;
        var acts := l.prev_delegate;
        Result := qr_factory.MakeDelayed(qr->new CLTaskLocalData(UserEvent.StartWorkThread(
          prev_ev, make_body(acts, qr1,qr2,qr3, err_handler, g.c, qr{$ifdef DEBUG}, err_test_reason{$endif}), g
          {$ifdef EventDebug}, $'body of {TypeName(self)}'{$endif}
        )));
      end;
      
    end;
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil;       override := Invoke(g, l, qr_nil_factory, MakeNilBody);
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes   <TRes>; override := Invoke(g, l, qr_val_factory, MakeResBody&<QueueResVal<TRes>>);
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<TRes>; override := Invoke(g, l, qr_ptr_factory, MakeResBody&<QueueResPtr<TRes>>);
    
  end;
  
  CommandQueueConvertThreadedArray3<TInp1,TInp2,TInp3,TRes, TInv, TFunc> = CommandQueueThreadedArray3<TInp1,TInp2,TInp3,TRes, TInv, TFunc, QueueArray3WorkConvert<TInp1,TInp2,TInp3,TRes, TFunc>>;
  CommandQueueUseThreadedArray3    <TInp1,TInp2,TInp3,      TInv, TProc> = CommandQueueThreadedArray3<TInp1,TInp2,TInp3,ValueTuple<TInp1,TInp2,TInp3>, TInv, TProc, QueueArray3WorkUse<TInp1,TInp2,TInp3, TProc>>;
  
  {$endregion Threaded}
  
{$endregion [3]}

{$region [4]} type
  
  {$region Invokers}
  
  QueueArray4InvokerData<TInp1,TInp2,TInp3,TInp4> = record
    public all_qrs_const := true;
    public next_l: CLTaskLocalData;
    public qr1: QueueRes<TInp1>;
    public qr2: QueueRes<TInp2>;
    public qr3: QueueRes<TInp3>;
    public qr4: QueueRes<TInp4>;
  end;
  
  IQueueArray4Invoker = interface
    
    function InvokeToNil<TInp1,TInp2,TInp3,TInp4>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; g: CLTaskGlobalData; l: CLTaskLocalData): CLTaskLocalData;
    function InvokeToAny<TInp1,TInp2,TInp3,TInp4>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; g: CLTaskGlobalData; l: CLTaskLocalData): QueueArray4InvokerData<TInp1,TInp2,TInp3,TInp4>;
    
  end;
  
  QueueArray4SyncInvoker = record(IQueueArray4Invoker)
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function InvokeToNil<TInp1,TInp2,TInp3,TInp4>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; g: CLTaskGlobalData; l: CLTaskLocalData): CLTaskLocalData;
    begin
      l := q1.InvokeToNil(g, l).base;
      l := q2.InvokeToNil(g, l).base;
      l := q3.InvokeToNil(g, l).base;
      l := q4.InvokeToNil(g, l).base;
      Result := l;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function InvokeToAny<TInp1,TInp2,TInp3,TInp4>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; g: CLTaskGlobalData; l: CLTaskLocalData): QueueArray4InvokerData<TInp1,TInp2,TInp3,TInp4>;
    begin
      
      Result.qr1 := q1.InvokeToAny(g, l);
      if not Result.qr1.IsConst then Result.all_qrs_const := false;
      l := Result.qr1.TakeBaseOut;
      
      Result.qr2 := q2.InvokeToAny(g, l);
      if not Result.qr2.IsConst then Result.all_qrs_const := false;
      l := Result.qr2.TakeBaseOut;
      
      Result.qr3 := q3.InvokeToAny(g, l);
      if not Result.qr3.IsConst then Result.all_qrs_const := false;
      l := Result.qr3.TakeBaseOut;
      
      Result.qr4 := q4.InvokeToAny(g, l);
      if not Result.qr4.IsConst then Result.all_qrs_const := false;
      l := Result.qr4.TakeBaseOut;
      
      Result.next_l := l;
    end;
    
  end;
  
  QueueArray4AsyncInvoker = record(IQueueArray4Invoker)
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function InvokeToNil<TInp1,TInp2,TInp3,TInp4>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; g: CLTaskGlobalData; l: CLTaskLocalData): CLTaskLocalData;
    begin
      var res_ev: EventList;
      g.ParallelInvoke(l, 4, invoker->(res_ev := EventList.Combine(|
        invoker.InvokeBranch(q1.InvokeToNil).AttachInvokeActions(invoker.g),
        invoker.InvokeBranch(q2.InvokeToNil).AttachInvokeActions(invoker.g),
        invoker.InvokeBranch(q3.InvokeToNil).AttachInvokeActions(invoker.g),
        invoker.InvokeBranch(q4.InvokeToNil).AttachInvokeActions(invoker.g)
      |)));
      Result := new CLTaskLocalData(res_ev);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function InvokeToAny<TInp1,TInp2,TInp3,TInp4>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; g: CLTaskGlobalData; l: CLTaskLocalData): QueueArray4InvokerData<TInp1,TInp2,TInp3,TInp4>;
    begin
      
      var res: QueueArray4InvokerData<TInp1,TInp2,TInp3,TInp4>;
      g.ParallelInvoke(l, 4, invoker->
      begin
        res.qr1 := invoker.InvokeBranch(q1.InvokeToAny);
        res.qr2 := invoker.InvokeBranch(q2.InvokeToAny);
        res.qr3 := invoker.InvokeBranch(q3.InvokeToAny);
        res.qr4 := invoker.InvokeBranch(q4.InvokeToAny);
      end);
      Result := res;
      
      Result.all_qrs_const := Result.qr1.IsConst and Result.qr2.IsConst and Result.qr3.IsConst and Result.qr4.IsConst;
      Result.next_l := new CLTaskLocalData(EventList.Combine(|
        Result.qr1.AttachInvokeActions(g),
        Result.qr2.AttachInvokeActions(g),
        Result.qr3.AttachInvokeActions(g),
        Result.qr4.AttachInvokeActions(g)
      |));
    end;
    
  end;
  
  {$endregion Invokers}
  
  {$region Work}
  
  IQueueArray4Work<TInp1,TInp2,TInp3,TInp4,TRes, TDelegate> = interface
  where TDelegate: ISimpleDelegateContainer;
    
    function PreInvoke(d: TDelegate; inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4): TRes;
    
    function Invoke(d: TDelegate; err_handler: ErrHandler{$ifdef DEBUG}; err_test_reason: string{$endif}; inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; c: CLContext): TRes;
    
  end;
  
  {$region Func}
  
  ISimpleFunc4Container<TInp1,TInp2,TInp3,TInp4,TRes> = interface(ISimpleDelegateContainer)
    
    function Invoke(inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; c: CLContext): TRes;
    
  end;
  
  SimpleFunc4Container<TInp1,TInp2,TInp3,TInp4,TRes> = record(ISimpleFunc4Container<TInp1,TInp2,TInp3,TInp4,TRes>)
    private d: (TInp1,TInp2,TInp3,TInp4)->TRes;
    
    public static function operator implicit(d: (TInp1,TInp2,TInp3,TInp4)->TRes): SimpleFunc4Container<TInp1,TInp2,TInp3,TInp4,TRes>;
    begin
      Result.d := d;
    end;
    
    public function Invoke(inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; c: CLContext) := d(inp1,inp2,inp3,inp4);
    
    public procedure ToStringB(sb: StringBuilder) :=
    CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  SimpleFunc4ContainerC<TInp1,TInp2,TInp3,TInp4,TRes> = record(ISimpleFunc4Container<TInp1,TInp2,TInp3,TInp4,TRes>)
    private d: (TInp1,TInp2,TInp3,TInp4, CLContext)->TRes;
    
    public static function operator implicit(d: (TInp1,TInp2,TInp3,TInp4, CLContext)->TRes): SimpleFunc4ContainerC<TInp1,TInp2,TInp3,TInp4,TRes>;
    begin
      Result.d := d;
    end;
    
    public function Invoke(inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; c: CLContext) := d(inp1,inp2,inp3,inp4,c);
    
    public procedure ToStringB(sb: StringBuilder) :=
    CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  
  QueueArray4WorkConvert<TInp1,TInp2,TInp3,TInp4,TRes, TFunc> = record(IQueueArray4Work<TInp1,TInp2,TInp3,TInp4,TRes, TFunc>)
  where TFunc: ISimpleFunc4Container<TInp1,TInp2,TInp3,TInp4,TRes>;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function PreInvoke(f: TFunc; inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4) :=
    f.Invoke(inp1,inp2,inp3,inp4, nil);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke(f: TFunc; err_handler: ErrHandler{$ifdef DEBUG}; err_test_reason: string{$endif}; inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; c: CLContext): TRes;
    begin
      if not err_handler.HadError then
      try
        Result := f.Invoke(inp1,inp2,inp3,inp4, c);
      except
        on e: Exception do err_handler.AddErr(e{$ifdef DEBUG}, err_test_reason{$endif})
      end;
      {$ifdef DEBUG}
      err_handler.EndMaybeError(err_test_reason);
      {$endif DEBUG}
    end;
    
  end;
  
  {$endregion Func}
  
  {$region Proc}
  
  ISimpleProc4Container<TInp1,TInp2,TInp3,TInp4> = interface(ISimpleDelegateContainer)
    
    procedure Invoke(inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; c: CLContext);
    
  end;
  
  SimpleProc4Container<TInp1,TInp2,TInp3,TInp4> = record(ISimpleProc4Container<TInp1,TInp2,TInp3,TInp4>)
    private d: (TInp1,TInp2,TInp3,TInp4)->();
    
    public static function operator implicit(d: (TInp1,TInp2,TInp3,TInp4)->()): SimpleProc4Container<TInp1,TInp2,TInp3,TInp4>;
    begin
      Result.d := d;
    end;
    
    public procedure Invoke(inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; c: CLContext) := d(inp1,inp2,inp3,inp4);
    
    public procedure ToStringB(sb: StringBuilder) :=
    CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  SimpleProc4ContainerC<TInp1,TInp2,TInp3,TInp4> = record(ISimpleProc4Container<TInp1,TInp2,TInp3,TInp4>)
    private d: (TInp1,TInp2,TInp3,TInp4, CLContext)->();
    
    public static function operator implicit(d: (TInp1,TInp2,TInp3,TInp4, CLContext)->()): SimpleProc4ContainerC<TInp1,TInp2,TInp3,TInp4>;
    begin
      Result.d := d;
    end;
    
    public procedure Invoke(inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; c: CLContext) := d(inp1,inp2,inp3,inp4,c);
    
    public procedure ToStringB(sb: StringBuilder) :=
    CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  
  QueueArray4WorkUse<TInp1,TInp2,TInp3,TInp4, TProc> = record(IQueueArray4Work<TInp1,TInp2,TInp3,TInp4,ValueTuple<TInp1,TInp2,TInp3,TInp4>, TProc>)
  where TProc: ISimpleProc4Container<TInp1,TInp2,TInp3,TInp4>;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function PreInvoke(p: TProc; inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4): ValueTuple<TInp1,TInp2,TInp3,TInp4>;
    begin
      p.Invoke(inp1,inp2,inp3,inp4, nil);
      Result := ValueTuple.Create(inp1,inp2,inp3,inp4);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke(p: TProc; err_handler: ErrHandler{$ifdef DEBUG}; err_test_reason: string{$endif}; inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; c: CLContext): ValueTuple<TInp1,TInp2,TInp3,TInp4>;
    begin
      if not err_handler.HadError then
      try
        p.Invoke(inp1,inp2,inp3,inp4, c);
        Result := ValueTuple.Create(inp1,inp2,inp3,inp4);
      except
        on e: Exception do err_handler.AddErr(e{$ifdef DEBUG}, err_test_reason{$endif})
      end;
      {$ifdef DEBUG}
      err_handler.EndMaybeError(err_test_reason);
      {$endif DEBUG}
    end;
    
  end;
  
  {$endregion Proc}
  
  {$endregion Work}
  
  {$region Common}
  
  CommandQueueArray4WithWork<TInp1,TInp2,TInp3,TInp4,TRes, TInv,TDelegate,TWork> = abstract class(CommandQueue<TRes>)
  where TInv: IQueueArray4Invoker, constructor;
  where TDelegate: ISimpleDelegateContainer;
  where TWork: IQueueArray4Work<TInp1,TInp2,TInp3,TInp4,TRes, TDelegate>, constructor;
    protected q1: CommandQueue<TInp1>;
    protected q2: CommandQueue<TInp2>;
    protected q3: CommandQueue<TInp3>;
    protected q4: CommandQueue<TInp4>;
    protected d: TDelegate;
    protected can_pre_call: boolean;
    
    public constructor(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; d: TDelegate; can_pre_call: boolean);
    begin
      self.q1 := q1;
      self.q2 := q2;
      self.q3 := q3;
      self.q4 := q4;
      self.d := d;
      self.can_pre_call := can_pre_call;
      if can_pre_call and (q1.const_res_dep<>nil) and (q2.const_res_dep<>nil) and (q3.const_res_dep<>nil) and (q4.const_res_dep<>nil) then
      begin
        self.expected_const_res := TWork.Create.PreInvoke(d,
          q1.expected_const_res,
          q2.expected_const_res,
          q3.expected_const_res,
          q4.expected_const_res
        );
        
        var c := q1.const_res_dep.Length + q2.const_res_dep.Length + q3.const_res_dep.Length + q4.const_res_dep.Length;
        {$ifdef DEBUG}
        if c=0 then raise new OpenCLABCInternalException($'0dep version is CQ/HFQ/HPQ');
        {$endif DEBUG}
        
        self.const_res_dep := new CommandQueueBase[c];
        var dep: array of CommandQueueBase;
        dep := q4.const_res_dep; c -= dep.Length; dep.CopyTo(self.const_res_dep, c);
        dep := q3.const_res_dep; c -= dep.Length; dep.CopyTo(self.const_res_dep, c);
        dep := q2.const_res_dep; c -= dep.Length; dep.CopyTo(self.const_res_dep, c);
        dep := q1.const_res_dep; c -= dep.Length; dep.CopyTo(self.const_res_dep, c);
      end;
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueue>); override :=
    begin
      q1.InitBeforeInvoke(g, inited_hubs);
      q2.InitBeforeInvoke(g, inited_hubs);
      q3.InitBeforeInvoke(g, inited_hubs);
      q4.InitBeforeInvoke(g, inited_hubs);
    end;
    
    protected function TrySkipInvoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; qr_factory: IQueueResFactory<TRes,TR>; var res: TR): boolean; where TR: IQueueRes;
    begin
      Result := qr_factory.TrySkipInvoke(
        g, l,
        self,(g,l)->new QueueResNil(TInv.Create.InvokeToNil(q1,q2,q3,q4, g,l)),
        res
      );
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      q1.ToString(sb, tabs, index, delayed);
      q2.ToString(sb, tabs, index, delayed);
      q3.ToString(sb, tabs, index, delayed);
      q4.ToString(sb, tabs, index, delayed);
      sb.Append(#9, tabs);
      d.ToStringB(sb);
      sb += #10;
    end;
    
  end;
  
  {$endregion Common}
  
  {$region Quick}
  
  CommandQueueQuickArray4<TInp1,TInp2,TInp3,TInp4,TRes, TInv, TDelegate, TWork> = sealed class(CommandQueueArray4WithWork<TInp1,TInp2,TInp3,TInp4,TRes, TInv, TDelegate, TWork>)
  where TInv: IQueueArray4Invoker, constructor;
  where TDelegate: ISimpleDelegateContainer;
  where TWork: IQueueArray4Work<TInp1,TInp2,TInp3,TInp4,TRes, TDelegate>, constructor;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; qr_factory: IQueueResFactory<TRes,TR>): TR; where TR: IQueueRes;
    begin
      if TrySkipInvoke(g,l, qr_factory, Result) then exit;
      var inv_data := TInv.Create.InvokeToAny(q1,q2,q3,q4, g, l);
      l := inv_data.next_l;
      
      var qr1 := inv_data.qr1;
      var qr2 := inv_data.qr2;
      var qr3 := inv_data.qr3;
      var qr4 := inv_data.qr4;
      var err_handler := g.curr_err_handler.Extract({$ifdef DEBUG}false{$endif});
      
      {$ifdef DEBUG}
      var err_test_reason := $'[{self.GetHashCode}]:{TypeName(self)}.d.Invoke';
      err_handler.AddMaybeError(err_test_reason);
      {$endif DEBUG}
      
      var should_make_const := if can_pre_call then
        inv_data.all_qrs_const else
        l.ShouldInstaCallAction;
      
      if should_make_const then
        Result := qr_factory.MakeConst(l, TWork.Create.Invoke(d,
          err_handler{$ifdef DEBUG}, err_test_reason{$endif},
          qr1.GetResDirect, qr2.GetResDirect, qr3.GetResDirect, qr4.GetResDirect, g.c
        )) else
        Result := qr_factory.MakeDelayed(l, qr->c->qr.SetRes(TWork.Create.Invoke(d,
          err_handler{$ifdef DEBUG}, err_test_reason{$endif},
          qr1.GetResDirect, qr2.GetResDirect, qr3.GetResDirect, qr4.GetResDirect, c
        )));
      
    end;
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil;       override := Invoke(g, l, qr_nil_factory);
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes   <TRes>; override := Invoke(g, l, qr_val_factory);
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<TRes>; override := Invoke(g, l, qr_ptr_factory);
    
  end;
  
  CommandQueueConvertQuickArray4<TInp1,TInp2,TInp3,TInp4,TRes, TInv, TFunc> = CommandQueueQuickArray4<TInp1,TInp2,TInp3,TInp4,TRes, TInv, TFunc, QueueArray4WorkConvert<TInp1,TInp2,TInp3,TInp4,TRes, TFunc>>;
  CommandQueueUseQuickArray4    <TInp1,TInp2,TInp3,TInp4,      TInv, TProc> = CommandQueueQuickArray4<TInp1,TInp2,TInp3,TInp4,ValueTuple<TInp1,TInp2,TInp3,TInp4>, TInv, TProc, QueueArray4WorkUse<TInp1,TInp2,TInp3,TInp4, TProc>>;
  
  {$endregion Quick}
  
  {$region Threaded}
  
  DCommandQueueThreadedArray4MakeBody<TInp1,TInp2,TInp3,TInp4, TR> = function(acts: QueueResComplDelegateData; qr1: QueueRes<TInp1>; qr2: QueueRes<TInp2>; qr3: QueueRes<TInp3>; qr4: QueueRes<TInp4>; err_handler: ErrHandler; c: CLContext; own_qr: TR{$ifdef DEBUG}; err_test_reason: string{$endif}): Action;
  CommandQueueThreadedArray4<TInp1,TInp2,TInp3,TInp4,TRes, TInv, TDelegate, TWork> = sealed class(CommandQueueArray4WithWork<TInp1,TInp2,TInp3,TInp4,TRes, TInv, TDelegate, TWork>)
  where TInv: IQueueArray4Invoker, constructor;
  where TDelegate: ISimpleDelegateContainer;
  where TWork: IQueueArray4Work<TInp1,TInp2,TInp3,TInp4,TRes, TDelegate>, constructor;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function MakeNilBody    (acts: QueueResComplDelegateData; qr1: QueueRes<TInp1>; qr2: QueueRes<TInp2>; qr3: QueueRes<TInp3>; qr4: QueueRes<TInp4>; err_handler: ErrHandler; c: CLContext; own_qr: QueueResNil{$ifdef DEBUG}; err_test_reason: string{$endif}): Action;
    begin
      Result := ()->
      begin
        acts.Invoke(c);
        TWork.Create.Invoke(d, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, qr1.GetResDirect, qr2.GetResDirect, qr3.GetResDirect, qr4.GetResDirect, c);
      end;
    end;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function MakeResBody<TR>(acts: QueueResComplDelegateData; qr1: QueueRes<TInp1>; qr2: QueueRes<TInp2>; qr3: QueueRes<TInp3>; qr4: QueueRes<TInp4>; err_handler: ErrHandler; c: CLContext; own_qr: TR{$ifdef DEBUG}; err_test_reason: string{$endif}): Action; where TR: QueueRes<TRes>;
    begin
      Result := ()->
      begin
        acts.Invoke(c);
        own_qr.SetRes(TWork.Create.Invoke(d, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, qr1.GetResDirect, qr2.GetResDirect, qr3.GetResDirect, qr4.GetResDirect, c));
      end;
    end;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; qr_factory: IQueueResFactory<TRes,TR>; make_body: DCommandQueueThreadedArray4MakeBody<TInp1,TInp2,TInp3,TInp4, TR>): TR; where TR: IQueueRes;
    begin
      if TrySkipInvoke(g,l, qr_factory, Result) then exit;
      var inv_data := TInv.Create.InvokeToAny(q1,q2,q3,q4, g, l);
      l := inv_data.next_l;
      
      var qr1 := inv_data.qr1;
      var qr2 := inv_data.qr2;
      var qr3 := inv_data.qr3;
      var qr4 := inv_data.qr4;
      var err_handler := g.curr_err_handler.Extract({$ifdef DEBUG}false{$endif});
      
      {$ifdef DEBUG}
      var err_test_reason := $'[{self.GetHashCode}]:{TypeName(self)}.d.Invoke';
      err_handler.AddMaybeError(err_test_reason);
      {$endif DEBUG}
      
      var should_make_const := if can_pre_call then
        inv_data.all_qrs_const else
        false;
      
      if should_make_const then
        Result := qr_factory.MakeConst(l, TWork.Create.Invoke(d,
          err_handler{$ifdef DEBUG}, err_test_reason{$endif},
          qr1.GetResDirect, qr2.GetResDirect, qr3.GetResDirect, qr4.GetResDirect, g.c
        )) else
      begin
        var prev_ev := l.prev_ev;
        var acts := l.prev_delegate;
        Result := qr_factory.MakeDelayed(qr->new CLTaskLocalData(UserEvent.StartWorkThread(
          prev_ev, make_body(acts, qr1,qr2,qr3,qr4, err_handler, g.c, qr{$ifdef DEBUG}, err_test_reason{$endif}), g
          {$ifdef EventDebug}, $'body of {TypeName(self)}'{$endif}
        )));
      end;
      
    end;
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil;       override := Invoke(g, l, qr_nil_factory, MakeNilBody);
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes   <TRes>; override := Invoke(g, l, qr_val_factory, MakeResBody&<QueueResVal<TRes>>);
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<TRes>; override := Invoke(g, l, qr_ptr_factory, MakeResBody&<QueueResPtr<TRes>>);
    
  end;
  
  CommandQueueConvertThreadedArray4<TInp1,TInp2,TInp3,TInp4,TRes, TInv, TFunc> = CommandQueueThreadedArray4<TInp1,TInp2,TInp3,TInp4,TRes, TInv, TFunc, QueueArray4WorkConvert<TInp1,TInp2,TInp3,TInp4,TRes, TFunc>>;
  CommandQueueUseThreadedArray4    <TInp1,TInp2,TInp3,TInp4,      TInv, TProc> = CommandQueueThreadedArray4<TInp1,TInp2,TInp3,TInp4,ValueTuple<TInp1,TInp2,TInp3,TInp4>, TInv, TProc, QueueArray4WorkUse<TInp1,TInp2,TInp3,TInp4, TProc>>;
  
  {$endregion Threaded}
  
{$endregion [4]}

{$region [5]} type
  
  {$region Invokers}
  
  QueueArray5InvokerData<TInp1,TInp2,TInp3,TInp4,TInp5> = record
    public all_qrs_const := true;
    public next_l: CLTaskLocalData;
    public qr1: QueueRes<TInp1>;
    public qr2: QueueRes<TInp2>;
    public qr3: QueueRes<TInp3>;
    public qr4: QueueRes<TInp4>;
    public qr5: QueueRes<TInp5>;
  end;
  
  IQueueArray5Invoker = interface
    
    function InvokeToNil<TInp1,TInp2,TInp3,TInp4,TInp5>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; g: CLTaskGlobalData; l: CLTaskLocalData): CLTaskLocalData;
    function InvokeToAny<TInp1,TInp2,TInp3,TInp4,TInp5>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; g: CLTaskGlobalData; l: CLTaskLocalData): QueueArray5InvokerData<TInp1,TInp2,TInp3,TInp4,TInp5>;
    
  end;
  
  QueueArray5SyncInvoker = record(IQueueArray5Invoker)
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function InvokeToNil<TInp1,TInp2,TInp3,TInp4,TInp5>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; g: CLTaskGlobalData; l: CLTaskLocalData): CLTaskLocalData;
    begin
      l := q1.InvokeToNil(g, l).base;
      l := q2.InvokeToNil(g, l).base;
      l := q3.InvokeToNil(g, l).base;
      l := q4.InvokeToNil(g, l).base;
      l := q5.InvokeToNil(g, l).base;
      Result := l;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function InvokeToAny<TInp1,TInp2,TInp3,TInp4,TInp5>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; g: CLTaskGlobalData; l: CLTaskLocalData): QueueArray5InvokerData<TInp1,TInp2,TInp3,TInp4,TInp5>;
    begin
      
      Result.qr1 := q1.InvokeToAny(g, l);
      if not Result.qr1.IsConst then Result.all_qrs_const := false;
      l := Result.qr1.TakeBaseOut;
      
      Result.qr2 := q2.InvokeToAny(g, l);
      if not Result.qr2.IsConst then Result.all_qrs_const := false;
      l := Result.qr2.TakeBaseOut;
      
      Result.qr3 := q3.InvokeToAny(g, l);
      if not Result.qr3.IsConst then Result.all_qrs_const := false;
      l := Result.qr3.TakeBaseOut;
      
      Result.qr4 := q4.InvokeToAny(g, l);
      if not Result.qr4.IsConst then Result.all_qrs_const := false;
      l := Result.qr4.TakeBaseOut;
      
      Result.qr5 := q5.InvokeToAny(g, l);
      if not Result.qr5.IsConst then Result.all_qrs_const := false;
      l := Result.qr5.TakeBaseOut;
      
      Result.next_l := l;
    end;
    
  end;
  
  QueueArray5AsyncInvoker = record(IQueueArray5Invoker)
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function InvokeToNil<TInp1,TInp2,TInp3,TInp4,TInp5>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; g: CLTaskGlobalData; l: CLTaskLocalData): CLTaskLocalData;
    begin
      var res_ev: EventList;
      g.ParallelInvoke(l, 5, invoker->(res_ev := EventList.Combine(|
        invoker.InvokeBranch(q1.InvokeToNil).AttachInvokeActions(invoker.g),
        invoker.InvokeBranch(q2.InvokeToNil).AttachInvokeActions(invoker.g),
        invoker.InvokeBranch(q3.InvokeToNil).AttachInvokeActions(invoker.g),
        invoker.InvokeBranch(q4.InvokeToNil).AttachInvokeActions(invoker.g),
        invoker.InvokeBranch(q5.InvokeToNil).AttachInvokeActions(invoker.g)
      |)));
      Result := new CLTaskLocalData(res_ev);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function InvokeToAny<TInp1,TInp2,TInp3,TInp4,TInp5>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; g: CLTaskGlobalData; l: CLTaskLocalData): QueueArray5InvokerData<TInp1,TInp2,TInp3,TInp4,TInp5>;
    begin
      
      var res: QueueArray5InvokerData<TInp1,TInp2,TInp3,TInp4,TInp5>;
      g.ParallelInvoke(l, 5, invoker->
      begin
        res.qr1 := invoker.InvokeBranch(q1.InvokeToAny);
        res.qr2 := invoker.InvokeBranch(q2.InvokeToAny);
        res.qr3 := invoker.InvokeBranch(q3.InvokeToAny);
        res.qr4 := invoker.InvokeBranch(q4.InvokeToAny);
        res.qr5 := invoker.InvokeBranch(q5.InvokeToAny);
      end);
      Result := res;
      
      Result.all_qrs_const := Result.qr1.IsConst and Result.qr2.IsConst and Result.qr3.IsConst and Result.qr4.IsConst and Result.qr5.IsConst;
      Result.next_l := new CLTaskLocalData(EventList.Combine(|
        Result.qr1.AttachInvokeActions(g),
        Result.qr2.AttachInvokeActions(g),
        Result.qr3.AttachInvokeActions(g),
        Result.qr4.AttachInvokeActions(g),
        Result.qr5.AttachInvokeActions(g)
      |));
    end;
    
  end;
  
  {$endregion Invokers}
  
  {$region Work}
  
  IQueueArray5Work<TInp1,TInp2,TInp3,TInp4,TInp5,TRes, TDelegate> = interface
  where TDelegate: ISimpleDelegateContainer;
    
    function PreInvoke(d: TDelegate; inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5): TRes;
    
    function Invoke(d: TDelegate; err_handler: ErrHandler{$ifdef DEBUG}; err_test_reason: string{$endif}; inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; c: CLContext): TRes;
    
  end;
  
  {$region Func}
  
  ISimpleFunc5Container<TInp1,TInp2,TInp3,TInp4,TInp5,TRes> = interface(ISimpleDelegateContainer)
    
    function Invoke(inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; c: CLContext): TRes;
    
  end;
  
  SimpleFunc5Container<TInp1,TInp2,TInp3,TInp4,TInp5,TRes> = record(ISimpleFunc5Container<TInp1,TInp2,TInp3,TInp4,TInp5,TRes>)
    private d: (TInp1,TInp2,TInp3,TInp4,TInp5)->TRes;
    
    public static function operator implicit(d: (TInp1,TInp2,TInp3,TInp4,TInp5)->TRes): SimpleFunc5Container<TInp1,TInp2,TInp3,TInp4,TInp5,TRes>;
    begin
      Result.d := d;
    end;
    
    public function Invoke(inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; c: CLContext) := d(inp1,inp2,inp3,inp4,inp5);
    
    public procedure ToStringB(sb: StringBuilder) :=
    CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  SimpleFunc5ContainerC<TInp1,TInp2,TInp3,TInp4,TInp5,TRes> = record(ISimpleFunc5Container<TInp1,TInp2,TInp3,TInp4,TInp5,TRes>)
    private d: (TInp1,TInp2,TInp3,TInp4,TInp5, CLContext)->TRes;
    
    public static function operator implicit(d: (TInp1,TInp2,TInp3,TInp4,TInp5, CLContext)->TRes): SimpleFunc5ContainerC<TInp1,TInp2,TInp3,TInp4,TInp5,TRes>;
    begin
      Result.d := d;
    end;
    
    public function Invoke(inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; c: CLContext) := d(inp1,inp2,inp3,inp4,inp5,c);
    
    public procedure ToStringB(sb: StringBuilder) :=
    CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  
  QueueArray5WorkConvert<TInp1,TInp2,TInp3,TInp4,TInp5,TRes, TFunc> = record(IQueueArray5Work<TInp1,TInp2,TInp3,TInp4,TInp5,TRes, TFunc>)
  where TFunc: ISimpleFunc5Container<TInp1,TInp2,TInp3,TInp4,TInp5,TRes>;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function PreInvoke(f: TFunc; inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5) :=
    f.Invoke(inp1,inp2,inp3,inp4,inp5, nil);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke(f: TFunc; err_handler: ErrHandler{$ifdef DEBUG}; err_test_reason: string{$endif}; inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; c: CLContext): TRes;
    begin
      if not err_handler.HadError then
      try
        Result := f.Invoke(inp1,inp2,inp3,inp4,inp5, c);
      except
        on e: Exception do err_handler.AddErr(e{$ifdef DEBUG}, err_test_reason{$endif})
      end;
      {$ifdef DEBUG}
      err_handler.EndMaybeError(err_test_reason);
      {$endif DEBUG}
    end;
    
  end;
  
  {$endregion Func}
  
  {$region Proc}
  
  ISimpleProc5Container<TInp1,TInp2,TInp3,TInp4,TInp5> = interface(ISimpleDelegateContainer)
    
    procedure Invoke(inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; c: CLContext);
    
  end;
  
  SimpleProc5Container<TInp1,TInp2,TInp3,TInp4,TInp5> = record(ISimpleProc5Container<TInp1,TInp2,TInp3,TInp4,TInp5>)
    private d: (TInp1,TInp2,TInp3,TInp4,TInp5)->();
    
    public static function operator implicit(d: (TInp1,TInp2,TInp3,TInp4,TInp5)->()): SimpleProc5Container<TInp1,TInp2,TInp3,TInp4,TInp5>;
    begin
      Result.d := d;
    end;
    
    public procedure Invoke(inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; c: CLContext) := d(inp1,inp2,inp3,inp4,inp5);
    
    public procedure ToStringB(sb: StringBuilder) :=
    CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  SimpleProc5ContainerC<TInp1,TInp2,TInp3,TInp4,TInp5> = record(ISimpleProc5Container<TInp1,TInp2,TInp3,TInp4,TInp5>)
    private d: (TInp1,TInp2,TInp3,TInp4,TInp5, CLContext)->();
    
    public static function operator implicit(d: (TInp1,TInp2,TInp3,TInp4,TInp5, CLContext)->()): SimpleProc5ContainerC<TInp1,TInp2,TInp3,TInp4,TInp5>;
    begin
      Result.d := d;
    end;
    
    public procedure Invoke(inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; c: CLContext) := d(inp1,inp2,inp3,inp4,inp5,c);
    
    public procedure ToStringB(sb: StringBuilder) :=
    CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  
  QueueArray5WorkUse<TInp1,TInp2,TInp3,TInp4,TInp5, TProc> = record(IQueueArray5Work<TInp1,TInp2,TInp3,TInp4,TInp5,ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5>, TProc>)
  where TProc: ISimpleProc5Container<TInp1,TInp2,TInp3,TInp4,TInp5>;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function PreInvoke(p: TProc; inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5): ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5>;
    begin
      p.Invoke(inp1,inp2,inp3,inp4,inp5, nil);
      Result := ValueTuple.Create(inp1,inp2,inp3,inp4,inp5);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke(p: TProc; err_handler: ErrHandler{$ifdef DEBUG}; err_test_reason: string{$endif}; inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; c: CLContext): ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5>;
    begin
      if not err_handler.HadError then
      try
        p.Invoke(inp1,inp2,inp3,inp4,inp5, c);
        Result := ValueTuple.Create(inp1,inp2,inp3,inp4,inp5);
      except
        on e: Exception do err_handler.AddErr(e{$ifdef DEBUG}, err_test_reason{$endif})
      end;
      {$ifdef DEBUG}
      err_handler.EndMaybeError(err_test_reason);
      {$endif DEBUG}
    end;
    
  end;
  
  {$endregion Proc}
  
  {$endregion Work}
  
  {$region Common}
  
  CommandQueueArray5WithWork<TInp1,TInp2,TInp3,TInp4,TInp5,TRes, TInv,TDelegate,TWork> = abstract class(CommandQueue<TRes>)
  where TInv: IQueueArray5Invoker, constructor;
  where TDelegate: ISimpleDelegateContainer;
  where TWork: IQueueArray5Work<TInp1,TInp2,TInp3,TInp4,TInp5,TRes, TDelegate>, constructor;
    protected q1: CommandQueue<TInp1>;
    protected q2: CommandQueue<TInp2>;
    protected q3: CommandQueue<TInp3>;
    protected q4: CommandQueue<TInp4>;
    protected q5: CommandQueue<TInp5>;
    protected d: TDelegate;
    protected can_pre_call: boolean;
    
    public constructor(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; d: TDelegate; can_pre_call: boolean);
    begin
      self.q1 := q1;
      self.q2 := q2;
      self.q3 := q3;
      self.q4 := q4;
      self.q5 := q5;
      self.d := d;
      self.can_pre_call := can_pre_call;
      if can_pre_call and (q1.const_res_dep<>nil) and (q2.const_res_dep<>nil) and (q3.const_res_dep<>nil) and (q4.const_res_dep<>nil) and (q5.const_res_dep<>nil) then
      begin
        self.expected_const_res := TWork.Create.PreInvoke(d,
          q1.expected_const_res,
          q2.expected_const_res,
          q3.expected_const_res,
          q4.expected_const_res,
          q5.expected_const_res
        );
        
        var c := q1.const_res_dep.Length + q2.const_res_dep.Length + q3.const_res_dep.Length + q4.const_res_dep.Length + q5.const_res_dep.Length;
        {$ifdef DEBUG}
        if c=0 then raise new OpenCLABCInternalException($'0dep version is CQ/HFQ/HPQ');
        {$endif DEBUG}
        
        self.const_res_dep := new CommandQueueBase[c];
        var dep: array of CommandQueueBase;
        dep := q5.const_res_dep; c -= dep.Length; dep.CopyTo(self.const_res_dep, c);
        dep := q4.const_res_dep; c -= dep.Length; dep.CopyTo(self.const_res_dep, c);
        dep := q3.const_res_dep; c -= dep.Length; dep.CopyTo(self.const_res_dep, c);
        dep := q2.const_res_dep; c -= dep.Length; dep.CopyTo(self.const_res_dep, c);
        dep := q1.const_res_dep; c -= dep.Length; dep.CopyTo(self.const_res_dep, c);
      end;
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueue>); override :=
    begin
      q1.InitBeforeInvoke(g, inited_hubs);
      q2.InitBeforeInvoke(g, inited_hubs);
      q3.InitBeforeInvoke(g, inited_hubs);
      q4.InitBeforeInvoke(g, inited_hubs);
      q5.InitBeforeInvoke(g, inited_hubs);
    end;
    
    protected function TrySkipInvoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; qr_factory: IQueueResFactory<TRes,TR>; var res: TR): boolean; where TR: IQueueRes;
    begin
      Result := qr_factory.TrySkipInvoke(
        g, l,
        self,(g,l)->new QueueResNil(TInv.Create.InvokeToNil(q1,q2,q3,q4,q5, g,l)),
        res
      );
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      q1.ToString(sb, tabs, index, delayed);
      q2.ToString(sb, tabs, index, delayed);
      q3.ToString(sb, tabs, index, delayed);
      q4.ToString(sb, tabs, index, delayed);
      q5.ToString(sb, tabs, index, delayed);
      sb.Append(#9, tabs);
      d.ToStringB(sb);
      sb += #10;
    end;
    
  end;
  
  {$endregion Common}
  
  {$region Quick}
  
  CommandQueueQuickArray5<TInp1,TInp2,TInp3,TInp4,TInp5,TRes, TInv, TDelegate, TWork> = sealed class(CommandQueueArray5WithWork<TInp1,TInp2,TInp3,TInp4,TInp5,TRes, TInv, TDelegate, TWork>)
  where TInv: IQueueArray5Invoker, constructor;
  where TDelegate: ISimpleDelegateContainer;
  where TWork: IQueueArray5Work<TInp1,TInp2,TInp3,TInp4,TInp5,TRes, TDelegate>, constructor;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; qr_factory: IQueueResFactory<TRes,TR>): TR; where TR: IQueueRes;
    begin
      if TrySkipInvoke(g,l, qr_factory, Result) then exit;
      var inv_data := TInv.Create.InvokeToAny(q1,q2,q3,q4,q5, g, l);
      l := inv_data.next_l;
      
      var qr1 := inv_data.qr1;
      var qr2 := inv_data.qr2;
      var qr3 := inv_data.qr3;
      var qr4 := inv_data.qr4;
      var qr5 := inv_data.qr5;
      var err_handler := g.curr_err_handler.Extract({$ifdef DEBUG}false{$endif});
      
      {$ifdef DEBUG}
      var err_test_reason := $'[{self.GetHashCode}]:{TypeName(self)}.d.Invoke';
      err_handler.AddMaybeError(err_test_reason);
      {$endif DEBUG}
      
      var should_make_const := if can_pre_call then
        inv_data.all_qrs_const else
        l.ShouldInstaCallAction;
      
      if should_make_const then
        Result := qr_factory.MakeConst(l, TWork.Create.Invoke(d,
          err_handler{$ifdef DEBUG}, err_test_reason{$endif},
          qr1.GetResDirect, qr2.GetResDirect, qr3.GetResDirect, qr4.GetResDirect, qr5.GetResDirect, g.c
        )) else
        Result := qr_factory.MakeDelayed(l, qr->c->qr.SetRes(TWork.Create.Invoke(d,
          err_handler{$ifdef DEBUG}, err_test_reason{$endif},
          qr1.GetResDirect, qr2.GetResDirect, qr3.GetResDirect, qr4.GetResDirect, qr5.GetResDirect, c
        )));
      
    end;
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil;       override := Invoke(g, l, qr_nil_factory);
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes   <TRes>; override := Invoke(g, l, qr_val_factory);
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<TRes>; override := Invoke(g, l, qr_ptr_factory);
    
  end;
  
  CommandQueueConvertQuickArray5<TInp1,TInp2,TInp3,TInp4,TInp5,TRes, TInv, TFunc> = CommandQueueQuickArray5<TInp1,TInp2,TInp3,TInp4,TInp5,TRes, TInv, TFunc, QueueArray5WorkConvert<TInp1,TInp2,TInp3,TInp4,TInp5,TRes, TFunc>>;
  CommandQueueUseQuickArray5    <TInp1,TInp2,TInp3,TInp4,TInp5,      TInv, TProc> = CommandQueueQuickArray5<TInp1,TInp2,TInp3,TInp4,TInp5,ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5>, TInv, TProc, QueueArray5WorkUse<TInp1,TInp2,TInp3,TInp4,TInp5, TProc>>;
  
  {$endregion Quick}
  
  {$region Threaded}
  
  DCommandQueueThreadedArray5MakeBody<TInp1,TInp2,TInp3,TInp4,TInp5, TR> = function(acts: QueueResComplDelegateData; qr1: QueueRes<TInp1>; qr2: QueueRes<TInp2>; qr3: QueueRes<TInp3>; qr4: QueueRes<TInp4>; qr5: QueueRes<TInp5>; err_handler: ErrHandler; c: CLContext; own_qr: TR{$ifdef DEBUG}; err_test_reason: string{$endif}): Action;
  CommandQueueThreadedArray5<TInp1,TInp2,TInp3,TInp4,TInp5,TRes, TInv, TDelegate, TWork> = sealed class(CommandQueueArray5WithWork<TInp1,TInp2,TInp3,TInp4,TInp5,TRes, TInv, TDelegate, TWork>)
  where TInv: IQueueArray5Invoker, constructor;
  where TDelegate: ISimpleDelegateContainer;
  where TWork: IQueueArray5Work<TInp1,TInp2,TInp3,TInp4,TInp5,TRes, TDelegate>, constructor;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function MakeNilBody    (acts: QueueResComplDelegateData; qr1: QueueRes<TInp1>; qr2: QueueRes<TInp2>; qr3: QueueRes<TInp3>; qr4: QueueRes<TInp4>; qr5: QueueRes<TInp5>; err_handler: ErrHandler; c: CLContext; own_qr: QueueResNil{$ifdef DEBUG}; err_test_reason: string{$endif}): Action;
    begin
      Result := ()->
      begin
        acts.Invoke(c);
        TWork.Create.Invoke(d, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, qr1.GetResDirect, qr2.GetResDirect, qr3.GetResDirect, qr4.GetResDirect, qr5.GetResDirect, c);
      end;
    end;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function MakeResBody<TR>(acts: QueueResComplDelegateData; qr1: QueueRes<TInp1>; qr2: QueueRes<TInp2>; qr3: QueueRes<TInp3>; qr4: QueueRes<TInp4>; qr5: QueueRes<TInp5>; err_handler: ErrHandler; c: CLContext; own_qr: TR{$ifdef DEBUG}; err_test_reason: string{$endif}): Action; where TR: QueueRes<TRes>;
    begin
      Result := ()->
      begin
        acts.Invoke(c);
        own_qr.SetRes(TWork.Create.Invoke(d, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, qr1.GetResDirect, qr2.GetResDirect, qr3.GetResDirect, qr4.GetResDirect, qr5.GetResDirect, c));
      end;
    end;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; qr_factory: IQueueResFactory<TRes,TR>; make_body: DCommandQueueThreadedArray5MakeBody<TInp1,TInp2,TInp3,TInp4,TInp5, TR>): TR; where TR: IQueueRes;
    begin
      if TrySkipInvoke(g,l, qr_factory, Result) then exit;
      var inv_data := TInv.Create.InvokeToAny(q1,q2,q3,q4,q5, g, l);
      l := inv_data.next_l;
      
      var qr1 := inv_data.qr1;
      var qr2 := inv_data.qr2;
      var qr3 := inv_data.qr3;
      var qr4 := inv_data.qr4;
      var qr5 := inv_data.qr5;
      var err_handler := g.curr_err_handler.Extract({$ifdef DEBUG}false{$endif});
      
      {$ifdef DEBUG}
      var err_test_reason := $'[{self.GetHashCode}]:{TypeName(self)}.d.Invoke';
      err_handler.AddMaybeError(err_test_reason);
      {$endif DEBUG}
      
      var should_make_const := if can_pre_call then
        inv_data.all_qrs_const else
        false;
      
      if should_make_const then
        Result := qr_factory.MakeConst(l, TWork.Create.Invoke(d,
          err_handler{$ifdef DEBUG}, err_test_reason{$endif},
          qr1.GetResDirect, qr2.GetResDirect, qr3.GetResDirect, qr4.GetResDirect, qr5.GetResDirect, g.c
        )) else
      begin
        var prev_ev := l.prev_ev;
        var acts := l.prev_delegate;
        Result := qr_factory.MakeDelayed(qr->new CLTaskLocalData(UserEvent.StartWorkThread(
          prev_ev, make_body(acts, qr1,qr2,qr3,qr4,qr5, err_handler, g.c, qr{$ifdef DEBUG}, err_test_reason{$endif}), g
          {$ifdef EventDebug}, $'body of {TypeName(self)}'{$endif}
        )));
      end;
      
    end;
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil;       override := Invoke(g, l, qr_nil_factory, MakeNilBody);
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes   <TRes>; override := Invoke(g, l, qr_val_factory, MakeResBody&<QueueResVal<TRes>>);
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<TRes>; override := Invoke(g, l, qr_ptr_factory, MakeResBody&<QueueResPtr<TRes>>);
    
  end;
  
  CommandQueueConvertThreadedArray5<TInp1,TInp2,TInp3,TInp4,TInp5,TRes, TInv, TFunc> = CommandQueueThreadedArray5<TInp1,TInp2,TInp3,TInp4,TInp5,TRes, TInv, TFunc, QueueArray5WorkConvert<TInp1,TInp2,TInp3,TInp4,TInp5,TRes, TFunc>>;
  CommandQueueUseThreadedArray5    <TInp1,TInp2,TInp3,TInp4,TInp5,      TInv, TProc> = CommandQueueThreadedArray5<TInp1,TInp2,TInp3,TInp4,TInp5,ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5>, TInv, TProc, QueueArray5WorkUse<TInp1,TInp2,TInp3,TInp4,TInp5, TProc>>;
  
  {$endregion Threaded}
  
{$endregion [5]}

{$region [6]} type
  
  {$region Invokers}
  
  QueueArray6InvokerData<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6> = record
    public all_qrs_const := true;
    public next_l: CLTaskLocalData;
    public qr1: QueueRes<TInp1>;
    public qr2: QueueRes<TInp2>;
    public qr3: QueueRes<TInp3>;
    public qr4: QueueRes<TInp4>;
    public qr5: QueueRes<TInp5>;
    public qr6: QueueRes<TInp6>;
  end;
  
  IQueueArray6Invoker = interface
    
    function InvokeToNil<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; g: CLTaskGlobalData; l: CLTaskLocalData): CLTaskLocalData;
    function InvokeToAny<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; g: CLTaskGlobalData; l: CLTaskLocalData): QueueArray6InvokerData<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>;
    
  end;
  
  QueueArray6SyncInvoker = record(IQueueArray6Invoker)
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function InvokeToNil<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; g: CLTaskGlobalData; l: CLTaskLocalData): CLTaskLocalData;
    begin
      l := q1.InvokeToNil(g, l).base;
      l := q2.InvokeToNil(g, l).base;
      l := q3.InvokeToNil(g, l).base;
      l := q4.InvokeToNil(g, l).base;
      l := q5.InvokeToNil(g, l).base;
      l := q6.InvokeToNil(g, l).base;
      Result := l;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function InvokeToAny<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; g: CLTaskGlobalData; l: CLTaskLocalData): QueueArray6InvokerData<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>;
    begin
      
      Result.qr1 := q1.InvokeToAny(g, l);
      if not Result.qr1.IsConst then Result.all_qrs_const := false;
      l := Result.qr1.TakeBaseOut;
      
      Result.qr2 := q2.InvokeToAny(g, l);
      if not Result.qr2.IsConst then Result.all_qrs_const := false;
      l := Result.qr2.TakeBaseOut;
      
      Result.qr3 := q3.InvokeToAny(g, l);
      if not Result.qr3.IsConst then Result.all_qrs_const := false;
      l := Result.qr3.TakeBaseOut;
      
      Result.qr4 := q4.InvokeToAny(g, l);
      if not Result.qr4.IsConst then Result.all_qrs_const := false;
      l := Result.qr4.TakeBaseOut;
      
      Result.qr5 := q5.InvokeToAny(g, l);
      if not Result.qr5.IsConst then Result.all_qrs_const := false;
      l := Result.qr5.TakeBaseOut;
      
      Result.qr6 := q6.InvokeToAny(g, l);
      if not Result.qr6.IsConst then Result.all_qrs_const := false;
      l := Result.qr6.TakeBaseOut;
      
      Result.next_l := l;
    end;
    
  end;
  
  QueueArray6AsyncInvoker = record(IQueueArray6Invoker)
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function InvokeToNil<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; g: CLTaskGlobalData; l: CLTaskLocalData): CLTaskLocalData;
    begin
      var res_ev: EventList;
      g.ParallelInvoke(l, 6, invoker->(res_ev := EventList.Combine(|
        invoker.InvokeBranch(q1.InvokeToNil).AttachInvokeActions(invoker.g),
        invoker.InvokeBranch(q2.InvokeToNil).AttachInvokeActions(invoker.g),
        invoker.InvokeBranch(q3.InvokeToNil).AttachInvokeActions(invoker.g),
        invoker.InvokeBranch(q4.InvokeToNil).AttachInvokeActions(invoker.g),
        invoker.InvokeBranch(q5.InvokeToNil).AttachInvokeActions(invoker.g),
        invoker.InvokeBranch(q6.InvokeToNil).AttachInvokeActions(invoker.g)
      |)));
      Result := new CLTaskLocalData(res_ev);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function InvokeToAny<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; g: CLTaskGlobalData; l: CLTaskLocalData): QueueArray6InvokerData<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>;
    begin
      
      var res: QueueArray6InvokerData<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>;
      g.ParallelInvoke(l, 6, invoker->
      begin
        res.qr1 := invoker.InvokeBranch(q1.InvokeToAny);
        res.qr2 := invoker.InvokeBranch(q2.InvokeToAny);
        res.qr3 := invoker.InvokeBranch(q3.InvokeToAny);
        res.qr4 := invoker.InvokeBranch(q4.InvokeToAny);
        res.qr5 := invoker.InvokeBranch(q5.InvokeToAny);
        res.qr6 := invoker.InvokeBranch(q6.InvokeToAny);
      end);
      Result := res;
      
      Result.all_qrs_const := Result.qr1.IsConst and Result.qr2.IsConst and Result.qr3.IsConst and Result.qr4.IsConst and Result.qr5.IsConst and Result.qr6.IsConst;
      Result.next_l := new CLTaskLocalData(EventList.Combine(|
        Result.qr1.AttachInvokeActions(g),
        Result.qr2.AttachInvokeActions(g),
        Result.qr3.AttachInvokeActions(g),
        Result.qr4.AttachInvokeActions(g),
        Result.qr5.AttachInvokeActions(g),
        Result.qr6.AttachInvokeActions(g)
      |));
    end;
    
  end;
  
  {$endregion Invokers}
  
  {$region Work}
  
  IQueueArray6Work<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TRes, TDelegate> = interface
  where TDelegate: ISimpleDelegateContainer;
    
    function PreInvoke(d: TDelegate; inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; inp6: TInp6): TRes;
    
    function Invoke(d: TDelegate; err_handler: ErrHandler{$ifdef DEBUG}; err_test_reason: string{$endif}; inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; inp6: TInp6; c: CLContext): TRes;
    
  end;
  
  {$region Func}
  
  ISimpleFunc6Container<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TRes> = interface(ISimpleDelegateContainer)
    
    function Invoke(inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; inp6: TInp6; c: CLContext): TRes;
    
  end;
  
  SimpleFunc6Container<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TRes> = record(ISimpleFunc6Container<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TRes>)
    private d: (TInp1,TInp2,TInp3,TInp4,TInp5,TInp6)->TRes;
    
    public static function operator implicit(d: (TInp1,TInp2,TInp3,TInp4,TInp5,TInp6)->TRes): SimpleFunc6Container<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TRes>;
    begin
      Result.d := d;
    end;
    
    public function Invoke(inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; inp6: TInp6; c: CLContext) := d(inp1,inp2,inp3,inp4,inp5,inp6);
    
    public procedure ToStringB(sb: StringBuilder) :=
    CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  SimpleFunc6ContainerC<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TRes> = record(ISimpleFunc6Container<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TRes>)
    private d: (TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, CLContext)->TRes;
    
    public static function operator implicit(d: (TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, CLContext)->TRes): SimpleFunc6ContainerC<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TRes>;
    begin
      Result.d := d;
    end;
    
    public function Invoke(inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; inp6: TInp6; c: CLContext) := d(inp1,inp2,inp3,inp4,inp5,inp6,c);
    
    public procedure ToStringB(sb: StringBuilder) :=
    CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  
  QueueArray6WorkConvert<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TRes, TFunc> = record(IQueueArray6Work<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TRes, TFunc>)
  where TFunc: ISimpleFunc6Container<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TRes>;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function PreInvoke(f: TFunc; inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; inp6: TInp6) :=
    f.Invoke(inp1,inp2,inp3,inp4,inp5,inp6, nil);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke(f: TFunc; err_handler: ErrHandler{$ifdef DEBUG}; err_test_reason: string{$endif}; inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; inp6: TInp6; c: CLContext): TRes;
    begin
      if not err_handler.HadError then
      try
        Result := f.Invoke(inp1,inp2,inp3,inp4,inp5,inp6, c);
      except
        on e: Exception do err_handler.AddErr(e{$ifdef DEBUG}, err_test_reason{$endif})
      end;
      {$ifdef DEBUG}
      err_handler.EndMaybeError(err_test_reason);
      {$endif DEBUG}
    end;
    
  end;
  
  {$endregion Func}
  
  {$region Proc}
  
  ISimpleProc6Container<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6> = interface(ISimpleDelegateContainer)
    
    procedure Invoke(inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; inp6: TInp6; c: CLContext);
    
  end;
  
  SimpleProc6Container<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6> = record(ISimpleProc6Container<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>)
    private d: (TInp1,TInp2,TInp3,TInp4,TInp5,TInp6)->();
    
    public static function operator implicit(d: (TInp1,TInp2,TInp3,TInp4,TInp5,TInp6)->()): SimpleProc6Container<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>;
    begin
      Result.d := d;
    end;
    
    public procedure Invoke(inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; inp6: TInp6; c: CLContext) := d(inp1,inp2,inp3,inp4,inp5,inp6);
    
    public procedure ToStringB(sb: StringBuilder) :=
    CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  SimpleProc6ContainerC<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6> = record(ISimpleProc6Container<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>)
    private d: (TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, CLContext)->();
    
    public static function operator implicit(d: (TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, CLContext)->()): SimpleProc6ContainerC<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>;
    begin
      Result.d := d;
    end;
    
    public procedure Invoke(inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; inp6: TInp6; c: CLContext) := d(inp1,inp2,inp3,inp4,inp5,inp6,c);
    
    public procedure ToStringB(sb: StringBuilder) :=
    CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  
  QueueArray6WorkUse<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, TProc> = record(IQueueArray6Work<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>, TProc>)
  where TProc: ISimpleProc6Container<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function PreInvoke(p: TProc; inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; inp6: TInp6): ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>;
    begin
      p.Invoke(inp1,inp2,inp3,inp4,inp5,inp6, nil);
      Result := ValueTuple.Create(inp1,inp2,inp3,inp4,inp5,inp6);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke(p: TProc; err_handler: ErrHandler{$ifdef DEBUG}; err_test_reason: string{$endif}; inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; inp6: TInp6; c: CLContext): ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>;
    begin
      if not err_handler.HadError then
      try
        p.Invoke(inp1,inp2,inp3,inp4,inp5,inp6, c);
        Result := ValueTuple.Create(inp1,inp2,inp3,inp4,inp5,inp6);
      except
        on e: Exception do err_handler.AddErr(e{$ifdef DEBUG}, err_test_reason{$endif})
      end;
      {$ifdef DEBUG}
      err_handler.EndMaybeError(err_test_reason);
      {$endif DEBUG}
    end;
    
  end;
  
  {$endregion Proc}
  
  {$endregion Work}
  
  {$region Common}
  
  CommandQueueArray6WithWork<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TRes, TInv,TDelegate,TWork> = abstract class(CommandQueue<TRes>)
  where TInv: IQueueArray6Invoker, constructor;
  where TDelegate: ISimpleDelegateContainer;
  where TWork: IQueueArray6Work<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TRes, TDelegate>, constructor;
    protected q1: CommandQueue<TInp1>;
    protected q2: CommandQueue<TInp2>;
    protected q3: CommandQueue<TInp3>;
    protected q4: CommandQueue<TInp4>;
    protected q5: CommandQueue<TInp5>;
    protected q6: CommandQueue<TInp6>;
    protected d: TDelegate;
    protected can_pre_call: boolean;
    
    public constructor(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; d: TDelegate; can_pre_call: boolean);
    begin
      self.q1 := q1;
      self.q2 := q2;
      self.q3 := q3;
      self.q4 := q4;
      self.q5 := q5;
      self.q6 := q6;
      self.d := d;
      self.can_pre_call := can_pre_call;
      if can_pre_call and (q1.const_res_dep<>nil) and (q2.const_res_dep<>nil) and (q3.const_res_dep<>nil) and (q4.const_res_dep<>nil) and (q5.const_res_dep<>nil) and (q6.const_res_dep<>nil) then
      begin
        self.expected_const_res := TWork.Create.PreInvoke(d,
          q1.expected_const_res,
          q2.expected_const_res,
          q3.expected_const_res,
          q4.expected_const_res,
          q5.expected_const_res,
          q6.expected_const_res
        );
        
        var c := q1.const_res_dep.Length + q2.const_res_dep.Length + q3.const_res_dep.Length + q4.const_res_dep.Length + q5.const_res_dep.Length + q6.const_res_dep.Length;
        {$ifdef DEBUG}
        if c=0 then raise new OpenCLABCInternalException($'0dep version is CQ/HFQ/HPQ');
        {$endif DEBUG}
        
        self.const_res_dep := new CommandQueueBase[c];
        var dep: array of CommandQueueBase;
        dep := q6.const_res_dep; c -= dep.Length; dep.CopyTo(self.const_res_dep, c);
        dep := q5.const_res_dep; c -= dep.Length; dep.CopyTo(self.const_res_dep, c);
        dep := q4.const_res_dep; c -= dep.Length; dep.CopyTo(self.const_res_dep, c);
        dep := q3.const_res_dep; c -= dep.Length; dep.CopyTo(self.const_res_dep, c);
        dep := q2.const_res_dep; c -= dep.Length; dep.CopyTo(self.const_res_dep, c);
        dep := q1.const_res_dep; c -= dep.Length; dep.CopyTo(self.const_res_dep, c);
      end;
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueue>); override :=
    begin
      q1.InitBeforeInvoke(g, inited_hubs);
      q2.InitBeforeInvoke(g, inited_hubs);
      q3.InitBeforeInvoke(g, inited_hubs);
      q4.InitBeforeInvoke(g, inited_hubs);
      q5.InitBeforeInvoke(g, inited_hubs);
      q6.InitBeforeInvoke(g, inited_hubs);
    end;
    
    protected function TrySkipInvoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; qr_factory: IQueueResFactory<TRes,TR>; var res: TR): boolean; where TR: IQueueRes;
    begin
      Result := qr_factory.TrySkipInvoke(
        g, l,
        self,(g,l)->new QueueResNil(TInv.Create.InvokeToNil(q1,q2,q3,q4,q5,q6, g,l)),
        res
      );
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      q1.ToString(sb, tabs, index, delayed);
      q2.ToString(sb, tabs, index, delayed);
      q3.ToString(sb, tabs, index, delayed);
      q4.ToString(sb, tabs, index, delayed);
      q5.ToString(sb, tabs, index, delayed);
      q6.ToString(sb, tabs, index, delayed);
      sb.Append(#9, tabs);
      d.ToStringB(sb);
      sb += #10;
    end;
    
  end;
  
  {$endregion Common}
  
  {$region Quick}
  
  CommandQueueQuickArray6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TRes, TInv, TDelegate, TWork> = sealed class(CommandQueueArray6WithWork<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TRes, TInv, TDelegate, TWork>)
  where TInv: IQueueArray6Invoker, constructor;
  where TDelegate: ISimpleDelegateContainer;
  where TWork: IQueueArray6Work<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TRes, TDelegate>, constructor;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; qr_factory: IQueueResFactory<TRes,TR>): TR; where TR: IQueueRes;
    begin
      if TrySkipInvoke(g,l, qr_factory, Result) then exit;
      var inv_data := TInv.Create.InvokeToAny(q1,q2,q3,q4,q5,q6, g, l);
      l := inv_data.next_l;
      
      var qr1 := inv_data.qr1;
      var qr2 := inv_data.qr2;
      var qr3 := inv_data.qr3;
      var qr4 := inv_data.qr4;
      var qr5 := inv_data.qr5;
      var qr6 := inv_data.qr6;
      var err_handler := g.curr_err_handler.Extract({$ifdef DEBUG}false{$endif});
      
      {$ifdef DEBUG}
      var err_test_reason := $'[{self.GetHashCode}]:{TypeName(self)}.d.Invoke';
      err_handler.AddMaybeError(err_test_reason);
      {$endif DEBUG}
      
      var should_make_const := if can_pre_call then
        inv_data.all_qrs_const else
        l.ShouldInstaCallAction;
      
      if should_make_const then
        Result := qr_factory.MakeConst(l, TWork.Create.Invoke(d,
          err_handler{$ifdef DEBUG}, err_test_reason{$endif},
          qr1.GetResDirect, qr2.GetResDirect, qr3.GetResDirect, qr4.GetResDirect, qr5.GetResDirect, qr6.GetResDirect, g.c
        )) else
        Result := qr_factory.MakeDelayed(l, qr->c->qr.SetRes(TWork.Create.Invoke(d,
          err_handler{$ifdef DEBUG}, err_test_reason{$endif},
          qr1.GetResDirect, qr2.GetResDirect, qr3.GetResDirect, qr4.GetResDirect, qr5.GetResDirect, qr6.GetResDirect, c
        )));
      
    end;
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil;       override := Invoke(g, l, qr_nil_factory);
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes   <TRes>; override := Invoke(g, l, qr_val_factory);
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<TRes>; override := Invoke(g, l, qr_ptr_factory);
    
  end;
  
  CommandQueueConvertQuickArray6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TRes, TInv, TFunc> = CommandQueueQuickArray6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TRes, TInv, TFunc, QueueArray6WorkConvert<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TRes, TFunc>>;
  CommandQueueUseQuickArray6    <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,      TInv, TProc> = CommandQueueQuickArray6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>, TInv, TProc, QueueArray6WorkUse<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, TProc>>;
  
  {$endregion Quick}
  
  {$region Threaded}
  
  DCommandQueueThreadedArray6MakeBody<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, TR> = function(acts: QueueResComplDelegateData; qr1: QueueRes<TInp1>; qr2: QueueRes<TInp2>; qr3: QueueRes<TInp3>; qr4: QueueRes<TInp4>; qr5: QueueRes<TInp5>; qr6: QueueRes<TInp6>; err_handler: ErrHandler; c: CLContext; own_qr: TR{$ifdef DEBUG}; err_test_reason: string{$endif}): Action;
  CommandQueueThreadedArray6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TRes, TInv, TDelegate, TWork> = sealed class(CommandQueueArray6WithWork<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TRes, TInv, TDelegate, TWork>)
  where TInv: IQueueArray6Invoker, constructor;
  where TDelegate: ISimpleDelegateContainer;
  where TWork: IQueueArray6Work<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TRes, TDelegate>, constructor;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function MakeNilBody    (acts: QueueResComplDelegateData; qr1: QueueRes<TInp1>; qr2: QueueRes<TInp2>; qr3: QueueRes<TInp3>; qr4: QueueRes<TInp4>; qr5: QueueRes<TInp5>; qr6: QueueRes<TInp6>; err_handler: ErrHandler; c: CLContext; own_qr: QueueResNil{$ifdef DEBUG}; err_test_reason: string{$endif}): Action;
    begin
      Result := ()->
      begin
        acts.Invoke(c);
        TWork.Create.Invoke(d, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, qr1.GetResDirect, qr2.GetResDirect, qr3.GetResDirect, qr4.GetResDirect, qr5.GetResDirect, qr6.GetResDirect, c);
      end;
    end;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function MakeResBody<TR>(acts: QueueResComplDelegateData; qr1: QueueRes<TInp1>; qr2: QueueRes<TInp2>; qr3: QueueRes<TInp3>; qr4: QueueRes<TInp4>; qr5: QueueRes<TInp5>; qr6: QueueRes<TInp6>; err_handler: ErrHandler; c: CLContext; own_qr: TR{$ifdef DEBUG}; err_test_reason: string{$endif}): Action; where TR: QueueRes<TRes>;
    begin
      Result := ()->
      begin
        acts.Invoke(c);
        own_qr.SetRes(TWork.Create.Invoke(d, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, qr1.GetResDirect, qr2.GetResDirect, qr3.GetResDirect, qr4.GetResDirect, qr5.GetResDirect, qr6.GetResDirect, c));
      end;
    end;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; qr_factory: IQueueResFactory<TRes,TR>; make_body: DCommandQueueThreadedArray6MakeBody<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, TR>): TR; where TR: IQueueRes;
    begin
      if TrySkipInvoke(g,l, qr_factory, Result) then exit;
      var inv_data := TInv.Create.InvokeToAny(q1,q2,q3,q4,q5,q6, g, l);
      l := inv_data.next_l;
      
      var qr1 := inv_data.qr1;
      var qr2 := inv_data.qr2;
      var qr3 := inv_data.qr3;
      var qr4 := inv_data.qr4;
      var qr5 := inv_data.qr5;
      var qr6 := inv_data.qr6;
      var err_handler := g.curr_err_handler.Extract({$ifdef DEBUG}false{$endif});
      
      {$ifdef DEBUG}
      var err_test_reason := $'[{self.GetHashCode}]:{TypeName(self)}.d.Invoke';
      err_handler.AddMaybeError(err_test_reason);
      {$endif DEBUG}
      
      var should_make_const := if can_pre_call then
        inv_data.all_qrs_const else
        false;
      
      if should_make_const then
        Result := qr_factory.MakeConst(l, TWork.Create.Invoke(d,
          err_handler{$ifdef DEBUG}, err_test_reason{$endif},
          qr1.GetResDirect, qr2.GetResDirect, qr3.GetResDirect, qr4.GetResDirect, qr5.GetResDirect, qr6.GetResDirect, g.c
        )) else
      begin
        var prev_ev := l.prev_ev;
        var acts := l.prev_delegate;
        Result := qr_factory.MakeDelayed(qr->new CLTaskLocalData(UserEvent.StartWorkThread(
          prev_ev, make_body(acts, qr1,qr2,qr3,qr4,qr5,qr6, err_handler, g.c, qr{$ifdef DEBUG}, err_test_reason{$endif}), g
          {$ifdef EventDebug}, $'body of {TypeName(self)}'{$endif}
        )));
      end;
      
    end;
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil;       override := Invoke(g, l, qr_nil_factory, MakeNilBody);
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes   <TRes>; override := Invoke(g, l, qr_val_factory, MakeResBody&<QueueResVal<TRes>>);
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<TRes>; override := Invoke(g, l, qr_ptr_factory, MakeResBody&<QueueResPtr<TRes>>);
    
  end;
  
  CommandQueueConvertThreadedArray6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TRes, TInv, TFunc> = CommandQueueThreadedArray6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TRes, TInv, TFunc, QueueArray6WorkConvert<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TRes, TFunc>>;
  CommandQueueUseThreadedArray6    <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,      TInv, TProc> = CommandQueueThreadedArray6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>, TInv, TProc, QueueArray6WorkUse<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, TProc>>;
  
  {$endregion Threaded}
  
{$endregion [6]}

{$region [7]} type
  
  {$region Invokers}
  
  QueueArray7InvokerData<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7> = record
    public all_qrs_const := true;
    public next_l: CLTaskLocalData;
    public qr1: QueueRes<TInp1>;
    public qr2: QueueRes<TInp2>;
    public qr3: QueueRes<TInp3>;
    public qr4: QueueRes<TInp4>;
    public qr5: QueueRes<TInp5>;
    public qr6: QueueRes<TInp6>;
    public qr7: QueueRes<TInp7>;
  end;
  
  IQueueArray7Invoker = interface
    
    function InvokeToNil<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; g: CLTaskGlobalData; l: CLTaskLocalData): CLTaskLocalData;
    function InvokeToAny<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; g: CLTaskGlobalData; l: CLTaskLocalData): QueueArray7InvokerData<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>;
    
  end;
  
  QueueArray7SyncInvoker = record(IQueueArray7Invoker)
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function InvokeToNil<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; g: CLTaskGlobalData; l: CLTaskLocalData): CLTaskLocalData;
    begin
      l := q1.InvokeToNil(g, l).base;
      l := q2.InvokeToNil(g, l).base;
      l := q3.InvokeToNil(g, l).base;
      l := q4.InvokeToNil(g, l).base;
      l := q5.InvokeToNil(g, l).base;
      l := q6.InvokeToNil(g, l).base;
      l := q7.InvokeToNil(g, l).base;
      Result := l;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function InvokeToAny<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; g: CLTaskGlobalData; l: CLTaskLocalData): QueueArray7InvokerData<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>;
    begin
      
      Result.qr1 := q1.InvokeToAny(g, l);
      if not Result.qr1.IsConst then Result.all_qrs_const := false;
      l := Result.qr1.TakeBaseOut;
      
      Result.qr2 := q2.InvokeToAny(g, l);
      if not Result.qr2.IsConst then Result.all_qrs_const := false;
      l := Result.qr2.TakeBaseOut;
      
      Result.qr3 := q3.InvokeToAny(g, l);
      if not Result.qr3.IsConst then Result.all_qrs_const := false;
      l := Result.qr3.TakeBaseOut;
      
      Result.qr4 := q4.InvokeToAny(g, l);
      if not Result.qr4.IsConst then Result.all_qrs_const := false;
      l := Result.qr4.TakeBaseOut;
      
      Result.qr5 := q5.InvokeToAny(g, l);
      if not Result.qr5.IsConst then Result.all_qrs_const := false;
      l := Result.qr5.TakeBaseOut;
      
      Result.qr6 := q6.InvokeToAny(g, l);
      if not Result.qr6.IsConst then Result.all_qrs_const := false;
      l := Result.qr6.TakeBaseOut;
      
      Result.qr7 := q7.InvokeToAny(g, l);
      if not Result.qr7.IsConst then Result.all_qrs_const := false;
      l := Result.qr7.TakeBaseOut;
      
      Result.next_l := l;
    end;
    
  end;
  
  QueueArray7AsyncInvoker = record(IQueueArray7Invoker)
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function InvokeToNil<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; g: CLTaskGlobalData; l: CLTaskLocalData): CLTaskLocalData;
    begin
      var res_ev: EventList;
      g.ParallelInvoke(l, 7, invoker->(res_ev := EventList.Combine(|
        invoker.InvokeBranch(q1.InvokeToNil).AttachInvokeActions(invoker.g),
        invoker.InvokeBranch(q2.InvokeToNil).AttachInvokeActions(invoker.g),
        invoker.InvokeBranch(q3.InvokeToNil).AttachInvokeActions(invoker.g),
        invoker.InvokeBranch(q4.InvokeToNil).AttachInvokeActions(invoker.g),
        invoker.InvokeBranch(q5.InvokeToNil).AttachInvokeActions(invoker.g),
        invoker.InvokeBranch(q6.InvokeToNil).AttachInvokeActions(invoker.g),
        invoker.InvokeBranch(q7.InvokeToNil).AttachInvokeActions(invoker.g)
      |)));
      Result := new CLTaskLocalData(res_ev);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function InvokeToAny<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; g: CLTaskGlobalData; l: CLTaskLocalData): QueueArray7InvokerData<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>;
    begin
      
      var res: QueueArray7InvokerData<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>;
      g.ParallelInvoke(l, 7, invoker->
      begin
        res.qr1 := invoker.InvokeBranch(q1.InvokeToAny);
        res.qr2 := invoker.InvokeBranch(q2.InvokeToAny);
        res.qr3 := invoker.InvokeBranch(q3.InvokeToAny);
        res.qr4 := invoker.InvokeBranch(q4.InvokeToAny);
        res.qr5 := invoker.InvokeBranch(q5.InvokeToAny);
        res.qr6 := invoker.InvokeBranch(q6.InvokeToAny);
        res.qr7 := invoker.InvokeBranch(q7.InvokeToAny);
      end);
      Result := res;
      
      Result.all_qrs_const := Result.qr1.IsConst and Result.qr2.IsConst and Result.qr3.IsConst and Result.qr4.IsConst and Result.qr5.IsConst and Result.qr6.IsConst and Result.qr7.IsConst;
      Result.next_l := new CLTaskLocalData(EventList.Combine(|
        Result.qr1.AttachInvokeActions(g),
        Result.qr2.AttachInvokeActions(g),
        Result.qr3.AttachInvokeActions(g),
        Result.qr4.AttachInvokeActions(g),
        Result.qr5.AttachInvokeActions(g),
        Result.qr6.AttachInvokeActions(g),
        Result.qr7.AttachInvokeActions(g)
      |));
    end;
    
  end;
  
  {$endregion Invokers}
  
  {$region Work}
  
  IQueueArray7Work<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes, TDelegate> = interface
  where TDelegate: ISimpleDelegateContainer;
    
    function PreInvoke(d: TDelegate; inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; inp6: TInp6; inp7: TInp7): TRes;
    
    function Invoke(d: TDelegate; err_handler: ErrHandler{$ifdef DEBUG}; err_test_reason: string{$endif}; inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; inp6: TInp6; inp7: TInp7; c: CLContext): TRes;
    
  end;
  
  {$region Func}
  
  ISimpleFunc7Container<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes> = interface(ISimpleDelegateContainer)
    
    function Invoke(inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; inp6: TInp6; inp7: TInp7; c: CLContext): TRes;
    
  end;
  
  SimpleFunc7Container<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes> = record(ISimpleFunc7Container<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes>)
    private d: (TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7)->TRes;
    
    public static function operator implicit(d: (TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7)->TRes): SimpleFunc7Container<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes>;
    begin
      Result.d := d;
    end;
    
    public function Invoke(inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; inp6: TInp6; inp7: TInp7; c: CLContext) := d(inp1,inp2,inp3,inp4,inp5,inp6,inp7);
    
    public procedure ToStringB(sb: StringBuilder) :=
    CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  SimpleFunc7ContainerC<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes> = record(ISimpleFunc7Container<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes>)
    private d: (TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, CLContext)->TRes;
    
    public static function operator implicit(d: (TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, CLContext)->TRes): SimpleFunc7ContainerC<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes>;
    begin
      Result.d := d;
    end;
    
    public function Invoke(inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; inp6: TInp6; inp7: TInp7; c: CLContext) := d(inp1,inp2,inp3,inp4,inp5,inp6,inp7,c);
    
    public procedure ToStringB(sb: StringBuilder) :=
    CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  
  QueueArray7WorkConvert<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes, TFunc> = record(IQueueArray7Work<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes, TFunc>)
  where TFunc: ISimpleFunc7Container<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes>;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function PreInvoke(f: TFunc; inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; inp6: TInp6; inp7: TInp7) :=
    f.Invoke(inp1,inp2,inp3,inp4,inp5,inp6,inp7, nil);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke(f: TFunc; err_handler: ErrHandler{$ifdef DEBUG}; err_test_reason: string{$endif}; inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; inp6: TInp6; inp7: TInp7; c: CLContext): TRes;
    begin
      if not err_handler.HadError then
      try
        Result := f.Invoke(inp1,inp2,inp3,inp4,inp5,inp6,inp7, c);
      except
        on e: Exception do err_handler.AddErr(e{$ifdef DEBUG}, err_test_reason{$endif})
      end;
      {$ifdef DEBUG}
      err_handler.EndMaybeError(err_test_reason);
      {$endif DEBUG}
    end;
    
  end;
  
  {$endregion Func}
  
  {$region Proc}
  
  ISimpleProc7Container<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7> = interface(ISimpleDelegateContainer)
    
    procedure Invoke(inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; inp6: TInp6; inp7: TInp7; c: CLContext);
    
  end;
  
  SimpleProc7Container<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7> = record(ISimpleProc7Container<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>)
    private d: (TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7)->();
    
    public static function operator implicit(d: (TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7)->()): SimpleProc7Container<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>;
    begin
      Result.d := d;
    end;
    
    public procedure Invoke(inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; inp6: TInp6; inp7: TInp7; c: CLContext) := d(inp1,inp2,inp3,inp4,inp5,inp6,inp7);
    
    public procedure ToStringB(sb: StringBuilder) :=
    CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  SimpleProc7ContainerC<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7> = record(ISimpleProc7Container<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>)
    private d: (TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, CLContext)->();
    
    public static function operator implicit(d: (TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, CLContext)->()): SimpleProc7ContainerC<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>;
    begin
      Result.d := d;
    end;
    
    public procedure Invoke(inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; inp6: TInp6; inp7: TInp7; c: CLContext) := d(inp1,inp2,inp3,inp4,inp5,inp6,inp7,c);
    
    public procedure ToStringB(sb: StringBuilder) :=
    CommandQueueBase.ToStringWriteDelegate(sb, d);
    
  end;
  
  QueueArray7WorkUse<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TProc> = record(IQueueArray7Work<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>, TProc>)
  where TProc: ISimpleProc7Container<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function PreInvoke(p: TProc; inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; inp6: TInp6; inp7: TInp7): ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>;
    begin
      p.Invoke(inp1,inp2,inp3,inp4,inp5,inp6,inp7, nil);
      Result := ValueTuple.Create(inp1,inp2,inp3,inp4,inp5,inp6,inp7);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke(p: TProc; err_handler: ErrHandler{$ifdef DEBUG}; err_test_reason: string{$endif}; inp1: TInp1; inp2: TInp2; inp3: TInp3; inp4: TInp4; inp5: TInp5; inp6: TInp6; inp7: TInp7; c: CLContext): ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>;
    begin
      if not err_handler.HadError then
      try
        p.Invoke(inp1,inp2,inp3,inp4,inp5,inp6,inp7, c);
        Result := ValueTuple.Create(inp1,inp2,inp3,inp4,inp5,inp6,inp7);
      except
        on e: Exception do err_handler.AddErr(e{$ifdef DEBUG}, err_test_reason{$endif})
      end;
      {$ifdef DEBUG}
      err_handler.EndMaybeError(err_test_reason);
      {$endif DEBUG}
    end;
    
  end;
  
  {$endregion Proc}
  
  {$endregion Work}
  
  {$region Common}
  
  CommandQueueArray7WithWork<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes, TInv,TDelegate,TWork> = abstract class(CommandQueue<TRes>)
  where TInv: IQueueArray7Invoker, constructor;
  where TDelegate: ISimpleDelegateContainer;
  where TWork: IQueueArray7Work<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes, TDelegate>, constructor;
    protected q1: CommandQueue<TInp1>;
    protected q2: CommandQueue<TInp2>;
    protected q3: CommandQueue<TInp3>;
    protected q4: CommandQueue<TInp4>;
    protected q5: CommandQueue<TInp5>;
    protected q6: CommandQueue<TInp6>;
    protected q7: CommandQueue<TInp7>;
    protected d: TDelegate;
    protected can_pre_call: boolean;
    
    public constructor(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; d: TDelegate; can_pre_call: boolean);
    begin
      self.q1 := q1;
      self.q2 := q2;
      self.q3 := q3;
      self.q4 := q4;
      self.q5 := q5;
      self.q6 := q6;
      self.q7 := q7;
      self.d := d;
      self.can_pre_call := can_pre_call;
      if can_pre_call and (q1.const_res_dep<>nil) and (q2.const_res_dep<>nil) and (q3.const_res_dep<>nil) and (q4.const_res_dep<>nil) and (q5.const_res_dep<>nil) and (q6.const_res_dep<>nil) and (q7.const_res_dep<>nil) then
      begin
        self.expected_const_res := TWork.Create.PreInvoke(d,
          q1.expected_const_res,
          q2.expected_const_res,
          q3.expected_const_res,
          q4.expected_const_res,
          q5.expected_const_res,
          q6.expected_const_res,
          q7.expected_const_res
        );
        
        var c := q1.const_res_dep.Length + q2.const_res_dep.Length + q3.const_res_dep.Length + q4.const_res_dep.Length + q5.const_res_dep.Length + q6.const_res_dep.Length + q7.const_res_dep.Length;
        {$ifdef DEBUG}
        if c=0 then raise new OpenCLABCInternalException($'0dep version is CQ/HFQ/HPQ');
        {$endif DEBUG}
        
        self.const_res_dep := new CommandQueueBase[c];
        var dep: array of CommandQueueBase;
        dep := q7.const_res_dep; c -= dep.Length; dep.CopyTo(self.const_res_dep, c);
        dep := q6.const_res_dep; c -= dep.Length; dep.CopyTo(self.const_res_dep, c);
        dep := q5.const_res_dep; c -= dep.Length; dep.CopyTo(self.const_res_dep, c);
        dep := q4.const_res_dep; c -= dep.Length; dep.CopyTo(self.const_res_dep, c);
        dep := q3.const_res_dep; c -= dep.Length; dep.CopyTo(self.const_res_dep, c);
        dep := q2.const_res_dep; c -= dep.Length; dep.CopyTo(self.const_res_dep, c);
        dep := q1.const_res_dep; c -= dep.Length; dep.CopyTo(self.const_res_dep, c);
      end;
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueue>); override :=
    begin
      q1.InitBeforeInvoke(g, inited_hubs);
      q2.InitBeforeInvoke(g, inited_hubs);
      q3.InitBeforeInvoke(g, inited_hubs);
      q4.InitBeforeInvoke(g, inited_hubs);
      q5.InitBeforeInvoke(g, inited_hubs);
      q6.InitBeforeInvoke(g, inited_hubs);
      q7.InitBeforeInvoke(g, inited_hubs);
    end;
    
    protected function TrySkipInvoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; qr_factory: IQueueResFactory<TRes,TR>; var res: TR): boolean; where TR: IQueueRes;
    begin
      Result := qr_factory.TrySkipInvoke(
        g, l,
        self,(g,l)->new QueueResNil(TInv.Create.InvokeToNil(q1,q2,q3,q4,q5,q6,q7, g,l)),
        res
      );
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      q1.ToString(sb, tabs, index, delayed);
      q2.ToString(sb, tabs, index, delayed);
      q3.ToString(sb, tabs, index, delayed);
      q4.ToString(sb, tabs, index, delayed);
      q5.ToString(sb, tabs, index, delayed);
      q6.ToString(sb, tabs, index, delayed);
      q7.ToString(sb, tabs, index, delayed);
      sb.Append(#9, tabs);
      d.ToStringB(sb);
      sb += #10;
    end;
    
  end;
  
  {$endregion Common}
  
  {$region Quick}
  
  CommandQueueQuickArray7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes, TInv, TDelegate, TWork> = sealed class(CommandQueueArray7WithWork<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes, TInv, TDelegate, TWork>)
  where TInv: IQueueArray7Invoker, constructor;
  where TDelegate: ISimpleDelegateContainer;
  where TWork: IQueueArray7Work<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes, TDelegate>, constructor;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; qr_factory: IQueueResFactory<TRes,TR>): TR; where TR: IQueueRes;
    begin
      if TrySkipInvoke(g,l, qr_factory, Result) then exit;
      var inv_data := TInv.Create.InvokeToAny(q1,q2,q3,q4,q5,q6,q7, g, l);
      l := inv_data.next_l;
      
      var qr1 := inv_data.qr1;
      var qr2 := inv_data.qr2;
      var qr3 := inv_data.qr3;
      var qr4 := inv_data.qr4;
      var qr5 := inv_data.qr5;
      var qr6 := inv_data.qr6;
      var qr7 := inv_data.qr7;
      var err_handler := g.curr_err_handler.Extract({$ifdef DEBUG}false{$endif});
      
      {$ifdef DEBUG}
      var err_test_reason := $'[{self.GetHashCode}]:{TypeName(self)}.d.Invoke';
      err_handler.AddMaybeError(err_test_reason);
      {$endif DEBUG}
      
      var should_make_const := if can_pre_call then
        inv_data.all_qrs_const else
        l.ShouldInstaCallAction;
      
      if should_make_const then
        Result := qr_factory.MakeConst(l, TWork.Create.Invoke(d,
          err_handler{$ifdef DEBUG}, err_test_reason{$endif},
          qr1.GetResDirect, qr2.GetResDirect, qr3.GetResDirect, qr4.GetResDirect, qr5.GetResDirect, qr6.GetResDirect, qr7.GetResDirect, g.c
        )) else
        Result := qr_factory.MakeDelayed(l, qr->c->qr.SetRes(TWork.Create.Invoke(d,
          err_handler{$ifdef DEBUG}, err_test_reason{$endif},
          qr1.GetResDirect, qr2.GetResDirect, qr3.GetResDirect, qr4.GetResDirect, qr5.GetResDirect, qr6.GetResDirect, qr7.GetResDirect, c
        )));
      
    end;
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil;       override := Invoke(g, l, qr_nil_factory);
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes   <TRes>; override := Invoke(g, l, qr_val_factory);
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<TRes>; override := Invoke(g, l, qr_ptr_factory);
    
  end;
  
  CommandQueueConvertQuickArray7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes, TInv, TFunc> = CommandQueueQuickArray7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes, TInv, TFunc, QueueArray7WorkConvert<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes, TFunc>>;
  CommandQueueUseQuickArray7    <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,      TInv, TProc> = CommandQueueQuickArray7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>, TInv, TProc, QueueArray7WorkUse<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TProc>>;
  
  {$endregion Quick}
  
  {$region Threaded}
  
  DCommandQueueThreadedArray7MakeBody<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TR> = function(acts: QueueResComplDelegateData; qr1: QueueRes<TInp1>; qr2: QueueRes<TInp2>; qr3: QueueRes<TInp3>; qr4: QueueRes<TInp4>; qr5: QueueRes<TInp5>; qr6: QueueRes<TInp6>; qr7: QueueRes<TInp7>; err_handler: ErrHandler; c: CLContext; own_qr: TR{$ifdef DEBUG}; err_test_reason: string{$endif}): Action;
  CommandQueueThreadedArray7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes, TInv, TDelegate, TWork> = sealed class(CommandQueueArray7WithWork<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes, TInv, TDelegate, TWork>)
  where TInv: IQueueArray7Invoker, constructor;
  where TDelegate: ISimpleDelegateContainer;
  where TWork: IQueueArray7Work<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes, TDelegate>, constructor;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function MakeNilBody    (acts: QueueResComplDelegateData; qr1: QueueRes<TInp1>; qr2: QueueRes<TInp2>; qr3: QueueRes<TInp3>; qr4: QueueRes<TInp4>; qr5: QueueRes<TInp5>; qr6: QueueRes<TInp6>; qr7: QueueRes<TInp7>; err_handler: ErrHandler; c: CLContext; own_qr: QueueResNil{$ifdef DEBUG}; err_test_reason: string{$endif}): Action;
    begin
      Result := ()->
      begin
        acts.Invoke(c);
        TWork.Create.Invoke(d, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, qr1.GetResDirect, qr2.GetResDirect, qr3.GetResDirect, qr4.GetResDirect, qr5.GetResDirect, qr6.GetResDirect, qr7.GetResDirect, c);
      end;
    end;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function MakeResBody<TR>(acts: QueueResComplDelegateData; qr1: QueueRes<TInp1>; qr2: QueueRes<TInp2>; qr3: QueueRes<TInp3>; qr4: QueueRes<TInp4>; qr5: QueueRes<TInp5>; qr6: QueueRes<TInp6>; qr7: QueueRes<TInp7>; err_handler: ErrHandler; c: CLContext; own_qr: TR{$ifdef DEBUG}; err_test_reason: string{$endif}): Action; where TR: QueueRes<TRes>;
    begin
      Result := ()->
      begin
        acts.Invoke(c);
        own_qr.SetRes(TWork.Create.Invoke(d, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, qr1.GetResDirect, qr2.GetResDirect, qr3.GetResDirect, qr4.GetResDirect, qr5.GetResDirect, qr6.GetResDirect, qr7.GetResDirect, c));
      end;
    end;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; qr_factory: IQueueResFactory<TRes,TR>; make_body: DCommandQueueThreadedArray7MakeBody<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TR>): TR; where TR: IQueueRes;
    begin
      if TrySkipInvoke(g,l, qr_factory, Result) then exit;
      var inv_data := TInv.Create.InvokeToAny(q1,q2,q3,q4,q5,q6,q7, g, l);
      l := inv_data.next_l;
      
      var qr1 := inv_data.qr1;
      var qr2 := inv_data.qr2;
      var qr3 := inv_data.qr3;
      var qr4 := inv_data.qr4;
      var qr5 := inv_data.qr5;
      var qr6 := inv_data.qr6;
      var qr7 := inv_data.qr7;
      var err_handler := g.curr_err_handler.Extract({$ifdef DEBUG}false{$endif});
      
      {$ifdef DEBUG}
      var err_test_reason := $'[{self.GetHashCode}]:{TypeName(self)}.d.Invoke';
      err_handler.AddMaybeError(err_test_reason);
      {$endif DEBUG}
      
      var should_make_const := if can_pre_call then
        inv_data.all_qrs_const else
        false;
      
      if should_make_const then
        Result := qr_factory.MakeConst(l, TWork.Create.Invoke(d,
          err_handler{$ifdef DEBUG}, err_test_reason{$endif},
          qr1.GetResDirect, qr2.GetResDirect, qr3.GetResDirect, qr4.GetResDirect, qr5.GetResDirect, qr6.GetResDirect, qr7.GetResDirect, g.c
        )) else
      begin
        var prev_ev := l.prev_ev;
        var acts := l.prev_delegate;
        Result := qr_factory.MakeDelayed(qr->new CLTaskLocalData(UserEvent.StartWorkThread(
          prev_ev, make_body(acts, qr1,qr2,qr3,qr4,qr5,qr6,qr7, err_handler, g.c, qr{$ifdef DEBUG}, err_test_reason{$endif}), g
          {$ifdef EventDebug}, $'body of {TypeName(self)}'{$endif}
        )));
      end;
      
    end;
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil;       override := Invoke(g, l, qr_nil_factory, MakeNilBody);
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes   <TRes>; override := Invoke(g, l, qr_val_factory, MakeResBody&<QueueResVal<TRes>>);
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<TRes>; override := Invoke(g, l, qr_ptr_factory, MakeResBody&<QueueResPtr<TRes>>);
    
  end;
  
  CommandQueueConvertThreadedArray7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes, TInv, TFunc> = CommandQueueThreadedArray7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes, TInv, TFunc, QueueArray7WorkConvert<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,TRes, TFunc>>;
  CommandQueueUseThreadedArray7    <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,      TInv, TProc> = CommandQueueThreadedArray7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7,ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>, TInv, TProc, QueueArray7WorkUse<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TProc>>;
  
  {$endregion Threaded}
  
{$endregion [7]}

{$endregion +/*}

{$region Cast}

type
  TypedNilQueue<T> = sealed class(CommandQueue<T>)
    private static nil_val := default(T);
    private q: CommandQueueNil;
    
    static constructor;
    begin
      if object(nil_val)<>nil then
        raise new System.InvalidCastException($'.Cast не может преобразовывать nil в {TypeToTypeName(typeof(T))}');
    end;
    public constructor(q: CommandQueueNil) := self.q := q;
    private constructor := raise new OpenCLABCInternalException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_mu: HashSet<IMultiusableCommandQueue>); override := q.InitBeforeInvoke(g, inited_mu);
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil; override := q.InvokeToNil(g, l);
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes<T>; override := qr_val_factory.MakeConst(q.InvokeToNil(g, l).base, nil_val);
    
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<T>; override;
    begin
      Result := nil;
      raise new OpenCLABCInternalException($'%Err:Invoke:InvalidToPtr%');
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      q.ToString(sb, tabs, index, delayed);
    end;
    
  end;
  
  CastQueue<TInp, TRes> = sealed class(CastQueueBase<TRes>)
    private q: CommandQueue<TInp>;
    
    static constructor;
    begin
      if typeof(TInp)=typeof(object) then exit;
      try
        var res := TRes(object(default(TInp)));
        System.GC.KeepAlive(res);
      except
        raise new System.InvalidCastException($'.Cast не может преобразовывать {TypeToTypeName(typeof(TInp))} в {TypeToTypeName(typeof(TRes))}');
      end;
    end;
    public constructor(q: CommandQueue<TInp>);
    begin
      self.q := q;
      if q.const_res_dep<>nil then
      begin
        self.expected_const_res := TRes(q.expected_const_res as object);
        self.const_res_dep := q.const_res_dep;
      end;
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    public property SourceBase: CommandQueueBase read q as CommandQueueBase; override;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_mu: HashSet<IMultiusableCommandQueue>); override :=
    q.InitBeforeInvoke(g, inited_mu);
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil; override := q.InvokeToNil(g, l);
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; qr_factory: IQueueResFactory<TRes,TR>): TR; where TR: QueueRes<TRes>;
    begin
      if qr_factory.TrySkipInvoke(g,l, self,q.InvokeToNil, Result) then exit;
      var prev_qr := q.InvokeToAny(g,l);
      var err_handler := g.curr_err_handler.Extract({$ifdef DEBUG}false{$endif});
      {$ifdef DEBUG}
      var err_test_reason := $'[{self.GetHashCode}]:{TypeName(self)}';
      err_handler.AddMaybeError(err_test_reason);
      {$endif DEBUG}
      Result := prev_qr.TransformResult(qr_factory, true, o->
      begin
        if not err_handler.HadError then
        try
          Result := TRes(o as object);
        except
          on e: Exception do err_handler.AddErr(e{$ifdef DEBUG}, err_test_reason{$endif});
        end;
        {$ifdef DEBUG}
        err_handler.EndMaybeError(err_test_reason);
        {$endif DEBUG}
      end);
    end;
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes   <TRes>; override := Invoke(g, l, qr_val_factory);
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<TRes>; override := Invoke(g, l, qr_ptr_factory);
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      q.ToString(sb, tabs, index, delayed);
    end;
    
  end;
  
  CastQueueConstructor<TRes> = record(ITypedCQConverter<CommandQueue<TRes>>)
    
    public function ConvertNil(q: CommandQueueNil): CommandQueue<TRes> :=
    if q is ConstQueueNil then
      CQ(TypedNilQueue&<TRes>.nil_val) else
      new TypedNilQueue<TRes>(q);
    
    public function Convert<TInp>(q: CommandQueue<TInp>): CommandQueue<TRes> :=
    if q is CastQueueBase<TInp>(var cqb) then
      cqb.SourceBase.Cast&<TRes> else
    if q.IsConstResDepEmpty then
      q + CQ(TRes(q.expected_const_res as object)) else
      new CastQueue<TInp, TRes>(q);
    
  end;
  
function CommandQueueBase.Cast<T>: CommandQueue<T>;
begin
  if self is CommandQueue<T>(var tcq) then
    Result := tcq else
  try
    Result := self.ConvertTyped(new CastQueueConstructor<T>);
  except
    on e: TypeInitializationException do
      raise e.InnerException;
    on e: InvalidCastException do
      raise e;
  end;
end;

function CommandQueueNil.Cast<T> := new TypedNilQueue<T>(self);

{$endregion Cast}

{$region DiscardResult}

function CommandQueue<T>.DiscardResult := self + CQNil;

{$endregion DiscardResult}

{$region Then[Convert,Use]}

{$region Common}

type
  CommandQueueThenWork<TInp,TRes, TDelegate> = abstract class(CommandQueue<TRes>)
  where TDelegate: ISimpleDelegateContainer;
    protected q: CommandQueue<TInp>;
    protected d: TDelegate;
    protected can_pre_call: boolean;
    
    public constructor(q: CommandQueue<TInp>; d: TDelegate; can_pre_call: boolean);
    begin
      self.q := q;
      self.d := d;
      self.can_pre_call := can_pre_call;
      if can_pre_call and (q.const_res_dep<>nil) then
      begin
        {$ifdef DEBUG}
        if q.IsConstResDepEmpty then
          raise new OpenCLABCInternalException($'0dep version is CQ/HFQ');
        {$endif DEBUG}
        self.expected_const_res := d.PreInvoke&<TInp,TRes>(q.expected_const_res);
        self.const_res_dep := q.const_res_dep;
      end;
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_mu: HashSet<IMultiusableCommandQueue>); override := q.InitBeforeInvoke(g, inited_mu);
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      q.ToString(sb, tabs, index, delayed);
      
      sb.Append(#9, tabs);
      d.ToStringB(sb);
      sb += #10;
      
    end;
    
  end;
  CommandQueueThenConvert<TInp,TRes, TFunc> = CommandQueueThenWork<TInp,TRes, TFunc>;
  CommandQueueThenUse<T, TProc> = CommandQueueThenWork<T,T, TProc>;
  
{$endregion Common}

{$region Convert}

type
  CommandQueueThenQuickConvert<TInp, TRes, TFunc> = sealed class(CommandQueueThenConvert<TInp,TRes, TFunc>)
  where TFunc: ISimpleFuncContainer<TInp, TRes>;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; qr_factory: IQueueResFactory<TRes,TR>): TR; where TR: IQueueRes;
    begin
      if qr_factory.TrySkipInvoke(g,l, self,q.InvokeToNil, Result) then exit;
      var prev_qr := q.InvokeToAny(g, l);
      
      var should_make_const := if can_pre_call then
        prev_qr.IsConst else
        prev_qr.ShouldInstaCallAction;
      l := prev_qr.TakeBaseOut;
      
      var err_handler := g.curr_err_handler.Extract({$ifdef DEBUG}false{$endif});
      {$ifdef DEBUG}
      var err_test_reason := $'[{self.GetHashCode}]:{TypeName(self)}.d.Invoke';
      err_handler.AddMaybeError(err_test_reason);
      {$endif DEBUG}
      Result := if should_make_const then
        qr_factory.MakeConst(l,
          d.Invoke(g, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, prev_qr.GetResDirect, g.c)
        ) else
        qr_factory.MakeDelayed(l, qr->c->qr.SetRes(
          d.Invoke(nil, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, prev_qr.GetResDirect, c)
        ));
      
    end;
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil;       override := Invoke(g, l, qr_nil_factory);
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes   <TRes>; override := Invoke(g, l, qr_val_factory);
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<TRes>; override := Invoke(g, l, qr_ptr_factory);
    
  end;
  
  CommandQueueThenThreadedConvert<TInp,TRes, TFunc> = sealed class(CommandQueueThenConvert<TInp,TRes, TFunc>)
  where TFunc: ISimpleFuncContainer<TInp,TRes>;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function MakeNilBody    (prev_qr: QueueRes<TInp>; err_handler: ErrHandler; c: CLContext; own_qr: QueueResNil{$ifdef DEBUG}; err_test_reason: string{$endif}): Action;
    begin
      Result := ()->
        d.Invoke(nil, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, prev_qr.GetRes(c), c)
    end;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function MakeResBody<TR>(prev_qr: QueueRes<TInp>; err_handler: ErrHandler; c: CLContext; own_qr: TR{$ifdef DEBUG}; err_test_reason: string{$endif}): Action; where TR: QueueRes<TRes>;
    begin
      Result := ()->own_qr.SetRes(
        d.Invoke(nil, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, prev_qr.GetRes(c), c)
      );
    end;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; qr_factory: IQueueResFactory<TRes,TR>; make_body: (QueueRes<TInp>,ErrHandler,CLContext,TR{$ifdef DEBUG},string{$endif})->Action): TR; where TR: IQueueRes;
    begin
      if qr_factory.TrySkipInvoke(g,l, self,q.InvokeToNil, Result) then exit;
      var prev_qr := q.InvokeToAny(g, l);
      var err_handler := g.curr_err_handler.Extract({$ifdef DEBUG}false{$endif});
      
      {$ifdef DEBUG}
      var err_test_reason := $'[{self.GetHashCode}]:{TypeName(self)}.d.Invoke';
      err_handler.AddMaybeError(err_test_reason);
      {$endif DEBUG}
      
      Result := if can_pre_call and prev_qr.IsConst then
        qr_factory.MakeConst(l,
          d.Invoke(g, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, prev_qr.GetResDirect, nil)
        ) else
        qr_factory.MakeDelayed(qr->new CLTaskLocalData(UserEvent.StartWorkThread(
          prev_qr.ResEv, make_body(prev_qr, err_handler, g.c, qr{$ifdef DEBUG}, err_test_reason{$endif}), g
          {$ifdef EventDebug}, $'body of {TypeName(self)}'{$endif}
        )));
      
    end;
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil;       override := Invoke(g, l, qr_nil_factory, MakeNilBody);
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes   <TRes>; override := Invoke(g, l, qr_val_factory, MakeResBody&<QueueResVal<TRes>>);
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<TRes>; override := Invoke(g, l, qr_ptr_factory, MakeResBody&<QueueResPtr<TRes>>);
    
  end;
  
function CommandQueue<T>.ThenConvert<TOtp>(f: T->TOtp; need_own_thread, can_pre_calc: boolean): CommandQueue<TOtp>;
begin
  if self.IsConstResDepEmpty then
  begin
    var inp := self.expected_const_res;
    Result := self + if can_pre_calc then
      CQ(f(inp)) else
      HFQ(()->f(inp), need_own_thread);
  end else
  if need_own_thread then
    Result := new CommandQueueThenThreadedConvert <T, TOtp, SimpleFuncContainer<T,TOtp>>(self, f, can_pre_calc) else
    Result := new CommandQueueThenQuickConvert    <T, TOtp, SimpleFuncContainer<T,TOtp>>(self, f, can_pre_calc);
end;

function CommandQueue<T>.ThenConvert<TOtp>(f: (T,CLContext)->TOtp; need_own_thread, can_pre_calc: boolean): CommandQueue<TOtp>;
begin
  if self.IsConstResDepEmpty then
  begin
    var inp := self.expected_const_res;
    Result := self + if can_pre_calc then
      CQ(f(inp,nil)) else
      HFQ(c->f(inp,c), need_own_thread);
  end else
  if need_own_thread then
    Result := new CommandQueueThenThreadedConvert <T, TOtp, SimpleFuncContainerC<T,TOtp>>(self, f, can_pre_calc) else
    Result := new CommandQueueThenQuickConvert    <T, TOtp, SimpleFuncContainerC<T,TOtp>>(self, f, can_pre_calc);
end;

{$endregion Convert}

{$region Use}

type
  CommandQueueThenQuickUse<T, TProc> = sealed class(CommandQueueThenUse<T, TProc>)
  where TProc: ISimpleProcContainer<T>;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function AddUse<TR1, TR2>(prev_is_const: boolean; prev_qr: TR1; own_qr: TR2; g: CLTaskGlobalData): TR2; where TR1: QueueRes<T>; where TR2: IQueueRes;
    begin
      Result := own_qr;
      
      // .IsConst debug tests executed before this
      // So if prev_is_const then also Result.ShouldInstaCallAction
      var should_insta_call := if can_pre_call then
        prev_is_const else
        Result.ShouldInstaCallAction;
      
      var err_handler := g.curr_err_handler.Extract({$ifdef DEBUG}false{$endif});
      {$ifdef DEBUG}
      var err_test_reason := $'[{self.GetHashCode}]:{TypeName(self)}.d.Invoke';
      err_handler.AddMaybeError(err_test_reason);
      {$endif DEBUG}
      if should_insta_call then
        d.Invoke(g, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, prev_qr.GetResDirect, g.c) else
        //TODO #????: self.
        Result.AddAction(c->self.d.Invoke(nil, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, prev_qr.GetResDirect, c));
      
    end;
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil; override;
    begin
      if g.CheckDeps(self.const_res_dep) then
        Result := q.InvokeToNil(g, l) else
      begin
        var prev_qr := q.InvokeToAny(g, l);
        Result := AddUse(prev_qr.IsConst, prev_qr, new QueueResNil(prev_qr.TakeBaseOut), g);
      end;
    end;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function AddUse<TR>(qr: TR; g: CLTaskGlobalData): TR; where TR: QueueRes<T>;
    begin
      Result := qr;
      //TODO Единственный способ не вызывать эту же проверку из q.InvokeToAny(g, l)
      // - Передавать данные о том, что все зависимости сработали
      // - Или self=>q, или q=>self
      // - Первый способ должен быть капельку быстрее для Combine очередей,
      //   если один параметр используется в нескольких ветках
      // - А второй поидее проще реализовать, потому что данные будут в qr
      // - Подумать, может ли константность qr сразу говорить и о CheckDeps
      if g.CheckDeps(self.const_res_dep) then exit;
      Result := AddUse(qr.IsConst, qr,qr, g);
    end;
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes   <T>; override := AddUse(q.InvokeToAny(g, l), g);
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<T>; override := AddUse(q.InvokeToPtr(g, l), g);
    
  end;
  
  CommandQueueThenThreadedUse<T, TProc> = sealed class(CommandQueueThenUse<T, TProc>)
  where TProc: ISimpleProcContainer<T>;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke<TR1,TR2>(g: CLTaskGlobalData; l: CLTaskLocalData; q_invoker: CommandQueueInvoker<TR1>; qr_factory: IQueueResFactory<T,TR2>): TR2; where TR1: QueueRes<T>; where TR2: IQueueRes;
    begin
      if qr_factory.TrySkipInvoke(g,l, self,q.InvokeToNil, Result) then exit;
      
      var prev_qr := q_invoker(g, l);
      if can_pre_call and prev_qr.IsConst then
      begin
        //TODO И тут тоже (как и ниже) лишний объект во всех случаях кроме TR2=QueueResNil
        Result := qr_factory.MakeConst(prev_qr.TakeBaseOut, prev_qr.GetResDirect);
        //TODO А разве не надо тут делать self.d.Invoke(g, ...), как в ThenQuickConvert?
        exit;
      end;
      
      var acts := prev_qr.base.complition_delegate.TakeOut;
      
      var err_handler := g.curr_err_handler.Extract({$ifdef DEBUG}false{$endif});
      {$ifdef DEBUG}
      var err_test_reason := $'[{self.GetHashCode}]:{TypeName(self)}.d.Invoke';
      err_handler.AddMaybeError(err_test_reason);
      {$endif DEBUG}
      var c := g.c;
      var work_ev := UserEvent.StartWorkThread(
        prev_qr.ResEv, ()->
        begin
          acts.Invoke(c);
          //TODO #????: self.
          self.d.Invoke(nil, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, prev_qr.GetResDirect, c);
        end, g
        {$ifdef EventDebug}, $'body of {TypeName(self)}'{$endif}
      );
      
      //TODO На самом деле создавать новый объект, даже если обёртку - ни к чему
      // - Новый объект нужен только при .MakeWrap mu результата
      // - А тут должно быть достаточно подменить ивент
      // --- status check ожидает что ивент не будет меняться
      // - Но InvokeToNil создаёт "new QueueResNil(work_ev)"
      // --- InvokeToAny и InvokeToPtr копируют тип prev_qr
      // - Это касается только .Then и только Use, потому что в остальных случаях нельзя использовать существующий QR
      Result := qr_factory.MakeWrap(prev_qr, work_ev);
    end;
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil;    override := Invoke(g, l, q.InvokeToAny, qr_nil_factory);
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes   <T>; override := Invoke(g, l, q.InvokeToAny, qr_val_factory);
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<T>; override := Invoke(g, l, q.InvokeToPtr, qr_ptr_factory);
    
  end;
  
function CommandQueue<T>.ThenUse(p: T->(); need_own_thread, can_pre_calc: boolean): CommandQueue<T>;
begin
  if self.IsConstResDepEmpty then
  begin
    var inp := self.expected_const_res;
    Result := self;
    if can_pre_calc then
      p(inp) else
      Result += HPQ(()->p(inp), need_own_thread) + CQ(inp);
  end else
  if need_own_thread then
    Result := new CommandQueueThenThreadedUse <T, SimpleProcContainer<T>>(self, p, can_pre_calc) else
    Result := new CommandQueueThenQuickUse    <T, SimpleProcContainer<T>>(self, p, can_pre_calc);
end;

function CommandQueue<T>.ThenUse(p: (T,CLContext)->(); need_own_thread, can_pre_calc: boolean): CommandQueue<T>;
begin
  if self.IsConstResDepEmpty then
  begin
    var inp := self.expected_const_res;
    Result := self;
    if can_pre_calc then
      p(inp,nil) else
      Result += HPQ(c->p(inp,c), need_own_thread) + CQ(inp);
  end else
  if need_own_thread then
    Result := new CommandQueueThenThreadedUse <T, SimpleProcContainerC<T>>(self, p, can_pre_calc) else
    Result := new CommandQueueThenQuickUse    <T, SimpleProcContainerC<T>>(self, p, can_pre_calc);
end;

{$endregion Use}

{$endregion Then[Convert,Use}

{$region Multiusable}

type
  MultiusableCommandQueueCommon = static class
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static procedure InitBeforeInvoke(self: IMultiusableCommandQueue; q: CommandQueueBase; g: CLTaskGlobalData; inited_mu: HashSet<IMultiusableCommandQueue>) :=
    if inited_mu.Add(self) then q.InitBeforeInvoke(g, inited_mu);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static function Invoke<TR1, TR2>(
      self: IMultiusableCommandQueue;
      g: CLTaskGlobalData; l: CLTaskLocalData;
      invoke_q: CommandQueueInvoker<TR1>;
      make_wrap: (TR1, EventList)->TR2
    ): TR2; where TR1,TR2: IQueueRes;
    begin
      var res_data: MultiuseableResultData;
      var qr: TR1;
      
      var origin_err_handler := g.curr_err_handler;
      // Потоко-безопасно, потому что все .Invoke выполняются синхронно
      //TODO А что будет когда .ThenIf и т.п.?
      if g.mu_res.TryGetValue(self, res_data) then
      begin
        qr := TR1(res_data.qres);
        if res_data.had_insta_err then
          g.had_insta_err := true;
      end else
      begin
        var prev_had_insta_err := g.had_insta_err;
        g.had_insta_err := false;
        g.curr_err_handler := LazyErrHandler.FromFunc(true, ()->new ErrHandlerInitial({$ifdef DEBUG}$'Initial MU invoke'{$endif}));
        
        qr := invoke_q(g, new CLTaskLocalData);
        var ev := qr.AttachInvokeActions(g);
        
        res_data := new MultiuseableResultData(qr, ev, g.curr_err_handler.TrySkipFunc, g.had_insta_err);
        g.mu_res.Add(self, res_data);
        
        if prev_had_insta_err then
          g.had_insta_err := true;
      end;
      g.curr_err_handler := ErrHandlerMURepeater.Wrap(origin_err_handler, res_data.victim_err_handler{$ifdef DEBUG}, $'MU repeater for {TypeName(self.Victim)}'{$endif});
      
      if g.prev_mu.Add(self) then
      begin
        // "all", except Q+Q, because q's in g.prev_mu are already waited upon
        res_data.ev.Retain({$ifdef EventDebug}$'for all mu branches'{$endif});
        Result := make_wrap(qr, res_data.ev + l.AttachInvokeActions(g{$ifdef EventDebug}, qr{$endif}));
      end else
      begin
        Result := make_wrap(qr, l.prev_ev);
        Result.AddActions(l.prev_delegate);
      end;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static function InvokeToNil<TR>(self: IMultiusableCommandQueue; g: CLTaskGlobalData; l: CLTaskLocalData; invoke_q: CommandQueueInvoker<TR>): QueueResNil; where TR: IQueueRes;
    begin
      Result := Invoke(self, g,l, invoke_q, (qr, ev)->new QueueResNil(ev));
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static procedure ToString(q: CommandQueueBase; sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>);
    begin
      sb += ' => ';
      if q.ToStringHeader(sb, index) then
        delayed.Add(q);
      sb += #10;
    end;
    
  end;
  
  MultiusableCommandQueueNil = sealed class(CommandQueueNil, IMultiusableCommandQueue)
    public q: CommandQueueNil;
    
    public constructor(q: CommandQueueNil) := self.q := q;
    private constructor := raise new OpenCLABCInternalException;
    
    {$ifdef DEBUG}
    public property Victim: CommandQueueBase read q as CommandQueueBase;
    {$endif DEBUG}
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_mu: HashSet<IMultiusableCommandQueue>); override :=
    MultiusableCommandQueueCommon.InitBeforeInvoke(self,q, g,inited_mu);
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil; override :=
    MultiusableCommandQueueCommon.InvokeToNil(self, g,l, q.InvokeToNil);
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    MultiusableCommandQueueCommon.ToString(q, sb,tabs,index,delayed);
    
  end;
  
  MultiusableCommandQueue<T> = sealed class(CommandQueue<T>, IMultiusableCommandQueue)
    public q: CommandQueue<T>;
    
    public constructor(q: CommandQueue<T>);
    begin
      inherited Create(q.expected_const_res, q.const_res_dep);
      self.q := q;
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    {$ifdef DEBUG}
    public property Victim: CommandQueueBase read q as CommandQueueBase;
    {$endif DEBUG}
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_mu: HashSet<IMultiusableCommandQueue>); override :=
    MultiusableCommandQueueCommon.InitBeforeInvoke(self,q, g,inited_mu);
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil;    override :=
    MultiusableCommandQueueCommon.InvokeToNil(self, g,l, q.InvokeToAny);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; qr_factory: IQueueResFactory<T,TR>): TR; where TR: QueueRes<T>;
    begin
      Result := MultiusableCommandQueueCommon
        .Invoke(self, g,l, q.InvokeToAny, qr_factory.MakeWrap);
    end;
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes   <T>; override := Invoke(g, l, qr_val_factory);
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<T>; override := Invoke(g, l, qr_ptr_factory);
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    MultiusableCommandQueueCommon.ToString(q, sb,tabs,index,delayed);
    
  end;
  
function CommandQueueNil.Multiusable :=
if (self is MultiusableCommandQueueNil) or (self is ConstQueueNil) then
  self else new MultiusableCommandQueueNil(self);

function CommandQueue<T>.Multiusable :=
// No const_res_dep checks, because (HPQ+CQ).MU should execute HPQ once
if (self is MultiusableCommandQueue<T>) or (self is ConstQueue<T>) or (self is ParameterQueue<T>) then
  self else new MultiusableCommandQueue<T>(self);

{$endregion Multiusable}

{$region Wait}

{$region Def}
//TODO Куча дублей кода, особенно в Combination
//TODO data ничего не делает, кроме как для WaitDebug, потому что state хранится в sub_info
// - Лучше передавать self.GetHashCode
//TODO Отписка никогда не происходит - пока не сделал, чтоб перепродумывать как обрабатывать всё при циклах

{$region Base}

type
  WaitMarker = abstract partial class
    
    public procedure InitInnerHandles(g: CLTaskGlobalData); abstract;
    
    public function MakeWaitEv(g: CLTaskGlobalData; prev_ev: EventList): EventList; abstract;
    public function MakeWaitEv(g: CLTaskGlobalData; l: CLTaskLocalData) := MakeWaitEv(g, l.AttachInvokeActions(g{$ifdef EventDebug}, l{$endif}));
    
  end;
  
{$endregion Base}

{$region Outer}

type
  /// wait_handler, который можно встроить в очередь как есть
  WaitHandlerOuter = abstract class
    public uev: UserEvent;
    private state := 0;
    private gc_hnd: GCHandle;
    
    public constructor(g: CLTaskGlobalData; prev_ev: EventList);
    begin
      
      uev := new UserEvent(g.cl_c{$ifdef EventDebug}, $'Wait result'{$endif});
      {$ifdef WaitDebug}
      WaitDebug.RegisterAction(self, $'Created outer with prev_ev=[ {prev_ev.evs?.JoinToString} ], res_ev={uev}');
      {$endif WaitDebug}
      self.gc_hnd := GCHandle.Alloc(self);
      
      // Code of .ThenFinallyWaitFor expects
      // g.curr_err_handler to not change
      // and no new errors to be added
      var err_handler := g.curr_err_handler.TrySkipFunc;
      prev_ev.MultiAttachCallback(()->
      begin
        if (err_handler<>nil) and err_handler.HadError then
        begin
          {$ifdef WaitDebug}
          WaitDebug.RegisterAction(self, $'Aborted');
          {$endif WaitDebug}
          uev.SetComplete(true);
          self.gc_hnd.Free;
        end else
        begin
          {$ifdef WaitDebug}
          WaitDebug.RegisterAction(self, $'Got prev_ev boost');
          {$endif WaitDebug}
          self.IncState;
        end;
      end{$ifdef EventDebug}, $'prev_ev boost for wait handler[{self.GetHashCode}]'{$endif});
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    protected function TryConsume: boolean; abstract;
    
    protected function IncState: boolean;
    begin
      var new_state := Interlocked.Increment(self.state);
      
      {$ifdef DEBUG}
      if not new_state.InRange(1,2) then raise new OpenCLABCInternalException($'WaitHandlerOuter.state={new_state}');
      {$endif DEBUG}
      
      {$ifdef WaitDebug}
      WaitDebug.RegisterAction(self, $'Advanced to state {new_state}');
      {$endif WaitDebug}
      
      Result := (new_state=2) and TryConsume;
      if Result then self.gc_hnd.Free;
    end;
    protected procedure DecState;
    begin
      {$ifdef DEBUG}
      var new_state :=
      {$endif DEBUG}
      Interlocked.Decrement(self.state);
      
      {$ifdef DEBUG}
      if not new_state.InRange(0,1) then
        raise new OpenCLABCInternalException($'WaitHandlerOuter.state={new_state}');
      
      {$ifdef WaitDebug}
      WaitDebug.RegisterAction(self, $'Gone back to state {new_state}');
      {$endif WaitDebug}
      
      {$endif DEBUG}
      
    end;
    
  end;
  
{$endregion Outer}

{$region Direct}

type
  IWaitHandlerSub = interface
    
    // Возвращает true, если активацию успешно съели
    function HandleChildInc(data: integer): boolean;
    procedure HandleChildDec(data: integer);
    
  end;
  
  WaitHandlerDirectSubInfo = class
    public threshold, data: integer;
    public state := new InterlockedBoolean;
    public constructor(threshold, data: integer);
    begin
      self.threshold := threshold;
      self.data := data;
    end;
    public constructor := raise new OpenCLABCInternalException;
  end;
  /// Напрямую хранит активации конкретного CLTaskGlobalData
  WaitHandlerDirect = sealed class
    private subs := new ConcurrentDictionary<IWaitHandlerSub, WaitHandlerDirectSubInfo>;
    private activations := 0;
    private reserved := 0;
    
    public procedure Subscribe(sub: IWaitHandlerSub; info: WaitHandlerDirectSubInfo);
    begin
      
      {$ifdef WaitDebug}
      WaitDebug.RegisterAction(self, $'Got new sub {sub.GetHashCode}');
      {$endif WaitDebug}
      
      if not subs.TryAdd(sub, info) then
      begin
        {$ifdef DEBUG}
        raise new OpenCLABCInternalException($'Sub added twice');
        {$endif DEBUG}
      end else
      if activations>=info.threshold then
        if info.state.TrySet(true) then
        begin
          {$ifdef WaitDebug}
          WaitDebug.RegisterAction(self, $'Add immidiatly inced sub {sub.GetHashCode}');
          {$endif WaitDebug}
          // Может выполняться одновременно с AddActivation, в таком случае 
          sub.HandleChildInc(info.data);
        end;
    end;
    
    public procedure AddActivation;
    begin
      {$ifdef WaitDebug}
      var new_act :=
      {$endif WaitDebug}
      Interlocked.Increment(activations);
      {$ifdef WaitDebug}
      WaitDebug.RegisterAction(self, $'Got activation =>{new_act}');
      {$endif WaitDebug}
      
      foreach var kvp in subs do
        // activations может изменится, если .HandleChildInc из
        // .AddActivation другого хэндлера или .Subscribe затронет self.activations
        // Поэтому результат Interlocked.Increment использовать нельзя
        if activations>=kvp.Value.threshold then
          if kvp.Value.state.TrySet(true) and kvp.Key.HandleChildInc(kvp.Value.data) then
          begin
            {$ifdef WaitDebug}
            WaitDebug.RegisterAction(self, $'Sub {kvp.Key.GetHashCode} consumed activation =>{activations}');
            {$endif WaitDebug}
            // Если активацию съели - нет смысла продолжать
            break;
          end;
    end;
    
    public function TryReserve(c: integer): boolean;
    begin
      var n_reserved := Interlocked.Add(reserved, c);
      Result := n_reserved<=activations;
      
      {$ifdef WaitDebug}
      WaitDebug.RegisterAction(self, $'Tried to reserve {c}=>{n_reserved}: {Result}');
      {$endif WaitDebug}
      
      // Надо делать там, где было вызвано TryReserve
      // Потому что TryReserve не последняя проверка, есть ещё uev.SetComplete
//      if not Result then ReleaseReserve(c);
    end;
    public procedure ReleaseReserve(c: integer) :=
    if Interlocked.Add(reserved, -c)<0 then
    begin
      {$ifdef DEBUG}
      raise new OpenCLABCInternalException($'reserved={reserved}');
      {$endif DEBUG}
    end else
    begin
      {$ifdef WaitDebug}
      WaitDebug.RegisterAction(self, $'Released reserve {c}=>{reserved}');
      {$endif WaitDebug}
    end;
    
    public procedure Comsume(c: integer);
    begin
      {$ifdef DEBUG}var new_act:={$endif} Interlocked.Add(activations, -c);
      {$ifdef DEBUG}var new_res:={$endif} Interlocked.Add(reserved, -c);
      {$ifdef DEBUG}
      if (new_act<0) or (new_res<0) then
        raise new OpenCLABCInternalException($'new_act={new_act}, new_res={new_res}');
      {$endif DEBUG}
      
      {$ifdef WaitDebug}
      WaitDebug.RegisterAction(self, $'Sub consumed {c}, new_act={new_act}, new_res={new_res}');
      {$endif WaitDebug}
      
      foreach var kvp in subs do
        if activations<kvp.Value.threshold then
          if kvp.Value.state.TrySet(false) then
            kvp.Key.HandleChildDec(kvp.Value.data);
    end;
    
  end;
  /// Обёртка WaitHandlerDirect, которая является WaitHandlerOuter
  WaitHandlerDirectWrap = sealed class(WaitHandlerOuter, IWaitHandlerSub)
    private source: WaitHandlerDirect;
    
    public constructor(g: CLTaskGlobalData; prev_ev: EventList; source: WaitHandlerDirect);
    begin
      inherited Create(g, prev_ev);
      {$ifdef WaitDebug}
      WaitDebug.RegisterAction(self, $'This is DirectWrap for {source.GetHashCode}');
      {$endif WaitDebug}
      self.source := source;
      source.Subscribe(self, new WaitHandlerDirectSubInfo(1,0));
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    //TODO mono#11034
    public function {IWaitHandlerSub.}HandleChildInc(data: integer) := self.IncState;
    public procedure {IWaitHandlerSub.}HandleChildDec(data: integer) := self.DecState;
    
    protected function TryConsume: boolean; override;
    begin
      Result := source.TryReserve(1) and self.uev.SetComplete(false);
      if not Result then source.ReleaseReserve(1);
      
      {$ifdef WaitDebug}
      WaitDebug.RegisterAction(self, $'Tried reserving {1} in source[{source.GetHashCode}]: {Result}');
      {$endif WaitDebug}
      
      if Result then source.Comsume(1);
    end;
    
  end;
  
  /// Маркер, не ссылающийся на другие маркеры
  WaitMarkerDirect = abstract class(WaitMarker)
    private handlers := new ConcurrentDictionary<CLTaskGlobalData, WaitHandlerDirect>;
    
    public procedure InitInnerHandles(g: CLTaskGlobalData); override :=
    handlers.GetOrAdd(g, g->
    begin
      Result := new WaitHandlerDirect;
      {$ifdef WaitDebug}
      WaitDebug.RegisterAction(Result, $'Created for {TypeName(self)}[{self.GetHashCode}]');
      {$endif WaitDebug}
    end);
    
    public function MakeWaitEv(g: CLTaskGlobalData; prev_ev: EventList): EventList; override :=
    WaitHandlerDirectWrap.Create(g, prev_ev, handlers[g]).uev;
    
    public procedure SendSignal; override :=
    foreach var h in handlers.Values do
      h.AddActivation;
    
  end;
  
{$endregion Direct}

{$region Combination}

{$region Base}

type
  WaitMarkerCombination<TChild> = abstract class(WaitMarker)
  where TChild: WaitMarker;
    private children: array of TChild;
    
    public constructor(children: array of TChild) := self.children := children;
    public constructor := raise new OpenCLABCInternalException;
    
    public procedure InitInnerHandles(g: CLTaskGlobalData); override :=
    foreach var child in children do child.InitInnerHandles(g);
    
    {$region Disabled override's}
    
    private function ConvertToQBase: CommandQueueBase; override;
    begin
      Result := nil;
      raise new System.InvalidProgramException($'Преобразовывать комбинацию маркеров в очередь нельзя. Возможно вы забыли написать WaitFor?');
    end;
    
    public procedure SendSignal; override :=
    raise new System.InvalidProgramException($'%Err:WaitMarkerCombination.SendSignal%');
    
    {$endregion Disabled override's}
    
  end;
  
{$endregion Base}

{$region All}

type
  WaitHandlerAllInner<TSub> = sealed class(IWaitHandlerSub)
  where TSub: IWaitHandlerSub;
    private sources: array of WaitHandlerDirect;
    private ref_counts: array of integer;
    private done_c := 0;
    
    private sub: TSub;
    private sub_data: integer;
    
    public constructor(sources: array of WaitHandlerDirect; ref_counts: array of integer; sub: TSub; sub_data: integer);
    begin
      {$ifdef WaitDebug}
      WaitDebug.RegisterAction(self, $'Created AllInner for: {sources.Select(s->s.GetHashCode).JoinToString}');
      {$endif WaitDebug}
      self.sources := sources;
      for var i := 0 to sources.Length-1 do
        sources[i].Subscribe(self, new WaitHandlerDirectSubInfo(ref_counts[i], i));
      self.ref_counts := ref_counts;
      self.sub := sub;
      self.sub_data := sub_data;
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    //TODO mono#11034
    public function {IWaitHandlerSub.}HandleChildInc(data: integer): boolean;
    begin
      var new_done_c := Interlocked.Increment(done_c);
      
      {$ifdef WaitDebug}
      WaitDebug.RegisterAction(self, $'Got activation from {sources[data].GetHashCode}, new_done_c={new_done_c}/{sources.Length}');
      {$endif WaitDebug}
      
      Result := (new_done_c=sources.Length) and sub.HandleChildInc(sub_data);
    end;
    //TODO mono#11034
    public procedure {IWaitHandlerSub.}HandleChildDec(data: integer);
    begin
      var prev_done_c := Interlocked.Decrement(done_c)+1;
      
      {$ifdef WaitDebug}
      WaitDebug.RegisterAction(self, $'Got deactivation from {sources[data].GetHashCode}, new_done_c={prev_done_c-1}/{sources.Length}');
      {$endif WaitDebug}
      
      if prev_done_c=sources.Length then sub.HandleChildDec(sub_data);
    end;
    
    public function TryConsume(uev: UserEvent): boolean;
    begin
      {$ifdef WaitDebug}
      WaitDebug.RegisterAction(self, $'Trying to reserve');
      {$endif WaitDebug}
      Result := false;
      for var i := 0 to sources.Length-1 do
      begin
        if sources[i].TryReserve(ref_counts[i]) then continue;
        for var prev_i := 0 to i do
          sources[i].ReleaseReserve(ref_counts[i]);
        exit;
      end;
      Result := uev.SetComplete(false);
      if Result then
      begin
        {$ifdef WaitDebug}
        WaitDebug.RegisterAction(self, $'Consuming');
        {$endif WaitDebug}
        for var i := 0 to sources.Length-1 do
          sources[i].Comsume(ref_counts[i]);
      end else
      begin
        {$ifdef WaitDebug}
        WaitDebug.RegisterAction(self, $'Abort consume');
        {$endif WaitDebug}
        for var i := 0 to sources.Length-1 do
          sources[i].ReleaseReserve(ref_counts[i]);
      end;
    end;
    
  end;
  WaitHandlerAllOuter = sealed class(WaitHandlerOuter, IWaitHandlerSub)
    private sources: array of WaitHandlerDirect;
    private ref_counts: array of integer;
    private done_c := 0;
    
    public constructor(g: CLTaskGlobalData; prev_ev: EventList; sources: array of WaitHandlerDirect; ref_counts: array of integer);
    begin
      inherited Create(g, prev_ev);
      {$ifdef WaitDebug}
      WaitDebug.RegisterAction(self, $'This is AllOuter for: {sources.Select(s->s.GetHashCode).JoinToString}');
      {$endif WaitDebug}
      self.sources := sources;
      for var i := 0 to sources.Length-1 do
        sources[i].Subscribe(self, new WaitHandlerDirectSubInfo(ref_counts[i], i));
      self.ref_counts := ref_counts;
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    //TODO mono#11034
    public function {IWaitHandlerSub.}HandleChildInc(data: integer): boolean;
    begin
      var new_done_c := Interlocked.Increment(done_c);
      
      {$ifdef WaitDebug}
      WaitDebug.RegisterAction(self, $'Got activation from {sources[data].GetHashCode}, new_done_c={new_done_c}/{sources.Length}');
      {$endif WaitDebug}
      
      Result := (new_done_c=sources.Length) and self.IncState;
    end;
    //TODO mono#11034
    public procedure {IWaitHandlerSub.}HandleChildDec(data: integer);
    begin
      var prev_done_c := Interlocked.Decrement(done_c)+1;
      
      {$ifdef WaitDebug}
      WaitDebug.RegisterAction(self, $'Got deactivation from {sources[data].GetHashCode}, new_done_c={prev_done_c-1}/{sources.Length}');
      {$endif WaitDebug}
      
      if prev_done_c=sources.Length then self.DecState;
    end;
    
    protected function TryConsume: boolean; override;
    begin
      {$ifdef WaitDebug}
      WaitDebug.RegisterAction(self, $'Trying to reserve');
      {$endif WaitDebug}
      Result := false;
      for var i := 0 to sources.Length-1 do
      begin
        if sources[i].TryReserve(ref_counts[i]) then continue;
        for var prev_i := 0 to i do
          sources[i].ReleaseReserve(ref_counts[i]);
        exit;
      end;
      Result := uev.SetComplete(false);
      if Result then
      begin
        {$ifdef WaitDebug}
        WaitDebug.RegisterAction(self, $'Consuming');
        {$endif WaitDebug}
        for var i := 0 to sources.Length-1 do
          sources[i].Comsume(ref_counts[i]);
      end else
      begin
        {$ifdef WaitDebug}
        WaitDebug.RegisterAction(self, $'Abort consume');
        {$endif WaitDebug}
        for var i := 0 to sources.Length-1 do
          sources[i].ReleaseReserve(ref_counts[i]);
      end;
    end;
    
  end;
  
  WaitMarkerAll = sealed partial class(WaitMarkerCombination<WaitMarkerDirect>)
    private ref_counts: array of integer;
    
    public constructor(children: Dictionary<WaitMarkerDirect, integer>);
    begin
      inherited Create(children.Keys.ToArray);
      self.ref_counts := self.children.ConvertAll(key->children[key]);
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      // Конфликт с System.Range, но воспроизводится только из под mono
      foreach var i in PABCSystem.Range(0,children.Length-1).OrderByDescending(i->ref_counts[i]) do
      begin
        children[i].ToString(sb, tabs, index, delayed);
        if ref_counts[i]<>1 then
        begin
          sb.Length -= 1;
          sb += ' * ';
          sb.Append(ref_counts[i]);
          sb += #10;
        end;
      end;
    end;
    
    public function MakeWaitEv(g: CLTaskGlobalData; prev_ev: EventList): EventList; override :=
    WaitHandlerAllOuter.Create(g, prev_ev, children.ConvertAll(m->m.handlers[g]), ref_counts).uev;
    
    private function GetChildrenArr: array of WaitMarkerDirect;
    begin
      Result := new WaitMarkerDirect[ref_counts.Sum];
      var res_ind := 0;
      for var i := 0 to children.Length-1 do
        loop ref_counts[i] do
        begin
          Result[res_ind] := children[i];
          res_ind += 1;
        end;
    end;
    
  end;
  
{$endregion All}

{$region Any}

type
  WaitHandlerAnyOuter = sealed class(WaitHandlerOuter, IWaitHandlerSub)
    private sources: array of WaitHandlerAllInner<WaitHandlerAnyOuter>;
    
    private done_c := 0;
    
    public constructor(g: CLTaskGlobalData; prev_ev: EventList; markers: array of WaitMarkerAll);
    begin
      inherited Create(g, prev_ev);
      self.sources := new WaitHandlerAllInner<WaitHandlerAnyOuter>[markers.Length];
      for var i := 0 to markers.Length-1 do
        self.sources[i] := new WaitHandlerAllInner<WaitHandlerAnyOuter>(markers[i].children.ConvertAll(m->m.handlers[g]), markers[i].ref_counts, self, i);
      {$ifdef WaitDebug}
      WaitDebug.RegisterAction(self, $'This is AnyOuter for: {sources.Select(s->s.GetHashCode).JoinToString}');
      {$endif WaitDebug}
    end;
    public constructor := raise new OpenCLABCInternalException;
    
    //TODO mono#11034
    public function {IWaitHandlerSub.}HandleChildInc(data: integer): boolean;
    begin
      var new_done_c := Interlocked.Increment(done_c);
      
      {$ifdef WaitDebug}
      WaitDebug.RegisterAction(self, $'Got activation from {sources[data].GetHashCode}, new_done_c={new_done_c}/{sources.Length}');
      {$endif WaitDebug}
      
      Result := (new_done_c=1) and self.IncState;
    end;
    //TODO mono#11034
    public procedure {IWaitHandlerSub.}HandleChildDec(data: integer);
    begin
      var prev_done_c := Interlocked.Decrement(done_c)+1;
      
      {$ifdef WaitDebug}
      WaitDebug.RegisterAction(self, $'Got deactivation from {sources[data].GetHashCode}, new_done_c={prev_done_c-1}/{sources.Length}');
      {$endif WaitDebug}
      
      if prev_done_c=1 then self.DecState;
    end;
    
    protected function TryConsume: boolean; override;
    begin
      {$ifdef WaitDebug}
      WaitDebug.RegisterAction(self, $'Trying to consume');
      {$endif WaitDebug}
      Result := false;
      for var i := 0 to sources.Length-1 do
        if sources[i].TryConsume(uev) then
        begin
          Result := true;
          break;
        end;
    end;
    
  end;
  
  WaitMarkerAny = sealed partial class(WaitMarkerCombination<WaitMarkerAll>)
    
    public constructor(sources: array of WaitMarkerAll) := inherited Create(sources);
    private constructor := raise new OpenCLABCInternalException;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      foreach var child in children do
        child.ToString(sb, tabs, index, delayed);
    end;
    
    public function MakeWaitEv(g: CLTaskGlobalData; prev_ev: EventList): EventList; override :=
    WaitHandlerAnyOuter.Create(g, prev_ev, children).uev;
    
  end;
  
{$endregion Any}

{$region public}

type
  WaitMarkerAllFast = sealed class
    private children: Dictionary<WaitMarkerDirect, integer>;
    
    public constructor(c: integer) :=
    children := new Dictionary<WaitMarkerDirect, integer>(c);
    public constructor(m: WaitMarkerDirect);
    begin
      Create(1);
      self.children.Add(m, 1);
    end;
    public constructor(m: WaitMarkerAll);
    begin
      Create(m.children.Length);
      for var i := 0 to m.children.Length-1 do
        self.children.Add(m.children[i], m.ref_counts[i]);
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    public static function operator in(what, in_what: WaitMarkerAllFast): boolean;
    begin
      Result := false;
      
      if what.children.Count>in_what.children.Count then
        exit;
      foreach var kvp in what.children do
        if in_what.children.Get(kvp.Key) < kvp.Value then
          exit;
      
      Result := true;
    end;
    
    public static function operator+(c1, c2: WaitMarkerAllFast): WaitMarkerAllFast;
    begin
      Result := new WaitMarkerAllFast(c1.children.Count+c2.children.Count);
      foreach var kvp in c1.children do
        Result.children.Add(kvp.Key, kvp.Value);
      foreach var kvp in c2.children do
        Result.children[kvp.Key] := Result.children.Get(kvp.Key) + kvp.Value;
    end;
    
    public static procedure TryAdd(lst: List<WaitMarkerAllFast>; c: WaitMarkerAllFast);
    begin
      
      for var i := 0 to lst.Count-1 do
      begin
        var c0 := lst[i];
        
        if c0 in c then
          lst[i] := c else
        if c in c0 then
          {nothing} else
          continue;
        
        exit;
      end;
      
      lst += c;
    end;
    
    public static function MarkerFromLst(lst: IList<WaitMarkerAllFast>): WaitMarker;
    begin
      if lst.Count>1 then
      begin
        var res := new WaitMarkerAll[lst.Count];
        for var i := 0 to res.Length-1 do
          res[i] := new WaitMarkerAll(lst[i].children);
        Result := new WaitMarkerAny(res);
      end else
      case lst[0].children.Values.Sum of
        0: raise new System.ArgumentException($'Количество комбинируемых маркеров должно быть положительным');
        1: Result := lst[0].children.Keys.Single;
        else Result := new WaitMarkerAll(lst[0].children);
      end;
    end;
    
  end;
  
function CombineWaitAll(sub_markers: sequence of WaitMarker): WaitMarker;
begin
  var prev := |new WaitMarkerAllFast(0)| as IList<WaitMarkerAllFast>;
  var next := new List<WaitMarkerAllFast>;
  
  foreach var m in sub_markers do
  begin
    
    if m is WaitMarkerAny(var ma) then
    begin
      foreach var child in ma.children do
      begin
        var c2 := new WaitMarkerAllFast(child);
        foreach var c1 in prev do
          WaitMarkerAllFast.TryAdd(next, c1+c2);
      end;
    end else
    begin
      var c2 := if m is WaitMarkerDirect(var md) then
        new WaitMarkerAllFast(md) else
        new WaitMarkerAllFast(WaitMarkerAll(m));
      foreach var c1 in prev do
        next += c1+c2;
    end;
    
    prev := next.ToArray;
    next.Clear;
  end;
  
  Result := WaitMarkerAllFast.MarkerFromLst(prev);
end;
function CombineWaitAll(params sub_markers: array of WaitMarker) := CombineWaitAll(sub_markers.AsEnumerable);

function CombineWaitAny(sub_markers: sequence of WaitMarker): WaitMarker;
begin
  var res := new List<WaitMarkerAllFast>;
  foreach var m in sub_markers do
    if m is WaitMarkerAny(var ma) then
    begin
      foreach var child in ma.children do
        WaitMarkerAllFast.TryAdd(res, new WaitMarkerAllFast(child));
    end else
    begin
      var c := if m is WaitMarkerDirect(var md) then
        new WaitMarkerAllFast(md) else
        new WaitMarkerAllFast(WaitMarkerAll(m));
      WaitMarkerAllFast.TryAdd(res, c);
    end;
  Result := WaitMarkerAllFast.MarkerFromLst(res);
end;
function CombineWaitAny(params sub_markers: array of WaitMarker) := CombineWaitAny(sub_markers.AsEnumerable);

static function WaitMarker.operator and(m1, m2: WaitMarker) := CombineWaitAll(|m1, m2|);
static function WaitMarker.operator or(m1, m2: WaitMarker) := CombineWaitAny(|m1, m2|);

{$endregion public}

{$endregion Combination}

{$endregion Def}

{$region WaitMarkerDummy}

type
  WaitMarkerDummyExecutor = sealed class(CommandQueueNil)
    private m: WaitMarkerDirect;
    
    public constructor(m: WaitMarkerDirect) := self.m := m;
    private constructor := raise new OpenCLABCInternalException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_mu: HashSet<IMultiusableCommandQueue>); override := exit;
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil; override;
    begin
      Result := new QueueResNil(l);
      var err_handler := g.curr_err_handler.TrySkipFunc;
      
      if Result.ShouldInstaCallAction then
      begin
        if (err_handler=nil) or not err_handler.HadError then
          m.SendSignal;
      end else
      if err_handler=nil then
        Result.AddAction(c->m.SendSignal()) else
      begin
        var l_err_handler := err_handler;
        Result.AddAction(c->if not l_err_handler.HadError then m.SendSignal);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      m.ToString(sb, tabs, index, delayed);
    end;
    
  end;
  
  WaitMarkerDummy = sealed class(WaitMarkerDirect)
    private executor: WaitMarkerDummyExecutor;
    public constructor := executor := new WaitMarkerDummyExecutor(self);
    
    private function ConvertToQBase: CommandQueueBase; override := executor;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override := sb += #10;
    
  end;
  
static function WaitMarker.Create := new WaitMarkerDummy;

{$endregion WaitMarkerDummy}

{$region ThenMarkerSignal}

type
  CommandQueueMarkedCapWrapper<TQ> = sealed class(WaitMarkerDirect)
  where TQ: CommandQueueBase;
    protected org: TQ;
    
    public constructor(org: TQ) := self.org := org;
    private constructor := raise new OpenCLABCInternalException;
    
    private function ConvertToQBase: CommandQueueBase; override := org;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      org.ToStringHeader(sb, index);
      sb += #10;
      
    end;
    
  end;
  
  CommandQueueMarkedCapCommon<TQ> = record
  where TQ: CommandQueueBase;
    public q: TQ;
    public wrap: CommandQueueMarkedCapWrapper<TQ>;
    public signal_in_finally: boolean;
    
    public procedure Init(q: TQ; wrap: CommandQueueMarkedCapWrapper<TQ>; signal_in_finally: boolean);
    begin
      self.q := q;
      self.wrap := wrap;
      self.signal_in_finally := signal_in_finally;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_mu: HashSet<IMultiusableCommandQueue>) := q.InitBeforeInvoke(g, inited_mu);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke<TR>(prev_qr: TR; err_handler: ErrHandler): TR; where TR: IQueueRes;
    begin
      var just_send_it := signal_in_finally or (err_handler=nil);
      if prev_qr.ShouldInstaCallAction then
      begin
        if just_send_it or not err_handler.HadError then
          wrap.SendSignal;
      end else
      if just_send_it then
        prev_qr.AddAction(c->wrap.SendSignal()) else
      begin
        var l_err_handler := err_handler;
        prev_qr.AddAction(c->if not l_err_handler.HadError then wrap.SendSignal);
      end;
      Result := prev_qr;
    end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; invoke_q: CommandQueueInvoker<TR>): TR; where TR: IQueueRes;
    begin
      Result := Invoke(invoke_q(g,l), g.curr_err_handler.TrySkipFunc);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    procedure ToString(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>);
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      wrap.ToStringHeader(sb, index);
      sb += #10;
      
      q.ToString(sb, tabs, index, delayed);
    end;
    
  end;
  
  CommandQueueMarkedCapNil = sealed partial class(CommandQueueNil)
    data: CommandQueueMarkedCapCommon<CommandQueueNil>;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_mu: HashSet<IMultiusableCommandQueue>); override := data.InitBeforeInvoke(g, inited_mu);
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil; override :=
      data.Invoke(data.q.InvokeToNil(g,l), g.curr_err_handler.TrySkipFunc);
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
  CommandQueueMarkedCap<T> = sealed partial class(CommandQueue<T>)
    data: CommandQueueMarkedCapCommon<CommandQueue<T>>;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_mu: HashSet<IMultiusableCommandQueue>); override := data.InitBeforeInvoke(g, inited_mu);
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil;    override := data.Invoke(g, l, data.q.InvokeToNil);
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes   <T>; override := data.Invoke(g, l, data.q.InvokeToAny);
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<T>; override := data.Invoke(g, l, data.q.InvokeToPtr);
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
function CommandQueueMarkedCapNil.get_signal_in_finally := data.signal_in_finally;
function CommandQueueMarkedCap<T>.get_signal_in_finally := data.signal_in_finally;

constructor CommandQueueMarkedCapNil.Create(q: CommandQueueNil; signal_in_finally: boolean);
begin
  data.Init(q, new CommandQueueMarkedCapWrapper<CommandQueueNil>(self), signal_in_finally);
end;
constructor CommandQueueMarkedCap<T>.Create(q: CommandQueue<T>; signal_in_finally: boolean);
begin
  data.Init(q, new CommandQueueMarkedCapWrapper<CommandQueue<T>>(self), signal_in_finally);
  self.const_res_dep      := q.const_res_dep;
  self.expected_const_res := q.expected_const_res;
end;

static function CommandQueueMarkedCapNil.operator implicit(dms: CommandQueueMarkedCapNil) := dms.data.wrap;
static function CommandQueueMarkedCap<T>.operator implicit(dms: CommandQueueMarkedCap<T>) := dms.data.wrap;

{$endregion ThenMarkerSignal}

{$region WaitFor}

type
  CommandQueueWaitFor = sealed class(CommandQueueNil)
    public marker: WaitMarker;
    public constructor(marker: WaitMarker) := self.marker := marker;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_mu: HashSet<IMultiusableCommandQueue>); override :=
    marker.InitInnerHandles(g);
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil; override :=
    new QueueResNil( marker.MakeWaitEv(g,l) );
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      marker.ToString(sb, tabs, index, delayed);
    end;
    
  end;
  
function WaitFor(marker: WaitMarker) := new CommandQueueWaitFor(marker);

{$endregion WaitFor}

{$region ThenWaitFor}

type
  CommandQueueThenBaseWaitFor<T> = abstract class(CommandQueue<T>)
    public q: CommandQueue<T>;
    public marker: WaitMarker;
    
    public constructor(q: CommandQueue<T>; marker: WaitMarker);
    begin
      self.q := q;
      self.marker := marker;
      self.const_res_dep      := q.const_res_dep;
      self.expected_const_res := q.expected_const_res;
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_mu: HashSet<IMultiusableCommandQueue>); override;
    begin
      q.InitBeforeInvoke(g, inited_mu);
      marker.InitInnerHandles(g);
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      q.ToString(sb, tabs, index, delayed);
      marker.ToString(sb, tabs, index, delayed);
    end;
    
  end;
  
  CommandQueueThenWaitFor<T> = sealed class(CommandQueueThenBaseWaitFor<T>)
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; invoke_q: CommandQueueInvoker<TR>): TR; where TR: IQueueRes;
    begin
      var prev_qr := invoke_q(g, l);
      Result := prev_qr.MakeWrapWith(
        marker.MakeWaitEv(g,
          prev_qr.AttachInvokeActions(g)
        )
      );
    end;
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil;    override := Invoke(g, l, q.InvokeToNil);
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes   <T>; override := Invoke(g, l, q.InvokeToAny);
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<T>; override := Invoke(g, l, q.InvokeToPtr);
    
  end;
  CommandQueueThenFinallyWaitFor<T> = sealed class(CommandQueueThenBaseWaitFor<T>)
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; invoke_q: CommandQueueInvoker<TR>): TR; where TR: IQueueRes;
    begin
      
      var pre_q_err_handler := g.curr_err_handler;
      var prev_qr := invoke_q(g, l);
      var post_q_err_handler := g.curr_err_handler;
      
      g.curr_err_handler := pre_q_err_handler;
      var res_ev := marker.MakeWaitEv(g, prev_qr.AttachInvokeActions(g));
      {$ifdef DEBUG}
      if g.curr_err_handler <> pre_q_err_handler then
        raise new OpenCLABCInternalException($'MakeWaitEv should not change g.curr_err_handler');
      // Otherwise, ErrHandlerBranchBud (like in >=) would be needed
      {$endif DEBUG}
      g.curr_err_handler := post_q_err_handler;
      
      Result := prev_qr.MakeWrapWith(res_ev);
    end;
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil;    override := Invoke(g, l, q.InvokeToNil);
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes   <T>; override := Invoke(g, l, q.InvokeToAny);
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<T>; override := Invoke(g, l, q.InvokeToPtr);
    
  end;
  
function CommandQueue<T>.ThenWaitFor(marker: WaitMarker) := new CommandQueueThenWaitFor<T>(self, marker);
function CommandQueue<T>.ThenFinallyWaitFor(marker: WaitMarker) := new CommandQueueThenFinallyWaitFor<T>(self, marker);

{$endregion ThenWaitFor}

{$endregion Wait}

{$region Finally}

type
  CommandQueueTryFinallyCommon<TQ> = record
  where TQ: CommandQueueBase;
    public try_do: CommandQueueBase;
    public do_finally: TQ;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_mu: HashSet<IMultiusableCommandQueue>);
    begin
      try_do.InitBeforeInvoke(g, inited_mu);
      do_finally.InitBeforeInvoke(g, inited_mu);
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; invoke_finally: CommandQueueInvoker<TR>{$ifdef DEBUG}; q: CommandQueueBase{$endif}): TR; where TR: IQueueRes;
    begin
      var origin_err_handler := g.curr_err_handler;
      var branch_handlers := new List<ErrHandler>(2);
      
      {$region try_do}
      
      g.curr_err_handler := ErrHandlerBranchBud.Wrap(origin_err_handler{$ifdef DEBUG}, $'{TypeName(q)}: try_do'{$endif});
      {$ifdef DEBUG}
      var initial_try_handler := g.curr_err_handler;
      {$endif DEBUG}
      l := try_do.InvokeToNil(g, l).base;
      var try_handler := g.curr_err_handler.ForceSkipFunc({$ifdef DEBUG}initial_try_handler{$endif});
      if try_handler<>nil then branch_handlers += try_handler;
      
      {$endregion try_do}
      
      {$region do_finally}
      
      g.curr_err_handler := ErrHandlerBranchBud.Wrap(origin_err_handler{$ifdef DEBUG}, $'{TypeName(q)}: do_finally'{$endif});
      {$ifdef DEBUG}
      var initial_finally_handler := g.curr_err_handler;
      {$endif DEBUG}
      Result := invoke_finally(g, l);
      var finally_handler := g.curr_err_handler.ForceSkipFunc({$ifdef DEBUG}initial_finally_handler{$endif});
      if finally_handler<>nil then branch_handlers += finally_handler;
      
      {$endregion do_finally}
      
      g.curr_err_handler := ErrHandlerBranchCombinator.Wrap(
        origin_err_handler, branch_handlers.ToArray
        {$ifdef DEBUG}, $'{TypeName(self)} origin+try+finally union'{$endif}
      );
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    procedure ToString(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>);
    begin
      sb += #10;
      try_do.ToString(sb, tabs, index, delayed);
      do_finally.ToString(sb, tabs, index, delayed);
    end;
    
  end;
  
  CommandQueueTryFinallyNil = sealed class(CommandQueueNil)
    private data := new CommandQueueTryFinallyCommon< CommandQueueNil >;
    
    private constructor(try_do: CommandQueueBase; do_finally: CommandQueueNil);
    begin
      data.try_do := try_do;
      data.do_finally := do_finally;
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_mu: HashSet<IMultiusableCommandQueue>); override :=
    data.InitBeforeInvoke(g, inited_mu);
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil; override := data.Invoke(g, l, data.do_finally.InvokeToNil{$ifdef DEBUG}, self{$endif});
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  CommandQueueTryFinally<T> = sealed class(CommandQueue<T>)
    private data := new CommandQueueTryFinallyCommon< CommandQueue<T> >;
    
    private constructor(try_do: CommandQueueBase; do_finally: CommandQueue<T>);
    begin
      data.try_do := try_do;
      data.do_finally := do_finally;
      self.const_res_dep      := do_finally.const_res_dep;
      self.expected_const_res := do_finally.expected_const_res;
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_mu: HashSet<IMultiusableCommandQueue>); override :=
    data.InitBeforeInvoke(g, inited_mu);
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil;    override := data.Invoke(g, l, data.do_finally.InvokeToNil{$ifdef DEBUG}, self{$endif});
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes   <T>; override := data.Invoke(g, l, data.do_finally.InvokeToAny{$ifdef DEBUG}, self{$endif});
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<T>; override := data.Invoke(g, l, data.do_finally.InvokeToPtr{$ifdef DEBUG}, self{$endif});
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
  CommandQueueTryFinallyConstructor = sealed auto class(ITypedCQConverter<CommandQueueBase>)
    private try_do: CommandQueueBase;
    
    public function ConvertNil(do_finally: CommandQueueNil): CommandQueueBase :=
    new CommandQueueTryFinallyNil(try_do, do_finally);
    public function Convert<T>(do_finally: CommandQueue<T>): CommandQueueBase :=
    new CommandQueueTryFinally<T>(try_do, do_finally);
    
  end;
  
function operator>=<TQ>(try_do: CommandQueueBase; do_finally: TQ): TQ; extensionmethod; where TQ: CommandQueueBase;
begin
  Result := TQ(do_finally.ConvertTyped(
    new CommandQueueTryFinallyConstructor(try_do)
  ));
end;

function operator>=(q: CommandQueueBase; m: WaitMarker); extensionmethod := q >= CommandQueueBase(m);

{$endregion Finally}

{$region Handle}

type
  
  CommandQueueHandleWithoutRes = sealed class(CommandQueueNil)
    private try_do: CommandQueueBase;
    private handler: Exception->boolean;
    
    public constructor(try_do: CommandQueueBase; handler: Exception->boolean);
    begin
      self.try_do := try_do;
      self.handler := handler;
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_mu: HashSet<IMultiusableCommandQueue>); override :=
    try_do.InitBeforeInvoke(g, inited_mu);
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    procedure ApplyTo(err_handler: ErrHandler{$ifdef DEBUG}; err_test_reason: string{$endif});
    begin
      try
        err_handler.TryRemoveErrors(self.handler);
      except
        on e: Exception do err_handler.AddErr(e{$ifdef DEBUG}, err_test_reason{$endif});
      end;
      {$ifdef DEBUG}
      err_handler.EndMaybeError(err_test_reason);
      {$endif DEBUG}
    end;
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil; override;
    begin
      var origin_err_handler := g.curr_err_handler;
      
      g.curr_err_handler := ErrHandlerBranchBud.Wrap(origin_err_handler{$ifdef DEBUG}, $'{TypeName(self)}: try_do'{$endif});
      Result := try_do.InvokeToNil(g, l);
      var try_err_handler := g.curr_err_handler.TrySkipFunc;
      
      {$ifdef DEBUG}
      var err_test_reason := $'[{self.GetHashCode}]:{TypeName(self)}.Apply';
      try_err_handler.AddMaybeError(err_test_reason);
      {$endif DEBUG}
      if Result.ShouldInstaCallAction then
        self.ApplyTo(try_err_handler{$ifdef DEBUG}, err_test_reason{$endif}) else
        Result.AddAction(c->self.ApplyTo(try_err_handler{$ifdef DEBUG}, err_test_reason{$endif}));
      
      g.curr_err_handler := ErrHandlerBranchCombinator.Wrap(
        origin_err_handler, try_err_handler
        {$ifdef DEBUG}, $'{TypeName(self)} origin+try union'{$endif}
      );
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      try_do.ToString(sb, tabs, index, delayed);
      
      sb.Append(#9, tabs);
      ToStringWriteDelegate(sb, handler);
      sb += #10;
      
    end;
    
  end;
  
  CommandQueueHandleWithoutResConstructor = record(ITypedCQConverter<CommandQueueNil>)
    
    function ConvertNil(cq: CommandQueueNil): CommandQueueNil :=
    if cq is ConstQueueNil then cq else nil;
    function Convert<T>(cq: CommandQueue<T>): CommandQueueNil :=
    if (cq is ConstQueue<T>) or (cq is ParameterQueue<T>) then CQNil else nil;
    
  end;
  
function CommandQueueBase.HandleWithoutRes(handler: Exception->boolean) :=
self.ConvertTyped(new CommandQueueHandleWithoutResConstructor) ??
new CommandQueueHandleWithoutRes(self, handler);

type
  CommandQueueHandleDefaultRes<T> = sealed class(CommandQueue<T>)
    private try_do: CommandQueue<T>;
    private handler: Exception->boolean;
    private def: T;
    
    public constructor(try_do: CommandQueue<T>; handler: Exception->boolean; def: T);
    begin
      self.try_do := try_do;
      self.handler := handler;
      self.def := def;
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_mu: HashSet<IMultiusableCommandQueue>); override :=
    try_do.InitBeforeInvoke(g, inited_mu);
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    procedure ApplyTo(err_handler: ErrHandler{$ifdef DEBUG}; err_test_reason: string{$endif});
    begin
      try
        err_handler.TryRemoveErrors(self.handler);
      except
        on e: Exception do err_handler.AddErr(e{$ifdef DEBUG}, err_test_reason{$endif});
      end;
      {$ifdef DEBUG}
      err_handler.EndMaybeError(err_test_reason);
      {$endif DEBUG}
    end;
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil; override;
    begin
      var origin_err_handler := g.curr_err_handler;
      
      g.curr_err_handler := ErrHandlerBranchBud.Wrap(origin_err_handler{$ifdef DEBUG}, $'{TypeName(self)}: try_do'{$endif});
      Result := try_do.InvokeToNil(g, l);
      var try_err_handler := g.curr_err_handler.TrySkipFunc;
      
      {$ifdef DEBUG}
      var err_test_reason := $'[{self.GetHashCode}]:{TypeName(self)}.Apply';
      try_err_handler.AddMaybeError(err_test_reason);
      {$endif DEBUG}
      if Result.ShouldInstaCallAction then
        self.ApplyTo(try_err_handler{$ifdef DEBUG}, err_test_reason{$endif}) else
        Result.AddAction(c->self.ApplyTo(try_err_handler{$ifdef DEBUG}, err_test_reason{$endif}));
      
      g.curr_err_handler := ErrHandlerBranchCombinator.Wrap(
        origin_err_handler, try_err_handler
        {$ifdef DEBUG}, $'{TypeName(self)} origin+try union'{$endif}
      );
    end;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; qr_factory: IQueueResFactory<T,TR>): TR; where TR: QueueRes<T>;
    begin
      var origin_err_handler := g.curr_err_handler;
      
      g.curr_err_handler := ErrHandlerBranchBud.Wrap(origin_err_handler{$ifdef DEBUG}, $'{TypeName(self)}: try_do'{$endif});
      var prev_qr := try_do.InvokeToAny(g, l);
      var try_err_handler := g.curr_err_handler.TrySkipFunc;
      
      {$ifdef DEBUG}
      var err_test_reason := $'[{self.GetHashCode}]:{TypeName(self)}.Apply';
      try_err_handler.AddMaybeError(err_test_reason);
      {$endif DEBUG}
      Result := prev_qr.TransformResult(qr_factory, true, prev_res->
      begin
        if not try_err_handler.HadError then
        begin
          Result := prev_res;
          {$ifdef DEBUG}
          try_err_handler.EndMaybeError(err_test_reason);
          {$endif DEBUG}
        end else
        begin
          self.ApplyTo(try_err_handler{$ifdef DEBUG}, err_test_reason{$endif});
          Result := self.def;
        end;
      end);
      
      g.curr_err_handler := ErrHandlerBranchCombinator.Wrap(
        origin_err_handler, try_err_handler
        {$ifdef DEBUG}, $'{TypeName(self)} origin+try union'{$endif}
      );
    end;
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes   <T>; override := Invoke(g, l, qr_val_factory);
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<T>; override := Invoke(g, l, qr_ptr_factory);
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += ': ';
      ToStringRuntimeValue(sb, self.def);
      sb += #10;
      
      try_do.ToString(sb, tabs, index, delayed);
      
      sb.Append(#9, tabs);
      ToStringWriteDelegate(sb, handler);
      sb += #10;
      
    end;
    
  end;
  
function CommandQueue<T>.HandleDefaultRes(handler: Exception->boolean; def: T): CommandQueue<T> :=
if (self is ConstQueue<T>) or (self is ParameterQueue<T>) then self else
new CommandQueueHandleDefaultRes<T>(self, handler, def);

type
  CommandQueueHandleReplaceRes<T> = sealed class(CommandQueue<T>)
    private try_do: CommandQueue<T>;
    private handler: List<Exception> -> T;
    
    public constructor(try_do: CommandQueue<T>; handler: List<Exception> -> T);
    begin
      self.try_do := try_do;
      self.handler := handler;
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_mu: HashSet<IMultiusableCommandQueue>); override :=
    try_do.InitBeforeInvoke(g, inited_mu);
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function ApplyTo(err_handler: ErrHandlerThiefBase{$ifdef DEBUG}; err_test_reason: string{$endif}): ValueTuple<boolean,T>;
    begin
      Result.Item1 := err_handler.HadError;
      if Result.Item1 then
      begin
        err_handler.StealPrevErrors;
        try
          Result.Item2 := self.handler(err_handler.AccessErrors);
        except
          on e: Exception do err_handler.AddErr(e{$ifdef DEBUG}, err_test_reason{$endif});
        end;
      end;
      {$ifdef DEBUG}
      err_handler.EndMaybeError(err_test_reason);
      {$endif DEBUG}
    end;
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil; override;
    begin
      var origin_err_handler := g.curr_err_handler;
      
      g.curr_err_handler := ErrHandlerBranchBud.Wrap(origin_err_handler{$ifdef DEBUG}, $'{TypeName(self)}: try_do'{$endif});
      Result := try_do.InvokeToNil(g, l);
      var try_err_handler := g.curr_err_handler.TrySkipFunc;
      if try_err_handler=nil then
      begin
        g.curr_err_handler := origin_err_handler;
        exit;
      end;
      var handle_err_handler := ErrHandlerFlattener.Wrap(try_err_handler{$ifdef DEBUG}, $'{TypeName(self)} wrap'{$endif});
      
      {$ifdef DEBUG}
      var err_test_reason := $'[{self.GetHashCode}]:{TypeName(self)}.Apply';
      handle_err_handler.AddMaybeError(err_test_reason);
      {$endif DEBUG}
      if Result.ShouldInstaCallAction then
        self.ApplyTo(handle_err_handler{$ifdef DEBUG}, err_test_reason{$endif}) else
      begin
        var l_handle_err_handler := handle_err_handler;
        Result.AddAction(c->self.ApplyTo(l_handle_err_handler{$ifdef DEBUG}, err_test_reason{$endif}));
      end;
      
      g.curr_err_handler := ErrHandlerBranchCombinator.Wrap(
        origin_err_handler, handle_err_handler
        {$ifdef DEBUG}, $'{TypeName(self)} origin+handle union'{$endif}
      );
    end;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; qr_factory: IQueueResFactory<T,TR>): TR; where TR: QueueRes<T>;
    begin
      var origin_err_handler := g.curr_err_handler;
      
      g.curr_err_handler := ErrHandlerBranchBud.Wrap(origin_err_handler{$ifdef DEBUG}, $'{TypeName(self)}: try_do'{$endif});
      var prev_qr := try_do.InvokeToAny(g, l);
      var try_err_handler := g.curr_err_handler.TrySkipFunc;
      if try_err_handler=nil then
      begin
        g.curr_err_handler := origin_err_handler;
        exit;
      end;
      var handle_err_handler := ErrHandlerFlattener.Wrap(try_err_handler{$ifdef DEBUG}, $'{TypeName(self)} wrap'{$endif});
      
      {$ifdef DEBUG}
      var err_test_reason := $'[{self.GetHashCode}]:{TypeName(self)}.Apply';
      handle_err_handler.AddMaybeError(err_test_reason);
      {$endif DEBUG}
      var l_handle_err_handler := handle_err_handler;
      Result := prev_qr.TransformResult(qr_factory, true, prev_res->
      begin
        var (appl, res) := self.ApplyTo(l_handle_err_handler{$ifdef DEBUG}, err_test_reason{$endif});
        Result := if appl then res else prev_res;
      end);
      
      g.curr_err_handler := ErrHandlerBranchCombinator.Wrap(
        origin_err_handler, handle_err_handler
        {$ifdef DEBUG}, $'{TypeName(self)} origin+handle union'{$endif}
      );
    end;
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes   <T>; override := Invoke(g, l, qr_val_factory);
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<T>; override := Invoke(g, l, qr_ptr_factory);
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      try_do.ToString(sb, tabs, index, delayed);
      
      sb.Append(#9, tabs);
      ToStringWriteDelegate(sb, handler);
      sb += #10;
      
    end;
    
  end;
  
function CommandQueue<T>.HandleReplaceRes(handler: List<Exception> -> T) :=
if (self is ConstQueue<T>) or (self is ParameterQueue<T>) then self else
new CommandQueueHandleReplaceRes<T>(self, handler);

{$endregion Handle}

{$endregion Queue converter's}

{$region GPUCommand}

{$region Base}

type
  GPUCommand<T> = abstract class
    
    protected function TryPreCall(q: CommandQueue<T>): boolean; abstract;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_mu: HashSet<IMultiusableCommandQueue>); abstract;
    
    protected function Invoke(dep_ok: boolean; inp: CommandQueue<T>; g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil; abstract;
    
    protected static procedure ToStringWriteDelegate(sb: StringBuilder; d: System.Delegate) := CommandQueueBase.ToStringWriteDelegate(sb,d);
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); abstract;
    
    private procedure ToString(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>);
    begin
      sb.Append(#9, tabs);
      sb += TypeName(self);
      self.ToStringImpl(sb, tabs+1, index, delayed);
    end;
    
  end;
  
{$endregion Base}

{$region Queue}

type
  QueueCommand<T> = sealed class(GPUCommand<T>)
    public q: CommandQueueBase;
    
    public constructor(q: CommandQueueBase) := self.q := q;
    private constructor := raise new OpenCLABCInternalException;
    
    protected function TryPreCall(q: CommandQueue<T>): boolean; override := false;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_mu: HashSet<IMultiusableCommandQueue>); override :=
    q.InitBeforeInvoke(g, inited_mu);
    
    protected function Invoke(dep_ok: boolean; inp: CommandQueue<T>; g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil; override := q.InvokeToNil(g, l);
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      q.ToString(sb, tabs, index, delayed);
    end;
    
  end;
  
  //TODO Разбить на 2 ITypedCQConverter: IsEmpty и CastUnpack
  QueueCommandConstructor<TObj> = sealed class(ITypedCQConverter<GPUCommand<TObj>>)
    
    public function ConvertNil(cq: CommandQueueNil): GPUCommand<TObj> :=
    if cq is ConstQueueNil then nil else
      new QueueCommand<TObj>(cq);
    public function Convert<T>(cq: CommandQueue<T>): GPUCommand<TObj> :=
    if cq is ConstQueue<T> then nil else
    if cq is ParameterQueue<T> then nil else
    if cq is CastQueueBase<T>(var ccq) then
      ccq.SourceBase.ConvertTyped(self) else
      new QueueCommand<TObj>(cq);
    
    public static function Make(q: CommandQueueBase): GPUCommand<TObj> :=
    q.ConvertTyped(new QueueCommandConstructor<TObj>);
    
  end;
  
{$endregion Queue}

{$region Proc} type
  
  {$region Base}
  
  ProcCommandBase<T, TProc> = abstract class(GPUCommand<T>)
  where TProc: ISimpleProcContainer<T>;
    public p: TProc;
    public can_pre_call: boolean;
    
    public constructor(p: TProc; can_pre_call: boolean);
    begin
      self.p := p;
      self.can_pre_call := can_pre_call;
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    protected function TryPreCall(q: CommandQueue<T>): boolean; override;
    begin
      Result := false;
      if not can_pre_call then exit;
      if q.const_res_dep=nil then exit;
      p.Invoke(q.expected_const_res, nil);
      Result := q.IsConstResDepEmpty;
    end;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_mu: HashSet<IMultiusableCommandQueue>); override := exit;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += ': ';
      p.ToStringB(sb);
      sb += #10;
    end;
    
  end;
  
  {$endregion Base}
  
  {$region Quick}
  
  QuickProcCommand<T, TProc> = sealed class(ProcCommandBase<T, TProc>)
  where TProc: ISimpleProcContainer<T>;
    
    protected function Invoke(dep_ok: boolean; inp: CommandQueue<T>; g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil; override;
    begin
      Result := new QueueResNil(l);
      if can_pre_call and dep_ok then exit;
      
      var prev_qr := inp.InvokeToAny(g, l);
      var should_insta_call := if can_pre_call then
        prev_qr.IsConst else
        prev_qr.ShouldInstaCallAction;
      
      var err_handler := g.curr_err_handler.Extract({$ifdef DEBUG}false{$endif});
      {$ifdef DEBUG}
      var err_test_reason := $'[{self.GetHashCode}]:{TypeName(self)}.p.Invoke';
      err_handler.AddMaybeError(err_test_reason);
      {$endif DEBUG}
      if should_insta_call then
        p.Invoke(g, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, prev_qr.GetResDirect, g.c) else
        //TODO #????: self.
        Result.AddAction(c->self.p.Invoke(nil, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, prev_qr.GetResDirect, c));
      
    end;
    
  end;
  
  {$endregion Quick}
  
  {$region Threaded}
  
  ThreadedProcCommand<T, TProc> = sealed class(ProcCommandBase<T, TProc>)
  where TProc: ISimpleProcContainer<T>;
    
    protected function Invoke(dep_ok: boolean; inp: CommandQueue<T>; g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil; override;
    begin
      if can_pre_call and dep_ok then
      begin
        Result := new QueueResNil(l);
        exit;
      end;
      
      var prev_qr := inp.InvokeToAny(g, l);
      l := prev_qr.TakeBaseOut;
      var acts := l.prev_delegate;
      var c := g.c;
      var err_handler := g.curr_err_handler.Extract({$ifdef DEBUG}false{$endif});
      {$ifdef DEBUG}
      var err_test_reason := $'[{self.GetHashCode}]:{TypeName(self)}.p.Invoke';
      err_handler.AddMaybeError(err_test_reason);
      {$endif DEBUG}
      
      var work_ev := UserEvent.StartWorkThread(l.prev_ev, ()->
      begin
        acts.Invoke(c);
        p.Invoke(nil, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, prev_qr.GetResDirect, c);
      end, g
      {$ifdef EventDebug}, $'body of {TypeName(self)}'{$endif});
      
      Result := new QueueResNil(work_ev);
    end;
    
  end;
  
  {$endregion Threaded}
  
  {$region Constructor}
  
  ProcCommandConstructor<TObj> = sealed class
    
    private constructor := raise new OpenCLABCInternalException;
    
    public static function Make<TProc>(p: TProc; need_own_thread, can_pre_calc: boolean): GPUCommand<TObj>; where TProc: ISimpleProcContainer<TObj>;
    begin
      // Check for const input is in a .Validate
      if need_own_thread then
        Result := new ThreadedProcCommand<TObj, TProc>(p, can_pre_calc) else
        Result := new    QuickProcCommand<TObj, TProc>(p, can_pre_calc);
    end;
    
  end;
  
  {$endregion Constructor}
  
{$endregion Proc}

{$region Wait}

type
  WaitCommand<T> = sealed class(GPUCommand<T>)
    public marker: WaitMarker;
    
    public constructor(marker: WaitMarker) := self.marker := marker;
    private constructor := raise new OpenCLABCInternalException;
    
    protected function TryPreCall(q: CommandQueue<T>): boolean; override := false;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_mu: HashSet<IMultiusableCommandQueue>); override :=
    marker.InitInnerHandles(g);
    
    protected function Invoke(dep_ok: boolean; inp: CommandQueue<T>; g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil; override :=
    new QueueResNil( marker.MakeWaitEv(g,l) );
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      marker.ToString(sb, tabs, index, delayed);
    end;
    
  end;
  
  WaitCommandConstructor<TObj> = sealed class
    
    private constructor := raise new OpenCLABCInternalException;
    
    public static function Make(marker: WaitMarker) := new WaitCommand<TObj>(marker);
    
  end;
  
{$endregion Wait}

{$endregion GPUCommand}

{$region GPUCommandContainer}

{$region Base}

type
  GPUCommandContainer<T> = abstract class(CommandQueue<T>)
    protected q: CommandQueue<T>;
    
    protected commands := new List<GPUCommand<T>>;
    // Not nil only when commands are nil
    private commands_in: GPUCommandContainer<T>;
    private old_command_count: integer;
    
    protected constructor(q: CommandQueue<T>);
    begin
      self.q := q.Multiusable;
      self.const_res_dep      := q.const_res_dep;
      self.expected_const_res := q.expected_const_res;
    end;
    
    protected constructor(ccq: GPUCommandContainer<T>);
    begin
      self.q := ccq.q;
      self.commands := ccq.commands;
    end;
    
    private constructor := raise new OpenCLABCInternalException;
    
    private procedure TakeCommandsBack;
    begin
      var commands_in := self.commands_in;
      if commands_in=nil then exit;
      
      while true do
      begin
        var next := commands_in.commands_in;
        if next=nil then break;
        commands_in := next;
      end;
      
      var commands := new List<GPUCommand<T>>(old_command_count);
      for var i := 0 to old_command_count-1 do
        commands += commands_in.commands[i];
      
      Volatile.Write(self.commands, commands);
      Volatile.Write(self.commands_in, nil);
    end;
    
    public function Clone: GPUCommandContainer<T>; abstract;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_mu: HashSet<IMultiusableCommandQueue>); override;
    begin
      q.InitBeforeInvoke(g, inited_mu);
      TakeCommandsBack;
      foreach var comm in self.commands do comm.InitBeforeInvoke(g, inited_mu);
    end;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; last_invoke: CommandQueueInvoker<TR>): TR;
    begin
      var dep_ok := g.CheckDeps(q.const_res_dep);
      l := q.InvokeToNil(g,l).base; //TODO Костыль, но сначала убрать .MU из заголовка
      
      foreach var comm in commands do
        l := comm.Invoke(dep_ok,q, g,l).base;
      
      Result := last_invoke(g,l);
    end;
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil; override := Invoke(g, l, q.InvokeToNil);
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes<T>; override := Invoke(g, l, q.InvokeToAny);
    
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<T>; override;
    begin
      Result := nil;
      raise new OpenCLABCInternalException($'%Err:Invoke:InvalidToPtr%');
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      q.ToString(sb, tabs, index, delayed);
      TakeCommandsBack;
      foreach var comm in commands do
        comm.ToString(sb, tabs, index, delayed);
    end;
    
  end;
  
function AddCommand<TContainer, T>(cc: TContainer; comm: GPUCommand<T>): TContainer; where TContainer: GPUCommandContainer<T>;
begin
  if comm.TryPreCall(cc.q) then exit;
  cc.TakeCommandsBack;
  Result := TContainer(cc.Clone);
  cc.commands_in := Result;
  //TODO #????
  cc.old_command_count := (cc as GPUCommandContainer<T>).commands.Count;
  cc.commands := nil;
  Result.commands += comm;
end;

{$endregion Base}

{$region CLKernel}

type
  CLKernelCCQ = sealed partial class(GPUCommandContainer<CLKernel>)
    
    private constructor(ccq: GPUCommandContainer<CLKernel>) := inherited;
    public function Clone: GPUCommandContainer<CLKernel>; override := new CLKernelCCQ(self);
    
  end;
  
constructor CLKernelCCQ.Create(q: CommandQueue<CLKernel>) := inherited;
constructor CLKernelCCQ.Create := inherited;

/// %CommandQueue<CLKernel>.MakeCCQ%
function MakeCCQ(self: CommandQueue<CLKernel>): CLKernelCCQ; extensionmethod;
begin
  Result := new CLKernelCCQ(self);
end;

{$region Special .Add's}

function CLKernelCCQ.ThenQueue(q: CommandQueueBase): CLKernelCCQ;
begin
  var comm := QueueCommandConstructor&<CLKernel>.Make(q);
  Result := if comm=nil then self else AddCommand(self, comm);
end;

function CLKernelCCQ.ThenProc(p: CLKernel->(); need_own_thread, can_pre_calc: boolean) := AddCommand(self, ProcCommandConstructor&<CLKernel>.Make&<SimpleProcContainer<CLKernel>>(p, need_own_thread, can_pre_calc));
function CLKernelCCQ.ThenProc(p: (CLKernel, CLContext)->(); need_own_thread, can_pre_calc: boolean) := AddCommand(self, ProcCommandConstructor&<CLKernel>.Make&<SimpleProcContainerC<CLKernel>>(p, need_own_thread, can_pre_calc));

function CLKernelCCQ.ThenWait(marker: WaitMarker) := AddCommand(self, WaitCommandConstructor&<CLKernel>.Make(marker));

{$endregion Special .Add's}

{$endregion CLKernel}

{$region CLMemory}

type
  CLMemoryCCQ = sealed partial class(GPUCommandContainer<CLMemory>)
    
    private constructor(ccq: GPUCommandContainer<CLMemory>) := inherited;
    public function Clone: GPUCommandContainer<CLMemory>; override := new CLMemoryCCQ(self);
    
  end;
  
constructor CLMemoryCCQ.Create(q: CommandQueue<CLMemory>) := inherited;
constructor CLMemoryCCQ.Create := inherited;

/// %CommandQueue<CLMemory>.MakeCCQ%
function MakeCCQ(self: CommandQueue<CLMemory>): CLMemoryCCQ; extensionmethod;
begin
  Result := new CLMemoryCCQ(self);
end;

{$region Special .Add's}

function CLMemoryCCQ.ThenQueue(q: CommandQueueBase): CLMemoryCCQ;
begin
  var comm := QueueCommandConstructor&<CLMemory>.Make(q);
  Result := if comm=nil then self else AddCommand(self, comm);
end;

function CLMemoryCCQ.ThenProc(p: CLMemory->(); need_own_thread, can_pre_calc: boolean) := AddCommand(self, ProcCommandConstructor&<CLMemory>.Make&<SimpleProcContainer<CLMemory>>(p, need_own_thread, can_pre_calc));
function CLMemoryCCQ.ThenProc(p: (CLMemory, CLContext)->(); need_own_thread, can_pre_calc: boolean) := AddCommand(self, ProcCommandConstructor&<CLMemory>.Make&<SimpleProcContainerC<CLMemory>>(p, need_own_thread, can_pre_calc));

function CLMemoryCCQ.ThenWait(marker: WaitMarker) := AddCommand(self, WaitCommandConstructor&<CLMemory>.Make(marker));

{$endregion Special .Add's}

{$endregion CLMemory}

{$region CLValue}

type
  CLValueCCQ<T> = sealed partial class(GPUCommandContainer<CLValue<T>>)
    
    private constructor(ccq: GPUCommandContainer<CLValue<T>>) := inherited;
    public function Clone: GPUCommandContainer<CLValue<T>>; override := new CLValueCCQ<T>(self);
    
  end;
  
constructor CLValueCCQ<T>.Create(q: CommandQueue<CLValue<T>>) := inherited;
constructor CLValueCCQ<T>.Create := inherited;

/// %CommandQueue<CLValue<T>>.MakeCCQ%
function MakeCCQ<T>(self: CommandQueue<CLValue<T>>): CLValueCCQ<T>; extensionmethod; where T: record;
begin
  Result := new CLValueCCQ<T>(self);
end;

{$region Special .Add's}

function CLValueCCQ<T>.ThenQueue(q: CommandQueueBase): CLValueCCQ<T>;
begin
  var comm := QueueCommandConstructor&<CLValue<T>>.Make(q);
  Result := if comm=nil then self else AddCommand(self, comm);
end;

function CLValueCCQ<T>.ThenProc(p: CLValue<T>->(); need_own_thread, can_pre_calc: boolean) := AddCommand(self, ProcCommandConstructor&<CLValue<T>>.Make&<SimpleProcContainer<CLValue<T>>>(p, need_own_thread, can_pre_calc));
function CLValueCCQ<T>.ThenProc(p: (CLValue<T>, CLContext)->(); need_own_thread, can_pre_calc: boolean) := AddCommand(self, ProcCommandConstructor&<CLValue<T>>.Make&<SimpleProcContainerC<CLValue<T>>>(p, need_own_thread, can_pre_calc));

function CLValueCCQ<T>.ThenWait(marker: WaitMarker) := AddCommand(self, WaitCommandConstructor&<CLValue<T>>.Make(marker));

{$endregion Special .Add's}

{$endregion CLArray}

{$region CLArray}

type
  CLArrayCCQ<T> = sealed partial class(GPUCommandContainer<CLArray<T>>)
    
    private constructor(ccq: GPUCommandContainer<CLArray<T>>) := inherited;
    public function Clone: GPUCommandContainer<CLArray<T>>; override := new CLArrayCCQ<T>(self);
    
  end;
  
constructor CLArrayCCQ<T>.Create(q: CommandQueue<CLArray<T>>) := inherited;
constructor CLArrayCCQ<T>.Create := inherited;

/// %CommandQueue<CLArray<T>>.MakeCCQ%
function MakeCCQ<T>(self: CommandQueue<CLArray<T>>): CLArrayCCQ<T>; extensionmethod; where T: record;
begin
  Result := new CLArrayCCQ<T>(self);
end;

{$region Special .Add's}

function CLArrayCCQ<T>.ThenQueue(q: CommandQueueBase): CLArrayCCQ<T>;
begin
  var comm := QueueCommandConstructor&<CLArray<T>>.Make(q);
  Result := if comm=nil then self else AddCommand(self, comm);
end;

function CLArrayCCQ<T>.ThenProc(p: CLArray<T>->(); need_own_thread, can_pre_calc: boolean) := AddCommand(self, ProcCommandConstructor&<CLArray<T>>.Make&<SimpleProcContainer<CLArray<T>>>(p, need_own_thread, can_pre_calc));
function CLArrayCCQ<T>.ThenProc(p: (CLArray<T>, CLContext)->(); need_own_thread, can_pre_calc: boolean) := AddCommand(self, ProcCommandConstructor&<CLArray<T>>.Make&<SimpleProcContainerC<CLArray<T>>>(p, need_own_thread, can_pre_calc));

function CLArrayCCQ<T>.ThenWait(marker: WaitMarker) := AddCommand(self, WaitCommandConstructor&<CLArray<T>>.Make(marker));

{$endregion Special .Add's}

{$endregion CLArray}

{$endregion GPUCommandContainer}

{$region CLKernelArg}

{$region Common}

{$region Base}

type
  CLKernelArgCacheEntry = record
    public val_is_set: boolean;
    public last_set_val: object;
    
    public function TrySetVal(val: object): boolean;
    begin
      Result := false;
      if self.val_is_set and Object.Equals(self.last_set_val, val) then exit;
      self.val_is_set := true;
      self.last_set_val := val;
      Result := true;
    end;
    
  end;
  CLKernelArgCache = record
    private ntv: cl_kernel;
    private vals: array of CLKernelArgCacheEntry;
    
    public constructor(k: CLKernel; args_c: integer);
    begin
      self.ntv := k.AllocNative;
      self.vals := new CLKernelArgCacheEntry[args_c];
    end;
    public constructor := raise new OpenCLABCInternalException;
    
    public function TrySetVal(ind: integer; val: object) := vals[ind].TrySetVal(val);
    
    public procedure Release(k: CLKernel);
    begin
      k.ReleaseNative(self.ntv);
      {$ifdef DEBUG}
      self.ntv := cl_kernel.Zero;
      {$endif DEBUG}
    end;
    
  end;
  
  CLKernelArgSetter = abstract class
    private is_const: boolean;
    
    public constructor(is_const: boolean) := self.is_const := is_const;
    private constructor := raise new OpenCLABCInternalException;
    
    public property IsConst: boolean read is_const;
    
    public procedure Apply(ind: UInt32; cache: CLKernelArgCache); abstract;
    
  end;
  CLKernelArgSetterTyped<T> = abstract class(CLKernelArgSetter)
    protected o := default(T);
    {$ifdef DEBUG}
    private o_set := false;
    {$endif DEBUG}
    
    public constructor(o: T);
    begin
      inherited Create(true);
      SetObj(o);
    end;
    public constructor :=
    inherited Create(false);
    
    public procedure SetObj(o: T);
    begin
      {$ifdef DEBUG}
      if o_set then raise new OpenCLABCInternalException($'Conflicting {TypeName(self)} values');
      o_set := true;
      {$endif DEBUG}
      self.o := o;
    end;
    
    public procedure Apply(ind: UInt32; cache: CLKernelArgCache); override;
    begin
      {$ifdef DEBUG}
      if not o_set then
        raise new OpenCLABCInternalException($'Unset {TypeName(self)} value');
      {$endif DEBUG}
      
      if not cache.TrySetVal(ind, self.o) then exit;
      
      ApplyImpl(cache.ntv, ind);
    end;
    public procedure ApplyImpl(k: cl_kernel; ind: UInt32); abstract;
    
  end;
  
  CLKernelArg = abstract partial class
    
    protected function TryGetConstSetter: CLKernelArgSetter; abstract;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_mu: HashSet<IMultiusableCommandQueue>); abstract;
    
    protected function Invoke(inv: CLTaskBranchInvoker; par_err_handlers: DoubleList<ErrHandler>): ValueTuple<CLKernelArgSetter, EventList>; abstract;
    
  end;
  
{$endregion Base}

{$region Global}

type
  CLKernelArgSetterGlobal<TWrap> = sealed class(CLKernelArgSetterTyped<cl_mem>)
  where TWrap: class;
    private wrap: TWrap := nil;
    
    public constructor(wrap: TWrap; mem: cl_mem);
    begin
      inherited Create(mem);
      self.wrap := wrap;
    end;
    public constructor := inherited;
    
    public procedure SetObj(wrap: TWrap; mem: cl_mem);
    begin
      inherited SetObj(mem);
      self.wrap := wrap;
    end;
    public procedure ApplyImpl(k: cl_kernel; ind: UInt32); override;
    begin
      OpenCLABCInternalException.RaiseIfError(
        cl.SetKernelArg(k, ind, new UIntPtr(cl_mem.Size), self.o)
      );
      
      GC.KeepAlive(self.wrap);
      self.wrap := nil;
    end;
    
  end;
  
  CLKernelArgGlobalCommon<TWrap> = record
  where TWrap: class;
    private q: CommandQueue<TWrap>;
    
    public constructor(q: CommandQueue<TWrap>) := self.q := q;
    public constructor := raise new OpenCLABCInternalException;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function TryGetConstSetter(get_ntv: TWrap->cl_mem): CLKernelArgSetter :=
    if q is ConstQueue<TWrap>(var c_q) then
      new CLKernelArgSetterGlobal<TWrap>(c_q.Value, get_ntv(c_q.Value)) else nil;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke(inv: CLTaskBranchInvoker; get_ntv: TWrap->cl_mem; par_err_handlers: DoubleList<ErrHandler>): ValueTuple<CLKernelArgSetter, EventList>;
    begin
      var wrap_qr := inv.InvokeBranch(q.InvokeToAny, par_err_handlers, true);
      var arg_setter: CLKernelArgSetter;
      if wrap_qr.IsConst then
      begin
        var wrap := wrap_qr.GetResDirect;
        arg_setter := new CLKernelArgSetterGlobal<TWrap>(wrap, get_ntv(wrap));
      end else
      begin
        var res := new CLKernelArgSetterGlobal<TWrap>;
        wrap_qr.AddAction(c->
        begin
          var wrap := wrap_qr.GetResDirect;
          res.SetObj(wrap, get_ntv(wrap));
        end);
        arg_setter := res;
      end;
      Result := ValueTuple.Create(arg_setter,
        wrap_qr.AttachInvokeActions(inv.g)
      );
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    procedure ToString(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>);
    begin
      sb += #10;
      q.ToString(sb, tabs, index, delayed);
    end;
    
  end;
  CLKernelArgConstantCommon<TWrap> = CLKernelArgGlobalCommon<TWrap>;
  
{$endregion GlobalWrap}

{$region Local}

type
  CLKernelArgSetterLocalBytes = sealed class(CLKernelArgSetterTyped<UIntPtr>)
    
    public procedure ApplyImpl(k: cl_kernel; ind: UInt32); override :=
    OpenCLABCInternalException.RaiseIfError( cl.SetKernelArg(k, ind, self.o, nil) );
    
  end;
  
  CLKernelArgLocal = abstract partial class(CLKernelArg) end;
  CLKernelArgLocalBytes = sealed class(CLKernelArgLocal)
    private bytes: CommandQueue<UIntPtr>;
    
    public constructor(bytes: CommandQueue<UIntPtr>) := self.bytes := bytes;
    private constructor := raise new OpenCLABCInternalException;
    
    protected function TryGetConstSetter: CLKernelArgSetter; override :=
    if bytes is ConstQueue<UIntPtr>(var c_bytes) then
      new CLKernelArgSetterLocalBytes(c_bytes.Value) else nil;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_mu: HashSet<IMultiusableCommandQueue>); override :=
    bytes.InitBeforeInvoke(g, inited_mu);
    
    protected function Invoke(inv: CLTaskBranchInvoker; par_err_handlers: DoubleList<ErrHandler>): ValueTuple<CLKernelArgSetter, EventList>; override;
    begin
      var bytes_qr := inv.InvokeBranch(bytes.InvokeToAny, par_err_handlers, true);
      var arg_setter: CLKernelArgSetter;
      if bytes_qr.IsConst then
        arg_setter := new CLKernelArgSetterLocalBytes(bytes_qr.GetResDirect) else
      begin
        var res := new CLKernelArgSetterLocalBytes;
        bytes_qr.AddAction(c->res.SetObj(bytes_qr.GetResDirect));
        arg_setter := res;
      end;
      Result := ValueTuple.Create(arg_setter,
        bytes_qr.AttachInvokeActions(inv.g)
      );
    end;
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      bytes.ToString(sb, tabs, index, delayed);
    end;
    
  end;
  
{$endregion Local}

{$region Private}

type
  CLKernelArgPrivateCommon<TInp> = record
    private q: CommandQueue<TInp>;
    
    public constructor(q: CommandQueue<TInp>) := self.q := q;
    public constructor := raise new OpenCLABCInternalException;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke(inv: CLTaskBranchInvoker; make_const: TInp->CLKernelArgSetterTyped<TInp>; make_delayed: ()->CLKernelArgSetterTyped<TInp>; par_err_handlers: DoubleList<ErrHandler>): ValueTuple<CLKernelArgSetter, EventList>;
    begin
      var prev_qr := inv.InvokeBranch(q.InvokeToAny, par_err_handlers, true);
      var arg_setter: CLKernelArgSetter;
      if prev_qr.IsConst then
        arg_setter := make_const(prev_qr.GetResDirect) else
      begin
        var res := make_delayed();
        prev_qr.AddAction(c->res.SetObj(prev_qr.GetResDirect));
        arg_setter := res;
      end;
      Result := ValueTuple.Create(arg_setter,
        prev_qr.AttachInvokeActions(inv.g)
      );
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    procedure ToString(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>);
    begin
      sb += #10;
      q.ToString(sb, tabs, index, delayed);
    end;
    
  end;
  
{$endregion Private}

{$endregion Common}

{$region Global}

{$region CL}

{$region CLMemory}

type
  CLKernelArgGlobalCLMemory = sealed class(CLKernelArgGlobal)
    private data: CLKernelArgGlobalCommon<CLMemory>;
    
    public constructor(cl_mem: CommandQueue<CLMemory>) :=
    data := new CLKernelArgGlobalCommon<CLMemory>(cl_mem);
    
    private static function WrapToNative(o: CLMemory) := o.Native;
    
    protected function TryGetConstSetter: CLKernelArgSetter; override :=
    data.TryGetConstSetter(WrapToNative);
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueue>); override :=
    data.q.InitBeforeInvoke(g, inited_hubs);
    
    protected function Invoke(inv: CLTaskBranchInvoker; par_err_handlers: DoubleList<ErrHandler>): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke(inv, WrapToNative, par_err_handlers);
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgGlobal.FromCLMemory(cl_mem: CommandQueue<CLMemory>): CLKernelArgGlobal;
begin Result := new CLKernelArgGlobalCLMemory(cl_mem) end;
static function CLKernelArgGlobal.operator implicit(cl_mem: CLMemoryCCQ): CLKernelArgGlobal;
begin Result := FromCLMemory(cl_mem as object as CommandQueue<CLMemory>) end;

{$endregion CLMemory}

{$region CLValue}

type
  CLKernelArgGlobalCLValue<T> = sealed class(CLKernelArgGlobal)
  where T: record;
    private data: CLKernelArgGlobalCommon<CLValue<T>>;
    
    public constructor(cl_val: CommandQueue<CLValue<T>>) :=
    data := new CLKernelArgGlobalCommon<CLValue<T>>(cl_val);
    
    private static function WrapToNative(o: CLValue<T>) := o.Native;
    
    protected function TryGetConstSetter: CLKernelArgSetter; override :=
    data.TryGetConstSetter(WrapToNative);
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueue>); override :=
    data.q.InitBeforeInvoke(g, inited_hubs);
    
    protected function Invoke(inv: CLTaskBranchInvoker; par_err_handlers: DoubleList<ErrHandler>): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke(inv, WrapToNative, par_err_handlers);
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgGlobal.FromCLValue<T>(cl_val: CommandQueue<CLValue<T>>): CLKernelArgGlobal; where T: record;
begin Result := new CLKernelArgGlobalCLValue<T>(cl_val) end;
static function CLKernelArgGlobal.operator implicit<T>(cl_val: CLValueCCQ<T>): CLKernelArgGlobal; where T: record;
begin Result := FromCLValue(cl_val as object as CommandQueue<CLValue<T>>) end;

{$endregion CLValue}

{$region CLArray}

type
  CLKernelArgGlobalCLArray<T> = sealed class(CLKernelArgGlobal)
  where T: record;
    private data: CLKernelArgGlobalCommon<CLArray<T>>;
    
    public constructor(cl_arr: CommandQueue<CLArray<T>>) :=
    data := new CLKernelArgGlobalCommon<CLArray<T>>(cl_arr);
    
    private static function WrapToNative(o: CLArray<T>) := o.Native;
    
    protected function TryGetConstSetter: CLKernelArgSetter; override :=
    data.TryGetConstSetter(WrapToNative);
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueue>); override :=
    data.q.InitBeforeInvoke(g, inited_hubs);
    
    protected function Invoke(inv: CLTaskBranchInvoker; par_err_handlers: DoubleList<ErrHandler>): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke(inv, WrapToNative, par_err_handlers);
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgGlobal.FromCLArray<T>(cl_arr: CommandQueue<CLArray<T>>): CLKernelArgGlobal; where T: record;
begin Result := new CLKernelArgGlobalCLArray<T>(cl_arr) end;
static function CLKernelArgGlobal.operator implicit<T>(cl_arr: CLArrayCCQ<T>): CLKernelArgGlobal; where T: record;
begin Result := FromCLArray(cl_arr as object as CommandQueue<CLArray<T>>) end;

{$endregion CLArray}

{$endregion CL}

{$endregion Global}

{$region Constant}

{$region CL}

{$region CLMemory}

type
  CLKernelArgConstantCLMemory = sealed class(CLKernelArgConstant)
    private data: CLKernelArgConstantCommon<CLMemory>;
    
    public constructor(cl_mem: CommandQueue<CLMemory>) :=
    data := new CLKernelArgConstantCommon<CLMemory>(cl_mem);
    
    private static function WrapToNative(o: CLMemory) := o.Native;
    
    protected function TryGetConstSetter: CLKernelArgSetter; override :=
    data.TryGetConstSetter(WrapToNative);
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueue>); override :=
    data.q.InitBeforeInvoke(g, inited_hubs);
    
    protected function Invoke(inv: CLTaskBranchInvoker; par_err_handlers: DoubleList<ErrHandler>): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke(inv, WrapToNative, par_err_handlers);
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgConstant.FromCLMemory(cl_mem: CommandQueue<CLMemory>): CLKernelArgConstant;
begin Result := new CLKernelArgConstantCLMemory(cl_mem) end;
static function CLKernelArgConstant.operator implicit(cl_mem: CLMemoryCCQ): CLKernelArgConstant;
begin Result := FromCLMemory(cl_mem as object as CommandQueue<CLMemory>) end;

{$endregion CLMemory}

{$region CLValue}

type
  CLKernelArgConstantCLValue<T> = sealed class(CLKernelArgConstant)
  where T: record;
    private data: CLKernelArgConstantCommon<CLValue<T>>;
    
    public constructor(cl_val: CommandQueue<CLValue<T>>) :=
    data := new CLKernelArgConstantCommon<CLValue<T>>(cl_val);
    
    private static function WrapToNative(o: CLValue<T>) := o.Native;
    
    protected function TryGetConstSetter: CLKernelArgSetter; override :=
    data.TryGetConstSetter(WrapToNative);
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueue>); override :=
    data.q.InitBeforeInvoke(g, inited_hubs);
    
    protected function Invoke(inv: CLTaskBranchInvoker; par_err_handlers: DoubleList<ErrHandler>): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke(inv, WrapToNative, par_err_handlers);
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgConstant.FromCLValue<T>(cl_val: CommandQueue<CLValue<T>>): CLKernelArgConstant; where T: record;
begin Result := new CLKernelArgConstantCLValue<T>(cl_val) end;
static function CLKernelArgConstant.operator implicit<T>(cl_val: CLValueCCQ<T>): CLKernelArgConstant; where T: record;
begin Result := FromCLValue(cl_val as object as CommandQueue<CLValue<T>>) end;

{$endregion CLValue}

{$region CLArray}

type
  CLKernelArgConstantCLArray<T> = sealed class(CLKernelArgConstant)
  where T: record;
    private data: CLKernelArgConstantCommon<CLArray<T>>;
    
    public constructor(cl_arr: CommandQueue<CLArray<T>>) :=
    data := new CLKernelArgConstantCommon<CLArray<T>>(cl_arr);
    
    private static function WrapToNative(o: CLArray<T>) := o.Native;
    
    protected function TryGetConstSetter: CLKernelArgSetter; override :=
    data.TryGetConstSetter(WrapToNative);
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueue>); override :=
    data.q.InitBeforeInvoke(g, inited_hubs);
    
    protected function Invoke(inv: CLTaskBranchInvoker; par_err_handlers: DoubleList<ErrHandler>): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke(inv, WrapToNative, par_err_handlers);
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgConstant.FromCLArray<T>(cl_arr: CommandQueue<CLArray<T>>): CLKernelArgConstant; where T: record;
begin Result := new CLKernelArgConstantCLArray<T>(cl_arr) end;
static function CLKernelArgConstant.operator implicit<T>(cl_arr: CLArrayCCQ<T>): CLKernelArgConstant; where T: record;
begin Result := FromCLArray(cl_arr as object as CommandQueue<CLArray<T>>) end;

{$endregion CLArray}

{$endregion CL}

{$endregion Constant}

{$region Local}

{$region FromBytes}

static function CLKernelArgLocal.FromBytes(bytes: CommandQueue<UIntPtr>) := new CLKernelArgLocalBytes(bytes);

{$endregion FromBytes}

{$region FromItemCount}

static function CLKernelArgLocal.FromItemCount<T>(item_count: CommandQueue<UInt32>): CLKernelArgLocal; where T: record;
begin
  BlittableHelper.RaiseIfBad(typeof(T), '%Err:Blittable:Source:CLKernelArgLocal:ItemCount%');
  Result := FromBytes(item_count.ThenConvert(item_count->new UIntPtr(
    uint64(Marshal.Sizeof(default(T)))*UInt32(item_count)
  ), false,true));
end;
static function CLKernelArgLocal.FromItemCount<T>(item_count: CommandQueue<Int32>): CLKernelArgLocal; where T: record;
begin
  BlittableHelper.RaiseIfBad(typeof(T), '%Err:Blittable:Source:CLKernelArgLocal:ItemCount%');
  Result := FromBytes(item_count.ThenConvert(item_count->new UIntPtr(
    uint64(Marshal.Sizeof(default(T)))*UInt32(item_count)
  ), false,true));
end;

{$endregion FromItemCount}

{$region LikeArray}

{$endregion LikeArray}

{$endregion Local}

{$region Private}

{$region Managed}

{$region Array}

type
  CLKernelArgPrivateSetterArray<T> = sealed class(CLKernelArgSetterTyped<array of T>)
  where T: record;
    
    public procedure ApplyImpl(k: cl_kernel; ind: UInt32); override :=
    OpenCLABCInternalException.RaiseIfError( cl.SetKernelArg(k, ind, new UIntPtr(UInt32(self.o.Length)*uint64(Marshal.SizeOf(default(T)))), self.o[0]) );
    
  end;
  CLKernelArgPrivateArray<T> = sealed class(CLKernelArgPrivate)
  where T: record;
    private data: CLKernelArgPrivateCommon<array of T>;
    
    static constructor := BlittableHelper.RaiseIfBad(typeof(T), $'%Err:Blittable:Source:CLKernelArgPrivate:Array%');
    
    public constructor(a: CommandQueue<array of T>) :=
    data := new CLKernelArgPrivateCommon<array of T>(a);
    
    protected function TryGetConstSetter: CLKernelArgSetter; override :=
    if data.q is ConstQueue<array of T>(var c_q) then
      new CLKernelArgPrivateSetterArray<T>(c_q.Value) else nil;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueue>); override :=
    data.q.InitBeforeInvoke(g, inited_hubs);
    
    protected function Invoke(inv: CLTaskBranchInvoker; par_err_handlers: DoubleList<ErrHandler>): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke(inv, o->new CLKernelArgPrivateSetterArray<T>(o), ()->new CLKernelArgPrivateSetterArray<T>, par_err_handlers);
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgPrivate.FromArray<T>(a: CommandQueue<array of T>): CLKernelArgPrivate; where T: record;
begin Result := new CLKernelArgPrivateArray<T>(a) end;

{$endregion Array}

{$region Array2}

type
  CLKernelArgPrivateSetterArray2<T> = sealed class(CLKernelArgSetterTyped<array[,] of T>)
  where T: record;
    
    public procedure ApplyImpl(k: cl_kernel; ind: UInt32); override :=
    OpenCLABCInternalException.RaiseIfError( cl.SetKernelArg(k, ind, new UIntPtr(UInt32(self.o.Length)*uint64(Marshal.SizeOf(default(T)))), self.o[0,0]) );
    
  end;
  CLKernelArgPrivateArray2<T> = sealed class(CLKernelArgPrivate)
  where T: record;
    private data: CLKernelArgPrivateCommon<array[,] of T>;
    
    static constructor := BlittableHelper.RaiseIfBad(typeof(T), $'%Err:Blittable:Source:CLKernelArgPrivate:Array2%');
    
    public constructor(a2: CommandQueue<array[,] of T>) :=
    data := new CLKernelArgPrivateCommon<array[,] of T>(a2);
    
    protected function TryGetConstSetter: CLKernelArgSetter; override :=
    if data.q is ConstQueue<array[,] of T>(var c_q) then
      new CLKernelArgPrivateSetterArray2<T>(c_q.Value) else nil;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueue>); override :=
    data.q.InitBeforeInvoke(g, inited_hubs);
    
    protected function Invoke(inv: CLTaskBranchInvoker; par_err_handlers: DoubleList<ErrHandler>): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke(inv, o->new CLKernelArgPrivateSetterArray2<T>(o), ()->new CLKernelArgPrivateSetterArray2<T>, par_err_handlers);
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgPrivate.FromArray2<T>(a2: CommandQueue<array[,] of T>): CLKernelArgPrivate; where T: record;
begin Result := new CLKernelArgPrivateArray2<T>(a2) end;

{$endregion Array2}

{$region Array3}

type
  CLKernelArgPrivateSetterArray3<T> = sealed class(CLKernelArgSetterTyped<array[,,] of T>)
  where T: record;
    
    public procedure ApplyImpl(k: cl_kernel; ind: UInt32); override :=
    OpenCLABCInternalException.RaiseIfError( cl.SetKernelArg(k, ind, new UIntPtr(UInt32(self.o.Length)*uint64(Marshal.SizeOf(default(T)))), self.o[0,0,0]) );
    
  end;
  CLKernelArgPrivateArray3<T> = sealed class(CLKernelArgPrivate)
  where T: record;
    private data: CLKernelArgPrivateCommon<array[,,] of T>;
    
    static constructor := BlittableHelper.RaiseIfBad(typeof(T), $'%Err:Blittable:Source:CLKernelArgPrivate:Array3%');
    
    public constructor(a3: CommandQueue<array[,,] of T>) :=
    data := new CLKernelArgPrivateCommon<array[,,] of T>(a3);
    
    protected function TryGetConstSetter: CLKernelArgSetter; override :=
    if data.q is ConstQueue<array[,,] of T>(var c_q) then
      new CLKernelArgPrivateSetterArray3<T>(c_q.Value) else nil;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueue>); override :=
    data.q.InitBeforeInvoke(g, inited_hubs);
    
    protected function Invoke(inv: CLTaskBranchInvoker; par_err_handlers: DoubleList<ErrHandler>): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke(inv, o->new CLKernelArgPrivateSetterArray3<T>(o), ()->new CLKernelArgPrivateSetterArray3<T>, par_err_handlers);
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgPrivate.FromArray3<T>(a3: CommandQueue<array[,,] of T>): CLKernelArgPrivate; where T: record;
begin Result := new CLKernelArgPrivateArray3<T>(a3) end;

{$endregion Array3}

{$region ArraySegment}

type
  CLKernelArgPrivateSetterArraySegment<T> = sealed class(CLKernelArgSetterTyped<ArraySegment<T>>)
  where T: record;
    
    public procedure ApplyImpl(k: cl_kernel; ind: UInt32); override :=
    OpenCLABCInternalException.RaiseIfError( cl.SetKernelArg(k, ind, new UIntPtr(UInt32(self.o.Count)*uint64(Marshal.SizeOf(default(T)))), self.o.Array[self.o.Offset]) );
    
  end;
  CLKernelArgPrivateArraySegment<T> = sealed class(CLKernelArgPrivate)
  where T: record;
    private data: CLKernelArgPrivateCommon<ArraySegment<T>>;
    
    static constructor := BlittableHelper.RaiseIfBad(typeof(T), $'%Err:Blittable:Source:CLKernelArgPrivate:ArraySegment%');
    
    public constructor(seg: CommandQueue<ArraySegment<T>>) :=
    data := new CLKernelArgPrivateCommon<ArraySegment<T>>(seg);
    
    protected function TryGetConstSetter: CLKernelArgSetter; override :=
    if data.q is ConstQueue<ArraySegment<T>>(var c_q) then
      new CLKernelArgPrivateSetterArraySegment<T>(c_q.Value) else nil;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueue>); override :=
    data.q.InitBeforeInvoke(g, inited_hubs);
    
    protected function Invoke(inv: CLTaskBranchInvoker; par_err_handlers: DoubleList<ErrHandler>): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke(inv, o->new CLKernelArgPrivateSetterArraySegment<T>(o), ()->new CLKernelArgPrivateSetterArraySegment<T>, par_err_handlers);
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgPrivate.FromArraySegment<T>(seg: CommandQueue<ArraySegment<T>>): CLKernelArgPrivate; where T: record;
begin Result := new CLKernelArgPrivateArraySegment<T>(seg) end;

{$endregion ArraySegment}

{$endregion Managed}

{$region NativeArea}

{$region NativeMemoryArea}

type
  CLKernelArgPrivateSetterNativeMemoryArea = sealed class(CLKernelArgSetterTyped<NativeMemoryArea>)
    
    public procedure ApplyImpl(k: cl_kernel; ind: UInt32); override :=
    OpenCLABCInternalException.RaiseIfError( cl.SetKernelArg(k, ind, self.o.sz, self.o.ptr) );
    
  end;
  CLKernelArgPrivateNativeMemoryArea = sealed class(CLKernelArgPrivate)
    private data: CLKernelArgPrivateCommon<NativeMemoryArea>;
    
    public constructor(ntv_mem_area: CommandQueue<NativeMemoryArea>) :=
    data := new CLKernelArgPrivateCommon<NativeMemoryArea>(ntv_mem_area);
    
    protected function TryGetConstSetter: CLKernelArgSetter; override :=
    if data.q is ConstQueue<NativeMemoryArea>(var c_q) then
      new CLKernelArgPrivateSetterNativeMemoryArea(c_q.Value) else nil;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueue>); override :=
    data.q.InitBeforeInvoke(g, inited_hubs);
    
    protected function Invoke(inv: CLTaskBranchInvoker; par_err_handlers: DoubleList<ErrHandler>): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke(inv, o->new CLKernelArgPrivateSetterNativeMemoryArea(o), ()->new CLKernelArgPrivateSetterNativeMemoryArea, par_err_handlers);
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgPrivate.FromNativeMemoryArea(ntv_mem_area: CommandQueue<NativeMemoryArea>): CLKernelArgPrivate;
begin Result := new CLKernelArgPrivateNativeMemoryArea(ntv_mem_area) end;

{$endregion NativeMemoryArea}

{$region NativeValueArea}

type
  CLKernelArgPrivateSetterNativeValueArea<T> = sealed class(CLKernelArgSetterTyped<NativeValueArea<T>>)
  where T: record;
    
    public procedure ApplyImpl(k: cl_kernel; ind: UInt32); override :=
    OpenCLABCInternalException.RaiseIfError( cl.SetKernelArg(k, ind, self.o.ByteSize, self.o.ptr) );
    
  end;
  CLKernelArgPrivateNativeValueArea<T> = sealed class(CLKernelArgPrivate)
  where T: record;
    private data: CLKernelArgPrivateCommon<NativeValueArea<T>>;
    
    static constructor := BlittableHelper.RaiseIfBad(typeof(T), $'%Err:Blittable:Source:CLKernelArgPrivate:NativeValueArea%');
    
    public constructor(ntv_val_area: CommandQueue<NativeValueArea<T>>) :=
    data := new CLKernelArgPrivateCommon<NativeValueArea<T>>(ntv_val_area);
    
    protected function TryGetConstSetter: CLKernelArgSetter; override :=
    if data.q is ConstQueue<NativeValueArea<T>>(var c_q) then
      new CLKernelArgPrivateSetterNativeValueArea<T>(c_q.Value) else nil;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueue>); override :=
    data.q.InitBeforeInvoke(g, inited_hubs);
    
    protected function Invoke(inv: CLTaskBranchInvoker; par_err_handlers: DoubleList<ErrHandler>): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke(inv, o->new CLKernelArgPrivateSetterNativeValueArea<T>(o), ()->new CLKernelArgPrivateSetterNativeValueArea<T>, par_err_handlers);
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgPrivate.FromNativeValueArea<T>(ntv_val_area: CommandQueue<NativeValueArea<T>>): CLKernelArgPrivate; where T: record;
begin Result := new CLKernelArgPrivateNativeValueArea<T>(ntv_val_area) end;

{$endregion NativeValueArea}

{$region NativeArrayArea}

type
  CLKernelArgPrivateSetterNativeArrayArea<T> = sealed class(CLKernelArgSetterTyped<NativeArrayArea<T>>)
  where T: record;
    
    public procedure ApplyImpl(k: cl_kernel; ind: UInt32); override :=
    OpenCLABCInternalException.RaiseIfError( cl.SetKernelArg(k, ind, self.o.ByteSize, self.o.first_ptr) );
    
  end;
  CLKernelArgPrivateNativeArrayArea<T> = sealed class(CLKernelArgPrivate)
  where T: record;
    private data: CLKernelArgPrivateCommon<NativeArrayArea<T>>;
    
    static constructor := BlittableHelper.RaiseIfBad(typeof(T), $'%Err:Blittable:Source:CLKernelArgPrivate:NativeArrayArea%');
    
    public constructor(ntv_arr_area: CommandQueue<NativeArrayArea<T>>) :=
    data := new CLKernelArgPrivateCommon<NativeArrayArea<T>>(ntv_arr_area);
    
    protected function TryGetConstSetter: CLKernelArgSetter; override :=
    if data.q is ConstQueue<NativeArrayArea<T>>(var c_q) then
      new CLKernelArgPrivateSetterNativeArrayArea<T>(c_q.Value) else nil;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueue>); override :=
    data.q.InitBeforeInvoke(g, inited_hubs);
    
    protected function Invoke(inv: CLTaskBranchInvoker; par_err_handlers: DoubleList<ErrHandler>): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke(inv, o->new CLKernelArgPrivateSetterNativeArrayArea<T>(o), ()->new CLKernelArgPrivateSetterNativeArrayArea<T>, par_err_handlers);
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgPrivate.FromNativeArrayArea<T>(ntv_arr_area: CommandQueue<NativeArrayArea<T>>): CLKernelArgPrivate; where T: record;
begin Result := new CLKernelArgPrivateNativeArrayArea<T>(ntv_arr_area) end;

{$endregion NativeArrayArea}

{$endregion NativeArea}

{$region Native}

{$region NativeMemory}

type
  CLKernelArgPrivateSetterNativeMemory = sealed class(CLKernelArgSetterTyped<NativeMemory>)
    
    public procedure ApplyImpl(k: cl_kernel; ind: UInt32); override :=
    OpenCLABCInternalException.RaiseIfError( cl.SetKernelArg(k, ind, self.o.Area.sz, self.o.Area.ptr) );
    
  end;
  CLKernelArgPrivateNativeMemory = sealed class(CLKernelArgPrivate)
    private data: CLKernelArgPrivateCommon<NativeMemory>;
    
    public constructor(ntv_mem: CommandQueue<NativeMemory>) :=
    data := new CLKernelArgPrivateCommon<NativeMemory>(ntv_mem);
    
    protected function TryGetConstSetter: CLKernelArgSetter; override :=
    if data.q is ConstQueue<NativeMemory>(var c_q) then
      new CLKernelArgPrivateSetterNativeMemory(c_q.Value) else nil;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueue>); override :=
    data.q.InitBeforeInvoke(g, inited_hubs);
    
    protected function Invoke(inv: CLTaskBranchInvoker; par_err_handlers: DoubleList<ErrHandler>): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke(inv, o->new CLKernelArgPrivateSetterNativeMemory(o), ()->new CLKernelArgPrivateSetterNativeMemory, par_err_handlers);
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgPrivate.FromNativeMemory(ntv_mem: CommandQueue<NativeMemory>): CLKernelArgPrivate;
begin Result := new CLKernelArgPrivateNativeMemory(ntv_mem) end;

{$endregion NativeMemory}

{$region NativeValue}

type
  CLKernelArgPrivateSetterNativeValue<T> = sealed class(CLKernelArgSetterTyped<NativeValue<T>>)
  where T: record;
    
    public procedure ApplyImpl(k: cl_kernel; ind: UInt32); override :=
    OpenCLABCInternalException.RaiseIfError( cl.SetKernelArg(k, ind, self.o.Area.ByteSize, self.o.Area.ptr) );
    
  end;
  CLKernelArgPrivateNativeValue<T> = sealed class(CLKernelArgPrivate)
  where T: record;
    private data: CLKernelArgPrivateCommon<NativeValue<T>>;
    
    static constructor := BlittableHelper.RaiseIfBad(typeof(T), $'%Err:Blittable:Source:CLKernelArgPrivate:NativeValue%');
    
    public constructor(ntv_val: CommandQueue<NativeValue<T>>) :=
    data := new CLKernelArgPrivateCommon<NativeValue<T>>(ntv_val);
    
    protected function TryGetConstSetter: CLKernelArgSetter; override :=
    if data.q is ConstQueue<NativeValue<T>>(var c_q) then
      new CLKernelArgPrivateSetterNativeValue<T>(c_q.Value) else nil;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueue>); override :=
    data.q.InitBeforeInvoke(g, inited_hubs);
    
    protected function Invoke(inv: CLTaskBranchInvoker; par_err_handlers: DoubleList<ErrHandler>): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke(inv, o->new CLKernelArgPrivateSetterNativeValue<T>(o), ()->new CLKernelArgPrivateSetterNativeValue<T>, par_err_handlers);
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgPrivate.FromNativeValue<T>(ntv_val: CommandQueue<NativeValue<T>>): CLKernelArgPrivate; where T: record;
begin Result := new CLKernelArgPrivateNativeValue<T>(ntv_val) end;

{$endregion NativeValue}

{$region NativeArray}

type
  CLKernelArgPrivateSetterNativeArray<T> = sealed class(CLKernelArgSetterTyped<NativeArray<T>>)
  where T: record;
    
    public procedure ApplyImpl(k: cl_kernel; ind: UInt32); override :=
    OpenCLABCInternalException.RaiseIfError( cl.SetKernelArg(k, ind, self.o.Area.ByteSize, self.o.Area.first_ptr) );
    
  end;
  CLKernelArgPrivateNativeArray<T> = sealed class(CLKernelArgPrivate)
  where T: record;
    private data: CLKernelArgPrivateCommon<NativeArray<T>>;
    
    static constructor := BlittableHelper.RaiseIfBad(typeof(T), $'%Err:Blittable:Source:CLKernelArgPrivate:NativeArray%');
    
    public constructor(ntv_arr: CommandQueue<NativeArray<T>>) :=
    data := new CLKernelArgPrivateCommon<NativeArray<T>>(ntv_arr);
    
    protected function TryGetConstSetter: CLKernelArgSetter; override :=
    if data.q is ConstQueue<NativeArray<T>>(var c_q) then
      new CLKernelArgPrivateSetterNativeArray<T>(c_q.Value) else nil;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueue>); override :=
    data.q.InitBeforeInvoke(g, inited_hubs);
    
    protected function Invoke(inv: CLTaskBranchInvoker; par_err_handlers: DoubleList<ErrHandler>): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke(inv, o->new CLKernelArgPrivateSetterNativeArray<T>(o), ()->new CLKernelArgPrivateSetterNativeArray<T>, par_err_handlers);
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgPrivate.FromNativeArray<T>(ntv_arr: CommandQueue<NativeArray<T>>): CLKernelArgPrivate; where T: record;
begin Result := new CLKernelArgPrivateNativeArray<T>(ntv_arr) end;

{$endregion NativeArray}

{$endregion Native}

{$region Value}

type
  CLKernelArgPrivateSetterValue<T> = sealed class(CLKernelArgSetterTyped<T>)
  where T: record;
    
    public procedure ApplyImpl(k: cl_kernel; ind: UInt32); override :=
    OpenCLABCInternalException.RaiseIfError( cl.SetKernelArg(k, ind, new UIntPtr(Marshal.SizeOf(default(T))), self.o) );
    
  end;
  CLKernelArgPrivateValue<T> = sealed class(CLKernelArgPrivate)
  where T: record;
    private data: CLKernelArgPrivateCommon<T>;
    
    static constructor := BlittableHelper.RaiseIfBad(typeof(T), $'%Err:Blittable:Source:CLKernelArgPrivate:Value%');
    
    public constructor(val: CommandQueue<T>) :=
    data := new CLKernelArgPrivateCommon<T>(val);
    
    protected function TryGetConstSetter: CLKernelArgSetter; override :=
    if data.q is ConstQueue<T>(var c_q) then
      new CLKernelArgPrivateSetterValue<T>(c_q.Value) else nil;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueue>); override :=
    data.q.InitBeforeInvoke(g, inited_hubs);
    
    protected function Invoke(inv: CLTaskBranchInvoker; par_err_handlers: DoubleList<ErrHandler>): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke(inv, o->new CLKernelArgPrivateSetterValue<T>(o), ()->new CLKernelArgPrivateSetterValue<T>, par_err_handlers);
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgPrivate.FromValue<T>(val: CommandQueue<T>): CLKernelArgPrivate; where T: record;
begin Result := new CLKernelArgPrivateValue<T>(val) end;

{$endregion Value}

{$endregion Private}

{$region Generic}

{$region Managed}

{$region Array}

static function CLKernelArg.FromArray<T>(a: CommandQueue<array of T>): CLKernelArg; where T: record;
begin Result := CLKernelArgPrivate.FromArray(a) end;

{$endregion Array}

{$region Array2}

static function CLKernelArg.FromArray2<T>(a2: CommandQueue<array[,] of T>): CLKernelArg; where T: record;
begin Result := CLKernelArgPrivate.FromArray2(a2) end;

{$endregion Array2}

{$region Array3}

static function CLKernelArg.FromArray3<T>(a3: CommandQueue<array[,,] of T>): CLKernelArg; where T: record;
begin Result := CLKernelArgPrivate.FromArray3(a3) end;

{$endregion Array3}

{$region ArraySegment}

static function CLKernelArg.FromArraySegment<T>(seg: CommandQueue<ArraySegment<T>>): CLKernelArg; where T: record;
begin Result := CLKernelArgPrivate.FromArraySegment(seg) end;

{$endregion ArraySegment}

{$endregion Managed}

{$region NativeArea}

{$region NativeMemoryArea}

static function CLKernelArg.FromNativeMemoryArea(ntv_mem_area: CommandQueue<NativeMemoryArea>): CLKernelArg;
begin Result := CLKernelArgPrivate.FromNativeMemoryArea(ntv_mem_area) end;

{$endregion NativeMemoryArea}

{$region NativeValueArea}

static function CLKernelArg.FromNativeValueArea<T>(ntv_val_area: CommandQueue<NativeValueArea<T>>): CLKernelArg; where T: record;
begin Result := CLKernelArgPrivate.FromNativeValueArea(ntv_val_area) end;

{$endregion NativeValueArea}

{$region NativeArrayArea}

static function CLKernelArg.FromNativeArrayArea<T>(ntv_arr_area: CommandQueue<NativeArrayArea<T>>): CLKernelArg; where T: record;
begin Result := CLKernelArgPrivate.FromNativeArrayArea(ntv_arr_area) end;

{$endregion NativeArrayArea}

{$endregion NativeArea}

{$region Native}

{$region NativeMemory}

static function CLKernelArg.FromNativeMemory(ntv_mem: CommandQueue<NativeMemory>): CLKernelArg;
begin Result := CLKernelArgPrivate.FromNativeMemory(ntv_mem) end;

{$endregion NativeMemory}

{$region NativeValue}

static function CLKernelArg.FromNativeValue<T>(ntv_val: CommandQueue<NativeValue<T>>): CLKernelArg; where T: record;
begin Result := CLKernelArgPrivate.FromNativeValue(ntv_val) end;

{$endregion NativeValue}

{$region NativeArray}

static function CLKernelArg.FromNativeArray<T>(ntv_arr: CommandQueue<NativeArray<T>>): CLKernelArg; where T: record;
begin Result := CLKernelArgPrivate.FromNativeArray(ntv_arr) end;

{$endregion NativeArray}

{$endregion Native}

{$region CL}

{$region CLMemory}

static function CLKernelArg.FromCLMemory(cl_mem: CommandQueue<CLMemory>): CLKernelArg;
begin Result := CLKernelArgGlobal.FromCLMemory(cl_mem) end;
static function CLKernelArg.operator implicit(cl_mem: CLMemoryCCQ): CLKernelArg;
begin Result := FromCLMemory(cl_mem as object as CommandQueue<CLMemory>) end;

{$endregion CLMemory}

{$region CLValue}

static function CLKernelArg.FromCLValue<T>(cl_val: CommandQueue<CLValue<T>>): CLKernelArg; where T: record;
begin Result := CLKernelArgGlobal.FromCLValue(cl_val) end;
static function CLKernelArg.operator implicit<T>(cl_val: CLValueCCQ<T>): CLKernelArg; where T: record;
begin Result := FromCLValue(cl_val as object as CommandQueue<CLValue<T>>) end;

{$endregion CLValue}

{$region CLArray}

static function CLKernelArg.FromCLArray<T>(cl_arr: CommandQueue<CLArray<T>>): CLKernelArg; where T: record;
begin Result := CLKernelArgGlobal.FromCLArray(cl_arr) end;
static function CLKernelArg.operator implicit<T>(cl_arr: CLArrayCCQ<T>): CLKernelArg; where T: record;
begin Result := FromCLArray(cl_arr as object as CommandQueue<CLArray<T>>) end;

{$endregion CLArray}

{$endregion CL}

{$region Value}

static function CLKernelArg.FromValue<T>(val: CommandQueue<T>): CLKernelArg; where T: record;
begin Result := CLKernelArgPrivate.FromValue(val) end;

{$endregion Value}

{$endregion Generic}

{$endregion CLKernelArg}

{$region Enqueueable's}

{$region Core}

type
  DirectEnqRes = ValueTuple<cl_event, QueueResAction>;
  EnqRes = ValueTuple<EventList, QueueResAction>;
  EnqFunc<T> = function(prev_res: T; cq: cl_command_queue; ev_l2: EventList): DirectEnqRes;
  
  ParamInvRes<T> = ValueTuple<Action, EnqFunc<T>>;
  InvokeParamsFunc<T> = function(
    enq_c: integer;
    o_const: boolean;
    g: CLTaskGlobalData;
    enq_evs: DoubleList<EventList>;
    par_err_handlers: DoubleList<ErrHandler>
  ): ParamInvRes<T>;
  
  EnqueueableCore = static class
    
    //TODO Положить после Invoke, потому что оно в таком порядке вызывается...
    // - При поиске будет интуитивнее
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static function ExecuteEnqFunc<T>(
      prev_res: T;
      cq: cl_command_queue;
      ev_l2: EventList;
      {$ifdef DEBUG}cancel_p: Action;{$endif}
      enq_f: EnqFunc<T>;
      had_l1_err: boolean;
      enq_err_handler: ErrHandler
      {$ifdef DEBUG}; err_test_reason: string{$endif}
      {$ifdef EventDebug}; q: object{$endif}
    ): EnqRes;
    begin
      var direct_enq_res: DirectEnqRes;
      try
        {$ifdef DEBUG}
        if prev_res=default(t) then
          raise new OpenCLABCInternalException($'NULL Native');
        {$endif DEBUG}
        Result := new EnqRes(ev_l2, nil);
        if had_l1_err then
        begin
          {$ifdef DEBUG}
          cancel_p;
          {$endif DEBUG}
          exit;
        end;
        
        try
          direct_enq_res := enq_f(prev_res, cq, ev_l2);
        except
          on e: Exception do
          begin
            enq_err_handler.AddErr(e{$ifdef DEBUG}, err_test_reason{$endif});
            exit;
          end;
        end;
      finally
        {$ifdef DEBUG}
        enq_err_handler.EndMaybeError(err_test_reason);
        {$endif DEBUG}
      end;
      
      var (enq_ev, act) := direct_enq_res;
      Result.Item2 := act;
      
      // NVidia implementation doesn't create event if ev_l2.HasError
      if enq_ev=cl_event.Zero then
      begin
        if not ev_l2.HasError then
          raise new OpenCLABCInternalException($'');
        exit;
      end;
      // Optimize the same way for the rest of implementations
      // Also makes sure the debug event count is the same for all vendors
      if EventList.HasError(enq_ev) or ev_l2.HasError then
      begin
        cl.ReleaseEvent(enq_ev).RaiseIfError;
        exit;
      end;
      
      {$ifdef EventDebug}
      EventDebug.RegisterEventRetain(enq_ev, $'Enq by {TypeName(q)}, waiting on: {ev_l2.evs?.JoinToString}');
      {$endif EventDebug}
      // 1. ev_l2 can only be released after executing dependant command
      // 2. If event in ev_l2 would complete with error, enq_ev would have non-descriptive error code
      Result.Item1 := ev_l2 + enq_ev;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static function Invoke<T>(
      enq_c: integer;
      o_const: boolean; get_o: ()->T;
      {$ifdef DEBUG}cancel_o_qr: Action;{$endif}
      g: CLTaskGlobalData; l: CLTaskLocalData;
      invoke_params: InvokeParamsFunc<T>;
      on_err: clErrorCode->()
      {$ifdef DEBUG}; q: object{$endif}
    ): EnqRes;
    begin
      var pre_enq_had_insta_err := g.had_insta_err;
      g.had_insta_err := false;
      
      // Can extract or skip
      // For now skipping, as extracting known handler doesn't seem to help
      var origin_err_handler := g.curr_err_handler.TrySkipFunc;//.Extract({$ifdef DEBUG}false{$endif});
      g.curr_err_handler := LazyErrHandler.InvalidFunc;
      
      // L1 events need to be waited before running enq_f
      // L2 events need to be waited before executing what enq_f has enqueued
      var enq_evs := new DoubleList<EventList>(enq_c+1);
      // L1 handlers will be checked in case of can_sync_enq=true
      // Also the .CheckSameSize sanity check...
      // Otherwise, all handlers are combined with origin and enq
      var par_err_handlers := new DoubleList<ErrHandler>(enq_c+2);
      var (cancel_p, enq_f) := invoke_params(enq_c, o_const, g, enq_evs, par_err_handlers);
      {$ifdef DEBUG}
      cancel_p += cancel_o_qr;
      {$endif DEBUG}
      
      if g.had_insta_err then
        pre_enq_had_insta_err := true;
      g.had_insta_err := pre_enq_had_insta_err;
      
      var can_sync_enq := enq_evs.L1Empty and o_const;
      
      // If ExecuteEnqFunc (and so prev_qr.GetRes) is insta-called,
      // there is no point in creating another event for actions
      var start_ev := if can_sync_enq then l.prev_ev else
        l.AttachInvokeActions(g{$ifdef EventDebug}, l{$endif});
      
      // If o_const=true, no point in waiting for start_ev,
      // enq as fast as possible, even if can_sync_enq=false
      // If o_const=false, need to wait for start_ev before calling get_o
      if start_ev.count=0 then
        {$ifdef DEBUG}enq_evs.FakeAdd(not o_const){$endif} else
        enq_evs.Add(start_ev, not o_const);
      
      // Only check for origin errors during async enq, if start_ev was waited for in ev_l1
      // In other words: (HPQ + CQ(M)).MakeCCQ
      // Here enq may be sync, but HPQ completes and sets event after enq
      // Thread-less HPQ can add error before enq, but that error will be in g.had_insta_err
      // Threaded HPQ can only add error in origin_err_handler, which doesn't need to be checked before const get_o
      if origin_err_handler=nil then
        {$ifdef DEBUG}par_err_handlers.FakeAdd(not o_const){$endif} else
        par_err_handlers.Add(origin_err_handler, not o_const);
      {$ifdef DEBUG}
      enq_evs.CheckSameSize(par_err_handlers);
      {$endif DEBUG}
      
      // Can only use origin_err_handler if origin has no prev handlers
      // Otherwise, need separate eh from origin, because origin can have unfinished nested errors
      // (HPQ(wh.Wait) + CQ(a)).MakeCCQ.ThenWriteArray(HFQQ(()->nil, false))
      var enq_err_handler := (origin_err_handler as ErrHandlerInitial) ??
        new ErrHandlerInitial({$ifdef DEBUG}'ExecuteEnqFunc container'{$endif});
      if enq_err_handler=origin_err_handler then
        {$ifdef DEBUG}par_err_handlers.FakeAdd(false){$endif} else
        par_err_handlers.AddL2(enq_err_handler);
      
      //TODO #2976
      var (ev_l1, ev_l2) := enq_evs.Combine(EventList.Combine&<ArraySegment<EventList>>);
      
      // When need_async_inv, cq needs to be secured for thread safety
      // Otherwise, next command can be written before current one
      //TODO Created even if par_err_handlers.l1 had errors
      var cq := g.GetCQ(not can_sync_enq);
      {$ifdef QueueDebug}
      QueueDebug.Add(cq, TypeName(q));
      {$endif QueueDebug}
      
      {$ifdef DEBUG}
      var err_test_reason := $'[{q.GetHashCode}]:{TypeName(q)}.ExecuteEnqFunc';
      enq_err_handler.AddMaybeError(err_test_reason);
      {$endif DEBUG}
      
      g.curr_err_handler :=
        ErrHandlerBranchCombinator.Wrap(
          LazyErrHandler.InvalidFunc, par_err_handlers.GetAll
          {$ifdef DEBUG}, $'{TypeName(q)} origin+par+enq union'{$endif}
        );
      var final_err_handler := g.curr_err_handler.TrySkipFunc;
      
      if can_sync_enq then
      begin
        {$ifdef DEBUG}
        if ev_l1.count<>0 then
          raise new OpenCLABCInternalException($'');
        if par_err_handlers.L1Any(h->true) then
          raise new OpenCLABCInternalException($'');
        {$endif DEBUG}
        l.prev_delegate.Invoke(g.c);
        Result := ExecuteEnqFunc(
          get_o(), cq, ev_l2, {$ifdef DEBUG}cancel_p, {$endif}enq_f, pre_enq_had_insta_err, enq_err_handler
          {$ifdef DEBUG}, err_test_reason{$endif}{$ifdef EventDebug}, q{$endif}
        );
      end else
      begin
        var res_ev := new UserEvent(g.cl_c
          {$ifdef EventDebug}, $'{TypeName(q)}, temp for nested AttachCallback: [{ev_l1.evs?.JoinToString}], then [{ev_l2.evs?.JoinToString}]'{$endif}
        );
        var l1_had_err := pre_enq_had_insta_err;
        
        ev_l1.MultiAttachCallback(()->
        begin
          if par_err_handlers.L1Any(h->h.HadError) then
            l1_had_err := true;
          var (enq_ev, post_enq_act) := ExecuteEnqFunc(
            get_o(), cq, ev_l2, {$ifdef DEBUG}cancel_p, {$endif}enq_f, l1_had_err, enq_err_handler
            {$ifdef DEBUG}, err_test_reason{$endif}{$ifdef EventDebug}, q{$endif}
          );
          OpenCLABCInternalException.RaiseIfError( cl.Flush(cq) );
          enq_ev.MultiAttachCallback(()->
          begin
            if post_enq_act<>nil then post_enq_act(g.c);
            g.ReturnCQ(cq);
            res_ev.SetComplete((final_err_handler<>nil) and final_err_handler.HadError);
          end{$ifdef EventDebug}, $'propagating Enq ev of {TypeName(q)} to res_ev: {res_ev.uev}'{$endif});
        end{$ifdef EventDebug}, $'calling async Enq of {TypeName(q)}'{$endif});
        
        Result := new EnqRes(res_ev, nil);
      end;
      
    end;
    
  end;
  
{$endregion Core}

{$region GPUCommand}

type
  EnqueueableGPUCommand<T> = abstract class(GPUCommand<T>)
    
    protected function TryPreCall(q: CommandQueue<T>): boolean; override := false;
    
    protected function ExpectedEnqCount: integer; abstract;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<T>; abstract;
    protected procedure ProcessError(ec: clErrorCode);
    begin
      var TODO := 0; //TODO abstract
    end;
    
    protected function Invoke(dep_ok: boolean; inp: CommandQueue<T>; g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil; override;
    begin
      var get_o: ()->T;
      var o_const: boolean;
      {$ifdef DEBUG}
      var cancel_o_qr := default(Action);
      {$endif DEBUG}
      if dep_ok then
      begin
        get_o := ()->inp.expected_const_res;
        o_const := true;
      end else
      begin
        var prev_qr := inp.InvokeToAny(g, l);
        l := prev_qr.TakeBaseOut;
        get_o := prev_qr.GetResDirect;
        o_const := prev_qr.IsConst;
        {$ifdef DEBUG}
        cancel_o_qr := ()->prev_qr.CancelStatusCheck('enq o cancel');
        {$endif DEBUG}
      end;
      
      var (enq_ev, post_enq_act) := EnqueueableCore.Invoke(
        self.ExpectedEnqCount, o_const, get_o, {$ifdef DEBUG}cancel_o_qr, {$endif}g, l,
        InvokeParams, ProcessError
        {$ifdef DEBUG},self{$endif}
      );
      
      Result := new QueueResNil(enq_ev);
      if post_enq_act<>nil then Result.AddAction(post_enq_act);
    end;
    
  end;
  
{$endregion GPUCommand}

{$region ExecCommand}

type
  ExecCommandCLKernelCacheEntry = record
    k: CLKernel;
    cache: CLKernelArgCache;
    last_use: TimeSpan;
    static last_use_timer := Stopwatch.StartNew;
    
    procedure Bump := last_use := last_use_timer.Elapsed;
    
    procedure TryRelease({$ifdef ExecDebug}command: object{$endif}) := if k<>nil then
    begin
      {$ifdef ExecDebug}
      ExecDebug.RegisterExecCacheTry(command, false, $'For {k} returned {cache.ntv}');
      {$endif ExecDebug}
      cache.Release(k);
    end;
    procedure Replace(k: CLKernel; cache: CLKernelArgCache{$ifdef ExecDebug}; command: object{$endif});
    begin
      self.TryRelease({$ifdef ExecDebug}command{$endif});
      self.k := k;
      self.cache := cache;
      self.Bump;
    end;
    
  end;
  ExecCommandCLKernelCache = record
    private const cache_size = 16;
    
    private data := new ExecCommandCLKernelCacheEntry[cache_size];
    private data_ind := new Dictionary<CLKernel, integer>(cache_size);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function GetArgCache(k: CLKernel; make_new: CLKernel->CLKernelArgCache{$ifdef ExecDebug}; command: object{$endif}): CLKernelArgCache;
    begin
      lock data do
      begin
        
        var ind := 0;
        if data_ind.TryGetValue(k, ind) then
        begin
          data[ind].Bump;
          Result := data[ind].cache;
          {$ifdef ExecDebug}
          ExecDebug.RegisterExecCacheTry(command, false, $'For {k} taken {Result.ntv}');
          {$endif ExecDebug}
        end else
        
        begin
          for var i := 1 to cache_size-1 do
            if data[i].last_use<data[ind].last_use then
              ind := i;
          Result := make_new(k);
          data[ind].Replace(k, Result{$ifdef ExecDebug}, command{$endif});
          data_ind[k] := ind;
          {$ifdef ExecDebug}
          ExecDebug.RegisterExecCacheTry(command, true, $'For {k} made {Result.ntv}');
          {$endif ExecDebug}
        end;
        
      end;
    end;
    
    public procedure Release({$ifdef ExecDebug}command: object{$endif});
    begin
      if data=nil then raise new OpenCLABCInternalException($'');
      for var i := 0 to cache_size-1 do
        data[i].TryRelease({$ifdef ExecDebug}command{$endif});
      data := nil;
      data_ind := nil;
    end;
    
  end;
  
  EnqueueableExecCommand = abstract class(GPUCommand<CLKernel>, IDisposable)
    private args: array of CLKernelArg;
    private const_args_setters: array of CLKernelArgSetter;
    private args_c, args_non_const_c: integer;
    {$ifdef ExecDebug}
    private static All := new ConcurrentBag<EnqueueableExecCommand>;
    {$endif ExecDebug}
    
    protected constructor(args: array of CLKernelArg);
    begin
      {$ifdef ExecDebug}
      All.Add(self);
      {$endif ExecDebug}
      args := args.ToArray;
      self.args := args;
      self.const_args_setters := new CLKernelArgSetter[args.Length];
      self.args_c := args.Length;
      self.args_non_const_c := args.Length;
      for var i := 0 to args_c-1 do
      begin
        var setter := args[i].TryGetConstSetter;
        if setter=nil then continue;
        args_non_const_c -= 1;
        const_args_setters[i] := setter;
        args[i] := nil;
      end;
      if args_non_const_c=0 then
        self.args := nil else
      if args_non_const_c=args_c then
        self.const_args_setters := nil;
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    private procedure ApplyConstArgsTo(arg_cache: CLKernelArgCache);
    begin
      if const_args_setters=nil then exit;
      for var i := 0 to args_c-1 do
      begin
        if const_args_setters[i]=nil then continue;
        const_args_setters[i].Apply(i, arg_cache);
      end;
    end;
    
    private k_cache := new ExecCommandCLKernelCache;
    private function GetArgCache(k: CLKernel) :=
    k_cache.GetArgCache(k, k->
    begin
      Result := new CLKernelArgCache(k, self.args_c);
      ApplyConstArgsTo(Result);
    end{$ifdef ExecDebug}, self{$endif});
    
    protected function TryPreCall(q: CommandQueue<CLKernel>): boolean; override;
    begin
      Result := false;
      if q.const_res_dep=nil then exit;
      GetArgCache(q.expected_const_res); // Auto calls ApplyConstArgsTo
    end;
    
    protected function ExpectedEnqCount: integer; abstract;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>; get_arg_cache: ()->CLKernelArgCache): ParamInvRes<cl_kernel>; abstract;
    protected procedure ProcessError(ec: clErrorCode);
    begin
      var TODO := 0; //TODO abstract
    end;
    
    {$region DerCommon}
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function InvokeArgs(inv: CLTaskBranchInvoker; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): array of CLKernelArgSetter;
    begin
      if args=nil then exit;
      Result := new CLKernelArgSetter[self.args_c];
      for var i := 0 to self.args_c-1 do
      begin
        if args[i]=nil then continue;
        var (arg_setter, arg_ev) := self.args[i].Invoke(inv, par_err_handlers);
        Result[i] := arg_setter;
        
        var to_l1 := not arg_setter.IsConst;
        if arg_ev.count=0 then
          {$ifdef DEBUG}enq_evs.FakeAdd(to_l1){$endif} else
          enq_evs.Add(arg_ev, to_l1);
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    procedure ApplySetters(cache: CLKernelArgCache; setters: array of CLKernelArgSetter);
    begin
      if setters=nil then exit;
      for var i := 0 to self.args_c-1 do
      begin
        if setters[i]=nil then continue;
        setters[i].Apply(i, cache);
      end;
    end;
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    procedure KeepArgsGCAlive := GC.KeepAlive(self.args);
    
    {$endregion DerCommon}
    
    protected function Invoke(dep_ok: boolean; inp: CommandQueue<CLKernel>; g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil; override;
    begin
      var k_const: boolean;
      var get_k: ()->CLKernel;
      {$ifdef DEBUG}
      var cancel_k_qr := default(Action);
      {$endif DEBUG}
      if dep_ok then
      begin
        k_const := true;
        get_k := ()->inp.expected_const_res;
      end else
      begin
        var prev_qr := inp.InvokeToAny(g, l);
        l := prev_qr.TakeBaseOut;
        k_const := prev_qr.IsConst;
        get_k := prev_qr.GetResDirect;
        {$ifdef DEBUG}
        cancel_k_qr := ()->prev_qr.CancelStatusCheck('enq k cancel');
        {$endif DEBUG}
      end;
      
      var get_k_ntv: ()->cl_kernel;
      var arg_cache := default(CLKernelArgCache);
      if k_const then
      begin
        arg_cache := self.GetArgCache(get_k);
        get_k_ntv := ()->arg_cache.ntv;
      end else
        get_k_ntv := ()->
        begin
          arg_cache := self.GetArgCache(get_k);
          Result := arg_cache.ntv;
        end;
      
      //TODO Надо ли "()->" перед arg_cache? Разница в том что:
      // - Без "()->" его будет читать прямо перед вызовом InvokeParams
      // - А сейчас его считает аж в EnqFunc<cl_kernel>
      var (enq_ev, post_enq_act) := EnqueueableCore.Invoke(
        self.ExpectedEnqCount+args_non_const_c, k_const, get_k_ntv, {$ifdef DEBUG}cancel_k_qr, {$endif}g, l,
        (enq_c, o_const, g, enq_evs, par_err_handlers)->
          InvokeParams(enq_c, o_const, g, enq_evs, par_err_handlers, ()->arg_cache),
        ProcessError
        {$ifdef DEBUG},self{$endif}
      );
      
      Result := new QueueResNil(enq_ev);
      if post_enq_act<>nil then Result.AddAction(post_enq_act);
    end;
    
    public procedure Dispose;
    begin
      if k_cache.data=nil then exit;
      k_cache.Release({$ifdef ExecDebug}self{$endif});
      GC.SuppressFinalize(self);
    end;
    protected procedure Finalize; override := Dispose;
    
  end;
  
{$ifdef ExecDebug}
static procedure ExecDebug.DisposeAllCommands :=
  while true do
  begin
    var c: EnqueueableExecCommand;
    if not EnqueueableExecCommand.All.TryTake(c) then break;
    c.Dispose;
  end;
{$endif ExecDebug}

{$endregion ExecCommand}

{$region GetCommand}

type
  EnqueueableGetCommand<TObj, TRes> = abstract class(CommandQueue<TRes>)
    protected prev_commands: GPUCommandContainer<TObj>;
    
    public constructor(prev_commands: GPUCommandContainer<TObj>) :=
    self.prev_commands := prev_commands;
    
    protected function ExpectedEnqCount: integer; abstract;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>; own_qr: QueueRes<TRes>): ParamInvRes<TObj>; abstract;
    protected procedure ProcessError(ec: clErrorCode);
    begin
      var TODO := 0; //TODO abstract
    end;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; qr_factory: IQueueResFactory<TRes,TR>): TR; where TR: QueueRes<TRes>;
    begin
      Result := qr_factory.MakeDelayed(qr->
      begin
        var prev_qr := prev_commands.InvokeToAny(g, l);
        var inp_const := prev_qr.IsConst;
        l := prev_qr.TakeBaseOut;
        
        var (enq_ev, post_enq_act) := EnqueueableCore.Invoke(
          self.ExpectedEnqCount, inp_const, prev_qr.GetResDirect, {$ifdef DEBUG}()->prev_qr.CancelStatusCheck('enq prev cancel'), {$endif}g, l,
          (enq_c, o_const, g, enq_evs, par_err_handlers)->
            InvokeParams(enq_c, o_const, g, enq_evs, par_err_handlers, qr),
          ProcessError
          {$ifdef DEBUG},self{$endif}
        );
        
        Result := new CLTaskLocalData(enq_ev);
        if post_enq_act<>nil then Result.prev_delegate.AddAction(post_enq_act);
      end);
    end;
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil; override := new QueueResNil(l);
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes   <TRes>; override := Invoke(g, l, qr_val_factory);
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<TRes>; override := Invoke(g, l, qr_ptr_factory);
    
  end;
  
  //TODO Через InvokeParams должно передаваться own_qr: QueueResPtr<TRes>
  // - Для этого надо разделить на GetVal и GetPtr комманды
  EnqueueableGetPtrCommand<TObj, TRes> = abstract class(EnqueueableGetCommand<TObj,TRes>)
    
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes<TRes>; override := InvokeToPtr(g,l);
    
  end;
  
{$endregion GetCommand}

{$region CLKernel}

{$region Implicit}

{$region Exec}

function CLKernel.Exec1(sz1: CommandQueue<integer>; params args: array of CLKernelArg): CLKernel;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenExec1(sz1, args));
end;

function CLKernel.Exec2(sz1,sz2: CommandQueue<integer>; params args: array of CLKernelArg): CLKernel;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenExec2(sz1, sz2, args));
end;

function CLKernel.Exec3(sz1,sz2,sz3: CommandQueue<integer>; params args: array of CLKernelArg): CLKernel;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenExec3(sz1, sz2, sz3, args));
end;

function CLKernel.Exec(global_work_offset, global_work_size, local_work_size: CommandQueue<array of UIntPtr>; params args: array of CLKernelArg): CLKernel;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenExec(global_work_offset, global_work_size, local_work_size, args));
end;

{$endregion Exec}

{$endregion Implicit}

{$region Explicit}

{$region Exec}

{$region Exec1}

type
  CLKernelCommandExec1 = sealed class(EnqueueableExecCommand)
    private  sz1: CommandQueue<integer>;
    private args: array of CLKernelArg;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(sz1: CommandQueue<integer>; params args: array of CLKernelArg);
    begin
      inherited Create(args);
      self. sz1 :=  sz1;
      self.args := args;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      foreach var arg in args do arg.InitBeforeInvoke(g, prev_hubs);
       sz1.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>; get_arg_cache: ()->CLKernelArgCache): ParamInvRes<cl_kernel>; override;
    begin
      var  sz1_qr: QueueRes<integer>;
      var arg_setters: array of CLKernelArgSetter;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
         sz1_qr := invoker.InvokeBranch( sz1.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        arg_setters := self.InvokeArgs(invoker, enq_evs, par_err_handlers);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
         sz1_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var  sz1 :=  sz1_qr.GetResDirect;
        ApplySetters(get_arg_cache(), arg_setters);
        var res_ev: cl_event;
        
        var ec := cl.EnqueueNDRangeKernel(
          cq, o, 1,
          IntPtr.Zero,
          | new UIntPtr(sz1) |[0],
          IntPtr.Zero,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          self.KeepArgsGCAlive;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'sz1:';
      sb += ' ';
      sz1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'args:';
      sb += #10;
      foreach var arg in args do arg.ToString(sb, tabs+1, index, delayed);
      
    end;
    
  end;
  
function CLKernelCCQ.ThenExec1(sz1: CommandQueue<integer>; params args: array of CLKernelArg): CLKernelCCQ;
begin
  Result := AddCommand(self, new CLKernelCommandExec1(sz1, args));
end;

{$endregion Exec1}

{$region Exec2}

type
  CLKernelCommandExec2 = sealed class(EnqueueableExecCommand)
    private  sz1: CommandQueue<integer>;
    private  sz2: CommandQueue<integer>;
    private args: array of CLKernelArg;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    public constructor(sz1,sz2: CommandQueue<integer>; params args: array of CLKernelArg);
    begin
      inherited Create(args);
      self. sz1 :=  sz1;
      self. sz2 :=  sz2;
      self.args := args;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      foreach var arg in args do arg.InitBeforeInvoke(g, prev_hubs);
       sz1.InitBeforeInvoke(g, prev_hubs);
       sz2.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>; get_arg_cache: ()->CLKernelArgCache): ParamInvRes<cl_kernel>; override;
    begin
      var  sz1_qr: QueueRes<integer>;
      var  sz2_qr: QueueRes<integer>;
      var arg_setters: array of CLKernelArgSetter;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
         sz1_qr := invoker.InvokeBranch( sz1.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
         sz2_qr := invoker.InvokeBranch( sz2.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        arg_setters := self.InvokeArgs(invoker, enq_evs, par_err_handlers);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
         sz1_qr.CancelStatusCheck('enq cancel');
         sz2_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var  sz1 :=  sz1_qr.GetResDirect;
        var  sz2 :=  sz2_qr.GetResDirect;
        ApplySetters(get_arg_cache(), arg_setters);
        var res_ev: cl_event;
        
        var ec := cl.EnqueueNDRangeKernel(
          cq, o, 2,
          IntPtr.Zero,
          | new UIntPtr(sz1),new UIntPtr(sz2) |[0],
          IntPtr.Zero,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          self.KeepArgsGCAlive;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'sz1:';
      sb += ' ';
      sz1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'sz2:';
      sb += ' ';
      sz2.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'args:';
      sb += #10;
      foreach var arg in args do arg.ToString(sb, tabs+1, index, delayed);
      
    end;
    
  end;
  
function CLKernelCCQ.ThenExec2(sz1,sz2: CommandQueue<integer>; params args: array of CLKernelArg): CLKernelCCQ;
begin
  Result := AddCommand(self, new CLKernelCommandExec2(sz1, sz2, args));
end;

{$endregion Exec2}

{$region Exec3}

type
  CLKernelCommandExec3 = sealed class(EnqueueableExecCommand)
    private  sz1: CommandQueue<integer>;
    private  sz2: CommandQueue<integer>;
    private  sz3: CommandQueue<integer>;
    private args: array of CLKernelArg;
    
    protected function ExpectedEnqCount: integer; override := 3;
    
    public constructor(sz1,sz2,sz3: CommandQueue<integer>; params args: array of CLKernelArg);
    begin
      inherited Create(args);
      self. sz1 :=  sz1;
      self. sz2 :=  sz2;
      self. sz3 :=  sz3;
      self.args := args;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      foreach var arg in args do arg.InitBeforeInvoke(g, prev_hubs);
       sz1.InitBeforeInvoke(g, prev_hubs);
       sz2.InitBeforeInvoke(g, prev_hubs);
       sz3.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>; get_arg_cache: ()->CLKernelArgCache): ParamInvRes<cl_kernel>; override;
    begin
      var  sz1_qr: QueueRes<integer>;
      var  sz2_qr: QueueRes<integer>;
      var  sz3_qr: QueueRes<integer>;
      var arg_setters: array of CLKernelArgSetter;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
         sz1_qr := invoker.InvokeBranch( sz1.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
         sz2_qr := invoker.InvokeBranch( sz2.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
         sz3_qr := invoker.InvokeBranch( sz3.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        arg_setters := self.InvokeArgs(invoker, enq_evs, par_err_handlers);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
         sz1_qr.CancelStatusCheck('enq cancel');
         sz2_qr.CancelStatusCheck('enq cancel');
         sz3_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var  sz1 :=  sz1_qr.GetResDirect;
        var  sz2 :=  sz2_qr.GetResDirect;
        var  sz3 :=  sz3_qr.GetResDirect;
        ApplySetters(get_arg_cache(), arg_setters);
        var res_ev: cl_event;
        
        var ec := cl.EnqueueNDRangeKernel(
          cq, o, 3,
          IntPtr.Zero,
          | new UIntPtr(sz1),new UIntPtr(sz2),new UIntPtr(sz3) |[0],
          IntPtr.Zero,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          self.KeepArgsGCAlive;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'sz1:';
      sb += ' ';
      sz1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'sz2:';
      sb += ' ';
      sz2.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'sz3:';
      sb += ' ';
      sz3.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'args:';
      sb += #10;
      foreach var arg in args do arg.ToString(sb, tabs+1, index, delayed);
      
    end;
    
  end;
  
function CLKernelCCQ.ThenExec3(sz1,sz2,sz3: CommandQueue<integer>; params args: array of CLKernelArg): CLKernelCCQ;
begin
  Result := AddCommand(self, new CLKernelCommandExec3(sz1, sz2, sz3, args));
end;

{$endregion Exec3}

{$region Exec}

type
  CLKernelCommandExec = sealed class(EnqueueableExecCommand)
    private global_work_offset: CommandQueue<array of UIntPtr>;
    private   global_work_size: CommandQueue<array of UIntPtr>;
    private    local_work_size: CommandQueue<array of UIntPtr>;
    private               args: array of CLKernelArg;
    
    protected function ExpectedEnqCount: integer; override := 3;
    
    public constructor(global_work_offset, global_work_size, local_work_size: CommandQueue<array of UIntPtr>; params args: array of CLKernelArg);
    begin
      inherited Create(args);
      self.global_work_offset := global_work_offset;
      self.  global_work_size :=   global_work_size;
      self.   local_work_size :=    local_work_size;
      self.              args :=               args;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      foreach var arg in args do arg.InitBeforeInvoke(g, prev_hubs);
      global_work_offset.InitBeforeInvoke(g, prev_hubs);
        global_work_size.InitBeforeInvoke(g, prev_hubs);
         local_work_size.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>; get_arg_cache: ()->CLKernelArgCache): ParamInvRes<cl_kernel>; override;
    begin
      var global_work_offset_qr: QueueRes<array of UIntPtr>;
      var   global_work_size_qr: QueueRes<array of UIntPtr>;
      var    local_work_size_qr: QueueRes<array of UIntPtr>;
      var arg_setters: array of CLKernelArgSetter;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        global_work_offset_qr := invoker.InvokeBranch(global_work_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
          global_work_size_qr := invoker.InvokeBranch(  global_work_size.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
           local_work_size_qr := invoker.InvokeBranch(   local_work_size.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        arg_setters := self.InvokeArgs(invoker, enq_evs, par_err_handlers);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        global_work_offset_qr.CancelStatusCheck('enq cancel');
          global_work_size_qr.CancelStatusCheck('enq cancel');
           local_work_size_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var global_work_offset := global_work_offset_qr.GetResDirect;
        var   global_work_size :=   global_work_size_qr.GetResDirect;
        var    local_work_size :=    local_work_size_qr.GetResDirect;
        ApplySetters(get_arg_cache(), arg_setters);
        var res_ev: cl_event;
        
        var ec := cl.EnqueueNDRangeKernel(
          cq, o, global_work_size.Length,
          global_work_offset[0],
          global_work_size[0],
          local_work_size[0],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          self.KeepArgsGCAlive;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'global_work_offset:';
      sb += ' ';
      global_work_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'global_work_size:';
      sb += ' ';
      global_work_size.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'local_work_size:';
      sb += ' ';
      local_work_size.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'args:';
      sb += #10;
      foreach var arg in args do arg.ToString(sb, tabs+1, index, delayed);
      
    end;
    
  end;
  
function CLKernelCCQ.ThenExec(global_work_offset, global_work_size, local_work_size: CommandQueue<array of UIntPtr>; params args: array of CLKernelArg): CLKernelCCQ;
begin
  Result := AddCommand(self, new CLKernelCommandExec(global_work_offset, global_work_size, local_work_size, args));
end;

{$endregion Exec}

{$endregion Exec}

{$endregion Explicit}

{$endregion CLKernel}

{$region CLMemory}

{$region Implicit}

{$region 1#Write&Read}

function CLMemory.WriteValue<TRecord>(val: TRecord): CLMemory; where TRecord: record;
begin
  Result := WriteValue(val, 0);
end;

function CLMemory.WriteValue<TRecord>(val: CommandQueue<TRecord>): CLMemory; where TRecord: record;
begin
  Result := WriteValue(val, 0);
end;

function CLMemory.WriteValue<TRecord>(val: TRecord; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenWriteValue&<TRecord>(val, mem_offset));
end;

function CLMemory.WriteValue<TRecord>(val: CommandQueue<TRecord>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenWriteValue&<TRecord>(val, mem_offset));
end;

function CLMemory.WriteArray1<TRecord>(a: array of TRecord): CLMemory; where TRecord: record;
begin
  Result := WriteArray1(CQ(a));
end;

function CLMemory.WriteArray2<TRecord>(a: array[,] of TRecord): CLMemory; where TRecord: record;
begin
  Result := WriteArray2(CQ(a));
end;

function CLMemory.WriteArray3<TRecord>(a: array[,,] of TRecord): CLMemory; where TRecord: record;
begin
  Result := WriteArray3(CQ(a));
end;

function CLMemory.ReadArray1<TRecord>(a: array of TRecord): CLMemory; where TRecord: record;
begin
  Result := ReadArray1(CQ(a));
end;

function CLMemory.ReadArray2<TRecord>(a: array[,] of TRecord): CLMemory; where TRecord: record;
begin
  Result := ReadArray2(CQ(a));
end;

function CLMemory.ReadArray3<TRecord>(a: array[,,] of TRecord): CLMemory; where TRecord: record;
begin
  Result := ReadArray3(CQ(a));
end;

function CLMemory.WriteArray1<TRecord>(a: array of TRecord; a_ind, el_count, mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := WriteArray1(CQ(a), a_ind, el_count, mem_offset);
end;

function CLMemory.WriteArray2<TRecord>(a: array[,] of TRecord; a_ind1,a_ind2, el_count, mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := WriteArray2(CQ(a), a_ind1,a_ind2, el_count, mem_offset);
end;

function CLMemory.WriteArray3<TRecord>(a: array[,,] of TRecord; a_ind1,a_ind2,a_ind3, el_count, mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := WriteArray3(CQ(a), a_ind1,a_ind2,a_ind3, el_count, mem_offset);
end;

function CLMemory.ReadArray1<TRecord>(a: array of TRecord; a_ind, el_count, mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := ReadArray1(CQ(a), a_ind, el_count, mem_offset);
end;

function CLMemory.ReadArray2<TRecord>(a: array[,] of TRecord; a_ind1,a_ind2, el_count, mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := ReadArray2(CQ(a), a_ind1,a_ind2, el_count, mem_offset);
end;

function CLMemory.ReadArray3<TRecord>(a: array[,,] of TRecord; a_ind1,a_ind2,a_ind3, el_count, mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := ReadArray3(CQ(a), a_ind1,a_ind2,a_ind3, el_count, mem_offset);
end;

function CLMemory.WriteArray1<TRecord>(a: CommandQueue<array of TRecord>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenWriteArray1&<TRecord>(a));
end;

function CLMemory.WriteArray2<TRecord>(a: CommandQueue<array[,] of TRecord>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenWriteArray2&<TRecord>(a));
end;

function CLMemory.WriteArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenWriteArray3&<TRecord>(a));
end;

function CLMemory.ReadArray1<TRecord>(a: CommandQueue<array of TRecord>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenReadArray1&<TRecord>(a));
end;

function CLMemory.ReadArray2<TRecord>(a: CommandQueue<array[,] of TRecord>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenReadArray2&<TRecord>(a));
end;

function CLMemory.ReadArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenReadArray3&<TRecord>(a));
end;

function CLMemory.WriteArray1<TRecord>(a: CommandQueue<array of TRecord>; a_ind, el_count, mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenWriteArray1&<TRecord>(a, a_ind, el_count, mem_offset));
end;

function CLMemory.WriteArray2<TRecord>(a: CommandQueue<array[,] of TRecord>; a_ind1,a_ind2, el_count, mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenWriteArray2&<TRecord>(a, a_ind1, a_ind2, el_count, mem_offset));
end;

function CLMemory.WriteArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>; a_ind1,a_ind2,a_ind3, el_count, mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenWriteArray3&<TRecord>(a, a_ind1, a_ind2, a_ind3, el_count, mem_offset));
end;

function CLMemory.ReadArray1<TRecord>(a: CommandQueue<array of TRecord>; a_ind, el_count, mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenReadArray1&<TRecord>(a, a_ind, el_count, mem_offset));
end;

function CLMemory.ReadArray2<TRecord>(a: CommandQueue<array[,] of TRecord>; a_ind1,a_ind2, el_count, mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenReadArray2&<TRecord>(a, a_ind1, a_ind2, el_count, mem_offset));
end;

function CLMemory.ReadArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>; a_ind1,a_ind2,a_ind3, el_count, mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenReadArray3&<TRecord>(a, a_ind1, a_ind2, a_ind3, el_count, mem_offset));
end;

function CLMemory.WriteArraySegment<TRecord>(a: ArraySegment<TRecord>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := WriteArray1(CQ(a.Array), a.Offset, a.Count, mem_offset);
end;

function CLMemory.ReadArraySegment<TRecord>(a: ArraySegment<TRecord>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := ReadArray1(CQ(a.Array), a.Offset, a.Count, mem_offset);
end;

function CLMemory.WriteData(ptr: CommandQueue<IntPtr>): CLMemory;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenWriteData(ptr));
end;

function CLMemory.WriteData(ptr: CommandQueue<IntPtr>; mem_offset, len: CommandQueue<integer>): CLMemory;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenWriteData(ptr, mem_offset, len));
end;

function CLMemory.ReadData(ptr: CommandQueue<IntPtr>): CLMemory;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenReadData(ptr));
end;

function CLMemory.ReadData(ptr: CommandQueue<IntPtr>; mem_offset, len: CommandQueue<integer>): CLMemory;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenReadData(ptr, mem_offset, len));
end;

function CLMemory.WriteData(ptr: pointer): CLMemory;
begin
  Result := WriteData(IntPtr(ptr));
end;

function CLMemory.WriteData(ptr: pointer; mem_offset, len: CommandQueue<integer>): CLMemory;
begin
  Result := WriteData(IntPtr(ptr), mem_offset, len);
end;

function CLMemory.ReadData(ptr: pointer): CLMemory;
begin
  Result := ReadData(IntPtr(ptr));
end;

function CLMemory.ReadData(ptr: pointer; mem_offset, len: CommandQueue<integer>): CLMemory;
begin
  Result := ReadData(IntPtr(ptr), mem_offset, len);
end;

function CLMemory.WriteNativeMemoryArea(native_data: NativeMemoryArea): CLMemory;
begin
  Result := WriteNativeMemoryArea(CQ(native_data), 0);
end;

function CLMemory.WriteNativeMemoryArea(native_data: NativeMemoryArea; mem_offset: CommandQueue<integer>): CLMemory;
begin
  Result := WriteNativeMemoryArea(CQ(native_data), mem_offset);
end;

function CLMemory.WriteNativeMemory(native_data: NativeMemory): CLMemory;
begin
  Result := WriteNativeMemory(CQ(native_data), 0);
end;

function CLMemory.WriteNativeMemory(native_data: NativeMemory; mem_offset: CommandQueue<integer>): CLMemory;
begin
  Result := WriteNativeMemory(CQ(native_data), mem_offset);
end;

function CLMemory.WriteNativeValueArea<TRecord>(native_data: NativeValueArea<TRecord>): CLMemory; where TRecord: record;
begin
  Result := WriteNativeValueArea(CQ(native_data), 0);
end;

function CLMemory.WriteNativeValueArea<TRecord>(native_data: NativeValueArea<TRecord>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := WriteNativeValueArea(CQ(native_data), mem_offset);
end;

function CLMemory.WriteNativeValue<TRecord>(native_data: NativeValue<TRecord>): CLMemory; where TRecord: record;
begin
  Result := WriteNativeValue(CQ(native_data), 0);
end;

function CLMemory.WriteNativeValue<TRecord>(native_data: NativeValue<TRecord>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := WriteNativeValue(CQ(native_data), mem_offset);
end;

function CLMemory.WriteNativeArrayArea<TRecord>(native_data: NativeArrayArea<TRecord>): CLMemory; where TRecord: record;
begin
  Result := WriteNativeArrayArea(CQ(native_data), 0);
end;

function CLMemory.WriteNativeArrayArea<TRecord>(native_data: NativeArrayArea<TRecord>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := WriteNativeArrayArea(CQ(native_data), mem_offset);
end;

function CLMemory.WriteNativeArray<TRecord>(native_data: NativeArray<TRecord>): CLMemory; where TRecord: record;
begin
  Result := WriteNativeArray(CQ(native_data), 0);
end;

function CLMemory.WriteNativeArray<TRecord>(native_data: NativeArray<TRecord>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := WriteNativeArray(CQ(native_data), mem_offset);
end;

function CLMemory.ReadNativeMemoryArea(native_data: NativeMemoryArea): CLMemory;
begin
  Result := ReadNativeMemoryArea(CQ(native_data), 0);
end;

function CLMemory.ReadNativeMemoryArea(native_data: NativeMemoryArea; mem_offset: CommandQueue<integer>): CLMemory;
begin
  Result := ReadNativeMemoryArea(CQ(native_data), mem_offset);
end;

function CLMemory.ReadNativeMemory(native_data: NativeMemory): CLMemory;
begin
  Result := ReadNativeMemory(CQ(native_data), 0);
end;

function CLMemory.ReadNativeMemory(native_data: NativeMemory; mem_offset: CommandQueue<integer>): CLMemory;
begin
  Result := ReadNativeMemory(CQ(native_data), mem_offset);
end;

function CLMemory.ReadNativeValueArea<TRecord>(native_data: NativeValueArea<TRecord>): CLMemory; where TRecord: record;
begin
  Result := ReadNativeValueArea(CQ(native_data), 0);
end;

function CLMemory.ReadNativeValueArea<TRecord>(native_data: NativeValueArea<TRecord>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := ReadNativeValueArea(CQ(native_data), mem_offset);
end;

function CLMemory.ReadNativeValue<TRecord>(native_data: NativeValue<TRecord>): CLMemory; where TRecord: record;
begin
  Result := ReadNativeValue(CQ(native_data), 0);
end;

function CLMemory.ReadNativeValue<TRecord>(native_data: NativeValue<TRecord>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := ReadNativeValue(CQ(native_data), mem_offset);
end;

function CLMemory.ReadNativeArrayArea<TRecord>(native_data: NativeArrayArea<TRecord>): CLMemory; where TRecord: record;
begin
  Result := ReadNativeArrayArea(CQ(native_data), 0);
end;

function CLMemory.ReadNativeArrayArea<TRecord>(native_data: NativeArrayArea<TRecord>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := ReadNativeArrayArea(CQ(native_data), mem_offset);
end;

function CLMemory.ReadNativeArray<TRecord>(native_data: NativeArray<TRecord>): CLMemory; where TRecord: record;
begin
  Result := ReadNativeArray(CQ(native_data), 0);
end;

function CLMemory.ReadNativeArray<TRecord>(native_data: NativeArray<TRecord>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := ReadNativeArray(CQ(native_data), mem_offset);
end;

function CLMemory.WriteNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>): CLMemory;
begin
  Result := WriteNativeMemoryArea(native_data, 0);
end;

function CLMemory.WriteNativeMemory(native_data: CommandQueue<NativeMemory>): CLMemory;
begin
  Result := WriteNativeMemory(native_data, 0);
end;

function CLMemory.WriteNativeValueArea<TRecord>(native_data: CommandQueue<NativeValueArea<TRecord>>): CLMemory; where TRecord: record;
begin
  Result := WriteNativeValueArea(native_data, 0);
end;

function CLMemory.WriteNativeValue<TRecord>(native_data: CommandQueue<NativeValue<TRecord>>): CLMemory; where TRecord: record;
begin
  Result := WriteNativeValue(native_data, 0);
end;

function CLMemory.WriteNativeArrayArea<TRecord>(native_data: CommandQueue<NativeArrayArea<TRecord>>): CLMemory; where TRecord: record;
begin
  Result := WriteNativeArrayArea(native_data, 0);
end;

function CLMemory.WriteNativeArray<TRecord>(native_data: CommandQueue<NativeArray<TRecord>>): CLMemory; where TRecord: record;
begin
  Result := WriteNativeArray(native_data, 0);
end;

function CLMemory.ReadNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>): CLMemory;
begin
  Result := ReadNativeMemoryArea(native_data, 0);
end;

function CLMemory.ReadNativeMemory(native_data: CommandQueue<NativeMemory>): CLMemory;
begin
  Result := ReadNativeMemory(native_data, 0);
end;

function CLMemory.ReadNativeValueArea<TRecord>(native_data: CommandQueue<NativeValueArea<TRecord>>): CLMemory; where TRecord: record;
begin
  Result := ReadNativeValueArea(native_data, 0);
end;

function CLMemory.ReadNativeValue<TRecord>(native_data: CommandQueue<NativeValue<TRecord>>): CLMemory; where TRecord: record;
begin
  Result := ReadNativeValue(native_data, 0);
end;

function CLMemory.ReadNativeArrayArea<TRecord>(native_data: CommandQueue<NativeArrayArea<TRecord>>): CLMemory; where TRecord: record;
begin
  Result := ReadNativeArrayArea(native_data, 0);
end;

function CLMemory.ReadNativeArray<TRecord>(native_data: CommandQueue<NativeArray<TRecord>>): CLMemory; where TRecord: record;
begin
  Result := ReadNativeArray(native_data, 0);
end;

function CLMemory.WriteNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>; mem_offset: CommandQueue<integer>): CLMemory;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenWriteNativeMemoryArea(native_data, mem_offset));
end;

function CLMemory.WriteNativeMemory(native_data: CommandQueue<NativeMemory>; mem_offset: CommandQueue<integer>): CLMemory;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenWriteNativeMemory(native_data, mem_offset));
end;

function CLMemory.WriteNativeValueArea<TRecord>(native_data: CommandQueue<NativeValueArea<TRecord>>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenWriteNativeValueArea&<TRecord>(native_data, mem_offset));
end;

function CLMemory.WriteNativeValue<TRecord>(native_data: CommandQueue<NativeValue<TRecord>>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenWriteNativeValue&<TRecord>(native_data, mem_offset));
end;

function CLMemory.WriteNativeArrayArea<TRecord>(native_data: CommandQueue<NativeArrayArea<TRecord>>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenWriteNativeArrayArea&<TRecord>(native_data, mem_offset));
end;

function CLMemory.WriteNativeArray<TRecord>(native_data: CommandQueue<NativeArray<TRecord>>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenWriteNativeArray&<TRecord>(native_data, mem_offset));
end;

function CLMemory.ReadNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>; mem_offset: CommandQueue<integer>): CLMemory;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenReadNativeMemoryArea(native_data, mem_offset));
end;

function CLMemory.ReadNativeMemory(native_data: CommandQueue<NativeMemory>; mem_offset: CommandQueue<integer>): CLMemory;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenReadNativeMemory(native_data, mem_offset));
end;

function CLMemory.ReadNativeValueArea<TRecord>(native_data: CommandQueue<NativeValueArea<TRecord>>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenReadNativeValueArea&<TRecord>(native_data, mem_offset));
end;

function CLMemory.ReadNativeValue<TRecord>(native_data: CommandQueue<NativeValue<TRecord>>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenReadNativeValue&<TRecord>(native_data, mem_offset));
end;

function CLMemory.ReadNativeArrayArea<TRecord>(native_data: CommandQueue<NativeArrayArea<TRecord>>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenReadNativeArrayArea&<TRecord>(native_data, mem_offset));
end;

function CLMemory.ReadNativeArray<TRecord>(native_data: CommandQueue<NativeArray<TRecord>>; mem_offset: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenReadNativeArray&<TRecord>(native_data, mem_offset));
end;

{$endregion 1#Write&Read}

{$region 2#Fill}

function CLMemory.FillValue<TRecord>(val: TRecord): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillValue&<TRecord>(val));
end;

function CLMemory.FillValue<TRecord>(val: CommandQueue<TRecord>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillValue&<TRecord>(val));
end;

function CLMemory.FillValue<TRecord>(val: TRecord; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillValue&<TRecord>(val, mem_offset, fill_byte_len));
end;

function CLMemory.FillValue<TRecord>(val: CommandQueue<TRecord>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillValue&<TRecord>(val, mem_offset, fill_byte_len));
end;

function CLMemory.FillArray1<TRecord>(a: array of TRecord): CLMemory; where TRecord: record;
begin
  Result := FillArray1(CQ(a));
end;

function CLMemory.FillArray2<TRecord>(a: array[,] of TRecord): CLMemory; where TRecord: record;
begin
  Result := FillArray2(CQ(a));
end;

function CLMemory.FillArray3<TRecord>(a: array[,,] of TRecord): CLMemory; where TRecord: record;
begin
  Result := FillArray3(CQ(a));
end;

function CLMemory.FillArray1<TRecord>(a: array of TRecord; a_ind, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := FillArray1(CQ(a), a_ind, pattern_byte_len, mem_offset, fill_byte_len);
end;

function CLMemory.FillArray2<TRecord>(a: array[,] of TRecord; a_ind1,a_ind2, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := FillArray2(CQ(a), a_ind1,a_ind2, pattern_byte_len, mem_offset, fill_byte_len);
end;

function CLMemory.FillArray3<TRecord>(a: array[,,] of TRecord; a_ind1,a_ind2,a_ind3, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := FillArray3(CQ(a), a_ind1,a_ind2,a_ind3, pattern_byte_len, mem_offset, fill_byte_len);
end;

function CLMemory.FillArray1<TRecord>(a: CommandQueue<array of TRecord>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillArray1&<TRecord>(a));
end;

function CLMemory.FillArray1<TRecord>(a: CommandQueue<array of TRecord>; a_ind, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillArray1&<TRecord>(a, a_ind, pattern_byte_len, mem_offset, fill_byte_len));
end;

function CLMemory.FillArray2<TRecord>(a: CommandQueue<array[,] of TRecord>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillArray2&<TRecord>(a));
end;

function CLMemory.FillArray2<TRecord>(a: CommandQueue<array[,] of TRecord>; a_ind1,a_ind2, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillArray2&<TRecord>(a, a_ind1, a_ind2, pattern_byte_len, mem_offset, fill_byte_len));
end;

function CLMemory.FillArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillArray3&<TRecord>(a));
end;

function CLMemory.FillArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>; a_ind1,a_ind2,a_ind3, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillArray3&<TRecord>(a, a_ind1, a_ind2, a_ind3, pattern_byte_len, mem_offset, fill_byte_len));
end;

function CLMemory.FillArraySegment<TRecord>(a: CommandQueue<ArraySegment<TRecord>>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillArraySegment&<TRecord>(a));
end;

function CLMemory.FillArraySegment<TRecord>(a: CommandQueue<ArraySegment<TRecord>>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillArraySegment&<TRecord>(a, mem_offset, fill_byte_len));
end;

function CLMemory.FillArraySegment<TRecord>(a: ArraySegment<TRecord>): CLMemory; where TRecord: record;
begin
  Result := FillArraySegment(CQ(a));
end;

function CLMemory.FillArraySegment<TRecord>(a: ArraySegment<TRecord>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := FillArraySegment(CQ(a),mem_offset,fill_byte_len);
end;

function CLMemory.FillData(ptr: CommandQueue<IntPtr>; pattern_byte_len: CommandQueue<integer>): CLMemory;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillData(ptr, pattern_byte_len));
end;

function CLMemory.FillData(ptr: CommandQueue<IntPtr>; pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillData(ptr, pattern_byte_len, mem_offset, fill_byte_len));
end;

function CLMemory.FillData(ptr: pointer; pattern_byte_len: CommandQueue<integer>): CLMemory;
begin
  Result := FillData(IntPtr(ptr), pattern_byte_len);
end;

function CLMemory.FillData(ptr: pointer; pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory;
begin
  Result := FillData(IntPtr(ptr), pattern_byte_len, mem_offset, fill_byte_len);
end;

function CLMemory.FillNativeMemoryArea(native_data: NativeMemoryArea): CLMemory;
begin
  Result := FillNativeMemoryArea(CQ(native_data));
end;

function CLMemory.FillNativeMemoryArea(native_data: NativeMemoryArea; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory;
begin
  Result := FillNativeMemoryArea(CQ(native_data),mem_offset,fill_byte_len);
end;

function CLMemory.FillNativeMemory(native_data: NativeMemory): CLMemory;
begin
  Result := FillNativeMemory(CQ(native_data));
end;

function CLMemory.FillNativeMemory(native_data: NativeMemory; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory;
begin
  Result := FillNativeMemory(CQ(native_data),mem_offset,fill_byte_len);
end;

function CLMemory.FillNativeValueArea<TRecord>(native_data: NativeValueArea<TRecord>): CLMemory; where TRecord: record;
begin
  Result := FillNativeValueArea(CQ(native_data));
end;

function CLMemory.FillNativeValueArea<TRecord>(native_data: NativeValueArea<TRecord>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := FillNativeValueArea(CQ(native_data),mem_offset,fill_byte_len);
end;

function CLMemory.FillNativeValue<TRecord>(native_data: NativeValue<TRecord>): CLMemory; where TRecord: record;
begin
  Result := FillNativeValue(CQ(native_data));
end;

function CLMemory.FillNativeValue<TRecord>(native_data: NativeValue<TRecord>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := FillNativeValue(CQ(native_data),mem_offset,fill_byte_len);
end;

function CLMemory.FillNativeArrayArea<TRecord>(native_data: NativeArrayArea<TRecord>): CLMemory; where TRecord: record;
begin
  Result := FillNativeArrayArea(CQ(native_data));
end;

function CLMemory.FillNativeArrayArea<TRecord>(native_data: NativeArrayArea<TRecord>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := FillNativeArrayArea(CQ(native_data),mem_offset,fill_byte_len);
end;

function CLMemory.FillNativeArray<TRecord>(native_data: NativeArray<TRecord>): CLMemory; where TRecord: record;
begin
  Result := FillNativeArray(CQ(native_data));
end;

function CLMemory.FillNativeArray<TRecord>(native_data: NativeArray<TRecord>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := FillNativeArray(CQ(native_data),mem_offset,fill_byte_len);
end;

function CLMemory.FillNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>): CLMemory;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillNativeMemoryArea(native_data));
end;

function CLMemory.FillNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillNativeMemoryArea(native_data, mem_offset, fill_byte_len));
end;

function CLMemory.FillNativeMemory(native_data: CommandQueue<NativeMemory>): CLMemory;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillNativeMemory(native_data));
end;

function CLMemory.FillNativeMemory(native_data: CommandQueue<NativeMemory>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillNativeMemory(native_data, mem_offset, fill_byte_len));
end;

function CLMemory.FillNativeValueArea<TRecord>(native_data: CommandQueue<NativeValueArea<TRecord>>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillNativeValueArea&<TRecord>(native_data));
end;

function CLMemory.FillNativeValueArea<TRecord>(native_data: CommandQueue<NativeValueArea<TRecord>>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillNativeValueArea&<TRecord>(native_data, mem_offset, fill_byte_len));
end;

function CLMemory.FillNativeValue<TRecord>(native_data: CommandQueue<NativeValue<TRecord>>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillNativeValue&<TRecord>(native_data));
end;

function CLMemory.FillNativeValue<TRecord>(native_data: CommandQueue<NativeValue<TRecord>>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillNativeValue&<TRecord>(native_data, mem_offset, fill_byte_len));
end;

function CLMemory.FillNativeArrayArea<TRecord>(native_data: CommandQueue<NativeArrayArea<TRecord>>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillNativeArrayArea&<TRecord>(native_data));
end;

function CLMemory.FillNativeArrayArea<TRecord>(native_data: CommandQueue<NativeArrayArea<TRecord>>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillNativeArrayArea&<TRecord>(native_data, mem_offset, fill_byte_len));
end;

function CLMemory.FillNativeArray<TRecord>(native_data: CommandQueue<NativeArray<TRecord>>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillNativeArray&<TRecord>(native_data));
end;

function CLMemory.FillNativeArray<TRecord>(native_data: CommandQueue<NativeArray<TRecord>>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemory; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillNativeArray&<TRecord>(native_data, mem_offset, fill_byte_len));
end;

{$endregion 2#Fill}

{$region 3#Copy}

function CLMemory.CopyTo(mem: CommandQueue<CLMemory>): CLMemory;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenCopyTo(mem));
end;

function CLMemory.CopyTo(mem: CommandQueue<CLMemory>; from_offset, to_offset, len: CommandQueue<integer>): CLMemory;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenCopyTo(mem, from_offset, to_offset, len));
end;

function CLMemory.CopyFrom(mem: CommandQueue<CLMemory>): CLMemory;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenCopyFrom(mem));
end;

function CLMemory.CopyFrom(mem: CommandQueue<CLMemory>; from_offset, to_offset, len: CommandQueue<integer>): CLMemory;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenCopyFrom(mem, from_offset, to_offset, len));
end;

{$endregion 3#Copy}

{$region Get}

function CLMemory.GetValue<TRecord>: TRecord; where TRecord: record;
begin
  Result := GetValue&<TRecord>(0);
end;

function CLMemory.GetValue<TRecord>(mem_offset: CommandQueue<integer>): TRecord; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenGetValue&<TRecord>(mem_offset));
end;

function CLMemory.GetArray<TRecord>: array of TRecord; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenGetArray&<TRecord>);
end;

function CLMemory.GetArray<TRecord>(len: CommandQueue<integer>): array of TRecord; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenGetArray&<TRecord>(len));
end;

function CLMemory.GetArray2<TRecord>(len1,len2: CommandQueue<integer>): array[,] of TRecord; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenGetArray2&<TRecord>(len1, len2));
end;

function CLMemory.GetArray3<TRecord>(len1,len2,len3: CommandQueue<integer>): array[,,] of TRecord; where TRecord: record;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenGetArray3&<TRecord>(len1, len2, len3));
end;

{$endregion Get}

{$endregion Implicit}

{$region Explicit}

{$region 1#Write&Read}

{$region WriteValue}

function CLMemoryCCQ.ThenWriteValue<TRecord>(val: TRecord): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenWriteValue(val, 0);
end;

{$endregion WriteValue}

{$region WriteValue!Q}

function CLMemoryCCQ.ThenWriteValue<TRecord>(val: CommandQueue<TRecord>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenWriteValue(val, 0);
end;

{$endregion WriteValue!Q}

{$region WriteValue}

type
  CLMemoryCommandWriteValue<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private        val := new NativeValueArea<TRecord>(true);
    private mem_offset: CommandQueue<integer>;
    
    protected procedure Finalize; override;
    begin
      val.Release;
    end;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'записывать в область памяти OpenCL');
    end;
    public constructor(val: TRecord; mem_offset: CommandQueue<integer>);
    begin
      self.       val.Value :=        val;
      self.mem_offset       := mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var mem_offset_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        mem_offset_qr := invoker.InvokeBranch(mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        mem_offset_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var mem_offset := mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(mem_offset), new UIntPtr(Marshal.SizeOf(default(TRecord))),
          val.Pointer,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      sb.Append(val.Value);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenWriteValue<TRecord>(val: TRecord; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandWriteValue<TRecord>(val, mem_offset));
end;

{$endregion WriteValue}

{$region WriteValue!Q}

type
  CLMemoryCommandWriteValueQ<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private        val: CommandQueue<TRecord>;
    private mem_offset: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'записывать в область памяти OpenCL');
    end;
    public constructor(val: CommandQueue<TRecord>; mem_offset: CommandQueue<integer>);
    begin
      self.       val :=        val;
      self.mem_offset := mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
             val.InitBeforeInvoke(g, prev_hubs);
      mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var        val_qr: QueueResPtr<TRecord>;
      var mem_offset_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        mem_offset_qr := invoker.InvokeBranch(mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
               val_qr := invoker.InvokeBranch(       val.InvokeToPtr, par_err_handlers, False).AddToEvLst(g, enq_evs, False);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
               val_qr.CancelStatusCheck('enq cancel');
        mem_offset_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var        val :=        val_qr.GetResPtrForRead;
        var mem_offset := mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(mem_offset), new UIntPtr(Marshal.SizeOf(default(TRecord))),
          val,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          GC.KeepAlive(val_qr);
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      val.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenWriteValue<TRecord>(val: CommandQueue<TRecord>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandWriteValueQ<TRecord>(val, mem_offset));
end;

{$endregion WriteValue!Q}

{$region WriteArray1!AutoSize}

function CLMemoryCCQ.ThenWriteArray1<TRecord>(a: array of TRecord): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenWriteArray1(CQ(a));
end;

{$endregion WriteArray1!AutoSize}

{$region WriteArray2!AutoSize}

function CLMemoryCCQ.ThenWriteArray2<TRecord>(a: array[,] of TRecord): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenWriteArray2(CQ(a));
end;

{$endregion WriteArray2!AutoSize}

{$region WriteArray3!AutoSize}

function CLMemoryCCQ.ThenWriteArray3<TRecord>(a: array[,,] of TRecord): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenWriteArray3(CQ(a));
end;

{$endregion WriteArray3!AutoSize}

{$region ReadArray1!AutoSize}

function CLMemoryCCQ.ThenReadArray1<TRecord>(a: array of TRecord): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenReadArray1(CQ(a));
end;

{$endregion ReadArray1!AutoSize}

{$region ReadArray2!AutoSize}

function CLMemoryCCQ.ThenReadArray2<TRecord>(a: array[,] of TRecord): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenReadArray2(CQ(a));
end;

{$endregion ReadArray2!AutoSize}

{$region ReadArray3!AutoSize}

function CLMemoryCCQ.ThenReadArray3<TRecord>(a: array[,,] of TRecord): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenReadArray3(CQ(a));
end;

{$endregion ReadArray3!AutoSize}

{$region WriteArray1}

function CLMemoryCCQ.ThenWriteArray1<TRecord>(a: array of TRecord; a_ind, el_count, mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenWriteArray1(CQ(a), a_ind, el_count, mem_offset);
end;

{$endregion WriteArray1}

{$region WriteArray2}

function CLMemoryCCQ.ThenWriteArray2<TRecord>(a: array[,] of TRecord; a_ind1,a_ind2, el_count, mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenWriteArray2(CQ(a), a_ind1,a_ind2, el_count, mem_offset);
end;

{$endregion WriteArray2}

{$region WriteArray3}

function CLMemoryCCQ.ThenWriteArray3<TRecord>(a: array[,,] of TRecord; a_ind1,a_ind2,a_ind3, el_count, mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenWriteArray3(CQ(a), a_ind1,a_ind2,a_ind3, el_count, mem_offset);
end;

{$endregion WriteArray3}

{$region ReadArray1}

function CLMemoryCCQ.ThenReadArray1<TRecord>(a: array of TRecord; a_ind, el_count, mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenReadArray1(CQ(a), a_ind, el_count, mem_offset);
end;

{$endregion ReadArray1}

{$region ReadArray2}

function CLMemoryCCQ.ThenReadArray2<TRecord>(a: array[,] of TRecord; a_ind1,a_ind2, el_count, mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenReadArray2(CQ(a), a_ind1,a_ind2, el_count, mem_offset);
end;

{$endregion ReadArray2}

{$region ReadArray3}

function CLMemoryCCQ.ThenReadArray3<TRecord>(a: array[,,] of TRecord; a_ind1,a_ind2,a_ind3, el_count, mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenReadArray3(CQ(a), a_ind1,a_ind2,a_ind3, el_count, mem_offset);
end;

{$endregion ReadArray3}

{$region WriteArray1!AutoSize}

type
  CLMemoryCommandWriteArray1AutoSize<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private a: CommandQueue<array of TRecord>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'записывать в область памяти OpenCL');
    end;
    public constructor(a: CommandQueue<array of TRecord>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var a_qr: QueueRes<array of TRecord>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        a_qr := invoker.InvokeBranch(a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        a_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        //TODO unable to merge this Enqueue with non-AutoSize, because {-rank-} block would be nested in {-AutoSize-}
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(a.Length*Marshal.SizeOf(default(TRecord))),
          a[0],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenWriteArray1<TRecord>(a: CommandQueue<array of TRecord>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandWriteArray1AutoSize<TRecord>(a));
end;

{$endregion WriteArray1!AutoSize}

{$region WriteArray2!AutoSize}

type
  CLMemoryCommandWriteArray2AutoSize<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private a: CommandQueue<array[,] of TRecord>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'записывать в область памяти OpenCL');
    end;
    public constructor(a: CommandQueue<array[,] of TRecord>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var a_qr: QueueRes<array[,] of TRecord>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        a_qr := invoker.InvokeBranch(a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        a_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        //TODO unable to merge this Enqueue with non-AutoSize, because {-rank-} block would be nested in {-AutoSize-}
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(a.Length*Marshal.SizeOf(default(TRecord))),
          a[0,0],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenWriteArray2<TRecord>(a: CommandQueue<array[,] of TRecord>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandWriteArray2AutoSize<TRecord>(a));
end;

{$endregion WriteArray2!AutoSize}

{$region WriteArray3!AutoSize}

type
  CLMemoryCommandWriteArray3AutoSize<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private a: CommandQueue<array[,,] of TRecord>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'записывать в область памяти OpenCL');
    end;
    public constructor(a: CommandQueue<array[,,] of TRecord>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var a_qr: QueueRes<array[,,] of TRecord>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        a_qr := invoker.InvokeBranch(a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        a_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        //TODO unable to merge this Enqueue with non-AutoSize, because {-rank-} block would be nested in {-AutoSize-}
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(a.Length*Marshal.SizeOf(default(TRecord))),
          a[0,0,0],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenWriteArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandWriteArray3AutoSize<TRecord>(a));
end;

{$endregion WriteArray3!AutoSize}

{$region ReadArray1!AutoSize}

type
  CLMemoryCommandReadArray1AutoSize<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private a: CommandQueue<array of TRecord>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'читать из области памяти OpenCL');
    end;
    public constructor(a: CommandQueue<array of TRecord>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var a_qr: QueueRes<array of TRecord>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        a_qr := invoker.InvokeBranch(a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        a_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        //TODO unable to merge this Enqueue with non-AutoSize, because {-rank-} block would be nested in {-AutoSize-}
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(a.Length*Marshal.SizeOf(default(TRecord))),
          a[0],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenReadArray1<TRecord>(a: CommandQueue<array of TRecord>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandReadArray1AutoSize<TRecord>(a));
end;

{$endregion ReadArray1!AutoSize}

{$region ReadArray2!AutoSize}

type
  CLMemoryCommandReadArray2AutoSize<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private a: CommandQueue<array[,] of TRecord>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'читать из области памяти OpenCL');
    end;
    public constructor(a: CommandQueue<array[,] of TRecord>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var a_qr: QueueRes<array[,] of TRecord>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        a_qr := invoker.InvokeBranch(a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        a_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        //TODO unable to merge this Enqueue with non-AutoSize, because {-rank-} block would be nested in {-AutoSize-}
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(a.Length*Marshal.SizeOf(default(TRecord))),
          a[0,0],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenReadArray2<TRecord>(a: CommandQueue<array[,] of TRecord>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandReadArray2AutoSize<TRecord>(a));
end;

{$endregion ReadArray2!AutoSize}

{$region ReadArray3!AutoSize}

type
  CLMemoryCommandReadArray3AutoSize<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private a: CommandQueue<array[,,] of TRecord>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'читать из области памяти OpenCL');
    end;
    public constructor(a: CommandQueue<array[,,] of TRecord>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var a_qr: QueueRes<array[,,] of TRecord>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        a_qr := invoker.InvokeBranch(a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        a_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        //TODO unable to merge this Enqueue with non-AutoSize, because {-rank-} block would be nested in {-AutoSize-}
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(a.Length*Marshal.SizeOf(default(TRecord))),
          a[0,0,0],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenReadArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandReadArray3AutoSize<TRecord>(a));
end;

{$endregion ReadArray3!AutoSize}

{$region WriteArray1}

type
  CLMemoryCommandWriteArray1<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private          a: CommandQueue<array of TRecord>;
    private      a_ind: CommandQueue<integer>;
    private   el_count: CommandQueue<integer>;
    private mem_offset: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 4;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'записывать в область памяти OpenCL');
    end;
    public constructor(a: CommandQueue<array of TRecord>; a_ind, el_count, mem_offset: CommandQueue<integer>);
    begin
      self.         a :=          a;
      self.     a_ind :=      a_ind;
      self.  el_count :=   el_count;
      self.mem_offset := mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
               a.InitBeforeInvoke(g, prev_hubs);
           a_ind.InitBeforeInvoke(g, prev_hubs);
        el_count.InitBeforeInvoke(g, prev_hubs);
      mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var          a_qr: QueueRes<array of TRecord>;
      var      a_ind_qr: QueueRes<integer>;
      var   el_count_qr: QueueRes<integer>;
      var mem_offset_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
                 a_qr := invoker.InvokeBranch(         a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
             a_ind_qr := invoker.InvokeBranch(     a_ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
          el_count_qr := invoker.InvokeBranch(  el_count.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        mem_offset_qr := invoker.InvokeBranch(mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
                 a_qr.CancelStatusCheck('enq cancel');
             a_ind_qr.CancelStatusCheck('enq cancel');
          el_count_qr.CancelStatusCheck('enq cancel');
        mem_offset_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var          a :=          a_qr.GetResDirect;
        var      a_ind :=      a_ind_qr.GetResDirect;
        var   el_count :=   el_count_qr.GetResDirect;
        var mem_offset := mem_offset_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(mem_offset), new UIntPtr(el_count*Marshal.SizeOf(default(TRecord))),
          a[a_ind],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind:';
      sb += ' ';
      a_ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'el_count:';
      sb += ' ';
      el_count.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenWriteArray1<TRecord>(a: CommandQueue<array of TRecord>; a_ind, el_count, mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandWriteArray1<TRecord>(a, a_ind, el_count, mem_offset));
end;

{$endregion WriteArray1}

{$region WriteArray2}

type
  CLMemoryCommandWriteArray2<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private          a: CommandQueue<array[,] of TRecord>;
    private     a_ind1: CommandQueue<integer>;
    private     a_ind2: CommandQueue<integer>;
    private   el_count: CommandQueue<integer>;
    private mem_offset: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 5;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'записывать в область памяти OpenCL');
    end;
    public constructor(a: CommandQueue<array[,] of TRecord>; a_ind1,a_ind2, el_count, mem_offset: CommandQueue<integer>);
    begin
      self.         a :=          a;
      self.    a_ind1 :=     a_ind1;
      self.    a_ind2 :=     a_ind2;
      self.  el_count :=   el_count;
      self.mem_offset := mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
               a.InitBeforeInvoke(g, prev_hubs);
          a_ind1.InitBeforeInvoke(g, prev_hubs);
          a_ind2.InitBeforeInvoke(g, prev_hubs);
        el_count.InitBeforeInvoke(g, prev_hubs);
      mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var          a_qr: QueueRes<array[,] of TRecord>;
      var     a_ind1_qr: QueueRes<integer>;
      var     a_ind2_qr: QueueRes<integer>;
      var   el_count_qr: QueueRes<integer>;
      var mem_offset_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
                 a_qr := invoker.InvokeBranch(         a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
            a_ind1_qr := invoker.InvokeBranch(    a_ind1.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
            a_ind2_qr := invoker.InvokeBranch(    a_ind2.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
          el_count_qr := invoker.InvokeBranch(  el_count.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        mem_offset_qr := invoker.InvokeBranch(mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
                 a_qr.CancelStatusCheck('enq cancel');
            a_ind1_qr.CancelStatusCheck('enq cancel');
            a_ind2_qr.CancelStatusCheck('enq cancel');
          el_count_qr.CancelStatusCheck('enq cancel');
        mem_offset_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var          a :=          a_qr.GetResDirect;
        var     a_ind1 :=     a_ind1_qr.GetResDirect;
        var     a_ind2 :=     a_ind2_qr.GetResDirect;
        var   el_count :=   el_count_qr.GetResDirect;
        var mem_offset := mem_offset_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(mem_offset), new UIntPtr(el_count*Marshal.SizeOf(default(TRecord))),
          a[a_ind1,a_ind2],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind1:';
      sb += ' ';
      a_ind1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind2:';
      sb += ' ';
      a_ind2.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'el_count:';
      sb += ' ';
      el_count.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenWriteArray2<TRecord>(a: CommandQueue<array[,] of TRecord>; a_ind1,a_ind2, el_count, mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandWriteArray2<TRecord>(a, a_ind1, a_ind2, el_count, mem_offset));
end;

{$endregion WriteArray2}

{$region WriteArray3}

type
  CLMemoryCommandWriteArray3<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private          a: CommandQueue<array[,,] of TRecord>;
    private     a_ind1: CommandQueue<integer>;
    private     a_ind2: CommandQueue<integer>;
    private     a_ind3: CommandQueue<integer>;
    private   el_count: CommandQueue<integer>;
    private mem_offset: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 6;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'записывать в область памяти OpenCL');
    end;
    public constructor(a: CommandQueue<array[,,] of TRecord>; a_ind1,a_ind2,a_ind3, el_count, mem_offset: CommandQueue<integer>);
    begin
      self.         a :=          a;
      self.    a_ind1 :=     a_ind1;
      self.    a_ind2 :=     a_ind2;
      self.    a_ind3 :=     a_ind3;
      self.  el_count :=   el_count;
      self.mem_offset := mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
               a.InitBeforeInvoke(g, prev_hubs);
          a_ind1.InitBeforeInvoke(g, prev_hubs);
          a_ind2.InitBeforeInvoke(g, prev_hubs);
          a_ind3.InitBeforeInvoke(g, prev_hubs);
        el_count.InitBeforeInvoke(g, prev_hubs);
      mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var          a_qr: QueueRes<array[,,] of TRecord>;
      var     a_ind1_qr: QueueRes<integer>;
      var     a_ind2_qr: QueueRes<integer>;
      var     a_ind3_qr: QueueRes<integer>;
      var   el_count_qr: QueueRes<integer>;
      var mem_offset_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
                 a_qr := invoker.InvokeBranch(         a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
            a_ind1_qr := invoker.InvokeBranch(    a_ind1.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
            a_ind2_qr := invoker.InvokeBranch(    a_ind2.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
            a_ind3_qr := invoker.InvokeBranch(    a_ind3.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
          el_count_qr := invoker.InvokeBranch(  el_count.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        mem_offset_qr := invoker.InvokeBranch(mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
                 a_qr.CancelStatusCheck('enq cancel');
            a_ind1_qr.CancelStatusCheck('enq cancel');
            a_ind2_qr.CancelStatusCheck('enq cancel');
            a_ind3_qr.CancelStatusCheck('enq cancel');
          el_count_qr.CancelStatusCheck('enq cancel');
        mem_offset_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var          a :=          a_qr.GetResDirect;
        var     a_ind1 :=     a_ind1_qr.GetResDirect;
        var     a_ind2 :=     a_ind2_qr.GetResDirect;
        var     a_ind3 :=     a_ind3_qr.GetResDirect;
        var   el_count :=   el_count_qr.GetResDirect;
        var mem_offset := mem_offset_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(mem_offset), new UIntPtr(el_count*Marshal.SizeOf(default(TRecord))),
          a[a_ind1,a_ind2,a_ind3],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind1:';
      sb += ' ';
      a_ind1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind2:';
      sb += ' ';
      a_ind2.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind3:';
      sb += ' ';
      a_ind3.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'el_count:';
      sb += ' ';
      el_count.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenWriteArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>; a_ind1,a_ind2,a_ind3, el_count, mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandWriteArray3<TRecord>(a, a_ind1, a_ind2, a_ind3, el_count, mem_offset));
end;

{$endregion WriteArray3}

{$region ReadArray1}

type
  CLMemoryCommandReadArray1<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private          a: CommandQueue<array of TRecord>;
    private      a_ind: CommandQueue<integer>;
    private   el_count: CommandQueue<integer>;
    private mem_offset: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 4;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'читать из области памяти OpenCL');
    end;
    public constructor(a: CommandQueue<array of TRecord>; a_ind, el_count, mem_offset: CommandQueue<integer>);
    begin
      self.         a :=          a;
      self.     a_ind :=      a_ind;
      self.  el_count :=   el_count;
      self.mem_offset := mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
               a.InitBeforeInvoke(g, prev_hubs);
           a_ind.InitBeforeInvoke(g, prev_hubs);
        el_count.InitBeforeInvoke(g, prev_hubs);
      mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var          a_qr: QueueRes<array of TRecord>;
      var      a_ind_qr: QueueRes<integer>;
      var   el_count_qr: QueueRes<integer>;
      var mem_offset_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
                 a_qr := invoker.InvokeBranch(         a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
             a_ind_qr := invoker.InvokeBranch(     a_ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
          el_count_qr := invoker.InvokeBranch(  el_count.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        mem_offset_qr := invoker.InvokeBranch(mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
                 a_qr.CancelStatusCheck('enq cancel');
             a_ind_qr.CancelStatusCheck('enq cancel');
          el_count_qr.CancelStatusCheck('enq cancel');
        mem_offset_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var          a :=          a_qr.GetResDirect;
        var      a_ind :=      a_ind_qr.GetResDirect;
        var   el_count :=   el_count_qr.GetResDirect;
        var mem_offset := mem_offset_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(mem_offset), new UIntPtr(el_count*Marshal.SizeOf(default(TRecord))),
          a[a_ind],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind:';
      sb += ' ';
      a_ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'el_count:';
      sb += ' ';
      el_count.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenReadArray1<TRecord>(a: CommandQueue<array of TRecord>; a_ind, el_count, mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandReadArray1<TRecord>(a, a_ind, el_count, mem_offset));
end;

{$endregion ReadArray1}

{$region ReadArray2}

type
  CLMemoryCommandReadArray2<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private          a: CommandQueue<array[,] of TRecord>;
    private     a_ind1: CommandQueue<integer>;
    private     a_ind2: CommandQueue<integer>;
    private   el_count: CommandQueue<integer>;
    private mem_offset: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 5;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'читать из области памяти OpenCL');
    end;
    public constructor(a: CommandQueue<array[,] of TRecord>; a_ind1,a_ind2, el_count, mem_offset: CommandQueue<integer>);
    begin
      self.         a :=          a;
      self.    a_ind1 :=     a_ind1;
      self.    a_ind2 :=     a_ind2;
      self.  el_count :=   el_count;
      self.mem_offset := mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
               a.InitBeforeInvoke(g, prev_hubs);
          a_ind1.InitBeforeInvoke(g, prev_hubs);
          a_ind2.InitBeforeInvoke(g, prev_hubs);
        el_count.InitBeforeInvoke(g, prev_hubs);
      mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var          a_qr: QueueRes<array[,] of TRecord>;
      var     a_ind1_qr: QueueRes<integer>;
      var     a_ind2_qr: QueueRes<integer>;
      var   el_count_qr: QueueRes<integer>;
      var mem_offset_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
                 a_qr := invoker.InvokeBranch(         a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
            a_ind1_qr := invoker.InvokeBranch(    a_ind1.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
            a_ind2_qr := invoker.InvokeBranch(    a_ind2.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
          el_count_qr := invoker.InvokeBranch(  el_count.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        mem_offset_qr := invoker.InvokeBranch(mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
                 a_qr.CancelStatusCheck('enq cancel');
            a_ind1_qr.CancelStatusCheck('enq cancel');
            a_ind2_qr.CancelStatusCheck('enq cancel');
          el_count_qr.CancelStatusCheck('enq cancel');
        mem_offset_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var          a :=          a_qr.GetResDirect;
        var     a_ind1 :=     a_ind1_qr.GetResDirect;
        var     a_ind2 :=     a_ind2_qr.GetResDirect;
        var   el_count :=   el_count_qr.GetResDirect;
        var mem_offset := mem_offset_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(mem_offset), new UIntPtr(el_count*Marshal.SizeOf(default(TRecord))),
          a[a_ind1,a_ind2],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind1:';
      sb += ' ';
      a_ind1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind2:';
      sb += ' ';
      a_ind2.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'el_count:';
      sb += ' ';
      el_count.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenReadArray2<TRecord>(a: CommandQueue<array[,] of TRecord>; a_ind1,a_ind2, el_count, mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandReadArray2<TRecord>(a, a_ind1, a_ind2, el_count, mem_offset));
end;

{$endregion ReadArray2}

{$region ReadArray3}

type
  CLMemoryCommandReadArray3<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private          a: CommandQueue<array[,,] of TRecord>;
    private     a_ind1: CommandQueue<integer>;
    private     a_ind2: CommandQueue<integer>;
    private     a_ind3: CommandQueue<integer>;
    private   el_count: CommandQueue<integer>;
    private mem_offset: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 6;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'читать из области памяти OpenCL');
    end;
    public constructor(a: CommandQueue<array[,,] of TRecord>; a_ind1,a_ind2,a_ind3, el_count, mem_offset: CommandQueue<integer>);
    begin
      self.         a :=          a;
      self.    a_ind1 :=     a_ind1;
      self.    a_ind2 :=     a_ind2;
      self.    a_ind3 :=     a_ind3;
      self.  el_count :=   el_count;
      self.mem_offset := mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
               a.InitBeforeInvoke(g, prev_hubs);
          a_ind1.InitBeforeInvoke(g, prev_hubs);
          a_ind2.InitBeforeInvoke(g, prev_hubs);
          a_ind3.InitBeforeInvoke(g, prev_hubs);
        el_count.InitBeforeInvoke(g, prev_hubs);
      mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var          a_qr: QueueRes<array[,,] of TRecord>;
      var     a_ind1_qr: QueueRes<integer>;
      var     a_ind2_qr: QueueRes<integer>;
      var     a_ind3_qr: QueueRes<integer>;
      var   el_count_qr: QueueRes<integer>;
      var mem_offset_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
                 a_qr := invoker.InvokeBranch(         a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
            a_ind1_qr := invoker.InvokeBranch(    a_ind1.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
            a_ind2_qr := invoker.InvokeBranch(    a_ind2.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
            a_ind3_qr := invoker.InvokeBranch(    a_ind3.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
          el_count_qr := invoker.InvokeBranch(  el_count.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        mem_offset_qr := invoker.InvokeBranch(mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
                 a_qr.CancelStatusCheck('enq cancel');
            a_ind1_qr.CancelStatusCheck('enq cancel');
            a_ind2_qr.CancelStatusCheck('enq cancel');
            a_ind3_qr.CancelStatusCheck('enq cancel');
          el_count_qr.CancelStatusCheck('enq cancel');
        mem_offset_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var          a :=          a_qr.GetResDirect;
        var     a_ind1 :=     a_ind1_qr.GetResDirect;
        var     a_ind2 :=     a_ind2_qr.GetResDirect;
        var     a_ind3 :=     a_ind3_qr.GetResDirect;
        var   el_count :=   el_count_qr.GetResDirect;
        var mem_offset := mem_offset_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(mem_offset), new UIntPtr(el_count*Marshal.SizeOf(default(TRecord))),
          a[a_ind1,a_ind2,a_ind3],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind1:';
      sb += ' ';
      a_ind1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind2:';
      sb += ' ';
      a_ind2.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind3:';
      sb += ' ';
      a_ind3.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'el_count:';
      sb += ' ';
      el_count.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenReadArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>; a_ind1,a_ind2,a_ind3, el_count, mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandReadArray3<TRecord>(a, a_ind1, a_ind2, a_ind3, el_count, mem_offset));
end;

{$endregion ReadArray3}

{$region WriteArraySegment}

function CLMemoryCCQ.ThenWriteArraySegment<TRecord>(a: ArraySegment<TRecord>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenWriteArray1(CQ(a.Array), a.Offset, a.Count, mem_offset);
end;

{$endregion WriteArraySegment}

{$region ReadArraySegment}

function CLMemoryCCQ.ThenReadArraySegment<TRecord>(a: ArraySegment<TRecord>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenReadArray1(CQ(a.Array), a.Offset, a.Count, mem_offset);
end;

{$endregion ReadArraySegment}

{$region WriteData!AutoSize}

type
  CLMemoryCommandWriteDataAutoSize = sealed class(EnqueueableGPUCommand<CLMemory>)
    private ptr: CommandQueue<IntPtr>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(ptr: CommandQueue<IntPtr>);
    begin
      self.ptr := ptr;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      ptr.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var ptr_qr: QueueRes<IntPtr>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        ptr_qr := invoker.InvokeBranch(ptr.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        ptr_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var ptr := ptr_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          UIntPtr.Zero, o.Size,
          ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'ptr:';
      sb += ' ';
      ptr.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenWriteData(ptr: CommandQueue<IntPtr>): CLMemoryCCQ;
begin
  Result := AddCommand(self, new CLMemoryCommandWriteDataAutoSize(ptr));
end;

{$endregion WriteData!AutoSize}

{$region WriteData}

type
  CLMemoryCommandWriteData = sealed class(EnqueueableGPUCommand<CLMemory>)
    private        ptr: CommandQueue<IntPtr>;
    private mem_offset: CommandQueue<integer>;
    private        len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 3;
    
    public constructor(ptr: CommandQueue<IntPtr>; mem_offset, len: CommandQueue<integer>);
    begin
      self.       ptr :=        ptr;
      self.mem_offset := mem_offset;
      self.       len :=        len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
             ptr.InitBeforeInvoke(g, prev_hubs);
      mem_offset.InitBeforeInvoke(g, prev_hubs);
             len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var        ptr_qr: QueueRes<IntPtr>;
      var mem_offset_qr: QueueRes<integer>;
      var        len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
               ptr_qr := invoker.InvokeBranch(       ptr.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        mem_offset_qr := invoker.InvokeBranch(mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
               len_qr := invoker.InvokeBranch(       len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
               ptr_qr.CancelStatusCheck('enq cancel');
        mem_offset_qr.CancelStatusCheck('enq cancel');
               len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var        ptr :=        ptr_qr.GetResDirect;
        var mem_offset := mem_offset_qr.GetResDirect;
        var        len :=        len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(mem_offset), new UIntPtr(len),
          ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'ptr:';
      sb += ' ';
      ptr.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenWriteData(ptr: CommandQueue<IntPtr>; mem_offset, len: CommandQueue<integer>): CLMemoryCCQ;
begin
  Result := AddCommand(self, new CLMemoryCommandWriteData(ptr, mem_offset, len));
end;

{$endregion WriteData}

{$region ReadData!AutoSize}

type
  CLMemoryCommandReadDataAutoSize = sealed class(EnqueueableGPUCommand<CLMemory>)
    private ptr: CommandQueue<IntPtr>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(ptr: CommandQueue<IntPtr>);
    begin
      self.ptr := ptr;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      ptr.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var ptr_qr: QueueRes<IntPtr>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        ptr_qr := invoker.InvokeBranch(ptr.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        ptr_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var ptr := ptr_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          UIntPtr.Zero, o.Size,
          ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'ptr:';
      sb += ' ';
      ptr.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenReadData(ptr: CommandQueue<IntPtr>): CLMemoryCCQ;
begin
  Result := AddCommand(self, new CLMemoryCommandReadDataAutoSize(ptr));
end;

{$endregion ReadData!AutoSize}

{$region ReadData}

type
  CLMemoryCommandReadData = sealed class(EnqueueableGPUCommand<CLMemory>)
    private        ptr: CommandQueue<IntPtr>;
    private mem_offset: CommandQueue<integer>;
    private        len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 3;
    
    public constructor(ptr: CommandQueue<IntPtr>; mem_offset, len: CommandQueue<integer>);
    begin
      self.       ptr :=        ptr;
      self.mem_offset := mem_offset;
      self.       len :=        len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
             ptr.InitBeforeInvoke(g, prev_hubs);
      mem_offset.InitBeforeInvoke(g, prev_hubs);
             len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var        ptr_qr: QueueRes<IntPtr>;
      var mem_offset_qr: QueueRes<integer>;
      var        len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
               ptr_qr := invoker.InvokeBranch(       ptr.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        mem_offset_qr := invoker.InvokeBranch(mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
               len_qr := invoker.InvokeBranch(       len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
               ptr_qr.CancelStatusCheck('enq cancel');
        mem_offset_qr.CancelStatusCheck('enq cancel');
               len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var        ptr :=        ptr_qr.GetResDirect;
        var mem_offset := mem_offset_qr.GetResDirect;
        var        len :=        len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(mem_offset), new UIntPtr(len),
          ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'ptr:';
      sb += ' ';
      ptr.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenReadData(ptr: CommandQueue<IntPtr>; mem_offset, len: CommandQueue<integer>): CLMemoryCCQ;
begin
  Result := AddCommand(self, new CLMemoryCommandReadData(ptr, mem_offset, len));
end;

{$endregion ReadData}

{$region WriteData!AutoSize}

function CLMemoryCCQ.ThenWriteData(ptr: pointer): CLMemoryCCQ;
begin
  Result := ThenWriteData(IntPtr(ptr));
end;

{$endregion WriteData!AutoSize}

{$region WriteData}

function CLMemoryCCQ.ThenWriteData(ptr: pointer; mem_offset, len: CommandQueue<integer>): CLMemoryCCQ;
begin
  Result := ThenWriteData(IntPtr(ptr), mem_offset, len);
end;

{$endregion WriteData}

{$region ReadData!AutoSize}

function CLMemoryCCQ.ThenReadData(ptr: pointer): CLMemoryCCQ;
begin
  Result := ThenReadData(IntPtr(ptr));
end;

{$endregion ReadData!AutoSize}

{$region ReadData}

function CLMemoryCCQ.ThenReadData(ptr: pointer; mem_offset, len: CommandQueue<integer>): CLMemoryCCQ;
begin
  Result := ThenReadData(IntPtr(ptr), mem_offset, len);
end;

{$endregion ReadData}

{$region WriteNativeMemoryArea!AutoOffset}

function CLMemoryCCQ.ThenWriteNativeMemoryArea(native_data: NativeMemoryArea): CLMemoryCCQ;
begin
  Result := ThenWriteNativeMemoryArea(CQ(native_data), 0);
end;

{$endregion WriteNativeMemoryArea!AutoOffset}

{$region WriteNativeMemoryArea}

function CLMemoryCCQ.ThenWriteNativeMemoryArea(native_data: NativeMemoryArea; mem_offset: CommandQueue<integer>): CLMemoryCCQ;
begin
  Result := ThenWriteNativeMemoryArea(CQ(native_data), mem_offset);
end;

{$endregion WriteNativeMemoryArea}

{$region WriteNativeMemory!AutoOffset}

function CLMemoryCCQ.ThenWriteNativeMemory(native_data: NativeMemory): CLMemoryCCQ;
begin
  Result := ThenWriteNativeMemory(CQ(native_data), 0);
end;

{$endregion WriteNativeMemory!AutoOffset}

{$region WriteNativeMemory}

function CLMemoryCCQ.ThenWriteNativeMemory(native_data: NativeMemory; mem_offset: CommandQueue<integer>): CLMemoryCCQ;
begin
  Result := ThenWriteNativeMemory(CQ(native_data), mem_offset);
end;

{$endregion WriteNativeMemory}

{$region WriteNativeValueArea!AutoOffset}

function CLMemoryCCQ.ThenWriteNativeValueArea<TRecord>(native_data: NativeValueArea<TRecord>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenWriteNativeValueArea(CQ(native_data), 0);
end;

{$endregion WriteNativeValueArea!AutoOffset}

{$region WriteNativeValueArea}

function CLMemoryCCQ.ThenWriteNativeValueArea<TRecord>(native_data: NativeValueArea<TRecord>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenWriteNativeValueArea(CQ(native_data), mem_offset);
end;

{$endregion WriteNativeValueArea}

{$region WriteNativeValue!AutoOffset}

function CLMemoryCCQ.ThenWriteNativeValue<TRecord>(native_data: NativeValue<TRecord>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenWriteNativeValue(CQ(native_data), 0);
end;

{$endregion WriteNativeValue!AutoOffset}

{$region WriteNativeValue}

function CLMemoryCCQ.ThenWriteNativeValue<TRecord>(native_data: NativeValue<TRecord>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenWriteNativeValue(CQ(native_data), mem_offset);
end;

{$endregion WriteNativeValue}

{$region WriteNativeArrayArea!AutoOffset}

function CLMemoryCCQ.ThenWriteNativeArrayArea<TRecord>(native_data: NativeArrayArea<TRecord>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenWriteNativeArrayArea(CQ(native_data), 0);
end;

{$endregion WriteNativeArrayArea!AutoOffset}

{$region WriteNativeArrayArea}

function CLMemoryCCQ.ThenWriteNativeArrayArea<TRecord>(native_data: NativeArrayArea<TRecord>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenWriteNativeArrayArea(CQ(native_data), mem_offset);
end;

{$endregion WriteNativeArrayArea}

{$region WriteNativeArray!AutoOffset}

function CLMemoryCCQ.ThenWriteNativeArray<TRecord>(native_data: NativeArray<TRecord>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenWriteNativeArray(CQ(native_data), 0);
end;

{$endregion WriteNativeArray!AutoOffset}

{$region WriteNativeArray}

function CLMemoryCCQ.ThenWriteNativeArray<TRecord>(native_data: NativeArray<TRecord>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenWriteNativeArray(CQ(native_data), mem_offset);
end;

{$endregion WriteNativeArray}

{$region ReadNativeMemoryArea!AutoOffset}

function CLMemoryCCQ.ThenReadNativeMemoryArea(native_data: NativeMemoryArea): CLMemoryCCQ;
begin
  Result := ThenReadNativeMemoryArea(CQ(native_data), 0);
end;

{$endregion ReadNativeMemoryArea!AutoOffset}

{$region ReadNativeMemoryArea}

function CLMemoryCCQ.ThenReadNativeMemoryArea(native_data: NativeMemoryArea; mem_offset: CommandQueue<integer>): CLMemoryCCQ;
begin
  Result := ThenReadNativeMemoryArea(CQ(native_data), mem_offset);
end;

{$endregion ReadNativeMemoryArea}

{$region ReadNativeMemory!AutoOffset}

function CLMemoryCCQ.ThenReadNativeMemory(native_data: NativeMemory): CLMemoryCCQ;
begin
  Result := ThenReadNativeMemory(CQ(native_data), 0);
end;

{$endregion ReadNativeMemory!AutoOffset}

{$region ReadNativeMemory}

function CLMemoryCCQ.ThenReadNativeMemory(native_data: NativeMemory; mem_offset: CommandQueue<integer>): CLMemoryCCQ;
begin
  Result := ThenReadNativeMemory(CQ(native_data), mem_offset);
end;

{$endregion ReadNativeMemory}

{$region ReadNativeValueArea!AutoOffset}

function CLMemoryCCQ.ThenReadNativeValueArea<TRecord>(native_data: NativeValueArea<TRecord>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenReadNativeValueArea(CQ(native_data), 0);
end;

{$endregion ReadNativeValueArea!AutoOffset}

{$region ReadNativeValueArea}

function CLMemoryCCQ.ThenReadNativeValueArea<TRecord>(native_data: NativeValueArea<TRecord>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenReadNativeValueArea(CQ(native_data), mem_offset);
end;

{$endregion ReadNativeValueArea}

{$region ReadNativeValue!AutoOffset}

function CLMemoryCCQ.ThenReadNativeValue<TRecord>(native_data: NativeValue<TRecord>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenReadNativeValue(CQ(native_data), 0);
end;

{$endregion ReadNativeValue!AutoOffset}

{$region ReadNativeValue}

function CLMemoryCCQ.ThenReadNativeValue<TRecord>(native_data: NativeValue<TRecord>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenReadNativeValue(CQ(native_data), mem_offset);
end;

{$endregion ReadNativeValue}

{$region ReadNativeArrayArea!AutoOffset}

function CLMemoryCCQ.ThenReadNativeArrayArea<TRecord>(native_data: NativeArrayArea<TRecord>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenReadNativeArrayArea(CQ(native_data), 0);
end;

{$endregion ReadNativeArrayArea!AutoOffset}

{$region ReadNativeArrayArea}

function CLMemoryCCQ.ThenReadNativeArrayArea<TRecord>(native_data: NativeArrayArea<TRecord>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenReadNativeArrayArea(CQ(native_data), mem_offset);
end;

{$endregion ReadNativeArrayArea}

{$region ReadNativeArray!AutoOffset}

function CLMemoryCCQ.ThenReadNativeArray<TRecord>(native_data: NativeArray<TRecord>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenReadNativeArray(CQ(native_data), 0);
end;

{$endregion ReadNativeArray!AutoOffset}

{$region ReadNativeArray}

function CLMemoryCCQ.ThenReadNativeArray<TRecord>(native_data: NativeArray<TRecord>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenReadNativeArray(CQ(native_data), mem_offset);
end;

{$endregion ReadNativeArray}

{$region WriteNativeMemoryArea}

function CLMemoryCCQ.ThenWriteNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>): CLMemoryCCQ;
begin
  Result := ThenWriteNativeMemoryArea(native_data, 0);
end;

{$endregion WriteNativeMemoryArea}

{$region WriteNativeMemory}

function CLMemoryCCQ.ThenWriteNativeMemory(native_data: CommandQueue<NativeMemory>): CLMemoryCCQ;
begin
  Result := ThenWriteNativeMemory(native_data, 0);
end;

{$endregion WriteNativeMemory}

{$region WriteNativeValueArea}

function CLMemoryCCQ.ThenWriteNativeValueArea<TRecord>(native_data: CommandQueue<NativeValueArea<TRecord>>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenWriteNativeValueArea(native_data, 0);
end;

{$endregion WriteNativeValueArea}

{$region WriteNativeValue}

function CLMemoryCCQ.ThenWriteNativeValue<TRecord>(native_data: CommandQueue<NativeValue<TRecord>>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenWriteNativeValue(native_data, 0);
end;

{$endregion WriteNativeValue}

{$region WriteNativeArrayArea}

function CLMemoryCCQ.ThenWriteNativeArrayArea<TRecord>(native_data: CommandQueue<NativeArrayArea<TRecord>>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenWriteNativeArrayArea(native_data, 0);
end;

{$endregion WriteNativeArrayArea}

{$region WriteNativeArray}

function CLMemoryCCQ.ThenWriteNativeArray<TRecord>(native_data: CommandQueue<NativeArray<TRecord>>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenWriteNativeArray(native_data, 0);
end;

{$endregion WriteNativeArray}

{$region ReadNativeMemoryArea}

function CLMemoryCCQ.ThenReadNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>): CLMemoryCCQ;
begin
  Result := ThenReadNativeMemoryArea(native_data, 0);
end;

{$endregion ReadNativeMemoryArea}

{$region ReadNativeMemory}

function CLMemoryCCQ.ThenReadNativeMemory(native_data: CommandQueue<NativeMemory>): CLMemoryCCQ;
begin
  Result := ThenReadNativeMemory(native_data, 0);
end;

{$endregion ReadNativeMemory}

{$region ReadNativeValueArea}

function CLMemoryCCQ.ThenReadNativeValueArea<TRecord>(native_data: CommandQueue<NativeValueArea<TRecord>>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenReadNativeValueArea(native_data, 0);
end;

{$endregion ReadNativeValueArea}

{$region ReadNativeValue}

function CLMemoryCCQ.ThenReadNativeValue<TRecord>(native_data: CommandQueue<NativeValue<TRecord>>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenReadNativeValue(native_data, 0);
end;

{$endregion ReadNativeValue}

{$region ReadNativeArrayArea}

function CLMemoryCCQ.ThenReadNativeArrayArea<TRecord>(native_data: CommandQueue<NativeArrayArea<TRecord>>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenReadNativeArrayArea(native_data, 0);
end;

{$endregion ReadNativeArrayArea}

{$region ReadNativeArray}

function CLMemoryCCQ.ThenReadNativeArray<TRecord>(native_data: CommandQueue<NativeArray<TRecord>>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenReadNativeArray(native_data, 0);
end;

{$endregion ReadNativeArray}

{$region WriteNativeMemoryArea}

type
  CLMemoryCommandWriteNativeMemoryArea = sealed class(EnqueueableGPUCommand<CLMemory>)
    private native_data: CommandQueue<NativeMemoryArea>;
    private  mem_offset: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    public constructor(native_data: CommandQueue<NativeMemoryArea>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var native_data_qr: QueueRes<NativeMemoryArea>;
      var  mem_offset_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
         mem_offset_qr := invoker.InvokeBranch( mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
         mem_offset_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.sz,
          native_data.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenWriteNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>; mem_offset: CommandQueue<integer>): CLMemoryCCQ;
begin
  Result := AddCommand(self, new CLMemoryCommandWriteNativeMemoryArea(native_data, mem_offset));
end;

{$endregion WriteNativeMemoryArea}

{$region WriteNativeMemory}

type
  CLMemoryCommandWriteNativeMemory = sealed class(EnqueueableGPUCommand<CLMemory>)
    private native_data: CommandQueue<NativeMemory>;
    private  mem_offset: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    public constructor(native_data: CommandQueue<NativeMemory>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var native_data_qr: QueueRes<NativeMemory>;
      var  mem_offset_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
         mem_offset_qr := invoker.InvokeBranch( mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
         mem_offset_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.Area.sz,
          native_data.Area.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenWriteNativeMemory(native_data: CommandQueue<NativeMemory>; mem_offset: CommandQueue<integer>): CLMemoryCCQ;
begin
  Result := AddCommand(self, new CLMemoryCommandWriteNativeMemory(native_data, mem_offset));
end;

{$endregion WriteNativeMemory}

{$region WriteNativeValueArea}

type
  CLMemoryCommandWriteNativeValueArea<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private native_data: CommandQueue<NativeValueArea<TRecord>>;
    private  mem_offset: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemory:WriteNativeValueArea%');
    end;
    public constructor(native_data: CommandQueue<NativeValueArea<TRecord>>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var native_data_qr: QueueRes<NativeValueArea<TRecord>>;
      var  mem_offset_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
         mem_offset_qr := invoker.InvokeBranch( mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
         mem_offset_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.ByteSize,
          native_data.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenWriteNativeValueArea<TRecord>(native_data: CommandQueue<NativeValueArea<TRecord>>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandWriteNativeValueArea<TRecord>(native_data, mem_offset));
end;

{$endregion WriteNativeValueArea}

{$region WriteNativeValue}

type
  CLMemoryCommandWriteNativeValue<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private native_data: CommandQueue<NativeValue<TRecord>>;
    private  mem_offset: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'записывать в область памяти OpenCL');
    end;
    public constructor(native_data: CommandQueue<NativeValue<TRecord>>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var native_data_qr: QueueRes<NativeValue<TRecord>>;
      var  mem_offset_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
         mem_offset_qr := invoker.InvokeBranch( mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
         mem_offset_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.Area.ByteSize,
          native_data.Area.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenWriteNativeValue<TRecord>(native_data: CommandQueue<NativeValue<TRecord>>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandWriteNativeValue<TRecord>(native_data, mem_offset));
end;

{$endregion WriteNativeValue}

{$region WriteNativeArrayArea}

type
  CLMemoryCommandWriteNativeArrayArea<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private native_data: CommandQueue<NativeArrayArea<TRecord>>;
    private  mem_offset: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemory:WriteNativeArrayArea%');
    end;
    public constructor(native_data: CommandQueue<NativeArrayArea<TRecord>>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var native_data_qr: QueueRes<NativeArrayArea<TRecord>>;
      var  mem_offset_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
         mem_offset_qr := invoker.InvokeBranch( mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
         mem_offset_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.ByteSize,
          native_data.first_ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenWriteNativeArrayArea<TRecord>(native_data: CommandQueue<NativeArrayArea<TRecord>>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandWriteNativeArrayArea<TRecord>(native_data, mem_offset));
end;

{$endregion WriteNativeArrayArea}

{$region WriteNativeArray}

type
  CLMemoryCommandWriteNativeArray<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private native_data: CommandQueue<NativeArray<TRecord>>;
    private  mem_offset: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'записывать в область памяти OpenCL');
    end;
    public constructor(native_data: CommandQueue<NativeArray<TRecord>>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var native_data_qr: QueueRes<NativeArray<TRecord>>;
      var  mem_offset_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
         mem_offset_qr := invoker.InvokeBranch( mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
         mem_offset_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.Area.ByteSize,
          native_data.Area.first_ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenWriteNativeArray<TRecord>(native_data: CommandQueue<NativeArray<TRecord>>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandWriteNativeArray<TRecord>(native_data, mem_offset));
end;

{$endregion WriteNativeArray}

{$region ReadNativeMemoryArea}

type
  CLMemoryCommandReadNativeMemoryArea = sealed class(EnqueueableGPUCommand<CLMemory>)
    private native_data: CommandQueue<NativeMemoryArea>;
    private  mem_offset: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    public constructor(native_data: CommandQueue<NativeMemoryArea>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var native_data_qr: QueueRes<NativeMemoryArea>;
      var  mem_offset_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
         mem_offset_qr := invoker.InvokeBranch( mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
         mem_offset_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.sz,
          native_data.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenReadNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>; mem_offset: CommandQueue<integer>): CLMemoryCCQ;
begin
  Result := AddCommand(self, new CLMemoryCommandReadNativeMemoryArea(native_data, mem_offset));
end;

{$endregion ReadNativeMemoryArea}

{$region ReadNativeMemory}

type
  CLMemoryCommandReadNativeMemory = sealed class(EnqueueableGPUCommand<CLMemory>)
    private native_data: CommandQueue<NativeMemory>;
    private  mem_offset: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    public constructor(native_data: CommandQueue<NativeMemory>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var native_data_qr: QueueRes<NativeMemory>;
      var  mem_offset_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
         mem_offset_qr := invoker.InvokeBranch( mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
         mem_offset_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.Area.sz,
          native_data.Area.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenReadNativeMemory(native_data: CommandQueue<NativeMemory>; mem_offset: CommandQueue<integer>): CLMemoryCCQ;
begin
  Result := AddCommand(self, new CLMemoryCommandReadNativeMemory(native_data, mem_offset));
end;

{$endregion ReadNativeMemory}

{$region ReadNativeValueArea}

type
  CLMemoryCommandReadNativeValueArea<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private native_data: CommandQueue<NativeValueArea<TRecord>>;
    private  mem_offset: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemory:ReadNativeValueArea%');
    end;
    public constructor(native_data: CommandQueue<NativeValueArea<TRecord>>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var native_data_qr: QueueRes<NativeValueArea<TRecord>>;
      var  mem_offset_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
         mem_offset_qr := invoker.InvokeBranch( mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
         mem_offset_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.ByteSize,
          native_data.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenReadNativeValueArea<TRecord>(native_data: CommandQueue<NativeValueArea<TRecord>>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandReadNativeValueArea<TRecord>(native_data, mem_offset));
end;

{$endregion ReadNativeValueArea}

{$region ReadNativeValue}

type
  CLMemoryCommandReadNativeValue<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private native_data: CommandQueue<NativeValue<TRecord>>;
    private  mem_offset: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'читать из области памяти OpenCL');
    end;
    public constructor(native_data: CommandQueue<NativeValue<TRecord>>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var native_data_qr: QueueRes<NativeValue<TRecord>>;
      var  mem_offset_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
         mem_offset_qr := invoker.InvokeBranch( mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
         mem_offset_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.Area.ByteSize,
          native_data.Area.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenReadNativeValue<TRecord>(native_data: CommandQueue<NativeValue<TRecord>>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandReadNativeValue<TRecord>(native_data, mem_offset));
end;

{$endregion ReadNativeValue}

{$region ReadNativeArrayArea}

type
  CLMemoryCommandReadNativeArrayArea<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private native_data: CommandQueue<NativeArrayArea<TRecord>>;
    private  mem_offset: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemory:ReadNativeArrayArea%');
    end;
    public constructor(native_data: CommandQueue<NativeArrayArea<TRecord>>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var native_data_qr: QueueRes<NativeArrayArea<TRecord>>;
      var  mem_offset_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
         mem_offset_qr := invoker.InvokeBranch( mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
         mem_offset_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.ByteSize,
          native_data.first_ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenReadNativeArrayArea<TRecord>(native_data: CommandQueue<NativeArrayArea<TRecord>>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandReadNativeArrayArea<TRecord>(native_data, mem_offset));
end;

{$endregion ReadNativeArrayArea}

{$region ReadNativeArray}

type
  CLMemoryCommandReadNativeArray<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private native_data: CommandQueue<NativeArray<TRecord>>;
    private  mem_offset: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'читать из области памяти OpenCL');
    end;
    public constructor(native_data: CommandQueue<NativeArray<TRecord>>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var native_data_qr: QueueRes<NativeArray<TRecord>>;
      var  mem_offset_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
         mem_offset_qr := invoker.InvokeBranch( mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
         mem_offset_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.Area.ByteSize,
          native_data.Area.first_ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenReadNativeArray<TRecord>(native_data: CommandQueue<NativeArray<TRecord>>; mem_offset: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandReadNativeArray<TRecord>(native_data, mem_offset));
end;

{$endregion ReadNativeArray}

{$endregion 1#Write&Read}

{$region 2#Fill}

{$region FillValue!AutoSize}

type
  CLMemoryCommandFillValueAutoSize<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private val := new NativeValueArea<TRecord>(true);
    
    protected procedure Finalize; override;
    begin
      val.Release;
    end;
    
    protected function ExpectedEnqCount: integer; override := 0;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'записывать в область памяти OpenCL');
    end;
    public constructor(val: TRecord);
    begin
      self.val.Value := val;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          val.Pointer, new UIntPtr(Marshal.SizeOf(default(TRecord))),
          UIntPtr.Zero, o.Size,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      sb.Append(val.Value);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenFillValue<TRecord>(val: TRecord): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandFillValueAutoSize<TRecord>(val));
end;

{$endregion FillValue!AutoSize}

{$region FillValue!AutoSizeQ}

type
  CLMemoryCommandFillValueAutoSizeQ<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private val: CommandQueue<TRecord>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'записывать в область памяти OpenCL');
    end;
    public constructor(val: CommandQueue<TRecord>);
    begin
      self.val := val;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      val.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var val_qr: QueueResPtr<TRecord>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        val_qr := invoker.InvokeBranch(val.InvokeToPtr, par_err_handlers, False).AddToEvLst(g, enq_evs, False);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        val_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var val := val_qr.GetResPtrForRead;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          val, new UIntPtr(Marshal.SizeOf(default(TRecord))),
          UIntPtr.Zero, o.Size,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          GC.KeepAlive(val_qr);
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      val.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenFillValue<TRecord>(val: CommandQueue<TRecord>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandFillValueAutoSizeQ<TRecord>(val));
end;

{$endregion FillValue!AutoSizeQ}

{$region FillValue}

type
  CLMemoryCommandFillValue<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private           val := new NativeValueArea<TRecord>(true);
    private    mem_offset: CommandQueue<integer>;
    private fill_byte_len: CommandQueue<integer>;
    
    protected procedure Finalize; override;
    begin
      val.Release;
    end;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'записывать в область памяти OpenCL');
    end;
    public constructor(val: TRecord; mem_offset, fill_byte_len: CommandQueue<integer>);
    begin
      self.          val.Value :=           val;
      self.   mem_offset       :=    mem_offset;
      self.fill_byte_len       := fill_byte_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
         mem_offset.InitBeforeInvoke(g, prev_hubs);
      fill_byte_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var    mem_offset_qr: QueueRes<integer>;
      var fill_byte_len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
           mem_offset_qr := invoker.InvokeBranch(   mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        fill_byte_len_qr := invoker.InvokeBranch(fill_byte_len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
           mem_offset_qr.CancelStatusCheck('enq cancel');
        fill_byte_len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var    mem_offset :=    mem_offset_qr.GetResDirect;
        var fill_byte_len := fill_byte_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          val.Pointer, new UIntPtr(Marshal.SizeOf(default(TRecord))),
          new UIntPtr(mem_offset), new UIntPtr(fill_byte_len),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      sb.Append(val.Value);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_byte_len:';
      sb += ' ';
      fill_byte_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenFillValue<TRecord>(val: TRecord; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandFillValue<TRecord>(val, mem_offset, fill_byte_len));
end;

{$endregion FillValue}

{$region FillValue!Q}

type
  CLMemoryCommandFillValueQ<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private           val: CommandQueue<TRecord>;
    private    mem_offset: CommandQueue<integer>;
    private fill_byte_len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 3;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'записывать в область памяти OpenCL');
    end;
    public constructor(val: CommandQueue<TRecord>; mem_offset, fill_byte_len: CommandQueue<integer>);
    begin
      self.          val :=           val;
      self.   mem_offset :=    mem_offset;
      self.fill_byte_len := fill_byte_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
                val.InitBeforeInvoke(g, prev_hubs);
         mem_offset.InitBeforeInvoke(g, prev_hubs);
      fill_byte_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var           val_qr: QueueResPtr<TRecord>;
      var    mem_offset_qr: QueueRes<integer>;
      var fill_byte_len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
           mem_offset_qr := invoker.InvokeBranch(   mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        fill_byte_len_qr := invoker.InvokeBranch(fill_byte_len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
                  val_qr := invoker.InvokeBranch(          val.InvokeToPtr, par_err_handlers, False).AddToEvLst(g, enq_evs, False);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
                  val_qr.CancelStatusCheck('enq cancel');
           mem_offset_qr.CancelStatusCheck('enq cancel');
        fill_byte_len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var           val :=           val_qr.GetResPtrForRead;
        var    mem_offset :=    mem_offset_qr.GetResDirect;
        var fill_byte_len := fill_byte_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          val, new UIntPtr(Marshal.SizeOf(default(TRecord))),
          new UIntPtr(mem_offset), new UIntPtr(fill_byte_len),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          GC.KeepAlive(val_qr);
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      val.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_byte_len:';
      sb += ' ';
      fill_byte_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenFillValue<TRecord>(val: CommandQueue<TRecord>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandFillValueQ<TRecord>(val, mem_offset, fill_byte_len));
end;

{$endregion FillValue!Q}

{$region FillArray1!AutoSize}

function CLMemoryCCQ.ThenFillArray1<TRecord>(a: array of TRecord): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenFillArray1(CQ(a));
end;

{$endregion FillArray1!AutoSize}

{$region FillArray2!AutoSize}

function CLMemoryCCQ.ThenFillArray2<TRecord>(a: array[,] of TRecord): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenFillArray2(CQ(a));
end;

{$endregion FillArray2!AutoSize}

{$region FillArray3!AutoSize}

function CLMemoryCCQ.ThenFillArray3<TRecord>(a: array[,,] of TRecord): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenFillArray3(CQ(a));
end;

{$endregion FillArray3!AutoSize}

{$region FillArray1}

function CLMemoryCCQ.ThenFillArray1<TRecord>(a: array of TRecord; a_ind, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenFillArray1(CQ(a), a_ind, pattern_byte_len, mem_offset, fill_byte_len);
end;

{$endregion FillArray1}

{$region FillArray2}

function CLMemoryCCQ.ThenFillArray2<TRecord>(a: array[,] of TRecord; a_ind1,a_ind2, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenFillArray2(CQ(a), a_ind1,a_ind2, pattern_byte_len, mem_offset, fill_byte_len);
end;

{$endregion FillArray2}

{$region FillArray3}

function CLMemoryCCQ.ThenFillArray3<TRecord>(a: array[,,] of TRecord; a_ind1,a_ind2,a_ind3, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenFillArray3(CQ(a), a_ind1,a_ind2,a_ind3, pattern_byte_len, mem_offset, fill_byte_len);
end;

{$endregion FillArray3}

{$region FillArray1!AutoSize}

type
  CLMemoryCommandFillArray1AutoSize<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private a: CommandQueue<array of TRecord>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'записывать в область памяти OpenCL');
    end;
    public constructor(a: CommandQueue<array of TRecord>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var a_qr: QueueRes<array of TRecord>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        a_qr := invoker.InvokeBranch(a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        a_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          a[0], new UIntPtr(a.Length*Marshal.SizeOf(default(TRecord))),
          UIntPtr.Zero, o.Size,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenFillArray1<TRecord>(a: CommandQueue<array of TRecord>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandFillArray1AutoSize<TRecord>(a));
end;

{$endregion FillArray1!AutoSize}

{$region FillArray1}

type
  CLMemoryCommandFillArray1<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private                a: CommandQueue<array of TRecord>;
    private            a_ind: CommandQueue<integer>;
    private pattern_byte_len: CommandQueue<integer>;
    private       mem_offset: CommandQueue<integer>;
    private    fill_byte_len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 5;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'записывать в область памяти OpenCL');
    end;
    public constructor(a: CommandQueue<array of TRecord>; a_ind, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>);
    begin
      self.               a :=                a;
      self.           a_ind :=            a_ind;
      self.pattern_byte_len := pattern_byte_len;
      self.      mem_offset :=       mem_offset;
      self.   fill_byte_len :=    fill_byte_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
                     a.InitBeforeInvoke(g, prev_hubs);
                 a_ind.InitBeforeInvoke(g, prev_hubs);
      pattern_byte_len.InitBeforeInvoke(g, prev_hubs);
            mem_offset.InitBeforeInvoke(g, prev_hubs);
         fill_byte_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var                a_qr: QueueRes<array of TRecord>;
      var            a_ind_qr: QueueRes<integer>;
      var pattern_byte_len_qr: QueueRes<integer>;
      var       mem_offset_qr: QueueRes<integer>;
      var    fill_byte_len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
                       a_qr := invoker.InvokeBranch(               a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
                   a_ind_qr := invoker.InvokeBranch(           a_ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        pattern_byte_len_qr := invoker.InvokeBranch(pattern_byte_len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
              mem_offset_qr := invoker.InvokeBranch(      mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
           fill_byte_len_qr := invoker.InvokeBranch(   fill_byte_len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
                       a_qr.CancelStatusCheck('enq cancel');
                   a_ind_qr.CancelStatusCheck('enq cancel');
        pattern_byte_len_qr.CancelStatusCheck('enq cancel');
              mem_offset_qr.CancelStatusCheck('enq cancel');
           fill_byte_len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var                a :=                a_qr.GetResDirect;
        var            a_ind :=            a_ind_qr.GetResDirect;
        var pattern_byte_len := pattern_byte_len_qr.GetResDirect;
        var       mem_offset :=       mem_offset_qr.GetResDirect;
        var    fill_byte_len :=    fill_byte_len_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          a[a_ind], new UIntPtr(pattern_byte_len),
          new UIntPtr(mem_offset), new UIntPtr(fill_byte_len),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind:';
      sb += ' ';
      a_ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'pattern_byte_len:';
      sb += ' ';
      pattern_byte_len.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_byte_len:';
      sb += ' ';
      fill_byte_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenFillArray1<TRecord>(a: CommandQueue<array of TRecord>; a_ind, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandFillArray1<TRecord>(a, a_ind, pattern_byte_len, mem_offset, fill_byte_len));
end;

{$endregion FillArray1}

{$region FillArray2!AutoSize}

type
  CLMemoryCommandFillArray2AutoSize<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private a: CommandQueue<array[,] of TRecord>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'записывать в область памяти OpenCL');
    end;
    public constructor(a: CommandQueue<array[,] of TRecord>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var a_qr: QueueRes<array[,] of TRecord>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        a_qr := invoker.InvokeBranch(a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        a_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          a[0,0], new UIntPtr(a.Length*Marshal.SizeOf(default(TRecord))),
          UIntPtr.Zero, o.Size,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenFillArray2<TRecord>(a: CommandQueue<array[,] of TRecord>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandFillArray2AutoSize<TRecord>(a));
end;

{$endregion FillArray2!AutoSize}

{$region FillArray2}

type
  CLMemoryCommandFillArray2<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private                a: CommandQueue<array[,] of TRecord>;
    private           a_ind1: CommandQueue<integer>;
    private           a_ind2: CommandQueue<integer>;
    private pattern_byte_len: CommandQueue<integer>;
    private       mem_offset: CommandQueue<integer>;
    private    fill_byte_len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 6;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'записывать в область памяти OpenCL');
    end;
    public constructor(a: CommandQueue<array[,] of TRecord>; a_ind1,a_ind2, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>);
    begin
      self.               a :=                a;
      self.          a_ind1 :=           a_ind1;
      self.          a_ind2 :=           a_ind2;
      self.pattern_byte_len := pattern_byte_len;
      self.      mem_offset :=       mem_offset;
      self.   fill_byte_len :=    fill_byte_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
                     a.InitBeforeInvoke(g, prev_hubs);
                a_ind1.InitBeforeInvoke(g, prev_hubs);
                a_ind2.InitBeforeInvoke(g, prev_hubs);
      pattern_byte_len.InitBeforeInvoke(g, prev_hubs);
            mem_offset.InitBeforeInvoke(g, prev_hubs);
         fill_byte_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var                a_qr: QueueRes<array[,] of TRecord>;
      var           a_ind1_qr: QueueRes<integer>;
      var           a_ind2_qr: QueueRes<integer>;
      var pattern_byte_len_qr: QueueRes<integer>;
      var       mem_offset_qr: QueueRes<integer>;
      var    fill_byte_len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
                       a_qr := invoker.InvokeBranch(               a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
                  a_ind1_qr := invoker.InvokeBranch(          a_ind1.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
                  a_ind2_qr := invoker.InvokeBranch(          a_ind2.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        pattern_byte_len_qr := invoker.InvokeBranch(pattern_byte_len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
              mem_offset_qr := invoker.InvokeBranch(      mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
           fill_byte_len_qr := invoker.InvokeBranch(   fill_byte_len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
                       a_qr.CancelStatusCheck('enq cancel');
                  a_ind1_qr.CancelStatusCheck('enq cancel');
                  a_ind2_qr.CancelStatusCheck('enq cancel');
        pattern_byte_len_qr.CancelStatusCheck('enq cancel');
              mem_offset_qr.CancelStatusCheck('enq cancel');
           fill_byte_len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var                a :=                a_qr.GetResDirect;
        var           a_ind1 :=           a_ind1_qr.GetResDirect;
        var           a_ind2 :=           a_ind2_qr.GetResDirect;
        var pattern_byte_len := pattern_byte_len_qr.GetResDirect;
        var       mem_offset :=       mem_offset_qr.GetResDirect;
        var    fill_byte_len :=    fill_byte_len_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          a[a_ind1,a_ind2], new UIntPtr(pattern_byte_len),
          new UIntPtr(mem_offset), new UIntPtr(fill_byte_len),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind1:';
      sb += ' ';
      a_ind1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind2:';
      sb += ' ';
      a_ind2.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'pattern_byte_len:';
      sb += ' ';
      pattern_byte_len.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_byte_len:';
      sb += ' ';
      fill_byte_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenFillArray2<TRecord>(a: CommandQueue<array[,] of TRecord>; a_ind1,a_ind2, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandFillArray2<TRecord>(a, a_ind1, a_ind2, pattern_byte_len, mem_offset, fill_byte_len));
end;

{$endregion FillArray2}

{$region FillArray3!AutoSize}

type
  CLMemoryCommandFillArray3AutoSize<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private a: CommandQueue<array[,,] of TRecord>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'записывать в область памяти OpenCL');
    end;
    public constructor(a: CommandQueue<array[,,] of TRecord>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var a_qr: QueueRes<array[,,] of TRecord>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        a_qr := invoker.InvokeBranch(a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        a_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          a[0,0,0], new UIntPtr(a.Length*Marshal.SizeOf(default(TRecord))),
          UIntPtr.Zero, o.Size,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenFillArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandFillArray3AutoSize<TRecord>(a));
end;

{$endregion FillArray3!AutoSize}

{$region FillArray3}

type
  CLMemoryCommandFillArray3<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private                a: CommandQueue<array[,,] of TRecord>;
    private           a_ind1: CommandQueue<integer>;
    private           a_ind2: CommandQueue<integer>;
    private           a_ind3: CommandQueue<integer>;
    private pattern_byte_len: CommandQueue<integer>;
    private       mem_offset: CommandQueue<integer>;
    private    fill_byte_len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 7;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'записывать в область памяти OpenCL');
    end;
    public constructor(a: CommandQueue<array[,,] of TRecord>; a_ind1,a_ind2,a_ind3, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>);
    begin
      self.               a :=                a;
      self.          a_ind1 :=           a_ind1;
      self.          a_ind2 :=           a_ind2;
      self.          a_ind3 :=           a_ind3;
      self.pattern_byte_len := pattern_byte_len;
      self.      mem_offset :=       mem_offset;
      self.   fill_byte_len :=    fill_byte_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
                     a.InitBeforeInvoke(g, prev_hubs);
                a_ind1.InitBeforeInvoke(g, prev_hubs);
                a_ind2.InitBeforeInvoke(g, prev_hubs);
                a_ind3.InitBeforeInvoke(g, prev_hubs);
      pattern_byte_len.InitBeforeInvoke(g, prev_hubs);
            mem_offset.InitBeforeInvoke(g, prev_hubs);
         fill_byte_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var                a_qr: QueueRes<array[,,] of TRecord>;
      var           a_ind1_qr: QueueRes<integer>;
      var           a_ind2_qr: QueueRes<integer>;
      var           a_ind3_qr: QueueRes<integer>;
      var pattern_byte_len_qr: QueueRes<integer>;
      var       mem_offset_qr: QueueRes<integer>;
      var    fill_byte_len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
                       a_qr := invoker.InvokeBranch(               a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
                  a_ind1_qr := invoker.InvokeBranch(          a_ind1.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
                  a_ind2_qr := invoker.InvokeBranch(          a_ind2.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
                  a_ind3_qr := invoker.InvokeBranch(          a_ind3.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        pattern_byte_len_qr := invoker.InvokeBranch(pattern_byte_len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
              mem_offset_qr := invoker.InvokeBranch(      mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
           fill_byte_len_qr := invoker.InvokeBranch(   fill_byte_len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
                       a_qr.CancelStatusCheck('enq cancel');
                  a_ind1_qr.CancelStatusCheck('enq cancel');
                  a_ind2_qr.CancelStatusCheck('enq cancel');
                  a_ind3_qr.CancelStatusCheck('enq cancel');
        pattern_byte_len_qr.CancelStatusCheck('enq cancel');
              mem_offset_qr.CancelStatusCheck('enq cancel');
           fill_byte_len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var                a :=                a_qr.GetResDirect;
        var           a_ind1 :=           a_ind1_qr.GetResDirect;
        var           a_ind2 :=           a_ind2_qr.GetResDirect;
        var           a_ind3 :=           a_ind3_qr.GetResDirect;
        var pattern_byte_len := pattern_byte_len_qr.GetResDirect;
        var       mem_offset :=       mem_offset_qr.GetResDirect;
        var    fill_byte_len :=    fill_byte_len_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          a[a_ind1,a_ind2,a_ind3], new UIntPtr(pattern_byte_len),
          new UIntPtr(mem_offset), new UIntPtr(fill_byte_len),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind1:';
      sb += ' ';
      a_ind1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind2:';
      sb += ' ';
      a_ind2.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind3:';
      sb += ' ';
      a_ind3.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'pattern_byte_len:';
      sb += ' ';
      pattern_byte_len.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_byte_len:';
      sb += ' ';
      fill_byte_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenFillArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>; a_ind1,a_ind2,a_ind3, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandFillArray3<TRecord>(a, a_ind1, a_ind2, a_ind3, pattern_byte_len, mem_offset, fill_byte_len));
end;

{$endregion FillArray3}

{$region FillArraySegment!AutoSize}

type
  CLMemoryCommandFillArraySegmentAutoSize<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private a: CommandQueue<ArraySegment<TRecord>>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'записывать в область памяти OpenCL');
    end;
    public constructor(a: CommandQueue<ArraySegment<TRecord>>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var a_qr: QueueRes<ArraySegment<TRecord>>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        a_qr := invoker.InvokeBranch(a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        a_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a.Array, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          a.Array[a.Offset], new UIntPtr(a.Count * Marshal.SizeOf(default(TRecord))),
          UIntPtr.Zero,o.Size,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenFillArraySegment<TRecord>(a: CommandQueue<ArraySegment<TRecord>>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandFillArraySegmentAutoSize<TRecord>(a));
end;

{$endregion FillArraySegment!AutoSize}

{$region FillArraySegment}

type
  CLMemoryCommandFillArraySegment<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private             a: CommandQueue<ArraySegment<TRecord>>;
    private    mem_offset: CommandQueue<integer>;
    private fill_byte_len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 3;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'записывать в область памяти OpenCL');
    end;
    public constructor(a: CommandQueue<ArraySegment<TRecord>>; mem_offset, fill_byte_len: CommandQueue<integer>);
    begin
      self.            a :=             a;
      self.   mem_offset :=    mem_offset;
      self.fill_byte_len := fill_byte_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
                  a.InitBeforeInvoke(g, prev_hubs);
         mem_offset.InitBeforeInvoke(g, prev_hubs);
      fill_byte_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var             a_qr: QueueRes<ArraySegment<TRecord>>;
      var    mem_offset_qr: QueueRes<integer>;
      var fill_byte_len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
                    a_qr := invoker.InvokeBranch(            a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
           mem_offset_qr := invoker.InvokeBranch(   mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        fill_byte_len_qr := invoker.InvokeBranch(fill_byte_len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
                    a_qr.CancelStatusCheck('enq cancel');
           mem_offset_qr.CancelStatusCheck('enq cancel');
        fill_byte_len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var             a :=             a_qr.GetResDirect;
        var    mem_offset :=    mem_offset_qr.GetResDirect;
        var fill_byte_len := fill_byte_len_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a.Array, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          a.Array[a.Offset], new UIntPtr(a.Count * Marshal.SizeOf(default(TRecord))),
          new UIntPtr(mem_offset),new UIntPtr(fill_byte_len),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_byte_len:';
      sb += ' ';
      fill_byte_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenFillArraySegment<TRecord>(a: CommandQueue<ArraySegment<TRecord>>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandFillArraySegment<TRecord>(a, mem_offset, fill_byte_len));
end;

{$endregion FillArraySegment}

{$region FillArraySegment!AutoSize}

function CLMemoryCCQ.ThenFillArraySegment<TRecord>(a: ArraySegment<TRecord>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenFillArraySegment(CQ(a));
end;

{$endregion FillArraySegment!AutoSize}

{$region FillArraySegment}

function CLMemoryCCQ.ThenFillArraySegment<TRecord>(a: ArraySegment<TRecord>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenFillArraySegment(CQ(a),mem_offset,fill_byte_len);
end;

{$endregion FillArraySegment}

{$region FillData!AutoSize}

type
  CLMemoryCommandFillDataAutoSize = sealed class(EnqueueableGPUCommand<CLMemory>)
    private              ptr: CommandQueue<IntPtr>;
    private pattern_byte_len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    public constructor(ptr: CommandQueue<IntPtr>; pattern_byte_len: CommandQueue<integer>);
    begin
      self.             ptr :=              ptr;
      self.pattern_byte_len := pattern_byte_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
                   ptr.InitBeforeInvoke(g, prev_hubs);
      pattern_byte_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var              ptr_qr: QueueRes<IntPtr>;
      var pattern_byte_len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
                     ptr_qr := invoker.InvokeBranch(             ptr.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        pattern_byte_len_qr := invoker.InvokeBranch(pattern_byte_len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
                     ptr_qr.CancelStatusCheck('enq cancel');
        pattern_byte_len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var              ptr :=              ptr_qr.GetResDirect;
        var pattern_byte_len := pattern_byte_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          ptr, new UIntPtr(pattern_byte_len),
          UIntPtr.Zero, o.Size,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'ptr:';
      sb += ' ';
      ptr.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'pattern_byte_len:';
      sb += ' ';
      pattern_byte_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenFillData(ptr: CommandQueue<IntPtr>; pattern_byte_len: CommandQueue<integer>): CLMemoryCCQ;
begin
  Result := AddCommand(self, new CLMemoryCommandFillDataAutoSize(ptr, pattern_byte_len));
end;

{$endregion FillData!AutoSize}

{$region FillData}

type
  CLMemoryCommandFillData = sealed class(EnqueueableGPUCommand<CLMemory>)
    private              ptr: CommandQueue<IntPtr>;
    private pattern_byte_len: CommandQueue<integer>;
    private       mem_offset: CommandQueue<integer>;
    private    fill_byte_len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 4;
    
    public constructor(ptr: CommandQueue<IntPtr>; pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>);
    begin
      self.             ptr :=              ptr;
      self.pattern_byte_len := pattern_byte_len;
      self.      mem_offset :=       mem_offset;
      self.   fill_byte_len :=    fill_byte_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
                   ptr.InitBeforeInvoke(g, prev_hubs);
      pattern_byte_len.InitBeforeInvoke(g, prev_hubs);
            mem_offset.InitBeforeInvoke(g, prev_hubs);
         fill_byte_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var              ptr_qr: QueueRes<IntPtr>;
      var pattern_byte_len_qr: QueueRes<integer>;
      var       mem_offset_qr: QueueRes<integer>;
      var    fill_byte_len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
                     ptr_qr := invoker.InvokeBranch(             ptr.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        pattern_byte_len_qr := invoker.InvokeBranch(pattern_byte_len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
              mem_offset_qr := invoker.InvokeBranch(      mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
           fill_byte_len_qr := invoker.InvokeBranch(   fill_byte_len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
                     ptr_qr.CancelStatusCheck('enq cancel');
        pattern_byte_len_qr.CancelStatusCheck('enq cancel');
              mem_offset_qr.CancelStatusCheck('enq cancel');
           fill_byte_len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var              ptr :=              ptr_qr.GetResDirect;
        var pattern_byte_len := pattern_byte_len_qr.GetResDirect;
        var       mem_offset :=       mem_offset_qr.GetResDirect;
        var    fill_byte_len :=    fill_byte_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          ptr, new UIntPtr(pattern_byte_len),
          new UIntPtr(mem_offset), new UIntPtr(fill_byte_len),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'ptr:';
      sb += ' ';
      ptr.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'pattern_byte_len:';
      sb += ' ';
      pattern_byte_len.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_byte_len:';
      sb += ' ';
      fill_byte_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenFillData(ptr: CommandQueue<IntPtr>; pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ;
begin
  Result := AddCommand(self, new CLMemoryCommandFillData(ptr, pattern_byte_len, mem_offset, fill_byte_len));
end;

{$endregion FillData}

{$region FillData!AutoSize}

function CLMemoryCCQ.ThenFillData(ptr: pointer; pattern_byte_len: CommandQueue<integer>): CLMemoryCCQ;
begin
  Result := ThenFillData(IntPtr(ptr), pattern_byte_len);
end;

{$endregion FillData!AutoSize}

{$region FillData}

function CLMemoryCCQ.ThenFillData(ptr: pointer; pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ;
begin
  Result := ThenFillData(IntPtr(ptr), pattern_byte_len, mem_offset, fill_byte_len);
end;

{$endregion FillData}

{$region FillNativeMemoryArea!AutoSize}

function CLMemoryCCQ.ThenFillNativeMemoryArea(native_data: NativeMemoryArea): CLMemoryCCQ;
begin
  Result := ThenFillNativeMemoryArea(CQ(native_data));
end;

{$endregion FillNativeMemoryArea!AutoSize}

{$region FillNativeMemoryArea}

function CLMemoryCCQ.ThenFillNativeMemoryArea(native_data: NativeMemoryArea; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ;
begin
  Result := ThenFillNativeMemoryArea(CQ(native_data),mem_offset,fill_byte_len);
end;

{$endregion FillNativeMemoryArea}

{$region FillNativeMemory!AutoSize}

function CLMemoryCCQ.ThenFillNativeMemory(native_data: NativeMemory): CLMemoryCCQ;
begin
  Result := ThenFillNativeMemory(CQ(native_data));
end;

{$endregion FillNativeMemory!AutoSize}

{$region FillNativeMemory}

function CLMemoryCCQ.ThenFillNativeMemory(native_data: NativeMemory; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ;
begin
  Result := ThenFillNativeMemory(CQ(native_data),mem_offset,fill_byte_len);
end;

{$endregion FillNativeMemory}

{$region FillNativeValueArea!AutoSize}

function CLMemoryCCQ.ThenFillNativeValueArea<TRecord>(native_data: NativeValueArea<TRecord>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenFillNativeValueArea(CQ(native_data));
end;

{$endregion FillNativeValueArea!AutoSize}

{$region FillNativeValueArea}

function CLMemoryCCQ.ThenFillNativeValueArea<TRecord>(native_data: NativeValueArea<TRecord>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenFillNativeValueArea(CQ(native_data),mem_offset,fill_byte_len);
end;

{$endregion FillNativeValueArea}

{$region FillNativeValue!AutoSize}

function CLMemoryCCQ.ThenFillNativeValue<TRecord>(native_data: NativeValue<TRecord>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenFillNativeValue(CQ(native_data));
end;

{$endregion FillNativeValue!AutoSize}

{$region FillNativeValue}

function CLMemoryCCQ.ThenFillNativeValue<TRecord>(native_data: NativeValue<TRecord>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenFillNativeValue(CQ(native_data),mem_offset,fill_byte_len);
end;

{$endregion FillNativeValue}

{$region FillNativeArrayArea!AutoSize}

function CLMemoryCCQ.ThenFillNativeArrayArea<TRecord>(native_data: NativeArrayArea<TRecord>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenFillNativeArrayArea(CQ(native_data));
end;

{$endregion FillNativeArrayArea!AutoSize}

{$region FillNativeArrayArea}

function CLMemoryCCQ.ThenFillNativeArrayArea<TRecord>(native_data: NativeArrayArea<TRecord>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenFillNativeArrayArea(CQ(native_data),mem_offset,fill_byte_len);
end;

{$endregion FillNativeArrayArea}

{$region FillNativeArray!AutoSize}

function CLMemoryCCQ.ThenFillNativeArray<TRecord>(native_data: NativeArray<TRecord>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenFillNativeArray(CQ(native_data));
end;

{$endregion FillNativeArray!AutoSize}

{$region FillNativeArray}

function CLMemoryCCQ.ThenFillNativeArray<TRecord>(native_data: NativeArray<TRecord>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := ThenFillNativeArray(CQ(native_data),mem_offset,fill_byte_len);
end;

{$endregion FillNativeArray}

{$region FillNativeMemoryArea!AutoSize}

type
  CLMemoryCommandFillNativeMemoryAreaAutoSize = sealed class(EnqueueableGPUCommand<CLMemory>)
    private native_data: CommandQueue<NativeMemoryArea>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(native_data: CommandQueue<NativeMemoryArea>);
    begin
      self.native_data := native_data;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var native_data_qr: QueueRes<NativeMemoryArea>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.ptr,
          native_data.sz,
          UIntPtr.Zero, o.Size,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenFillNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>): CLMemoryCCQ;
begin
  Result := AddCommand(self, new CLMemoryCommandFillNativeMemoryAreaAutoSize(native_data));
end;

{$endregion FillNativeMemoryArea!AutoSize}

{$region FillNativeMemoryArea}

type
  CLMemoryCommandFillNativeMemoryArea = sealed class(EnqueueableGPUCommand<CLMemory>)
    private   native_data: CommandQueue<NativeMemoryArea>;
    private    mem_offset: CommandQueue<integer>;
    private fill_byte_len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 3;
    
    public constructor(native_data: CommandQueue<NativeMemoryArea>; mem_offset, fill_byte_len: CommandQueue<integer>);
    begin
      self.  native_data :=   native_data;
      self.   mem_offset :=    mem_offset;
      self.fill_byte_len := fill_byte_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
        native_data.InitBeforeInvoke(g, prev_hubs);
         mem_offset.InitBeforeInvoke(g, prev_hubs);
      fill_byte_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var   native_data_qr: QueueRes<NativeMemoryArea>;
      var    mem_offset_qr: QueueRes<integer>;
      var fill_byte_len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
          native_data_qr := invoker.InvokeBranch(  native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
           mem_offset_qr := invoker.InvokeBranch(   mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        fill_byte_len_qr := invoker.InvokeBranch(fill_byte_len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
          native_data_qr.CancelStatusCheck('enq cancel');
           mem_offset_qr.CancelStatusCheck('enq cancel');
        fill_byte_len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var   native_data :=   native_data_qr.GetResDirect;
        var    mem_offset :=    mem_offset_qr.GetResDirect;
        var fill_byte_len := fill_byte_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.ptr,
          native_data.sz,
          new UIntPtr(mem_offset), new UIntPtr(fill_byte_len),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_byte_len:';
      sb += ' ';
      fill_byte_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenFillNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ;
begin
  Result := AddCommand(self, new CLMemoryCommandFillNativeMemoryArea(native_data, mem_offset, fill_byte_len));
end;

{$endregion FillNativeMemoryArea}

{$region FillNativeMemory!AutoSize}

type
  CLMemoryCommandFillNativeMemoryAutoSize = sealed class(EnqueueableGPUCommand<CLMemory>)
    private native_data: CommandQueue<NativeMemory>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(native_data: CommandQueue<NativeMemory>);
    begin
      self.native_data := native_data;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var native_data_qr: QueueRes<NativeMemory>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.Area.ptr,
          native_data.Area.sz,
          UIntPtr.Zero, o.Size,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenFillNativeMemory(native_data: CommandQueue<NativeMemory>): CLMemoryCCQ;
begin
  Result := AddCommand(self, new CLMemoryCommandFillNativeMemoryAutoSize(native_data));
end;

{$endregion FillNativeMemory!AutoSize}

{$region FillNativeMemory}

type
  CLMemoryCommandFillNativeMemory = sealed class(EnqueueableGPUCommand<CLMemory>)
    private   native_data: CommandQueue<NativeMemory>;
    private    mem_offset: CommandQueue<integer>;
    private fill_byte_len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 3;
    
    public constructor(native_data: CommandQueue<NativeMemory>; mem_offset, fill_byte_len: CommandQueue<integer>);
    begin
      self.  native_data :=   native_data;
      self.   mem_offset :=    mem_offset;
      self.fill_byte_len := fill_byte_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
        native_data.InitBeforeInvoke(g, prev_hubs);
         mem_offset.InitBeforeInvoke(g, prev_hubs);
      fill_byte_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var   native_data_qr: QueueRes<NativeMemory>;
      var    mem_offset_qr: QueueRes<integer>;
      var fill_byte_len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
          native_data_qr := invoker.InvokeBranch(  native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
           mem_offset_qr := invoker.InvokeBranch(   mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        fill_byte_len_qr := invoker.InvokeBranch(fill_byte_len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
          native_data_qr.CancelStatusCheck('enq cancel');
           mem_offset_qr.CancelStatusCheck('enq cancel');
        fill_byte_len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var   native_data :=   native_data_qr.GetResDirect;
        var    mem_offset :=    mem_offset_qr.GetResDirect;
        var fill_byte_len := fill_byte_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.Area.ptr,
          native_data.Area.sz,
          new UIntPtr(mem_offset), new UIntPtr(fill_byte_len),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_byte_len:';
      sb += ' ';
      fill_byte_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenFillNativeMemory(native_data: CommandQueue<NativeMemory>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ;
begin
  Result := AddCommand(self, new CLMemoryCommandFillNativeMemory(native_data, mem_offset, fill_byte_len));
end;

{$endregion FillNativeMemory}

{$region FillNativeValueArea!AutoSize}

type
  CLMemoryCommandFillNativeValueAreaAutoSize<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private native_data: CommandQueue<NativeValueArea<TRecord>>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemory:FillNativeValueAreaAutoSize%');
    end;
    public constructor(native_data: CommandQueue<NativeValueArea<TRecord>>);
    begin
      self.native_data := native_data;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var native_data_qr: QueueRes<NativeValueArea<TRecord>>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.ptr,
          native_data.ByteSize,
          UIntPtr.Zero, o.Size,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenFillNativeValueArea<TRecord>(native_data: CommandQueue<NativeValueArea<TRecord>>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandFillNativeValueAreaAutoSize<TRecord>(native_data));
end;

{$endregion FillNativeValueArea!AutoSize}

{$region FillNativeValueArea}

type
  CLMemoryCommandFillNativeValueArea<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private   native_data: CommandQueue<NativeValueArea<TRecord>>;
    private    mem_offset: CommandQueue<integer>;
    private fill_byte_len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 3;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemory:FillNativeValueArea%');
    end;
    public constructor(native_data: CommandQueue<NativeValueArea<TRecord>>; mem_offset, fill_byte_len: CommandQueue<integer>);
    begin
      self.  native_data :=   native_data;
      self.   mem_offset :=    mem_offset;
      self.fill_byte_len := fill_byte_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
        native_data.InitBeforeInvoke(g, prev_hubs);
         mem_offset.InitBeforeInvoke(g, prev_hubs);
      fill_byte_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var   native_data_qr: QueueRes<NativeValueArea<TRecord>>;
      var    mem_offset_qr: QueueRes<integer>;
      var fill_byte_len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
          native_data_qr := invoker.InvokeBranch(  native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
           mem_offset_qr := invoker.InvokeBranch(   mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        fill_byte_len_qr := invoker.InvokeBranch(fill_byte_len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
          native_data_qr.CancelStatusCheck('enq cancel');
           mem_offset_qr.CancelStatusCheck('enq cancel');
        fill_byte_len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var   native_data :=   native_data_qr.GetResDirect;
        var    mem_offset :=    mem_offset_qr.GetResDirect;
        var fill_byte_len := fill_byte_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.ptr,
          native_data.ByteSize,
          new UIntPtr(mem_offset), new UIntPtr(fill_byte_len),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_byte_len:';
      sb += ' ';
      fill_byte_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenFillNativeValueArea<TRecord>(native_data: CommandQueue<NativeValueArea<TRecord>>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandFillNativeValueArea<TRecord>(native_data, mem_offset, fill_byte_len));
end;

{$endregion FillNativeValueArea}

{$region FillNativeValue!AutoSize}

type
  CLMemoryCommandFillNativeValueAutoSize<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private native_data: CommandQueue<NativeValue<TRecord>>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'записывать в область памяти OpenCL');
    end;
    public constructor(native_data: CommandQueue<NativeValue<TRecord>>);
    begin
      self.native_data := native_data;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var native_data_qr: QueueRes<NativeValue<TRecord>>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.Area.ptr,
          native_data.Area.ByteSize,
          UIntPtr.Zero, o.Size,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenFillNativeValue<TRecord>(native_data: CommandQueue<NativeValue<TRecord>>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandFillNativeValueAutoSize<TRecord>(native_data));
end;

{$endregion FillNativeValue!AutoSize}

{$region FillNativeValue}

type
  CLMemoryCommandFillNativeValue<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private   native_data: CommandQueue<NativeValue<TRecord>>;
    private    mem_offset: CommandQueue<integer>;
    private fill_byte_len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 3;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'записывать в область памяти OpenCL');
    end;
    public constructor(native_data: CommandQueue<NativeValue<TRecord>>; mem_offset, fill_byte_len: CommandQueue<integer>);
    begin
      self.  native_data :=   native_data;
      self.   mem_offset :=    mem_offset;
      self.fill_byte_len := fill_byte_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
        native_data.InitBeforeInvoke(g, prev_hubs);
         mem_offset.InitBeforeInvoke(g, prev_hubs);
      fill_byte_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var   native_data_qr: QueueRes<NativeValue<TRecord>>;
      var    mem_offset_qr: QueueRes<integer>;
      var fill_byte_len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
          native_data_qr := invoker.InvokeBranch(  native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
           mem_offset_qr := invoker.InvokeBranch(   mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        fill_byte_len_qr := invoker.InvokeBranch(fill_byte_len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
          native_data_qr.CancelStatusCheck('enq cancel');
           mem_offset_qr.CancelStatusCheck('enq cancel');
        fill_byte_len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var   native_data :=   native_data_qr.GetResDirect;
        var    mem_offset :=    mem_offset_qr.GetResDirect;
        var fill_byte_len := fill_byte_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.Area.ptr,
          native_data.Area.ByteSize,
          new UIntPtr(mem_offset), new UIntPtr(fill_byte_len),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_byte_len:';
      sb += ' ';
      fill_byte_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenFillNativeValue<TRecord>(native_data: CommandQueue<NativeValue<TRecord>>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandFillNativeValue<TRecord>(native_data, mem_offset, fill_byte_len));
end;

{$endregion FillNativeValue}

{$region FillNativeArrayArea!AutoSize}

type
  CLMemoryCommandFillNativeArrayAreaAutoSize<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private native_data: CommandQueue<NativeArrayArea<TRecord>>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemory:FillNativeArrayAreaAutoSize%');
    end;
    public constructor(native_data: CommandQueue<NativeArrayArea<TRecord>>);
    begin
      self.native_data := native_data;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var native_data_qr: QueueRes<NativeArrayArea<TRecord>>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.first_ptr,
          native_data.ByteSize,
          UIntPtr.Zero, o.Size,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenFillNativeArrayArea<TRecord>(native_data: CommandQueue<NativeArrayArea<TRecord>>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandFillNativeArrayAreaAutoSize<TRecord>(native_data));
end;

{$endregion FillNativeArrayArea!AutoSize}

{$region FillNativeArrayArea}

type
  CLMemoryCommandFillNativeArrayArea<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private   native_data: CommandQueue<NativeArrayArea<TRecord>>;
    private    mem_offset: CommandQueue<integer>;
    private fill_byte_len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 3;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemory:FillNativeArrayArea%');
    end;
    public constructor(native_data: CommandQueue<NativeArrayArea<TRecord>>; mem_offset, fill_byte_len: CommandQueue<integer>);
    begin
      self.  native_data :=   native_data;
      self.   mem_offset :=    mem_offset;
      self.fill_byte_len := fill_byte_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
        native_data.InitBeforeInvoke(g, prev_hubs);
         mem_offset.InitBeforeInvoke(g, prev_hubs);
      fill_byte_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var   native_data_qr: QueueRes<NativeArrayArea<TRecord>>;
      var    mem_offset_qr: QueueRes<integer>;
      var fill_byte_len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
          native_data_qr := invoker.InvokeBranch(  native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
           mem_offset_qr := invoker.InvokeBranch(   mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        fill_byte_len_qr := invoker.InvokeBranch(fill_byte_len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
          native_data_qr.CancelStatusCheck('enq cancel');
           mem_offset_qr.CancelStatusCheck('enq cancel');
        fill_byte_len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var   native_data :=   native_data_qr.GetResDirect;
        var    mem_offset :=    mem_offset_qr.GetResDirect;
        var fill_byte_len := fill_byte_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.first_ptr,
          native_data.ByteSize,
          new UIntPtr(mem_offset), new UIntPtr(fill_byte_len),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_byte_len:';
      sb += ' ';
      fill_byte_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenFillNativeArrayArea<TRecord>(native_data: CommandQueue<NativeArrayArea<TRecord>>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandFillNativeArrayArea<TRecord>(native_data, mem_offset, fill_byte_len));
end;

{$endregion FillNativeArrayArea}

{$region FillNativeArray!AutoSize}

type
  CLMemoryCommandFillNativeArrayAutoSize<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private native_data: CommandQueue<NativeArray<TRecord>>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'записывать в область памяти OpenCL');
    end;
    public constructor(native_data: CommandQueue<NativeArray<TRecord>>);
    begin
      self.native_data := native_data;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var native_data_qr: QueueRes<NativeArray<TRecord>>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.Area.first_ptr,
          native_data.Area.ByteSize,
          UIntPtr.Zero, o.Size,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenFillNativeArray<TRecord>(native_data: CommandQueue<NativeArray<TRecord>>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandFillNativeArrayAutoSize<TRecord>(native_data));
end;

{$endregion FillNativeArray!AutoSize}

{$region FillNativeArray}

type
  CLMemoryCommandFillNativeArray<TRecord> = sealed class(EnqueueableGPUCommand<CLMemory>)
  where TRecord: record;
    private   native_data: CommandQueue<NativeArray<TRecord>>;
    private    mem_offset: CommandQueue<integer>;
    private fill_byte_len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 3;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'записывать в область памяти OpenCL');
    end;
    public constructor(native_data: CommandQueue<NativeArray<TRecord>>; mem_offset, fill_byte_len: CommandQueue<integer>);
    begin
      self.  native_data :=   native_data;
      self.   mem_offset :=    mem_offset;
      self.fill_byte_len := fill_byte_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
        native_data.InitBeforeInvoke(g, prev_hubs);
         mem_offset.InitBeforeInvoke(g, prev_hubs);
      fill_byte_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var   native_data_qr: QueueRes<NativeArray<TRecord>>;
      var    mem_offset_qr: QueueRes<integer>;
      var fill_byte_len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
          native_data_qr := invoker.InvokeBranch(  native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
           mem_offset_qr := invoker.InvokeBranch(   mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        fill_byte_len_qr := invoker.InvokeBranch(fill_byte_len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
          native_data_qr.CancelStatusCheck('enq cancel');
           mem_offset_qr.CancelStatusCheck('enq cancel');
        fill_byte_len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var   native_data :=   native_data_qr.GetResDirect;
        var    mem_offset :=    mem_offset_qr.GetResDirect;
        var fill_byte_len := fill_byte_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.Area.first_ptr,
          native_data.Area.ByteSize,
          new UIntPtr(mem_offset), new UIntPtr(fill_byte_len),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_byte_len:';
      sb += ' ';
      fill_byte_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenFillNativeArray<TRecord>(native_data: CommandQueue<NativeArray<TRecord>>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemoryCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemoryCommandFillNativeArray<TRecord>(native_data, mem_offset, fill_byte_len));
end;

{$endregion FillNativeArray}

{$endregion 2#Fill}

{$region 3#Copy}

{$region CopyTo!AutoSize}

type
  CLMemoryCommandCopyToAutoSize = sealed class(EnqueueableGPUCommand<CLMemory>)
    private mem: CommandQueue<CLMemory>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(mem: CommandQueue<CLMemory>);
    begin
      self.mem := mem;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      mem.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var mem_qr: QueueRes<CLMemory>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        mem_qr := invoker.InvokeBranch(mem.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        mem_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var mem := mem_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueCopyBuffer(
          cq, o.Native,mem.Native,
          UIntPtr.Zero, UIntPtr.Zero,
          o.Size64<mem.Size64 ? o.Size : mem.Size,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'mem:';
      sb += ' ';
      mem.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenCopyTo(mem: CommandQueue<CLMemory>): CLMemoryCCQ;
begin
  Result := AddCommand(self, new CLMemoryCommandCopyToAutoSize(mem));
end;

{$endregion CopyTo!AutoSize}

{$region CopyTo}

type
  CLMemoryCommandCopyTo = sealed class(EnqueueableGPUCommand<CLMemory>)
    private         mem: CommandQueue<CLMemory>;
    private from_offset: CommandQueue<integer>;
    private   to_offset: CommandQueue<integer>;
    private         len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 4;
    
    public constructor(mem: CommandQueue<CLMemory>; from_offset, to_offset, len: CommandQueue<integer>);
    begin
      self.        mem :=         mem;
      self.from_offset := from_offset;
      self.  to_offset :=   to_offset;
      self.        len :=         len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
              mem.InitBeforeInvoke(g, prev_hubs);
      from_offset.InitBeforeInvoke(g, prev_hubs);
        to_offset.InitBeforeInvoke(g, prev_hubs);
              len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var         mem_qr: QueueRes<CLMemory>;
      var from_offset_qr: QueueRes<integer>;
      var   to_offset_qr: QueueRes<integer>;
      var         len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
                mem_qr := invoker.InvokeBranch(        mem.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        from_offset_qr := invoker.InvokeBranch(from_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
          to_offset_qr := invoker.InvokeBranch(  to_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
                len_qr := invoker.InvokeBranch(        len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
                mem_qr.CancelStatusCheck('enq cancel');
        from_offset_qr.CancelStatusCheck('enq cancel');
          to_offset_qr.CancelStatusCheck('enq cancel');
                len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var         mem :=         mem_qr.GetResDirect;
        var from_offset := from_offset_qr.GetResDirect;
        var   to_offset :=   to_offset_qr.GetResDirect;
        var         len :=         len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueCopyBuffer(
          cq, o.Native,mem.Native,
          new UIntPtr(from_offset), new UIntPtr(to_offset),
          new UIntPtr(len),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'mem:';
      sb += ' ';
      mem.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'from_offset:';
      sb += ' ';
      from_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'to_offset:';
      sb += ' ';
      to_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenCopyTo(mem: CommandQueue<CLMemory>; from_offset, to_offset, len: CommandQueue<integer>): CLMemoryCCQ;
begin
  Result := AddCommand(self, new CLMemoryCommandCopyTo(mem, from_offset, to_offset, len));
end;

{$endregion CopyTo}

{$region CopyFrom!AutoSize}

type
  CLMemoryCommandCopyFromAutoSize = sealed class(EnqueueableGPUCommand<CLMemory>)
    private mem: CommandQueue<CLMemory>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(mem: CommandQueue<CLMemory>);
    begin
      self.mem := mem;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      mem.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var mem_qr: QueueRes<CLMemory>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        mem_qr := invoker.InvokeBranch(mem.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        mem_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var mem := mem_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueCopyBuffer(
          cq, mem.Native,o.Native,
          UIntPtr.Zero, UIntPtr.Zero,
          o.Size64<mem.Size64 ? o.Size : mem.Size,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'mem:';
      sb += ' ';
      mem.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenCopyFrom(mem: CommandQueue<CLMemory>): CLMemoryCCQ;
begin
  Result := AddCommand(self, new CLMemoryCommandCopyFromAutoSize(mem));
end;

{$endregion CopyFrom!AutoSize}

{$region CopyFrom}

type
  CLMemoryCommandCopyFrom = sealed class(EnqueueableGPUCommand<CLMemory>)
    private         mem: CommandQueue<CLMemory>;
    private from_offset: CommandQueue<integer>;
    private   to_offset: CommandQueue<integer>;
    private         len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 4;
    
    public constructor(mem: CommandQueue<CLMemory>; from_offset, to_offset, len: CommandQueue<integer>);
    begin
      self.        mem :=         mem;
      self.from_offset := from_offset;
      self.  to_offset :=   to_offset;
      self.        len :=         len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
              mem.InitBeforeInvoke(g, prev_hubs);
      from_offset.InitBeforeInvoke(g, prev_hubs);
        to_offset.InitBeforeInvoke(g, prev_hubs);
              len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLMemory>; override;
    begin
      var         mem_qr: QueueRes<CLMemory>;
      var from_offset_qr: QueueRes<integer>;
      var   to_offset_qr: QueueRes<integer>;
      var         len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
                mem_qr := invoker.InvokeBranch(        mem.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        from_offset_qr := invoker.InvokeBranch(from_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
          to_offset_qr := invoker.InvokeBranch(  to_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
                len_qr := invoker.InvokeBranch(        len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
                mem_qr.CancelStatusCheck('enq cancel');
        from_offset_qr.CancelStatusCheck('enq cancel');
          to_offset_qr.CancelStatusCheck('enq cancel');
                len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var         mem :=         mem_qr.GetResDirect;
        var from_offset := from_offset_qr.GetResDirect;
        var   to_offset :=   to_offset_qr.GetResDirect;
        var         len :=         len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueCopyBuffer(
          cq, mem.Native,o.Native,
          new UIntPtr(from_offset), new UIntPtr(to_offset),
          new UIntPtr(len),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'mem:';
      sb += ' ';
      mem.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'from_offset:';
      sb += ' ';
      from_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'to_offset:';
      sb += ' ';
      to_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenCopyFrom(mem: CommandQueue<CLMemory>; from_offset, to_offset, len: CommandQueue<integer>): CLMemoryCCQ;
begin
  Result := AddCommand(self, new CLMemoryCommandCopyFrom(mem, from_offset, to_offset, len));
end;

{$endregion CopyFrom}

{$endregion 3#Copy}

{$region Get}

{$region GetValue}

function CLMemoryCCQ.ThenGetValue<TRecord>: CommandQueue<TRecord>; where TRecord: record;
begin
  Result := ThenGetValue&<TRecord>(0);
end;

{$endregion GetValue}

{$region GetValue}

type
  CLMemoryCommandGetValue<TRecord> = sealed class(EnqueueableGetPtrCommand<CLMemory, TRecord>)
  where TRecord: record;
    private mem_offset: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'читать из области памяти OpenCL');
    end;
    public constructor(ccq: CLMemoryCCQ; mem_offset: CommandQueue<integer>);
    begin
      inherited Create(ccq);
      self.mem_offset := mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      prev_commands.InitBeforeInvoke(g, prev_hubs);
      mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>; own_qr: QueueRes<TRecord>): ParamInvRes<CLMemory>; override;
    begin
      var mem_offset_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        mem_offset_qr := invoker.InvokeBranch(mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        mem_offset_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var mem_offset := mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(mem_offset), new UIntPtr(Marshal.SizeOf(default(TRecord))),
          (own_qr as QueueResPtr<TRecord>).GetResPtrForWrite,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          GC.KeepAlive(own_qr);
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenGetValue<TRecord>(mem_offset: CommandQueue<integer>): CommandQueue<TRecord>; where TRecord: record;
begin
  Result := new CLMemoryCommandGetValue<TRecord>(self, mem_offset) as CommandQueue<TRecord>;
end;

{$endregion GetValue}

{$region GetArray!AutoSize}

type
  CLMemoryCommandGetArrayAutoSize<TRecord> = sealed class(EnqueueableGetCommand<CLMemory, array of TRecord>)
  where TRecord: record;
    
    protected function ExpectedEnqCount: integer; override := 0;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'читать из области памяти OpenCL');
    end;
    public constructor(ccq: CLMemoryCCQ);
    begin
      inherited Create(ccq);
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override := prev_commands.InitBeforeInvoke(g, prev_hubs);
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>; own_qr: QueueRes<array of TRecord>): ParamInvRes<CLMemory>; override;
    begin
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var res := new TRecord[o.Size64 div Marshal.SizeOf(default(TRecord))];;
        own_qr.SetRes(res);
        var res_hnd := GCHandle.Alloc(res, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(0), new UIntPtr(res.Length * Marshal.SizeOf(default(TRecord))),
          res_hnd.AddrOfPinnedObject.ToPointer,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          res_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override := sb += #10;
    
  end;
  
function CLMemoryCCQ.ThenGetArray<TRecord>: CommandQueue<array of TRecord>; where TRecord: record;
begin
  Result := new CLMemoryCommandGetArrayAutoSize<TRecord>(self) as CommandQueue<array of TRecord>;
end;

{$endregion GetArray!AutoSize}

{$region GetArray}

type
  CLMemoryCommandGetArray<TRecord> = sealed class(EnqueueableGetCommand<CLMemory, array of TRecord>)
  where TRecord: record;
    private len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'читать из области памяти OpenCL');
    end;
    public constructor(ccq: CLMemoryCCQ; len: CommandQueue<integer>);
    begin
      inherited Create(ccq);
      self.len := len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      prev_commands.InitBeforeInvoke(g, prev_hubs);
      len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>; own_qr: QueueRes<array of TRecord>): ParamInvRes<CLMemory>; override;
    begin
      var len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        len_qr := invoker.InvokeBranch(len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var len := len_qr.GetResDirect;
        var res := new TRecord[len];
        own_qr.SetRes(res);
        var res_hnd := GCHandle.Alloc(res, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(0), new UIntPtr(int64(len) * Marshal.SizeOf(default(TRecord))),
          res[0],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          res_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenGetArray<TRecord>(len: CommandQueue<integer>): CommandQueue<array of TRecord>; where TRecord: record;
begin
  Result := new CLMemoryCommandGetArray<TRecord>(self, len) as CommandQueue<array of TRecord>;
end;

{$endregion GetArray}

{$region GetArray2}

type
  CLMemoryCommandGetArray2<TRecord> = sealed class(EnqueueableGetCommand<CLMemory, array[,] of TRecord>)
  where TRecord: record;
    private len1: CommandQueue<integer>;
    private len2: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'читать из области памяти OpenCL');
    end;
    public constructor(ccq: CLMemoryCCQ; len1,len2: CommandQueue<integer>);
    begin
      inherited Create(ccq);
      self.len1 := len1;
      self.len2 := len2;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      prev_commands.InitBeforeInvoke(g, prev_hubs);
      len1.InitBeforeInvoke(g, prev_hubs);
      len2.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>; own_qr: QueueRes<array[,] of TRecord>): ParamInvRes<CLMemory>; override;
    begin
      var len1_qr: QueueRes<integer>;
      var len2_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        len1_qr := invoker.InvokeBranch(len1.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        len2_qr := invoker.InvokeBranch(len2.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        len1_qr.CancelStatusCheck('enq cancel');
        len2_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var len1 := len1_qr.GetResDirect;
        var len2 := len2_qr.GetResDirect;
        var res := new TRecord[len1,len2];
        own_qr.SetRes(res);
        var res_hnd := GCHandle.Alloc(res, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(0), new UIntPtr(int64(len1)*len2 * Marshal.SizeOf(default(TRecord))),
          res[0,0],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          res_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'len1:';
      sb += ' ';
      len1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len2:';
      sb += ' ';
      len2.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenGetArray2<TRecord>(len1,len2: CommandQueue<integer>): CommandQueue<array[,] of TRecord>; where TRecord: record;
begin
  Result := new CLMemoryCommandGetArray2<TRecord>(self, len1, len2) as CommandQueue<array[,] of TRecord>;
end;

{$endregion GetArray2}

{$region GetArray3}

type
  CLMemoryCommandGetArray3<TRecord> = sealed class(EnqueueableGetCommand<CLMemory, array[,,] of TRecord>)
  where TRecord: record;
    private len1: CommandQueue<integer>;
    private len2: CommandQueue<integer>;
    private len3: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 3;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), 'читать из области памяти OpenCL');
    end;
    public constructor(ccq: CLMemoryCCQ; len1,len2,len3: CommandQueue<integer>);
    begin
      inherited Create(ccq);
      self.len1 := len1;
      self.len2 := len2;
      self.len3 := len3;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      prev_commands.InitBeforeInvoke(g, prev_hubs);
      len1.InitBeforeInvoke(g, prev_hubs);
      len2.InitBeforeInvoke(g, prev_hubs);
      len3.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>; own_qr: QueueRes<array[,,] of TRecord>): ParamInvRes<CLMemory>; override;
    begin
      var len1_qr: QueueRes<integer>;
      var len2_qr: QueueRes<integer>;
      var len3_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        len1_qr := invoker.InvokeBranch(len1.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        len2_qr := invoker.InvokeBranch(len2.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        len3_qr := invoker.InvokeBranch(len3.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        len1_qr.CancelStatusCheck('enq cancel');
        len2_qr.CancelStatusCheck('enq cancel');
        len3_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var len1 := len1_qr.GetResDirect;
        var len2 := len2_qr.GetResDirect;
        var len3 := len3_qr.GetResDirect;
        var res := new TRecord[len1,len2,len3];
        own_qr.SetRes(res);
        var res_hnd := GCHandle.Alloc(res, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(0), new UIntPtr(int64(len1)*len2*len3 * Marshal.SizeOf(default(TRecord))),
          res[0,0,0],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          res_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'len1:';
      sb += ' ';
      len1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len2:';
      sb += ' ';
      len2.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len3:';
      sb += ' ';
      len3.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemoryCCQ.ThenGetArray3<TRecord>(len1,len2,len3: CommandQueue<integer>): CommandQueue<array[,,] of TRecord>; where TRecord: record;
begin
  Result := new CLMemoryCommandGetArray3<TRecord>(self, len1, len2, len3) as CommandQueue<array[,,] of TRecord>;
end;

{$endregion GetArray3}

{$endregion Get}

{$endregion Explicit}

{$endregion CLMemory}

{$region CLValue}

{$region Implicit}

{$region 1#Write&Read}

function CLValue<T>.WriteValue(val: &T): CLValue<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenWriteValue(val));
end;

function CLValue<T>.WriteValue(val: CommandQueue<&T>): CLValue<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenWriteValue(val));
end;

function CLValue<T>.WriteNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>): CLValue<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenWriteNativeValueArea(native_data));
end;

function CLValue<T>.WriteNativeValue(native_data: CommandQueue<NativeValue<&T>>): CLValue<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenWriteNativeValue(native_data));
end;

function CLValue<T>.ReadNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>): CLValue<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenReadNativeValueArea(native_data));
end;

function CLValue<T>.ReadNativeValue(native_data: CommandQueue<NativeValue<&T>>): CLValue<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenReadNativeValue(native_data));
end;

{$endregion 1#Write&Read}

{$region 3#Copy}

function CLValue<T>.CopyTo(mem: CommandQueue<CLMemory>): CLValue<T>;
begin
  Result := CopyTo(mem, 0);
end;

function CLValue<T>.CopyFrom(mem: CommandQueue<CLMemory>): CLValue<T>;
begin
  Result := CopyFrom(mem, 0);
end;

function CLValue<T>.CopyTo(mem: CommandQueue<CLMemory>; mem_offset: CommandQueue<integer>): CLValue<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenCopyTo(mem, mem_offset));
end;

function CLValue<T>.CopyFrom(mem: CommandQueue<CLMemory>; mem_offset: CommandQueue<integer>): CLValue<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenCopyFrom(mem, mem_offset));
end;

function CLValue<T>.CopyTo(val: CommandQueue<CLValue<&T>>): CLValue<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenCopyTo(val));
end;

function CLValue<T>.CopyFrom(val: CommandQueue<CLValue<&T>>): CLValue<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenCopyFrom(val));
end;

{$endregion 3#Copy}

{$region Get}

function CLValue<T>.GetValue: &T;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenGetValue);
end;

{$endregion Get}

{$endregion Implicit}

{$region Explicit}

{$region 1#Write&Read}

{$region WriteValue}

type
  CLValueCommandWriteValue<T> = sealed class(EnqueueableGPUCommand<CLValue<T>>)
  where T: record;
    private val := new NativeValueArea<&T>(true);
    
    protected procedure Finalize; override;
    begin
      val.Release;
    end;
    
    protected function ExpectedEnqCount: integer; override := 0;
    
    public constructor(val: &T);
    begin
      self.val.Value := val;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLValue<T>>; override;
    begin
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(Marshal.SizeOf(default(T))),
          val.Pointer,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      sb.Append(val.Value);
      
    end;
    
  end;
  
function CLValueCCQ<T>.ThenWriteValue(val: &T): CLValueCCQ<T>;
begin
  Result := AddCommand(self, new CLValueCommandWriteValue<T>(val));
end;

{$endregion WriteValue}

{$region WriteValue!Q}

type
  CLValueCommandWriteValueQ<T> = sealed class(EnqueueableGPUCommand<CLValue<T>>)
  where T: record;
    private val: CommandQueue<&T>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(val: CommandQueue<&T>);
    begin
      self.val := val;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      val.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLValue<T>>; override;
    begin
      var val_qr: QueueResPtr<&T>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        val_qr := invoker.InvokeBranch(val.InvokeToPtr, par_err_handlers, False).AddToEvLst(g, enq_evs, False);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        val_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var val := val_qr.GetResPtrForRead;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(Marshal.SizeOf(default(T))),
          val,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          GC.KeepAlive(val_qr);
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      val.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLValueCCQ<T>.ThenWriteValue(val: CommandQueue<&T>): CLValueCCQ<T>;
begin
  Result := AddCommand(self, new CLValueCommandWriteValueQ<T>(val));
end;

{$endregion WriteValue!Q}

{$region WriteNativeValueArea}

type
  CLValueCommandWriteNativeValueArea<T> = sealed class(EnqueueableGPUCommand<CLValue<T>>)
  where T: record;
    private native_data: CommandQueue<NativeValueArea<&T>>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(native_data: CommandQueue<NativeValueArea<&T>>);
    begin
      self.native_data := native_data;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLValue<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeValueArea<&T>>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          UIntPtr.Zero, native_data.ByteSize,
          native_data.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLValueCCQ<T>.ThenWriteNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>): CLValueCCQ<T>;
begin
  Result := AddCommand(self, new CLValueCommandWriteNativeValueArea<T>(native_data));
end;

{$endregion WriteNativeValueArea}

{$region WriteNativeValue}

type
  CLValueCommandWriteNativeValue<T> = sealed class(EnqueueableGPUCommand<CLValue<T>>)
  where T: record;
    private native_data: CommandQueue<NativeValue<&T>>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(native_data: CommandQueue<NativeValue<&T>>);
    begin
      self.native_data := native_data;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLValue<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeValue<&T>>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          UIntPtr.Zero, native_data.Area.ByteSize,
          native_data.Area.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLValueCCQ<T>.ThenWriteNativeValue(native_data: CommandQueue<NativeValue<&T>>): CLValueCCQ<T>;
begin
  Result := AddCommand(self, new CLValueCommandWriteNativeValue<T>(native_data));
end;

{$endregion WriteNativeValue}

{$region ReadNativeValueArea}

type
  CLValueCommandReadNativeValueArea<T> = sealed class(EnqueueableGPUCommand<CLValue<T>>)
  where T: record;
    private native_data: CommandQueue<NativeValueArea<&T>>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(native_data: CommandQueue<NativeValueArea<&T>>);
    begin
      self.native_data := native_data;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLValue<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeValueArea<&T>>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          UIntPtr.Zero, native_data.ByteSize,
          native_data.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLValueCCQ<T>.ThenReadNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>): CLValueCCQ<T>;
begin
  Result := AddCommand(self, new CLValueCommandReadNativeValueArea<T>(native_data));
end;

{$endregion ReadNativeValueArea}

{$region ReadNativeValue}

type
  CLValueCommandReadNativeValue<T> = sealed class(EnqueueableGPUCommand<CLValue<T>>)
  where T: record;
    private native_data: CommandQueue<NativeValue<&T>>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(native_data: CommandQueue<NativeValue<&T>>);
    begin
      self.native_data := native_data;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLValue<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeValue<&T>>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          UIntPtr.Zero, native_data.Area.ByteSize,
          native_data.Area.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLValueCCQ<T>.ThenReadNativeValue(native_data: CommandQueue<NativeValue<&T>>): CLValueCCQ<T>;
begin
  Result := AddCommand(self, new CLValueCommandReadNativeValue<T>(native_data));
end;

{$endregion ReadNativeValue}

{$endregion 1#Write&Read}

{$region 3#Copy}

{$region CopyTo!CLMemory}

function CLValueCCQ<T>.ThenCopyTo(mem: CommandQueue<CLMemory>): CLValueCCQ<T>;
begin
  Result := ThenCopyTo(mem, 0);
end;

{$endregion CopyTo!CLMemory}

{$region CopyFrom!CLMemory}

function CLValueCCQ<T>.ThenCopyFrom(mem: CommandQueue<CLMemory>): CLValueCCQ<T>;
begin
  Result := ThenCopyFrom(mem, 0);
end;

{$endregion CopyFrom!CLMemory}

{$region CopyTo}

type
  CLValueCommandCopyTo<T> = sealed class(EnqueueableGPUCommand<CLValue<T>>)
  where T: record;
    private        mem: CommandQueue<CLMemory>;
    private mem_offset: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    public constructor(mem: CommandQueue<CLMemory>; mem_offset: CommandQueue<integer>);
    begin
      self.       mem :=        mem;
      self.mem_offset := mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
             mem.InitBeforeInvoke(g, prev_hubs);
      mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLValue<T>>; override;
    begin
      var        mem_qr: QueueRes<CLMemory>;
      var mem_offset_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
               mem_qr := invoker.InvokeBranch(       mem.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        mem_offset_qr := invoker.InvokeBranch(mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
               mem_qr.CancelStatusCheck('enq cancel');
        mem_offset_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var        mem :=        mem_qr.GetResDirect;
        var mem_offset := mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueCopyBuffer(
          cq, o.Native,mem.Native,
          UIntPtr.Zero,new UIntPtr(mem_offset),
          new UIntPtr(Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'mem:';
      sb += ' ';
      mem.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLValueCCQ<T>.ThenCopyTo(mem: CommandQueue<CLMemory>; mem_offset: CommandQueue<integer>): CLValueCCQ<T>;
begin
  Result := AddCommand(self, new CLValueCommandCopyTo<T>(mem, mem_offset));
end;

{$endregion CopyTo}

{$region CopyFrom}

type
  CLValueCommandCopyFrom<T> = sealed class(EnqueueableGPUCommand<CLValue<T>>)
  where T: record;
    private        mem: CommandQueue<CLMemory>;
    private mem_offset: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    public constructor(mem: CommandQueue<CLMemory>; mem_offset: CommandQueue<integer>);
    begin
      self.       mem :=        mem;
      self.mem_offset := mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
             mem.InitBeforeInvoke(g, prev_hubs);
      mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLValue<T>>; override;
    begin
      var        mem_qr: QueueRes<CLMemory>;
      var mem_offset_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
               mem_qr := invoker.InvokeBranch(       mem.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        mem_offset_qr := invoker.InvokeBranch(mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
               mem_qr.CancelStatusCheck('enq cancel');
        mem_offset_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var        mem :=        mem_qr.GetResDirect;
        var mem_offset := mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueCopyBuffer(
          cq, mem.Native,o.Native,
          new UIntPtr(mem_offset),UIntPtr.Zero,
          new UIntPtr(Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'mem:';
      sb += ' ';
      mem.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLValueCCQ<T>.ThenCopyFrom(mem: CommandQueue<CLMemory>; mem_offset: CommandQueue<integer>): CLValueCCQ<T>;
begin
  Result := AddCommand(self, new CLValueCommandCopyFrom<T>(mem, mem_offset));
end;

{$endregion CopyFrom}

{$region CopyTo!CLValue}

type
  CLValueCommandCopyToCLValue<T> = sealed class(EnqueueableGPUCommand<CLValue<T>>)
  where T: record;
    private val: CommandQueue<CLValue<&T>>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(val: CommandQueue<CLValue<&T>>);
    begin
      self.val := val;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      val.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLValue<T>>; override;
    begin
      var val_qr: QueueRes<CLValue<&T>>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        val_qr := invoker.InvokeBranch(val.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        val_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var val := val_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueCopyBuffer(
          cq, o.Native,val.Native,
          UIntPtr.Zero, UIntPtr.Zero,
          new UIntPtr(Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      val.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLValueCCQ<T>.ThenCopyTo(val: CommandQueue<CLValue<&T>>): CLValueCCQ<T>;
begin
  Result := AddCommand(self, new CLValueCommandCopyToCLValue<T>(val));
end;

{$endregion CopyTo!CLValue}

{$region CopyFrom!CLValue}

type
  CLValueCommandCopyFromCLValue<T> = sealed class(EnqueueableGPUCommand<CLValue<T>>)
  where T: record;
    private val: CommandQueue<CLValue<&T>>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(val: CommandQueue<CLValue<&T>>);
    begin
      self.val := val;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      val.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLValue<T>>; override;
    begin
      var val_qr: QueueRes<CLValue<&T>>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        val_qr := invoker.InvokeBranch(val.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        val_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var val := val_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueCopyBuffer(
          cq, val.Native,o.Native,
          UIntPtr.Zero, UIntPtr.Zero,
          new UIntPtr(Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      val.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLValueCCQ<T>.ThenCopyFrom(val: CommandQueue<CLValue<&T>>): CLValueCCQ<T>;
begin
  Result := AddCommand(self, new CLValueCommandCopyFromCLValue<T>(val));
end;

{$endregion CopyFrom!CLValue}

{$endregion 3#Copy}

{$region Get}

{$region GetValue}

type
  CLValueCommandGetValue<T> = sealed class(EnqueueableGetPtrCommand<CLValue<T>, &T>)
  where T: record;
    
    protected function ExpectedEnqCount: integer; override := 0;
    
    public constructor(ccq: CLValueCCQ<T>);
    begin
      inherited Create(ccq);
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override := prev_commands.InitBeforeInvoke(g, prev_hubs);
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>; own_qr: QueueRes<&T>): ParamInvRes<CLValue<T>>; override;
    begin
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(Marshal.SizeOf(default(T))),
          (own_qr as QueueResPtr<&T>).GetResPtrForWrite,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          GC.KeepAlive(own_qr);
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override := sb += #10;
    
  end;
  
function CLValueCCQ<T>.ThenGetValue: CommandQueue<&T>;
begin
  Result := new CLValueCommandGetValue<T>(self) as CommandQueue<&T>;
end;

{$endregion GetValue}

{$endregion Get}

{$endregion Explicit}

{$endregion CLValue}

{$region CLArray}

{$region Implicit}

{$region 1#Write&Read}

function CLArray<T>.WriteValue(val: &T; ind: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenWriteValue(val, ind));
end;

function CLArray<T>.WriteValue(val: CommandQueue<&T>; ind: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenWriteValue(val, ind));
end;

function CLArray<T>.WriteArray(a: CommandQueue<array of &T>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenWriteArray(a));
end;

function CLArray<T>.WriteArray2(a: CommandQueue<array[,] of &T>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenWriteArray2(a));
end;

function CLArray<T>.WriteArray3(a: CommandQueue<array[,,] of &T>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenWriteArray3(a));
end;

function CLArray<T>.ReadArray(a: CommandQueue<array of &T>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenReadArray(a));
end;

function CLArray<T>.ReadArray2(a: CommandQueue<array[,] of &T>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenReadArray2(a));
end;

function CLArray<T>.ReadArray3(a: CommandQueue<array[,,] of &T>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenReadArray3(a));
end;

function CLArray<T>.WriteArray(a: CommandQueue<array of &T>; a_ind, len, ind: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenWriteArray(a, a_ind, len, ind));
end;

function CLArray<T>.WriteArray2(a: CommandQueue<array[,] of &T>; a_ind1,a_ind2, len, ind: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenWriteArray2(a, a_ind1, a_ind2, len, ind));
end;

function CLArray<T>.WriteArray3(a: CommandQueue<array[,,] of &T>; a_ind1,a_ind2,a_ind3, len, ind: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenWriteArray3(a, a_ind1, a_ind2, a_ind3, len, ind));
end;

function CLArray<T>.ReadArray(a: CommandQueue<array of &T>; a_ind, len, ind: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenReadArray(a, a_ind, len, ind));
end;

function CLArray<T>.ReadArray2(a: CommandQueue<array[,] of &T>; a_ind1,a_ind2, len, ind: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenReadArray2(a, a_ind1, a_ind2, len, ind));
end;

function CLArray<T>.ReadArray3(a: CommandQueue<array[,,] of &T>; a_ind1,a_ind2,a_ind3, len, ind: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenReadArray3(a, a_ind1, a_ind2, a_ind3, len, ind));
end;

function CLArray<T>.WriteArraySegment(a: CommandQueue<ArraySegment<&T>>): CLArray<T>;
begin
  Result := WriteArraySegment(a, 0);
end;

function CLArray<T>.ReadArraySegment(a: CommandQueue<ArraySegment<&T>>): CLArray<T>;
begin
  Result := ReadArraySegment(a, 0);
end;

function CLArray<T>.WriteArraySegment(a: CommandQueue<ArraySegment<&T>>; ind: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenWriteArraySegment(a, ind));
end;

function CLArray<T>.ReadArraySegment(a: CommandQueue<ArraySegment<&T>>; ind: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenReadArraySegment(a, ind));
end;

function CLArray<T>.WriteData(ptr: CommandQueue<IntPtr>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenWriteData(ptr));
end;

function CLArray<T>.WriteData(ptr: CommandQueue<IntPtr>; ind, len: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenWriteData(ptr, ind, len));
end;

function CLArray<T>.ReadData(ptr: CommandQueue<IntPtr>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenReadData(ptr));
end;

function CLArray<T>.ReadData(ptr: CommandQueue<IntPtr>; ind, len: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenReadData(ptr, ind, len));
end;

function CLArray<T>.WriteData(ptr: pointer): CLArray<T>;
begin
  Result := WriteData(IntPtr(ptr));
end;

function CLArray<T>.WriteData(ptr: pointer; ind, len: CommandQueue<integer>): CLArray<T>;
begin
  Result := WriteData(IntPtr(ptr), ind, len);
end;

function CLArray<T>.ReadData(ptr: pointer): CLArray<T>;
begin
  Result := ReadData(IntPtr(ptr));
end;

function CLArray<T>.ReadData(ptr: pointer; ind, len: CommandQueue<integer>): CLArray<T>;
begin
  Result := ReadData(IntPtr(ptr), ind, len);
end;

function CLArray<T>.WriteNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>): CLArray<T>;
begin
  Result := WriteNativeMemoryArea(native_data, 0);
end;

function CLArray<T>.WriteNativeMemory(native_data: CommandQueue<NativeMemory>): CLArray<T>;
begin
  Result := WriteNativeMemory(native_data, 0);
end;

function CLArray<T>.WriteNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>): CLArray<T>;
begin
  Result := WriteNativeValueArea(native_data, 0);
end;

function CLArray<T>.WriteNativeValue(native_data: CommandQueue<NativeValue<&T>>): CLArray<T>;
begin
  Result := WriteNativeValue(native_data, 0);
end;

function CLArray<T>.WriteNativeArrayArea(native_data: CommandQueue<NativeArrayArea<&T>>): CLArray<T>;
begin
  Result := WriteNativeArrayArea(native_data, 0);
end;

function CLArray<T>.WriteNativeArray(native_data: CommandQueue<NativeArray<&T>>): CLArray<T>;
begin
  Result := WriteNativeArray(native_data, 0);
end;

function CLArray<T>.ReadNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>): CLArray<T>;
begin
  Result := ReadNativeMemoryArea(native_data, 0);
end;

function CLArray<T>.ReadNativeMemory(native_data: CommandQueue<NativeMemory>): CLArray<T>;
begin
  Result := ReadNativeMemory(native_data, 0);
end;

function CLArray<T>.ReadNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>): CLArray<T>;
begin
  Result := ReadNativeValueArea(native_data, 0);
end;

function CLArray<T>.ReadNativeValue(native_data: CommandQueue<NativeValue<&T>>): CLArray<T>;
begin
  Result := ReadNativeValue(native_data, 0);
end;

function CLArray<T>.ReadNativeArrayArea(native_data: CommandQueue<NativeArrayArea<&T>>): CLArray<T>;
begin
  Result := ReadNativeArrayArea(native_data, 0);
end;

function CLArray<T>.ReadNativeArray(native_data: CommandQueue<NativeArray<&T>>): CLArray<T>;
begin
  Result := ReadNativeArray(native_data, 0);
end;

function CLArray<T>.WriteNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>; mem_offset: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenWriteNativeMemoryArea(native_data, mem_offset));
end;

function CLArray<T>.WriteNativeMemory(native_data: CommandQueue<NativeMemory>; mem_offset: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenWriteNativeMemory(native_data, mem_offset));
end;

function CLArray<T>.WriteNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>; mem_offset: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenWriteNativeValueArea(native_data, mem_offset));
end;

function CLArray<T>.WriteNativeValue(native_data: CommandQueue<NativeValue<&T>>; mem_offset: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenWriteNativeValue(native_data, mem_offset));
end;

function CLArray<T>.WriteNativeArrayArea(native_data: CommandQueue<NativeArrayArea<&T>>; mem_offset: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenWriteNativeArrayArea(native_data, mem_offset));
end;

function CLArray<T>.WriteNativeArray(native_data: CommandQueue<NativeArray<&T>>; mem_offset: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenWriteNativeArray(native_data, mem_offset));
end;

function CLArray<T>.ReadNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>; mem_offset: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenReadNativeMemoryArea(native_data, mem_offset));
end;

function CLArray<T>.ReadNativeMemory(native_data: CommandQueue<NativeMemory>; mem_offset: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenReadNativeMemory(native_data, mem_offset));
end;

function CLArray<T>.ReadNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>; mem_offset: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenReadNativeValueArea(native_data, mem_offset));
end;

function CLArray<T>.ReadNativeValue(native_data: CommandQueue<NativeValue<&T>>; mem_offset: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenReadNativeValue(native_data, mem_offset));
end;

function CLArray<T>.ReadNativeArrayArea(native_data: CommandQueue<NativeArrayArea<&T>>; mem_offset: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenReadNativeArrayArea(native_data, mem_offset));
end;

function CLArray<T>.ReadNativeArray(native_data: CommandQueue<NativeArray<&T>>; mem_offset: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenReadNativeArray(native_data, mem_offset));
end;

{$endregion 1#Write&Read}

{$region 2#Fill}

function CLArray<T>.FillValue(val: &T): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillValue(val));
end;

function CLArray<T>.FillValue(val: CommandQueue<&T>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillValue(val));
end;

function CLArray<T>.FillValue(val: &T; ind, len: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillValue(val, ind, len));
end;

function CLArray<T>.FillValue(val: CommandQueue<&T>; ind, len: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillValue(val, ind, len));
end;

function CLArray<T>.FillArray(a: CommandQueue<array of &T>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillArray(a));
end;

function CLArray<T>.FillArray2(a: CommandQueue<array[,] of &T>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillArray2(a));
end;

function CLArray<T>.FillArray3(a: CommandQueue<array[,,] of &T>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillArray3(a));
end;

function CLArray<T>.FillArray(a: CommandQueue<array of &T>; a_ind, pattern_len, ind, fill_len: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillArray(a, a_ind, pattern_len, ind, fill_len));
end;

function CLArray<T>.FillArray2(a: CommandQueue<array[,] of &T>; a_ind1,a_ind2, pattern_len, ind, fill_len: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillArray2(a, a_ind1, a_ind2, pattern_len, ind, fill_len));
end;

function CLArray<T>.FillArray3(a: CommandQueue<array[,,] of &T>; a_ind1,a_ind2,a_ind3, pattern_len, ind, fill_len: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillArray3(a, a_ind1, a_ind2, a_ind3, pattern_len, ind, fill_len));
end;

function CLArray<T>.FillArraySegment(a: CommandQueue<ArraySegment<&T>>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillArraySegment(a));
end;

function CLArray<T>.FillArraySegment(a: CommandQueue<ArraySegment<&T>>; ind, fill_len: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillArraySegment(a, ind, fill_len));
end;

function CLArray<T>.FillData(ptr: CommandQueue<IntPtr>; pattern_len: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillData(ptr, pattern_len));
end;

function CLArray<T>.FillData(ptr: CommandQueue<IntPtr>; pattern_len, ind, fill_len: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillData(ptr, pattern_len, ind, fill_len));
end;

function CLArray<T>.FillData(ptr: pointer; pattern_len: CommandQueue<integer>): CLArray<T>;
begin
  Result := FillData(IntPtr(ptr), pattern_len);
end;

function CLArray<T>.FillData(ptr: pointer; pattern_len, ind, fill_len: CommandQueue<integer>): CLArray<T>;
begin
  Result := FillData(IntPtr(ptr), pattern_len, ind, fill_len);
end;

function CLArray<T>.FillNativeMemoryArea(native_data: NativeMemoryArea): CLArray<T>;
begin
  Result := FillNativeMemoryArea(CQ(native_data));
end;

function CLArray<T>.FillNativeMemoryArea(native_data: NativeMemoryArea; ind,fill_len: CommandQueue<integer>): CLArray<T>;
begin
  Result := FillNativeMemoryArea(CQ(native_data),ind,fill_len);
end;

function CLArray<T>.FillNativeMemory(native_data: NativeMemory): CLArray<T>;
begin
  Result := FillNativeMemory(CQ(native_data));
end;

function CLArray<T>.FillNativeMemory(native_data: NativeMemory; ind,fill_len: CommandQueue<integer>): CLArray<T>;
begin
  Result := FillNativeMemory(CQ(native_data),ind,fill_len);
end;

function CLArray<T>.FillNativeValueArea(native_data: NativeValueArea<&T>): CLArray<T>;
begin
  Result := FillNativeValueArea(CQ(native_data));
end;

function CLArray<T>.FillNativeValueArea(native_data: NativeValueArea<&T>; ind,fill_len: CommandQueue<integer>): CLArray<T>;
begin
  Result := FillNativeValueArea(CQ(native_data),ind,fill_len);
end;

function CLArray<T>.FillNativeValue(native_data: NativeValue<&T>): CLArray<T>;
begin
  Result := FillNativeValue(CQ(native_data));
end;

function CLArray<T>.FillNativeValue(native_data: NativeValue<&T>; ind,fill_len: CommandQueue<integer>): CLArray<T>;
begin
  Result := FillNativeValue(CQ(native_data),ind,fill_len);
end;

function CLArray<T>.FillNativeArrayArea(native_data: NativeArrayArea<&T>): CLArray<T>;
begin
  Result := FillNativeArrayArea(CQ(native_data));
end;

function CLArray<T>.FillNativeArrayArea(native_data: NativeArrayArea<&T>; ind,fill_len: CommandQueue<integer>): CLArray<T>;
begin
  Result := FillNativeArrayArea(CQ(native_data),ind,fill_len);
end;

function CLArray<T>.FillNativeArray(native_data: NativeArray<&T>): CLArray<T>;
begin
  Result := FillNativeArray(CQ(native_data));
end;

function CLArray<T>.FillNativeArray(native_data: NativeArray<&T>; ind,fill_len: CommandQueue<integer>): CLArray<T>;
begin
  Result := FillNativeArray(CQ(native_data),ind,fill_len);
end;

function CLArray<T>.FillNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillNativeMemoryArea(native_data));
end;

function CLArray<T>.FillNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>; ind,fill_len: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillNativeMemoryArea(native_data, ind, fill_len));
end;

function CLArray<T>.FillNativeMemory(native_data: CommandQueue<NativeMemory>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillNativeMemory(native_data));
end;

function CLArray<T>.FillNativeMemory(native_data: CommandQueue<NativeMemory>; ind,fill_len: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillNativeMemory(native_data, ind, fill_len));
end;

function CLArray<T>.FillNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillNativeValueArea(native_data));
end;

function CLArray<T>.FillNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>; ind,fill_len: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillNativeValueArea(native_data, ind, fill_len));
end;

function CLArray<T>.FillNativeValue(native_data: CommandQueue<NativeValue<&T>>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillNativeValue(native_data));
end;

function CLArray<T>.FillNativeValue(native_data: CommandQueue<NativeValue<&T>>; ind,fill_len: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillNativeValue(native_data, ind, fill_len));
end;

function CLArray<T>.FillNativeArrayArea(native_data: CommandQueue<NativeArrayArea<&T>>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillNativeArrayArea(native_data));
end;

function CLArray<T>.FillNativeArrayArea(native_data: CommandQueue<NativeArrayArea<&T>>; ind,fill_len: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillNativeArrayArea(native_data, ind, fill_len));
end;

function CLArray<T>.FillNativeArray(native_data: CommandQueue<NativeArray<&T>>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillNativeArray(native_data));
end;

function CLArray<T>.FillNativeArray(native_data: CommandQueue<NativeArray<&T>>; ind,fill_len: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenFillNativeArray(native_data, ind, fill_len));
end;

{$endregion 2#Fill}

{$region 3#Copy}

function CLArray<T>.CopyTo(mem: CommandQueue<CLMemory>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenCopyTo(mem));
end;

function CLArray<T>.CopyTo(mem: CommandQueue<CLMemory>; mem_offset, ind, len: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenCopyTo(mem, mem_offset, ind, len));
end;

function CLArray<T>.CopyFrom(mem: CommandQueue<CLMemory>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenCopyFrom(mem));
end;

function CLArray<T>.CopyFrom(mem: CommandQueue<CLMemory>; mem_offset, ind, len: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenCopyFrom(mem, mem_offset, ind, len));
end;

function CLArray<T>.CopyTo(val: CommandQueue<CLValue<&T>>; ind: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenCopyTo(val, ind));
end;

function CLArray<T>.CopyFrom(val: CommandQueue<CLValue<&T>>; ind: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenCopyFrom(val, ind));
end;

function CLArray<T>.CopyTo(a: CommandQueue<CLArray<&T>>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenCopyTo(a));
end;

function CLArray<T>.CopyTo(a: CommandQueue<CLArray<&T>>; from_ind, to_ind, len: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenCopyTo(a, from_ind, to_ind, len));
end;

function CLArray<T>.CopyFrom(a: CommandQueue<CLArray<&T>>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenCopyFrom(a));
end;

function CLArray<T>.CopyFrom(a: CommandQueue<CLArray<&T>>; from_ind, to_ind, len: CommandQueue<integer>): CLArray<T>;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenCopyFrom(a, from_ind, to_ind, len));
end;

{$endregion 3#Copy}

{$region Get}

function CLArray<T>.GetValue(ind: CommandQueue<integer>): &T;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenGetValue(ind));
end;

function CLArray<T>.GetArray: array of &T;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenGetArray);
end;

function CLArray<T>.GetArray(len: CommandQueue<integer>): array of &T;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenGetArray(len));
end;

function CLArray<T>.GetArray2(len1,len2: CommandQueue<integer>): array[,] of &T;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenGetArray2(len1, len2));
end;

function CLArray<T>.GetArray3(len1,len2,len3: CommandQueue<integer>): array[,,] of &T;
begin
  Result := CLContext.Default.SyncInvoke(self.MakeCCQ.ThenGetArray3(len1, len2, len3));
end;

{$endregion Get}

{$endregion Implicit}

{$region Explicit}

{$region 1#Write&Read}

{$region WriteValue}

type
  CLArrayCommandWriteValue<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private val := new NativeValueArea<&T>(true);
    private ind: CommandQueue<integer>;
    
    protected procedure Finalize; override;
    begin
      val.Release;
    end;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(val: &T; ind: CommandQueue<integer>);
    begin
      self.val.Value := val;
      self.ind       := ind;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      ind.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var ind_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        ind_qr := invoker.InvokeBranch(ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        ind_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var ind := ind_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(ind * Marshal.SizeOf(default(T))), new UIntPtr(Marshal.SizeOf(default(T))),
          val.Pointer,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      sb.Append(val.Value);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteValue(val: &T; ind: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteValue<T>(val, ind));
end;

{$endregion WriteValue}

{$region WriteValue!Q}

type
  CLArrayCommandWriteValueQ<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private val: CommandQueue<&T>;
    private ind: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    public constructor(val: CommandQueue<&T>; ind: CommandQueue<integer>);
    begin
      self.val := val;
      self.ind := ind;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      val.InitBeforeInvoke(g, prev_hubs);
      ind.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var val_qr: QueueResPtr<&T>;
      var ind_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        ind_qr := invoker.InvokeBranch(ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        val_qr := invoker.InvokeBranch(val.InvokeToPtr, par_err_handlers, False).AddToEvLst(g, enq_evs, False);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        val_qr.CancelStatusCheck('enq cancel');
        ind_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var val := val_qr.GetResPtrForRead;
        var ind := ind_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(ind * Marshal.SizeOf(default(T))), new UIntPtr(Marshal.SizeOf(default(T))),
          val,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          GC.KeepAlive(val_qr);
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      val.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteValue(val: CommandQueue<&T>; ind: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteValueQ<T>(val, ind));
end;

{$endregion WriteValue!Q}

{$region WriteArray!AutoSize}

type
  CLArrayCommandWriteArrayAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private a: CommandQueue<array of &T>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(a: CommandQueue<array of &T>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var a_qr: QueueRes<array of &T>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        a_qr := invoker.InvokeBranch(a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        a_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        //TODO unable to merge this Enqueue with non-AutoSize, because {-rank-} block would be nested in {-AutoSize-}
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(a.Length * Marshal.SizeOf(default(T))),
          a[0],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteArray(a: CommandQueue<array of &T>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteArrayAutoSize<T>(a));
end;

{$endregion WriteArray!AutoSize}

{$region WriteArray2!AutoSize}

type
  CLArrayCommandWriteArray2AutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private a: CommandQueue<array[,] of &T>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(a: CommandQueue<array[,] of &T>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var a_qr: QueueRes<array[,] of &T>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        a_qr := invoker.InvokeBranch(a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        a_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        //TODO unable to merge this Enqueue with non-AutoSize, because {-rank-} block would be nested in {-AutoSize-}
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(a.Length * Marshal.SizeOf(default(T))),
          a[0,0],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteArray2(a: CommandQueue<array[,] of &T>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteArray2AutoSize<T>(a));
end;

{$endregion WriteArray2!AutoSize}

{$region WriteArray3!AutoSize}

type
  CLArrayCommandWriteArray3AutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private a: CommandQueue<array[,,] of &T>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(a: CommandQueue<array[,,] of &T>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var a_qr: QueueRes<array[,,] of &T>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        a_qr := invoker.InvokeBranch(a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        a_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        //TODO unable to merge this Enqueue with non-AutoSize, because {-rank-} block would be nested in {-AutoSize-}
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(a.Length * Marshal.SizeOf(default(T))),
          a[0,0,0],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteArray3(a: CommandQueue<array[,,] of &T>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteArray3AutoSize<T>(a));
end;

{$endregion WriteArray3!AutoSize}

{$region ReadArray!AutoSize}

type
  CLArrayCommandReadArrayAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private a: CommandQueue<array of &T>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(a: CommandQueue<array of &T>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var a_qr: QueueRes<array of &T>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        a_qr := invoker.InvokeBranch(a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        a_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        //TODO unable to merge this Enqueue with non-AutoSize, because {-rank-} block would be nested in {-AutoSize-}
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(a.Length * Marshal.SizeOf(default(T))),
          a[0],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenReadArray(a: CommandQueue<array of &T>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandReadArrayAutoSize<T>(a));
end;

{$endregion ReadArray!AutoSize}

{$region ReadArray2!AutoSize}

type
  CLArrayCommandReadArray2AutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private a: CommandQueue<array[,] of &T>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(a: CommandQueue<array[,] of &T>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var a_qr: QueueRes<array[,] of &T>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        a_qr := invoker.InvokeBranch(a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        a_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        //TODO unable to merge this Enqueue with non-AutoSize, because {-rank-} block would be nested in {-AutoSize-}
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(a.Length * Marshal.SizeOf(default(T))),
          a[0,0],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenReadArray2(a: CommandQueue<array[,] of &T>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandReadArray2AutoSize<T>(a));
end;

{$endregion ReadArray2!AutoSize}

{$region ReadArray3!AutoSize}

type
  CLArrayCommandReadArray3AutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private a: CommandQueue<array[,,] of &T>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(a: CommandQueue<array[,,] of &T>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var a_qr: QueueRes<array[,,] of &T>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        a_qr := invoker.InvokeBranch(a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        a_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        //TODO unable to merge this Enqueue with non-AutoSize, because {-rank-} block would be nested in {-AutoSize-}
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(a.Length * Marshal.SizeOf(default(T))),
          a[0,0,0],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenReadArray3(a: CommandQueue<array[,,] of &T>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandReadArray3AutoSize<T>(a));
end;

{$endregion ReadArray3!AutoSize}

{$region WriteArray}

type
  CLArrayCommandWriteArray<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private     a: CommandQueue<array of &T>;
    private a_ind: CommandQueue<integer>;
    private   len: CommandQueue<integer>;
    private   ind: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 4;
    
    public constructor(a: CommandQueue<array of &T>; a_ind, len, ind: CommandQueue<integer>);
    begin
      self.    a :=     a;
      self.a_ind := a_ind;
      self.  len :=   len;
      self.  ind :=   ind;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
          a.InitBeforeInvoke(g, prev_hubs);
      a_ind.InitBeforeInvoke(g, prev_hubs);
        len.InitBeforeInvoke(g, prev_hubs);
        ind.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var     a_qr: QueueRes<array of &T>;
      var a_ind_qr: QueueRes<integer>;
      var   len_qr: QueueRes<integer>;
      var   ind_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
            a_qr := invoker.InvokeBranch(    a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        a_ind_qr := invoker.InvokeBranch(a_ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
          len_qr := invoker.InvokeBranch(  len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
          ind_qr := invoker.InvokeBranch(  ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
            a_qr.CancelStatusCheck('enq cancel');
        a_ind_qr.CancelStatusCheck('enq cancel');
          len_qr.CancelStatusCheck('enq cancel');
          ind_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var     a :=     a_qr.GetResDirect;
        var a_ind := a_ind_qr.GetResDirect;
        var   len :=   len_qr.GetResDirect;
        var   ind :=   ind_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(ind * Marshal.SizeOf(default(T))), new UIntPtr(len * Marshal.SizeOf(default(T))),
          a[a_ind],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind:';
      sb += ' ';
      a_ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteArray(a: CommandQueue<array of &T>; a_ind, len, ind: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteArray<T>(a, a_ind, len, ind));
end;

{$endregion WriteArray}

{$region WriteArray2}

type
  CLArrayCommandWriteArray2<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private      a: CommandQueue<array[,] of &T>;
    private a_ind1: CommandQueue<integer>;
    private a_ind2: CommandQueue<integer>;
    private    len: CommandQueue<integer>;
    private    ind: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 5;
    
    public constructor(a: CommandQueue<array[,] of &T>; a_ind1,a_ind2, len, ind: CommandQueue<integer>);
    begin
      self.     a :=      a;
      self.a_ind1 := a_ind1;
      self.a_ind2 := a_ind2;
      self.   len :=    len;
      self.   ind :=    ind;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
           a.InitBeforeInvoke(g, prev_hubs);
      a_ind1.InitBeforeInvoke(g, prev_hubs);
      a_ind2.InitBeforeInvoke(g, prev_hubs);
         len.InitBeforeInvoke(g, prev_hubs);
         ind.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var      a_qr: QueueRes<array[,] of &T>;
      var a_ind1_qr: QueueRes<integer>;
      var a_ind2_qr: QueueRes<integer>;
      var    len_qr: QueueRes<integer>;
      var    ind_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
             a_qr := invoker.InvokeBranch(     a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        a_ind1_qr := invoker.InvokeBranch(a_ind1.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        a_ind2_qr := invoker.InvokeBranch(a_ind2.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
           len_qr := invoker.InvokeBranch(   len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
           ind_qr := invoker.InvokeBranch(   ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
             a_qr.CancelStatusCheck('enq cancel');
        a_ind1_qr.CancelStatusCheck('enq cancel');
        a_ind2_qr.CancelStatusCheck('enq cancel');
           len_qr.CancelStatusCheck('enq cancel');
           ind_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var      a :=      a_qr.GetResDirect;
        var a_ind1 := a_ind1_qr.GetResDirect;
        var a_ind2 := a_ind2_qr.GetResDirect;
        var    len :=    len_qr.GetResDirect;
        var    ind :=    ind_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(ind * Marshal.SizeOf(default(T))), new UIntPtr(len * Marshal.SizeOf(default(T))),
          a[a_ind1,a_ind2],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind1:';
      sb += ' ';
      a_ind1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind2:';
      sb += ' ';
      a_ind2.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteArray2(a: CommandQueue<array[,] of &T>; a_ind1,a_ind2, len, ind: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteArray2<T>(a, a_ind1, a_ind2, len, ind));
end;

{$endregion WriteArray2}

{$region WriteArray3}

type
  CLArrayCommandWriteArray3<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private      a: CommandQueue<array[,,] of &T>;
    private a_ind1: CommandQueue<integer>;
    private a_ind2: CommandQueue<integer>;
    private a_ind3: CommandQueue<integer>;
    private    len: CommandQueue<integer>;
    private    ind: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 6;
    
    public constructor(a: CommandQueue<array[,,] of &T>; a_ind1,a_ind2,a_ind3, len, ind: CommandQueue<integer>);
    begin
      self.     a :=      a;
      self.a_ind1 := a_ind1;
      self.a_ind2 := a_ind2;
      self.a_ind3 := a_ind3;
      self.   len :=    len;
      self.   ind :=    ind;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
           a.InitBeforeInvoke(g, prev_hubs);
      a_ind1.InitBeforeInvoke(g, prev_hubs);
      a_ind2.InitBeforeInvoke(g, prev_hubs);
      a_ind3.InitBeforeInvoke(g, prev_hubs);
         len.InitBeforeInvoke(g, prev_hubs);
         ind.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var      a_qr: QueueRes<array[,,] of &T>;
      var a_ind1_qr: QueueRes<integer>;
      var a_ind2_qr: QueueRes<integer>;
      var a_ind3_qr: QueueRes<integer>;
      var    len_qr: QueueRes<integer>;
      var    ind_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
             a_qr := invoker.InvokeBranch(     a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        a_ind1_qr := invoker.InvokeBranch(a_ind1.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        a_ind2_qr := invoker.InvokeBranch(a_ind2.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        a_ind3_qr := invoker.InvokeBranch(a_ind3.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
           len_qr := invoker.InvokeBranch(   len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
           ind_qr := invoker.InvokeBranch(   ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
             a_qr.CancelStatusCheck('enq cancel');
        a_ind1_qr.CancelStatusCheck('enq cancel');
        a_ind2_qr.CancelStatusCheck('enq cancel');
        a_ind3_qr.CancelStatusCheck('enq cancel');
           len_qr.CancelStatusCheck('enq cancel');
           ind_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var      a :=      a_qr.GetResDirect;
        var a_ind1 := a_ind1_qr.GetResDirect;
        var a_ind2 := a_ind2_qr.GetResDirect;
        var a_ind3 := a_ind3_qr.GetResDirect;
        var    len :=    len_qr.GetResDirect;
        var    ind :=    ind_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(ind * Marshal.SizeOf(default(T))), new UIntPtr(len * Marshal.SizeOf(default(T))),
          a[a_ind1,a_ind2,a_ind3],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind1:';
      sb += ' ';
      a_ind1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind2:';
      sb += ' ';
      a_ind2.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind3:';
      sb += ' ';
      a_ind3.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteArray3(a: CommandQueue<array[,,] of &T>; a_ind1,a_ind2,a_ind3, len, ind: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteArray3<T>(a, a_ind1, a_ind2, a_ind3, len, ind));
end;

{$endregion WriteArray3}

{$region ReadArray}

type
  CLArrayCommandReadArray<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private     a: CommandQueue<array of &T>;
    private a_ind: CommandQueue<integer>;
    private   len: CommandQueue<integer>;
    private   ind: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 4;
    
    public constructor(a: CommandQueue<array of &T>; a_ind, len, ind: CommandQueue<integer>);
    begin
      self.    a :=     a;
      self.a_ind := a_ind;
      self.  len :=   len;
      self.  ind :=   ind;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
          a.InitBeforeInvoke(g, prev_hubs);
      a_ind.InitBeforeInvoke(g, prev_hubs);
        len.InitBeforeInvoke(g, prev_hubs);
        ind.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var     a_qr: QueueRes<array of &T>;
      var a_ind_qr: QueueRes<integer>;
      var   len_qr: QueueRes<integer>;
      var   ind_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
            a_qr := invoker.InvokeBranch(    a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        a_ind_qr := invoker.InvokeBranch(a_ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
          len_qr := invoker.InvokeBranch(  len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
          ind_qr := invoker.InvokeBranch(  ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
            a_qr.CancelStatusCheck('enq cancel');
        a_ind_qr.CancelStatusCheck('enq cancel');
          len_qr.CancelStatusCheck('enq cancel');
          ind_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var     a :=     a_qr.GetResDirect;
        var a_ind := a_ind_qr.GetResDirect;
        var   len :=   len_qr.GetResDirect;
        var   ind :=   ind_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(ind * Marshal.SizeOf(default(T))), new UIntPtr(len * Marshal.SizeOf(default(T))),
          a[a_ind],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind:';
      sb += ' ';
      a_ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenReadArray(a: CommandQueue<array of &T>; a_ind, len, ind: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandReadArray<T>(a, a_ind, len, ind));
end;

{$endregion ReadArray}

{$region ReadArray2}

type
  CLArrayCommandReadArray2<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private      a: CommandQueue<array[,] of &T>;
    private a_ind1: CommandQueue<integer>;
    private a_ind2: CommandQueue<integer>;
    private    len: CommandQueue<integer>;
    private    ind: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 5;
    
    public constructor(a: CommandQueue<array[,] of &T>; a_ind1,a_ind2, len, ind: CommandQueue<integer>);
    begin
      self.     a :=      a;
      self.a_ind1 := a_ind1;
      self.a_ind2 := a_ind2;
      self.   len :=    len;
      self.   ind :=    ind;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
           a.InitBeforeInvoke(g, prev_hubs);
      a_ind1.InitBeforeInvoke(g, prev_hubs);
      a_ind2.InitBeforeInvoke(g, prev_hubs);
         len.InitBeforeInvoke(g, prev_hubs);
         ind.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var      a_qr: QueueRes<array[,] of &T>;
      var a_ind1_qr: QueueRes<integer>;
      var a_ind2_qr: QueueRes<integer>;
      var    len_qr: QueueRes<integer>;
      var    ind_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
             a_qr := invoker.InvokeBranch(     a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        a_ind1_qr := invoker.InvokeBranch(a_ind1.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        a_ind2_qr := invoker.InvokeBranch(a_ind2.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
           len_qr := invoker.InvokeBranch(   len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
           ind_qr := invoker.InvokeBranch(   ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
             a_qr.CancelStatusCheck('enq cancel');
        a_ind1_qr.CancelStatusCheck('enq cancel');
        a_ind2_qr.CancelStatusCheck('enq cancel');
           len_qr.CancelStatusCheck('enq cancel');
           ind_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var      a :=      a_qr.GetResDirect;
        var a_ind1 := a_ind1_qr.GetResDirect;
        var a_ind2 := a_ind2_qr.GetResDirect;
        var    len :=    len_qr.GetResDirect;
        var    ind :=    ind_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(ind * Marshal.SizeOf(default(T))), new UIntPtr(len * Marshal.SizeOf(default(T))),
          a[a_ind1,a_ind2],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind1:';
      sb += ' ';
      a_ind1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind2:';
      sb += ' ';
      a_ind2.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenReadArray2(a: CommandQueue<array[,] of &T>; a_ind1,a_ind2, len, ind: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandReadArray2<T>(a, a_ind1, a_ind2, len, ind));
end;

{$endregion ReadArray2}

{$region ReadArray3}

type
  CLArrayCommandReadArray3<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private      a: CommandQueue<array[,,] of &T>;
    private a_ind1: CommandQueue<integer>;
    private a_ind2: CommandQueue<integer>;
    private a_ind3: CommandQueue<integer>;
    private    len: CommandQueue<integer>;
    private    ind: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 6;
    
    public constructor(a: CommandQueue<array[,,] of &T>; a_ind1,a_ind2,a_ind3, len, ind: CommandQueue<integer>);
    begin
      self.     a :=      a;
      self.a_ind1 := a_ind1;
      self.a_ind2 := a_ind2;
      self.a_ind3 := a_ind3;
      self.   len :=    len;
      self.   ind :=    ind;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
           a.InitBeforeInvoke(g, prev_hubs);
      a_ind1.InitBeforeInvoke(g, prev_hubs);
      a_ind2.InitBeforeInvoke(g, prev_hubs);
      a_ind3.InitBeforeInvoke(g, prev_hubs);
         len.InitBeforeInvoke(g, prev_hubs);
         ind.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var      a_qr: QueueRes<array[,,] of &T>;
      var a_ind1_qr: QueueRes<integer>;
      var a_ind2_qr: QueueRes<integer>;
      var a_ind3_qr: QueueRes<integer>;
      var    len_qr: QueueRes<integer>;
      var    ind_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
             a_qr := invoker.InvokeBranch(     a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        a_ind1_qr := invoker.InvokeBranch(a_ind1.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        a_ind2_qr := invoker.InvokeBranch(a_ind2.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        a_ind3_qr := invoker.InvokeBranch(a_ind3.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
           len_qr := invoker.InvokeBranch(   len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
           ind_qr := invoker.InvokeBranch(   ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
             a_qr.CancelStatusCheck('enq cancel');
        a_ind1_qr.CancelStatusCheck('enq cancel');
        a_ind2_qr.CancelStatusCheck('enq cancel');
        a_ind3_qr.CancelStatusCheck('enq cancel');
           len_qr.CancelStatusCheck('enq cancel');
           ind_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var      a :=      a_qr.GetResDirect;
        var a_ind1 := a_ind1_qr.GetResDirect;
        var a_ind2 := a_ind2_qr.GetResDirect;
        var a_ind3 := a_ind3_qr.GetResDirect;
        var    len :=    len_qr.GetResDirect;
        var    ind :=    ind_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(ind * Marshal.SizeOf(default(T))), new UIntPtr(len * Marshal.SizeOf(default(T))),
          a[a_ind1,a_ind2,a_ind3],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind1:';
      sb += ' ';
      a_ind1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind2:';
      sb += ' ';
      a_ind2.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind3:';
      sb += ' ';
      a_ind3.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenReadArray3(a: CommandQueue<array[,,] of &T>; a_ind1,a_ind2,a_ind3, len, ind: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandReadArray3<T>(a, a_ind1, a_ind2, a_ind3, len, ind));
end;

{$endregion ReadArray3}

{$region WriteArraySegment}

function CLArrayCCQ<T>.ThenWriteArraySegment(a: CommandQueue<ArraySegment<&T>>): CLArrayCCQ<T>;
begin
  Result := ThenWriteArraySegment(a, 0);
end;

{$endregion WriteArraySegment}

{$region ReadArraySegment}

function CLArrayCCQ<T>.ThenReadArraySegment(a: CommandQueue<ArraySegment<&T>>): CLArrayCCQ<T>;
begin
  Result := ThenReadArraySegment(a, 0);
end;

{$endregion ReadArraySegment}

{$region WriteArraySegment}

type
  CLArrayCommandWriteArraySegment<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private   a: CommandQueue<ArraySegment<&T>>;
    private ind: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    public constructor(a: CommandQueue<ArraySegment<&T>>; ind: CommandQueue<integer>);
    begin
      self.  a :=   a;
      self.ind := ind;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
        a.InitBeforeInvoke(g, prev_hubs);
      ind.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var   a_qr: QueueRes<ArraySegment<&T>>;
      var ind_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
          a_qr := invoker.InvokeBranch(  a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        ind_qr := invoker.InvokeBranch(ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
          a_qr.CancelStatusCheck('enq cancel');
        ind_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var   a :=   a_qr.GetResDirect;
        var ind := ind_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a.Array, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(ind*Marshal.SizeOf(default(T))),
          new UIntPtr(a.Count * Marshal.SizeOf(default(T))),
          a.Array[a.Offset],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteArraySegment(a: CommandQueue<ArraySegment<&T>>; ind: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteArraySegment<T>(a, ind));
end;

{$endregion WriteArraySegment}

{$region ReadArraySegment}

type
  CLArrayCommandReadArraySegment<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private   a: CommandQueue<ArraySegment<&T>>;
    private ind: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    public constructor(a: CommandQueue<ArraySegment<&T>>; ind: CommandQueue<integer>);
    begin
      self.  a :=   a;
      self.ind := ind;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
        a.InitBeforeInvoke(g, prev_hubs);
      ind.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var   a_qr: QueueRes<ArraySegment<&T>>;
      var ind_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
          a_qr := invoker.InvokeBranch(  a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        ind_qr := invoker.InvokeBranch(ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
          a_qr.CancelStatusCheck('enq cancel');
        ind_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var   a :=   a_qr.GetResDirect;
        var ind := ind_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a.Array, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(ind*Marshal.SizeOf(default(T))),
          new UIntPtr(a.Count * Marshal.SizeOf(default(T))),
          a.Array[a.Offset],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenReadArraySegment(a: CommandQueue<ArraySegment<&T>>; ind: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandReadArraySegment<T>(a, ind));
end;

{$endregion ReadArraySegment}

{$region WriteData!AutoSize}

type
  CLArrayCommandWriteDataAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private ptr: CommandQueue<IntPtr>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(ptr: CommandQueue<IntPtr>);
    begin
      self.ptr := ptr;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      ptr.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var ptr_qr: QueueRes<IntPtr>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        ptr_qr := invoker.InvokeBranch(ptr.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        ptr_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var ptr := ptr_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(0),
          new UIntPtr(o.ByteSize),
          ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'ptr:';
      sb += ' ';
      ptr.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteData(ptr: CommandQueue<IntPtr>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteDataAutoSize<T>(ptr));
end;

{$endregion WriteData!AutoSize}

{$region WriteData}

type
  CLArrayCommandWriteData<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private ptr: CommandQueue<IntPtr>;
    private ind: CommandQueue<integer>;
    private len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 3;
    
    public constructor(ptr: CommandQueue<IntPtr>; ind, len: CommandQueue<integer>);
    begin
      self.ptr := ptr;
      self.ind := ind;
      self.len := len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      ptr.InitBeforeInvoke(g, prev_hubs);
      ind.InitBeforeInvoke(g, prev_hubs);
      len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var ptr_qr: QueueRes<IntPtr>;
      var ind_qr: QueueRes<integer>;
      var len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        ptr_qr := invoker.InvokeBranch(ptr.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        ind_qr := invoker.InvokeBranch(ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        len_qr := invoker.InvokeBranch(len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        ptr_qr.CancelStatusCheck('enq cancel');
        ind_qr.CancelStatusCheck('enq cancel');
        len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var ptr := ptr_qr.GetResDirect;
        var ind := ind_qr.GetResDirect;
        var len := len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(ind * Marshal.SizeOf(default(T))),
          new UIntPtr(len*Marshal.SizeOf(default(T))),
          ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'ptr:';
      sb += ' ';
      ptr.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteData(ptr: CommandQueue<IntPtr>; ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteData<T>(ptr, ind, len));
end;

{$endregion WriteData}

{$region ReadData!AutoSize}

type
  CLArrayCommandReadDataAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private ptr: CommandQueue<IntPtr>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(ptr: CommandQueue<IntPtr>);
    begin
      self.ptr := ptr;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      ptr.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var ptr_qr: QueueRes<IntPtr>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        ptr_qr := invoker.InvokeBranch(ptr.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        ptr_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var ptr := ptr_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(0),
          new UIntPtr(o.ByteSize),
          ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'ptr:';
      sb += ' ';
      ptr.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenReadData(ptr: CommandQueue<IntPtr>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandReadDataAutoSize<T>(ptr));
end;

{$endregion ReadData!AutoSize}

{$region ReadData}

type
  CLArrayCommandReadData<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private ptr: CommandQueue<IntPtr>;
    private ind: CommandQueue<integer>;
    private len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 3;
    
    public constructor(ptr: CommandQueue<IntPtr>; ind, len: CommandQueue<integer>);
    begin
      self.ptr := ptr;
      self.ind := ind;
      self.len := len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      ptr.InitBeforeInvoke(g, prev_hubs);
      ind.InitBeforeInvoke(g, prev_hubs);
      len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var ptr_qr: QueueRes<IntPtr>;
      var ind_qr: QueueRes<integer>;
      var len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        ptr_qr := invoker.InvokeBranch(ptr.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        ind_qr := invoker.InvokeBranch(ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        len_qr := invoker.InvokeBranch(len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        ptr_qr.CancelStatusCheck('enq cancel');
        ind_qr.CancelStatusCheck('enq cancel');
        len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var ptr := ptr_qr.GetResDirect;
        var ind := ind_qr.GetResDirect;
        var len := len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(ind * Marshal.SizeOf(default(T))),
          new UIntPtr(len*Marshal.SizeOf(default(T))),
          ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'ptr:';
      sb += ' ';
      ptr.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenReadData(ptr: CommandQueue<IntPtr>; ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandReadData<T>(ptr, ind, len));
end;

{$endregion ReadData}

{$region WriteData!AutoSize}

function CLArrayCCQ<T>.ThenWriteData(ptr: pointer): CLArrayCCQ<T>;
begin
  Result := ThenWriteData(IntPtr(ptr));
end;

{$endregion WriteData!AutoSize}

{$region WriteData}

function CLArrayCCQ<T>.ThenWriteData(ptr: pointer; ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := ThenWriteData(IntPtr(ptr), ind, len);
end;

{$endregion WriteData}

{$region ReadData!AutoSize}

function CLArrayCCQ<T>.ThenReadData(ptr: pointer): CLArrayCCQ<T>;
begin
  Result := ThenReadData(IntPtr(ptr));
end;

{$endregion ReadData!AutoSize}

{$region ReadData}

function CLArrayCCQ<T>.ThenReadData(ptr: pointer; ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := ThenReadData(IntPtr(ptr), ind, len);
end;

{$endregion ReadData}

{$region WriteNativeMemoryArea}

function CLArrayCCQ<T>.ThenWriteNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>): CLArrayCCQ<T>;
begin
  Result := ThenWriteNativeMemoryArea(native_data, 0);
end;

{$endregion WriteNativeMemoryArea}

{$region WriteNativeMemory}

function CLArrayCCQ<T>.ThenWriteNativeMemory(native_data: CommandQueue<NativeMemory>): CLArrayCCQ<T>;
begin
  Result := ThenWriteNativeMemory(native_data, 0);
end;

{$endregion WriteNativeMemory}

{$region WriteNativeValueArea}

function CLArrayCCQ<T>.ThenWriteNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>): CLArrayCCQ<T>;
begin
  Result := ThenWriteNativeValueArea(native_data, 0);
end;

{$endregion WriteNativeValueArea}

{$region WriteNativeValue}

function CLArrayCCQ<T>.ThenWriteNativeValue(native_data: CommandQueue<NativeValue<&T>>): CLArrayCCQ<T>;
begin
  Result := ThenWriteNativeValue(native_data, 0);
end;

{$endregion WriteNativeValue}

{$region WriteNativeArrayArea}

function CLArrayCCQ<T>.ThenWriteNativeArrayArea(native_data: CommandQueue<NativeArrayArea<&T>>): CLArrayCCQ<T>;
begin
  Result := ThenWriteNativeArrayArea(native_data, 0);
end;

{$endregion WriteNativeArrayArea}

{$region WriteNativeArray}

function CLArrayCCQ<T>.ThenWriteNativeArray(native_data: CommandQueue<NativeArray<&T>>): CLArrayCCQ<T>;
begin
  Result := ThenWriteNativeArray(native_data, 0);
end;

{$endregion WriteNativeArray}

{$region ReadNativeMemoryArea}

function CLArrayCCQ<T>.ThenReadNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>): CLArrayCCQ<T>;
begin
  Result := ThenReadNativeMemoryArea(native_data, 0);
end;

{$endregion ReadNativeMemoryArea}

{$region ReadNativeMemory}

function CLArrayCCQ<T>.ThenReadNativeMemory(native_data: CommandQueue<NativeMemory>): CLArrayCCQ<T>;
begin
  Result := ThenReadNativeMemory(native_data, 0);
end;

{$endregion ReadNativeMemory}

{$region ReadNativeValueArea}

function CLArrayCCQ<T>.ThenReadNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>): CLArrayCCQ<T>;
begin
  Result := ThenReadNativeValueArea(native_data, 0);
end;

{$endregion ReadNativeValueArea}

{$region ReadNativeValue}

function CLArrayCCQ<T>.ThenReadNativeValue(native_data: CommandQueue<NativeValue<&T>>): CLArrayCCQ<T>;
begin
  Result := ThenReadNativeValue(native_data, 0);
end;

{$endregion ReadNativeValue}

{$region ReadNativeArrayArea}

function CLArrayCCQ<T>.ThenReadNativeArrayArea(native_data: CommandQueue<NativeArrayArea<&T>>): CLArrayCCQ<T>;
begin
  Result := ThenReadNativeArrayArea(native_data, 0);
end;

{$endregion ReadNativeArrayArea}

{$region ReadNativeArray}

function CLArrayCCQ<T>.ThenReadNativeArray(native_data: CommandQueue<NativeArray<&T>>): CLArrayCCQ<T>;
begin
  Result := ThenReadNativeArray(native_data, 0);
end;

{$endregion ReadNativeArray}

{$region WriteNativeMemoryArea}

type
  CLArrayCommandWriteNativeMemoryArea<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeMemoryArea>;
    private  mem_offset: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    public constructor(native_data: CommandQueue<NativeMemoryArea>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeMemoryArea>;
      var  mem_offset_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
         mem_offset_qr := invoker.InvokeBranch( mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
         mem_offset_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.sz,
          native_data.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>; mem_offset: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteNativeMemoryArea<T>(native_data, mem_offset));
end;

{$endregion WriteNativeMemoryArea}

{$region WriteNativeMemory}

type
  CLArrayCommandWriteNativeMemory<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeMemory>;
    private  mem_offset: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    public constructor(native_data: CommandQueue<NativeMemory>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeMemory>;
      var  mem_offset_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
         mem_offset_qr := invoker.InvokeBranch( mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
         mem_offset_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.Area.sz,
          native_data.Area.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteNativeMemory(native_data: CommandQueue<NativeMemory>; mem_offset: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteNativeMemory<T>(native_data, mem_offset));
end;

{$endregion WriteNativeMemory}

{$region WriteNativeValueArea}

type
  CLArrayCommandWriteNativeValueArea<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeValueArea<&T>>;
    private  mem_offset: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    public constructor(native_data: CommandQueue<NativeValueArea<&T>>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeValueArea<&T>>;
      var  mem_offset_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
         mem_offset_qr := invoker.InvokeBranch( mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
         mem_offset_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.ByteSize,
          native_data.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>; mem_offset: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteNativeValueArea<T>(native_data, mem_offset));
end;

{$endregion WriteNativeValueArea}

{$region WriteNativeValue}

type
  CLArrayCommandWriteNativeValue<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeValue<&T>>;
    private  mem_offset: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    public constructor(native_data: CommandQueue<NativeValue<&T>>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeValue<&T>>;
      var  mem_offset_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
         mem_offset_qr := invoker.InvokeBranch( mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
         mem_offset_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.Area.ByteSize,
          native_data.Area.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteNativeValue(native_data: CommandQueue<NativeValue<&T>>; mem_offset: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteNativeValue<T>(native_data, mem_offset));
end;

{$endregion WriteNativeValue}

{$region WriteNativeArrayArea}

type
  CLArrayCommandWriteNativeArrayArea<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeArrayArea<&T>>;
    private  mem_offset: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    public constructor(native_data: CommandQueue<NativeArrayArea<&T>>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeArrayArea<&T>>;
      var  mem_offset_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
         mem_offset_qr := invoker.InvokeBranch( mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
         mem_offset_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.ByteSize,
          native_data.first_ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteNativeArrayArea(native_data: CommandQueue<NativeArrayArea<&T>>; mem_offset: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteNativeArrayArea<T>(native_data, mem_offset));
end;

{$endregion WriteNativeArrayArea}

{$region WriteNativeArray}

type
  CLArrayCommandWriteNativeArray<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeArray<&T>>;
    private  mem_offset: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    public constructor(native_data: CommandQueue<NativeArray<&T>>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeArray<&T>>;
      var  mem_offset_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
         mem_offset_qr := invoker.InvokeBranch( mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
         mem_offset_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.Area.ByteSize,
          native_data.Area.first_ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteNativeArray(native_data: CommandQueue<NativeArray<&T>>; mem_offset: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteNativeArray<T>(native_data, mem_offset));
end;

{$endregion WriteNativeArray}

{$region ReadNativeMemoryArea}

type
  CLArrayCommandReadNativeMemoryArea<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeMemoryArea>;
    private  mem_offset: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    public constructor(native_data: CommandQueue<NativeMemoryArea>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeMemoryArea>;
      var  mem_offset_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
         mem_offset_qr := invoker.InvokeBranch( mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
         mem_offset_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.sz,
          native_data.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenReadNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>; mem_offset: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandReadNativeMemoryArea<T>(native_data, mem_offset));
end;

{$endregion ReadNativeMemoryArea}

{$region ReadNativeMemory}

type
  CLArrayCommandReadNativeMemory<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeMemory>;
    private  mem_offset: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    public constructor(native_data: CommandQueue<NativeMemory>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeMemory>;
      var  mem_offset_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
         mem_offset_qr := invoker.InvokeBranch( mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
         mem_offset_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.Area.sz,
          native_data.Area.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenReadNativeMemory(native_data: CommandQueue<NativeMemory>; mem_offset: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandReadNativeMemory<T>(native_data, mem_offset));
end;

{$endregion ReadNativeMemory}

{$region ReadNativeValueArea}

type
  CLArrayCommandReadNativeValueArea<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeValueArea<&T>>;
    private  mem_offset: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    public constructor(native_data: CommandQueue<NativeValueArea<&T>>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeValueArea<&T>>;
      var  mem_offset_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
         mem_offset_qr := invoker.InvokeBranch( mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
         mem_offset_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.ByteSize,
          native_data.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenReadNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>; mem_offset: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandReadNativeValueArea<T>(native_data, mem_offset));
end;

{$endregion ReadNativeValueArea}

{$region ReadNativeValue}

type
  CLArrayCommandReadNativeValue<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeValue<&T>>;
    private  mem_offset: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    public constructor(native_data: CommandQueue<NativeValue<&T>>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeValue<&T>>;
      var  mem_offset_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
         mem_offset_qr := invoker.InvokeBranch( mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
         mem_offset_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.Area.ByteSize,
          native_data.Area.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenReadNativeValue(native_data: CommandQueue<NativeValue<&T>>; mem_offset: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandReadNativeValue<T>(native_data, mem_offset));
end;

{$endregion ReadNativeValue}

{$region ReadNativeArrayArea}

type
  CLArrayCommandReadNativeArrayArea<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeArrayArea<&T>>;
    private  mem_offset: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    public constructor(native_data: CommandQueue<NativeArrayArea<&T>>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeArrayArea<&T>>;
      var  mem_offset_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
         mem_offset_qr := invoker.InvokeBranch( mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
         mem_offset_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.ByteSize,
          native_data.first_ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenReadNativeArrayArea(native_data: CommandQueue<NativeArrayArea<&T>>; mem_offset: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandReadNativeArrayArea<T>(native_data, mem_offset));
end;

{$endregion ReadNativeArrayArea}

{$region ReadNativeArray}

type
  CLArrayCommandReadNativeArray<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeArray<&T>>;
    private  mem_offset: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    public constructor(native_data: CommandQueue<NativeArray<&T>>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeArray<&T>>;
      var  mem_offset_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
         mem_offset_qr := invoker.InvokeBranch( mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
         mem_offset_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.Area.ByteSize,
          native_data.Area.first_ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenReadNativeArray(native_data: CommandQueue<NativeArray<&T>>; mem_offset: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandReadNativeArray<T>(native_data, mem_offset));
end;

{$endregion ReadNativeArray}

{$endregion 1#Write&Read}

{$region 2#Fill}

{$region FillValue!AutoSize}

type
  CLArrayCommandFillValueAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private val := new NativeValueArea<&T>(true);
    
    protected procedure Finalize; override;
    begin
      val.Release;
    end;
    
    protected function ExpectedEnqCount: integer; override := 0;
    
    public constructor(val: &T);
    begin
      self.val.Value := val;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          val.Pointer, new UIntPtr(Marshal.SizeOf(default(T))),
          UIntPtr.Zero, new UIntPtr(o.ByteSize),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      sb.Append(val.Value);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillValue(val: &T): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillValueAutoSize<T>(val));
end;

{$endregion FillValue!AutoSize}

{$region FillValue!AutoSizeQ}

type
  CLArrayCommandFillValueAutoSizeQ<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private val: CommandQueue<&T>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(val: CommandQueue<&T>);
    begin
      self.val := val;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      val.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var val_qr: QueueResPtr<&T>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        val_qr := invoker.InvokeBranch(val.InvokeToPtr, par_err_handlers, False).AddToEvLst(g, enq_evs, False);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        val_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var val := val_qr.GetResPtrForRead;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          val, new UIntPtr(Marshal.SizeOf(default(T))),
          UIntPtr.Zero, new UIntPtr(o.ByteSize),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          GC.KeepAlive(val_qr);
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      val.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillValue(val: CommandQueue<&T>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillValueAutoSizeQ<T>(val));
end;

{$endregion FillValue!AutoSizeQ}

{$region FillValue}

type
  CLArrayCommandFillValue<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private val := new NativeValueArea<&T>(true);
    private ind: CommandQueue<integer>;
    private len: CommandQueue<integer>;
    
    protected procedure Finalize; override;
    begin
      val.Release;
    end;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    public constructor(val: &T; ind, len: CommandQueue<integer>);
    begin
      self.val.Value := val;
      self.ind       := ind;
      self.len       := len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      ind.InitBeforeInvoke(g, prev_hubs);
      len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var ind_qr: QueueRes<integer>;
      var len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        ind_qr := invoker.InvokeBranch(ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        len_qr := invoker.InvokeBranch(len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        ind_qr.CancelStatusCheck('enq cancel');
        len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var ind := ind_qr.GetResDirect;
        var len := len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          val.Pointer, new UIntPtr(Marshal.SizeOf(default(T))),
          new UIntPtr(ind*Marshal.SizeOf(default(T))), new UIntPtr(len*Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      sb.Append(val.Value);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillValue(val: &T; ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillValue<T>(val, ind, len));
end;

{$endregion FillValue}

{$region FillValue!Q}

type
  CLArrayCommandFillValueQ<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private val: CommandQueue<&T>;
    private ind: CommandQueue<integer>;
    private len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 3;
    
    public constructor(val: CommandQueue<&T>; ind, len: CommandQueue<integer>);
    begin
      self.val := val;
      self.ind := ind;
      self.len := len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      val.InitBeforeInvoke(g, prev_hubs);
      ind.InitBeforeInvoke(g, prev_hubs);
      len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var val_qr: QueueResPtr<&T>;
      var ind_qr: QueueRes<integer>;
      var len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        ind_qr := invoker.InvokeBranch(ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        len_qr := invoker.InvokeBranch(len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        val_qr := invoker.InvokeBranch(val.InvokeToPtr, par_err_handlers, False).AddToEvLst(g, enq_evs, False);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        val_qr.CancelStatusCheck('enq cancel');
        ind_qr.CancelStatusCheck('enq cancel');
        len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var val := val_qr.GetResPtrForRead;
        var ind := ind_qr.GetResDirect;
        var len := len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          val, new UIntPtr(Marshal.SizeOf(default(T))),
          new UIntPtr(ind*Marshal.SizeOf(default(T))), new UIntPtr(len*Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          GC.KeepAlive(val_qr);
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      val.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillValue(val: CommandQueue<&T>; ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillValueQ<T>(val, ind, len));
end;

{$endregion FillValue!Q}

{$region FillArray!AutoSize}

type
  CLArrayCommandFillArrayAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private a: CommandQueue<array of &T>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(a: CommandQueue<array of &T>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var a_qr: QueueRes<array of &T>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        a_qr := invoker.InvokeBranch(a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        a_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          a[0], new UIntPtr(a.Length * Marshal.SizeOf(default(T))),
          UIntPtr.Zero, new UIntPtr(o.ByteSize),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillArray(a: CommandQueue<array of &T>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillArrayAutoSize<T>(a));
end;

{$endregion FillArray!AutoSize}

{$region FillArray2!AutoSize}

type
  CLArrayCommandFillArray2AutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private a: CommandQueue<array[,] of &T>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(a: CommandQueue<array[,] of &T>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var a_qr: QueueRes<array[,] of &T>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        a_qr := invoker.InvokeBranch(a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        a_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          a[0,0], new UIntPtr(a.Length * Marshal.SizeOf(default(T))),
          UIntPtr.Zero, new UIntPtr(o.ByteSize),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillArray2(a: CommandQueue<array[,] of &T>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillArray2AutoSize<T>(a));
end;

{$endregion FillArray2!AutoSize}

{$region FillArray3!AutoSize}

type
  CLArrayCommandFillArray3AutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private a: CommandQueue<array[,,] of &T>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(a: CommandQueue<array[,,] of &T>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var a_qr: QueueRes<array[,,] of &T>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        a_qr := invoker.InvokeBranch(a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        a_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          a[0,0,0], new UIntPtr(a.Length * Marshal.SizeOf(default(T))),
          UIntPtr.Zero, new UIntPtr(o.ByteSize),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillArray3(a: CommandQueue<array[,,] of &T>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillArray3AutoSize<T>(a));
end;

{$endregion FillArray3!AutoSize}

{$region FillArray}

type
  CLArrayCommandFillArray<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private           a: CommandQueue<array of &T>;
    private       a_ind: CommandQueue<integer>;
    private pattern_len: CommandQueue<integer>;
    private         ind: CommandQueue<integer>;
    private    fill_len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 5;
    
    public constructor(a: CommandQueue<array of &T>; a_ind, pattern_len, ind, fill_len: CommandQueue<integer>);
    begin
      self.          a :=           a;
      self.      a_ind :=       a_ind;
      self.pattern_len := pattern_len;
      self.        ind :=         ind;
      self.   fill_len :=    fill_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
                a.InitBeforeInvoke(g, prev_hubs);
            a_ind.InitBeforeInvoke(g, prev_hubs);
      pattern_len.InitBeforeInvoke(g, prev_hubs);
              ind.InitBeforeInvoke(g, prev_hubs);
         fill_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var           a_qr: QueueRes<array of &T>;
      var       a_ind_qr: QueueRes<integer>;
      var pattern_len_qr: QueueRes<integer>;
      var         ind_qr: QueueRes<integer>;
      var    fill_len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
                  a_qr := invoker.InvokeBranch(          a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
              a_ind_qr := invoker.InvokeBranch(      a_ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        pattern_len_qr := invoker.InvokeBranch(pattern_len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
                ind_qr := invoker.InvokeBranch(        ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
           fill_len_qr := invoker.InvokeBranch(   fill_len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
                  a_qr.CancelStatusCheck('enq cancel');
              a_ind_qr.CancelStatusCheck('enq cancel');
        pattern_len_qr.CancelStatusCheck('enq cancel');
                ind_qr.CancelStatusCheck('enq cancel');
           fill_len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var           a :=           a_qr.GetResDirect;
        var       a_ind :=       a_ind_qr.GetResDirect;
        var pattern_len := pattern_len_qr.GetResDirect;
        var         ind :=         ind_qr.GetResDirect;
        var    fill_len :=    fill_len_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          a[a_ind], new UIntPtr(pattern_len * Marshal.SizeOf(default(T))),
          new UIntPtr(ind*Marshal.SizeOf(default(T))), new UIntPtr(fill_len*Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind:';
      sb += ' ';
      a_ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'pattern_len:';
      sb += ' ';
      pattern_len.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_len:';
      sb += ' ';
      fill_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillArray(a: CommandQueue<array of &T>; a_ind, pattern_len, ind, fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillArray<T>(a, a_ind, pattern_len, ind, fill_len));
end;

{$endregion FillArray}

{$region FillArray2}

type
  CLArrayCommandFillArray2<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private           a: CommandQueue<array[,] of &T>;
    private      a_ind1: CommandQueue<integer>;
    private      a_ind2: CommandQueue<integer>;
    private pattern_len: CommandQueue<integer>;
    private         ind: CommandQueue<integer>;
    private    fill_len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 6;
    
    public constructor(a: CommandQueue<array[,] of &T>; a_ind1,a_ind2, pattern_len, ind, fill_len: CommandQueue<integer>);
    begin
      self.          a :=           a;
      self.     a_ind1 :=      a_ind1;
      self.     a_ind2 :=      a_ind2;
      self.pattern_len := pattern_len;
      self.        ind :=         ind;
      self.   fill_len :=    fill_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
                a.InitBeforeInvoke(g, prev_hubs);
           a_ind1.InitBeforeInvoke(g, prev_hubs);
           a_ind2.InitBeforeInvoke(g, prev_hubs);
      pattern_len.InitBeforeInvoke(g, prev_hubs);
              ind.InitBeforeInvoke(g, prev_hubs);
         fill_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var           a_qr: QueueRes<array[,] of &T>;
      var      a_ind1_qr: QueueRes<integer>;
      var      a_ind2_qr: QueueRes<integer>;
      var pattern_len_qr: QueueRes<integer>;
      var         ind_qr: QueueRes<integer>;
      var    fill_len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
                  a_qr := invoker.InvokeBranch(          a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
             a_ind1_qr := invoker.InvokeBranch(     a_ind1.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
             a_ind2_qr := invoker.InvokeBranch(     a_ind2.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        pattern_len_qr := invoker.InvokeBranch(pattern_len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
                ind_qr := invoker.InvokeBranch(        ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
           fill_len_qr := invoker.InvokeBranch(   fill_len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
                  a_qr.CancelStatusCheck('enq cancel');
             a_ind1_qr.CancelStatusCheck('enq cancel');
             a_ind2_qr.CancelStatusCheck('enq cancel');
        pattern_len_qr.CancelStatusCheck('enq cancel');
                ind_qr.CancelStatusCheck('enq cancel');
           fill_len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var           a :=           a_qr.GetResDirect;
        var      a_ind1 :=      a_ind1_qr.GetResDirect;
        var      a_ind2 :=      a_ind2_qr.GetResDirect;
        var pattern_len := pattern_len_qr.GetResDirect;
        var         ind :=         ind_qr.GetResDirect;
        var    fill_len :=    fill_len_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          a[a_ind1,a_ind2], new UIntPtr(pattern_len * Marshal.SizeOf(default(T))),
          new UIntPtr(ind*Marshal.SizeOf(default(T))), new UIntPtr(fill_len*Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind1:';
      sb += ' ';
      a_ind1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind2:';
      sb += ' ';
      a_ind2.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'pattern_len:';
      sb += ' ';
      pattern_len.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_len:';
      sb += ' ';
      fill_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillArray2(a: CommandQueue<array[,] of &T>; a_ind1,a_ind2, pattern_len, ind, fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillArray2<T>(a, a_ind1, a_ind2, pattern_len, ind, fill_len));
end;

{$endregion FillArray2}

{$region FillArray3}

type
  CLArrayCommandFillArray3<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private           a: CommandQueue<array[,,] of &T>;
    private      a_ind1: CommandQueue<integer>;
    private      a_ind2: CommandQueue<integer>;
    private      a_ind3: CommandQueue<integer>;
    private pattern_len: CommandQueue<integer>;
    private         ind: CommandQueue<integer>;
    private    fill_len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 7;
    
    public constructor(a: CommandQueue<array[,,] of &T>; a_ind1,a_ind2,a_ind3, pattern_len, ind, fill_len: CommandQueue<integer>);
    begin
      self.          a :=           a;
      self.     a_ind1 :=      a_ind1;
      self.     a_ind2 :=      a_ind2;
      self.     a_ind3 :=      a_ind3;
      self.pattern_len := pattern_len;
      self.        ind :=         ind;
      self.   fill_len :=    fill_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
                a.InitBeforeInvoke(g, prev_hubs);
           a_ind1.InitBeforeInvoke(g, prev_hubs);
           a_ind2.InitBeforeInvoke(g, prev_hubs);
           a_ind3.InitBeforeInvoke(g, prev_hubs);
      pattern_len.InitBeforeInvoke(g, prev_hubs);
              ind.InitBeforeInvoke(g, prev_hubs);
         fill_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var           a_qr: QueueRes<array[,,] of &T>;
      var      a_ind1_qr: QueueRes<integer>;
      var      a_ind2_qr: QueueRes<integer>;
      var      a_ind3_qr: QueueRes<integer>;
      var pattern_len_qr: QueueRes<integer>;
      var         ind_qr: QueueRes<integer>;
      var    fill_len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
                  a_qr := invoker.InvokeBranch(          a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
             a_ind1_qr := invoker.InvokeBranch(     a_ind1.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
             a_ind2_qr := invoker.InvokeBranch(     a_ind2.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
             a_ind3_qr := invoker.InvokeBranch(     a_ind3.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        pattern_len_qr := invoker.InvokeBranch(pattern_len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
                ind_qr := invoker.InvokeBranch(        ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
           fill_len_qr := invoker.InvokeBranch(   fill_len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
                  a_qr.CancelStatusCheck('enq cancel');
             a_ind1_qr.CancelStatusCheck('enq cancel');
             a_ind2_qr.CancelStatusCheck('enq cancel');
             a_ind3_qr.CancelStatusCheck('enq cancel');
        pattern_len_qr.CancelStatusCheck('enq cancel');
                ind_qr.CancelStatusCheck('enq cancel');
           fill_len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var           a :=           a_qr.GetResDirect;
        var      a_ind1 :=      a_ind1_qr.GetResDirect;
        var      a_ind2 :=      a_ind2_qr.GetResDirect;
        var      a_ind3 :=      a_ind3_qr.GetResDirect;
        var pattern_len := pattern_len_qr.GetResDirect;
        var         ind :=         ind_qr.GetResDirect;
        var    fill_len :=    fill_len_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          a[a_ind1,a_ind2,a_ind3], new UIntPtr(pattern_len * Marshal.SizeOf(default(T))),
          new UIntPtr(ind*Marshal.SizeOf(default(T))), new UIntPtr(fill_len*Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind1:';
      sb += ' ';
      a_ind1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind2:';
      sb += ' ';
      a_ind2.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind3:';
      sb += ' ';
      a_ind3.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'pattern_len:';
      sb += ' ';
      pattern_len.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_len:';
      sb += ' ';
      fill_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillArray3(a: CommandQueue<array[,,] of &T>; a_ind1,a_ind2,a_ind3, pattern_len, ind, fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillArray3<T>(a, a_ind1, a_ind2, a_ind3, pattern_len, ind, fill_len));
end;

{$endregion FillArray3}

{$region FillArraySegment!AutoSize}

type
  CLArrayCommandFillArraySegmentAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private a: CommandQueue<ArraySegment<&T>>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(a: CommandQueue<ArraySegment<&T>>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var a_qr: QueueRes<ArraySegment<&T>>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        a_qr := invoker.InvokeBranch(a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        a_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a.Array, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          a.Array[a.Offset], new UIntPtr(a.Count * Marshal.SizeOf(default(T))),
          UIntPtr.Zero, new UIntPtr(o.ByteSize),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillArraySegment(a: CommandQueue<ArraySegment<&T>>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillArraySegmentAutoSize<T>(a));
end;

{$endregion FillArraySegment!AutoSize}

{$region FillArraySegment}

type
  CLArrayCommandFillArraySegment<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private        a: CommandQueue<ArraySegment<&T>>;
    private      ind: CommandQueue<integer>;
    private fill_len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 3;
    
    public constructor(a: CommandQueue<ArraySegment<&T>>; ind, fill_len: CommandQueue<integer>);
    begin
      self.       a :=        a;
      self.     ind :=      ind;
      self.fill_len := fill_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
             a.InitBeforeInvoke(g, prev_hubs);
           ind.InitBeforeInvoke(g, prev_hubs);
      fill_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var        a_qr: QueueRes<ArraySegment<&T>>;
      var      ind_qr: QueueRes<integer>;
      var fill_len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
               a_qr := invoker.InvokeBranch(       a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
             ind_qr := invoker.InvokeBranch(     ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        fill_len_qr := invoker.InvokeBranch(fill_len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
               a_qr.CancelStatusCheck('enq cancel');
             ind_qr.CancelStatusCheck('enq cancel');
        fill_len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var        a :=        a_qr.GetResDirect;
        var      ind :=      ind_qr.GetResDirect;
        var fill_len := fill_len_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a.Array, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          a.Array[a.Offset], new UIntPtr(a.Count * Marshal.SizeOf(default(T))),
          new UIntPtr(ind*Marshal.SizeOf(default(T))), new UIntPtr(fill_len*Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_len:';
      sb += ' ';
      fill_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillArraySegment(a: CommandQueue<ArraySegment<&T>>; ind, fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillArraySegment<T>(a, ind, fill_len));
end;

{$endregion FillArraySegment}

{$region FillData!AutoSize}

type
  CLArrayCommandFillDataAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private         ptr: CommandQueue<IntPtr>;
    private pattern_len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    public constructor(ptr: CommandQueue<IntPtr>; pattern_len: CommandQueue<integer>);
    begin
      self.        ptr :=         ptr;
      self.pattern_len := pattern_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
              ptr.InitBeforeInvoke(g, prev_hubs);
      pattern_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var         ptr_qr: QueueRes<IntPtr>;
      var pattern_len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
                ptr_qr := invoker.InvokeBranch(        ptr.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        pattern_len_qr := invoker.InvokeBranch(pattern_len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
                ptr_qr.CancelStatusCheck('enq cancel');
        pattern_len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var         ptr :=         ptr_qr.GetResDirect;
        var pattern_len := pattern_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          ptr, new UIntPtr(pattern_len*Marshal.SizeOf(default(T))),
          UIntPtr.Zero, new UIntPtr(o.ByteSize),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'ptr:';
      sb += ' ';
      ptr.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'pattern_len:';
      sb += ' ';
      pattern_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillData(ptr: CommandQueue<IntPtr>; pattern_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillDataAutoSize<T>(ptr, pattern_len));
end;

{$endregion FillData!AutoSize}

{$region FillData}

type
  CLArrayCommandFillData<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private         ptr: CommandQueue<IntPtr>;
    private pattern_len: CommandQueue<integer>;
    private         ind: CommandQueue<integer>;
    private    fill_len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 4;
    
    public constructor(ptr: CommandQueue<IntPtr>; pattern_len, ind, fill_len: CommandQueue<integer>);
    begin
      self.        ptr :=         ptr;
      self.pattern_len := pattern_len;
      self.        ind :=         ind;
      self.   fill_len :=    fill_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
              ptr.InitBeforeInvoke(g, prev_hubs);
      pattern_len.InitBeforeInvoke(g, prev_hubs);
              ind.InitBeforeInvoke(g, prev_hubs);
         fill_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var         ptr_qr: QueueRes<IntPtr>;
      var pattern_len_qr: QueueRes<integer>;
      var         ind_qr: QueueRes<integer>;
      var    fill_len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
                ptr_qr := invoker.InvokeBranch(        ptr.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        pattern_len_qr := invoker.InvokeBranch(pattern_len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
                ind_qr := invoker.InvokeBranch(        ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
           fill_len_qr := invoker.InvokeBranch(   fill_len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
                ptr_qr.CancelStatusCheck('enq cancel');
        pattern_len_qr.CancelStatusCheck('enq cancel');
                ind_qr.CancelStatusCheck('enq cancel');
           fill_len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var         ptr :=         ptr_qr.GetResDirect;
        var pattern_len := pattern_len_qr.GetResDirect;
        var         ind :=         ind_qr.GetResDirect;
        var    fill_len :=    fill_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          ptr, new UIntPtr(pattern_len*Marshal.SizeOf(default(T))),
          new UIntPtr(ind*Marshal.SizeOf(default(T))), new UIntPtr(fill_len*Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'ptr:';
      sb += ' ';
      ptr.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'pattern_len:';
      sb += ' ';
      pattern_len.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_len:';
      sb += ' ';
      fill_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillData(ptr: CommandQueue<IntPtr>; pattern_len, ind, fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillData<T>(ptr, pattern_len, ind, fill_len));
end;

{$endregion FillData}

{$region FillData!AutoSize}

function CLArrayCCQ<T>.ThenFillData(ptr: pointer; pattern_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := ThenFillData(IntPtr(ptr), pattern_len);
end;

{$endregion FillData!AutoSize}

{$region FillData}

function CLArrayCCQ<T>.ThenFillData(ptr: pointer; pattern_len, ind, fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := ThenFillData(IntPtr(ptr), pattern_len, ind, fill_len);
end;

{$endregion FillData}

{$region FillNativeMemoryArea!AutoSize}

function CLArrayCCQ<T>.ThenFillNativeMemoryArea(native_data: NativeMemoryArea): CLArrayCCQ<T>;
begin
  Result := ThenFillNativeMemoryArea(CQ(native_data));
end;

{$endregion FillNativeMemoryArea!AutoSize}

{$region FillNativeMemoryArea}

function CLArrayCCQ<T>.ThenFillNativeMemoryArea(native_data: NativeMemoryArea; ind,fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := ThenFillNativeMemoryArea(CQ(native_data),ind,fill_len);
end;

{$endregion FillNativeMemoryArea}

{$region FillNativeMemory!AutoSize}

function CLArrayCCQ<T>.ThenFillNativeMemory(native_data: NativeMemory): CLArrayCCQ<T>;
begin
  Result := ThenFillNativeMemory(CQ(native_data));
end;

{$endregion FillNativeMemory!AutoSize}

{$region FillNativeMemory}

function CLArrayCCQ<T>.ThenFillNativeMemory(native_data: NativeMemory; ind,fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := ThenFillNativeMemory(CQ(native_data),ind,fill_len);
end;

{$endregion FillNativeMemory}

{$region FillNativeValueArea!AutoSize}

function CLArrayCCQ<T>.ThenFillNativeValueArea(native_data: NativeValueArea<&T>): CLArrayCCQ<T>;
begin
  Result := ThenFillNativeValueArea(CQ(native_data));
end;

{$endregion FillNativeValueArea!AutoSize}

{$region FillNativeValueArea}

function CLArrayCCQ<T>.ThenFillNativeValueArea(native_data: NativeValueArea<&T>; ind,fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := ThenFillNativeValueArea(CQ(native_data),ind,fill_len);
end;

{$endregion FillNativeValueArea}

{$region FillNativeValue!AutoSize}

function CLArrayCCQ<T>.ThenFillNativeValue(native_data: NativeValue<&T>): CLArrayCCQ<T>;
begin
  Result := ThenFillNativeValue(CQ(native_data));
end;

{$endregion FillNativeValue!AutoSize}

{$region FillNativeValue}

function CLArrayCCQ<T>.ThenFillNativeValue(native_data: NativeValue<&T>; ind,fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := ThenFillNativeValue(CQ(native_data),ind,fill_len);
end;

{$endregion FillNativeValue}

{$region FillNativeArrayArea!AutoSize}

function CLArrayCCQ<T>.ThenFillNativeArrayArea(native_data: NativeArrayArea<&T>): CLArrayCCQ<T>;
begin
  Result := ThenFillNativeArrayArea(CQ(native_data));
end;

{$endregion FillNativeArrayArea!AutoSize}

{$region FillNativeArrayArea}

function CLArrayCCQ<T>.ThenFillNativeArrayArea(native_data: NativeArrayArea<&T>; ind,fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := ThenFillNativeArrayArea(CQ(native_data),ind,fill_len);
end;

{$endregion FillNativeArrayArea}

{$region FillNativeArray!AutoSize}

function CLArrayCCQ<T>.ThenFillNativeArray(native_data: NativeArray<&T>): CLArrayCCQ<T>;
begin
  Result := ThenFillNativeArray(CQ(native_data));
end;

{$endregion FillNativeArray!AutoSize}

{$region FillNativeArray}

function CLArrayCCQ<T>.ThenFillNativeArray(native_data: NativeArray<&T>; ind,fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := ThenFillNativeArray(CQ(native_data),ind,fill_len);
end;

{$endregion FillNativeArray}

{$region FillNativeMemoryArea!AutoSize}

type
  CLArrayCommandFillNativeMemoryAreaAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeMemoryArea>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(native_data: CommandQueue<NativeMemoryArea>);
    begin
      self.native_data := native_data;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeMemoryArea>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.ptr,
          native_data.sz,
          UIntPtr.Zero, new UIntPtr(o.ByteSize),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillNativeMemoryAreaAutoSize<T>(native_data));
end;

{$endregion FillNativeMemoryArea!AutoSize}

{$region FillNativeMemoryArea}

type
  CLArrayCommandFillNativeMemoryArea<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeMemoryArea>;
    private         ind: CommandQueue<integer>;
    private    fill_len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 3;
    
    public constructor(native_data: CommandQueue<NativeMemoryArea>; ind,fill_len: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self.        ind :=         ind;
      self.   fill_len :=    fill_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
              ind.InitBeforeInvoke(g, prev_hubs);
         fill_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeMemoryArea>;
      var         ind_qr: QueueRes<integer>;
      var    fill_len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
                ind_qr := invoker.InvokeBranch(        ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
           fill_len_qr := invoker.InvokeBranch(   fill_len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
                ind_qr.CancelStatusCheck('enq cancel');
           fill_len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var         ind :=         ind_qr.GetResDirect;
        var    fill_len :=    fill_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.ptr,
          native_data.sz,
          new UIntPtr(ind*Marshal.SizeOf(default(T))), new UIntPtr(fill_len*Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_len:';
      sb += ' ';
      fill_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>; ind,fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillNativeMemoryArea<T>(native_data, ind, fill_len));
end;

{$endregion FillNativeMemoryArea}

{$region FillNativeMemory!AutoSize}

type
  CLArrayCommandFillNativeMemoryAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeMemory>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(native_data: CommandQueue<NativeMemory>);
    begin
      self.native_data := native_data;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeMemory>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.Area.ptr,
          native_data.Area.sz,
          UIntPtr.Zero, new UIntPtr(o.ByteSize),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillNativeMemory(native_data: CommandQueue<NativeMemory>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillNativeMemoryAutoSize<T>(native_data));
end;

{$endregion FillNativeMemory!AutoSize}

{$region FillNativeMemory}

type
  CLArrayCommandFillNativeMemory<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeMemory>;
    private         ind: CommandQueue<integer>;
    private    fill_len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 3;
    
    public constructor(native_data: CommandQueue<NativeMemory>; ind,fill_len: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self.        ind :=         ind;
      self.   fill_len :=    fill_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
              ind.InitBeforeInvoke(g, prev_hubs);
         fill_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeMemory>;
      var         ind_qr: QueueRes<integer>;
      var    fill_len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
                ind_qr := invoker.InvokeBranch(        ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
           fill_len_qr := invoker.InvokeBranch(   fill_len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
                ind_qr.CancelStatusCheck('enq cancel');
           fill_len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var         ind :=         ind_qr.GetResDirect;
        var    fill_len :=    fill_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.Area.ptr,
          native_data.Area.sz,
          new UIntPtr(ind*Marshal.SizeOf(default(T))), new UIntPtr(fill_len*Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_len:';
      sb += ' ';
      fill_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillNativeMemory(native_data: CommandQueue<NativeMemory>; ind,fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillNativeMemory<T>(native_data, ind, fill_len));
end;

{$endregion FillNativeMemory}

{$region FillNativeValueArea!AutoSize}

type
  CLArrayCommandFillNativeValueAreaAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeValueArea<&T>>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(native_data: CommandQueue<NativeValueArea<&T>>);
    begin
      self.native_data := native_data;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeValueArea<&T>>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.ptr,
          native_data.ByteSize,
          UIntPtr.Zero, new UIntPtr(o.ByteSize),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillNativeValueAreaAutoSize<T>(native_data));
end;

{$endregion FillNativeValueArea!AutoSize}

{$region FillNativeValueArea}

type
  CLArrayCommandFillNativeValueArea<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeValueArea<&T>>;
    private         ind: CommandQueue<integer>;
    private    fill_len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 3;
    
    public constructor(native_data: CommandQueue<NativeValueArea<&T>>; ind,fill_len: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self.        ind :=         ind;
      self.   fill_len :=    fill_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
              ind.InitBeforeInvoke(g, prev_hubs);
         fill_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeValueArea<&T>>;
      var         ind_qr: QueueRes<integer>;
      var    fill_len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
                ind_qr := invoker.InvokeBranch(        ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
           fill_len_qr := invoker.InvokeBranch(   fill_len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
                ind_qr.CancelStatusCheck('enq cancel');
           fill_len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var         ind :=         ind_qr.GetResDirect;
        var    fill_len :=    fill_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.ptr,
          native_data.ByteSize,
          new UIntPtr(ind*Marshal.SizeOf(default(T))), new UIntPtr(fill_len*Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_len:';
      sb += ' ';
      fill_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillNativeValueArea(native_data: CommandQueue<NativeValueArea<&T>>; ind,fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillNativeValueArea<T>(native_data, ind, fill_len));
end;

{$endregion FillNativeValueArea}

{$region FillNativeValue!AutoSize}

type
  CLArrayCommandFillNativeValueAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeValue<&T>>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(native_data: CommandQueue<NativeValue<&T>>);
    begin
      self.native_data := native_data;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeValue<&T>>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.Area.ptr,
          native_data.Area.ByteSize,
          UIntPtr.Zero, new UIntPtr(o.ByteSize),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillNativeValue(native_data: CommandQueue<NativeValue<&T>>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillNativeValueAutoSize<T>(native_data));
end;

{$endregion FillNativeValue!AutoSize}

{$region FillNativeValue}

type
  CLArrayCommandFillNativeValue<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeValue<&T>>;
    private         ind: CommandQueue<integer>;
    private    fill_len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 3;
    
    public constructor(native_data: CommandQueue<NativeValue<&T>>; ind,fill_len: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self.        ind :=         ind;
      self.   fill_len :=    fill_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
              ind.InitBeforeInvoke(g, prev_hubs);
         fill_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeValue<&T>>;
      var         ind_qr: QueueRes<integer>;
      var    fill_len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
                ind_qr := invoker.InvokeBranch(        ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
           fill_len_qr := invoker.InvokeBranch(   fill_len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
                ind_qr.CancelStatusCheck('enq cancel');
           fill_len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var         ind :=         ind_qr.GetResDirect;
        var    fill_len :=    fill_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.Area.ptr,
          native_data.Area.ByteSize,
          new UIntPtr(ind*Marshal.SizeOf(default(T))), new UIntPtr(fill_len*Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_len:';
      sb += ' ';
      fill_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillNativeValue(native_data: CommandQueue<NativeValue<&T>>; ind,fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillNativeValue<T>(native_data, ind, fill_len));
end;

{$endregion FillNativeValue}

{$region FillNativeArrayArea!AutoSize}

type
  CLArrayCommandFillNativeArrayAreaAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeArrayArea<&T>>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(native_data: CommandQueue<NativeArrayArea<&T>>);
    begin
      self.native_data := native_data;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeArrayArea<&T>>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.first_ptr,
          native_data.ByteSize,
          UIntPtr.Zero, new UIntPtr(o.ByteSize),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillNativeArrayArea(native_data: CommandQueue<NativeArrayArea<&T>>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillNativeArrayAreaAutoSize<T>(native_data));
end;

{$endregion FillNativeArrayArea!AutoSize}

{$region FillNativeArrayArea}

type
  CLArrayCommandFillNativeArrayArea<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeArrayArea<&T>>;
    private         ind: CommandQueue<integer>;
    private    fill_len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 3;
    
    public constructor(native_data: CommandQueue<NativeArrayArea<&T>>; ind,fill_len: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self.        ind :=         ind;
      self.   fill_len :=    fill_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
              ind.InitBeforeInvoke(g, prev_hubs);
         fill_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeArrayArea<&T>>;
      var         ind_qr: QueueRes<integer>;
      var    fill_len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
                ind_qr := invoker.InvokeBranch(        ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
           fill_len_qr := invoker.InvokeBranch(   fill_len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
                ind_qr.CancelStatusCheck('enq cancel');
           fill_len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var         ind :=         ind_qr.GetResDirect;
        var    fill_len :=    fill_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.first_ptr,
          native_data.ByteSize,
          new UIntPtr(ind*Marshal.SizeOf(default(T))), new UIntPtr(fill_len*Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_len:';
      sb += ' ';
      fill_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillNativeArrayArea(native_data: CommandQueue<NativeArrayArea<&T>>; ind,fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillNativeArrayArea<T>(native_data, ind, fill_len));
end;

{$endregion FillNativeArrayArea}

{$region FillNativeArray!AutoSize}

type
  CLArrayCommandFillNativeArrayAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeArray<&T>>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(native_data: CommandQueue<NativeArray<&T>>);
    begin
      self.native_data := native_data;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeArray<&T>>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.Area.first_ptr,
          native_data.Area.ByteSize,
          UIntPtr.Zero, new UIntPtr(o.ByteSize),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillNativeArray(native_data: CommandQueue<NativeArray<&T>>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillNativeArrayAutoSize<T>(native_data));
end;

{$endregion FillNativeArray!AutoSize}

{$region FillNativeArray}

type
  CLArrayCommandFillNativeArray<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private native_data: CommandQueue<NativeArray<&T>>;
    private         ind: CommandQueue<integer>;
    private    fill_len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 3;
    
    public constructor(native_data: CommandQueue<NativeArray<&T>>; ind,fill_len: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self.        ind :=         ind;
      self.   fill_len :=    fill_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
              ind.InitBeforeInvoke(g, prev_hubs);
         fill_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var native_data_qr: QueueRes<NativeArray<&T>>;
      var         ind_qr: QueueRes<integer>;
      var    fill_len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        native_data_qr := invoker.InvokeBranch(native_data.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
                ind_qr := invoker.InvokeBranch(        ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
           fill_len_qr := invoker.InvokeBranch(   fill_len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        native_data_qr.CancelStatusCheck('enq cancel');
                ind_qr.CancelStatusCheck('enq cancel');
           fill_len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var         ind :=         ind_qr.GetResDirect;
        var    fill_len :=    fill_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.Area.first_ptr,
          native_data.Area.ByteSize,
          new UIntPtr(ind*Marshal.SizeOf(default(T))), new UIntPtr(fill_len*Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_len:';
      sb += ' ';
      fill_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillNativeArray(native_data: CommandQueue<NativeArray<&T>>; ind,fill_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillNativeArray<T>(native_data, ind, fill_len));
end;

{$endregion FillNativeArray}

{$endregion 2#Fill}

{$region 3#Copy}

{$region CopyTo!CLMemoryAutoSize}

type
  CLArrayCommandCopyToCLMemoryAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private mem: CommandQueue<CLMemory>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(mem: CommandQueue<CLMemory>);
    begin
      self.mem := mem;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      mem.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var mem_qr: QueueRes<CLMemory>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        mem_qr := invoker.InvokeBranch(mem.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        mem_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var mem := mem_qr.GetResDirect;
        var res_ev: cl_event;
        
        var uptr_mem_offset := UIntPtr.Zero;
        var uptr_own_offset := UIntPtr.Zero;
        var ec := cl.EnqueueCopyBuffer(
          cq, o.Native,mem.Native,
          uptr_own_offset,uptr_mem_offset,
          new UIntPtr(Min(o.ByteSize, mem.Size64)),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'mem:';
      sb += ' ';
      mem.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenCopyTo(mem: CommandQueue<CLMemory>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandCopyToCLMemoryAutoSize<T>(mem));
end;

{$endregion CopyTo!CLMemoryAutoSize}

{$region CopyTo!CLMemory}

type
  CLArrayCommandCopyToCLMemory<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private        mem: CommandQueue<CLMemory>;
    private mem_offset: CommandQueue<integer>;
    private        ind: CommandQueue<integer>;
    private        len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 4;
    
    public constructor(mem: CommandQueue<CLMemory>; mem_offset, ind, len: CommandQueue<integer>);
    begin
      self.       mem :=        mem;
      self.mem_offset := mem_offset;
      self.       ind :=        ind;
      self.       len :=        len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
             mem.InitBeforeInvoke(g, prev_hubs);
      mem_offset.InitBeforeInvoke(g, prev_hubs);
             ind.InitBeforeInvoke(g, prev_hubs);
             len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var        mem_qr: QueueRes<CLMemory>;
      var mem_offset_qr: QueueRes<integer>;
      var        ind_qr: QueueRes<integer>;
      var        len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
               mem_qr := invoker.InvokeBranch(       mem.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        mem_offset_qr := invoker.InvokeBranch(mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
               ind_qr := invoker.InvokeBranch(       ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
               len_qr := invoker.InvokeBranch(       len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
               mem_qr.CancelStatusCheck('enq cancel');
        mem_offset_qr.CancelStatusCheck('enq cancel');
               ind_qr.CancelStatusCheck('enq cancel');
               len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var        mem :=        mem_qr.GetResDirect;
        var mem_offset := mem_offset_qr.GetResDirect;
        var        ind :=        ind_qr.GetResDirect;
        var        len :=        len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var uptr_mem_offset := new UIntPtr(mem_offset);
        var uptr_own_offset := new UIntPtr(ind*Marshal.SizeOf(default(T)));
        var ec := cl.EnqueueCopyBuffer(
          cq, o.Native,mem.Native,
          uptr_own_offset,uptr_mem_offset,
          new UIntPtr(len*Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'mem:';
      sb += ' ';
      mem.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenCopyTo(mem: CommandQueue<CLMemory>; mem_offset, ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandCopyToCLMemory<T>(mem, mem_offset, ind, len));
end;

{$endregion CopyTo!CLMemory}

{$region CopyFrom!CLMemoryAutoSize}

type
  CLArrayCommandCopyFromCLMemoryAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private mem: CommandQueue<CLMemory>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(mem: CommandQueue<CLMemory>);
    begin
      self.mem := mem;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      mem.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var mem_qr: QueueRes<CLMemory>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        mem_qr := invoker.InvokeBranch(mem.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        mem_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var mem := mem_qr.GetResDirect;
        var res_ev: cl_event;
        
        var uptr_mem_offset := UIntPtr.Zero;
        var uptr_own_offset := UIntPtr.Zero;
        var ec := cl.EnqueueCopyBuffer(
          cq, mem.Native,o.Native,
          uptr_mem_offset,uptr_own_offset,
          new UIntPtr(Min(o.ByteSize, mem.Size64)),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'mem:';
      sb += ' ';
      mem.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenCopyFrom(mem: CommandQueue<CLMemory>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandCopyFromCLMemoryAutoSize<T>(mem));
end;

{$endregion CopyFrom!CLMemoryAutoSize}

{$region CopyFrom!CLMemory}

type
  CLArrayCommandCopyFromCLMemory<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private        mem: CommandQueue<CLMemory>;
    private mem_offset: CommandQueue<integer>;
    private        ind: CommandQueue<integer>;
    private        len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 4;
    
    public constructor(mem: CommandQueue<CLMemory>; mem_offset, ind, len: CommandQueue<integer>);
    begin
      self.       mem :=        mem;
      self.mem_offset := mem_offset;
      self.       ind :=        ind;
      self.       len :=        len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
             mem.InitBeforeInvoke(g, prev_hubs);
      mem_offset.InitBeforeInvoke(g, prev_hubs);
             ind.InitBeforeInvoke(g, prev_hubs);
             len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var        mem_qr: QueueRes<CLMemory>;
      var mem_offset_qr: QueueRes<integer>;
      var        ind_qr: QueueRes<integer>;
      var        len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
               mem_qr := invoker.InvokeBranch(       mem.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        mem_offset_qr := invoker.InvokeBranch(mem_offset.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
               ind_qr := invoker.InvokeBranch(       ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
               len_qr := invoker.InvokeBranch(       len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
               mem_qr.CancelStatusCheck('enq cancel');
        mem_offset_qr.CancelStatusCheck('enq cancel');
               ind_qr.CancelStatusCheck('enq cancel');
               len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var        mem :=        mem_qr.GetResDirect;
        var mem_offset := mem_offset_qr.GetResDirect;
        var        ind :=        ind_qr.GetResDirect;
        var        len :=        len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var uptr_mem_offset := new UIntPtr(mem_offset);
        var uptr_own_offset := new UIntPtr(ind*Marshal.SizeOf(default(T)));
        var ec := cl.EnqueueCopyBuffer(
          cq, mem.Native,o.Native,
          uptr_mem_offset,uptr_own_offset,
          new UIntPtr(len*Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'mem:';
      sb += ' ';
      mem.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenCopyFrom(mem: CommandQueue<CLMemory>; mem_offset, ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandCopyFromCLMemory<T>(mem, mem_offset, ind, len));
end;

{$endregion CopyFrom!CLMemory}

{$region CopyTo!CLValue}

type
  CLArrayCommandCopyToCLValue<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private val: CommandQueue<CLValue<&T>>;
    private ind: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    public constructor(val: CommandQueue<CLValue<&T>>; ind: CommandQueue<integer>);
    begin
      self.val := val;
      self.ind := ind;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      val.InitBeforeInvoke(g, prev_hubs);
      ind.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var val_qr: QueueRes<CLValue<&T>>;
      var ind_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        val_qr := invoker.InvokeBranch(val.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        ind_qr := invoker.InvokeBranch(ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        val_qr.CancelStatusCheck('enq cancel');
        ind_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var val := val_qr.GetResDirect;
        var ind := ind_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueCopyBuffer(
          cq, o.Native,val.Native,
          new UIntPtr(ind*Marshal.SizeOf(default(T))),UIntPtr.Zero,
          new UIntPtr(Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      val.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenCopyTo(val: CommandQueue<CLValue<&T>>; ind: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandCopyToCLValue<T>(val, ind));
end;

{$endregion CopyTo!CLValue}

{$region CopyFrom!CLValue}

type
  CLArrayCommandCopyFromCLValue<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private val: CommandQueue<CLValue<&T>>;
    private ind: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    public constructor(val: CommandQueue<CLValue<&T>>; ind: CommandQueue<integer>);
    begin
      self.val := val;
      self.ind := ind;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      val.InitBeforeInvoke(g, prev_hubs);
      ind.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var val_qr: QueueRes<CLValue<&T>>;
      var ind_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        val_qr := invoker.InvokeBranch(val.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        ind_qr := invoker.InvokeBranch(ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        val_qr.CancelStatusCheck('enq cancel');
        ind_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var val := val_qr.GetResDirect;
        var ind := ind_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueCopyBuffer(
          cq, val.Native,o.Native,
          UIntPtr.Zero,new UIntPtr(ind*Marshal.SizeOf(default(T))),
          new UIntPtr(Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      val.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenCopyFrom(val: CommandQueue<CLValue<&T>>; ind: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandCopyFromCLValue<T>(val, ind));
end;

{$endregion CopyFrom!CLValue}

{$region CopyTo!CLArrayAutoSize}

type
  CLArrayCommandCopyToCLArrayAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private a: CommandQueue<CLArray<&T>>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(a: CommandQueue<CLArray<&T>>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var a_qr: QueueRes<CLArray<&T>>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        a_qr := invoker.InvokeBranch(a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        a_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueCopyBuffer(
          cq, o.Native,a.Native,
          UIntPtr.Zero, UIntPtr.Zero,
          new UIntPtr(Min(o.ByteSize, a.ByteSize)),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenCopyTo(a: CommandQueue<CLArray<&T>>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandCopyToCLArrayAutoSize<T>(a));
end;

{$endregion CopyTo!CLArrayAutoSize}

{$region CopyTo!CLArray}

type
  CLArrayCommandCopyToCLArray<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private        a: CommandQueue<CLArray<&T>>;
    private from_ind: CommandQueue<integer>;
    private   to_ind: CommandQueue<integer>;
    private      len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 4;
    
    public constructor(a: CommandQueue<CLArray<&T>>; from_ind, to_ind, len: CommandQueue<integer>);
    begin
      self.       a :=        a;
      self.from_ind := from_ind;
      self.  to_ind :=   to_ind;
      self.     len :=      len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
             a.InitBeforeInvoke(g, prev_hubs);
      from_ind.InitBeforeInvoke(g, prev_hubs);
        to_ind.InitBeforeInvoke(g, prev_hubs);
           len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var        a_qr: QueueRes<CLArray<&T>>;
      var from_ind_qr: QueueRes<integer>;
      var   to_ind_qr: QueueRes<integer>;
      var      len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
               a_qr := invoker.InvokeBranch(       a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        from_ind_qr := invoker.InvokeBranch(from_ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
          to_ind_qr := invoker.InvokeBranch(  to_ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
             len_qr := invoker.InvokeBranch(     len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
               a_qr.CancelStatusCheck('enq cancel');
        from_ind_qr.CancelStatusCheck('enq cancel');
          to_ind_qr.CancelStatusCheck('enq cancel');
             len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var        a :=        a_qr.GetResDirect;
        var from_ind := from_ind_qr.GetResDirect;
        var   to_ind :=   to_ind_qr.GetResDirect;
        var      len :=      len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueCopyBuffer(
          cq, o.Native,a.Native,
          new UIntPtr(from_ind*Marshal.SizeOf(default(T))), new UIntPtr(to_ind*Marshal.SizeOf(default(T))),
          new UIntPtr(len*Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'from_ind:';
      sb += ' ';
      from_ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'to_ind:';
      sb += ' ';
      to_ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenCopyTo(a: CommandQueue<CLArray<&T>>; from_ind, to_ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandCopyToCLArray<T>(a, from_ind, to_ind, len));
end;

{$endregion CopyTo!CLArray}

{$region CopyFrom!CLArrayAutoSize}

type
  CLArrayCommandCopyFromCLArrayAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private a: CommandQueue<CLArray<&T>>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(a: CommandQueue<CLArray<&T>>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var a_qr: QueueRes<CLArray<&T>>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        a_qr := invoker.InvokeBranch(a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        a_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueCopyBuffer(
          cq, a.Native,o.Native,
          UIntPtr.Zero, UIntPtr.Zero,
          new UIntPtr(Min(o.ByteSize, a.ByteSize)),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenCopyFrom(a: CommandQueue<CLArray<&T>>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandCopyFromCLArrayAutoSize<T>(a));
end;

{$endregion CopyFrom!CLArrayAutoSize}

{$region CopyFrom!CLArray}

type
  CLArrayCommandCopyFromCLArray<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private        a: CommandQueue<CLArray<&T>>;
    private from_ind: CommandQueue<integer>;
    private   to_ind: CommandQueue<integer>;
    private      len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 4;
    
    public constructor(a: CommandQueue<CLArray<&T>>; from_ind, to_ind, len: CommandQueue<integer>);
    begin
      self.       a :=        a;
      self.from_ind := from_ind;
      self.  to_ind :=   to_ind;
      self.     len :=      len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
             a.InitBeforeInvoke(g, prev_hubs);
      from_ind.InitBeforeInvoke(g, prev_hubs);
        to_ind.InitBeforeInvoke(g, prev_hubs);
           len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>): ParamInvRes<CLArray<T>>; override;
    begin
      var        a_qr: QueueRes<CLArray<&T>>;
      var from_ind_qr: QueueRes<integer>;
      var   to_ind_qr: QueueRes<integer>;
      var      len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
               a_qr := invoker.InvokeBranch(       a.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        from_ind_qr := invoker.InvokeBranch(from_ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
          to_ind_qr := invoker.InvokeBranch(  to_ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
             len_qr := invoker.InvokeBranch(     len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
               a_qr.CancelStatusCheck('enq cancel');
        from_ind_qr.CancelStatusCheck('enq cancel');
          to_ind_qr.CancelStatusCheck('enq cancel');
             len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var        a :=        a_qr.GetResDirect;
        var from_ind := from_ind_qr.GetResDirect;
        var   to_ind :=   to_ind_qr.GetResDirect;
        var      len :=      len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueCopyBuffer(
          cq, a.Native,o.Native,
          new UIntPtr(from_ind*Marshal.SizeOf(default(T))), new UIntPtr(to_ind*Marshal.SizeOf(default(T))),
          new UIntPtr(len*Marshal.SizeOf(default(T))),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'from_ind:';
      sb += ' ';
      from_ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'to_ind:';
      sb += ' ';
      to_ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenCopyFrom(a: CommandQueue<CLArray<&T>>; from_ind, to_ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandCopyFromCLArray<T>(a, from_ind, to_ind, len));
end;

{$endregion CopyFrom!CLArray}

{$endregion 3#Copy}

{$region Get}

{$region GetValue}

type
  CLArrayCommandGetValue<T> = sealed class(EnqueueableGetPtrCommand<CLArray<T>, &T>)
  where T: record;
    private ind: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(ccq: CLArrayCCQ<T>; ind: CommandQueue<integer>);
    begin
      inherited Create(ccq);
      self.ind := ind;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      prev_commands.InitBeforeInvoke(g, prev_hubs);
      ind.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>; own_qr: QueueRes<&T>): ParamInvRes<CLArray<T>>; override;
    begin
      var ind_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        ind_qr := invoker.InvokeBranch(ind.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        ind_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var ind := ind_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          new UIntPtr(int64(ind) * Marshal.SizeOf(default(T))), new UIntPtr(Marshal.SizeOf(default(T))),
          (own_qr as QueueResPtr<&T>).GetResPtrForWrite,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          GC.KeepAlive(own_qr);
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'ind:';
      sb += ' ';
      ind.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenGetValue(ind: CommandQueue<integer>): CommandQueue<&T>;
begin
  Result := new CLArrayCommandGetValue<T>(self, ind) as CommandQueue<&T>;
end;

{$endregion GetValue}

{$region GetArray!AutoSize}

type
  CLArrayCommandGetArrayAutoSize<T> = sealed class(EnqueueableGetCommand<CLArray<T>, array of &T>)
  where T: record;
    
    protected function ExpectedEnqCount: integer; override := 0;
    
    public constructor(ccq: CLArrayCCQ<T>);
    begin
      inherited Create(ccq);
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override := prev_commands.InitBeforeInvoke(g, prev_hubs);
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>; own_qr: QueueRes<array of &T>): ParamInvRes<CLArray<T>>; override;
    begin
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var res := new T[o.Length];
        own_qr.SetRes(res);
        var res_hnd := GCHandle.Alloc(res, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(o.ByteSize),
          res_hnd.AddrOfPinnedObject.ToPointer,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          res_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override := sb += #10;
    
  end;
  
function CLArrayCCQ<T>.ThenGetArray: CommandQueue<array of &T>;
begin
  Result := new CLArrayCommandGetArrayAutoSize<T>(self) as CommandQueue<array of &T>;
end;

{$endregion GetArray!AutoSize}

{$region GetArray}

type
  CLArrayCommandGetArray<T> = sealed class(EnqueueableGetCommand<CLArray<T>, array of &T>)
  where T: record;
    private len: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 1;
    
    public constructor(ccq: CLArrayCCQ<T>; len: CommandQueue<integer>);
    begin
      inherited Create(ccq);
      self.len := len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      prev_commands.InitBeforeInvoke(g, prev_hubs);
      len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>; own_qr: QueueRes<array of &T>): ParamInvRes<CLArray<T>>; override;
    begin
      var len_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        len_qr := invoker.InvokeBranch(len.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        len_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var len := len_qr.GetResDirect;
        var res := new &T[len];
        own_qr.SetRes(res);
        var res_hnd := GCHandle.Alloc(res, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(res.Length * Marshal.SizeOf(default(T))),
          res[0],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          res_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenGetArray(len: CommandQueue<integer>): CommandQueue<array of &T>;
begin
  Result := new CLArrayCommandGetArray<T>(self, len) as CommandQueue<array of &T>;
end;

{$endregion GetArray}

{$region GetArray2}

type
  CLArrayCommandGetArray2<T> = sealed class(EnqueueableGetCommand<CLArray<T>, array[,] of &T>)
  where T: record;
    private len1: CommandQueue<integer>;
    private len2: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 2;
    
    public constructor(ccq: CLArrayCCQ<T>; len1,len2: CommandQueue<integer>);
    begin
      inherited Create(ccq);
      self.len1 := len1;
      self.len2 := len2;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      prev_commands.InitBeforeInvoke(g, prev_hubs);
      len1.InitBeforeInvoke(g, prev_hubs);
      len2.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>; own_qr: QueueRes<array[,] of &T>): ParamInvRes<CLArray<T>>; override;
    begin
      var len1_qr: QueueRes<integer>;
      var len2_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        len1_qr := invoker.InvokeBranch(len1.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        len2_qr := invoker.InvokeBranch(len2.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        len1_qr.CancelStatusCheck('enq cancel');
        len2_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var len1 := len1_qr.GetResDirect;
        var len2 := len2_qr.GetResDirect;
        var res := new &T[len1,len2];
        own_qr.SetRes(res);
        var res_hnd := GCHandle.Alloc(res, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(res.Length * Marshal.SizeOf(default(T))),
          res[0,0],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          res_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'len1:';
      sb += ' ';
      len1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len2:';
      sb += ' ';
      len2.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenGetArray2(len1,len2: CommandQueue<integer>): CommandQueue<array[,] of &T>;
begin
  Result := new CLArrayCommandGetArray2<T>(self, len1, len2) as CommandQueue<array[,] of &T>;
end;

{$endregion GetArray2}

{$region GetArray3}

type
  CLArrayCommandGetArray3<T> = sealed class(EnqueueableGetCommand<CLArray<T>, array[,,] of &T>)
  where T: record;
    private len1: CommandQueue<integer>;
    private len2: CommandQueue<integer>;
    private len3: CommandQueue<integer>;
    
    protected function ExpectedEnqCount: integer; override := 3;
    
    public constructor(ccq: CLArrayCCQ<T>; len1,len2,len3: CommandQueue<integer>);
    begin
      inherited Create(ccq);
      self.len1 := len1;
      self.len2 := len2;
      self.len3 := len3;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueue>); override;
    begin
      prev_commands.InitBeforeInvoke(g, prev_hubs);
      len1.InitBeforeInvoke(g, prev_hubs);
      len2.InitBeforeInvoke(g, prev_hubs);
      len3.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(enq_c: integer; o_const: boolean; g: CLTaskGlobalData; enq_evs: DoubleList<EventList>; par_err_handlers: DoubleList<ErrHandler>; own_qr: QueueRes<array[,,] of &T>): ParamInvRes<CLArray<T>>; override;
    begin
      var len1_qr: QueueRes<integer>;
      var len2_qr: QueueRes<integer>;
      var len3_qr: QueueRes<integer>;
      
      g.ParallelInvoke(nil, enq_c, invoker->
      begin
        len1_qr := invoker.InvokeBranch(len1.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        len2_qr := invoker.InvokeBranch(len2.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
        len3_qr := invoker.InvokeBranch(len3.InvokeToAny, par_err_handlers, True).AddToEvLst(g, enq_evs, True);
      end);
      
      {$ifdef DEBUG}
      Result.Item1 := ()->
      begin
        len1_qr.CancelStatusCheck('enq cancel');
        len2_qr.CancelStatusCheck('enq cancel');
        len3_qr.CancelStatusCheck('enq cancel');
      end;
      {$else DEBUG}
      Result.Item1 := nil;
      {$endif DEBUG}
      
      Result.Item2 := (o, cq, evs)->
      begin
        var len1 := len1_qr.GetResDirect;
        var len2 := len2_qr.GetResDirect;
        var len3 := len3_qr.GetResDirect;
        var res := new &T[len1,len2,len3];
        own_qr.SetRes(res);
        var res_hnd := GCHandle.Alloc(res, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, clBool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(res.Length * Marshal.SizeOf(default(T))),
          res[0,0,0],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          res_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'len1:';
      sb += ' ';
      len1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len2:';
      sb += ' ';
      len2.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len3:';
      sb += ' ';
      len3.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenGetArray3(len1,len2,len3: CommandQueue<integer>): CommandQueue<array[,,] of &T>;
begin
  Result := new CLArrayCommandGetArray3<T>(self, len1, len2, len3) as CommandQueue<array[,,] of &T>;
end;

{$endregion GetArray3}

{$endregion Get}

{$endregion Explicit}

{$endregion CLArray}

{$endregion Enqueueable's}

{$region Global subprograms}

{$region CQ}

function CQNil := ConstQueueNil.Instance;

function CQ<T>(o: T) := CommandQueue&<T>(o);

{$endregion CQ}

{$region HPQ/HFQ}

{$region Common} type
  
  {$region Proc}
  
  CommandQueueHostProcBase<TProc> = abstract class(CommandQueueNil)
  where TProc: ISimpleProc0Container;
    protected p: TProc;
    
    public constructor(p: TProc) := self.p := p;
    private constructor := raise new OpenCLABCInternalException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_mu: HashSet<IMultiusableCommandQueue>); override := exit;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += ': ';
      p.ToStringB(sb);
      sb += #10;
    end;
    
  end;
  
  {$endregion Proc}
  
  {$region Func}
  
  CommandQueueHostFuncBase<T, TFunc> = abstract class(CommandQueue<T>)
  where TFunc: ISimpleFunc0Container<T>;
    protected f: TFunc;
    
    public constructor(f: TFunc) := self.f := f;
    private constructor := raise new OpenCLABCInternalException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_mu: HashSet<IMultiusableCommandQueue>); override := exit;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += ': ';
      f.ToStringB(sb);
      sb += #10;
    end;
    
  end;
  
  {$endregion Func}
  
{$endregion Common}

{$region Proc}

type
  CommandQueueHostQuickProc<TProc> = sealed class(CommandQueueHostProcBase<TProc>)
  where TProc: ISimpleProc0Container;
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil; override;
    begin
      Result := new QueueResNil(l);
      var err_handler := g.curr_err_handler.Extract({$ifdef DEBUG}false{$endif});
      
      {$ifdef DEBUG}
      var err_test_reason := $'[{self.GetHashCode}]:{TypeName(self)}.InvokeProc';
      err_handler.AddMaybeError(err_test_reason);
      {$endif DEBUG}
      
      if l.ShouldInstaCallAction then
        p.Invoke(g, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, g.c) else
        Result.AddAction(c->self.p.Invoke(nil, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, c));
      
    end;
    
  end;
  
  CommandQueueHostThreadedProc<TProc> = sealed class(CommandQueueHostProcBase<TProc>)
  where TProc: ISimpleProc0Container;
    
    private function MakeBody(prev_d: QueueResComplDelegateData; err_handler: ErrHandler; c: CLContext{$ifdef DEBUG}; err_test_reason: string{$endif}): Action := ()->
    begin
      prev_d.Invoke(c);
      self.p.Invoke(nil, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, c);
    end;
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil; override;
    begin
      var err_handler := g.curr_err_handler.Extract({$ifdef DEBUG}false{$endif});
      
      {$ifdef DEBUG}
      var err_test_reason := $'[{self.GetHashCode}]:{TypeName(self)}.InvokeProc';
      err_handler.AddMaybeError(err_test_reason);
      {$endif DEBUG}
      
      Result := new QueueResNil(UserEvent.StartWorkThread(
        l.prev_ev, MakeBody(l.prev_delegate, err_handler, g.c{$ifdef DEBUG}, err_test_reason{$endif}), g
        {$ifdef EventDebug}, $'body of {TypeName(self)}'{$endif}
      ));
      
    end;
    
  end;
  
function HPQ<TProc>(p: TProc; need_own_thread: boolean): CommandQueueNil; where TProc: ISimpleProc0Container;
begin
  if need_own_thread then
    Result := new CommandQueueHostThreadedProc<TProc>(p) else
    Result := new CommandQueueHostQuickProc   <TProc>(p);
end;

function HPQ(p: ()->(); need_own_thread: boolean) :=
HPQ&<SimpleProc0Container >(p, need_own_thread);
function HPQ(p: CLContext->(); need_own_thread: boolean) :=
HPQ&<SimpleProc0ContainerC>(p, need_own_thread);

{$endregion Proc}

{$region Func}

type
  CommandQueueHostQuickFunc<T, TFunc> = sealed class(CommandQueueHostFuncBase<T, TFunc>)
  where TFunc: ISimpleFunc0Container<T>;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; qr_factory: IQueueResFactory<T,TR>): TR; where TR: IQueueRes;
    begin
      var err_handler := g.curr_err_handler.Extract({$ifdef DEBUG}false{$endif});
      {$ifdef DEBUG}
      var err_test_reason := $'[{self.GetHashCode}]:{TypeName(self)}.InvokeFunc';
      err_handler.AddMaybeError(err_test_reason);
      {$endif DEBUG}
      
      Result := if l.ShouldInstaCallAction then
        qr_factory.MakeConst(l,
          f.Invoke(g, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, g.c)
        ) else
        qr_factory.MakeDelayed(l, qr->c->qr.SetRes(
          f.Invoke(nil, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, g.c)
        ));
      
    end;
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil;    override := Invoke(g, l, qr_nil_factory);
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes   <T>; override := Invoke(g, l, qr_val_factory);
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<T>; override := Invoke(g, l, qr_ptr_factory);
    
  end;
  
  CommandQueueHostThreadedFunc<T, TFunc> = sealed class(CommandQueueHostFuncBase<T, TFunc>)
  where TFunc: ISimpleFunc0Container<T>;
    
    private function MakeNilBody    (prev_d: QueueResComplDelegateData; c: CLContext; err_handler: ErrHandler; own_qr: QueueResNil{$ifdef DEBUG}; err_test_reason: string{$endif}): Action := ()->
    begin
      prev_d.Invoke(c);
      f.Invoke(nil, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, c);
    end;
    private function MakeResBody<TR>(prev_d: QueueResComplDelegateData; c: CLContext; err_handler: ErrHandler; own_qr: TR{$ifdef DEBUG}; err_test_reason: string{$endif}): Action; where TR: QueueRes<T>;
    begin
      Result := ()->
      begin
        prev_d.Invoke(c);
        own_qr.SetRes(
          f.Invoke(nil, err_handler{$ifdef DEBUG}, err_test_reason{$endif}, c)
        );
      end;
    end;
    
    private [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function Invoke<TR>(g: CLTaskGlobalData; l: CLTaskLocalData; qr_factory: IQueueResFactory<T,TR>; make_body: (QueueResComplDelegateData,CLContext,ErrHandler,TR{$ifdef DEBUG},string{$endif})->Action): TR; where TR: IQueueRes;
    begin
      var err_handler := g.curr_err_handler.Extract({$ifdef DEBUG}false{$endif});
      
      {$ifdef DEBUG}
      var err_test_reason := $'[{self.GetHashCode}]:{TypeName(self)}.InvokeFunc';
      err_handler.AddMaybeError(err_test_reason);
      {$endif DEBUG}
      
      Result := qr_factory.MakeDelayed(qr->new CLTaskLocalData(
        UserEvent.StartWorkThread(l.prev_ev,
          make_body(l.prev_delegate, g.c, err_handler, qr{$ifdef DEBUG}, err_test_reason{$endif}), g
          {$ifdef EventDebug}, $'body of {TypeName(self)}'{$endif}
        )
      ));
      
    end;
    
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil;    override := Invoke(g, l, qr_nil_factory, MakeNilBody);
    protected function InvokeToAny(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes   <T>; override := Invoke(g, l, qr_val_factory, MakeResBody&<QueueResVal<T>>);
    protected function InvokeToPtr(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResPtr<T>; override := Invoke(g, l, qr_ptr_factory, MakeResBody&<QueueResPtr<T>>);
    
  end;
  
function HFQ<T,TFunc>(f: TFunc; need_own_thread: boolean): CommandQueue<T>; where TFunc: ISimpleFunc0Container<T>;
begin
  if need_own_thread then
    Result := new CommandQueueHostThreadedFunc<T, TFunc>(f) else
    Result := new CommandQueueHostQuickFunc   <T, TFunc>(f);
end;

function HFQ<T>(f: ()->T; need_own_thread: boolean) :=
HFQ&<T, SimpleFunc0Container <T>>(f, need_own_thread);
function HFQ<T>(f: CLContext->T; need_own_thread: boolean) :=
HFQ&<T, SimpleFunc0ContainerC<T>>(f, need_own_thread);

{$endregion Func}

{$endregion HPQ/HFQ}

{$region CombineQueue's}

{$region Sync}

{$region Simple}

function CombineSyncQueue(params qs: array of CommandQueueBase) := QueueArrayUtils.ConstructSync&<CommandQueueBase>(qs.Cast&<CommandQueueBase>);
function CombineSyncQueue(params qs: array of CommandQueueNil) := QueueArrayUtils.ConstructSync&<CommandQueueNil>(qs.Cast&<CommandQueueBase>);
function CombineSyncQueue<T>(params qs: array of CommandQueue<T>) := QueueArrayUtils.ConstructSync&<CommandQueue<T>>(qs.Cast&<CommandQueueBase>);

function CombineSyncQueue<TQ>(qs: array of TQ; last: CommandQueueBase) := QueueArrayUtils.ConstructSync&<CommandQueueBase>(qs.Cast&<CommandQueueBase>.Append&<CommandQueueBase>(last));
function CombineSyncQueue<TQ>(qs: array of TQ; last: CommandQueueNil) := QueueArrayUtils.ConstructSync&<CommandQueueNil>(qs.Cast&<CommandQueueBase>.Append&<CommandQueueBase>(last));
function CombineSyncQueue<T, TQ>(qs: array of TQ; last: CommandQueue<T>) := QueueArrayUtils.ConstructSync&<CommandQueue<T>>(qs.Cast&<CommandQueueBase>.Append&<CommandQueueBase>(last));

{$endregion Simple}

{$region Conv}

{$region NonContext}

function CombineConvSyncQueue<TInp, TRes>(conv: Func<array of TInp, TRes>; qs: array of CommandQueue<TInp>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if qs.All(q->q.IsConstResDepEmpty) then
  begin
    var inp := qs.ConvertAll(q->q.expected_const_res);
    Result := if can_pre_calc then
      CQ(conv(inp)) else
      HFQ(()->conv(inp), need_own_thread);
    Result := CombineSyncQueue(qs, Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray<TInp, TRes, QueueArraySyncInvoker, SimpleFuncContainer<array of TInp, TRes>>(qs.ToArray, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray   <TInp, TRes, QueueArraySyncInvoker, SimpleFuncContainer<array of TInp, TRes>>(qs.ToArray, conv, can_pre_calc);
end;

function CombineConvSyncQueueN2<TInp1,TInp2, TRes>(conv: Func<TInp1, TInp2, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2)) else
      HFQ(()->conv(inp1,inp2), need_own_thread);
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray2<TInp1,TInp2, TRes, QueueArray2SyncInvoker, SimpleFunc2Container<TInp1, TInp2, TRes>>(q1,q2, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray2   <TInp1,TInp2, TRes, QueueArray2SyncInvoker, SimpleFunc2Container<TInp1, TInp2, TRes>>(q1,q2, conv, can_pre_calc);
end;
function CombineConvSyncQueueN3<TInp1,TInp2,TInp3, TRes>(conv: Func<TInp1, TInp2, TInp3, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3)) else
      HFQ(()->conv(inp1,inp2,inp3), need_own_thread);
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray3<TInp1,TInp2,TInp3, TRes, QueueArray3SyncInvoker, SimpleFunc3Container<TInp1, TInp2, TInp3, TRes>>(q1,q2,q3, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray3   <TInp1,TInp2,TInp3, TRes, QueueArray3SyncInvoker, SimpleFunc3Container<TInp1, TInp2, TInp3, TRes>>(q1,q2,q3, conv, can_pre_calc);
end;
function CombineConvSyncQueueN4<TInp1,TInp2,TInp3,TInp4, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3,inp4)) else
      HFQ(()->conv(inp1,inp2,inp3,inp4), need_own_thread);
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3,q4), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray4<TInp1,TInp2,TInp3,TInp4, TRes, QueueArray4SyncInvoker, SimpleFunc4Container<TInp1, TInp2, TInp3, TInp4, TRes>>(q1,q2,q3,q4, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray4   <TInp1,TInp2,TInp3,TInp4, TRes, QueueArray4SyncInvoker, SimpleFunc4Container<TInp1, TInp2, TInp3, TInp4, TRes>>(q1,q2,q3,q4, conv, can_pre_calc);
end;
function CombineConvSyncQueueN5<TInp1,TInp2,TInp3,TInp4,TInp5, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TInp5, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3,inp4,inp5)) else
      HFQ(()->conv(inp1,inp2,inp3,inp4,inp5), need_own_thread);
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray5<TInp1,TInp2,TInp3,TInp4,TInp5, TRes, QueueArray5SyncInvoker, SimpleFunc5Container<TInp1, TInp2, TInp3, TInp4, TInp5, TRes>>(q1,q2,q3,q4,q5, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray5   <TInp1,TInp2,TInp3,TInp4,TInp5, TRes, QueueArray5SyncInvoker, SimpleFunc5Container<TInp1, TInp2, TInp3, TInp4, TInp5, TRes>>(q1,q2,q3,q4,q5, conv, can_pre_calc);
end;
function CombineConvSyncQueueN6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty and q6.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    var inp6 := q6.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3,inp4,inp5,inp6)) else
      HFQ(()->conv(inp1,inp2,inp3,inp4,inp5,inp6), need_own_thread);
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5,q6), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, TRes, QueueArray6SyncInvoker, SimpleFunc6Container<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes>>(q1,q2,q3,q4,q5,q6, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray6   <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, TRes, QueueArray6SyncInvoker, SimpleFunc6Container<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes>>(q1,q2,q3,q4,q5,q6, conv, can_pre_calc);
end;
function CombineConvSyncQueueN7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty and q6.IsConstResDepEmpty and q7.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    var inp6 := q6.expected_const_res;
    var inp7 := q7.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3,inp4,inp5,inp6,inp7)) else
      HFQ(()->conv(inp1,inp2,inp3,inp4,inp5,inp6,inp7), need_own_thread);
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5,q6,q7), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TRes, QueueArray7SyncInvoker, SimpleFunc7Container<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, TRes>>(q1,q2,q3,q4,q5,q6,q7, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray7   <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TRes, QueueArray7SyncInvoker, SimpleFunc7Container<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, TRes>>(q1,q2,q3,q4,q5,q6,q7, conv, can_pre_calc);
end;

{$endregion NonContext}

{$region Context}

function CombineConvSyncQueue<TInp, TRes>(conv: Func<array of TInp, CLContext, TRes>; qs: array of CommandQueue<TInp>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if qs.All(q->q.IsConstResDepEmpty) then
  begin
    var inp := qs.ConvertAll(q->q.expected_const_res);
    Result := if can_pre_calc then
      CQ(conv(inp, nil)) else
      HFQ(c->conv(inp, c), need_own_thread);
    Result := CombineSyncQueue(qs, Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray<TInp, TRes, QueueArraySyncInvoker, SimpleFuncContainerC<array of TInp, TRes>>(qs.ToArray, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray   <TInp, TRes, QueueArraySyncInvoker, SimpleFuncContainerC<array of TInp, TRes>>(qs.ToArray, conv, can_pre_calc);
end;

function CombineConvSyncQueueN2<TInp1,TInp2, TRes>(conv: Func<TInp1, TInp2, CLContext, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2, nil)) else
      HFQ(c->conv(inp1,inp2, c), need_own_thread);
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray2<TInp1,TInp2, TRes, QueueArray2SyncInvoker, SimpleFunc2ContainerC<TInp1, TInp2, TRes>>(q1,q2, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray2   <TInp1,TInp2, TRes, QueueArray2SyncInvoker, SimpleFunc2ContainerC<TInp1, TInp2, TRes>>(q1,q2, conv, can_pre_calc);
end;
function CombineConvSyncQueueN3<TInp1,TInp2,TInp3, TRes>(conv: Func<TInp1, TInp2, TInp3, CLContext, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3, nil)) else
      HFQ(c->conv(inp1,inp2,inp3, c), need_own_thread);
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray3<TInp1,TInp2,TInp3, TRes, QueueArray3SyncInvoker, SimpleFunc3ContainerC<TInp1, TInp2, TInp3, TRes>>(q1,q2,q3, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray3   <TInp1,TInp2,TInp3, TRes, QueueArray3SyncInvoker, SimpleFunc3ContainerC<TInp1, TInp2, TInp3, TRes>>(q1,q2,q3, conv, can_pre_calc);
end;
function CombineConvSyncQueueN4<TInp1,TInp2,TInp3,TInp4, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, CLContext, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3,inp4, nil)) else
      HFQ(c->conv(inp1,inp2,inp3,inp4, c), need_own_thread);
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3,q4), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray4<TInp1,TInp2,TInp3,TInp4, TRes, QueueArray4SyncInvoker, SimpleFunc4ContainerC<TInp1, TInp2, TInp3, TInp4, TRes>>(q1,q2,q3,q4, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray4   <TInp1,TInp2,TInp3,TInp4, TRes, QueueArray4SyncInvoker, SimpleFunc4ContainerC<TInp1, TInp2, TInp3, TInp4, TRes>>(q1,q2,q3,q4, conv, can_pre_calc);
end;
function CombineConvSyncQueueN5<TInp1,TInp2,TInp3,TInp4,TInp5, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TInp5, CLContext, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3,inp4,inp5, nil)) else
      HFQ(c->conv(inp1,inp2,inp3,inp4,inp5, c), need_own_thread);
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray5<TInp1,TInp2,TInp3,TInp4,TInp5, TRes, QueueArray5SyncInvoker, SimpleFunc5ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TRes>>(q1,q2,q3,q4,q5, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray5   <TInp1,TInp2,TInp3,TInp4,TInp5, TRes, QueueArray5SyncInvoker, SimpleFunc5ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TRes>>(q1,q2,q3,q4,q5, conv, can_pre_calc);
end;
function CombineConvSyncQueueN6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, CLContext, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty and q6.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    var inp6 := q6.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3,inp4,inp5,inp6, nil)) else
      HFQ(c->conv(inp1,inp2,inp3,inp4,inp5,inp6, c), need_own_thread);
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5,q6), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, TRes, QueueArray6SyncInvoker, SimpleFunc6ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes>>(q1,q2,q3,q4,q5,q6, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray6   <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, TRes, QueueArray6SyncInvoker, SimpleFunc6ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes>>(q1,q2,q3,q4,q5,q6, conv, can_pre_calc);
end;
function CombineConvSyncQueueN7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, CLContext, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty and q6.IsConstResDepEmpty and q7.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    var inp6 := q6.expected_const_res;
    var inp7 := q7.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3,inp4,inp5,inp6,inp7, nil)) else
      HFQ(c->conv(inp1,inp2,inp3,inp4,inp5,inp6,inp7, c), need_own_thread);
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5,q6,q7), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TRes, QueueArray7SyncInvoker, SimpleFunc7ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, TRes>>(q1,q2,q3,q4,q5,q6,q7, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray7   <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TRes, QueueArray7SyncInvoker, SimpleFunc7ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, TRes>>(q1,q2,q3,q4,q5,q6,q7, conv, can_pre_calc);
end;

{$endregion Context}

{$endregion Conv}

{$region Use}

{$region NonContext}

function CombineUseSyncQueue<TInp>(use: Action<array of TInp>; qs: array of CommandQueue<TInp>; need_own_thread, can_pre_calc: boolean): CommandQueue<array of TInp>;
begin
  if qs.All(q->q.IsConstResDepEmpty) then
  begin
    var inp := qs.ConvertAll(q->q.expected_const_res);
    Result := CQ(inp);
    if can_pre_calc then
      use(inp) else
      Result := HPQ(()->use(inp), need_own_thread) + Result;
    Result := CombineSyncQueue(qs, Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray<TInp, QueueArraySyncInvoker, SimpleProcContainer<array of TInp>>(qs.ToArray, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray   <TInp, QueueArraySyncInvoker, SimpleProcContainer<array of TInp>>(qs.ToArray, use, can_pre_calc);
end;

function CombineUseSyncQueueN2<TInp1,TInp2>(use: Action<TInp1, TInp2>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2));
    if can_pre_calc then
      use(inp1,inp2) else
      Result := HPQ(()->use(inp1,inp2), need_own_thread) + Result;
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray2<TInp1,TInp2, QueueArray2SyncInvoker, SimpleProc2Container<TInp1, TInp2>>(q1,q2, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray2   <TInp1,TInp2, QueueArray2SyncInvoker, SimpleProc2Container<TInp1, TInp2>>(q1,q2, use, can_pre_calc);
end;
function CombineUseSyncQueueN3<TInp1,TInp2,TInp3>(use: Action<TInp1, TInp2, TInp3>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3));
    if can_pre_calc then
      use(inp1,inp2,inp3) else
      Result := HPQ(()->use(inp1,inp2,inp3), need_own_thread) + Result;
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray3<TInp1,TInp2,TInp3, QueueArray3SyncInvoker, SimpleProc3Container<TInp1, TInp2, TInp3>>(q1,q2,q3, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray3   <TInp1,TInp2,TInp3, QueueArray3SyncInvoker, SimpleProc3Container<TInp1, TInp2, TInp3>>(q1,q2,q3, use, can_pre_calc);
end;
function CombineUseSyncQueueN4<TInp1,TInp2,TInp3,TInp4>(use: Action<TInp1, TInp2, TInp3, TInp4>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3, inp4));
    if can_pre_calc then
      use(inp1,inp2,inp3,inp4) else
      Result := HPQ(()->use(inp1,inp2,inp3,inp4), need_own_thread) + Result;
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3,q4), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray4<TInp1,TInp2,TInp3,TInp4, QueueArray4SyncInvoker, SimpleProc4Container<TInp1, TInp2, TInp3, TInp4>>(q1,q2,q3,q4, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray4   <TInp1,TInp2,TInp3,TInp4, QueueArray4SyncInvoker, SimpleProc4Container<TInp1, TInp2, TInp3, TInp4>>(q1,q2,q3,q4, use, can_pre_calc);
end;
function CombineUseSyncQueueN5<TInp1,TInp2,TInp3,TInp4,TInp5>(use: Action<TInp1, TInp2, TInp3, TInp4, TInp5>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3, inp4, inp5));
    if can_pre_calc then
      use(inp1,inp2,inp3,inp4,inp5) else
      Result := HPQ(()->use(inp1,inp2,inp3,inp4,inp5), need_own_thread) + Result;
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray5<TInp1,TInp2,TInp3,TInp4,TInp5, QueueArray5SyncInvoker, SimpleProc5Container<TInp1, TInp2, TInp3, TInp4, TInp5>>(q1,q2,q3,q4,q5, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray5   <TInp1,TInp2,TInp3,TInp4,TInp5, QueueArray5SyncInvoker, SimpleProc5Container<TInp1, TInp2, TInp3, TInp4, TInp5>>(q1,q2,q3,q4,q5, use, can_pre_calc);
end;
function CombineUseSyncQueueN6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>(use: Action<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty and q6.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    var inp6 := q6.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3, inp4, inp5, inp6));
    if can_pre_calc then
      use(inp1,inp2,inp3,inp4,inp5,inp6) else
      Result := HPQ(()->use(inp1,inp2,inp3,inp4,inp5,inp6), need_own_thread) + Result;
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5,q6), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, QueueArray6SyncInvoker, SimpleProc6Container<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6>>(q1,q2,q3,q4,q5,q6, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray6   <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, QueueArray6SyncInvoker, SimpleProc6Container<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6>>(q1,q2,q3,q4,q5,q6, use, can_pre_calc);
end;
function CombineUseSyncQueueN7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>(use: Action<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty and q6.IsConstResDepEmpty and q7.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    var inp6 := q6.expected_const_res;
    var inp7 := q7.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3, inp4, inp5, inp6, inp7));
    if can_pre_calc then
      use(inp1,inp2,inp3,inp4,inp5,inp6,inp7) else
      Result := HPQ(()->use(inp1,inp2,inp3,inp4,inp5,inp6,inp7), need_own_thread) + Result;
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5,q6,q7), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, QueueArray7SyncInvoker, SimpleProc7Container<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7>>(q1,q2,q3,q4,q5,q6,q7, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray7   <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, QueueArray7SyncInvoker, SimpleProc7Container<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7>>(q1,q2,q3,q4,q5,q6,q7, use, can_pre_calc);
end;

{$endregion NonContext}

{$region Context}

function CombineUseSyncQueue<TInp>(use: Action<array of TInp, CLContext>; qs: array of CommandQueue<TInp>; need_own_thread, can_pre_calc: boolean): CommandQueue<array of TInp>;
begin
  if qs.All(q->q.IsConstResDepEmpty) then
  begin
    var inp := qs.ConvertAll(q->q.expected_const_res);
    Result := CQ(inp);
    if can_pre_calc then
      use(inp, nil) else
      Result := HPQ(c->use(inp, c), need_own_thread) + Result;
    Result := CombineSyncQueue(qs, Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray<TInp, QueueArraySyncInvoker, SimpleProcContainerC<array of TInp>>(qs.ToArray, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray   <TInp, QueueArraySyncInvoker, SimpleProcContainerC<array of TInp>>(qs.ToArray, use, can_pre_calc);
end;

function CombineUseSyncQueueN2<TInp1,TInp2>(use: Action<TInp1, TInp2, CLContext>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2));
    if can_pre_calc then
      use(inp1,inp2, nil) else
      Result := HPQ(c->use(inp1,inp2, c), need_own_thread) + Result;
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray2<TInp1,TInp2, QueueArray2SyncInvoker, SimpleProc2ContainerC<TInp1, TInp2>>(q1,q2, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray2   <TInp1,TInp2, QueueArray2SyncInvoker, SimpleProc2ContainerC<TInp1, TInp2>>(q1,q2, use, can_pre_calc);
end;
function CombineUseSyncQueueN3<TInp1,TInp2,TInp3>(use: Action<TInp1, TInp2, TInp3, CLContext>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3));
    if can_pre_calc then
      use(inp1,inp2,inp3, nil) else
      Result := HPQ(c->use(inp1,inp2,inp3, c), need_own_thread) + Result;
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray3<TInp1,TInp2,TInp3, QueueArray3SyncInvoker, SimpleProc3ContainerC<TInp1, TInp2, TInp3>>(q1,q2,q3, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray3   <TInp1,TInp2,TInp3, QueueArray3SyncInvoker, SimpleProc3ContainerC<TInp1, TInp2, TInp3>>(q1,q2,q3, use, can_pre_calc);
end;
function CombineUseSyncQueueN4<TInp1,TInp2,TInp3,TInp4>(use: Action<TInp1, TInp2, TInp3, TInp4, CLContext>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3, inp4));
    if can_pre_calc then
      use(inp1,inp2,inp3,inp4, nil) else
      Result := HPQ(c->use(inp1,inp2,inp3,inp4, c), need_own_thread) + Result;
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3,q4), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray4<TInp1,TInp2,TInp3,TInp4, QueueArray4SyncInvoker, SimpleProc4ContainerC<TInp1, TInp2, TInp3, TInp4>>(q1,q2,q3,q4, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray4   <TInp1,TInp2,TInp3,TInp4, QueueArray4SyncInvoker, SimpleProc4ContainerC<TInp1, TInp2, TInp3, TInp4>>(q1,q2,q3,q4, use, can_pre_calc);
end;
function CombineUseSyncQueueN5<TInp1,TInp2,TInp3,TInp4,TInp5>(use: Action<TInp1, TInp2, TInp3, TInp4, TInp5, CLContext>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3, inp4, inp5));
    if can_pre_calc then
      use(inp1,inp2,inp3,inp4,inp5, nil) else
      Result := HPQ(c->use(inp1,inp2,inp3,inp4,inp5, c), need_own_thread) + Result;
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray5<TInp1,TInp2,TInp3,TInp4,TInp5, QueueArray5SyncInvoker, SimpleProc5ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5>>(q1,q2,q3,q4,q5, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray5   <TInp1,TInp2,TInp3,TInp4,TInp5, QueueArray5SyncInvoker, SimpleProc5ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5>>(q1,q2,q3,q4,q5, use, can_pre_calc);
end;
function CombineUseSyncQueueN6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>(use: Action<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, CLContext>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty and q6.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    var inp6 := q6.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3, inp4, inp5, inp6));
    if can_pre_calc then
      use(inp1,inp2,inp3,inp4,inp5,inp6, nil) else
      Result := HPQ(c->use(inp1,inp2,inp3,inp4,inp5,inp6, c), need_own_thread) + Result;
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5,q6), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, QueueArray6SyncInvoker, SimpleProc6ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6>>(q1,q2,q3,q4,q5,q6, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray6   <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, QueueArray6SyncInvoker, SimpleProc6ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6>>(q1,q2,q3,q4,q5,q6, use, can_pre_calc);
end;
function CombineUseSyncQueueN7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>(use: Action<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, CLContext>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty and q6.IsConstResDepEmpty and q7.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    var inp6 := q6.expected_const_res;
    var inp7 := q7.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3, inp4, inp5, inp6, inp7));
    if can_pre_calc then
      use(inp1,inp2,inp3,inp4,inp5,inp6,inp7, nil) else
      Result := HPQ(c->use(inp1,inp2,inp3,inp4,inp5,inp6,inp7, c), need_own_thread) + Result;
    Result := CombineSyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5,q6,q7), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, QueueArray7SyncInvoker, SimpleProc7ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7>>(q1,q2,q3,q4,q5,q6,q7, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray7   <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, QueueArray7SyncInvoker, SimpleProc7ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7>>(q1,q2,q3,q4,q5,q6,q7, use, can_pre_calc);
end;

{$endregion Context}

{$endregion Use}

{$endregion Sync}

{$region Async}

{$region Simple}

function CombineAsyncQueue(params qs: array of CommandQueueBase) := QueueArrayUtils.ConstructAsync&<CommandQueueBase>(qs.Cast&<CommandQueueBase>);
function CombineAsyncQueue(params qs: array of CommandQueueNil) := QueueArrayUtils.ConstructAsync&<CommandQueueNil>(qs.Cast&<CommandQueueBase>);
function CombineAsyncQueue<T>(params qs: array of CommandQueue<T>) := QueueArrayUtils.ConstructAsync&<CommandQueue<T>>(qs.Cast&<CommandQueueBase>);

function CombineAsyncQueue<TQ>(qs: array of TQ; last: CommandQueueBase) := QueueArrayUtils.ConstructAsync&<CommandQueueBase>(qs.Cast&<CommandQueueBase>.Append&<CommandQueueBase>(last));
function CombineAsyncQueue<TQ>(qs: array of TQ; last: CommandQueueNil) := QueueArrayUtils.ConstructAsync&<CommandQueueNil>(qs.Cast&<CommandQueueBase>.Append&<CommandQueueBase>(last));
function CombineAsyncQueue<T, TQ>(qs: array of TQ; last: CommandQueue<T>) := QueueArrayUtils.ConstructAsync&<CommandQueue<T>>(qs.Cast&<CommandQueueBase>.Append&<CommandQueueBase>(last));

{$endregion Simple}

{$region Conv}

{$region NonContext}

function CombineConvAsyncQueue<TInp, TRes>(conv: Func<array of TInp, TRes>; qs: array of CommandQueue<TInp>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if qs.All(q->q.IsConstResDepEmpty) then
  begin
    var inp := qs.ConvertAll(q->q.expected_const_res);
    Result := if can_pre_calc then
      CQ(conv(inp)) else
      HFQ(()->conv(inp), need_own_thread);
    Result := CombineAsyncQueue(qs, Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray<TInp, TRes, QueueArrayAsyncInvoker, SimpleFuncContainer<array of TInp, TRes>>(qs.ToArray, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray   <TInp, TRes, QueueArrayAsyncInvoker, SimpleFuncContainer<array of TInp, TRes>>(qs.ToArray, conv, can_pre_calc);
end;

function CombineConvAsyncQueueN2<TInp1,TInp2, TRes>(conv: Func<TInp1, TInp2, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2)) else
      HFQ(()->conv(inp1,inp2), need_own_thread);
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray2<TInp1,TInp2, TRes, QueueArray2AsyncInvoker, SimpleFunc2Container<TInp1, TInp2, TRes>>(q1,q2, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray2   <TInp1,TInp2, TRes, QueueArray2AsyncInvoker, SimpleFunc2Container<TInp1, TInp2, TRes>>(q1,q2, conv, can_pre_calc);
end;
function CombineConvAsyncQueueN3<TInp1,TInp2,TInp3, TRes>(conv: Func<TInp1, TInp2, TInp3, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3)) else
      HFQ(()->conv(inp1,inp2,inp3), need_own_thread);
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray3<TInp1,TInp2,TInp3, TRes, QueueArray3AsyncInvoker, SimpleFunc3Container<TInp1, TInp2, TInp3, TRes>>(q1,q2,q3, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray3   <TInp1,TInp2,TInp3, TRes, QueueArray3AsyncInvoker, SimpleFunc3Container<TInp1, TInp2, TInp3, TRes>>(q1,q2,q3, conv, can_pre_calc);
end;
function CombineConvAsyncQueueN4<TInp1,TInp2,TInp3,TInp4, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3,inp4)) else
      HFQ(()->conv(inp1,inp2,inp3,inp4), need_own_thread);
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3,q4), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray4<TInp1,TInp2,TInp3,TInp4, TRes, QueueArray4AsyncInvoker, SimpleFunc4Container<TInp1, TInp2, TInp3, TInp4, TRes>>(q1,q2,q3,q4, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray4   <TInp1,TInp2,TInp3,TInp4, TRes, QueueArray4AsyncInvoker, SimpleFunc4Container<TInp1, TInp2, TInp3, TInp4, TRes>>(q1,q2,q3,q4, conv, can_pre_calc);
end;
function CombineConvAsyncQueueN5<TInp1,TInp2,TInp3,TInp4,TInp5, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TInp5, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3,inp4,inp5)) else
      HFQ(()->conv(inp1,inp2,inp3,inp4,inp5), need_own_thread);
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray5<TInp1,TInp2,TInp3,TInp4,TInp5, TRes, QueueArray5AsyncInvoker, SimpleFunc5Container<TInp1, TInp2, TInp3, TInp4, TInp5, TRes>>(q1,q2,q3,q4,q5, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray5   <TInp1,TInp2,TInp3,TInp4,TInp5, TRes, QueueArray5AsyncInvoker, SimpleFunc5Container<TInp1, TInp2, TInp3, TInp4, TInp5, TRes>>(q1,q2,q3,q4,q5, conv, can_pre_calc);
end;
function CombineConvAsyncQueueN6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty and q6.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    var inp6 := q6.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3,inp4,inp5,inp6)) else
      HFQ(()->conv(inp1,inp2,inp3,inp4,inp5,inp6), need_own_thread);
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5,q6), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, TRes, QueueArray6AsyncInvoker, SimpleFunc6Container<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes>>(q1,q2,q3,q4,q5,q6, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray6   <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, TRes, QueueArray6AsyncInvoker, SimpleFunc6Container<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes>>(q1,q2,q3,q4,q5,q6, conv, can_pre_calc);
end;
function CombineConvAsyncQueueN7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty and q6.IsConstResDepEmpty and q7.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    var inp6 := q6.expected_const_res;
    var inp7 := q7.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3,inp4,inp5,inp6,inp7)) else
      HFQ(()->conv(inp1,inp2,inp3,inp4,inp5,inp6,inp7), need_own_thread);
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5,q6,q7), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TRes, QueueArray7AsyncInvoker, SimpleFunc7Container<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, TRes>>(q1,q2,q3,q4,q5,q6,q7, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray7   <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TRes, QueueArray7AsyncInvoker, SimpleFunc7Container<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, TRes>>(q1,q2,q3,q4,q5,q6,q7, conv, can_pre_calc);
end;

{$endregion NonContext}

{$region Context}

function CombineConvAsyncQueue<TInp, TRes>(conv: Func<array of TInp, CLContext, TRes>; qs: array of CommandQueue<TInp>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if qs.All(q->q.IsConstResDepEmpty) then
  begin
    var inp := qs.ConvertAll(q->q.expected_const_res);
    Result := if can_pre_calc then
      CQ(conv(inp, nil)) else
      HFQ(c->conv(inp, c), need_own_thread);
    Result := CombineAsyncQueue(qs, Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray<TInp, TRes, QueueArrayAsyncInvoker, SimpleFuncContainerC<array of TInp, TRes>>(qs.ToArray, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray   <TInp, TRes, QueueArrayAsyncInvoker, SimpleFuncContainerC<array of TInp, TRes>>(qs.ToArray, conv, can_pre_calc);
end;

function CombineConvAsyncQueueN2<TInp1,TInp2, TRes>(conv: Func<TInp1, TInp2, CLContext, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2, nil)) else
      HFQ(c->conv(inp1,inp2, c), need_own_thread);
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray2<TInp1,TInp2, TRes, QueueArray2AsyncInvoker, SimpleFunc2ContainerC<TInp1, TInp2, TRes>>(q1,q2, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray2   <TInp1,TInp2, TRes, QueueArray2AsyncInvoker, SimpleFunc2ContainerC<TInp1, TInp2, TRes>>(q1,q2, conv, can_pre_calc);
end;
function CombineConvAsyncQueueN3<TInp1,TInp2,TInp3, TRes>(conv: Func<TInp1, TInp2, TInp3, CLContext, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3, nil)) else
      HFQ(c->conv(inp1,inp2,inp3, c), need_own_thread);
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray3<TInp1,TInp2,TInp3, TRes, QueueArray3AsyncInvoker, SimpleFunc3ContainerC<TInp1, TInp2, TInp3, TRes>>(q1,q2,q3, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray3   <TInp1,TInp2,TInp3, TRes, QueueArray3AsyncInvoker, SimpleFunc3ContainerC<TInp1, TInp2, TInp3, TRes>>(q1,q2,q3, conv, can_pre_calc);
end;
function CombineConvAsyncQueueN4<TInp1,TInp2,TInp3,TInp4, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, CLContext, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3,inp4, nil)) else
      HFQ(c->conv(inp1,inp2,inp3,inp4, c), need_own_thread);
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3,q4), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray4<TInp1,TInp2,TInp3,TInp4, TRes, QueueArray4AsyncInvoker, SimpleFunc4ContainerC<TInp1, TInp2, TInp3, TInp4, TRes>>(q1,q2,q3,q4, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray4   <TInp1,TInp2,TInp3,TInp4, TRes, QueueArray4AsyncInvoker, SimpleFunc4ContainerC<TInp1, TInp2, TInp3, TInp4, TRes>>(q1,q2,q3,q4, conv, can_pre_calc);
end;
function CombineConvAsyncQueueN5<TInp1,TInp2,TInp3,TInp4,TInp5, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TInp5, CLContext, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3,inp4,inp5, nil)) else
      HFQ(c->conv(inp1,inp2,inp3,inp4,inp5, c), need_own_thread);
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray5<TInp1,TInp2,TInp3,TInp4,TInp5, TRes, QueueArray5AsyncInvoker, SimpleFunc5ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TRes>>(q1,q2,q3,q4,q5, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray5   <TInp1,TInp2,TInp3,TInp4,TInp5, TRes, QueueArray5AsyncInvoker, SimpleFunc5ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TRes>>(q1,q2,q3,q4,q5, conv, can_pre_calc);
end;
function CombineConvAsyncQueueN6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, CLContext, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty and q6.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    var inp6 := q6.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3,inp4,inp5,inp6, nil)) else
      HFQ(c->conv(inp1,inp2,inp3,inp4,inp5,inp6, c), need_own_thread);
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5,q6), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, TRes, QueueArray6AsyncInvoker, SimpleFunc6ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes>>(q1,q2,q3,q4,q5,q6, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray6   <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, TRes, QueueArray6AsyncInvoker, SimpleFunc6ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes>>(q1,q2,q3,q4,q5,q6, conv, can_pre_calc);
end;
function CombineConvAsyncQueueN7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TRes>(conv: Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, CLContext, TRes>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; need_own_thread, can_pre_calc: boolean): CommandQueue<TRes>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty and q6.IsConstResDepEmpty and q7.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    var inp6 := q6.expected_const_res;
    var inp7 := q7.expected_const_res;
    Result := if can_pre_calc then
      CQ(conv(inp1,inp2,inp3,inp4,inp5,inp6,inp7, nil)) else
      HFQ(c->conv(inp1,inp2,inp3,inp4,inp5,inp6,inp7, c), need_own_thread);
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5,q6,q7), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueConvertThreadedArray7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TRes, QueueArray7AsyncInvoker, SimpleFunc7ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, TRes>>(q1,q2,q3,q4,q5,q6,q7, conv, can_pre_calc) else
    Result := new CommandQueueConvertQuickArray7   <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, TRes, QueueArray7AsyncInvoker, SimpleFunc7ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, TRes>>(q1,q2,q3,q4,q5,q6,q7, conv, can_pre_calc);
end;

{$endregion Context}

{$endregion Conv}

{$region Use}

{$region NonContext}

function CombineUseAsyncQueue<TInp>(use: Action<array of TInp>; qs: array of CommandQueue<TInp>; need_own_thread, can_pre_calc: boolean): CommandQueue<array of TInp>;
begin
  if qs.All(q->q.IsConstResDepEmpty) then
  begin
    var inp := qs.ConvertAll(q->q.expected_const_res);
    Result := CQ(inp);
    if can_pre_calc then
      use(inp) else
      Result := HPQ(()->use(inp), need_own_thread) + Result;
    Result := CombineAsyncQueue(qs, Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray<TInp, QueueArrayAsyncInvoker, SimpleProcContainer<array of TInp>>(qs.ToArray, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray   <TInp, QueueArrayAsyncInvoker, SimpleProcContainer<array of TInp>>(qs.ToArray, use, can_pre_calc);
end;

function CombineUseAsyncQueueN2<TInp1,TInp2>(use: Action<TInp1, TInp2>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2));
    if can_pre_calc then
      use(inp1,inp2) else
      Result := HPQ(()->use(inp1,inp2), need_own_thread) + Result;
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray2<TInp1,TInp2, QueueArray2AsyncInvoker, SimpleProc2Container<TInp1, TInp2>>(q1,q2, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray2   <TInp1,TInp2, QueueArray2AsyncInvoker, SimpleProc2Container<TInp1, TInp2>>(q1,q2, use, can_pre_calc);
end;
function CombineUseAsyncQueueN3<TInp1,TInp2,TInp3>(use: Action<TInp1, TInp2, TInp3>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3));
    if can_pre_calc then
      use(inp1,inp2,inp3) else
      Result := HPQ(()->use(inp1,inp2,inp3), need_own_thread) + Result;
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray3<TInp1,TInp2,TInp3, QueueArray3AsyncInvoker, SimpleProc3Container<TInp1, TInp2, TInp3>>(q1,q2,q3, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray3   <TInp1,TInp2,TInp3, QueueArray3AsyncInvoker, SimpleProc3Container<TInp1, TInp2, TInp3>>(q1,q2,q3, use, can_pre_calc);
end;
function CombineUseAsyncQueueN4<TInp1,TInp2,TInp3,TInp4>(use: Action<TInp1, TInp2, TInp3, TInp4>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3, inp4));
    if can_pre_calc then
      use(inp1,inp2,inp3,inp4) else
      Result := HPQ(()->use(inp1,inp2,inp3,inp4), need_own_thread) + Result;
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3,q4), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray4<TInp1,TInp2,TInp3,TInp4, QueueArray4AsyncInvoker, SimpleProc4Container<TInp1, TInp2, TInp3, TInp4>>(q1,q2,q3,q4, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray4   <TInp1,TInp2,TInp3,TInp4, QueueArray4AsyncInvoker, SimpleProc4Container<TInp1, TInp2, TInp3, TInp4>>(q1,q2,q3,q4, use, can_pre_calc);
end;
function CombineUseAsyncQueueN5<TInp1,TInp2,TInp3,TInp4,TInp5>(use: Action<TInp1, TInp2, TInp3, TInp4, TInp5>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3, inp4, inp5));
    if can_pre_calc then
      use(inp1,inp2,inp3,inp4,inp5) else
      Result := HPQ(()->use(inp1,inp2,inp3,inp4,inp5), need_own_thread) + Result;
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray5<TInp1,TInp2,TInp3,TInp4,TInp5, QueueArray5AsyncInvoker, SimpleProc5Container<TInp1, TInp2, TInp3, TInp4, TInp5>>(q1,q2,q3,q4,q5, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray5   <TInp1,TInp2,TInp3,TInp4,TInp5, QueueArray5AsyncInvoker, SimpleProc5Container<TInp1, TInp2, TInp3, TInp4, TInp5>>(q1,q2,q3,q4,q5, use, can_pre_calc);
end;
function CombineUseAsyncQueueN6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>(use: Action<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty and q6.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    var inp6 := q6.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3, inp4, inp5, inp6));
    if can_pre_calc then
      use(inp1,inp2,inp3,inp4,inp5,inp6) else
      Result := HPQ(()->use(inp1,inp2,inp3,inp4,inp5,inp6), need_own_thread) + Result;
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5,q6), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, QueueArray6AsyncInvoker, SimpleProc6Container<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6>>(q1,q2,q3,q4,q5,q6, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray6   <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, QueueArray6AsyncInvoker, SimpleProc6Container<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6>>(q1,q2,q3,q4,q5,q6, use, can_pre_calc);
end;
function CombineUseAsyncQueueN7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>(use: Action<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty and q6.IsConstResDepEmpty and q7.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    var inp6 := q6.expected_const_res;
    var inp7 := q7.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3, inp4, inp5, inp6, inp7));
    if can_pre_calc then
      use(inp1,inp2,inp3,inp4,inp5,inp6,inp7) else
      Result := HPQ(()->use(inp1,inp2,inp3,inp4,inp5,inp6,inp7), need_own_thread) + Result;
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5,q6,q7), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, QueueArray7AsyncInvoker, SimpleProc7Container<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7>>(q1,q2,q3,q4,q5,q6,q7, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray7   <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, QueueArray7AsyncInvoker, SimpleProc7Container<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7>>(q1,q2,q3,q4,q5,q6,q7, use, can_pre_calc);
end;

{$endregion NonContext}

{$region Context}

function CombineUseAsyncQueue<TInp>(use: Action<array of TInp, CLContext>; qs: array of CommandQueue<TInp>; need_own_thread, can_pre_calc: boolean): CommandQueue<array of TInp>;
begin
  if qs.All(q->q.IsConstResDepEmpty) then
  begin
    var inp := qs.ConvertAll(q->q.expected_const_res);
    Result := CQ(inp);
    if can_pre_calc then
      use(inp, nil) else
      Result := HPQ(c->use(inp, c), need_own_thread) + Result;
    Result := CombineAsyncQueue(qs, Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray<TInp, QueueArrayAsyncInvoker, SimpleProcContainerC<array of TInp>>(qs.ToArray, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray   <TInp, QueueArrayAsyncInvoker, SimpleProcContainerC<array of TInp>>(qs.ToArray, use, can_pre_calc);
end;

function CombineUseAsyncQueueN2<TInp1,TInp2>(use: Action<TInp1, TInp2, CLContext>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2));
    if can_pre_calc then
      use(inp1,inp2, nil) else
      Result := HPQ(c->use(inp1,inp2, c), need_own_thread) + Result;
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray2<TInp1,TInp2, QueueArray2AsyncInvoker, SimpleProc2ContainerC<TInp1, TInp2>>(q1,q2, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray2   <TInp1,TInp2, QueueArray2AsyncInvoker, SimpleProc2ContainerC<TInp1, TInp2>>(q1,q2, use, can_pre_calc);
end;
function CombineUseAsyncQueueN3<TInp1,TInp2,TInp3>(use: Action<TInp1, TInp2, TInp3, CLContext>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3));
    if can_pre_calc then
      use(inp1,inp2,inp3, nil) else
      Result := HPQ(c->use(inp1,inp2,inp3, c), need_own_thread) + Result;
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray3<TInp1,TInp2,TInp3, QueueArray3AsyncInvoker, SimpleProc3ContainerC<TInp1, TInp2, TInp3>>(q1,q2,q3, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray3   <TInp1,TInp2,TInp3, QueueArray3AsyncInvoker, SimpleProc3ContainerC<TInp1, TInp2, TInp3>>(q1,q2,q3, use, can_pre_calc);
end;
function CombineUseAsyncQueueN4<TInp1,TInp2,TInp3,TInp4>(use: Action<TInp1, TInp2, TInp3, TInp4, CLContext>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3, inp4));
    if can_pre_calc then
      use(inp1,inp2,inp3,inp4, nil) else
      Result := HPQ(c->use(inp1,inp2,inp3,inp4, c), need_own_thread) + Result;
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3,q4), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray4<TInp1,TInp2,TInp3,TInp4, QueueArray4AsyncInvoker, SimpleProc4ContainerC<TInp1, TInp2, TInp3, TInp4>>(q1,q2,q3,q4, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray4   <TInp1,TInp2,TInp3,TInp4, QueueArray4AsyncInvoker, SimpleProc4ContainerC<TInp1, TInp2, TInp3, TInp4>>(q1,q2,q3,q4, use, can_pre_calc);
end;
function CombineUseAsyncQueueN5<TInp1,TInp2,TInp3,TInp4,TInp5>(use: Action<TInp1, TInp2, TInp3, TInp4, TInp5, CLContext>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3, inp4, inp5));
    if can_pre_calc then
      use(inp1,inp2,inp3,inp4,inp5, nil) else
      Result := HPQ(c->use(inp1,inp2,inp3,inp4,inp5, c), need_own_thread) + Result;
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray5<TInp1,TInp2,TInp3,TInp4,TInp5, QueueArray5AsyncInvoker, SimpleProc5ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5>>(q1,q2,q3,q4,q5, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray5   <TInp1,TInp2,TInp3,TInp4,TInp5, QueueArray5AsyncInvoker, SimpleProc5ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5>>(q1,q2,q3,q4,q5, use, can_pre_calc);
end;
function CombineUseAsyncQueueN6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>(use: Action<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, CLContext>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty and q6.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    var inp6 := q6.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3, inp4, inp5, inp6));
    if can_pre_calc then
      use(inp1,inp2,inp3,inp4,inp5,inp6, nil) else
      Result := HPQ(c->use(inp1,inp2,inp3,inp4,inp5,inp6, c), need_own_thread) + Result;
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5,q6), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray6<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, QueueArray6AsyncInvoker, SimpleProc6ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6>>(q1,q2,q3,q4,q5,q6, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray6   <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6, QueueArray6AsyncInvoker, SimpleProc6ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6>>(q1,q2,q3,q4,q5,q6, use, can_pre_calc);
end;
function CombineUseAsyncQueueN7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>(use: Action<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, CLContext>; q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; q7: CommandQueue<TInp7>; need_own_thread, can_pre_calc: boolean): CommandQueue<ValueTuple<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7>>;
begin
  if q1.IsConstResDepEmpty and q2.IsConstResDepEmpty and q3.IsConstResDepEmpty and q4.IsConstResDepEmpty and q5.IsConstResDepEmpty and q6.IsConstResDepEmpty and q7.IsConstResDepEmpty then
  begin
    var inp1 := q1.expected_const_res;
    var inp2 := q2.expected_const_res;
    var inp3 := q3.expected_const_res;
    var inp4 := q4.expected_const_res;
    var inp5 := q5.expected_const_res;
    var inp6 := q6.expected_const_res;
    var inp7 := q7.expected_const_res;
    Result := CQ(ValueTuple.Create(inp1, inp2, inp3, inp4, inp5, inp6, inp7));
    if can_pre_calc then
      use(inp1,inp2,inp3,inp4,inp5,inp6,inp7, nil) else
      Result := HPQ(c->use(inp1,inp2,inp3,inp4,inp5,inp6,inp7, c), need_own_thread) + Result;
    Result := CombineAsyncQueue(new CommandQueueBase[](q1,q2,q3,q4,q5,q6,q7), Result);
  end else
  if need_own_thread then
    Result := new CommandQueueUseThreadedArray7<TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, QueueArray7AsyncInvoker, SimpleProc7ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7>>(q1,q2,q3,q4,q5,q6,q7, use, can_pre_calc) else
    Result := new CommandQueueUseQuickArray7   <TInp1,TInp2,TInp3,TInp4,TInp5,TInp6,TInp7, QueueArray7AsyncInvoker, SimpleProc7ContainerC<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7>>(q1,q2,q3,q4,q5,q6,q7, use, can_pre_calc);
end;

{$endregion Context}

{$endregion Use}

{$endregion Async}

{$endregion CombineQueue's}

{$region GLIterop}

{$region Common} type
  
  GLIteropApiBlock = record
    public clGLSharingKHR: OpenCL.clGLSharingKHR;
  end;
  
  GLIterop = static class
    
    private [ThreadStatic] static api_block_cache := new Dictionary<CLPlatform, GLIteropApiBlock>;
    public static function ApiBlockForPlatform(pl: CLPlatform): GLIteropApiBlock;
    begin
      if api_block_cache.TryGetValue(pl, Result) then exit;
      Result.clGLSharingKHR := new OpenCL.clGLSharingKHR(pl.ntv);
      api_block_cache.Add(pl, Result);
    end;
    
  end;
  
  CommandQueueAcquireRelease = abstract class(CommandQueueNil)
    private mem_objs: array of ICLMemory;
    private ntv_mem_objs: array of cl_mem;
    private api_block: clGLSharingKHR;
    
    public constructor(mem_objs: array of ICLMemory);
    begin
      self.mem_objs := mem_objs;
      self.ntv_mem_objs := mem_objs.ConvertAll(m->m.Native);
      if mem_objs.Length=0 then
        raise new ArgumentException($'%Err:GLIterop:0MemObjects%');
      
      var ntv_contexts := ntv_mem_objs.Select(m->
      begin
        Result := default(cl_context);
        OpenCLABCInternalException.RaiseIfError(
          cl.GetMemObjectInfo_MEM_CONTEXT(m, Result)
        );
      end).Distinct.ToArray;
      if ntv_contexts.Length>1 then
        raise new ArgumentException($'%Err:GLIterop:MultipleContexts%');
      
      self.api_block := GLIterop.ApiBlockForPlatform(CLContext.Create(ntv_contexts[0], true).MainDevice.BaseCLPlatform).clGLSharingKHR;
    end;
    private constructor := raise new OpenCLABCInternalException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_mu: HashSet<IMultiusableCommandQueue>); override := exit;
    
    protected procedure InvokeImpl(clGLSharingKHR: OpenCL.clGLSharingKHR; q: cl_command_queue; a: array of cl_mem; prev_ev: EventList; var res_ev: cl_event); abstract;
    protected function InvokeToNil(g: CLTaskGlobalData; l: CLTaskLocalData): QueueResNil; override;
    begin
      var prev_ev := l.AttachInvokeActions(g{$ifdef EventDebug}, l{$endif});
      var res_ev: cl_event;
      InvokeImpl(api_block, g.GetCQ(false), ntv_mem_objs, prev_ev, res_ev);
	  //TODO Проверить и сделать всё релевантное из EnqueueableCore
	  // - В частности что если enq_ev=0 из за предыдущих ошибок? Может ли тут NV тоже отказываться давать ивент?
	  // - И сделать issue в OpenCL-Docs об этом, типа кто прав (или оба?)
      {$ifdef EventDebug}
      EventDebug.RegisterEventRetain(res_ev, $'Enq by {TypeName(self)}, waiting on: {prev_ev.evs?.Take(prev_ev.count).JoinToString}');
      {$endif EventDebug}
      Result := new QueueResNil(prev_ev + res_ev);
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += ':';
      foreach var m in mem_objs do
      begin
        sb += ' ';
        sb += m.ToString;
      end;
      sb += #10;
    end;
    
  end;
  
{$endregion Common}

{$region Acquire} type
  
  CommandQueueAcquire = sealed class(CommandQueueAcquireRelease)
    
    protected procedure InvokeImpl(clGLSharingKHR: OpenCL.clGLSharingKHR; q: cl_command_queue; a: array of cl_mem; prev_ev: EventList; var res_ev: cl_event); override :=
      OpenCLABCInternalException.RaiseIfError(clGLSharingKHR.EnqueueAcquireGLObjects(q, a.Length,a, prev_ev.count,prev_ev.evs, res_ev));
    
  end;
  
function CQAcquireGL(params mem_objs: array of ICLMemory) := new CommandQueueAcquire(mem_objs);

{$endregion Acquire}

{$region Release} type
  
  CommandQueueRelease = sealed class(CommandQueueAcquireRelease)
    
    protected procedure InvokeImpl(clGLSharingKHR: OpenCL.clGLSharingKHR; q: cl_command_queue; a: array of cl_mem; prev_ev: EventList; var res_ev: cl_event); override :=
      OpenCLABCInternalException.RaiseIfError(clGLSharingKHR.EnqueueReleaseGLObjects(q, a.Length,a, prev_ev.count,prev_ev.evs, res_ev));
    
  end;
  
function CQReleaseGL(params mem_objs: array of ICLMemory) := new CommandQueueRelease(mem_objs);

{$endregion Release}

{$endregion GLIterop}

{$endregion Global subprograms}

{$region Wrappers}

{$region CLDevice}

static function CLDevice.FromNative(ntv: cl_device_id): CLDevice;
begin
  
  var parent: cl_device_id;
  OpenCLABCInternalException.RaiseIfError(
    cl.GetDeviceInfo_DEVICE_PARENT_DEVICE(ntv, parent, false)
  );
  
  if parent=cl_device_id.Zero then
    Result := new CLDevice(ntv) else
    Result := new CLSubDevice(parent, ntv);
  
end;

{$endregion CLDevice}

{$region CLContext}

type
  CLContextTestData = static class
    
    private const test_prog = 'kernel void k(global int* v) { v[get_global_id(0)]++; }';
    
    public static function MakeTestQueue(test_size: integer): CommandQueue<boolean>;
    begin
      // Без кеширования, чтобы у всех
      // запусков .TestSanity были равные условия
      // что касается внутренних оптимизаций очереди
      var rng := new Random;
      var test_arr := ArrGen(test_size, i->rng.Next);
      var Q_Arr := HFQ(c->new CLArray<integer>(c, test_size), false).Multiusable;
      Result :=
        HFQ(c->CLProgramCode.Create(test_prog, c)['k'], false).MakeCCQ
          .ThenExec1(test_size, Q_Arr.MakeCCQ
            .ThenWriteArray(test_arr)
          ) +
        Q_Arr.MakeCCQ
          .ThenGetArray
          .ThenConvert(test_res->
            test_res.Zip(test_arr, (a,b)->a=b+1).All(r->r), false
          );
      Result := Result.Multiusable;
      Result := Result+Q_Arr.ThenUse(a->a.Dispose(), false)+Result;
    end;
    
  end;
  
function CLContext.TestSanity(test_size: integer): TimeSpan?;
begin
  var Q := CLContextTestData.MakeTestQueue(test_size);
  var sw := Stopwatch.StartNew;
  
  Result := nil;
  if not self.SyncInvoke(Q) then exit;
  
  Result := sw.Elapsed;
end;

static function CLContext.GenerateAndCheckAllPossible(test_size: integer; test_max_seconds: real): List<ValueTuple<CLContext,TimeSpan>>;
begin
  var test_max_time := TimeSpan.FromSeconds(test_max_seconds);
  Result := new List<ValueTuple<CLContext, TimeSpan>>;
  
  foreach var pl in CLPlatform.All do
  begin
    var dvcs := CLDevice.GetAllFor(pl, clDeviceType.DEVICE_TYPE_ALL).ToList;
    
    var keep := new boolean[dvcs.Count];
    var thrs := ArrGen(dvcs.Count, i->new Thread(()->
    begin
      keep[i] := nil <> CLContext.Create(dvcs[i]).TestSanity(test_size)
    end));
    foreach var thr in thrs do thr.IsBackground := true;
    foreach var thr in thrs do thr.Start;
    Thread.Sleep(test_max_time);
    foreach var thr in thrs do thr.Abort;
    
    for var i := 0 to dvcs.Count-1 do
      if not keep[i] then dvcs[i] := nil;
    dvcs.RemoveAll(d->d=nil);
    if dvcs.Count=0 then continue;
    
    var chosen := new List<CLDevice>(dvcs.Count);
    foreach var choise in |true,false|.CartesianPower(dvcs.Count) do
    begin
      chosen.Clear;
      for var i := 0 to dvcs.Count-1 do
        if choise[i] then chosen += dvcs[i];
      if chosen.Count=0 then continue;
      
      var c := new CLContext(chosen, chosen[0]);
      var time := c.TestSanity(test_size);
      if time=nil then continue;
      
      Result.Add(ValueTuple.Create(c, time.Value));
    end;
    
  end;
  
end;

static function CLContext.LoadTestContext: CLContext;
begin
  Result := nil;
  
  var fname :=
    SeqWhile(GetCurrentDir, System.IO.Path.GetDirectoryName, dir->dir<>nil)
    .Select(dir->System.IO.Path.Combine(dir, 'TestContext.dat'))
    .FirstOrDefault(FileExists);
  if fname=nil then
  begin
    $'Pregenerated context not found'.Println;
    exit;
  end;
  
  var br := new System.IO.BinaryReader(System.IO.File.OpenRead(fname));
  try
    var pl_name := br.ReadString;
    
    var pl := CLPlatform.All.SingleOrDefault(pl->pl.Properties.Name=pl_name);
    if pl=nil then
    begin
      var all_pl_names := CLPlatform.All.Select(pl->$'['+pl.Properties.Name+$']').JoinToString(', ');
      raise new InvalidOperationException($'No platform with name [{pl_name}], only: {all_pl_names}');
    end;
    var dvcs := CLDevice.GetAllFor(pl, clDeviceType.DEVICE_TYPE_ALL).ToDictionary(dvc->dvc.Properties.Name);
    Result := new CLContext(ArrGen(br.ReadInt32, i->
    begin
      Result := default(CLDevice);
      var dvc_name := br.ReadString;
      if dvcs.TryGetValue(dvc_name, Result) then exit;
      var all_dvc_names := dvcs.Keys.Select(key->$'[{key}]').JoinToString(', ');
      raise new InvalidOperationException($'No device with name [{dvc_name}], only: {all_dvc_names}');
    end));
    
  finally
    br.Close;
  end;
  
end;

{$endregion CLContext}

{$region CLProgramCompOptions}

procedure CLProgramCompOptions.LowerVersionToSupported;
begin
  var max_v := Version;
  
  foreach var d in BuildContext.AllDevices do
  begin
    var v_str := d.Properties.OpenclCVersion;
    var v_str_beg := 'OpenCL C ';
    if not v_str.StartsWith(v_str_beg) then raise new System.NotSupportedException;
    var v_spl := v_str.Substring(v_str_beg.Length).Split(|'.'|, 2);
    var v := (v_spl[0].ToInteger, v_spl[1].ToInteger);
    if max_v<>nil then
      case Sign(v[0]-max_v[0]) of
        1: continue;
        0:
        case Sign(v[1]-max_v[1]) of
          1: continue;
          0: ;
        end;
      end;
    max_v := v; // if max_v=nil or v<=max_v
  end;
  
  Version := max_v;
end;

{$endregion CLProgramCompOptions}

{$region CLKernel}

type
  CLKernelNtvList = record
    private const resize_limit_up = 1/sqrt(2);
    private const resize_limit_down = resize_limit_up/2;
    private const min_size_down = 16;
    
    private ntvs_lock := new object;
    private ntvs: array of record
      k: cl_kernel;
      used: boolean;
    end;
    private ntvs_used := 0;
    private unused_search_shift := 0;
    
    public constructor :=
    SetLength(ntvs, 1);
    
    private function MakeMask: integer;
    begin
      Result := ntvs.Length-1;
      {$ifdef DEBUG}
      if (Result and ntvs.Length) <> 0 then raise new OpenCLABCInternalException($'ntvs.Length was {ntvs.Length}, which is not a power of 2');
      {$endif DEBUG}
    end;
    
    private procedure AddExisting(k: cl_kernel; used: boolean; mask: integer);
    begin
      var search_shift := k.val.GetHashCode;
      for var i := 0 to mask do
      begin
        var ind := (i+search_shift) and mask;
        if ntvs[ind].k=cl_kernel.Zero then
        begin
          ntvs[ind].k := k;
          ntvs[ind].used := used;
          ntvs_used += Ord(used);
          exit;
        end;
      end;
      raise new OpenCLABCInternalException($'No space to add, {ntvs_used}/{ntvs.Length} filled');
    end;
    public procedure AddExisting(k: cl_kernel) :=
    lock ntvs_lock do
    begin
      TryResizeUp;
      AddExisting(k, false, MakeMask);
    end;
    
    private static procedure SetSz<T>(var a: array of T; sz: integer) := a := new T[sz];
    private procedure ResizeKeepingUsed(sz: integer);
    begin
      var prev_ntvs := ntvs;
      SetSz(self.ntvs, sz);
      self.ntvs_used := 0;
      self.unused_search_shift := 0;
      
      var mask := MakeMask;
      var added := 0;
      
      foreach var info in prev_ntvs do
        if info.used then
        begin
          AddExisting(info.k, true, mask);
          added += 1;
        end else
        if info.k<>cl_kernel.Zero then
          OpenCLABCInternalException.RaiseIfError(
            cl.ReleaseKernel(info.k)
          );
      
    end;
    private procedure TryResizeUp :=
    if ntvs_used > ntvs.Length*resize_limit_up then
      ResizeKeepingUsed(ntvs.Length shl 1);
    private procedure TryResizeDown :=
    if ntvs_used < ntvs.Length*resize_limit_down then
      ResizeKeepingUsed(ntvs.Length shr 1);
    
    public [MethodImpl(MethodImplOptions.AggressiveInlining)]
    function TakeOrMake(make_new: ()->cl_kernel): cl_kernel;
    begin
      lock ntvs_lock do
      begin
        TryResizeUp;
        var mask := MakeMask;
        var search_shift := self.unused_search_shift;
        for var i := 0 to mask do
        begin
          var ind := (i+search_shift) and mask;
          if ntvs[ind].k=cl_kernel.Zero then
          begin
            Result := make_new;
            ntvs[ind].k := Result;
          end else
          if not ntvs[ind].used then
            Result := ntvs[ind].k else
            continue;
          ntvs[ind].used := true;
          ntvs_used += 1;
          self.unused_search_shift := ind;
          exit;
        end;
        raise new OpenCLABCInternalException($'No unused or empty found, {ntvs_used}/{ntvs.Length} filled');
      end;
    end;
    
    public procedure Return(k: cl_kernel) :=
    lock ntvs_lock do
    begin
      var mask := MakeMask;
      var search_shift := k.val.GetHashCode;
      for var i := 0 to mask do
      begin
        var ind := (i+search_shift) and mask;
        if ntvs[ind].k=k then
        begin
          {$ifdef DEBUG}
          if not ntvs[ind].used then raise new OpenCLABCInternalException($'Return of not taken ntv');
          {$endif DEBUG}
          ntvs[ind].used := false;
          ntvs_used -= 1;
          if ntvs.Length > min_size_down then
            TryResizeDown;
          exit;
        end;
      end;
      raise new OpenCLABCInternalException($'Return of unknown ntv');
    end;
    
  end;
  
  CLKernel = partial class
    
    private ntvs := new CLKernelNtvList;
    
    protected procedure Finalize; override :=
    ntvs.ResizeKeepingUsed(ntvs.ntvs.Length);
    
  end;
  
function CLKernel.AllocNative :=
ntvs.TakeOrMake(()->
begin
  var ec: clErrorCode;
  Result := cl.CreateKernel(code.ntv, k_name, ec);
  OpenCLABCInternalException.RaiseIfError(ec);
end);

procedure CLKernel.ReleaseNative(ntv: cl_kernel) := ntvs.Return(ntv);

procedure CLKernel.AddExistingNative(ntv: cl_kernel) := ntvs.AddExisting(ntv);

{$endregion CLKernel}

{$region CLMemory}

static function CLMemory.FromNative(ntv: cl_mem; memory_report, need_retain: boolean): CLMemory;
begin
  var t: clMemObjectType;
  OpenCLABCInternalException.RaiseIfError(
    cl.GetMemObjectInfo_MEM_TYPE(ntv, t, false)
  );
  
  if t<>clMemObjectType.MEM_OBJECT_BUFFER then
    raise new ArgumentException($'Неправильный тип неуправляемого объекта памяти. Ожидалось [MEM_OBJECT_BUFFER], а не [{t}]');
  
  var parent: cl_mem;
  OpenCLABCInternalException.RaiseIfError(
    cl.GetMemObjectInfo_MEM_ASSOCIATED_MEMOBJECT(ntv, parent, false)
  );
  
  if parent=cl_mem.Zero then
    Result := new CLMemory(ntv, memory_report, need_retain) else
    Result := new CLMemorySubSegment(parent, ntv, memory_report, need_retain);
  
end;

{$endregion CLMemory}

{$region CLArray}

function CLArray<T>.GetItemProp(ind: integer): T :=
GetValue(ind);
procedure CLArray<T>.SetItemProp(ind: integer; value: T) :=
WriteValue(value, ind);

function CLArray<T>.GetSliceProp(range: IntRange): array of T;
begin
  Result := new T[range.High-range.Low+1];
  ReadArray(Result, 0,Result.Length, range.Low);
end;
procedure CLArray<T>.SetSliceProp(range: IntRange; value: array of T) :=
WriteArray(value, range.Low, range.High-range.Low+1, 0);

{$endregion CLArray}

{$endregion Wrappers}

{$ifdef ForceMaxDebug}
type
  FinalDebugChecks = static class
    private static checked := false;
    public static procedure Check;
    begin
      if checked then exit;
      checked := true;
      
      {$ifdef EventDebug}
      EventDebug.FinallyReport;
      {$endif EventDebug}
      
      {$ifdef QueueDebug}
      QueueDebug.FinallyReport;
      {$endif QueueDebug}
      
      {$ifdef WaitDebug}
      foreach var whd: WaitHandlerDirect in WaitDebug.WaitActions.Keys.OfType&<WaitHandlerDirect> do
        if whd.reserved<>0 then
          raise new OpenCLABCInternalException($'WaitHandler.reserved in finalization was <>0');
      WaitDebug.FinallyReport;
      {$endif WaitDebug}
      
      {$ifdef ExecDebug}
      ExecDebug.FinallyReport;
      {$endif ExecDebug}
      
      if QueueResNil.created_count<>0 then
        gen_debug_otp.WriteLine($'[QueueResNil]: {QueueResNil.created_count}');
      if QueueResT.created_count.Count<>0 then
      begin
        gen_debug_otp.WriteLine($'[QueueRes<T>]: {QueueResT.created_count.Values.Sum}');
        foreach var t in QueueResT.created_count.Keys.Order do
          gen_debug_otp.WriteLine($'{#9}{t}: {QueueResT.created_count[t]}');
      end;
      
      begin
        var obs := CLMemoryObserver.Current as TrackingMemoryObserver;
        if obs=nil then obs := EmptyMemoryObserver(CLMemoryObserver.Current).impl;
        var left_mem_objs := obs.mem_uses.Keys;
        if left_mem_objs.Any then
          raise new OpenCLABCInternalException($'Not all memory objects were disposed: ' + left_mem_objs.JoinToString);
      end;
      
      gen_debug_otp.Close;
      eh_debug_otp.Close;
    end;
  end;
  
initialization
finalization
  FinalDebugChecks.Check;
{$endif ForceMaxDebug}
end.